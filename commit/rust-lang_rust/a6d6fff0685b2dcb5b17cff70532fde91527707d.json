{"sha": "a6d6fff0685b2dcb5b17cff70532fde91527707d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZDZmZmYwNjg1YjJkY2I1YjE3Y2ZmNzA1MzJmZGU5MTUyNzcwN2Q=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-02T16:43:19Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-13T13:37:09Z"}, "message": "Lookup node type in map rather than using write_ty_expr", "tree": {"sha": "bc7e4cd7745ab6d4b4a6b1da62e0f9356b82518b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc7e4cd7745ab6d4b4a6b1da62e0f9356b82518b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6d6fff0685b2dcb5b17cff70532fde91527707d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d6fff0685b2dcb5b17cff70532fde91527707d", "html_url": "https://github.com/rust-lang/rust/commit/a6d6fff0685b2dcb5b17cff70532fde91527707d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6d6fff0685b2dcb5b17cff70532fde91527707d/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36393416850acf560554411a04b0098fcf3debd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/36393416850acf560554411a04b0098fcf3debd9", "html_url": "https://github.com/rust-lang/rust/commit/36393416850acf560554411a04b0098fcf3debd9"}], "stats": {"total": 75, "additions": 37, "deletions": 38}, "files": [{"sha": "04f22b195110f59b6bb7306695bc77808b98c8ab", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a6d6fff0685b2dcb5b17cff70532fde91527707d", "patch": "@@ -473,7 +473,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n-        self.write_ty_expr(expr.id, result_ty);\n+        self.write_ty(expr.id, result_ty);\n     }\n }\n \n@@ -550,7 +550,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let scheme = tcx.lookup_item_type(def.def_id());\n         let predicates = tcx.lookup_predicates(def.def_id());\n         let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id, false);\n+                                                 opt_ty, def, pat.span, pat.id);\n         self.demand_suptype(pat.span, expected, pat_ty);\n     }\n \n@@ -618,7 +618,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n         let predicates = tcx.lookup_predicates(def.def_id());\n         let pat_ty = self.instantiate_value_path(segments, scheme, &predicates,\n-                                                 opt_ty, def, pat.span, pat.id, false);\n+                                                 opt_ty, def, pat.span, pat.id);\n         self.demand_eqtype(pat.span, expected, pat_ty);\n \n         // Type check subpatterns."}, {"sha": "a3e03e72cdd1f0fde2a65d2b75357fa1b4b15f03", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a6d6fff0685b2dcb5b17cff70532fde91527707d", "patch": "@@ -1551,13 +1551,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n-    }\n \n-    #[inline]\n-    pub fn write_ty_expr(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n-        self.write_ty(node_id, ty);\n+        // Add adjustments to !-expressions\n         if ty.is_never() {\n-            self.write_adjustment(node_id, adjustment::AdjustNeverToAny(self.next_diverging_ty_var()));\n+            if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(node_id) {\n+                let adj = adjustment::AdjustNeverToAny(self.next_diverging_ty_var());\n+                self.write_adjustment(node_id, adj);\n+            }\n         }\n     }\n \n@@ -1733,7 +1733,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn write_never(&self, node_id: ast::NodeId) {\n-        self.write_ty_expr(node_id, self.tcx.types.never);\n+        self.write_ty(node_id, self.tcx.types.never);\n     }\n \n     pub fn write_error(&self, node_id: ast::NodeId) {\n@@ -1977,7 +1977,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             if self.type_var_diverges(resolved) {\n                 debug!(\"default_type_parameters: defaulting `{:?}` to `!` because it diverges\",\n                        resolved);\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_diverging_default());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                   self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n@@ -2051,7 +2052,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for ty in &unsolved_variables {\n                 let resolved = self.resolve_type_vars_if_possible(ty);\n                 if self.type_var_diverges(resolved) {\n-                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_diverging_default());\n+                    self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                       self.tcx.mk_diverging_default());\n                 } else {\n                     match self.type_is_unconstrained_numeric(resolved) {\n                         UnconstrainedInt | UnconstrainedFloat => {\n@@ -2109,7 +2111,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n                 for ty in &unbound_tyvars {\n                     if self.type_var_diverges(ty) {\n-                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_diverging_default());\n+                        self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                           self.tcx.mk_diverging_default());\n                     } else {\n                         match self.type_is_unconstrained_numeric(ty) {\n                             UnconstrainedInt => {\n@@ -2205,7 +2208,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // reporting for more then one conflict.\n         for ty in &unbound_tyvars {\n             if self.type_var_diverges(ty) {\n-                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty, self.tcx.mk_diverging_default());\n+                self.demand_eqtype(syntax_pos::DUMMY_SP, *ty,\n+                                   self.tcx.mk_diverging_default());\n             } else {\n                 match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n@@ -2682,7 +2686,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn write_call(&self,\n                   call_expr: &hir::Expr,\n                   output: Ty<'tcx>) {\n-        self.write_ty_expr(call_expr.id, output);\n+        self.write_ty(call_expr.id, output);\n     }\n \n     // AST fragment checking\n@@ -2915,7 +2919,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // the type of the block, because old trans still uses it.\n                 let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n                 if res.is_ok() && adj.is_some() {\n-                    self.write_ty_expr(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n+                    self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n                 }\n \n                 res\n@@ -2956,7 +2960,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty_expr(id, if_ty);\n+        self.write_ty(id, if_ty);\n     }\n \n     // Check field access expressions\n@@ -2977,7 +2981,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let field_ty = self.field_ty(expr.span, field, substs);\n                     if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                         autoderef.finalize(lvalue_pref, Some(base));\n-                        self.write_ty_expr(expr.id, field_ty);\n+                        self.write_ty(expr.id, field_ty);\n                         self.write_autoderef_adjustment(base.id, autoderefs);\n                         return;\n                     }\n@@ -2989,7 +2993,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            self.write_ty_expr(expr.id, field_ty);\n+            self.write_ty(expr.id, field_ty);\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             let mut err = self.tcx().sess.struct_span_err(expr.span, &msg);\n             // Also check if an accessible method exists, which is often what is meant.\n@@ -3084,7 +3088,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_ty_expr(expr.id, field_ty);\n+                self.write_ty(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n@@ -3095,7 +3099,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let struct_path = self.tcx().item_path_str(did);\n             let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n             self.tcx().sess.span_err(expr.span, &msg);\n-            self.write_ty_expr(expr.id, field_ty);\n+            self.write_ty(expr.id, field_ty);\n             return;\n         }\n \n@@ -3348,7 +3352,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n           hir::ExprLit(ref lit) => {\n             let typ = self.check_lit(&lit, expected);\n-            self.write_ty_expr(id, typ);\n+            self.write_ty(id, typ);\n           }\n           hir::ExprBinary(op, ref lhs, ref rhs) => {\n             self.check_binop(expr, op, lhs, rhs);\n@@ -3414,7 +3418,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty_expr(id, oprnd_t);\n+            self.write_ty(id, oprnd_t);\n           }\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -3465,7 +3469,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   let (scheme, predicates) = self.type_scheme_and_predicates_for_def(expr.span,\n                                                                                      def);\n                   self.instantiate_value_path(segments, scheme, &predicates,\n-                                              opt_ty, def, expr.span, id, true);\n+                                              opt_ty, def, expr.span, id);\n               } else {\n                   self.set_tainted_by_errors();\n                   self.write_error(id);\n@@ -3560,7 +3564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected);\n-            self.write_ty_expr(id, self.node_ty(b.id));\n+            self.write_ty(id, self.node_ty(b.id));\n           }\n           hir::ExprCall(ref callee, ref args) => {\n               self.check_call(expr, &callee, &args[..], expected);\n@@ -3596,7 +3600,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             } else {\n                 // Write a type for the whole expression, assuming everything is going\n                 // to work out Ok.\n-                self.write_ty_expr(id, t_cast);\n+                self.write_ty(id, t_cast);\n \n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n@@ -3613,7 +3617,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           hir::ExprType(ref e, ref t) => {\n             let typ = self.to_ty(&t);\n             self.check_expr_eq_type(&e, typ);\n-            self.write_ty_expr(id, typ);\n+            self.write_ty(id, typ);\n           }\n           hir::ExprVec(ref args) => {\n             let uty = expected.to_option(self).and_then(|uty| {\n@@ -3747,7 +3751,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       Some((index_ty, element_ty)) => {\n                           let idx_expr_ty = self.expr_ty(idx);\n                           self.demand_eqtype(expr.span, index_ty, idx_expr_ty);\n-                          self.write_ty_expr(id, element_ty);\n+                          self.write_ty(id, element_ty);\n                       }\n                       None => {\n                           self.check_expr_has_type(&idx, self.tcx.types.err);\n@@ -4042,7 +4046,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 } else if any_diverges {\n                     self.write_ty(blk.id, self.next_diverging_ty_var());\n                 } else {\n-                    self.write_ty_expr(blk.id, ety);\n+                    self.write_ty(blk.id, ety);\n                 }\n             }\n         };\n@@ -4091,8 +4095,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: Def,\n                                   span: Span,\n-                                  node_id: ast::NodeId,\n-                                  node_is_expr: bool)\n+                                  node_id: ast::NodeId)\n                                   -> Ty<'tcx> {\n         debug!(\"instantiate_value_path(path={:?}, def={:?}, node_id={}, type_scheme={:?})\",\n                segments,\n@@ -4356,11 +4359,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"instantiate_value_path: type of {:?} is {:?}\",\n                node_id,\n                ty_substituted);\n-        if node_is_expr {\n-            self.write_ty_expr(node_id, ty_substituted);\n-        } else {\n-            self.write_ty(node_id, ty_substituted);\n-        }\n+        self.write_ty(node_id, ty_substituted);\n         self.write_substs(node_id, ty::ItemSubsts {\n             substs: substs\n         });"}, {"sha": "16fe1f718b921a3bb71b885c35c748055181cd56", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d6fff0685b2dcb5b17cff70532fde91527707d/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=a6d6fff0685b2dcb5b17cff70532fde91527707d", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n             self.write_nil(expr.id);\n         } else {\n-            self.write_ty_expr(expr.id, return_ty);\n+            self.write_ty(expr.id, return_ty);\n         }\n \n         let tcx = self.tcx;\n@@ -69,7 +69,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 // && and || are a simple case.\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n-                self.write_ty_expr(expr.id, tcx.mk_bool());\n+                self.write_ty(expr.id, tcx.mk_bool());\n             }\n             _ => {\n                 // Otherwise, we always treat operators as if they are\n@@ -101,7 +101,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n-                self.write_ty_expr(expr.id, return_ty);\n+                self.write_ty(expr.id, return_ty);\n             }\n         }\n     }"}]}