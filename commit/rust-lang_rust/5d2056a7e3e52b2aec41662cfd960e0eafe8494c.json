{"sha": "5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkMjA1NmE3ZTNlNTJiMmFlYzQxNjYyY2ZkOTYwZTBlYWZlODQ5NGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-22T06:12:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-22T06:12:46Z"}, "message": "Auto merge of #21473 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "24169c2dc6be5e6c80f6bc3549fb83714160723f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24169c2dc6be5e6c80f6bc3549fb83714160723f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "html_url": "https://github.com/rust-lang/rust/commit/5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6869645e86c91544b8737b89809bdf10bef536d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/6869645e86c91544b8737b89809bdf10bef536d9", "html_url": "https://github.com/rust-lang/rust/commit/6869645e86c91544b8737b89809bdf10bef536d9"}, {"sha": "90af72378d9f848de78adc5003dff6b90f327b3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/90af72378d9f848de78adc5003dff6b90f327b3c", "html_url": "https://github.com/rust-lang/rust/commit/90af72378d9f848de78adc5003dff6b90f327b3c"}], "stats": {"total": 11655, "additions": 5411, "deletions": 6244}, "files": [{"sha": "b2f8c33380ce7015caa5ea10f80555885f1b4aa3", "filename": "configure", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -509,7 +509,6 @@ opt optimize-tests 1 \"build tests with optimizations\"\n opt libcpp 1 \"build with llvm with libc++ instead of libstdc++ when using clang\"\n opt llvm-assertions 1 \"build LLVM with assertions\"\n opt debug 1 \"build with extra debug fun\"\n-opt ratchet-bench 0 \"ratchet benchmarks\"\n opt fast-make 0 \"use .gitmodules as timestamp for submodule deps\"\n opt ccache 0 \"invoke gcc/clang via ccache to reuse object files between builds\"\n opt local-rust 0 \"use an installed rustc rather than downloading a snapshot\""}, {"sha": "a6f7f2ba1d66eb592e98cf844ce1c6a856b9c390", "filename": "mk/cfg/aarch64-linux-android.mk", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Fcfg%2Faarch64-linux-android.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Fcfg%2Faarch64-linux-android.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Faarch64-linux-android.mk?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -0,0 +1,30 @@\n+# aarch64-linux-android configuration\n+# CROSS_PREFIX_aarch64-linux-android-\n+CC_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc\n+CXX_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-g++\n+CPP_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-gcc -E\n+AR_aarch64-linux-android=$(CFG_ANDROID_CROSS_PATH)/bin/aarch64-linux-android-ar\n+CFG_LIB_NAME_aarch64-linux-android=lib$(1).so\n+CFG_STATIC_LIB_NAME_aarch64-linux-android=lib$(1).a\n+CFG_LIB_GLOB_aarch64-linux-android=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_aarch64-linux-android=lib$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_aarch64-linux-android := -D__aarch64__ -DANDROID -D__ANDROID__ $(CFLAGS)\n+CFG_GCCISH_CFLAGS_aarch64-linux-android := -Wall -g -fPIC -D__aarch64__ -DANDROID -D__ANDROID__ $(CFLAGS)\n+CFG_GCCISH_CXXFLAGS_aarch64-linux-android := -fno-rtti $(CXXFLAGS)\n+CFG_GCCISH_LINK_FLAGS_aarch64-linux-android := -shared -fPIC -ldl -g -lm -lsupc++\n+CFG_GCCISH_DEF_FLAG_aarch64-linux-android := -Wl,--export-dynamic,--dynamic-list=\n+CFG_GCCISH_PRE_LIB_FLAGS_aarch64-linux-android := -Wl,-whole-archive\n+CFG_GCCISH_POST_LIB_FLAGS_aarch64-linux-android := -Wl,-no-whole-archive\n+CFG_DEF_SUFFIX_aarch64-linux-android := .android.def\n+CFG_LLC_FLAGS_aarch64-linux-android :=\n+CFG_INSTALL_NAME_aarch64-linux-android =\n+CFG_EXE_SUFFIX_aarch64-linux-android :=\n+CFG_WINDOWSY_aarch64-linux-android :=\n+CFG_UNIXY_aarch64-linux-android := 1\n+CFG_PATH_MUNGE_aarch64-linux-android := true\n+CFG_LDPATH_aarch64-linux-android :=\n+CFG_RUN_aarch64-linux-android=\n+CFG_RUN_TARG_aarch64-linux-android=\n+RUSTC_FLAGS_aarch64-linux-android :=\n+RUSTC_CROSS_FLAGS_aarch64-linux-android :=\n+CFG_GNU_TRIPLE_aarch64-linux-android := aarch64-linux-android"}, {"sha": "a8bbeb4151701055a1c961973565b3dbd24097a5", "filename": "mk/rt.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -141,6 +141,8 @@ else ifeq ($(OSTYPE_$(1)), apple-ios)\n   JEMALLOC_ARGS_$(1) := --disable-tls\n else ifeq ($(OSTYPE_$(1)), linux-androideabi)\n   JEMALLOC_ARGS_$(1) := --disable-tls\n+else ifeq ($(OSTYPE_$(1)), linux-android)\n+  JEMALLOC_ARGS_$(1) := --disable-tls\n endif\n \n ################################################################################"}, {"sha": "32d4d178e6b8c65a4ad0435d8cb3101540cc2e35", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -300,6 +300,7 @@ tidy:\n \t\t| grep '^$(S)src/libbacktrace' -v \\\n \t\t| grep '^$(S)src/rust-installer' -v \\\n \t\t| xargs $(CFG_PYTHON) $(S)src/etc/check-binaries.py\n+\t\t$(Q) $(CFG_PYTHON) $(S)src/etc/errorck.py $(S)src/\n \n \n endif"}, {"sha": "c21785c45a3ac8422a1ed2dd5c4f04f3b9cf6e34", "filename": "src/compiletest/common.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcommon.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -13,7 +13,7 @@ use std::fmt;\n use std::str::FromStr;\n use regex::Regex;\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Debug)]\n pub enum Mode {\n     CompileFail,\n     RunFail,\n@@ -43,9 +43,9 @@ impl FromStr for Mode {\n     }\n }\n \n-impl fmt::String for Mode {\n+impl fmt::Display for Mode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(match *self {\n+        fmt::Display::fmt(match *self {\n             CompileFail => \"compile-fail\",\n             RunFail => \"run-fail\",\n             RunPass => \"run-pass\",\n@@ -58,12 +58,6 @@ impl fmt::String for Mode {\n     }\n }\n \n-impl fmt::Show for Mode {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n #[derive(Clone)]\n pub struct Config {\n     // The library paths required for running the compiler\n@@ -115,20 +109,6 @@ pub struct Config {\n     // Write out a parseable log of tests that were run\n     pub logfile: Option<Path>,\n \n-    // Write out a json file containing any metrics of the run\n-    pub save_metrics: Option<Path>,\n-\n-    // Write and ratchet a metrics file\n-    pub ratchet_metrics: Option<Path>,\n-\n-    // Percent change in metrics to consider noise\n-    pub ratchet_noise_percent: Option<f64>,\n-\n-    // \"Shard\" of the testsuite to pub run: this has the form of\n-    // two numbers (a,b), and causes only those tests with\n-    // positional order equal to a mod b to run.\n-    pub test_shard: Option<(uint,uint)>,\n-\n     // A command line to prefix program execution with,\n     // for running under valgrind\n     pub runtool: Option<String>,"}, {"sha": "1a9a1c08b07812c991d93734dca48984379ac9f1", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -77,10 +77,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"target-rustcflags\", \"flags to pass to rustc for target\", \"FLAGS\"),\n           optflag(\"\", \"verbose\", \"run tests verbosely, showing all output\"),\n           optopt(\"\", \"logfile\", \"file to log test execution to\", \"FILE\"),\n-          optopt(\"\", \"save-metrics\", \"file to save metrics to\", \"FILE\"),\n-          optopt(\"\", \"ratchet-metrics\", \"file to ratchet metrics against\", \"FILE\"),\n-          optopt(\"\", \"ratchet-noise-percent\",\n-                 \"percent change in metrics to consider noise\", \"N\"),\n           optflag(\"\", \"jit\", \"run tests under the JIT\"),\n           optopt(\"\", \"target\", \"the target to build for\", \"TARGET\"),\n           optopt(\"\", \"host\", \"the host to build for\", \"HOST\"),\n@@ -90,7 +86,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n           optopt(\"\", \"adb-path\", \"path to the android debugger\", \"PATH\"),\n           optopt(\"\", \"adb-test-dir\", \"path to tests for the android debugger\", \"PATH\"),\n           optopt(\"\", \"lldb-python-dir\", \"directory containing LLDB's python module\", \"PATH\"),\n-          optopt(\"\", \"test-shard\", \"run shard A, of B shards, worth of the testsuite\", \"A.B\"),\n           optflag(\"h\", \"help\", \"show this message\"));\n \n     assert!(!args.is_empty());\n@@ -152,12 +147,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n         filter: filter,\n         cfail_regex: Regex::new(errors::EXPECTED_PATTERN).unwrap(),\n         logfile: matches.opt_str(\"logfile\").map(|s| Path::new(s)),\n-        save_metrics: matches.opt_str(\"save-metrics\").map(|s| Path::new(s)),\n-        ratchet_metrics:\n-            matches.opt_str(\"ratchet-metrics\").map(|s| Path::new(s)),\n-        ratchet_noise_percent:\n-            matches.opt_str(\"ratchet-noise-percent\")\n-                   .and_then(|s| s.as_slice().parse::<f64>()),\n         runtool: matches.opt_str(\"runtool\"),\n         host_rustcflags: matches.opt_str(\"host-rustcflags\"),\n         target_rustcflags: matches.opt_str(\"target-rustcflags\"),\n@@ -176,7 +165,6 @@ pub fn parse_config(args: Vec<String> ) -> Config {\n                 opt_str2(matches.opt_str(\"adb-test-dir\")).as_slice() &&\n             !opt_str2(matches.opt_str(\"adb-test-dir\")).is_empty(),\n         lldb_python_dir: matches.opt_str(\"lldb-python-dir\"),\n-        test_shard: test::opt_shard(matches.opt_str(\"test-shard\")),\n         verbose: matches.opt_present(\"verbose\"),\n     }\n }\n@@ -210,10 +198,6 @@ pub fn log_config(config: &Config) {\n     logv(c, format!(\"adb_test_dir: {:?}\", config.adb_test_dir));\n     logv(c, format!(\"adb_device_status: {}\",\n                     config.adb_device_status));\n-    match config.test_shard {\n-        None => logv(c, \"test_shard: (all)\".to_string()),\n-        Some((a,b)) => logv(c, format!(\"test_shard: {}.{}\", a, b))\n-    }\n     logv(c, format!(\"verbose: {}\", config.verbose));\n     logv(c, format!(\"\\n\"));\n }\n@@ -284,15 +268,8 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         run_benchmarks: true,\n-        ratchet_metrics: config.ratchet_metrics.clone(),\n-        ratchet_noise_percent: config.ratchet_noise_percent.clone(),\n-        save_metrics: config.save_metrics.clone(),\n-        test_shard: config.test_shard.clone(),\n         nocapture: false,\n         color: test::AutoColor,\n-        show_boxplot: false,\n-        boxplot_width: 50,\n-        show_all_stats: false,\n     }\n }\n "}, {"sha": "d7af767688e81e7ecc92dc001ed6bf14d4f6e6c9", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -332,8 +332,7 @@ pub fn parse_name_value_directive(line: &str, directive: &str)\n     let keycolon = format!(\"{}:\", directive);\n     match line.find_str(keycolon.as_slice()) {\n         Some(colon) => {\n-            let value = line.slice(colon + keycolon.len(),\n-                                   line.len()).to_string();\n+            let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);\n             Some(value)\n         }"}, {"sha": "f075cff769fbaa26b962212db355152fd51a6b1a", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -294,6 +294,7 @@ fn run_pretty_test(config: &Config, props: &TestProps, testfile: &Path) {\n         let aux_dir = aux_output_dir_name(config, testfile);\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_string(),\n+                            \"-Zunstable-options\".to_string(),\n                             \"--pretty\".to_string(),\n                             pretty_type,\n                             format!(\"--target={}\", config.target),\n@@ -340,7 +341,7 @@ actual:\\n\\\n         };\n         // FIXME (#9639): This needs to handle non-utf8 paths\n         let mut args = vec!(\"-\".to_string(),\n-                            \"--no-trans\".to_string(),\n+                            \"-Zno-trans\".to_string(),\n                             \"--crate-type=lib\".to_string(),\n                             format!(\"--target={}\", target),\n                             \"-L\".to_string(),\n@@ -547,7 +548,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n \n             // Add line breakpoints\n             for line in breakpoint_lines.iter() {\n-                script_str.push_str(&format!(\"break '{:?}':{}\\n\",\n+                script_str.push_str(&format!(\"break '{}':{}\\n\",\n                                              testfile.filename_display(),\n                                              *line)[]);\n             }\n@@ -750,7 +751,7 @@ fn run_debuginfo_lldb_test(config: &Config, props: &TestProps, testfile: &Path)\n             status: status,\n             stdout: out,\n             stderr: err,\n-            cmdline: format!(\"{}\", cmd)\n+            cmdline: format!(\"{:?}\", cmd)\n         };\n     }\n }\n@@ -862,7 +863,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                         break;\n                     }\n                     Some(i) => {\n-                        rest = rest.slice_from(i + frag.len());\n+                        rest = &rest[(i + frag.len())..];\n                     }\n                 }\n                 first = false;\n@@ -953,7 +954,7 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n     }\n \n     let prefixes = expected_errors.iter().map(|ee| {\n-        format!(\"{:?}:{}:\", testfile.display(), ee.line)\n+        format!(\"{}:{}:\", testfile.display(), ee.line)\n     }).collect::<Vec<String> >();\n \n     #[cfg(windows)]\n@@ -1045,7 +1046,7 @@ fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n-    let opt = haystack.slice_from(*idx).find(needle);\n+    let opt = haystack[(*idx)..].find(needle);\n     if opt.is_none() {\n         return false;\n     }"}, {"sha": "b92d38215c29b3ecdd66ba4b99566ad51612f8ed", "filename": "src/doc/intro.md", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -480,14 +480,12 @@ use std::sync::{Arc,Mutex};\n fn main() {\n     let numbers = Arc::new(Mutex::new(vec![1is, 2, 3]));\n \n-    for i in 0..3 {\n+    for i in 0us..3 {\n         let number = numbers.clone();\n         Thread::spawn(move || {\n             let mut array = number.lock().unwrap();\n-\n-            (*array)[i] += 1;\n-\n-            println!(\"numbers[{}] is {}\", i, (*array)[i]);\n+            array[i] += 1;\n+            println!(\"numbers[{}] is {}\", i, array[i]);\n         });\n     }\n }"}, {"sha": "9ec4708eb2f36b27c6e9857de3b13512eca1fa85", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 27, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -803,8 +803,9 @@ Crates contain [items](#items), each of which may have some number of\n ## Items\n \n ```{.ebnf .gram}\n-item : mod_item | fn_item | type_item | struct_item | enum_item\n-     | static_item | trait_item | impl_item | extern_block ;\n+item : extern_crate_decl | use_decl | mod_item | fn_item | type_item\n+     | struct_item | enum_item | static_item | trait_item | impl_item\n+     | extern_block ;\n ```\n \n An _item_ is a component of a crate; some module items can be defined in crate\n@@ -818,6 +819,8 @@ execution, and may reside in read-only memory.\n \n There are several kinds of item:\n \n+* [`extern crate` declarations](#extern-crate-declarations)\n+* [`use` declarations](#use-declarations)\n * [modules](#modules)\n * [functions](#functions)\n * [type definitions](#type-definitions)\n@@ -854,13 +857,10 @@ no notion of type abstraction: there are no first-class \"forall\" types.\n \n ```{.ebnf .gram}\n mod_item : \"mod\" ident ( ';' | '{' mod '}' );\n-mod : [ view_item | item ] * ;\n+mod : item * ;\n ```\n \n-A module is a container for zero or more [view items](#view-items) and zero or\n-more [items](#items). The view items manage the visibility of the items defined\n-within the module, as well as the visibility of names from outside the module\n-when referenced from inside the module.\n+A module is a container for zero or more [items](#items).\n \n A _module item_ is a module, surrounded in braces, named, and prefixed with the\n keyword `mod`. A module item introduces a new, named module into the tree of\n@@ -918,19 +918,6 @@ mod thread {\n }\n ```\n \n-#### View items\n-\n-```{.ebnf .gram}\n-view_item : extern_crate_decl | use_decl ;\n-```\n-\n-A view item manages the namespace of a module. View items do not define new\n-items, but rather, simply change other items' visibility. There are two\n-kinds of view items:\n-\n-* [`extern crate` declarations](#extern-crate-declarations)\n-* [`use` declarations](#use-declarations)\n-\n ##### Extern crate declarations\n \n ```{.ebnf .gram}\n@@ -2377,10 +2364,6 @@ These types help drive the compiler's analysis\n   : ___Needs filling in___\n * `no_copy_bound`\n   : This type does not implement \"copy\", even if eligible.\n-* `no_send_bound`\n-  : This type does not implement \"send\", even if eligible.\n-* `no_sync_bound`\n-  : This type does not implement \"sync\", even if eligible.\n * `eh_personality`\n   : ___Needs filling in___\n * `exchange_free`\n@@ -2891,13 +2874,12 @@ Point3d {y: 0, z: 10, .. base};\n ### Block expressions\n \n ```{.ebnf .gram}\n-block_expr : '{' [ view_item ] *\n-                 [ stmt ';' | item ] *\n+block_expr : '{' [ stmt ';' | item ] *\n                  [ expr ] '}' ;\n ```\n \n A _block expression_ is similar to a module in terms of the declarations that\n-are possible. Each block conceptually introduces a new namespace scope. View\n+are possible. Each block conceptually introduces a new namespace scope. Use\n items can bring new names into scopes and declared items are in scope for only\n the block itself.\n "}, {"sha": "79bb5c182f49abb56ea03e8b0f226063f5c457e2", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -257,7 +257,7 @@ fn goodbye() -> String {\n \n (This is \"Say\u014dnara\", if you're curious.)\n \n-Now that we have our some functionality in our crate, let's try to use it from\n+Now that we have some functionality in our crate, let's try to use it from\n another crate.\n \n # Importing External Crates"}, {"sha": "a350df67b1759ebe47afc150dd917d393ce1e4cf", "filename": "src/doc/trpl/if.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fif.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fif.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fif.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1,4 +1,4 @@\n-% `if`\n+% If\n \n Rust's take on `if` is not particularly complex, but it's much more like the\n `if` you'll find in a dynamically typed language than in a more traditional"}, {"sha": "4301149d1f8b3d62a26c07ba395f43976c5c3a5c", "filename": "src/doc/trpl/looping.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Flooping.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Flooping.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flooping.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -123,7 +123,7 @@ We now loop forever with `loop` and use `break` to break out early.\n iteration. This will only print the odd numbers:\n \n ```{rust}\n-for x in 0..10 {\n+for x in 0u32..10 {\n     if x % 2 == 0 { continue; }\n \n     println!(\"{}\", x);"}, {"sha": "a801a1ab0e9217e1982f406aeabe5160b42662ef", "filename": "src/doc/trpl/threads.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fthreads.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Fthreads.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthreads.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -179,7 +179,7 @@ for init_val in 0 .. 3 {\n }\n \n let result = rx.recv().unwrap() + rx.recv().unwrap() + rx.recv().unwrap();\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n@@ -207,7 +207,7 @@ let rxs = (0 .. 3).map(|&:init_val| {\n \n // Wait on each port, accumulating the results\n let result = rxs.iter().fold(0, |&:accum, rx| accum + rx.recv().unwrap() );\n-# fn some_expensive_computation(_i: u32) -> u32 { 42 }\n+# fn some_expensive_computation(_i: i32) -> i32 { 42 }\n ```\n \n ## Backgrounding computations: Futures"}, {"sha": "3acd1eefe89d06f1b7a8578eaa76c1ff7b4b13b4", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -707,7 +707,7 @@ Other features provided by lang items include:\n   various kinds; lang items `send`, `sync` and `copy`.\n - the marker types and variance indicators found in\n   `std::marker`; lang items `covariant_type`,\n-  `contravariant_lifetime`, `no_sync_bound`, etc.\n+  `contravariant_lifetime`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses\n `Box` then there is no need to define functions for `exchange_malloc`"}, {"sha": "dae685f3a540a63dc1185304c4710e7f42547673", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -54,6 +54,11 @@\n   :type 'integer\n   :group 'rust-mode)\n \n+(defcustom rust-indent-method-chain nil\n+  \"Indent Rust method chains, aligned by the '.' operators\"\n+  :type 'boolean\n+  :group 'rust-mode)\n+\n (defun rust-paren-level () (nth 0 (syntax-ppss)))\n (defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n (defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n@@ -73,10 +78,19 @@\n     ;; open bracket ends the line\n     (when (not (looking-at \"[[:blank:]]*\\\\(?://.*\\\\)?$\"))\n       (when (looking-at \"[[:space:]]\")\n-\t(forward-word 1)\n-\t(backward-word 1))\n+    (forward-word 1)\n+    (backward-word 1))\n       (current-column))))\n \n+(defun rust-align-to-method-chain ()\n+  (save-excursion\n+    (previous-line)\n+    (end-of-line)\n+    (backward-word 1)\n+    (backward-char)\n+    (when (looking-at \"\\\\..+\\(.*\\)\\n\")\n+      (- (current-column) rust-indent-offset))))\n+\n (defun rust-rewind-to-beginning-of-current-level-expr ()\n   (let ((current-level (rust-paren-level)))\n     (back-to-indentation)\n@@ -99,10 +113,13 @@\n                    ;; the inside of it correctly relative to the outside.\n                    (if (= 0 level)\n                        0\n+                     (or\n+                      (when rust-indent-method-chain\n+                        (rust-align-to-method-chain))\n                      (save-excursion\n                        (backward-up-list)\n                        (rust-rewind-to-beginning-of-current-level-expr)\n-                       (+ (current-column) rust-indent-offset)))))\n+                       (+ (current-column) rust-indent-offset))))))\n              (cond\n               ;; A function return type is indented to the corresponding function arguments\n               ((looking-at \"->\")\n@@ -114,6 +131,16 @@\n               ;; A closing brace is 1 level unindended\n               ((looking-at \"}\") (- baseline rust-indent-offset))\n \n+              ;;Line up method chains by their .'s\n+              ((when (and rust-indent-method-chain\n+                          (looking-at \"\\..+\\(.*\\);?\\n\"))\n+                 (or\n+                  (let ((method-indent (rust-align-to-method-chain)))\n+                    (when method-indent\n+                      (+ method-indent rust-indent-offset)))\n+                  (+ baseline rust-indent-offset))))\n+\n+              \n               ;; Doc comments in /** style with leading * indent to line up the *s\n               ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n                (+ 1 baseline))"}, {"sha": "17659309d3b0d6822dcedb2b0f773e06d0b1187f", "filename": "src/etc/errorck.py", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Ferrorck.py", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Ferrorck.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ferrorck.py?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -0,0 +1,70 @@\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# Digs error codes out of files named 'diagnostics.rs' across\n+# the tree, and ensures thare are no duplicates.\n+\n+import sys, os, re\n+\n+src_dir = sys.argv[1]\n+\n+errcode_map = { }\n+\n+for (dirpath, dirnames, filenames) in os.walk(src_dir):\n+\n+    if \"src/test\" in dirpath or \"src/llvm\" in dirpath:\n+        # Short circuit for fast\n+        continue\n+\n+    for filename in filenames:\n+        if filename != \"diagnostics.rs\":\n+            continue\n+\n+        path = os.path.join(dirpath, filename)\n+        line_num = 1\n+        with open(path, 'r') as f:\n+            for line in f:\n+\n+                p = re.compile(\"(E\\d\\d\\d\\d)\")\n+                m = p.search(line)\n+                if not m is None:\n+                    errcode = m.group(1)\n+\n+                    new_record = [(errcode, path, line_num, line)]\n+                    existing = errcode_map.get(errcode)\n+                    if existing is not None:\n+                        # This is a dupe\n+                        errcode_map[errcode] = existing + new_record\n+                    else:\n+                        errcode_map[errcode] = new_record\n+\n+                line_num += 1\n+\n+errors = False\n+all_errors = []\n+for errcode in errcode_map:\n+    entries = errcode_map[errcode]\n+    all_errors += [entries[0][0]]\n+    if len(entries) > 1:\n+        print \"error: duplicate error code \" + errcode\n+        for entry in entries:\n+            print entry[1] + \": \" + str(entry[2])\n+            print entry[3]\n+        errors = True\n+\n+print str(len(errcode_map)) + \" error codes\"\n+\n+all_errors.sort()\n+all_errors.reverse()\n+\n+print \"highest error code: \" + all_errors[0]\n+\n+if errors:\n+    sys.exit(1)"}, {"sha": "07e832d317adb2f91f098e960865e84d18e085fd", "filename": "src/etc/rustup.sh", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Frustup.sh", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fetc%2Frustup.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frustup.sh?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -433,11 +433,16 @@ CFG_TMP_DIR=$(mktemp -d 2>/dev/null \\\n            || mktemp -d -t 'rustup-tmp-install' 2>/dev/null \\\n            || create_tmp_dir)\n \n-# If we're saving nightlies and we didn't specify which one, grab todays.\n-# Otherwise we'll use the latest version.\n+# If we're saving nightlies and we didn't specify which one, grab the latest\n+# verison from the perspective of the server. Buildbot has typically finished\n+# building and uploading by ~8UTC, but we want to include a little buffer.\n+#\n+# FIXME It would be better to use the known most recent nightly that has been\n+# built. This is waiting on a change to have buildbot publish metadata that\n+# can be queried.\n if [ -n \"${CFG_SAVE}\" -a -z \"${CFG_DATE}\" ];\n then\n-    CFG_DATE=`date \"+%Y-%m-%d\"`\n+    CFG_DATE=`TZ=Etc/UTC+9 date \"+%Y-%m-%d\"`\n fi\n \n RUST_URL=\"https://static.rust-lang.org/dist\"\n@@ -453,16 +458,33 @@ then\n     RUST_URL=\"${RUST_URL}/${CFG_DATE}\"\n fi\n \n-verify_hash() {\n-    remote_sha256=\"$1\"\n-    local_file=\"$2\"\n-\n+download_hash() {\n     msg \"Downloading ${remote_sha256}\"\n     remote_sha256=`\"${CFG_CURL}\" -f \"${remote_sha256}\"`\n+    if [ -n \"${CFG_SAVE}\" ]; then\n+        echo \"${remote_sha256}\" > \"${local_sha_file}\"\n+    fi\n     if [ \"$?\" -ne 0 ]; then\n         rm -Rf \"${CFG_TMP_DIR}\"\n         err \"Failed to download ${remote_url}\"\n     fi\n+}\n+\n+verify_hash() {\n+    remote_sha256=\"$1\"\n+    local_file=\"$2\"\n+    local_sha_file=\"${local_file}.sha256\"\n+\n+    if [ -n \"${CFG_SAVE}\" ]; then\n+        if [ -f \"${local_sha_file}\" ]; then\n+            msg \"Local ${local_sha_file} exists, treating as remote hash\"\n+            remote_sha256=`cat \"${local_sha_file}\"`\n+        else\n+            download_hash\n+        fi\n+    else\n+        download_hash\n+    fi\n \n     msg \"Verifying hash\"\n     local_sha256=$(calculate_hash \"${local_file}\")"}, {"sha": "5f8cd6baf9a743c7ec8072e396c367a1fff2dbf2", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -72,7 +72,7 @@ use core::prelude::*;\n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n-use core::fmt::{self, Show};\n+use core::fmt;\n use core::cmp::{Ordering};\n use core::default::Default;\n use core::mem::{min_align_of, size_of};\n@@ -578,16 +578,17 @@ impl<T: Ord> Ord for Arc<T> {\n #[stable]\n impl<T: Eq> Eq for Arc<T> {}\n \n-impl<T: fmt::Show> fmt::Show for Arc<T> {\n+#[stable]\n+impl<T: fmt::Display> fmt::Display for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Arc({:?})\", (**self))\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable]\n-impl<T: fmt::String> fmt::String for Arc<T> {\n+impl<T: fmt::Debug> fmt::Debug for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -806,7 +807,7 @@ mod tests {\n     #[test]\n     fn show_arc() {\n         let a = Arc::new(5u32);\n-        assert!(format!(\"{:?}\", a) == \"Arc(5u32)\")\n+        assert_eq!(format!(\"{:?}\", a), \"5\");\n     }\n \n     // Make sure deriving works with Arc<T>"}, {"sha": "5ec08a1f254066cea102e316e4e70d911a471d4d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 23, "deletions": 53, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -16,16 +16,18 @@ use core::any::Any;\n use core::clone::Clone;\n use core::cmp::{PartialEq, PartialOrd, Eq, Ord, Ordering};\n use core::default::Default;\n+use core::error::{Error, FromError};\n use core::fmt;\n use core::hash::{self, Hash};\n+use core::iter::Iterator;\n use core::marker::Sized;\n use core::mem;\n+use core::ops::{Deref, DerefMut};\n use core::option::Option;\n use core::ptr::Unique;\n use core::raw::TraitObject;\n-use core::result::Result;\n use core::result::Result::{Ok, Err};\n-use core::ops::{Deref, DerefMut};\n+use core::result::Result;\n \n /// A value that represents the global exchange heap. This is the default\n /// place that the `box` keyword allocates into when no place is supplied.\n@@ -156,20 +158,22 @@ impl BoxAny for Box<Any> {\n     }\n }\n \n-impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n+#[stable]\n+impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Box({:?})\", &**self)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable]\n-impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n+impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n-impl fmt::Show for Box<Any> {\n+#[stable]\n+impl fmt::Debug for Box<Any> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(\"Box<Any>\")\n     }\n@@ -187,56 +191,22 @@ impl<T: ?Sized> DerefMut for Box<T> {\n     fn deref_mut(&mut self) -> &mut T { &mut **self }\n }\n \n-#[cfg(test)]\n-mod test {\n-    #[test]\n-    fn test_owned_clone() {\n-        let a = Box::new(5i);\n-        let b: Box<int> = a.clone();\n-        assert!(a == b);\n-    }\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#[old_impl_check]\n+impl<'a, T> Iterator for Box<Iterator<Item=T> + 'a> {\n+    type Item = T;\n \n-    #[test]\n-    fn any_move() {\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n-\n-        match a.downcast::<uint>() {\n-            Ok(a) => { assert!(a == Box::new(8u)); }\n-            Err(..) => panic!()\n-        }\n-        match b.downcast::<Test>() {\n-            Ok(a) => { assert!(a == Box::new(Test)); }\n-            Err(..) => panic!()\n-        }\n-\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n-\n-        assert!(a.downcast::<Box<Test>>().is_err());\n-        assert!(b.downcast::<Box<uint>>().is_err());\n+    fn next(&mut self) -> Option<T> {\n+        (**self).next()\n     }\n \n-    #[test]\n-    fn test_show() {\n-        let a = Box::new(8u) as Box<Any>;\n-        let b = Box::new(Test) as Box<Any>;\n-        let a_str = a.to_str();\n-        let b_str = b.to_str();\n-        assert_eq!(a_str, \"Box<Any>\");\n-        assert_eq!(b_str, \"Box<Any>\");\n-\n-        let a = &8u as &Any;\n-        let b = &Test as &Any;\n-        let s = format!(\"{}\", a);\n-        assert_eq!(s, \"&Any\");\n-        let s = format!(\"{}\", b);\n-        assert_eq!(s, \"&Any\");\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n     }\n+}\n \n-    #[test]\n-    fn deref() {\n-        fn homura<T: Deref<Target=i32>>(_: T) { }\n-        homura(Box::new(765i32));\n+impl<'a, E: Error + 'a> FromError<E> for Box<Error + 'a> {\n+    fn from_error(err: E) -> Box<Error + 'a> {\n+        Box::new(err)\n     }\n }"}, {"sha": "c47a771f60d09ceb2ad74fed5a754413f396a34a", "filename": "src/liballoc/boxed_test.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Test for `boxed` mod.\n+\n+use core::any::Any;\n+use core::ops::Deref;\n+use core::result::Result::{Ok, Err};\n+use core::clone::Clone;\n+\n+use std::boxed::Box;\n+use std::boxed::BoxAny;\n+\n+#[test]\n+fn test_owned_clone() {\n+    let a = Box::new(5i);\n+    let b: Box<int> = a.clone();\n+    assert!(a == b);\n+}\n+\n+#[derive(PartialEq, Eq)]\n+struct Test;\n+\n+#[test]\n+fn any_move() {\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+\n+    match a.downcast::<uint>() {\n+        Ok(a) => { assert!(a == Box::new(8u)); }\n+        Err(..) => panic!()\n+    }\n+    match b.downcast::<Test>() {\n+        Ok(a) => { assert!(a == Box::new(Test)); }\n+        Err(..) => panic!()\n+    }\n+\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+\n+    assert!(a.downcast::<Box<Test>>().is_err());\n+    assert!(b.downcast::<Box<uint>>().is_err());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let a = Box::new(8u) as Box<Any>;\n+    let b = Box::new(Test) as Box<Any>;\n+    let a_str = format!(\"{:?}\", a);\n+    let b_str = format!(\"{:?}\", b);\n+    assert_eq!(a_str, \"Box<Any>\");\n+    assert_eq!(b_str, \"Box<Any>\");\n+\n+    static EIGHT: usize = 8us;\n+    static TEST: Test = Test;\n+    let a = &EIGHT as &Any;\n+    let b = &TEST as &Any;\n+    let s = format!(\"{:?}\", a);\n+    assert_eq!(s, \"&Any\");\n+    let s = format!(\"{:?}\", b);\n+    assert_eq!(s, \"&Any\");\n+}\n+\n+#[test]\n+fn deref() {\n+    fn homura<T: Deref<Target=i32>>(_: T) { }\n+    homura(Box::new(765i32));\n+}"}, {"sha": "a2643f4d0f79b5e6d752ead894a9c29068a531d1", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -280,7 +280,7 @@ mod imp {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n-            let mut out = 0 as *mut libc::c_void;\n+            let mut out = ptr::null_mut();\n             let ret = posix_memalign(&mut out,\n                                      align as libc::size_t,\n                                      size as libc::size_t);"}, {"sha": "231ef6e7e74daf3ecea897e5d2b2ff1aabe14286", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -70,6 +70,8 @@\n #![feature(lang_items, unsafe_destructor)]\n #![feature(box_syntax)]\n #![feature(optin_builtin_traits)]\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#![feature(old_impl_check)]\n #![allow(unknown_features)] #![feature(int_uint)]\n \n #[macro_use]\n@@ -91,6 +93,8 @@ pub mod heap;\n \n #[cfg(not(test))]\n pub mod boxed;\n+#[cfg(test)]\n+mod boxed_test;\n pub mod arc;\n pub mod rc;\n "}, {"sha": "5e82c4f1adea98db80d2b9a755e571b00c8c4659", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 8, "deletions": 162, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -174,61 +174,17 @@ struct RcBox<T> {\n /// See the [module level documentation](../index.html) for more details.\n #[unsafe_no_drop_flag]\n #[stable]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Rc<T> {\n     // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n     // type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n-    _nosend: marker::NoSend,\n-    _noshare: marker::NoSync\n }\n \n-/// An immutable reference-counted pointer type.\n-///\n-/// See the [module level documentation](../index.html) for more details.\n-#[unsafe_no_drop_flag]\n-#[stable]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct Rc<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with field accesses of the contained\n-    // type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Send for Rc<T> {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<T> !marker::Sync for Rc<T> {}\n \n impl<T> Rc<T> {\n-    /// Constructs a new `Rc<T>`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    /// ```\n-    #[stable]\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    pub fn new(value: T) -> Rc<T> {\n-        unsafe {\n-            Rc {\n-                // there is an implicit weak pointer owned by all the strong pointers, which\n-                // ensures that the weak destructor never frees the allocation while the strong\n-                // destructor is running, even if the weak pointer is stored inside the strong one.\n-                _ptr: NonZero::new(transmute(box RcBox {\n-                    value: value,\n-                    strong: Cell::new(1),\n-                    weak: Cell::new(1)\n-                })),\n-                _nosend: marker::NoSend,\n-                _noshare: marker::NoSync\n-            }\n-        }\n-    }\n \n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -240,7 +196,6 @@ impl<T> Rc<T> {\n     /// let five = Rc::new(5i);\n     /// ```\n     #[stable]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n             Rc {\n@@ -267,29 +222,6 @@ impl<T> Rc<T> {\n     ///\n     /// let weak_five = five.downgrade();\n     /// ```\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    #[unstable = \"Weak pointers may not belong in this module\"]\n-    pub fn downgrade(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak {\n-            _ptr: self._ptr,\n-            _nosend: marker::NoSend,\n-            _noshare: marker::NoSync\n-        }\n-    }\n-\n-    /// Downgrades the `Rc<T>` to a `Weak<T>` reference.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    /// ```\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     #[unstable = \"Weak pointers may not belong in this module\"]\n     pub fn downgrade(&self) -> Weak<T> {\n         self.inc_weak();\n@@ -483,25 +415,6 @@ impl<T> Drop for Rc<T> {\n \n #[stable]\n impl<T> Clone for Rc<T> {\n-    /// Makes a clone of the `Rc<T>`.\n-    ///\n-    /// This increases the strong reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// five.clone();\n-    /// ```\n-    #[inline]\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    fn clone(&self) -> Rc<T> {\n-        self.inc_strong();\n-        Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n-    }\n \n     /// Makes a clone of the `Rc<T>`.\n     ///\n@@ -517,7 +430,6 @@ impl<T> Clone for Rc<T> {\n     /// five.clone();\n     /// ```\n     #[inline]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n         Rc { _ptr: self._ptr }\n@@ -693,17 +605,17 @@ impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     }\n }\n \n-#[unstable = \"Show is experimental.\"]\n-impl<T: fmt::Show> fmt::Show for Rc<T> {\n+#[stable]\n+impl<T: fmt::Display> fmt::Display for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Rc({:?})\", **self)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable]\n-impl<T: fmt::String> fmt::String for Rc<T> {\n+impl<T: fmt::Debug> fmt::Debug for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -714,66 +626,21 @@ impl<T: fmt::String> fmt::String for Rc<T> {\n /// See the [module level documentation](../index.html) for more.\n #[unsafe_no_drop_flag]\n #[unstable = \"Weak pointers may not belong in this module.\"]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Weak<T> {\n     // FIXME #12808: strange names to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _ptr: NonZero<*mut RcBox<T>>,\n-    _nosend: marker::NoSend,\n-    _noshare: marker::NoSync\n }\n \n-/// A weak version of `Rc<T>`.\n-///\n-/// Weak references do not count when determining if the inner value should be dropped.\n-///\n-/// See the [module level documentation](../index.html) for more.\n-#[unsafe_no_drop_flag]\n-#[unstable = \"Weak pointers may not belong in this module.\"]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct Weak<T> {\n-    // FIXME #12808: strange names to try to avoid interfering with\n-    // field accesses of the contained type via Deref\n-    _ptr: NonZero<*mut RcBox<T>>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n #[allow(unstable)]\n impl<T> !marker::Send for Weak<T> {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n #[allow(unstable)]\n impl<T> !marker::Sync for Weak<T> {}\n \n \n #[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T> Weak<T> {\n-    /// Upgrades a weak reference to a strong reference.\n-    ///\n-    /// Upgrades the `Weak<T>` reference to an `Rc<T>`, if possible.\n-    ///\n-    /// Returns `None` if there were no strong references and the data was destroyed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let five = Rc::new(5i);\n-    ///\n-    /// let weak_five = five.downgrade();\n-    ///\n-    /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n-    /// ```\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    pub fn upgrade(&self) -> Option<Rc<T>> {\n-        if self.strong() == 0 {\n-            None\n-        } else {\n-            self.inc_strong();\n-            Some(Rc { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync })\n-        }\n-    }\n \n     /// Upgrades a weak reference to a strong reference.\n     ///\n@@ -792,7 +659,6 @@ impl<T> Weak<T> {\n     ///\n     /// let strong_five: Option<Rc<_>> = weak_five.upgrade();\n     /// ```\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn upgrade(&self) -> Option<Rc<T>> {\n         if self.strong() == 0 {\n             None\n@@ -849,25 +715,6 @@ impl<T> Drop for Weak<T> {\n \n #[unstable = \"Weak pointers may not belong in this module.\"]\n impl<T> Clone for Weak<T> {\n-    /// Makes a clone of the `Weak<T>`.\n-    ///\n-    /// This increases the weak reference count.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::rc::Rc;\n-    ///\n-    /// let weak_five = Rc::new(5i).downgrade();\n-    ///\n-    /// weak_five.clone();\n-    /// ```\n-    #[inline]\n-    #[cfg(stage0)] // NOTE remove after next snapshot\n-    fn clone(&self) -> Weak<T> {\n-        self.inc_weak();\n-        Weak { _ptr: self._ptr, _nosend: marker::NoSend, _noshare: marker::NoSync }\n-    }\n \n     /// Makes a clone of the `Weak<T>`.\n     ///\n@@ -883,15 +730,14 @@ impl<T> Clone for Weak<T> {\n     /// weak_five.clone();\n     /// ```\n     #[inline]\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn clone(&self) -> Weak<T> {\n         self.inc_weak();\n         Weak { _ptr: self._ptr }\n     }\n }\n \n-#[unstable = \"Show is experimental.\"]\n-impl<T: fmt::Show> fmt::Show for Weak<T> {\n+#[stable]\n+impl<T: fmt::Debug> fmt::Debug for Weak<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n@@ -1134,7 +980,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let foo = Rc::new(75u);\n-        assert!(format!(\"{:?}\", foo) == \"Rc(75u)\")\n+        assert_eq!(format!(\"{:?}\", foo), \"75\");\n     }\n \n }"}, {"sha": "4c07f5b31e64d01c0afa8e7d405d5c49b131efb8", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -330,7 +330,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes[(complete_words*4)..].iter().enumerate() {\n+            for (i, &byte) in bytes[complete_words*4..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);\n@@ -972,7 +972,7 @@ impl Ord for Bitv {\n }\n \n #[stable]\n-impl fmt::Show for Bitv {\n+impl fmt::Debug for Bitv {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self.iter() {\n             try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n@@ -1727,7 +1727,7 @@ impl BitvSet {\n     }\n }\n \n-impl fmt::Show for BitvSet {\n+impl fmt::Debug for BitvSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"BitvSet {{\"));\n         let mut first = true;\n@@ -2622,7 +2622,7 @@ mod bitv_set_test {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitvSet {1u, 2u, 10u, 50u}\", format!(\"{:?}\", s));\n+        assert_eq!(\"BitvSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]"}, {"sha": "8c2f00a5695144f53f8ffcce8f6fb4cb61ffda12", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,7 +22,7 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n@@ -871,7 +871,7 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n }\n \n #[stable]\n-impl<K: Show, V: Show> Show for BTreeMap<K, V> {\n+impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeMap {{\"));\n "}, {"sha": "50857c78469cf1a24cf5e24c556b7b0d679209a4", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,7 +21,7 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{Greater, Less, Equal};\n use core::iter::Zip;\n-use core::ops::{Deref, DerefMut};\n+use core::ops::{Deref, DerefMut, Index, IndexMut};\n use core::ptr::Unique;\n use core::{slice, mem, ptr, cmp, num, raw};\n use alloc::heap;\n@@ -1487,7 +1487,7 @@ impl<K, V, E, Impl> AbsTraversal<Impl>\n \n macro_rules! node_slice_impl {\n     ($NodeSlice:ident, $Traversal:ident,\n-     $as_slices_internal:ident, $slice_from:ident, $slice_to:ident, $iter:ident) => {\n+     $as_slices_internal:ident, $index:ident, $iter:ident) => {\n         impl<'a, K: Ord + 'a, V: 'a> $NodeSlice<'a, K, V> {\n             /// Performs linear search in a slice. Returns a tuple of (index, is_exact_match).\n             fn search_linear<Q: ?Sized>(&self, key: &Q) -> (uint, bool)\n@@ -1521,10 +1521,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_from(pos)\n+                        self.edges.$index(&(pos ..))\n                     },\n-                    keys: self.keys.slice_from(pos),\n-                    vals: self.vals.$slice_from(pos),\n+                    keys: &self.keys[pos ..],\n+                    vals: self.vals.$index(&(pos ..)),\n                     head_is_edge: !pos_is_kv,\n                     tail_is_edge: self.tail_is_edge,\n                 }\n@@ -1550,10 +1550,10 @@ macro_rules! node_slice_impl {\n                     edges: if !self.has_edges {\n                         self.edges\n                     } else {\n-                        self.edges.$slice_to(pos + 1)\n+                        self.edges.$index(&(.. (pos + 1)))\n                     },\n-                    keys: self.keys.slice_to(pos),\n-                    vals: self.vals.$slice_to(pos),\n+                    keys: &self.keys[..pos],\n+                    vals: self.vals.$index(&(.. pos)),\n                     head_is_edge: self.head_is_edge,\n                     tail_is_edge: !pos_is_kv,\n                 }\n@@ -1583,6 +1583,5 @@ macro_rules! node_slice_impl {\n     }\n }\n \n-node_slice_impl!(NodeSlice, Traversal, as_slices_internal, slice_from, slice_to, iter);\n-node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, slice_from_mut,\n-                                                                     slice_to_mut, iter_mut);\n+node_slice_impl!(NodeSlice, Traversal, as_slices_internal, index, iter);\n+node_slice_impl!(MutNodeSlice, MutTraversal, as_slices_internal_mut, index_mut, iter_mut);"}, {"sha": "d307b7dbde75d20267d72e4760365d90bdabfaf2", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -16,11 +16,8 @@ use core::prelude::*;\n use core::borrow::BorrowFrom;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::default::Default;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::fmt;\n-// NOTE(stage0) remove import after a snapshot\n-#[cfg(stage0)]\n-use core::hash::Hash;\n use core::iter::{Peekable, Map, FromIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub};\n \n@@ -592,7 +589,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n }\n \n #[stable]\n-impl<T: Show> Show for BTreeSet<T> {\n+impl<T: Debug> Debug for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"BTreeSet {{\"));\n \n@@ -892,7 +889,7 @@ mod test {\n \n         let set_str = format!(\"{:?}\", set);\n \n-        assert_eq!(set_str, \"BTreeSet {1i, 2i}\");\n+        assert_eq!(set_str, \"BTreeSet {1, 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"BTreeSet {}\");\n     }\n }"}, {"sha": "73fd806c9070bcfe930a5299bb5dbb003552f6ac", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -874,7 +874,7 @@ impl<A: Clone> Clone for DList<A> {\n }\n \n #[stable]\n-impl<A: fmt::Show> fmt::Show for DList<A> {\n+impl<A: fmt::Debug> fmt::Debug for DList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"DList [\"));\n \n@@ -1333,7 +1333,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"DList [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n+        assert_eq!(format!(\"{:?}\", list), \"DList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)"}, {"sha": "a40a590c51ace8abdeb4e818f9806d506cf50ff5", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -31,7 +31,7 @@ pub struct EnumSet<E> {\n \n impl<E> Copy for EnumSet<E> {}\n \n-impl<E:CLike+fmt::Show> fmt::Show for EnumSet<E> {\n+impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"EnumSet {{\"));\n         let mut first = true;"}, {"sha": "85aedaeb010f127689c8b43053a27b2f40e0e39a", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -12,13 +12,13 @@\n #[macro_export]\n #[stable]\n macro_rules! vec {\n-    ($x:expr; $y:expr) => ({\n-        let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$x; $y]);\n-        $crate::slice::SliceExt::into_vec(xs)\n-    });\n-    ($($x:expr),*) => ({\n-        let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$($x),*]);\n-        $crate::slice::SliceExt::into_vec(xs)\n-    });\n+    ($x:expr; $y:expr) => (\n+        <[_] as $crate::slice::SliceExt>::into_vec(\n+            $crate::boxed::Box::new([$x; $y]))\n+    );\n+    ($($x:expr),*) => (\n+        <[_] as $crate::slice::SliceExt>::into_vec(\n+            $crate::boxed::Box::new([$($x),*]))\n+    );\n     ($($x:expr,)*) => (vec![$($x),*])\n }"}, {"sha": "338166c2f0b7488f2458ac75f094b886149e1f9f", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -578,7 +578,7 @@ impl<T> RingBuf<T> {\n \n             if contiguous {\n                 let (empty, buf) = buf.split_at_mut(0);\n-                (buf.slice_mut(tail, head), empty)\n+                (&mut buf[tail .. head], empty)\n             } else {\n                 let (mid, right) = buf.split_at_mut(tail);\n                 let (left, _) = mid.split_at_mut(head);\n@@ -1611,7 +1611,7 @@ impl<A> Extend<A> for RingBuf<A> {\n }\n \n #[stable]\n-impl<T: fmt::Show> fmt::Show for RingBuf<T> {\n+impl<T: fmt::Debug> fmt::Debug for RingBuf<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"RingBuf [\"));\n \n@@ -1630,7 +1630,7 @@ mod tests {\n     use self::Taggypar::*;\n     use prelude::*;\n     use core::iter;\n-    use std::fmt::Show;\n+    use std::fmt::Debug;\n     use std::hash::{self, SipHasher};\n     use test::Bencher;\n     use test;\n@@ -1678,7 +1678,7 @@ mod tests {\n     }\n \n     #[cfg(test)]\n-    fn test_parameterized<T:Clone + PartialEq + Show>(a: T, b: T, c: T, d: T) {\n+    fn test_parameterized<T:Clone + PartialEq + Debug>(a: T, b: T, c: T, d: T) {\n         let mut deq = RingBuf::new();\n         assert_eq!(deq.len(), 0);\n         deq.push_front(a.clone());\n@@ -2302,7 +2302,7 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0i, 1i, 2i, 3i, 4i, 5i, 6i, 7i, 8i, 9i]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"RingBuf [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)"}, {"sha": "8c7f79d4d787ba4be5693f91932c14dd13781680", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 32, "deletions": 51, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -169,29 +169,16 @@ pub trait SliceExt {\n     #[unstable = \"uncertain about this API approach\"]\n     fn move_from(&mut self, src: Vec<Self::Item>, start: uint, end: uint) -> uint;\n \n-    /// Returns a subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start .. end]` notation instead.\n+    #[deprecated = \"use &s[start .. end] instead\"]\n     fn slice(&self, start: uint, end: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[start..]` notation instead.\n+    #[deprecated = \"use &s[start..] isntead\"]\n     fn slice_from(&self, start: uint) -> &[Self::Item];\n \n-    /// Returns a subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&s[..end]` notation instead.\n+    #[deprecated = \"use &s[..end] instead\"]\n     fn slice_to(&self, end: uint) -> &[Self::Item];\n \n     /// Divides one slice into two at an index.\n@@ -378,29 +365,16 @@ pub trait SliceExt {\n     #[stable]\n     fn as_mut_slice(&mut self) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice spanning the interval [`start`, `end`).\n-    ///\n-    /// Panics when the end of the new slice lies beyond the end of the\n-    /// original slice (i.e. when `end > self.len()`) or when `start > end`.\n-    ///\n-    /// Slicing with `start` equal to `end` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start .. end]` instead.\n+    #[deprecated = \"use &mut s[start .. end] instead\"]\n     fn slice_mut(&mut self, start: uint, end: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from `start` to the end of the slice.\n-    ///\n-    /// Panics when `start` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing from `self.len()` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[start ..]` instead.\n+    #[deprecated = \"use &mut s[start ..] instead\"]\n     fn slice_from_mut(&mut self, start: uint) -> &mut [Self::Item];\n \n-    /// Returns a mutable subslice from the start of the slice to `end`.\n-    ///\n-    /// Panics when `end` is strictly greater than the length of the original slice.\n-    ///\n-    /// Slicing to `0` yields an empty slice.\n-    #[unstable = \"will be replaced by slice syntax\"]\n+    /// Deprecated: use `&mut s[.. end]` instead.\n+    #[deprecated = \"use &mut s[.. end] instead\"]\n     fn slice_to_mut(&mut self, end: uint) -> &mut [Self::Item];\n \n     /// Returns an iterator that allows modifying each value\n@@ -712,25 +686,25 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn move_from(&mut self, mut src: Vec<T>, start: uint, end: uint) -> uint {\n-        for (a, b) in self.iter_mut().zip(src.slice_mut(start, end).iter_mut()) {\n+        for (a, b) in self.iter_mut().zip(src[start .. end].iter_mut()) {\n             mem::swap(a, b);\n         }\n         cmp::min(self.len(), end-start)\n     }\n \n     #[inline]\n     fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice(self, start, end)\n+        &self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from<'a>(&'a self, start: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_from(self, start)\n+        &self[start ..]\n     }\n \n     #[inline]\n     fn slice_to<'a>(&'a self, end: uint) -> &'a [T] {\n-        core_slice::SliceExt::slice_to(self, end)\n+        &self[.. end]\n     }\n \n     #[inline]\n@@ -834,17 +808,17 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_mut(self, start, end)\n+        &mut self[start .. end]\n     }\n \n     #[inline]\n     fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_from_mut(self, start)\n+        &mut self[start ..]\n     }\n \n     #[inline]\n     fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [T] {\n-        core_slice::SliceExt::slice_to_mut(self, end)\n+        &mut self[.. end]\n     }\n \n     #[inline]\n@@ -2409,8 +2383,12 @@ mod tests {\n \n     #[test]\n     fn test_chunksator() {\n+        use core::iter::ExactSizeIterator;\n+\n         let v = &[1i,2,3,4,5];\n \n+        assert_eq!(v.chunks(2).len(), 3);\n+\n         let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n         assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n@@ -2476,19 +2454,19 @@ mod tests {\n         }\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n-        test_show_vec!(vec![1i], \"[1i]\");\n-        test_show_vec!(vec![1i, 2, 3], \"[1i, 2i, 3i]\");\n+        test_show_vec!(vec![1i], \"[1]\");\n+        test_show_vec!(vec![1i, 2, 3], \"[1, 2, 3]\");\n         test_show_vec!(vec![vec![], vec![1u], vec![1u, 1u]],\n-                       \"[[], [1u], [1u, 1u]]\");\n+                       \"[[], [1], [1, 1]]\");\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\");\n         let v: &mut[int] = &mut[1];\n-        test_show_vec!(v, \"[1i]\");\n+        test_show_vec!(v, \"[1]\");\n         let v: &mut[int] = &mut[1, 2, 3];\n-        test_show_vec!(v, \"[1i, 2i, 3i]\");\n+        test_show_vec!(v, \"[1, 2, 3]\");\n         let v: &mut [&mut[uint]] = &mut[&mut[], &mut[1u], &mut[1u, 1u]];\n-        test_show_vec!(v, \"[[], [1u], [1u, 1u]]\");\n+        test_show_vec!(v, \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]\n@@ -2675,7 +2653,10 @@ mod tests {\n \n     #[test]\n     fn test_mut_chunks() {\n+        use core::iter::ExactSizeIterator;\n+\n         let mut v = [0u8, 1, 2, 3, 4, 5, 6];\n+        assert_eq!(v.chunks_mut(2).len(), 4);\n         for (i, chunk) in v.chunks_mut(3).enumerate() {\n             for x in chunk.iter_mut() {\n                 *x = i as u8;"}, {"sha": "6608d0ee9a7ec92ddab020fbbb3a17e6f2988dc7", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 22, "deletions": 60, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -750,67 +750,17 @@ pub trait StrExt: Index<FullRange, Output = str> {\n         core_str::StrExt::lines_any(&self[])\n     }\n \n-    /// Returns a slice of the given string from the byte range\n-    /// [`begin`..`end`).\n-    ///\n-    /// This operation is `O(1)`.\n-    ///\n-    /// Panics when `begin` and `end` do not point to valid characters\n-    /// or point beyond the last character of the string.\n-    ///\n-    /// See also `slice_to` and `slice_from` for slicing prefixes and\n-    /// suffixes of strings, and `slice_chars` for slicing based on\n-    /// code point counts.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```rust\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// assert_eq!(s.slice(0, 1), \"L\");\n-    ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n-    ///\n-    /// // these will panic:\n-    /// // byte 2 lies within `\u00f6`:\n-    /// // s.slice(2, 3);\n-    ///\n-    /// // byte 8 lies within `\u8001`\n-    /// // s.slice(1, 8);\n-    ///\n-    /// // byte 100 is outside the string\n-    /// // s.slice(3, 100);\n-    /// ```\n-    #[unstable = \"use slice notation [a..b] instead\"]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(&self[], begin, end)\n-    }\n+    /// Deprecated: use `s[a .. b]` instead.\n+    #[deprecated = \"use slice notation [a..b] instead\"]\n+    fn slice(&self, begin: uint, end: uint) -> &str;\n \n-    /// Returns a slice of the string from `begin` to its end.\n-    ///\n-    /// Equivalent to `self.slice(begin, self.len())`.\n-    ///\n-    /// Panics when `begin` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_to` and `slice_chars`.\n-    #[unstable = \"use slice notation [a..] instead\"]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(&self[], begin)\n-    }\n+    /// Deprecated: use `s[a..]` instead.\n+    #[deprecated = \"use slice notation [a..] instead\"]\n+    fn slice_from(&self, begin: uint) -> &str;\n \n-    /// Returns a slice of the string from the beginning to byte\n-    /// `end`.\n-    ///\n-    /// Equivalent to `self.slice(0, end)`.\n-    ///\n-    /// Panics when `end` does not point to a valid character, or is\n-    /// out of bounds.\n-    ///\n-    /// See also `slice`, `slice_from` and `slice_chars`.\n-    #[unstable = \"use slice notation [..a] instead\"]\n-    fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(&self[], end)\n-    }\n+    /// Deprecated: use `s[..a]` instead.\n+    #[deprecated = \"use slice notation [..a] instead\"]\n+    fn slice_to(&self, end: uint) -> &str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -1348,7 +1298,19 @@ pub trait StrExt: Index<FullRange, Output = str> {\n }\n \n #[stable]\n-impl StrExt for str {}\n+impl StrExt for str {\n+    fn slice(&self, begin: uint, end: uint) -> &str {\n+        &self[begin..end]\n+    }\n+\n+    fn slice_from(&self, begin: uint) -> &str {\n+        &self[begin..]\n+    }\n+\n+    fn slice_to(&self, end: uint) -> &str {\n+        &self[..end]\n+    }\n+}\n \n #[cfg(test)]\n mod tests {"}, {"sha": "c965aedbc5d2f3267e23ab4fe94af0ad68aeb69a", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -18,6 +18,7 @@ use core::prelude::*;\n \n use core::borrow::{Cow, IntoCow};\n use core::default::Default;\n+use core::error::Error;\n use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n@@ -40,6 +41,7 @@ pub struct String {\n \n /// A possible error value from the `String::from_utf8` function.\n #[stable]\n+#[derive(Show)]\n pub struct FromUtf8Error {\n     bytes: Vec<u8>,\n     error: Utf8Error,\n@@ -48,6 +50,7 @@ pub struct FromUtf8Error {\n /// A possible error value from the `String::from_utf16` function.\n #[stable]\n #[allow(missing_copy_implementations)]\n+#[derive(Show)]\n pub struct FromUtf16Error(());\n \n impl String {\n@@ -680,30 +683,28 @@ impl FromUtf8Error {\n     pub fn utf8_error(&self) -> Utf8Error { self.error }\n }\n \n-impl fmt::Show for FromUtf8Error {\n+#[stable]\n+impl fmt::Display for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(&self.error, f)\n     }\n }\n \n #[stable]\n-impl fmt::String for FromUtf8Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&self.error, f)\n-    }\n+impl Error for FromUtf8Error {\n+    fn description(&self) -> &str { \"invalid utf-8\" }\n }\n \n-impl fmt::Show for FromUtf16Error {\n+#[stable]\n+impl fmt::Display for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n \n #[stable]\n-impl fmt::String for FromUtf16Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n-    }\n+impl Error for FromUtf16Error {\n+    fn description(&self) -> &str { \"invalid utf-16\" }\n }\n \n #[stable]\n@@ -814,18 +815,18 @@ impl Default for String {\n }\n \n #[stable]\n-impl fmt::String for String {\n+impl fmt::Display for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&**self, f)\n+        fmt::Display::fmt(&**self, f)\n     }\n }\n \n-#[unstable = \"waiting on fmt stabilization\"]\n-impl fmt::Show for String {\n+#[stable]\n+impl fmt::Debug for String {\n     #[inline]\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(&**self, f)\n+        fmt::Debug::fmt(&**self, f)\n     }\n }\n \n@@ -848,27 +849,31 @@ impl<'a> Add<&'a str> for String {\n     }\n }\n \n+#[stable]\n impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n         &self[][*index]\n     }\n }\n+#[stable]\n impl ops::Index<ops::FullRange> for String {\n     type Output = str;\n     #[inline]\n@@ -934,7 +939,7 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n-impl<T: fmt::String + ?Sized> ToString for T {\n+impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n@@ -1295,10 +1300,10 @@ mod tests {\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n         assert_eq!(format!(\"{:?}\", x), \"[]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1i]\");\n-        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1i, 2i, 3i]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1, 2, 3]\");\n         assert!(format!(\"{:?}\", vec![vec![], vec![1i], vec![1i, 1]]) ==\n-               \"[[], [1i], [1i, 1i]]\");\n+               \"[[], [1], [1, 1]]\");\n     }\n \n     #[test]"}, {"sha": "52590297a6afa6db04f711f104e7fc1224f78349", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1229,7 +1229,7 @@ impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Index stability\"]\n+#[stable]\n impl<T> Index<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1239,6 +1239,7 @@ impl<T> Index<uint> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> IndexMut<uint> for Vec<T> {\n     type Output = T;\n \n@@ -1249,27 +1250,31 @@ impl<T> IndexMut<uint> for Vec<T> {\n }\n \n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1278,27 +1283,31 @@ impl<T> ops::Index<ops::FullRange> for Vec<T> {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for Vec<T> {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n         self.as_mut_slice().index_mut(index)\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     type Output = [T];\n     #[inline]\n@@ -1307,7 +1316,6 @@ impl<T> ops::IndexMut<ops::FullRange> for Vec<T> {\n     }\n }\n \n-\n #[stable]\n impl<T> ops::Deref for Vec<T> {\n     type Target = [T];\n@@ -1486,10 +1494,10 @@ impl<T> Default for Vec<T> {\n     }\n }\n \n-#[unstable = \"waiting on Show stability\"]\n-impl<T: fmt::Show> fmt::Show for Vec<T> {\n+#[stable]\n+impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(self.as_slice(), f)\n+        fmt::Debug::fmt(self.as_slice(), f)\n     }\n }\n \n@@ -2158,7 +2166,7 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_1() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        &x[(-1)..];\n+        &x[-1..];\n     }\n \n     #[test]\n@@ -2172,7 +2180,7 @@ mod tests {\n     #[should_fail]\n     fn test_slice_out_of_bounds_3() {\n         let x: Vec<int> = vec![1, 2, 3, 4, 5];\n-        &x[(-1)..4];\n+        &x[-1..4];\n     }\n \n     #[test]"}, {"sha": "f178d5bc7e9ed3aa26246e38517bb694f71ef3af", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -513,7 +513,7 @@ impl<V: Ord> Ord for VecMap<V> {\n }\n \n #[stable]\n-impl<V: fmt::Show> fmt::Show for VecMap<V> {\n+impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"VecMap {{\"));\n \n@@ -990,7 +990,7 @@ mod test_map {\n         map.insert(3, 4i);\n \n         let map_str = format!(\"{:?}\", map);\n-        assert!(map_str == \"VecMap {1: 2i, 3: 4i}\" || map_str == \"{3: 4i, 1: 2i}\");\n+        assert!(map_str == \"VecMap {1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"VecMap {}\");\n     }\n "}, {"sha": "9966f0d4bf7d061d731be5d9f3a1ec480d67b178", "filename": "src/libcore/any.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -34,11 +34,11 @@\n //! use runtime reflection instead.\n //!\n //! ```rust\n-//! use std::fmt::Show;\n+//! use std::fmt::Debug;\n //! use std::any::Any;\n //!\n-//! // Logger function for any type that implements Show.\n-//! fn log<T: Any+Show>(value: &T) {\n+//! // Logger function for any type that implements Debug.\n+//! fn log<T: Any + Debug>(value: &T) {\n //!     let value_any = value as &Any;\n //!\n //!     // try to convert our value to a String.  If successful, we want to\n@@ -55,7 +55,7 @@\n //! }\n //!\n //! // This function wants to log its parameter out prior to doing work with it.\n-//! fn do_work<T: Show+'static>(value: &T) {\n+//! fn do_work<T: Debug + 'static>(value: &T) {\n //!     log(value);\n //!     // ...do some other work\n //! }\n@@ -75,7 +75,7 @@ use mem::transmute;\n use option::Option::{self, Some, None};\n use raw::TraitObject;\n use intrinsics;\n-#[cfg(not(stage0))] use marker::Sized;\n+use marker::Sized;\n \n ///////////////////////////////////////////////////////////////////////////////\n // Any trait\n@@ -175,17 +175,10 @@ pub struct TypeId {\n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been\n     /// instantiated with\n-    #[cfg(not(stage0))]\n     #[unstable = \"may grow a `Reflect` bound soon via marker traits\"]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         TypeId {\n             t: unsafe { intrinsics::type_id::<T>() },\n         }\n     }\n-\n-    /// dox\n-    #[cfg(stage0)]\n-    pub fn of<T: 'static>() -> TypeId {\n-        unsafe { intrinsics::type_id::<T>() }\n-    }\n }"}, {"sha": "a83537e12f7a9cae95cf81e6ef62decbfa3acff1", "filename": "src/libcore/array.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -39,10 +39,10 @@ macro_rules! array_impls {\n                 }\n             }\n \n-            #[unstable = \"waiting for Show to stabilize\"]\n-            impl<T:fmt::Show> fmt::Show for [T; $N] {\n+            #[stable]\n+            impl<T: fmt::Debug> fmt::Debug for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&&self[], f)\n+                    fmt::Debug::fmt(&&self[], f)\n                 }\n             }\n "}, {"sha": "63614aaa4633567b6aaab2e54e84aea1caac5139", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -133,7 +133,6 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-#[derive(Show)]\n pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n@@ -239,14 +238,27 @@ impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwne\n }\n \n #[stable]\n-impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n-    B: fmt::String + ToOwned<T>,\n-    T: fmt::String,\n+impl<'a, T, B: ?Sized> fmt::Debug for Cow<'a, T, B> where\n+    B: fmt::Debug + ToOwned<T>,\n+    T: fmt::Debug,\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            Borrowed(ref b) => fmt::String::fmt(b, f),\n-            Owned(ref o) => fmt::String::fmt(o, f),\n+            Borrowed(ref b) => fmt::Debug::fmt(b, f),\n+            Owned(ref o) => fmt::Debug::fmt(o, f),\n+        }\n+    }\n+}\n+\n+#[stable]\n+impl<'a, T, B: ?Sized> fmt::Display for Cow<'a, T, B> where\n+    B: fmt::Display + ToOwned<T>,\n+    T: fmt::Display,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Borrowed(ref b) => fmt::Display::fmt(b, f),\n+            Owned(ref o) => fmt::Display::fmt(o, f),\n         }\n     }\n }"}, {"sha": "9ff38028df9f30e246552b7b7e93ec326fdafc61", "filename": "src/libcore/error.rs", "status": "renamed", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ferror.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -14,14 +14,15 @@\n //!\n //! `Error` is a trait representing the basic expectations for error values,\n //! i.e. values of type `E` in `Result<T, E>`. At a minimum, errors must provide\n-//! a description, but they may optionally provide additional detail and cause\n-//! chain information:\n+//! a description, but they may optionally provide additional detail (via\n+//! `Display`) and cause chain information:\n //!\n //! ```\n-//! trait Error {\n+//! use std::fmt::Display;\n+//!\n+//! trait Error: Display {\n //!     fn description(&self) -> &str;\n //!\n-//!     fn detail(&self) -> Option<String> { None }\n //!     fn cause(&self) -> Option<&Error> { None }\n //! }\n //! ```\n@@ -80,20 +81,15 @@\n \n #![stable]\n \n-use prelude::v1::*;\n-\n-use str::Utf8Error;\n-use string::{FromUtf8Error, FromUtf16Error};\n+use prelude::*;\n+use fmt::Display;\n \n /// Base functionality for all errors in Rust.\n #[unstable = \"the exact API of this trait may change\"]\n-pub trait Error {\n+pub trait Error: Display {\n     /// A short description of the error; usually a static string.\n     fn description(&self) -> &str;\n \n-    /// A detailed description of the error, usually including dynamic information.\n-    fn detail(&self) -> Option<String> { None }\n-\n     /// The lower-level cause of this error, if any.\n     fn cause(&self) -> Option<&Error> { None }\n }\n@@ -112,26 +108,3 @@ impl<E> FromError<E> for E {\n         err\n     }\n }\n-\n-#[stable]\n-impl Error for Utf8Error {\n-    fn description(&self) -> &str {\n-        match *self {\n-            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n-            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n-        }\n-    }\n-\n-    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n-}\n-\n-#[stable]\n-impl Error for FromUtf8Error {\n-    fn description(&self) -> &str { \"invalid utf-8\" }\n-    fn detail(&self) -> Option<String> { Some(self.to_string()) }\n-}\n-\n-#[stable]\n-impl Error for FromUtf16Error {\n-    fn description(&self) -> &str { \"invalid utf-16\" }\n-}", "previous_filename": "src/libstd/error.rs"}, {"sha": "245dc00d838244cf7746107a3e7773eef1aa2cfc", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -179,7 +179,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         _ => ()\n     }\n \n-    buf.slice_to_mut(end).reverse();\n+    buf[..end].reverse();\n \n     // Remember start of the fractional digits.\n     // Points one beyond end of buf if none get generated,\n@@ -316,7 +316,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             impl<'a> fmt::Writer for Filler<'a> {\n                 fn write_str(&mut self, s: &str) -> fmt::Result {\n-                    slice::bytes::copy_memory(self.buf.slice_from_mut(*self.end),\n+                    slice::bytes::copy_memory(&mut self.buf[(*self.end)..],\n                                               s.as_bytes());\n                     *self.end += s.len();\n                     Ok(())"}, {"sha": "0e8d31a62eed99f3c0cbab5a048d903ea4020327", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 91, "deletions": 51, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -26,12 +26,15 @@ use ops::{Deref, FnOnce};\n use result;\n use slice::SliceExt;\n use slice;\n-use str::{self, StrExt, Utf8Error};\n+use str::{self, StrExt};\n \n pub use self::num::radix;\n pub use self::num::Radix;\n pub use self::num::RadixFmt;\n \n+#[cfg(stage0)] pub use self::Debug as Show;\n+#[cfg(stage0)] pub use self::Display as String;\n+\n mod num;\n mod float;\n pub mod rt;\n@@ -46,7 +49,7 @@ pub type Result = result::Result<(), Error>;\n /// occurred. Any extra information must be arranged to be transmitted through\n /// some other means.\n #[unstable = \"core and I/O reconciliation may alter this definition\"]\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub struct Error;\n \n /// A collection of methods that are required to format a message into a stream.\n@@ -133,7 +136,7 @@ pub struct Argument<'a> {\n impl<'a> Argument<'a> {\n     #[inline(never)]\n     fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n-        Show::fmt(x, f)\n+        Display::fmt(x, f)\n     }\n \n     fn new<'b, T>(x: &'b T, f: fn(&T, &mut Formatter) -> Result) -> Argument<'b> {\n@@ -214,35 +217,65 @@ pub struct Arguments<'a> {\n     args: &'a [Argument<'a>],\n }\n \n-impl<'a> Show for Arguments<'a> {\n+#[stable]\n+impl<'a> Debug for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n-        String::fmt(self, fmt)\n+        Display::fmt(self, fmt)\n     }\n }\n \n #[stable]\n-impl<'a> String for Arguments<'a> {\n+impl<'a> Display for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n     }\n }\n \n /// Format trait for the `:?` format. Useful for debugging, most all types\n /// should implement this.\n-#[unstable = \"I/O and core have yet to be reconciled\"]\n+#[deprecated = \"renamed to Debug\"]\n+#[cfg(not(stage0))]\n pub trait Show {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+/// Format trait for the `:?` format. Useful for debugging, most all types\n+/// should implement this.\n+#[unstable = \"I/O and core have yet to be reconciled\"]\n+pub trait Debug {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T: Show + ?Sized> Debug for T {\n+    #[allow(deprecated)]\n+    fn fmt(&self, f: &mut Formatter) -> Result { Show::fmt(self, f) }\n+}\n+\n+/// When a value can be semantically expressed as a String, this trait may be\n+/// used. It corresponds to the default format, `{}`.\n+#[deprecated = \"renamed to Display\"]\n+#[cfg(not(stage0))]\n+pub trait String {\n+    /// Formats the value using the given formatter.\n+    fn fmt(&self, &mut Formatter) -> Result;\n+}\n+\n /// When a value can be semantically expressed as a String, this trait may be\n /// used. It corresponds to the default format, `{}`.\n #[unstable = \"I/O and core have yet to be reconciled\"]\n-pub trait String {\n+pub trait Display {\n     /// Formats the value using the given formatter.\n     fn fmt(&self, &mut Formatter) -> Result;\n }\n \n+#[cfg(not(stage0))]\n+impl<T: String + ?Sized> Display for T {\n+    #[allow(deprecated)]\n+    fn fmt(&self, f: &mut Formatter) -> Result { String::fmt(self, f) }\n+}\n \n /// Format trait for the `o` character\n #[unstable = \"I/O and core have yet to be reconciled\"]\n@@ -583,9 +616,10 @@ impl<'a> Formatter<'a> {\n     pub fn precision(&self) -> Option<uint> { self.precision }\n }\n \n-impl Show for Error {\n+#[stable]\n+impl Display for Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(\"an error occurred when formatting an argument\", f)\n+        Display::fmt(\"an error occurred when formatting an argument\", f)\n     }\n }\n \n@@ -611,32 +645,36 @@ pub fn argumentuint<'a>(s: &'a uint) -> Argument<'a> {\n macro_rules! fmt_refs {\n     ($($tr:ident),*) => {\n         $(\n+        #[stable]\n         impl<'a, T: ?Sized + $tr> $tr for &'a T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n+        #[stable]\n         impl<'a, T: ?Sized + $tr> $tr for &'a mut T {\n             fn fmt(&self, f: &mut Formatter) -> Result { $tr::fmt(&**self, f) }\n         }\n         )*\n     }\n }\n \n-fmt_refs! { Show, String, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n+fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }\n \n-impl Show for bool {\n+#[stable]\n+impl Debug for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(self, f)\n+        Display::fmt(self, f)\n     }\n }\n \n #[stable]\n-impl String for bool {\n+impl Display for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(if *self { \"true\" } else { \"false\" }, f)\n+        Display::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-impl Show for str {\n+#[stable]\n+impl Debug for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         try!(write!(f, \"\\\"\"));\n         for c in self.chars().flat_map(|c| c.escape_default()) {\n@@ -647,13 +685,14 @@ impl Show for str {\n }\n \n #[stable]\n-impl String for str {\n+impl Display for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-impl Show for char {\n+#[stable]\n+impl Debug for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n         try!(write!(f, \"'\"));\n@@ -665,15 +704,16 @@ impl Show for char {\n }\n \n #[stable]\n-impl String for char {\n+impl Display for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n         let s: &str = unsafe { mem::transmute(&utf8[..amt]) };\n-        String::fmt(s, f)\n+        Display::fmt(s, f)\n     }\n }\n \n+#[stable]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.flags |= 1 << (rt::FlagAlternate as uint);\n@@ -683,18 +723,21 @@ impl<T> Pointer for *const T {\n     }\n }\n \n+#[stable]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n+#[stable]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n+#[stable]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Pointer::fmt(&(&**self as *const T), f)\n@@ -703,15 +746,15 @@ impl<'a, T> Pointer for &'a mut T {\n \n macro_rules! floating { ($ty:ident) => {\n \n-    impl Show for $ty {\n+    #[stable]\n+    impl Debug for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n-            try!(String::fmt(self, fmt));\n-            fmt.write_str(stringify!($ty))\n+            Display::fmt(self, fmt)\n         }\n     }\n \n     #[stable]\n-    impl String for $ty {\n+    impl Display for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n \n@@ -732,6 +775,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n+    #[stable]\n     impl LowerExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -753,6 +797,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n+    #[stable]\n     impl UpperExp for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -777,12 +822,14 @@ macro_rules! floating { ($ty:ident) => {\n floating! { f32 }\n floating! { f64 }\n \n-// Implementation of Show for various core types\n+// Implementation of Display/Debug for various core types\n \n-impl<T> Show for *const T {\n+#[stable]\n+impl<T> Debug for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-impl<T> Show for *mut T {\n+#[stable]\n+impl<T> Debug for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n \n@@ -793,7 +840,8 @@ macro_rules! peel {\n macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<$($name:Show),*> Show for ($($name,)*) {\n+        #[stable]\n+        impl<$($name:Debug),*> Debug for ($($name,)*) {\n             #[allow(non_snake_case, unused_assignments)]\n             fn fmt(&self, f: &mut Formatter) -> Result {\n                 try!(write!(f, \"(\"));\n@@ -818,11 +866,13 @@ macro_rules! tuple {\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<'a> Show for &'a (any::Any+'a) {\n+#[stable]\n+impl<'a> Debug for &'a (any::Any+'a) {\n     fn fmt(&self, f: &mut Formatter) -> Result { f.pad(\"&Any\") }\n }\n \n-impl<T: Show> Show for [T] {\n+#[stable]\n+impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n             try!(write!(f, \"[\"));\n@@ -843,20 +893,22 @@ impl<T: Show> Show for [T] {\n     }\n }\n \n-impl Show for () {\n+#[stable]\n+impl Debug for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n     }\n }\n \n-impl<T: Copy + Show> Show for Cell<T> {\n+#[stable]\n+impl<T: Copy + Debug> Debug for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, \"Cell {{ value: {:?} }}\", self.get())\n     }\n }\n \n-#[unstable]\n-impl<T: Show> Show for RefCell<T> {\n+#[stable]\n+impl<T: Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.try_borrow() {\n             Some(val) => write!(f, \"RefCell {{ value: {:?} }}\", val),\n@@ -865,29 +917,17 @@ impl<T: Show> Show for RefCell<T> {\n     }\n }\n \n-impl<'b, T: Show> Show for Ref<'b, T> {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(&**self, f)\n-    }\n-}\n-\n-impl<'b, T: Show> Show for RefMut<'b, T> {\n+#[stable]\n+impl<'b, T: Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        Show::fmt(&*(self.deref()), f)\n+        Debug::fmt(&**self, f)\n     }\n }\n \n #[stable]\n-impl String for Utf8Error {\n+impl<'b, T: Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        match *self {\n-            Utf8Error::InvalidByte(n) => {\n-                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n-            }\n-            Utf8Error::TooShort => {\n-                write!(f, \"invalid utf-8: byte slice too short\")\n-            }\n-        }\n+        Debug::fmt(&*(self.deref()), f)\n     }\n }\n "}, {"sha": "c456b3379e8d36b8729d96f9d932422ef8080b95", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -154,13 +154,14 @@ pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n \n macro_rules! radix_fmt {\n     ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n-        impl fmt::Show for RadixFmt<$T, Radix> {\n+        #[stable]\n+        impl fmt::Debug for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                try!(fmt::String::fmt(self, f));\n-                f.write_str($S)\n+                fmt::Display::fmt(self, f)\n             }\n         }\n-        impl fmt::String for RadixFmt<$T, Radix> {\n+        #[stable]\n+        impl fmt::Display for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 match *self { RadixFmt(ref x, radix) => radix.$fmt(*x as $U, f) }\n             }\n@@ -169,6 +170,7 @@ macro_rules! radix_fmt {\n }\n macro_rules! int_base {\n     ($Trait:ident for $T:ident as $U:ident -> $Radix:ident) => {\n+        #[stable]\n         impl fmt::$Trait for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 $Radix.fmt_int(*self as $U, f)\n@@ -179,10 +181,10 @@ macro_rules! int_base {\n \n macro_rules! show {\n     ($T:ident with $S:expr) => {\n-        impl fmt::Show for $T {\n+        #[stable]\n+        impl fmt::Debug for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                try!(fmt::String::fmt(self, f));\n-                f.write_str($S)\n+                fmt::Display::fmt(self, f)\n             }\n         }\n     }\n@@ -192,15 +194,15 @@ macro_rules! integer {\n         integer! { $Int, $Uint, stringify!($Int), stringify!($Uint) }\n     };\n     ($Int:ident, $Uint:ident, $SI:expr, $SU:expr) => {\n-        int_base! { String   for $Int as $Int   -> Decimal }\n+        int_base! { Display  for $Int as $Int   -> Decimal }\n         int_base! { Binary   for $Int as $Uint  -> Binary }\n         int_base! { Octal    for $Int as $Uint  -> Octal }\n         int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n         int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n         radix_fmt! { $Int as $Int, fmt_int, $SI }\n         show! { $Int with $SI }\n \n-        int_base! { String   for $Uint as $Uint -> Decimal }\n+        int_base! { Display  for $Uint as $Uint -> Decimal }\n         int_base! { Binary   for $Uint as $Uint -> Binary }\n         int_base! { Octal    for $Uint as $Uint -> Octal }\n         int_base! { LowerHex for $Uint as $Uint -> LowerHex }"}, {"sha": "dd488a74216ebac19c47d37e57558118a74fde5b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -44,8 +44,6 @@\n \n use marker::Sized;\n \n-#[cfg(stage0)] use any::TypeId;\n-\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n@@ -208,12 +206,8 @@ extern \"rust-intrinsic\" {\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n-    #[cfg(not(stage0))]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n-    #[cfg(stage0)]\n-    pub fn type_id<T: ?Sized + 'static>() -> TypeId;\n-\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "773ac99b0dee2ff803f85430105c4a1c20596218", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 80, "deletions": 36, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -99,6 +99,20 @@ pub trait Iterator {\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n }\n \n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#[old_impl_check]\n+impl<'a, T> Iterator for &'a mut (Iterator<Item=T> + 'a) {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        (**self).next()\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}\n+\n /// Conversion from an `Iterator`\n #[stable]\n #[rustc_on_unimplemented=\"a collection of type `{Self}` cannot be \\\n@@ -2701,63 +2715,93 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n+macro_rules! range_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n+            #[inline]\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n+            }\n+\n+            #[inline]\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n+                debug_assert!(self.end >= self.start);\n+                let hint = (self.end - self.start) as uint;\n+                (hint, Some(hint))\n+            }\n+        }\n \n-/// The `Step` trait identifies objects which can be stepped over in both\n-/// directions. The `steps_between` function provides a way to\n-/// compare two Step objects (it could be provided using `step()` and `Ord`,\n-/// but the implementation would be so inefficient as to be useless).\n-#[unstable = \"design of range notation/iteration is in flux\"]\n-pub trait Step: Ord {\n-    /// Change self to the next object.\n-    fn step(&mut self);\n-    /// Change self to the previous object.\n-    fn step_back(&mut self);\n-    /// The steps_between two step objects.\n-    /// start should always be less than end, so the result should never be negative.\n-    /// Return None if it is not possible to calculate steps_between without\n-    /// overflow.\n-    fn steps_between(start: &Self, end: &Self) -> Option<uint>;\n+        #[stable]\n+        impl ExactSizeIterator for ::ops::Range<$t> {}\n+    )*)\n }\n \n-macro_rules! step_impl {\n+macro_rules! range_impl_no_hint {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n-            #[inline]\n-            fn step(&mut self) { *self += 1; }\n-            #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+        #[stable]\n+        impl Iterator for ::ops::Range<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn steps_between(start: &$t, end: &$t) -> Option<uint> {\n-                debug_assert!(end >= start);\n-                Some((*end - *start) as uint)\n+            fn next(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    let result = self.start;\n+                    self.start += 1;\n+                    return Some(result);\n+                }\n+\n+                return None;\n             }\n         }\n     )*)\n }\n \n-macro_rules! step_impl_no_between {\n+macro_rules! range_other_impls {\n     ($($t:ty)*) => ($(\n-        #[unstable = \"Trait is unstable.\"]\n-        impl Step for $t {\n-            #[inline]\n-            fn step(&mut self) { *self += 1; }\n+        #[stable]\n+        impl DoubleEndedIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn step_back(&mut self) { *self -= 1; }\n+            fn next_back(&mut self) -> Option<$t> {\n+                if self.start < self.end {\n+                    self.end -= 1;\n+                    return Some(self.end);\n+                }\n+\n+                return None;\n+            }\n+        }\n+\n+        #[stable]\n+        impl Iterator for ::ops::RangeFrom<$t> {\n+            type Item = $t;\n+\n             #[inline]\n-            fn steps_between(_start: &$t, _end: &$t) -> Option<uint> {\n-                None\n+            fn next(&mut self) -> Option<$t> {\n+                let result = self.start;\n+                self.start += 1;\n+                debug_assert!(result < self.start);\n+                return Some(result);\n             }\n         }\n     )*)\n }\n \n-step_impl!(uint u8 u16 u32 int i8 i16 i32);\n+range_impl!(uint u8 u16 u32 int i8 i16 i32);\n #[cfg(target_pointer_width = \"64\")]\n-step_impl!(u64 i64);\n+range_impl!(u64 i64);\n #[cfg(target_pointer_width = \"32\")]\n-step_impl_no_between!(u64 i64);\n+range_impl_no_hint!(u64 i64);\n \n+range_other_impls!(uint u8 u16 u32 u64 int i8 i16 i32 i64);\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]"}, {"sha": "1e271f972b13132bc125c7183bf624546d0a9d7e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -63,6 +63,8 @@\n #![feature(unboxed_closures)]\n #![allow(unknown_features)] #![feature(int_uint)]\n #![feature(on_unimplemented)]\n+// FIXME(#21363) remove `old_impl_check` when bug is fixed\n+#![feature(old_impl_check)]\n #![deny(missing_docs)]\n \n #[macro_use]\n@@ -136,6 +138,7 @@ pub mod slice;\n pub mod str;\n pub mod hash;\n pub mod fmt;\n+pub mod error;\n \n // note: does not need to be public\n mod tuple;"}, {"sha": "a987a0a5068a887341e585b5da5c31f35c1bf7d8", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -376,16 +376,6 @@ pub struct ContravariantLifetime<'a>;\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n pub struct InvariantLifetime<'a>;\n \n-/// A type which is considered \"not sendable\", meaning that it cannot\n-/// be safely sent between tasks, even if it is owned. This is\n-/// typically embedded in other types, such as `Gc`, to ensure that\n-/// their instances remain thread-local.\n-#[unstable = \"likely to change with new variance strategy\"]\n-#[lang=\"no_send_bound\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub struct NoSend;\n-\n /// A type which is considered \"not POD\", meaning that it is not\n /// implicitly copyable. This is typically embedded in other types to\n /// ensure that they are never copied, even if they lack a destructor.\n@@ -395,15 +385,6 @@ pub struct NoSend;\n #[allow(missing_copy_implementations)]\n pub struct NoCopy;\n \n-/// A type which is considered \"not sync\", meaning that\n-/// its contents are not threadsafe, hence they cannot be\n-/// shared between tasks.\n-#[unstable = \"likely to change with new variance strategy\"]\n-#[lang=\"no_sync_bound\"]\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub struct NoSync;\n-\n /// A type which is considered managed by the GC. This is typically\n /// embedded in other types.\n #[unstable = \"likely to change with new variance strategy\"]"}, {"sha": "372596cdd44ecfb3c30c5be0e7ec974f00c80c39", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 17, "deletions": 98, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -33,8 +33,6 @@\n //! demonstrates adding and subtracting two `Point`s.\n //!\n //! ```rust\n-//! #![feature(associated_types)]\n-//!\n //! use std::ops::{Add, Sub};\n //!\n //! #[derive(Show)]\n@@ -69,10 +67,7 @@\n \n #![stable]\n \n-use clone::Clone;\n-use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use marker::Sized;\n-use option::Option::{self, Some, None};\n use fmt;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n@@ -164,8 +159,6 @@ macro_rules! forward_ref_binop {\n /// calling `add`, and therefore, `main` prints `Adding!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Add;\n ///\n /// #[derive(Copy)]\n@@ -219,8 +212,6 @@ add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `sub`, and therefore, `main` prints `Subtracting!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Sub;\n ///\n /// #[derive(Copy)]\n@@ -274,8 +265,6 @@ sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `mul`, and therefore, `main` prints `Multiplying!`.\n ///\n /// ```rust\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Mul;\n ///\n /// #[derive(Copy)]\n@@ -329,8 +318,6 @@ mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `div`, and therefore, `main` prints `Dividing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Div;\n ///\n /// #[derive(Copy)]\n@@ -384,8 +371,6 @@ div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n /// calling `rem`, and therefore, `main` prints `Remainder-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Rem;\n ///\n /// #[derive(Copy)]\n@@ -458,8 +443,6 @@ rem_float_impl! { f64, fmod }\n /// `neg`, and therefore, `main` prints `Negating!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Neg;\n ///\n /// struct Foo;\n@@ -537,8 +520,6 @@ neg_uint_impl! { u64, i64 }\n /// `not`, and therefore, `main` prints `Not-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Not;\n ///\n /// struct Foo;\n@@ -593,8 +574,6 @@ not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitand`, and therefore, `main` prints `Bitwise And-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitAnd;\n ///\n /// #[derive(Copy)]\n@@ -648,8 +627,6 @@ bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitor`, and therefore, `main` prints `Bitwise Or-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitOr;\n ///\n /// #[derive(Copy)]\n@@ -703,8 +680,6 @@ bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `bitxor`, and therefore, `main` prints `Bitwise Xor-ing!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::BitXor;\n ///\n /// #[derive(Copy)]\n@@ -758,8 +733,6 @@ bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n /// calling `shl`, and therefore, `main` prints `Shifting left!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Shl;\n ///\n /// #[derive(Copy)]\n@@ -831,8 +804,6 @@ shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// calling `shr`, and therefore, `main` prints `Shifting right!`.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Shr;\n ///\n /// #[derive(Copy)]\n@@ -924,10 +895,12 @@ shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n /// }\n /// ```\n #[lang=\"index\"]\n+#[stable]\n pub trait Index<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index<'a>(&'a self, index: &Index) -> &'a Self::Output;\n }\n \n@@ -960,80 +933,41 @@ pub trait Index<Index: ?Sized> {\n /// }\n /// ```\n #[lang=\"index_mut\"]\n+#[stable]\n pub trait IndexMut<Index: ?Sized> {\n     type Output: ?Sized;\n \n     /// The method for the indexing (`Foo[Bar]`) operation\n+    #[stable]\n     fn index_mut<'a>(&'a mut self, index: &Index) -> &'a mut Self::Output;\n }\n \n /// An unbounded range.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"full_range\"]\n-#[unstable = \"API still in development\"]\n+#[unstable = \"may be renamed to RangeFull\"]\n pub struct FullRange;\n \n-#[unstable = \"API still in development\"]\n-impl fmt::Show for FullRange {\n+#[stable]\n+impl fmt::Debug for FullRange {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(\"..\", fmt)\n+        fmt::Debug::fmt(\"..\", fmt)\n     }\n }\n \n /// A (half-open) range which is bounded at both ends.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct Range<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for Range<Idx> {\n-    type Item = Idx;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            let result = self.start.clone();\n-            self.start.step();\n-            return Some(result);\n-        }\n-\n-        return None;\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        if let Some(hint) = Step::steps_between(&self.start, &self.end) {\n-            (hint, Some(hint))\n-        } else {\n-            (0, None)\n-        }\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<Idx> {\n-        if self.start < self.end {\n-            self.end.step_back();\n-            return Some(self.end.clone());\n-        }\n-\n-        return None;\n-    }\n-}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n-\n-#[unstable = \"API still in development\"]\n-impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n+#[stable]\n+impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n     }\n@@ -1042,27 +976,16 @@ impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n /// A range which is only bounded below.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_from\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeFrom<Idx> {\n     /// The lower bound of the range (inclusive).\n     pub start: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n-    type Item = Idx;\n \n-    #[inline]\n-    fn next(&mut self) -> Option<Idx> {\n-        // Deliberately overflow so we loop forever.\n-        let result = self.start.clone();\n-        self.start.step();\n-        return Some(result);\n-    }\n-}\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n+#[stable]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}..\", self.start)\n     }\n@@ -1071,14 +994,14 @@ impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n /// A range which is only bounded above.\n #[derive(Copy, Clone, PartialEq, Eq)]\n #[lang=\"range_to\"]\n-#[unstable = \"API still in development\"]\n+#[stable]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n-#[unstable = \"API still in development\"]\n-impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n+#[stable]\n+impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"..{:?}\", self.end)\n     }\n@@ -1094,8 +1017,6 @@ impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n /// struct.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::Deref;\n ///\n /// struct DerefExample<T> {\n@@ -1149,8 +1070,6 @@ impl<'a, T: ?Sized> Deref for &'a mut T {\n /// struct.\n ///\n /// ```\n-/// #![feature(associated_types)]\n-///\n /// use std::ops::{Deref, DerefMut};\n ///\n /// struct DerefMutExample<T> {"}, {"sha": "c3d49e24978455c5ab75a0c66cf6ab2e14723c25", "filename": "src/libcore/result.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -229,7 +229,7 @@\n use self::Result::{Ok, Err};\n \n use clone::Clone;\n-use fmt::Show;\n+use fmt::Display;\n use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator, ExactSizeIterator};\n use ops::{FnMut, FnOnce};\n use option::Option::{self, None, Some};\n@@ -714,7 +714,7 @@ impl<T, E> Result<T, E> {\n }\n \n #[stable]\n-impl<T, E: Show> Result<T, E> {\n+impl<T, E: Display> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Ok`.\n     ///\n     /// # Panics\n@@ -739,13 +739,13 @@ impl<T, E: Show> Result<T, E> {\n         match self {\n             Ok(t) => t,\n             Err(e) =>\n-                panic!(\"called `Result::unwrap()` on an `Err` value: {:?}\", e)\n+                panic!(\"called `Result::unwrap()` on an `Err` value: {}\", e)\n         }\n     }\n }\n \n #[stable]\n-impl<T: Show, E> Result<T, E> {\n+impl<T: Display, E> Result<T, E> {\n     /// Unwraps a result, yielding the content of an `Err`.\n     ///\n     /// # Panics\n@@ -769,7 +769,7 @@ impl<T: Show, E> Result<T, E> {\n     pub fn unwrap_err(self) -> E {\n         match self {\n             Ok(t) =>\n-                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {:?}\", t),\n+                panic!(\"called `Result::unwrap_err()` on an `Ok` value: {}\", t),\n             Err(e) => e\n         }\n     }"}, {"sha": "ec43a35248e2e69c882ff4f54629394545d66584", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 27, "deletions": 54, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -67,9 +67,6 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn slice<'a>(&'a self, start: uint, end: uint) -> &'a [Self::Item];\n-    fn slice_from<'a>(&'a self, start: uint) -> &'a [Self::Item];\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a [Self::Item];\n     fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n@@ -93,9 +90,6 @@ pub trait SliceExt {\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n-    fn slice_mut<'a>(&'a mut self, start: uint, end: uint) -> &'a mut [Self::Item];\n-    fn slice_from_mut<'a>(&'a mut self, start: uint) -> &'a mut [Self::Item];\n-    fn slice_to_mut<'a>(&'a mut self, end: uint) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn tail_mut<'a>(&'a mut self) -> &'a mut [Self::Item];\n@@ -135,28 +129,6 @@ pub trait SliceExt {\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n-    #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &[T] {\n-        assert!(start <= end);\n-        assert!(end <= self.len());\n-        unsafe {\n-            transmute(RawSlice {\n-                data: self.as_ptr().offset(start as int),\n-                len: (end - start)\n-            })\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, start: uint) -> &[T] {\n-        self.slice(start, self.len())\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &[T] {\n-        self.slice(0, end)\n-    }\n-\n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n@@ -240,7 +212,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        &self[..(self.len() - 1)]\n+        &self[..self.len() - 1]\n     }\n \n     #[inline]\n@@ -291,20 +263,6 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n-    fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::Range { start: start, end: end } )\n-    }\n-\n-    #[inline]\n-    fn slice_from_mut(&mut self, start: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeFrom { start: start } )\n-    }\n-\n-    #[inline]\n-    fn slice_to_mut(&mut self, end: uint) -> &mut [T] {\n-        ops::IndexMut::index_mut(self, &ops::RangeTo { end: end } )\n-    }\n-\n     #[inline]\n     fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n         unsafe {\n@@ -345,13 +303,13 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn tail_mut(&mut self) -> &mut [T] {\n-        self.slice_from_mut(1)\n+        &mut self[1 ..]\n     }\n \n     #[inline]\n     fn init_mut(&mut self) -> &mut [T] {\n         let len = self.len();\n-        self.slice_to_mut(len-1)\n+        &mut self[.. (len - 1)]\n     }\n \n     #[inline]\n@@ -449,7 +407,7 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == &self[(m-n)..]\n+        m >= n && needle == &self[m-n..]\n     }\n \n     #[unstable]\n@@ -483,7 +441,7 @@ impl<T> SliceExt for [T] {\n         self.swap(j, i-1);\n \n         // Step 4: Reverse the (previously) weakly decreasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         true\n     }\n@@ -505,7 +463,7 @@ impl<T> SliceExt for [T] {\n         }\n \n         // Step 2: Reverse the weakly increasing part\n-        self.slice_from_mut(i).reverse();\n+        self[i..].reverse();\n \n         // Step 3: Find the rightmost element equal to or bigger than the pivot (i-1)\n         let mut j = self.len() - 1;\n@@ -522,15 +480,16 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n-        let dst = self.slice_to_mut(min);\n-        let src = src.slice_to(min);\n+        let dst = &mut self[.. min];\n+        let src = &src[.. min];\n         for i in range(0, min) {\n             dst[i].clone_from(&src[i]);\n         }\n         min\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<uint> for [T] {\n     type Output = T;\n \n@@ -541,6 +500,7 @@ impl<T> ops::Index<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<uint> for [T] {\n     type Output = T;\n \n@@ -551,6 +511,7 @@ impl<T> ops::IndexMut<uint> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::Index<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -565,20 +526,23 @@ impl<T> ops::Index<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n+#[stable]\n impl<T> ops::Index<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -587,6 +551,7 @@ impl<T> ops::Index<ops::FullRange> for [T] {\n     }\n }\n \n+#[stable]\n impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -601,13 +566,15 @@ impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n         }\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n     fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -616,6 +583,7 @@ impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n }\n+#[stable]\n impl<T> ops::IndexMut<ops::FullRange> for [T] {\n     type Output = [T];\n     #[inline]\n@@ -973,7 +941,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n             None => self.finish(),\n             Some(idx) => {\n                 let ret = Some(&self.v[..idx]);\n-                self.v = &self.v[(idx + 1)..];\n+                self.v = &self.v[idx + 1..];\n                 ret\n             }\n         }\n@@ -998,7 +966,7 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(&self.v[(idx + 1)..]);\n+                let ret = Some(&self.v[idx + 1..]);\n                 self.v = &self.v[..idx];\n                 ret\n             }\n@@ -1051,7 +1019,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n             Some(idx) => {\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n-                self.v = tail.slice_from_mut(1);\n+                self.v = &mut tail[1..];\n                 Some(head)\n             }\n         }\n@@ -1087,7 +1055,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n                 let tmp = mem::replace(&mut self.v, &mut []);\n                 let (head, tail) = tmp.split_at_mut(idx);\n                 self.v = head;\n-                Some(tail.slice_from_mut(1))\n+                Some(&mut tail[1..])\n             }\n         }\n     }\n@@ -1269,6 +1237,9 @@ impl<'a, T> DoubleEndedIterator for Chunks<'a, T> {\n     }\n }\n \n+#[stable]\n+impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n+\n #[unstable = \"trait is experimental\"]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n@@ -1347,6 +1318,8 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n     }\n }\n \n+#[stable]\n+impl<'a, T> ExactSizeIterator for ChunksMut<'a, T> {}\n \n //\n // Free functions"}, {"sha": "bdac686cb66bd3edfa34607a3c671d4e3ac1d821", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 98, "deletions": 44, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -20,8 +20,10 @@ use self::Searcher::{Naive, TwoWay, TwoWayLong};\n \n use cmp::{self, Eq};\n use default::Default;\n-use iter::range;\n+use error::Error;\n+use fmt;\n use iter::ExactSizeIterator;\n+use iter::range;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n@@ -242,6 +244,30 @@ impl<'a> CharEq for &'a [char] {\n     }\n }\n \n+#[stable]\n+impl Error for Utf8Error {\n+    fn description(&self) -> &str {\n+        match *self {\n+            Utf8Error::TooShort => \"invalid utf-8: not enough bytes\",\n+            Utf8Error::InvalidByte(..) => \"invalid utf-8: corrupt contents\",\n+        }\n+    }\n+}\n+\n+#[stable]\n+impl fmt::Display for Utf8Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Utf8Error::InvalidByte(n) => {\n+                write!(f, \"invalid utf-8: invalid byte at index {}\", n)\n+            }\n+            Utf8Error::TooShort => {\n+                write!(f, \"invalid utf-8: byte slice too short\")\n+            }\n+        }\n+    }\n+}\n+\n /*\n Section: Iterators\n */\n@@ -902,13 +928,13 @@ impl<'a> Iterator for SplitStr<'a> {\n \n         match self.it.next() {\n             Some((from, to)) => {\n-                let ret = Some(self.it.haystack.slice(self.last_end, from));\n+                let ret = Some(&self.it.haystack[self.last_end .. from]);\n                 self.last_end = to;\n                 ret\n             }\n             None => {\n                 self.finished = true;\n-                Some(self.it.haystack.slice(self.last_end, self.it.haystack.len()))\n+                Some(&self.it.haystack[self.last_end .. self.it.haystack.len()])\n             }\n         }\n     }\n@@ -1115,27 +1141,90 @@ mod traits {\n         }\n     }\n \n+    /// Returns a slice of the given string from the byte range\n+    /// [`begin`..`end`).\n+    ///\n+    /// This operation is `O(1)`.\n+    ///\n+    /// Panics when `begin` and `end` do not point to valid characters\n+    /// or point beyond the last character of the string.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```rust\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// assert_eq!(&s[0 .. 1], \"L\");\n+    ///\n+    /// assert_eq!(&s[1 .. 9], \"\u00f6we \u8001\");\n+    ///\n+    /// // these will panic:\n+    /// // byte 2 lies within `\u00f6`:\n+    /// // &s[2 ..3];\n+    ///\n+    /// // byte 8 lies within `\u8001`\n+    /// // &s[1 .. 8];\n+    ///\n+    /// // byte 100 is outside the string\n+    /// // &s[3 .. 100];\n+    /// ```\n+    #[stable]\n     impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::Range<uint>) -> &str {\n-            self.slice(index.start, index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if index.start <= index.end &&\n+               self.is_char_boundary(index.start) &&\n+               self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(index.start, index.end) }\n+            } else {\n+                super::slice_error_fail(self, index.start, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from the beginning to byte\n+    /// `end`.\n+    ///\n+    /// Equivalent to `self[0 .. end]`.\n+    ///\n+    /// Panics when `end` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-            self.slice_to(index.end)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.end) {\n+                unsafe { self.slice_unchecked(0, index.end) }\n+            } else {\n+                super::slice_error_fail(self, 0, index.end)\n+            }\n         }\n     }\n+\n+    /// Returns a slice of the string from `begin` to its end.\n+    ///\n+    /// Equivalent to `self[begin .. self.len()]`.\n+    ///\n+    /// Panics when `begin` does not point to a valid character, or is\n+    /// out of bounds.\n+    #[stable]\n     impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n         fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-            self.slice_from(index.start)\n+            // is_char_boundary checks that the index is in [0, .len()]\n+            if self.is_char_boundary(index.start) {\n+                unsafe { self.slice_unchecked(index.start, self.len()) }\n+            } else {\n+                super::slice_error_fail(self, index.start, self.len())\n+            }\n         }\n     }\n+\n+    #[stable]\n     impl ops::Index<ops::FullRange> for str {\n         type Output = str;\n         #[inline]\n@@ -1147,7 +1236,7 @@ mod traits {\n \n /// Any string that can be represented as a slice\n #[unstable = \"Instead of taking this bound generically, this trait will be \\\n-              replaced with one of slicing syntax, deref coercions, or \\\n+              replaced with one of slicing syntax (&foo[]), deref coercions, or \\\n               a more generic conversion trait\"]\n pub trait Str {\n     /// Work with `self` as a slice.\n@@ -1208,9 +1297,6 @@ pub trait StrExt {\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> uint;\n-    fn slice<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    fn slice_from<'a>(&'a self, begin: uint) -> &'a str;\n-    fn slice_to<'a>(&'a self, end: uint) -> &'a str;\n     fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n@@ -1332,7 +1418,7 @@ impl StrExt for str {\n     fn lines_any(&self) -> LinesAny {\n         fn f(line: &str) -> &str {\n             let l = line.len();\n-            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { line.slice(0, l - 1) }\n+            if l > 0 && line.as_bytes()[l - 1] == b'\\r' { &line[0 .. l - 1] }\n             else { line }\n         }\n \n@@ -1343,38 +1429,6 @@ impl StrExt for str {\n     #[inline]\n     fn char_len(&self) -> uint { self.chars().count() }\n \n-    #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if begin <= end &&\n-           self.is_char_boundary(begin) &&\n-           self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(begin, end) }\n-        } else {\n-            slice_error_fail(self, begin, end)\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_from(&self, begin: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(begin) {\n-            unsafe { self.slice_unchecked(begin, self.len()) }\n-        } else {\n-            slice_error_fail(self, begin, self.len())\n-        }\n-    }\n-\n-    #[inline]\n-    fn slice_to(&self, end: uint) -> &str {\n-        // is_char_boundary checks that the index is in [0, .len()]\n-        if self.is_char_boundary(end) {\n-            unsafe { self.slice_unchecked(0, end) }\n-        } else {\n-            slice_error_fail(self, 0, end)\n-        }\n-    }\n-\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n@@ -1415,7 +1469,7 @@ impl StrExt for str {\n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == &self.as_bytes()[(m-n)..]\n+        m >= n && needle.as_bytes() == &self.as_bytes()[m-n..]\n     }\n \n     #[inline]"}, {"sha": "6ec87203e00306c307ad8fab73c28ba4d9e23891", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![allow(deprecated)]\n+\n use core::finally::{try_finally, Finally};\n use std::thread::Thread;\n "}, {"sha": "eb278d2cc9044366f06f435fa8f813b602451c1d", "filename": "src/libcoretest/fmt/num.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffmt%2Fnum.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -26,11 +26,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", -1i16) == \"-1\");\n     assert!(format!(\"{}\", -1i32) == \"-1\");\n     assert!(format!(\"{}\", -1i64) == \"-1\");\n-    assert!(format!(\"{:?}\", 1i) == \"1i\");\n-    assert!(format!(\"{:?}\", 1i8) == \"1i8\");\n-    assert!(format!(\"{:?}\", 1i16) == \"1i16\");\n-    assert!(format!(\"{:?}\", 1i32) == \"1i32\");\n-    assert!(format!(\"{:?}\", 1i64) == \"1i64\");\n+    assert!(format!(\"{:?}\", 1i) == \"1\");\n+    assert!(format!(\"{:?}\", 1i8) == \"1\");\n+    assert!(format!(\"{:?}\", 1i16) == \"1\");\n+    assert!(format!(\"{:?}\", 1i32) == \"1\");\n+    assert!(format!(\"{:?}\", 1i64) == \"1\");\n     assert!(format!(\"{:b}\", 1i) == \"1\");\n     assert!(format!(\"{:b}\", 1i8) == \"1\");\n     assert!(format!(\"{:b}\", 1i16) == \"1\");\n@@ -57,11 +57,11 @@ fn test_format_int() {\n     assert!(format!(\"{}\", 1u16) == \"1\");\n     assert!(format!(\"{}\", 1u32) == \"1\");\n     assert!(format!(\"{}\", 1u64) == \"1\");\n-    assert!(format!(\"{:?}\", 1u) == \"1u\");\n-    assert!(format!(\"{:?}\", 1u8) == \"1u8\");\n-    assert!(format!(\"{:?}\", 1u16) == \"1u16\");\n-    assert!(format!(\"{:?}\", 1u32) == \"1u32\");\n-    assert!(format!(\"{:?}\", 1u64) == \"1u64\");\n+    assert!(format!(\"{:?}\", 1u) == \"1\");\n+    assert!(format!(\"{:?}\", 1u8) == \"1\");\n+    assert!(format!(\"{:?}\", 1u16) == \"1\");\n+    assert!(format!(\"{:?}\", 1u32) == \"1\");\n+    assert!(format!(\"{:?}\", 1u64) == \"1\");\n     assert!(format!(\"{:b}\", 1u) == \"1\");\n     assert!(format!(\"{:b}\", 1u8) == \"1\");\n     assert!(format!(\"{:b}\", 1u16) == \"1\");\n@@ -94,14 +94,14 @@ fn test_format_int() {\n #[test]\n fn test_format_int_zero() {\n     assert!(format!(\"{}\", 0i) == \"0\");\n-    assert!(format!(\"{:?}\", 0i) == \"0i\");\n+    assert!(format!(\"{:?}\", 0i) == \"0\");\n     assert!(format!(\"{:b}\", 0i) == \"0\");\n     assert!(format!(\"{:o}\", 0i) == \"0\");\n     assert!(format!(\"{:x}\", 0i) == \"0\");\n     assert!(format!(\"{:X}\", 0i) == \"0\");\n \n     assert!(format!(\"{}\", 0u) == \"0\");\n-    assert!(format!(\"{:?}\", 0u) == \"0u\");\n+    assert!(format!(\"{:?}\", 0u) == \"0\");\n     assert!(format!(\"{:b}\", 0u) == \"0\");\n     assert!(format!(\"{:o}\", 0u) == \"0\");\n     assert!(format!(\"{:x}\", 0u) == \"0\");"}, {"sha": "4bbbde6b48cedf8ea62b5e8c5fcdf9b487d4a483", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -585,7 +585,7 @@ fn check_randacc_iter<A, T>(a: T, len: uint) where\n fn test_double_ended_flat_map() {\n     let u = [0u,1];\n     let v = [5u,6,7,8];\n-    let mut it = u.iter().flat_map(|x| v[(*x)..v.len()].iter());\n+    let mut it = u.iter().flat_map(|x| v[*x..v.len()].iter());\n     assert_eq!(it.next_back().unwrap(), &8);\n     assert_eq!(it.next().unwrap(),      &5);\n     assert_eq!(it.next_back().unwrap(), &7);"}, {"sha": "e0623bade5c0eb41ef4cfaba0bb47d31c0398ae9", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use core::cmp::PartialEq;\n-use core::fmt::Show;\n+use core::fmt::Debug;\n use core::num::{NumCast, cast};\n use core::ops::{Add, Sub, Mul, Div, Rem};\n use core::marker::Copy;\n@@ -37,7 +37,7 @@ pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq + NumCast\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Show\n+     + Rem<Output=T> + Debug\n      + Copy\n {\n     assert_eq!(ten.add(two),  cast(12i).unwrap());"}, {"sha": "daccb709890e158e8a83944903d3a04ed5689c93", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -14,11 +14,11 @@ pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n #[test]\n pub fn test_and() {\n     assert_eq!(op1().and(Ok(667i)).unwrap(), 667);\n-    assert_eq!(op1().and(Err::<(), &'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op1().and(Err::<i32, &'static str>(\"bad\")).unwrap_err(),\n                \"bad\");\n \n     assert_eq!(op2().and(Ok(667i)).unwrap_err(), \"sadface\");\n-    assert_eq!(op2().and(Err::<(),&'static str>(\"bad\")).unwrap_err(),\n+    assert_eq!(op2().and(Err::<i32,&'static str>(\"bad\")).unwrap_err(),\n                \"sadface\");\n }\n \n@@ -94,7 +94,7 @@ pub fn test_fmt_default() {\n     let err: Result<int, &'static str> = Err(\"Err\");\n \n     let s = format!(\"{:?}\", ok);\n-    assert_eq!(s, \"Ok(100i)\");\n+    assert_eq!(s, \"Ok(100)\");\n     let s = format!(\"{:?}\", err);\n     assert_eq!(s, \"Err(\\\"Err\\\")\");\n }"}, {"sha": "e524d8de0569342549b485b424786cf98aa013ba", "filename": "src/libcoretest/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibcoretest%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ftuple.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -60,9 +60,9 @@ fn test_tuple_cmp() {\n #[test]\n fn test_show() {\n     let s = format!(\"{:?}\", (1i,));\n-    assert_eq!(s, \"(1i,)\");\n+    assert_eq!(s, \"(1,)\");\n     let s = format!(\"{:?}\", (1i, true));\n-    assert_eq!(s, \"(1i, true)\");\n+    assert_eq!(s, \"(1, true)\");\n     let s = format!(\"{:?}\", (1i, \"hi\", true));\n-    assert_eq!(s, \"(1i, \\\"hi\\\", true)\");\n+    assert_eq!(s, \"(1, \\\"hi\\\", true)\");\n }"}, {"sha": "70f2429282b9adc1f91ffb8768e872f0677ea6be", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -544,7 +544,7 @@ impl Fail {\n     }\n }\n \n-impl fmt::String for Fail {\n+impl fmt::Display for Fail {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ArgumentMissing(ref nm) => {\n@@ -893,7 +893,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                      &ss[last_start..(i + 1)]),\n+                                      &ss[last_start..i + 1]),\n             (B, Cr, OverLim)  => {\n                 *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;"}, {"sha": "0ed32b7bf4f327647378dfe5ec4f5265b23c6b74", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -358,19 +358,19 @@ impl<'a> Id<'a> {\n     ///\n     /// Passing an invalid string (containing spaces, brackets,\n     /// quotes, ...) will return an empty `Err` value.\n-    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Result<Id<'a>, ()> {\n+    pub fn new<Name: IntoCow<'a, String, str>>(name: Name) -> Option<Id<'a>> {\n         let name = name.into_cow();\n         {\n             let mut chars = name.chars();\n             match chars.next() {\n                 Some(c) if is_letter_or_underscore(c) => { ; },\n-                _ => return Err(())\n+                _ => return None\n             }\n             if !chars.all(is_constituent) {\n-                return Err(());\n+                return None\n             }\n         }\n-        return Ok(Id{ name: name });\n+        return Some(Id{ name: name });\n \n         fn is_letter_or_underscore(c: char) -> bool {\n             in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n@@ -874,17 +874,17 @@ r#\"digraph syntax_tree {\n     fn simple_id_construction() {\n         let id1 = Id::new(\"hello\");\n         match id1 {\n-            Ok(_) => {;},\n-            Err(_) => panic!(\"'hello' is not a valid value for id anymore\")\n+            Some(_) => {;},\n+            None => panic!(\"'hello' is not a valid value for id anymore\")\n         }\n     }\n \n     #[test]\n     fn badly_formatted_id() {\n         let id2 = Id::new(\"Weird { struct : ure } !!!\");\n         match id2 {\n-            Ok(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n-            Err(_) => {;}\n+            Some(_) => panic!(\"graphviz id suddenly allows spaces, brackets and stuff\"),\n+            None => {;}\n         }\n     }\n }"}, {"sha": "4e6437a5e761fd88d64d7cf4f57d54d3fc117057", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -124,7 +124,7 @@ impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n     }\n }\n \n-impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n+impl<'a,T:fmt::Debug> fmt::Debug for MaybeOwnedVector<'a,T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_slice().fmt(f)\n     }"}, {"sha": "677a5f37a1be70b184f3cd3fa84cd3e8ae8ec14a", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -4648,13 +4648,13 @@ pub mod funcs {\n             use types::os::arch::c95::c_int;\n             use types::os::common::posix01::sighandler_t;\n \n-            #[cfg(not(target_os = \"android\"))]\n+            #[cfg(not(all(target_os = \"android\", target_arch = \"arm\")))]\n             extern {\n                 pub fn signal(signum: c_int,\n                               handler: sighandler_t) -> sighandler_t;\n             }\n \n-            #[cfg(target_os = \"android\")]\n+            #[cfg(all(target_os = \"android\", target_arch = \"arm\"))]\n             extern {\n                 #[link_name = \"bsd_signal\"]\n                 pub fn signal(signum: c_int,"}, {"sha": "4da07c50c595e5dee2bc1c84b01d4490431392f9", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -180,6 +180,7 @@ use std::io::LineBufferedWriter;\n use std::io;\n use std::mem;\n use std::os;\n+use std::ptr;\n use std::rt;\n use std::slice;\n use std::sync::{Once, ONCE_INIT};\n@@ -239,21 +240,15 @@ struct DefaultLogger {\n }\n \n /// Wraps the log level with fmt implementations.\n-#[derive(Copy, PartialEq, PartialOrd)]\n+#[derive(Copy, PartialEq, PartialOrd, Show)]\n pub struct LogLevel(pub u32);\n \n-impl fmt::Show for LogLevel {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, fmt)\n-    }\n-}\n-\n-impl fmt::String for LogLevel {\n+impl fmt::Display for LogLevel {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let LogLevel(level) = *self;\n         match LOG_LEVEL_NAMES.get(level as uint - 1) {\n-            Some(ref name) => fmt::String::fmt(name, fmt),\n-            None => fmt::String::fmt(&level, fmt)\n+            Some(ref name) => fmt::Display::fmt(name, fmt),\n+            None => fmt::Display::fmt(&level, fmt)\n         }\n     }\n }\n@@ -437,11 +432,11 @@ fn init() {\n             assert!(!DIRECTIVES.is_null());\n             let _directives: Box<Vec<directive::LogDirective>> =\n                 mem::transmute(DIRECTIVES);\n-            DIRECTIVES = 0 as *const Vec<directive::LogDirective>;\n+            DIRECTIVES = ptr::null();\n \n             if !FILTER.is_null() {\n                 let _filter: Box<Regex> = mem::transmute(FILTER);\n-                FILTER = 0 as *const _;\n+                FILTER = ptr::null();\n             }\n         });\n     }"}, {"sha": "3332e06e19e74e25220a5087537ed5100f92085b", "filename": "src/librand/chacha.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrand%2Fchacha.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrand%2Fchacha.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fchacha.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -174,7 +174,7 @@ impl<'a> SeedableRng<&'a [u32]> for ChaChaRng {\n         // reset state\n         self.init(&[0u32; KEY_WORDS]);\n         // set key in place\n-        let key = self.state.slice_mut(4, 4+KEY_WORDS);\n+        let key = &mut self.state[4 .. 4+KEY_WORDS];\n         for (k, s) in key.iter_mut().zip(seed.iter()) {\n             *k = *s;\n         }\n@@ -292,4 +292,3 @@ mod test {\n         }\n     }\n }\n-"}, {"sha": "9c746c69baafcf1f72eafc6df0b5eca5c3a24636", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -103,7 +103,7 @@ impl Writer for SeekableMemWriter {\n \n             // Do the necessary writes\n             if left.len() > 0 {\n-                slice::bytes::copy_memory(self.buf.slice_from_mut(self.pos), left);\n+                slice::bytes::copy_memory(&mut self.buf[self.pos..], left);\n             }\n             if right.len() > 0 {\n                 self.buf.push_all(right);"}, {"sha": "50fe56ff5c0733f2c8369d84ff999d70050e8a87", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -38,6 +38,7 @@ pub use self::EbmlEncoderTag::*;\n pub use self::Error::*;\n \n use std::str;\n+use std::fmt;\n \n pub mod io;\n \n@@ -113,6 +114,13 @@ pub enum Error {\n     IoError(std::io::IoError),\n     ApplicationError(String)\n }\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME: this should be a more useful display form\n+        fmt::Debug::fmt(self, f)\n+    }\n+}\n // --------------------------------------\n \n pub mod reader {"}, {"sha": "c2186a0ec241ce30b2184e05227c96e5dda92a63", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -30,14 +30,15 @@ static MAX_REPEAT: uint = 1000;\n ///\n /// (Once an expression is compiled, it is not possible to produce an error\n /// via searching, splitting or replacing.)\n+#[derive(Show)]\n pub struct Error {\n     /// The *approximate* character index of where the error occurred.\n     pub pos: uint,\n     /// A message describing the error.\n     pub msg: String,\n }\n \n-impl fmt::Show for Error {\n+impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"Regex syntax error near position {}: {:?}\",\n                self.pos, self.msg)\n@@ -518,7 +519,7 @@ impl<'a> Parser<'a> {\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = self.chars[(start+1)..closer].iter().cloned()\n+        let inner = self.chars[start+1..closer].iter().cloned()\n                                                .collect::<String>();\n \n         // Parse the min and max values from the regex."}, {"sha": "1b68ad500caa57820d936bfcd33831bb60faef03", "filename": "src/libregex/re.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -90,10 +90,10 @@ impl Clone for ExNative {\n     }\n }\n \n-impl fmt::String for Regex {\n+impl fmt::Display for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self.as_str(), f)\n+        fmt::Display::fmt(self.as_str(), f)\n     }\n }\n \n@@ -459,7 +459,7 @@ impl<'t> Captures<'t> {\n     pub fn at(&self, i: uint) -> Option<&'t str> {\n         match self.pos(i) {\n             None => None,\n-            Some((s, e)) => Some(self.text.slice(s, e))\n+            Some((s, e)) => Some(&self.text[s.. e])\n         }\n     }\n "}, {"sha": "b48df36a6793118c72b1526bd6ed3ad6d02260bc", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 82, "deletions": 21, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -10,28 +10,55 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic! { E0001, r##\"\n+register_long_diagnostics! {\n+    E0001: r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n     one of the preceeding patterns will match.\n \n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n-\"## }\n+\"##,\n+\n+    E0003: r##\"\n+    Not-a-Number (NaN) values can not be compared for equality and hence can never match\n+    the input to a match expression. To match against NaN values, you should instead use\n+    the `is_nan` method in a guard, as in: x if x.is_nan() => ...\n+\"##,\n+\n+    E0004: r##\"\n+    This error indicates that the compiler can not guarantee a matching pattern for one\n+    or more possible inputs to a match expression. Guaranteed matches are required in order\n+    to assign values to match expressions, or alternatively, determine the flow of execution.\n+\n+    If you encounter this error you must alter your patterns so that every possible value of\n+    the input type is matched. For types with a small number of variants (like enums) you\n+    should probably cover all cases explicitly. Alternatively, the underscore `_` wildcard\n+    pattern can be added after all other patterns to match \"anything else\".\n+\"##,\n+\n+    // FIXME: Remove duplication here?\n+    E0005: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##,\n+\n+    E0006: r##\"\n+    Patterns used to bind names must be irrefutable, that is, they must guarantee that a\n+    name will be extracted in all cases. If you encounter this error you probably need\n+    to use a `match` or `if let` to deal with the possibility of failure.\n+\"##\n+}\n \n register_diagnostics! {\n     E0002,\n-    E0003,\n-    E0004,\n-    E0005,\n-    E0006,\n     E0007,\n     E0008,\n     E0009,\n     E0010,\n     E0011,\n     E0012,\n-    E0013,\n     E0014,\n     E0015,\n     E0016,\n@@ -49,24 +76,58 @@ register_diagnostics! {\n     E0137,\n     E0138,\n     E0139,\n-    E0140,\n     E0152,\n-    E0153,\n-    E0157,\n     E0158,\n     E0161,\n     E0162,\n     E0165,\n-    E0166,\n-    E0167,\n-    E0168,\n-    E0169,\n     E0170,\n-    E0171,\n-    E0172,\n-    E0173,\n-    E0174,\n-    E0177,\n-    E0178,\n-    E0179\n+    E0261, // use of undeclared lifetime name\n+    E0262, // illegal lifetime parameter name\n+    E0263, // lifetime name declared twice in same scope\n+    E0264, // unknown external lang item\n+    E0265, // recursive constant\n+    E0266, // expected item\n+    E0267, // thing inside of a closure\n+    E0268, // thing outside of a loop\n+    E0269, // not all control paths return a value\n+    E0270, // computation may converge in a function marked as diverging\n+    E0271, // type mismatch resolving\n+    E0272, // rustc_on_unimplemented attribute refers to non-existent type parameter\n+    E0273, // rustc_on_unimplemented must have named format arguments\n+    E0274, // rustc_on_unimplemented must have a value\n+    E0275, // overflow evaluating requirement\n+    E0276, // requirement appears on impl method but not on corresponding trait method\n+    E0277, // trait is not implemented for type\n+    E0278, // requirement is not satisfied\n+    E0279, // requirement is not satisfied\n+    E0280, // requirement is not satisfied\n+    E0281, // type implements trait but other trait is required\n+    E0282, // unable to infer enough type information about\n+    E0283, // cannot resolve type\n+    E0284, // cannot resolve type\n+    E0285, // overflow evaluation builtin bounds\n+    E0296, // malformed recursion limit attribute\n+    E0297, // refutable pattern in for loop binding\n+    E0298, // mismatched types between arms\n+    E0299, // mismatched types between arms\n+    E0300, // unexpanded macro\n+    E0301, // cannot mutable borrow in a pattern guard\n+    E0302, // cannot assign in a pattern guard\n+    E0303, // pattern bindings are not allowed after an `@`\n+    E0304, // expected signed integer constant\n+    E0305, // expected constant\n+    E0306, // expected positive integer for repeat count\n+    E0307, // expected constant integer for repeat count\n+    E0308,\n+    E0309, // thing may not live long enough\n+    E0310, // thing may not live long enough\n+    E0311, // thing may not live long enough\n+    E0312, // lifetime of reference outlives lifetime of borrowed content\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0314, // closure outlives stack frame\n+    E0315 // cannot invoke closure outside of its lifetime\n }\n+\n+__build_diagnostic_array! { DIAGNOSTICS }\n+"}, {"sha": "377e5dd39ff57fe7ae0a4f033fffd8925ffa284d", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -54,7 +54,9 @@ extern crate test;\n \n pub use rustc_llvm as llvm;\n \n-mod diagnostics;\n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n \n pub mod back {\n     pub use rustc_back::abi;\n@@ -132,8 +134,6 @@ pub mod lib {\n     pub use llvm;\n }\n \n-__build_diagnostic_array! { DIAGNOSTICS }\n-\n // A private module so that macro-expanded idents like\n // `::rustc::lint::Lint` will also work in `rustc` itself.\n //"}, {"sha": "fef1017b782858030bd90ac1e3e0a9635435bf1c", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1202,17 +1202,17 @@ impl LintPass for UnusedImportBraces {\n         lint_array!(UNUSED_IMPORT_BRACES)\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, view_item: &ast::ViewItem) {\n-        match view_item.node {\n-            ast::ViewItemUse(ref view_path) => {\n+    fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref view_path) => {\n                 match view_path.node {\n-                    ast::ViewPathList(_, ref items, _) => {\n+                    ast::ViewPathList(_, ref items) => {\n                         if items.len() == 1 {\n                             match items[0].node {\n                                 ast::PathListIdent {ref name, ..} => {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n+                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n                                                  &m[]);\n                                 },\n                                 _ => ()\n@@ -1329,7 +1329,7 @@ impl UnusedMut {\n                 let ident = path1.node;\n                 if let ast::BindByValue(ast::MutMutable) = mode {\n                     if !token::get_ident(ident).get().starts_with(\"_\") {\n-                        match mutables.entry(ident.name.uint()) {\n+                        match mutables.entry(ident.name.usize()) {\n                             Vacant(entry) => { entry.insert(vec![id]); },\n                             Occupied(mut entry) => { entry.get_mut().push(id); },\n                         }\n@@ -1709,22 +1709,6 @@ impl LintPass for Stability {\n         }\n     }\n \n-    fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n-        // compiler-generated `extern crate` statements have a dummy span.\n-        if item.span == DUMMY_SP { return }\n-\n-        let id = match item.node {\n-            ast::ViewItemExternCrate(_, _, id) => id,\n-            ast::ViewItemUse(..) => return,\n-        };\n-        let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-            Some(cnum) => cnum,\n-            None => return,\n-        };\n-        let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n-        self.lint(cx, id, item.span);\n-    }\n-\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if self.is_internal(cx, e.span) { return; }\n \n@@ -1776,6 +1760,17 @@ impl LintPass for Stability {\n         if self.is_internal(cx, item.span) { return }\n \n         match item.node {\n+            ast::ItemExternCrate(_) => {\n+                // compiler-generated `extern crate` items have a dummy span.\n+                if item.span == DUMMY_SP { return }\n+\n+                let cnum = match cx.tcx.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => return,\n+                };\n+                let id = ast::DefId { krate: cnum, node: ast::CRATE_NODE_ID };\n+                self.lint(cx, id, item.span);\n+            }\n             ast::ItemTrait(_, _, ref supertraits, _) => {\n                 for t in supertraits.iter() {\n                     if let ast::TraitTyParamBound(ref t, _) = *t {"}, {"sha": "4cbfcf7e91ad1dd914507eaa2afcf4818f28ef54", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -231,30 +231,7 @@ impl LintStore {\n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n \n-        // Insert temporary renamings for a one-time deprecation (#16545)\n-        self.register_renamed(\"unnecessary_typecast\", \"unused_typecasts\");\n-        self.register_renamed(\"unsigned_negate\", \"unsigned_negation\");\n-        self.register_renamed(\"type_limits\", \"unused_comparisons\");\n-        self.register_renamed(\"type_overflow\", \"overflowing_literals\");\n-        self.register_renamed(\"ctypes\", \"improper_ctypes\");\n-        self.register_renamed(\"owned_heap_memory\", \"box_pointers\");\n-        self.register_renamed(\"unused_attribute\", \"unused_attributes\");\n-        self.register_renamed(\"path_statement\", \"path_statements\");\n-        self.register_renamed(\"unused_result\", \"unused_results\");\n-        self.register_renamed(\"non_uppercase_statics\", \"non_upper_case_globals\");\n-        self.register_renamed(\"unnecessary_parens\", \"unused_parens\");\n-        self.register_renamed(\"unnecessary_import_braces\", \"unused_import_braces\");\n-        self.register_renamed(\"unsafe_block\", \"unsafe_blocks\");\n-        self.register_renamed(\"unnecessary_allocation\", \"unused_allocation\");\n-        self.register_renamed(\"missing_doc\", \"missing_docs\");\n-        self.register_renamed(\"unused_extern_crate\", \"unused_extern_crates\");\n-        self.register_renamed(\"unnecessary_qualification\", \"unused_qualifications\");\n-        self.register_renamed(\"unrecognized_lint\", \"unknown_lints\");\n-        self.register_renamed(\"unused_variable\", \"unused_variables\");\n-        self.register_renamed(\"dead_assignment\", \"unused_assignments\");\n-        self.register_renamed(\"unknown_crate_type\", \"unknown_crate_types\");\n-        self.register_renamed(\"variant_size_difference\", \"variant_size_differences\");\n-        self.register_renamed(\"transmute_fat_ptr\", \"fat_ptr_transmutes\");\n+        // Insert temporary renamings for a one-time deprecation\n         self.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");\n \n     }\n@@ -603,14 +580,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(&i.attrs[], |cx| {\n-            run_lints!(cx, check_view_item, i);\n-            cx.visit_ids(|v| v.visit_view_item(i));\n-            visit::walk_view_item(cx, i);\n-        })\n-    }\n-\n     fn visit_pat(&mut self, p: &ast::Pat) {\n         run_lints!(self, check_pat, p);\n         visit::walk_pat(self, p);"}, {"sha": "a4a3f485af1d1034cfe4acc8d460ed8e00c31df4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -128,7 +128,6 @@ pub trait LintPass {\n     fn check_crate(&mut self, _: &Context, _: &ast::Crate) { }\n     fn check_ident(&mut self, _: &Context, _: Span, _: ast::Ident) { }\n     fn check_mod(&mut self, _: &Context, _: &ast::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_view_item(&mut self, _: &Context, _: &ast::ViewItem) { }\n     fn check_foreign_item(&mut self, _: &Context, _: &ast::ForeignItem) { }\n     fn check_item(&mut self, _: &Context, _: &ast::Item) { }\n     fn check_local(&mut self, _: &Context, _: &ast::Local) { }"}, {"sha": "7b71120ba64a6ea9807cb4f53dad5b3b7cc07904", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -40,10 +40,6 @@ pub struct CrateReader<'a> {\n }\n \n impl<'a, 'v> visit::Visitor<'v> for CrateReader<'a> {\n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        self.process_view_item(a);\n-        visit::walk_view_item(self, a);\n-    }\n     fn visit_item(&mut self, a: &ast::Item) {\n         self.process_item(a);\n         visit::walk_item(self, a);\n@@ -64,9 +60,8 @@ fn dump_crates(cstore: &CStore) {\n     })\n }\n \n-fn should_link(i: &ast::ViewItem) -> bool {\n+fn should_link(i: &ast::Item) -> bool {\n     !attr::contains_name(&i.attrs[], \"no_link\")\n-\n }\n \n struct CrateInfo {\n@@ -181,29 +176,10 @@ impl<'a> CrateReader<'a> {\n         }\n     }\n \n-    fn process_view_item(&mut self, i: &ast::ViewItem) {\n-        if !should_link(i) {\n-            return;\n-        }\n-\n-        match self.extract_crate_info(i) {\n-            Some(info) => {\n-                let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      &info.ident[],\n-                                                      &info.name[],\n-                                                      None,\n-                                                      i.span,\n-                                                      PathKind::Crate);\n-                self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n-            }\n-            None => ()\n-        }\n-    }\n-\n-    fn extract_crate_info(&self, i: &ast::ViewItem) -> Option<CrateInfo> {\n+    fn extract_crate_info(&self, i: &ast::Item) -> Option<CrateInfo> {\n         match i.node {\n-            ast::ViewItemExternCrate(ident, ref path_opt, id) => {\n-                let ident = token::get_ident(ident);\n+            ast::ItemExternCrate(ref path_opt) => {\n+                let ident = token::get_ident(i.ident);\n                 debug!(\"resolving extern crate stmt. ident: {} path_opt: {:?}\",\n                        ident, path_opt);\n                 let name = match *path_opt {\n@@ -218,16 +194,34 @@ impl<'a> CrateReader<'a> {\n                 Some(CrateInfo {\n                     ident: ident.get().to_string(),\n                     name: name,\n-                    id: id,\n+                    id: i.id,\n                     should_link: should_link(i),\n                 })\n             }\n             _ => None\n         }\n     }\n \n-    fn process_item(&self, i: &ast::Item) {\n+    fn process_item(&mut self, i: &ast::Item) {\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if !should_link(i) {\n+                    return;\n+                }\n+\n+                match self.extract_crate_info(i) {\n+                    Some(info) => {\n+                        let (cnum, _, _) = self.resolve_crate(&None,\n+                                                              &info.ident[],\n+                                                              &info.name[],\n+                                                              None,\n+                                                              i.span,\n+                                                              PathKind::Crate);\n+                        self.sess.cstore.add_extern_mod_stmt_cnum(info.id, cnum);\n+                    }\n+                    None => ()\n+                }\n+            }\n             ast::ItemForeignMod(ref fm) => {\n                 if fm.abi == abi::Rust || fm.abi == abi::RustIntrinsic {\n                     return;\n@@ -533,7 +527,7 @@ impl<'a> CrateReader<'a> {\n \n #[derive(Copy)]\n pub enum CrateOrString<'a> {\n-    Krate(&'a ast::ViewItem),\n+    Krate(&'a ast::Item),\n     Str(&'a str)\n }\n "}, {"sha": "7b7159da4385df37d9536543846695990caaf599", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -242,7 +242,7 @@ impl MetadataBlob {\n                        ((slice[2] as u32) << 8) |\n                        ((slice[3] as u32) << 0)) as uint;\n             if len + 4 <= slice.len() {\n-                slice.slice(4, len + 4)\n+                &slice[4.. len + 4]\n             } else {\n                 &[] // corrupt or old metadata\n             }"}, {"sha": "1197276b9908ff6f4a3c6b1c7c8ff65cac298f27", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -74,7 +74,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(&elt.data[(elt.start + 4) .. elt.end]) {\n+        if eq_fn(&elt.data[elt.start + 4 .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {"}, {"sha": "d0989160488f2da416d39fef8a5fc143cab3092c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1456,8 +1456,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n         }\n       }\n-      ast::ItemMac(..) => {\n-        // macros are encoded separately\n+      ast::ItemExternCrate(_) | ast::ItemUse(_) |ast::ItemMac(..) => {\n+        // these are encoded separately\n       }\n     }\n }"}, {"sha": "b1043a4152cfc74d1867f49a9313756f49a32483", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -392,11 +392,11 @@ impl<'a> Context<'a> {\n             };\n             let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n-                (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n+                (&file[(rlib_prefix.len()) .. (file.len() - \".rlib\".len())],\n                  true)\n             } else if file.starts_with(dylib_prefix.as_slice()) &&\n                       file.ends_with(dypair.1.as_slice()) {\n-                (file.slice(dylib_prefix.len(), file.len() - dypair.1.len()),\n+                (&file[(dylib_prefix.len()) .. (file.len() - dypair.1.len())],\n                  false)\n             } else {\n                 return FileDoesntMatch"}, {"sha": "943be282103a70a8e640e8a986579962e75f8c1d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -243,19 +243,6 @@ fn parse_size(st: &mut PState) -> Option<uint> {\n     }\n }\n \n-fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        '~' => ty::UniqTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n-        c => {\n-            st.tcx.sess.bug(&format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c)[])\n-        }\n-    }\n-}\n-\n fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n                                              mut f: F)\n                                              -> VecPerParamSpace<T> where\n@@ -641,14 +628,6 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     })\n }\n \n-fn parse_onceness(c: char) -> ast::Onceness {\n-    match c {\n-        'o' => ast::Once,\n-        'm' => ast::Many,\n-        _ => panic!(\"parse_onceness: bad onceness\")\n-    }\n-}\n-\n fn parse_closure_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n                                  mut conv: F) -> ty::ClosureTy<'tcx> where\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n@@ -661,16 +640,10 @@ fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n     F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n {\n     let unsafety = parse_unsafety(next(st));\n-    let onceness = parse_onceness(next(st));\n-    let store = parse_trait_store_(st, conv);\n-    let bounds = parse_existential_bounds_(st, conv);\n     let sig = parse_sig_(st, conv);\n     let abi = parse_abi_set(st);\n     ty::ClosureTy {\n         unsafety: unsafety,\n-        onceness: onceness,\n-        store: store,\n-        bounds: bounds,\n         sig: sig,\n         abi: abi,\n     }\n@@ -734,7 +707,7 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     }\n \n     let crate_part = &buf[0u..colon_idx];\n-    let def_part = &buf[(colon_idx + 1u)..len];\n+    let def_part = &buf[colon_idx + 1u..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "9aead5bf4e7f8ade91c33639a1512e4736f1297a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -305,17 +305,6 @@ pub fn enc_trait_ref<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     enc_substs(w, cx, s.substs);\n }\n \n-pub fn enc_trait_store(w: &mut SeekableMemWriter, cx: &ctxt, s: ty::TraitStore) {\n-    match s {\n-        ty::UniqTraitStore => mywrite!(w, \"~\"),\n-        ty::RegionTraitStore(re, m) => {\n-            mywrite!(w, \"&\");\n-            enc_region(w, cx, re);\n-            enc_mutability(w, m);\n-        }\n-    }\n-}\n-\n fn enc_unsafety(w: &mut SeekableMemWriter, p: ast::Unsafety) {\n     match p {\n         ast::Unsafety::Normal => mywrite!(w, \"n\"),\n@@ -329,13 +318,6 @@ fn enc_abi(w: &mut SeekableMemWriter, abi: Abi) {\n     mywrite!(w, \"]\")\n }\n \n-fn enc_onceness(w: &mut SeekableMemWriter, o: ast::Onceness) {\n-    match o {\n-        ast::Once => mywrite!(w, \"o\"),\n-        ast::Many => mywrite!(w, \"m\")\n-    }\n-}\n-\n pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n@@ -346,9 +328,6 @@ pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n pub fn enc_closure_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n-    enc_onceness(w, ft.onceness);\n-    enc_trait_store(w, cx, ft.store);\n-    enc_existential_bounds(w, cx, &ft.bounds);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }"}, {"sha": "537a2b3f545a2e4579e29beaa36897965b10a26f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -332,8 +332,6 @@ impl Folder for NestedItemsDropper {\n                 }\n             }).collect();\n             let blk_sans_items = P(ast::Block {\n-                view_items: Vec::new(), // I don't know if we need the view_items\n-                                        // here, but it doesn't break tests!\n                 stmts: stmts_sans_items,\n                 expr: expr,\n                 id: id,\n@@ -515,17 +513,6 @@ impl tr for ty::BoundRegion {\n     }\n }\n \n-impl tr for ty::TraitStore {\n-    fn tr(&self, dcx: &DecodeContext) -> ty::TraitStore {\n-        match *self {\n-            ty::RegionTraitStore(r, m) => {\n-                ty::RegionTraitStore(r.tr(dcx), m)\n-            }\n-            ty::UniqTraitStore => ty::UniqTraitStore\n-        }\n-    }\n-}\n-\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n "}, {"sha": "1a2162b3076ece7a2a85affafe7f025635796369", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -424,7 +424,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             }\n \n             ast::ExprMethodCall(_, _, ref args) => {\n-                self.call(expr, pred, &*args[0], args.slice_from(1).iter().map(|e| &**e))\n+                self.call(expr, pred, &*args[0], args[1..].iter().map(|e| &**e))\n             }\n \n             ast::ExprIndex(ref l, ref r) |"}, {"sha": "623f3525d4a90b3111740d20ce7e43b51d50c38a", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -73,12 +73,12 @@ impl<'a> CheckLoopVisitor<'a> {\n         match self.cx {\n             Loop => {}\n             Closure => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` inside of a closure\", name)[]);\n+                span_err!(self.sess, span, E0267,\n+                                   \"`{}` inside of a closure\", name);\n             }\n             Normal => {\n-                self.sess.span_err(span,\n-                                   &format!(\"`{}` outside of loop\", name)[]);\n+                span_err!(self.sess, span, E0268,\n+                                   \"`{}` outside of loop\", name);\n             }\n         }\n     }"}, {"sha": "aa803d9d8aea5b6971bebb648f61e7e250681114", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -57,7 +57,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n /// ++++++++++++++++++++++++++\n /// + _     + [_, _, ..tail] +\n /// ++++++++++++++++++++++++++\n-impl<'a> fmt::Show for Matrix<'a> {\n+impl<'a> fmt::Debug for Matrix<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"\\n\"));\n \n@@ -226,11 +226,10 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n         ast::ExprForLoop(ref pat, _, _, _) => {\n             let mut static_inliner = StaticInliner::new(cx.tcx);\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n-                cx.tcx.sess.span_err(\n-                    pat.span,\n-                    &format!(\"refutable pattern in `for` loop binding: \\\n+                span_err!(cx.tcx.sess, pat.span, E0297,\n+                    \"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat))[]);\n+                            pat_to_string(uncovered_pat));\n             });\n \n             // Check legality of move bindings.\n@@ -869,7 +868,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -882,7 +881,7 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n                 Some(true) => Some(vec![]),\n                 Some(false) => None,\n                 None => {\n-                    cx.tcx.sess.span_err(pat_span, \"mismatched types between arms\");\n+                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n                     None\n                 }\n             }\n@@ -921,13 +920,13 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n \n         ast::PatMac(_) => {\n-            cx.tcx.sess.span_err(pat_span, \"unexpanded macro\");\n+            span_err!(cx.tcx.sess, pat_span, E0300, \"unexpanded macro\");\n             None\n         }\n     };\n     head.map(|mut head| {\n         head.push_all(&r[..col]);\n-        head.push_all(&r[(col + 1)..]);\n+        head.push_all(&r[col + 1..]);\n         head\n     })\n }\n@@ -1082,11 +1081,8 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n               _: LoanCause) {\n         match kind {\n             MutBorrow => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span,\n-                              \"cannot mutably borrow in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0301,\n+                          \"cannot mutably borrow in a pattern guard\")\n             }\n             ImmBorrow | UniqueImmBorrow => {}\n         }\n@@ -1095,10 +1091,7 @@ impl<'a, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'tcx> {\n     fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             JustWrite | WriteAndRead => {\n-                self.cx\n-                    .tcx\n-                    .sess\n-                    .span_err(span, \"cannot assign in a pattern guard\")\n+                span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")\n             }\n             Init => {}\n         }\n@@ -1120,7 +1113,7 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n     fn visit_pat(&mut self, pat: &Pat) {\n         if !self.bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n-            self.cx.tcx.sess.span_err(pat.span,\n+            span_err!(self.cx.tcx.sess, pat.span, E0303,\n                                       \"pattern bindings are not allowed \\\n                                        after an `@`\");\n         }"}, {"sha": "4280b7fe3f09649170a73dc7e37f90873a22fa9f", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -83,7 +83,7 @@ pub fn check_item_recursion<'a>(sess: &'a Session,\n impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &ast::Item) {\n         if self.idstack.iter().any(|x| x == &(it.id)) {\n-            self.sess.span_err(self.root_it.span, \"recursive constant\");\n+            span_err!(self.sess, self.root_it.span, E0265, \"recursive constant\");\n             return;\n         }\n         self.idstack.push(it.id);\n@@ -103,9 +103,9 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                             self.visit_item(item),\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n-                            self.sess.span_err(e.span,\n-                              &format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node))[]);\n+                            span_err!(self.sess, e.span, E0266,\n+                              \"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node));\n                             return;\n                           },\n                         }"}, {"sha": "a17278698103167229069e82b10248c4ff08b49f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -118,17 +118,17 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             assert!(self.bits_per_id > 0);\n             let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n             let (start, end) = self.compute_id_range(cfgidx);\n-            let on_entry = self.on_entry.slice(start, end);\n+            let on_entry = &self.on_entry[start.. end];\n             let entry_str = bits_to_string(on_entry);\n \n-            let gens = self.gens.slice(start, end);\n+            let gens = &self.gens[start.. end];\n             let gens_str = if gens.iter().any(|&u| u != 0) {\n                 format!(\" gen: {}\", bits_to_string(gens))\n             } else {\n                 \"\".to_string()\n             };\n \n-            let kills = self.kills.slice(start, end);\n+            let kills = &self.kills[start .. end];\n             let kills_str = if kills.iter().any(|&u| u != 0) {\n                 format!(\" kill: {}\", bits_to_string(kills))\n             } else {\n@@ -232,7 +232,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice_mut(start, end);\n+        let gens = &mut self.gens[start.. end];\n         set_bit(gens, bit);\n     }\n \n@@ -245,7 +245,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let kills = self.kills.slice_mut(start, end);\n+        let kills = &mut self.kills[start.. end];\n         set_bit(kills, bit);\n     }\n \n@@ -256,9 +256,9 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         assert!(self.bits_per_id > 0);\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         bitwise(bits, gens, &Union);\n-        let kills = self.kills.slice(start, end);\n+        let kills = &self.kills[start.. end];\n         bitwise(bits, kills, &Subtract);\n \n         debug!(\"{} apply_gen_kill(cfgidx={:?}, bits={}) [after]\",\n@@ -304,7 +304,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         }\n \n         let (start, end) = self.compute_id_range(cfgidx);\n-        let on_entry = self.on_entry.slice(start, end);\n+        let on_entry = &self.on_entry[start.. end];\n         let temp_bits;\n         let slice = match e {\n             Entry => on_entry,\n@@ -336,7 +336,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n \n         let cfgidx = to_cfgidx_or_die(id, &self.nodeid_to_index);\n         let (start, end) = self.compute_id_range(cfgidx);\n-        let gens = self.gens.slice(start, end);\n+        let gens = &self.gens[start.. end];\n         debug!(\"{} each_gen_bit(id={}, gens={})\",\n                self.analysis_name, id, bits_to_string(gens));\n         self.each_bit(gens, f)\n@@ -396,15 +396,15 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n         cfg.graph.each_edge(|_edge_index, edge| {\n             let flow_exit = edge.source();\n             let (start, end) = self.compute_id_range(flow_exit);\n-            let mut orig_kills = self.kills.slice(start, end).to_vec();\n+            let mut orig_kills = self.kills[start.. end].to_vec();\n \n             let mut changed = false;\n             for &node_id in edge.data.exiting_scopes.iter() {\n                 let opt_cfg_idx = self.nodeid_to_index.get(&node_id).map(|&i|i);\n                 match opt_cfg_idx {\n                     Some(cfg_idx) => {\n                         let (start, end) = self.compute_id_range(cfg_idx);\n-                        let kills = self.kills.slice(start, end);\n+                        let kills = &self.kills[start.. end];\n                         if bitwise(orig_kills.as_mut_slice(), kills, &Union) {\n                             changed = true;\n                         }\n@@ -418,7 +418,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n             }\n \n             if changed {\n-                let bits = self.kills.slice_mut(start, end);\n+                let bits = &mut self.kills[start.. end];\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n                 bits.clone_from_slice(&orig_kills[]);\n@@ -487,7 +487,7 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n             let (start, end) = self.dfcx.compute_id_range(node_index);\n \n             // Initialize local bitvector with state on-entry.\n-            in_out.clone_from_slice(self.dfcx.on_entry.slice(start, end));\n+            in_out.clone_from_slice(&self.dfcx.on_entry[start.. end]);\n \n             // Compute state on-exit by applying transfer function to\n             // state on-entry.\n@@ -528,13 +528,13 @@ impl<'a, 'b, 'tcx, O:DataFlowOperator> PropagationContext<'a, 'b, 'tcx, O> {\n         let (start, end) = self.dfcx.compute_id_range(cfgidx);\n         let changed = {\n             // (scoping mutable borrow of self.dfcx.on_entry)\n-            let on_entry = self.dfcx.on_entry.slice_mut(start, end);\n+            let on_entry = &mut self.dfcx.on_entry[start.. end];\n             bitwise(on_entry, pred_bits, &self.dfcx.oper)\n         };\n         if changed {\n             debug!(\"{} changed entry set for {:?} to {}\",\n                    self.dfcx.analysis_name, cfgidx,\n-                   bits_to_string(self.dfcx.on_entry.slice(start, end)));\n+                   bits_to_string(&self.dfcx.on_entry[start.. end]));\n             self.changed = true;\n         }\n     }"}, {"sha": "affeef330c4541cbafeae7e255fcb449fc3407b6", "filename": "src/librustc/middle/graph.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fgraph.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -32,7 +32,7 @@\n \n #![allow(dead_code)] // still WIP\n \n-use std::fmt::{Formatter, Error, Show};\n+use std::fmt::{Formatter, Error, Debug};\n use std::uint;\n use std::collections::BitvSet;\n \n@@ -53,7 +53,7 @@ pub struct Edge<E> {\n     pub data: E,\n }\n \n-impl<E: Show> Show for Edge<E> {\n+impl<E: Debug> Debug for Edge<E> {\n     fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {\n         write!(f, \"Edge {{ next_edge: [{:?}, {:?}], source: {:?}, target: {:?}, data: {:?} }}\",\n                self.next_edge[0], self.next_edge[1], self.source,\n@@ -353,7 +353,7 @@ impl<E> Edge<E> {\n #[cfg(test)]\n mod test {\n     use middle::graph::*;\n-    use std::fmt::Show;\n+    use std::fmt::Debug;\n \n     type TestNode = Node<&'static str>;\n     type TestEdge = Edge<&'static str>;\n@@ -408,7 +408,7 @@ mod test {\n         });\n     }\n \n-    fn test_adjacent_edges<N:PartialEq+Show,E:PartialEq+Show>(graph: &Graph<N,E>,\n+    fn test_adjacent_edges<N:PartialEq+Debug,E:PartialEq+Debug>(graph: &Graph<N,E>,\n                                       start_index: NodeIndex,\n                                       start_data: N,\n                                       expected_incoming: &[(E,N)],"}, {"sha": "3280769ff03866bedbb3ad4dd9c0271299674b34", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -202,39 +202,6 @@ pub trait Combine<'tcx> : Sized {\n                          sig: sig})\n     }\n \n-    fn closure_tys(&self, a: &ty::ClosureTy<'tcx>,\n-                   b: &ty::ClosureTy<'tcx>) -> cres<'tcx, ty::ClosureTy<'tcx>> {\n-\n-        let store = match (a.store, b.store) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                let r = try!(self.contraregions(a_r, b_r));\n-                ty::RegionTraitStore(r, a_m)\n-            }\n-\n-            _ if a.store == b.store => {\n-                a.store\n-            }\n-\n-            _ => {\n-                return Err(ty::terr_sigil_mismatch(expected_found(self, a.store, b.store)))\n-            }\n-        };\n-        let unsafety = try!(self.unsafeties(a.unsafety, b.unsafety));\n-        let onceness = try!(self.oncenesses(a.onceness, b.onceness));\n-        let bounds = try!(self.existential_bounds(&a.bounds, &b.bounds));\n-        let sig = try!(self.binders(&a.sig, &b.sig));\n-        let abi = try!(self.abi(a.abi, b.abi));\n-        Ok(ty::ClosureTy {\n-            unsafety: unsafety,\n-            onceness: onceness,\n-            store: store,\n-            bounds: bounds,\n-            sig: sig,\n-            abi: abi,\n-        })\n-    }\n-\n     fn fn_sigs(&self, a: &ty::FnSig<'tcx>, b: &ty::FnSig<'tcx>) -> cres<'tcx, ty::FnSig<'tcx>> {\n         if a.variadic != b.variadic {\n             return Err(ty::terr_variadic_mismatch(expected_found(self, a.variadic, b.variadic)));\n@@ -356,31 +323,6 @@ pub trait Combine<'tcx> : Sized {\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<'tcx, ty::Region>;\n \n-    fn trait_stores(&self,\n-                    vk: ty::terr_vstore_kind,\n-                    a: ty::TraitStore,\n-                    b: ty::TraitStore)\n-                    -> cres<'tcx, ty::TraitStore> {\n-        debug!(\"{}.trait_stores(a={:?}, b={:?})\", self.tag(), a, b);\n-\n-        match (a, b) {\n-            (ty::RegionTraitStore(a_r, a_m),\n-             ty::RegionTraitStore(b_r, b_m)) if a_m == b_m => {\n-                self.contraregions(a_r, b_r).and_then(|r| {\n-                    Ok(ty::RegionTraitStore(r, a_m))\n-                })\n-            }\n-\n-            _ if a == b => {\n-                Ok(a)\n-            }\n-\n-            _ => {\n-                Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n-            }\n-        }\n-    }\n-\n     fn trait_refs(&self,\n                   a: &ty::TraitRef<'tcx>,\n                   b: &ty::TraitRef<'tcx>)"}, {"sha": "18c36f870b5bce09da24a3222f81d46bc56a487f", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -371,12 +371,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::EquatePredicate(_) => \"equality predicate not satisfied\",\n         };\n \n-        self.tcx.sess.span_err(\n-            trace.origin.span(),\n-            &format!(\"{}: {} ({})\",\n+        span_err!(self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr))[]);\n+                 ty::type_err_to_str(self.tcx, terr));\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -443,9 +442,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         match sub {\n             ty::ReFree(ty::FreeRegion {bound_region: ty::BrNamed(..), ..}) => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0309,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -456,9 +454,8 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n+                span_err!(self.tcx.sess, origin.span(), E0310,\n+                    \"{} may not live long enough\", labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -468,11 +465,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n             _ => {\n                 // If not, be less specific.\n-                self.tcx.sess.span_err(\n-                    origin.span(),\n-                    &format!(\n+                span_err!(self.tcx.sess, origin.span(), E0311,\n                         \"{} may not live long enough\",\n-                        labeled_user_string)[]);\n+                        labeled_user_string);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n                     &format!(\n@@ -499,8 +494,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.report_and_explain_type_error(trace, &terr);\n             }\n             infer::Reborrow(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0312,\n                     \"lifetime of reference outlines \\\n                      lifetime of borrowed content...\");\n                 note_and_explain_region(\n@@ -515,14 +509,13 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n-                self.tcx.sess.span_err(\n-                    span,\n-                    &format!(\"lifetime of borrowed pointer outlives \\\n+                span_err!(self.tcx.sess, span, E0313,\n+                    \"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string())[]);\n+                                .to_string());\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n@@ -539,8 +532,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InfStackClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0314,\n                     \"closure outlives stack frame\");\n                 note_and_explain_region(\n                     self.tcx,\n@@ -554,8 +546,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"\");\n             }\n             infer::InvokeClosure(span) => {\n-                self.tcx.sess.span_err(\n-                    span,\n+                span_err!(self.tcx.sess, span, E0315,\n                     \"cannot invoke closure outside of its lifetime\");\n                 note_and_explain_region(\n                     self.tcx,"}, {"sha": "9339f435d8fa01853080f199079612fb11b3ca14", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -609,8 +609,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot)\n                                        -> Vec<RegionVid>\n     {\n-        self.undo_log.borrow()\n-            .slice_from(mark.length)\n+        self.undo_log.borrow()[mark.length..]\n             .iter()\n             .filter_map(|&elt| match elt {\n                 AddVar(vid) => Some(vid),\n@@ -637,7 +636,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             debug!(\"result_index={}, r={:?}\", result_index, r);\n \n             for undo_entry in\n-                self.undo_log.borrow().slice_from(mark.length).iter()\n+                self.undo_log.borrow()[mark.length..].iter()\n             {\n                 match undo_entry {\n                     &AddConstraint(ConstrainVarSubVar(a, b)) => {"}, {"sha": "ed11cafdca9b5573015fe077ba260f729a68f3b6", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -17,7 +17,7 @@ use middle::ty::{self, Ty};\n use middle::infer::{uok, ures};\n use middle::infer::InferCtxt;\n use std::cell::RefCell;\n-use std::fmt::Show;\n+use std::fmt::Debug;\n use syntax::ast;\n use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n@@ -32,7 +32,7 @@ use util::snapshot_vec as sv;\n /// (possibly not yet known) sort of integer.\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey<'tcx, V> : Clone + Show + PartialEq + Repr<'tcx> {\n+pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;"}, {"sha": "2c0de9d16348618359f78709e9739e031031329e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -320,9 +320,7 @@ lets_do_this! {\n     ContravariantLifetimeItem,       \"contravariant_lifetime\",  contravariant_lifetime;\n     InvariantLifetimeItem,           \"invariant_lifetime\",      invariant_lifetime;\n \n-    NoSendItem,                      \"no_send_bound\",           no_send_bound;\n     NoCopyItem,                      \"no_copy_bound\",           no_copy_bound;\n-    NoSyncItem,                      \"no_sync_bound\",           no_sync_bound;\n     ManagedItem,                     \"managed_bound\",           managed_bound;\n \n     NonZeroItem,                     \"non_zero\",                non_zero;"}, {"sha": "43989d0aadc8adf1322e8cc744f4cb7cd13958cf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -198,13 +198,13 @@ pub fn check_crate(tcx: &ty::ctxt) {\n     tcx.sess.abort_if_errors();\n }\n \n-impl fmt::Show for LiveNode {\n+impl fmt::Debug for LiveNode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"ln({})\", self.get())\n     }\n }\n \n-impl fmt::Show for Variable {\n+impl fmt::Debug for Variable {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"v({})\", self.get())\n     }\n@@ -1557,8 +1557,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             },\n                         _ => false\n                     };\n-                    self.ir.tcx.sess.span_err(\n-                        sp, \"not all control paths return a value\");\n+                    span_err!(self.ir.tcx.sess, sp, E0269, \"not all control paths return a value\");\n                     if ends_with_stmt {\n                         let last_stmt = body.stmts.first().unwrap();\n                         let original_span = original_sp(self.ir.tcx.sess.codemap(),\n@@ -1575,7 +1574,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n             ty::FnDiverging\n                 if self.live_on_entry(entry_ln, self.s.clean_exit_var).is_some() => {\n-                    self.ir.tcx.sess.span_err(sp,\n+                    span_err!(self.ir.tcx.sess, sp, E0270,\n                         \"computation may converge in a function marked as diverging\");\n                 }\n "}, {"sha": "b93cde4bf646448b4c315279e1823cf1be0aaa49", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -297,6 +297,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n+                    ast::ItemExternCrate(_) | ast::ItemUse(_) |\n                     ast::ItemTy(..) | ast::ItemStatic(_, _, _) |\n                     ast::ItemMod(..) | ast::ItemForeignMod(..) |\n                     ast::ItemImpl(..) | ast::ItemTrait(..) |"}, {"sha": "81cbdf13c518925c60ef57b9b1d260a42fb8b870", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -33,7 +33,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n             }\n         }\n \n-        sess.span_err(attr.span, \"malformed recursion limit attribute, \\\n+        span_err!(sess, attr.span, E0296, \"malformed recursion limit attribute, \\\n                                   expected #![recursion_limit=\\\"N\\\"]\");\n     }\n }"}, {"sha": "b4b2e1b63e80cfe4c0f950df38c12418ef5160e6", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,9 +22,6 @@ use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n use util::common::can_reach;\n \n use std::cell::RefCell;\n-// NOTE(stage0) remove import after a snapshot\n-#[cfg(stage0)]\n-use std::hash::{Hash};\n use syntax::codemap::Span;\n use syntax::{ast, visit};\n use syntax::ast::{Block, Item, FnDecl, NodeId, Arm, Pat, Stmt, Expr, Local};"}, {"sha": "030bf26699fb23778ee57f58f3d38ceb3724256c", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -94,6 +94,8 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n                     // Fn lifetimes get added in visit_fn below:\n                     visit::walk_item(this, item);\n                 }\n+                ast::ItemExternCrate(_) |\n+                ast::ItemUse(_) |\n                 ast::ItemMod(..) |\n                 ast::ItemMac(..) |\n                 ast::ItemForeignMod(..) |\n@@ -396,10 +398,9 @@ impl<'a> LifetimeContext<'a> {\n     }\n \n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n-        self.sess.span_err(\n-            lifetime_ref.span,\n-            &format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name))[]);\n+        span_err!(self.sess, lifetime_ref.span, E0261,\n+            \"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name));\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -409,11 +410,9 @@ impl<'a> LifetimeContext<'a> {\n             let special_idents = [special_idents::static_lifetime];\n             for lifetime in lifetimes.iter() {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n-                    self.sess.span_err(\n-                        lifetime.lifetime.span,\n-                        &format!(\"illegal lifetime parameter name: `{}`\",\n-                                token::get_name(lifetime.lifetime.name))\n-                        []);\n+                    span_err!(self.sess, lifetime.lifetime.span, E0262,\n+                        \"illegal lifetime parameter name: `{}`\",\n+                                token::get_name(lifetime.lifetime.name));\n                 }\n             }\n \n@@ -422,12 +421,10 @@ impl<'a> LifetimeContext<'a> {\n                 let lifetime_j = &lifetimes[j];\n \n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n-                    self.sess.span_err(\n-                        lifetime_j.lifetime.span,\n-                        &format!(\"lifetime name `{}` declared twice in \\\n+                    span_err!(self.sess, lifetime_j.lifetime.span, E0263,\n+                        \"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n-                                token::get_name(lifetime_j.lifetime.name))\n-                        []);\n+                                token::get_name(lifetime_j.lifetime.name));\n                 }\n             }\n \n@@ -462,11 +459,11 @@ impl<'a> LifetimeContext<'a> {\n                             format!(\"lifetime name `{}` shadows another \\\n                                     lifetime name that is already in scope\",\n                                     token::get_name(lifetime.name)).as_slice());\n-                        self.sess.span_help(\n+                        self.sess.span_note(\n                             lifetime_def.span,\n                             format!(\"shadowed lifetime `{}` declared here\",\n                                     token::get_name(lifetime.name)).as_slice());\n-                        self.sess.span_help(\n+                        self.sess.span_note(\n                             lifetime.span,\n                             \"shadowed lifetimes are deprecated \\\n                              and will become a hard error before 1.0\");\n@@ -602,7 +599,7 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n     }\n }\n \n-impl<'a> fmt::Show for ScopeChain<'a> {\n+impl<'a> fmt::Debug for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({:?}, {:?})\", space, defs),"}, {"sha": "889d8b4052f0f4d0a73c834dc36f76348da16d68", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -238,7 +238,7 @@ pub struct SeparateVecsPerParamSpace<T> {\n     pub fns: Vec<T>,\n }\n \n-impl<T:fmt::Show> fmt::Show for VecPerParamSpace<T> {\n+impl<T: fmt::Debug> fmt::Debug for VecPerParamSpace<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"VecPerParamSpace {{\"));\n         for space in ParamSpace::all().iter() {\n@@ -373,12 +373,12 @@ impl<T> VecPerParamSpace<T> {\n \n     pub fn get_slice<'a>(&'a self, space: ParamSpace) -> &'a [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice(start, limit)\n+        &self.content[start.. limit]\n     }\n \n     pub fn get_mut_slice<'a>(&'a mut self, space: ParamSpace) -> &'a mut [T] {\n         let (start, limit) = self.limits(space);\n-        self.content.slice_mut(start, limit)\n+        &mut self.content[start.. limit]\n     }\n \n     pub fn opt_get<'a>(&'a self,"}, {"sha": "7ccb5e6e7116022f811c8546b104de064399afac", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -55,12 +55,10 @@ pub fn report_projection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     let predicate =\n         infcx.resolve_type_vars_if_possible(&obligation.predicate);\n     if !predicate.references_error() {\n-        infcx.tcx.sess.span_err(\n-            obligation.cause.span,\n-            format!(\n+        span_err!(infcx.tcx.sess, obligation.cause.span, E0271,\n                 \"type mismatch resolving `{}`: {}\",\n                 predicate.user_string(infcx.tcx),\n-                ty::type_err_to_str(infcx.tcx, &error.err)).as_slice());\n+                ty::type_err_to_str(infcx.tcx, &error.err));\n         note_obligation_cause(infcx, obligation);\n     }\n }\n@@ -97,28 +95,25 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                             Position::ArgumentNamed(s) => match generic_map.get(s) {\n                                 Some(val) => Some(val.as_slice()),\n                                 None => {\n-                                    infcx.tcx.sess\n-                                         .span_err(err_sp,\n-                                                   format!(\"the #[rustc_on_unimplemented] \\\n+                                    span_err!(infcx.tcx.sess, err_sp, E0272,\n+                                                   \"the #[rustc_on_unimplemented] \\\n                                                             attribute on \\\n                                                             trait definition for {} refers to \\\n                                                             non-existent type parameter {}\",\n-                                                           trait_str, s)\n-                                                   .as_slice());\n+                                                           trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n                             },\n                             _ => {\n-                                infcx.tcx.sess\n-                                     .span_err(err_sp,\n-                                               format!(\"the #[rustc_on_unimplemented] \\\n+                                     span_err!(infcx.tcx.sess, err_sp, E0273,\n+                                               \"the #[rustc_on_unimplemented] \\\n                                                         attribute on \\\n                                                         trait definition for {} must have named \\\n                                                         format arguments, \\\n                                                         eg `#[rustc_on_unimplemented = \\\n                                                         \\\"foo {{T}}\\\"]`\",\n-                                                       trait_str).as_slice());\n+                                                       trait_str);\n                                 errored = true;\n                                 None\n                             }\n@@ -130,11 +125,11 @@ fn report_on_unimplemented<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                     report = Some(err);\n                 }\n             } else {\n-                infcx.tcx.sess.span_err(err_sp,\n-                                        format!(\"the #[rustc_on_unimplemented] attribute on \\\n+                span_err!(infcx.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n                                                  trait definition for {} must have a value, \\\n                                                  eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                 trait_str).as_slice());\n+                                                 trait_str);\n             }\n             break;\n         }\n@@ -151,11 +146,9 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             // We could track the stack here more precisely if we wanted, I imagine.\n             let predicate =\n                 infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-            infcx.tcx.sess.span_err(\n-                obligation.cause.span,\n-                format!(\n+            span_err!(infcx.tcx.sess, obligation.cause.span, E0275,\n                     \"overflow evaluating the requirement `{}`\",\n-                    predicate.user_string(infcx.tcx)).as_slice());\n+                    predicate.user_string(infcx.tcx));\n \n             suggest_new_overflow_limit(infcx.tcx, obligation.cause.span);\n \n@@ -165,12 +158,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n         SelectionError::Unimplemented => {\n             match &obligation.cause.code {\n                 &ObligationCauseCode::CompareImplMethodObligation => {\n-                    infcx.tcx.sess.span_err(\n-                        obligation.cause.span,\n-                        format!(\n+                    span_err!(infcx.tcx.sess, obligation.cause.span, E0276,\n                             \"the requirement `{}` appears on the impl \\\n                             method but not on the corresponding trait method\",\n-                            obligation.predicate.user_string(infcx.tcx)).as_slice());\n+                            obligation.predicate.user_string(infcx.tcx));;\n                 }\n                 _ => {\n                     match obligation.predicate {\n@@ -180,12 +171,10 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n                             if !trait_predicate.references_error() {\n                                 let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0277,\n                                         \"the trait `{}` is not implemented for the type `{}`\",\n                                         trait_ref.user_string(infcx.tcx),\n-                                        trait_ref.self_ty().user_string(infcx.tcx)).as_slice());\n+                                        trait_ref.self_ty().user_string(infcx.tcx));\n                                 // Check if it has a custom \"#[rustc_on_unimplemented]\"\n                                 // error message, report with that message if it does\n                                 let custom_note = report_on_unimplemented(infcx, &*trait_ref.0,\n@@ -200,35 +189,29 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         ty::Predicate::Equate(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.equality_predicate(obligation.cause.span,\n-                                                               &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                                                               &predicate).err().unwrap();\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0278,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::RegionOutlives(ref predicate) => {\n                             let predicate = infcx.resolve_type_vars_if_possible(predicate);\n                             let err = infcx.region_outlives_predicate(obligation.cause.span,\n-                                                                      &predicate).unwrap_err();\n-                            infcx.tcx.sess.span_err(\n-                                obligation.cause.span,\n-                                format!(\n+                                                                      &predicate).err().unwrap();\n+                            span_err!(infcx.tcx.sess, obligation.cause.span, E0279,\n                                     \"the requirement `{}` is not satisfied (`{}`)\",\n                                     predicate.user_string(infcx.tcx),\n-                                    ty::type_err_to_str(infcx.tcx, &err)).as_slice());\n+                                    ty::type_err_to_str(infcx.tcx, &err));\n                         }\n \n                         ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n                                 let predicate =\n                                     infcx.resolve_type_vars_if_possible(&obligation.predicate);\n-                                infcx.tcx.sess.span_err(\n-                                    obligation.cause.span,\n-                                    format!(\n+                                span_err!(infcx.tcx.sess, obligation.cause.span, E0280,\n                                         \"the requirement `{}` is not satisfied\",\n-                                        predicate.user_string(infcx.tcx)).as_slice());\n+                                        predicate.user_string(infcx.tcx));\n                         }\n                     }\n                 }\n@@ -239,15 +222,13 @@ pub fn report_selection_error<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n             let expected_trait_ref = infcx.resolve_type_vars_if_possible(&*expected_trait_ref);\n             let actual_trait_ref = infcx.resolve_type_vars_if_possible(&*actual_trait_ref);\n             if !ty::type_is_error(actual_trait_ref.self_ty()) {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0281,\n                         \"type mismatch: the type `{}` implements the trait `{}`, \\\n                         but the trait `{}` is required ({})\",\n                         expected_trait_ref.self_ty().user_string(infcx.tcx),\n                         expected_trait_ref.user_string(infcx.tcx),\n                         actual_trait_ref.user_string(infcx.tcx),\n-                        ty::type_err_to_str(infcx.tcx, e)).as_slice());\n+                        ty::type_err_to_str(infcx.tcx, e));\n                     note_obligation_cause(infcx, obligation);\n             }\n         }\n@@ -293,18 +274,14 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n                         infcx.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0282,\n                                 \"unable to infer enough type information about `{}`; \\\n                                  type annotations required\",\n-                                self_ty.user_string(infcx.tcx)).as_slice());\n+                                self_ty.user_string(infcx.tcx));\n                     } else {\n-                        infcx.tcx.sess.span_err(\n-                            obligation.cause.span,\n-                            format!(\n+                        span_err!(infcx.tcx.sess, obligation.cause.span, E0283,\n                                 \"type annotations required: cannot resolve `{}`\",\n-                                predicate.user_string(infcx.tcx)).as_slice());\n+                                predicate.user_string(infcx.tcx));;\n                         note_obligation_cause(infcx, obligation);\n                     }\n                 }\n@@ -323,11 +300,9 @@ pub fn maybe_report_ambiguity<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n \n         _ => {\n             if !infcx.tcx.sess.has_errors() {\n-                infcx.tcx.sess.span_err(\n-                    obligation.cause.span,\n-                    format!(\n+                span_err!(infcx.tcx.sess, obligation.cause.span, E0284,\n                         \"type annotations required: cannot resolve `{}`\",\n-                        predicate.user_string(infcx.tcx)).as_slice());\n+                        predicate.user_string(infcx.tcx));;\n                 note_obligation_cause(infcx, obligation);\n             }\n         }"}, {"sha": "568286e39d597df84be12997581b347890fcbd5b", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -84,6 +84,7 @@ pub struct FulfillmentContext<'tcx> {\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n }\n \n+#[derive(Clone)]\n pub struct RegionObligation<'tcx> {\n     pub sub_region: ty::Region,\n     pub sup_type: Ty<'tcx>,"}, {"sha": "89459f95b879fe730c020fc9ab88ae94309b54ba", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -379,11 +379,10 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n             false\n         }\n         Err(Overflow) => {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                format!(\"overflow evaluating whether `{}` is `{}`\",\n-                        ty.user_string(infcx.tcx),\n-                        bound.user_string(infcx.tcx)).as_slice());\n+            span_err!(infcx.tcx.sess, span, E0285,\n+                \"overflow evaluating whether `{}` is `{}`\",\n+                      ty.user_string(infcx.tcx),\n+                      bound.user_string(infcx.tcx));\n             suggest_new_overflow_limit(infcx.tcx, span);\n             false\n         }"}, {"sha": "e8d82150ade4bd2888c9d06ad5c93b7e1beafd4d", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1554,10 +1554,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let tcx = this.tcx();\n             match bound {\n                 ty::BoundSend => {\n-                    if\n-                        Some(def_id) == tcx.lang_items.no_send_bound() ||\n-                        Some(def_id) == tcx.lang_items.managed_bound()\n-                    {\n+                    if Some(def_id) == tcx.lang_items.managed_bound() {\n                         return Err(Unimplemented)\n                     }\n                 }\n@@ -1568,7 +1565,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 ty::BoundSync => {\n                     if\n-                        Some(def_id) == tcx.lang_items.no_sync_bound() ||\n                         Some(def_id) == tcx.lang_items.managed_bound() ||\n                         Some(def_id) == tcx.lang_items.unsafe_type()\n                     {"}, {"sha": "bdf9b16f139602346c2d3b88d34d2009ff0733fd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -236,13 +236,13 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n     infcx.fresh_substs_for_generics(span, &impl_generics)\n }\n \n-impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {\n+impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableImpl({:?})\", self.impl_def_id)\n     }\n }\n \n-impl<'tcx> fmt::Show for super::VtableObjectData<'tcx> {\n+impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableObject(...)\")\n     }\n@@ -449,7 +449,7 @@ impl<'tcx> Repr<'tcx> for super::FulfillmentErrorCode<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Show for super::FulfillmentErrorCode<'tcx> {\n+impl<'tcx> fmt::Debug for super::FulfillmentErrorCode<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             super::CodeSelectionError(ref e) => write!(f, \"{:?}\", e),\n@@ -465,7 +465,7 @@ impl<'tcx> Repr<'tcx> for super::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Show for super::MismatchedProjectionTypes<'tcx> {\n+impl<'tcx> fmt::Debug for super::MismatchedProjectionTypes<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"MismatchedProjectionTypes(..)\")\n     }"}, {"sha": "83bbdf14e4a74e4029145df21ded019da80afe00", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 22, "deletions": 90, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -17,7 +17,6 @@ pub use self::InferTy::*;\n pub use self::InferRegion::*;\n pub use self::ImplOrTraitItemId::*;\n pub use self::UnboxedClosureKind::*;\n-pub use self::TraitStore::*;\n pub use self::ast_ty_to_ty_cache_entry::*;\n pub use self::Variance::*;\n pub use self::AutoAdjustment::*;\n@@ -61,7 +60,7 @@ use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n use middle::ty_walk::TypeWalker;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n-use util::ppaux::{trait_store_to_string, ty_to_string};\n+use util::ppaux::ty_to_string;\n use util::ppaux::{Repr, UserString};\n use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -70,7 +69,7 @@ use util::nodemap::{FnvHashMap};\n use arena::TypedArena;\n use std::borrow::{BorrowFrom, Cow};\n use std::cell::{Cell, RefCell};\n-use std::cmp::{self, Ordering};\n+use std::cmp;\n use std::fmt::{self, Show};\n use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n@@ -247,14 +246,6 @@ pub struct mt<'tcx> {\n     pub mutbl: ast::Mutability,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Show)]\n-pub enum TraitStore {\n-    /// Box<Trait>\n-    UniqTraitStore,\n-    /// &Trait and &mut Trait\n-    RegionTraitStore(Region, ast::Mutability),\n-}\n-\n #[derive(Clone, Copy, Show)]\n pub struct field_ty {\n     pub name: Name,\n@@ -934,7 +925,7 @@ pub struct TyS<'tcx> {\n     region_depth: u32,\n }\n \n-impl fmt::Show for TypeFlags {\n+impl fmt::Debug for TypeFlags {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", self.bits)\n     }\n@@ -1041,11 +1032,8 @@ pub struct BareFnTy<'tcx> {\n #[derive(Clone, PartialEq, Eq, Hash, Show)]\n pub struct ClosureTy<'tcx> {\n     pub unsafety: ast::Unsafety,\n-    pub onceness: ast::Onceness,\n-    pub store: TraitStore,\n-    pub bounds: ExistentialBounds<'tcx>,\n-    pub sig: PolyFnSig<'tcx>,\n     pub abi: abi::Abi,\n+    pub sig: PolyFnSig<'tcx>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Show)]\n@@ -1545,7 +1533,6 @@ pub enum type_err<'tcx> {\n     terr_onceness_mismatch(expected_found<Onceness>),\n     terr_abi_mismatch(expected_found<abi::Abi>),\n     terr_mutability,\n-    terr_sigil_mismatch(expected_found<TraitStore>),\n     terr_box_mutability,\n     terr_ptr_mutability,\n     terr_ref_mutability,\n@@ -1559,7 +1546,6 @@ pub enum type_err<'tcx> {\n     terr_regions_no_overlap(Region, Region),\n     terr_regions_insufficiently_polymorphic(BoundRegion, Region),\n     terr_regions_overly_polymorphic(BoundRegion, Region),\n-    terr_trait_stores_differ(terr_vstore_kind, expected_found<TraitStore>),\n     terr_sorts(expected_found<Ty<'tcx>>),\n     terr_integer_as_char,\n     terr_int_mismatch(expected_found<IntVarValue>),\n@@ -1703,37 +1689,37 @@ impl cmp::PartialEq for InferRegion {\n     }\n }\n \n-impl fmt::Show for TyVid {\n+impl fmt::Debug for TyVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result{\n         write!(f, \"_#{}t\", self.index)\n     }\n }\n \n-impl fmt::Show for IntVid {\n+impl fmt::Debug for IntVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}i\", self.index)\n     }\n }\n \n-impl fmt::Show for FloatVid {\n+impl fmt::Debug for FloatVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"_#{}f\", self.index)\n     }\n }\n \n-impl fmt::Show for RegionVid {\n+impl fmt::Debug for RegionVid {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"'_#{}r\", self.index)\n     }\n }\n \n-impl<'tcx> fmt::Show for FnSig<'tcx> {\n+impl<'tcx> fmt::Debug for FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n     }\n }\n \n-impl fmt::Show for InferTy {\n+impl fmt::Debug for InferTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TyVar(ref v) => v.fmt(f),\n@@ -1745,7 +1731,7 @@ impl fmt::Show for InferTy {\n     }\n }\n \n-impl fmt::Show for IntVarValue {\n+impl fmt::Debug for IntVarValue {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             IntType(ref v) => v.fmt(f),\n@@ -3319,7 +3305,7 @@ impl ops::Sub for TypeContents {\n     }\n }\n \n-impl fmt::Show for TypeContents {\n+impl fmt::Debug for TypeContents {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"TypeContents({:b})\", self.bits)\n     }\n@@ -4194,19 +4180,6 @@ pub fn ty_fn_args<'tcx>(fty: Ty<'tcx>) -> ty::Binder<Vec<Ty<'tcx>>> {\n     ty_fn_sig(fty).inputs()\n }\n \n-pub fn ty_closure_store(fty: Ty) -> TraitStore {\n-    match fty.sty {\n-        ty_unboxed_closure(..) => {\n-            // Close enough for the purposes of all the callers of this\n-            // function (which is soon to be deprecated anyhow).\n-            UniqTraitStore\n-        }\n-        ref s => {\n-            panic!(\"ty_closure_store() called on non-closure type: {:?}\", s)\n-        }\n-    }\n-}\n-\n pub fn ty_fn_ret<'tcx>(fty: Ty<'tcx>) -> Binder<FnOutput<'tcx>> {\n     match fty.sty {\n         ty_bare_fn(_, ref f) => f.sig.output(),\n@@ -4751,13 +4724,6 @@ impl<'tcx> Repr<'tcx> for ty::type_err<'tcx> {\n /// afterwards to present additional details, particularly when it comes to lifetime-related\n /// errors.\n pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n-    fn tstore_to_closure(s: &TraitStore) -> String {\n-        match s {\n-            &UniqTraitStore => \"proc\".to_string(),\n-            &RegionTraitStore(..) => \"closure\".to_string()\n-        }\n-    }\n-\n     match *err {\n         terr_cyclic_ty => \"cyclic type of infinite size\".to_string(),\n         terr_mismatch => \"types differ\".to_string(),\n@@ -4776,11 +4742,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                     values.expected,\n                     values.found)\n         }\n-        terr_sigil_mismatch(values) => {\n-            format!(\"expected {}, found {}\",\n-                    tstore_to_closure(&values.expected),\n-                    tstore_to_closure(&values.found))\n-        }\n         terr_mutability => \"values differ in mutability\".to_string(),\n         terr_box_mutability => {\n             \"boxed values differ in mutability\".to_string()\n@@ -4828,11 +4789,6 @@ pub fn type_err_to_str<'tcx>(cx: &ctxt<'tcx>, err: &type_err<'tcx>) -> String {\n                      found bound lifetime parameter {}\",\n                     bound_region_ptr_to_string(cx, br))\n         }\n-        terr_trait_stores_differ(_, ref values) => {\n-            format!(\"trait storage differs: expected `{}`, found `{}`\",\n-                    trait_store_to_string(cx, (*values).expected),\n-                    trait_store_to_string(cx, (*values).found))\n-        }\n         terr_sorts(values) => {\n             // A naive approach to making sure that we're not reporting silly errors such as:\n             // (expected closure, found closure).\n@@ -5089,25 +5045,6 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n     cx.sess.bug(\"couldn't find associated type parameter index\")\n }\n \n-#[derive(Copy, PartialEq, Eq)]\n-pub struct AssociatedTypeInfo {\n-    pub def_id: ast::DefId,\n-    pub index: uint,\n-    pub name: ast::Name,\n-}\n-\n-impl PartialOrd for AssociatedTypeInfo {\n-    fn partial_cmp(&self, other: &AssociatedTypeInfo) -> Option<Ordering> {\n-        Some(self.index.cmp(&other.index))\n-    }\n-}\n-\n-impl Ord for AssociatedTypeInfo {\n-    fn cmp(&self, other: &AssociatedTypeInfo) -> Ordering {\n-        self.index.cmp(&other.index)\n-    }\n-}\n-\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\",\n@@ -5369,15 +5306,13 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                                 discriminant = val as Disr\n                                             }\n                                             Ok(_) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n+                                                span_err!(cx.sess, e.span, E0304,\n                                                             \"expected signed integer constant\");\n                                             }\n                                             Err(ref err) => {\n-                                                cx.sess\n-                                                  .span_err(e.span,\n-                                                            &format!(\"expected constant: {}\",\n-                                                                    *err)[]);\n+                                                span_err!(cx.sess, e.span, E0305,\n+                                                            \"expected constant: {}\",\n+                                                                    *err);\n                                             }\n                                         },\n                                     None => {}\n@@ -5851,9 +5786,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0306,\n                 \"expected positive integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5866,9 +5801,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, &format!(\n+            span_err!(tcx.sess, count_expr.span, E0307,\n                 \"expected constant integer for repeat count, found {}\",\n-                found)[]);\n+                found);\n         }\n     }\n     0\n@@ -7338,11 +7273,8 @@ impl ReferencesError for Region\n \n impl<'tcx> Repr<'tcx> for ClosureTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"ClosureTy({},{},{:?},{},{},{})\",\n+        format!(\"ClosureTy({},{},{})\",\n                 self.unsafety,\n-                self.onceness,\n-                self.store,\n-                self.bounds.repr(tcx),\n                 self.sig.repr(tcx),\n                 self.abi)\n     }\n@@ -7373,5 +7305,5 @@ impl<'a, 'tcx> Repr<'tcx> for ParameterEnvironment<'a, 'tcx> {\n             self.free_substs.repr(tcx),\n             self.implicit_region_bound.repr(tcx),\n             self.caller_bounds.repr(tcx))\n-        }\n     }\n+}"}, {"sha": "b4e6cff954bcc745b94aa07ce6b94f1055539b8f", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -124,10 +124,6 @@ pub trait TypeFolder<'tcx> : Sized {\n         r\n     }\n \n-    fn fold_trait_store(&mut self, s: ty::TraitStore) -> ty::TraitStore {\n-        super_fold_trait_store(self, s)\n-    }\n-\n     fn fold_existential_bounds(&mut self, s: &ty::ExistentialBounds<'tcx>)\n                                -> ty::ExistentialBounds<'tcx> {\n         super_fold_existential_bounds(self, s)\n@@ -225,12 +221,6 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for VecPerParamSpace<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitStore {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitStore {\n-        folder.fold_trait_store(*self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Ty<'tcx> {\n         folder.fold_ty(*self)\n@@ -699,11 +689,8 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                         -> ty::ClosureTy<'tcx>\n {\n     ty::ClosureTy {\n-        store: fty.store.fold_with(this),\n         sig: fty.sig.fold_with(this),\n         unsafety: fty.unsafety,\n-        onceness: fty.onceness,\n-        bounds: fty.bounds.fold_with(this),\n         abi: fty.abi,\n     }\n }\n@@ -726,17 +713,6 @@ pub fn super_fold_mt<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             mutbl: mt.mutbl}\n }\n \n-pub fn super_fold_trait_store<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                         trait_store: ty::TraitStore)\n-                                                         -> ty::TraitStore {\n-    match trait_store {\n-        ty::UniqTraitStore => ty::UniqTraitStore,\n-        ty::RegionTraitStore(r, m) => {\n-            ty::RegionTraitStore(r.fold_with(this), m)\n-        }\n-    }\n-}\n-\n pub fn super_fold_existential_bounds<'tcx, T: TypeFolder<'tcx>>(\n     this: &mut T,\n     bounds: &ty::ExistentialBounds<'tcx>)"}, {"sha": "25cca98c5fb4788af7f1fce215b2444bb43f8579", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -99,9 +99,9 @@ impl<'a> Context<'a> {\n                 self.items.missing.push(lang_items::$item);\n             }\n         } else)* {\n-            self.sess.span_err(span,\n-                               format!(\"unknown external lang item: `{}`\",\n-                                       name).as_slice());\n+            span_err!(self.sess, span, E0264,\n+                               \"unknown external lang item: `{}`\",\n+                                       name);\n         }\n     }\n }"}, {"sha": "c420d1f15b43b1213691b3c7735ddb1635ef80b8", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -73,8 +73,10 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n     // We need to error on `#[macro_use] extern crate` when it isn't at the\n     // crate root, because `$crate` won't work properly. Identify these by\n     // spans, because the crate map isn't set up yet.\n-    for vi in krate.module.view_items.iter() {\n-        loader.span_whitelist.insert(vi.span);\n+    for item in krate.module.items.iter() {\n+        if let ast::ItemExternCrate(_) = item.node {\n+            loader.span_whitelist.insert(item.span);\n+        }\n     }\n \n     visit::walk_crate(&mut loader, krate);\n@@ -91,18 +93,21 @@ pub fn load_plugins(sess: &Session, krate: &ast::Crate,\n \n // note that macros aren't expanded yet, and therefore macros can't add plugins.\n impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n-    fn visit_view_item(&mut self, vi: &ast::ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // We're only interested in `extern crate`.\n-        match vi.node {\n-            ast::ViewItemExternCrate(..) => (),\n-            _ => return,\n+        match item.node {\n+            ast::ItemExternCrate(_) => {}\n+            _ => {\n+                visit::walk_item(self, item);\n+                return;\n+            }\n         }\n \n         // Parse the attributes relating to macro / plugin loading.\n         let mut plugin_attr = None;\n         let mut macro_selection = Some(HashSet::new());  // None => load all\n         let mut reexport = HashSet::new();\n-        for attr in vi.attrs.iter() {\n+        for attr in item.attrs.iter() {\n             let mut used = true;\n             match attr.name().get() {\n                 \"phase\" => {\n@@ -155,7 +160,10 @@ impl<'a, 'v> Visitor<'v> for PluginLoader<'a> {\n             }\n         }\n \n-        self.load_plugin(CrateOrString::Krate(vi), plugin_attr, macro_selection, Some(reexport))\n+        self.load_plugin(CrateOrString::Krate(item),\n+                         plugin_attr,\n+                         macro_selection,\n+                         Some(reexport))\n     }\n \n     fn visit_mac(&mut self, _: &ast::Mac) {"}, {"sha": "a2bba313cca87331810027506a364395f18998ba", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 98, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -249,7 +249,7 @@ pub enum EntryFnType {\n     EntryNone,\n }\n \n-#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash)]\n+#[derive(Copy, PartialEq, PartialOrd, Clone, Ord, Eq, Hash, Show)]\n pub enum CrateType {\n     CrateTypeExecutable,\n     CrateTypeDylib,\n@@ -786,30 +786,14 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n         opt::multi(\"\", \"extern\", \"Specify where an external rust library is \\\n                                 located\",\n                  \"NAME=PATH\"),\n-        opt::opt(\"\", \"opt-level\", \"Optimize with possible levels 0-3\", \"LEVEL\"),\n         opt::opt(\"\", \"sysroot\", \"Override the system root\", \"PATH\"),\n         opt::multi(\"Z\", \"\", \"Set internal debugging options\", \"FLAG\"),\n         opt::opt(\"\", \"color\", \"Configure coloring of output:\n             auto   = colorize, if output goes to a tty (default);\n             always = always colorize output;\n             never  = never colorize output\", \"auto|always|never\"),\n \n-        // DEPRECATED\n-        opt::flag(\"\", \"print-crate-name\", \"Output the crate name and exit\"),\n-        opt::flag(\"\", \"print-file-name\", \"Output the file(s) that would be \\\n-                                        written if compilation \\\n-                                        continued and exit\"),\n-        opt::opt(\"\",  \"debuginfo\",  \"Emit DWARF debug info to the objects created:\n-             0 = no debug info,\n-             1 = line-tables only (for stacktraces and breakpoints),\n-             2 = full debug info with variable and type information \\\n-                    (same as -g)\", \"LEVEL\"),\n-        opt::flag(\"\", \"no-trans\", \"Run all passes except translation; no output\"),\n-        opt::flag(\"\", \"no-analysis\", \"Parse and expand the source, but run no \\\n-                                    analysis and produce no output\"),\n-        opt::flag(\"\", \"parse-only\", \"Parse only; do not compile, assemble, \\\n-                                   or link\"),\n-        opt::flagopt(\"\", \"pretty\",\n+        opt::flagopt_u(\"\", \"pretty\",\n                    \"Pretty-print the input instead of compiling;\n                    valid types are: `normal` (un-annotated source),\n                    `expanded` (crates expanded),\n@@ -823,9 +807,6 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n                       `everybody_loops` (all function bodies replaced with `loop {}`).\",\n                      \"TYPE\"),\n         opt::opt_u(\"\", \"show-span\", \"Show spans for compiler debugging\", \"expr|pat|ty\"),\n-        opt::flagopt(\"\", \"dep-info\",\n-                 \"Output dependency info to <filename> after compiling, \\\n-                  in a format suitable for use by Makefiles\", \"FILENAME\"),\n     ]);\n     opts\n }\n@@ -861,27 +842,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let debugging_opts = build_debugging_options(matches);\n \n-    let parse_only = if matches.opt_present(\"parse-only\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--parse-only is deprecated in favor of -Z parse-only\");\n-        true\n-    } else {\n-        debugging_opts.parse_only\n-    };\n-    let no_trans = if matches.opt_present(\"no-trans\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--no-trans is deprecated in favor of -Z no-trans\");\n-        true\n-    } else {\n-        debugging_opts.no_trans\n-    };\n-    let no_analysis = if matches.opt_present(\"no-analysis\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--no-analysis is deprecated in favor of -Z no-analysis\");\n-        true\n-    } else {\n-        debugging_opts.no_analysis\n-    };\n+    let parse_only = debugging_opts.parse_only;\n+    let no_trans = debugging_opts.no_trans;\n+    let no_analysis = debugging_opts.no_analysis;\n \n     if debugging_opts.debug_llvm {\n         unsafe { llvm::LLVMSetDebug(1); }\n@@ -921,28 +884,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         host_triple().to_string());\n     let opt_level = {\n         if matches.opt_present(\"O\") {\n-            if matches.opt_present(\"opt-level\") {\n-                early_error(\"-O and --opt-level both provided\");\n-            }\n             if cg.opt_level.is_some() {\n                 early_error(\"-O and -C opt-level both provided\");\n             }\n             Default\n-        } else if matches.opt_present(\"opt-level\") {\n-            // FIXME(acrichto) remove this eventually\n-            early_warn(\"--opt-level=N is deprecated in favor of -C opt-level=N\");\n-            match matches.opt_str(\"opt-level\").as_ref().map(|s| s.as_slice()) {\n-                None      |\n-                Some(\"0\") => No,\n-                Some(\"1\") => Less,\n-                Some(\"2\") => Default,\n-                Some(\"3\") => Aggressive,\n-                Some(arg) => {\n-                    early_error(&format!(\"optimization level needs to be \\\n-                                         between 0-3 (instead was `{}`)\",\n-                                        arg)[]);\n-                }\n-            }\n         } else {\n             match cg.opt_level {\n                 None => No,\n@@ -960,27 +905,10 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n     };\n     let gc = debugging_opts.gc;\n     let debuginfo = if matches.opt_present(\"g\") {\n-        if matches.opt_present(\"debuginfo\") {\n-            early_error(\"-g and --debuginfo both provided\");\n-        }\n         if cg.debuginfo.is_some() {\n             early_error(\"-g and -C debuginfo both provided\");\n         }\n         FullDebugInfo\n-    } else if matches.opt_present(\"debuginfo\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--debuginfo=N is deprecated in favor of -C debuginfo=N\");\n-        match matches.opt_str(\"debuginfo\").as_ref().map(|s| s.as_slice()) {\n-            Some(\"0\") => NoDebugInfo,\n-            Some(\"1\") => LimitedDebugInfo,\n-            None      |\n-            Some(\"2\") => FullDebugInfo,\n-            Some(arg) => {\n-                early_error(&format!(\"debug info level needs to be between \\\n-                                     0-2 (instead was `{}`)\",\n-                                    arg)[]);\n-            }\n-        }\n     } else {\n         match cg.debuginfo {\n             None | Some(0) => NoDebugInfo,\n@@ -1036,15 +964,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n     let test = matches.opt_present(\"test\");\n-    let write_dependency_info = if matches.opt_present(\"dep-info\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--dep-info has been deprecated in favor of --emit\");\n-        (true, matches.opt_str(\"dep-info\").map(|p| Path::new(p)))\n-    } else {\n-        (output_types.contains(&OutputTypeDepInfo), None)\n-    };\n+    let write_dependency_info = (output_types.contains(&OutputTypeDepInfo), None);\n \n-    let mut prints = matches.opt_strs(\"print\").into_iter().map(|s| {\n+    let prints = matches.opt_strs(\"print\").into_iter().map(|s| {\n         match s.as_slice() {\n             \"crate-name\" => PrintRequest::CrateName,\n             \"file-names\" => PrintRequest::FileNames,\n@@ -1054,18 +976,6 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n     }).collect::<Vec<_>>();\n-    if matches.opt_present(\"print-crate-name\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--print-crate-name has been deprecated in favor of \\\n-                    --print crate-name\");\n-        prints.push(PrintRequest::CrateName);\n-    }\n-    if matches.opt_present(\"print-file-name\") {\n-        // FIXME(acrichto) remove this eventually\n-        early_warn(\"--print-file-name has been deprecated in favor of \\\n-                    --print file-names\");\n-        prints.push(PrintRequest::FileNames);\n-    }\n \n     if !cg.remark.is_empty() && debuginfo == NoDebugInfo {\n         early_warn(\"-C remark will not show source locations without \\\n@@ -1159,7 +1069,7 @@ pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateTy\n     return Ok(crate_types);\n }\n \n-impl fmt::Show for CrateType {\n+impl fmt::Display for CrateType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             CrateTypeExecutable => \"bin\".fmt(f),"}, {"sha": "4150335abc3d3080ddbc4a7dc3c2c239c1acd787", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -69,65 +69,23 @@ impl Session {\n     pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        self.diagnostic().span_fatal_with_code(sp, msg, code)\n+    }\n     pub fn fatal(&self, msg: &str) -> ! {\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n-        // Conditions for enabling multi-line errors:\n-        if !msg.contains(\"mismatched types\") &&\n-           !msg.contains(\"type mismatch resolving\") &&\n-           !msg.contains(\"if and else have incompatible types\") &&\n-           !msg.contains(\"if may be missing an else clause\") &&\n-           !msg.contains(\"match arms have incompatible types\") &&\n-           !msg.contains(\"structure constructor specifies a structure of type\") {\n-            return self.diagnostic().span_err(sp, msg);\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err(sp, &msg[]),\n+            None => self.diagnostic().span_err(sp, msg)\n         }\n-\n-        let first  = Regex::new(r\"[( ]expected\").unwrap();\n-        let second = Regex::new(r\" found\").unwrap();\n-        let third  = Regex::new(\n-                     r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n-\n-        let mut new_msg = String::new();\n-        let mut head = 0u;\n-\n-        // Insert `\\n` before expected and found.\n-        for (pos1, pos2) in first.find_iter(msg).zip(\n-                            second.find_iter(msg)) {\n-            new_msg = new_msg +\n-            // A `(` may be preceded by a space and it should be trimmed\n-                      msg[head..pos1.0].trim_right() + // prefix\n-                      \"\\n\" +                           // insert before first\n-                      &msg[pos1.0..pos1.1] +           // insert what first matched\n-                      &msg[pos1.1..pos2.0] +           // between matches\n-                      \"\\n   \" +                        // insert before second\n-            //           123\n-            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n-            // 3 spaces prepended.\n-                      &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-            head = pos2.1;\n-        }\n-\n-        let mut tail = &msg[head..];\n-        // Insert `\\n` before any remaining messages which match.\n-        for pos in third.find_iter(tail).take(1) {\n-            // The end of the message may just be wrapped in `()` without `expected`/`found`.\n-            // Push this also to a new line and add the final tail after.\n-            new_msg = new_msg +\n-            // `(` is usually preceded by a space and should be trimmed.\n-                      tail[..pos.0].trim_right() + // prefix\n-                      \"\\n\" +                       // insert before paren\n-                      &tail[pos.0..];              // append the tail\n-\n-            tail = \"\";\n-        }\n-\n-        new_msg.push_str(tail);\n-        self.diagnostic().span_err(sp, &new_msg[])\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n-        self.diagnostic().span_err_with_code(sp, msg, code)\n+        match split_msg_into_multilines(msg) {\n+            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[], code),\n+            None => self.diagnostic().span_err_with_code(sp, msg, code)\n+        }\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().handler().err(msg)\n@@ -285,6 +243,62 @@ impl Session {\n     }\n }\n \n+fn split_msg_into_multilines(msg: &str) -> Option<String> {\n+    // Conditions for enabling multi-line errors:\n+    if !msg.contains(\"mismatched types\") &&\n+        !msg.contains(\"type mismatch resolving\") &&\n+        !msg.contains(\"if and else have incompatible types\") &&\n+        !msg.contains(\"if may be missing an else clause\") &&\n+        !msg.contains(\"match arms have incompatible types\") &&\n+        !msg.contains(\"structure constructor specifies a structure of type\") {\n+            return None\n+    }\n+\n+    let first  = Regex::new(r\"[( ]expected\").unwrap();\n+    let second = Regex::new(r\" found\").unwrap();\n+    let third  = Regex::new(\n+        r\"\\((values differ|lifetime|cyclic type of infinite size)\").unwrap();\n+\n+    let mut new_msg = String::new();\n+    let mut head = 0u;\n+\n+    // Insert `\\n` before expected and found.\n+    for (pos1, pos2) in first.find_iter(msg).zip(\n+        second.find_iter(msg)) {\n+        new_msg = new_msg +\n+            // A `(` may be preceded by a space and it should be trimmed\n+            msg[head..pos1.0].trim_right() + // prefix\n+            \"\\n\" +                           // insert before first\n+            &msg[pos1.0..pos1.1] +           // insert what first matched\n+            &msg[pos1.1..pos2.0] +           // between matches\n+            \"\\n   \" +                        // insert before second\n+            //           123\n+            // `expected` is 3 char longer than `found`. To align the types, `found` gets\n+            // 3 spaces prepended.\n+            &msg[pos2.0..pos2.1];            // insert what second matched\n+\n+        head = pos2.1;\n+    }\n+\n+    let mut tail = &msg[head..];\n+    // Insert `\\n` before any remaining messages which match.\n+    for pos in third.find_iter(tail).take(1) {\n+        // The end of the message may just be wrapped in `()` without `expected`/`found`.\n+        // Push this also to a new line and add the final tail after.\n+        new_msg = new_msg +\n+            // `(` is usually preceded by a space and should be trimmed.\n+            tail[..pos.0].trim_right() + // prefix\n+            \"\\n\" +                       // insert before paren\n+            &tail[pos.0..];              // append the tail\n+\n+        tail = \"\";\n+    }\n+\n+    new_msg.push_str(tail);\n+\n+    return Some(new_msg)\n+}\n+\n pub fn build_session(sopts: config::Options,\n                      local_crate_source_file: Option<Path>,\n                      registry: diagnostics::registry::Registry)"}, {"sha": "dfc27d3ae684d1370611c95d43d75de579724619", "filename": "src/librustc/session/search_paths.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Fsession%2Fsearch_paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fsearch_paths.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -36,13 +36,13 @@ impl SearchPaths {\n \n     pub fn add_path(&mut self, path: &str) {\n         let (kind, path) = if path.starts_with(\"native=\") {\n-            (PathKind::Native, path.slice_from(\"native=\".len()))\n+            (PathKind::Native, &path[\"native=\".len()..])\n         } else if path.starts_with(\"crate=\") {\n-            (PathKind::Crate, path.slice_from(\"crate=\".len()))\n+            (PathKind::Crate, &path[\"crate=\".len()..])\n         } else if path.starts_with(\"dependency=\") {\n-            (PathKind::Dependency, path.slice_from(\"dependency=\".len()))\n+            (PathKind::Dependency, &path[\"dependency=\".len()..])\n         } else if path.starts_with(\"all=\") {\n-            (PathKind::All, path.slice_from(\"all=\".len()))\n+            (PathKind::All, &path[\"all=\".len()..])\n         } else {\n             (PathKind::All, path)\n         };"}, {"sha": "8915d55e2063e7b5fa7ce1c4ffee26bfaedbff3e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -12,7 +12,7 @@\n \n use std::cell::{RefCell, Cell};\n use std::collections::HashMap;\n-use std::fmt::Show;\n+use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::iter::repeat;\n use std::time::Duration;\n@@ -58,7 +58,7 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n }\n \n pub fn indent<R, F>(op: F) -> R where\n-    R: Show,\n+    R: Debug,\n     F: FnOnce() -> R,\n {\n     // Use in conjunction with the log post-processor like `src/etc/indenter`"}, {"sha": "c5aced4eb86f5902a9db6a5d974874705a5b47e1", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 52, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -164,7 +164,7 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n     fn explain_span(cx: &ctxt, heading: &str, span: Span)\n                     -> (String, Option<Span>) {\n         let lo = cx.sess.codemap().lookup_char_pos_adj(span.lo);\n-        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_uint()),\n+        (format!(\"the {} at {}:{}\", heading, lo.line, lo.col.to_usize()),\n          Some(span))\n     }\n }\n@@ -237,15 +237,6 @@ pub fn mt_to_string<'tcx>(cx: &ctxt<'tcx>, m: &mt<'tcx>) -> String {\n         ty_to_string(cx, m.ty))\n }\n \n-pub fn trait_store_to_string(cx: &ctxt, s: ty::TraitStore) -> String {\n-    match s {\n-        ty::UniqTraitStore => \"Box \".to_string(),\n-        ty::RegionTraitStore(r, m) => {\n-            format!(\"{}{}\", region_ptr_to_string(cx, r), mutability_to_string(m))\n-        }\n-    }\n-}\n-\n pub fn vec_map_to_string<T, F>(ts: &[T], f: F) -> String where\n     F: FnMut(&T) -> String,\n {\n@@ -285,7 +276,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             _ => { }\n         }\n \n-        push_sig_to_string(cx, &mut s, '(', ')', sig, \"\");\n+        push_sig_to_string(cx, &mut s, '(', ')', sig);\n \n         match opt_def_id {\n             Some(def_id) => {\n@@ -303,13 +294,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n     fn closure_to_string<'tcx>(cx: &ctxt<'tcx>, cty: &ty::ClosureTy<'tcx>) -> String {\n         let mut s = String::new();\n \n-        match cty.store {\n-            ty::UniqTraitStore => {}\n-            ty::RegionTraitStore(region, _) => {\n-                s.push_str(&region_to_string(cx, \"\", true, region)[]);\n-            }\n-        }\n-\n         match cty.unsafety {\n             ast::Unsafety::Normal => {}\n             ast::Unsafety::Unsafe => {\n@@ -318,24 +302,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             }\n         };\n \n-        let bounds_str = cty.bounds.user_string(cx);\n-\n-        match cty.store {\n-            ty::UniqTraitStore => {\n-                assert_eq!(cty.onceness, ast::Once);\n-                s.push_str(\"proc\");\n-                push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n-            ty::RegionTraitStore(..) => {\n-                match cty.onceness {\n-                    ast::Many => {}\n-                    ast::Once => s.push_str(\"once \")\n-                }\n-                push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   &bounds_str[]);\n-            }\n-        }\n+        push_sig_to_string(cx, &mut s, '|', '|', &cty.sig);\n \n         s\n     }\n@@ -344,8 +311,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                                 s: &mut String,\n                                 bra: char,\n                                 ket: char,\n-                                sig: &ty::PolyFnSig<'tcx>,\n-                                bounds: &str) {\n+                                sig: &ty::PolyFnSig<'tcx>) {\n         s.push(bra);\n         let strs = sig.0.inputs\n             .iter()\n@@ -357,11 +323,6 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         s.push(ket);\n \n-        if !bounds.is_empty() {\n-            s.push_str(\":\");\n-            s.push_str(bounds);\n-        }\n-\n         match sig.0.output {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n@@ -542,17 +503,17 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps[..(tps.len() - num_defaults)].iter() {\n+    for t in tps[..tps.len() - num_defaults].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    &strs[0][1 .. (strs[0].len() - 2)] // Remove '(' and ',)'\n+                    &strs[0][1 .. strs[0].len() - 2] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    &strs[0][1 .. (strs[0].len() - 1)] // Remove '(' and ')'\n+                    &strs[0][1 .. strs[0].len() - 1] // Remove '(' and ')'\n                 } else {\n                     &strs[0][]\n                 },\n@@ -1090,12 +1051,6 @@ impl<'tcx> Repr<'tcx> for ty::MethodObject<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for ty::TraitStore {\n-    fn repr(&self, tcx: &ctxt) -> String {\n-        trait_store_to_string(tcx, *self)\n-    }\n-}\n-\n impl<'tcx> Repr<'tcx> for ty::BuiltinBound {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         format!(\"{:?}\", *self)"}, {"sha": "fa754b4a3018cda0fb8fa671529365c1c8ebdd57", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -59,7 +59,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n     let mut cmd = Command::new(ar);\n \n     cmd.arg(args).args(paths);\n-    debug!(\"{}\", cmd);\n+    debug!(\"{:?}\", cmd);\n \n     match cwd {\n         Some(p) => {\n@@ -73,9 +73,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(&format!(\"{} failed with: {}\",\n-                                 cmd,\n-                                 o.status)[]);\n+                handler.err(&format!(\"{:?} failed with: {}\", cmd, o.status)[]);\n                 handler.note(&format!(\"stdout ---\\n{}\",\n                                   str::from_utf8(&o.output[]).unwrap())[]);\n                 handler.note(&format!(\"stderr ---\\n{}\","}, {"sha": "0228098b8f8384c4aad7eb4068b401504d372381", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(&input[i..(i + size)]);\n+            func(&input[i..i + size]);\n             i += size;\n         }\n "}, {"sha": "ebeaf3e6e22d7e6a02d078fb09aa0734664399f4", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 2, "deletions": 22, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -52,7 +52,7 @@ use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n \n-#[derive(Clone, PartialEq)]\n+#[derive(Clone, PartialEq, Show)]\n pub struct Svh {\n     hash: String,\n }\n@@ -117,13 +117,7 @@ impl Svh {\n     }\n }\n \n-impl fmt::Show for Svh {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"Svh {{ {} }}\", self.as_str())\n-    }\n-}\n-\n-impl fmt::String for Svh {\n+impl fmt::Display for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.pad(self.as_str())\n     }\n@@ -188,7 +182,6 @@ mod svh_visitor {\n         SawLifetimeDef(token::InternedString),\n \n         SawMod,\n-        SawViewItem,\n         SawForeignItem,\n         SawItem,\n         SawDecl,\n@@ -436,19 +429,6 @@ mod svh_visitor {\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n-        fn visit_view_item(&mut self, i: &ViewItem) {\n-            // Two kinds of view items can affect the ABI for a crate:\n-            // exported `pub use` view items (since that may expose\n-            // items that downstream crates can call), and `use\n-            // foo::Trait`, since changing that may affect method\n-            // resolution.\n-            //\n-            // The simplest approach to handling both of the above is\n-            // just to adopt the same simple-minded (fine-grained)\n-            // hash that I am deploying elsewhere here.\n-            SawViewItem.hash(self.st); visit::walk_view_item(self, i)\n-        }\n-\n         fn visit_foreign_item(&mut self, i: &ForeignItem) {\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items"}, {"sha": "313c0dc2a6ea74c1ee10d8ce3109379165a90ecd", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::Target;\n+\n+pub fn target() -> Target {\n+    let mut base = super::linux_base::opts();\n+    base.pre_link_args.push(\"-Wl,--allow-multiple-definition\".to_string());\n+    base.position_independent_executables = true;\n+    Target {\n+        data_layout: \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                      f32:32:32-f64:64:64-v64:64:64-v128:128:128-a:0:64-\\\n+                      n32:64-S128\".to_string(),\n+        llvm_target: \"aarch64-linux-android\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"android\".to_string(),\n+        options: base,\n+    }\n+}"}, {"sha": "4626f2dc483394863517558e38ef23a7988aca87", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -65,6 +65,7 @@ mod arm_linux_androideabi;\n mod arm_unknown_linux_gnueabi;\n mod arm_unknown_linux_gnueabihf;\n mod aarch64_apple_ios;\n+mod aarch64_linux_android;\n mod aarch64_unknown_linux_gnu;\n mod i686_apple_darwin;\n mod i686_pc_windows_gnu;\n@@ -357,6 +358,7 @@ impl Target {\n             i386_apple_ios,\n             x86_64_apple_ios,\n             aarch64_apple_ios,\n+            aarch64_linux_android,\n             armv7_apple_ios,\n             armv7s_apple_ios,\n "}, {"sha": "0ade916f6390a34c0b6350e850ab9372a4eeafa7", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -370,7 +370,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n         for (i, &x) in new_loan_indices.iter().enumerate() {\n             let old_loan = &self.all_loans[x];\n-            for &y in new_loan_indices.slice_from(i+1).iter() {\n+            for &y in new_loan_indices[(i+1) ..].iter() {\n                 let new_loan = &self.all_loans[y];\n                 self.report_error_if_loans_conflict(old_loan, new_loan);\n             }"}, {"sha": "b1cc3a651200c427592334bd2fe3302ac000637d", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -491,7 +491,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n         if let ast::ExprAddrOf(mutbl, ref base) = ex.node {\n             let param_env = ty::empty_parameter_environment(self.bccx.tcx);\n             let mc = mc::MemCategorizationContext::new(&param_env);\n-            let base_cmt = mc.cat_expr(&**base).unwrap();\n+            let base_cmt = mc.cat_expr(&**base).ok().unwrap();\n             let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n             // Check that we don't allow borrows of unsafe static items.\n             if check_aliasability(self.bccx, ex.span, euv::AddrOf,"}, {"sha": "0e940b85bd84d9064669d46b61f625c7bc846a49", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -61,7 +61,6 @@ use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n use rustc::metadata::creader::CrateOrString::Str;\n-use rustc::DIAGNOSTICS;\n use rustc::util::common::time;\n \n use std::cmp::Ordering::Equal;\n@@ -98,7 +97,7 @@ fn run_compiler(args: &[String]) {\n         None => return\n     };\n \n-    let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n+    let descriptions = diagnostics_registry();\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n             match descriptions.find_description(&code[]) {\n@@ -154,10 +153,14 @@ fn run_compiler(args: &[String]) {\n         return\n     }\n \n-    let pretty = matches.opt_default(\"pretty\", \"normal\").map(|a| {\n-        // stable pretty-print variants only\n-        pretty::parse_pretty(&sess, a.as_slice(), false)\n-    });\n+    let pretty = if sess.opts.debugging_opts.unstable_options {\n+        matches.opt_default(\"pretty\", \"normal\").map(|a| {\n+            // stable pretty-print variants only\n+            pretty::parse_pretty(&sess, a.as_slice(), false)\n+        })\n+    } else {\n+        None\n+    };\n     let pretty = if pretty.is_none() &&\n         sess.unstable_options() {\n             matches.opt_str(\"xpretty\").map(|a| {\n@@ -659,8 +662,20 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n     }\n }\n \n+pub fn diagnostics_registry() -> diagnostics::registry::Registry {\n+    use syntax::diagnostics::registry::Registry;\n+\n+    let all_errors = Vec::new() +\n+        rustc::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_typeck::diagnostics::DIAGNOSTICS.as_slice() +\n+        rustc_resolve::diagnostics::DIAGNOSTICS.as_slice();\n+\n+    Registry::new(&*all_errors)\n+}\n+\n pub fn main() {\n     let args = std::os::args();\n     let result = run(args);\n     std::os::set_exit_status(result);\n }\n+"}, {"sha": "582e10323248cfb80ea95f35bb78b75f052eeb83", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -477,7 +477,7 @@ impl fold::Folder for ReplaceBodyWithLoop {\n                          e: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n                 expr: e,\n-                view_items: vec![], stmts: vec![], rules: rules,\n+                stmts: vec![], rules: rules,\n                 id: ast::DUMMY_NODE_ID, span: codemap::DUMMY_SP,\n             })\n         }"}, {"sha": "cd28a27f9886bc80ccb3522f8d43ffc9d98af8e2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -200,6 +200,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n \n             return match it.node {\n+                ast::ItemUse(..) | ast::ItemExternCrate(..) |\n                 ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemFn(..) |\n                 ast::ItemForeignMod(..) | ast::ItemTy(..) => {\n                     None"}, {"sha": "db2a569cdeffa0edbae0f09bf8914215c00fa1a3", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -14,6 +14,7 @@ pub use self::OptimizationDiagnosticKind::*;\n pub use self::Diagnostic::*;\n \n use libc::c_char;\n+use std::ptr;\n \n use {ValueRef, TwineRef, DebugLocRef, DiagnosticInfoRef};\n \n@@ -52,10 +53,10 @@ impl OptimizationDiagnostic {\n \n         let mut opt = OptimizationDiagnostic {\n             kind: kind,\n-            pass_name: 0 as *const c_char,\n-            function: 0 as ValueRef,\n-            debug_loc: 0 as DebugLocRef,\n-            message: 0 as TwineRef,\n+            pass_name: ptr::null(),\n+            function: ptr::null_mut(),\n+            debug_loc: ptr::null_mut(),\n+            message: ptr::null_mut(),\n         };\n \n         super::LLVMUnpackOptimizationDiagnostic(di,"}, {"sha": "eded88bb62e74cbcac4ad2a972fed7cac2177860", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -53,7 +53,7 @@ pub use self::Linkage::*;\n \n use std::ffi::CString;\n use std::cell::RefCell;\n-use std::{raw, mem};\n+use std::{raw, mem, ptr};\n use libc::{c_uint, c_ushort, uint64_t, c_int, size_t, c_char};\n use libc::{c_longlong, c_ulonglong, c_void};\n use debuginfo::{DIBuilderRef, DIDescriptor,\n@@ -2262,19 +2262,18 @@ pub unsafe fn static_link_hack_this_sucks() {\n     LLVMInitializePowerPCAsmPrinter();\n     LLVMInitializePowerPCAsmParser();\n \n-    LLVMRustSetLLVMOptions(0 as c_int,\n-                                       0 as *const _);\n+    LLVMRustSetLLVMOptions(0 as c_int, ptr::null());\n \n-    LLVMPassManagerBuilderPopulateModulePassManager(0 as *mut _, 0 as *mut _);\n-    LLVMPassManagerBuilderPopulateLTOPassManager(0 as *mut _, 0 as *mut _, False, False);\n-    LLVMPassManagerBuilderPopulateFunctionPassManager(0 as *mut _, 0 as *mut _);\n-    LLVMPassManagerBuilderSetOptLevel(0 as *mut _, 0 as c_uint);\n-    LLVMPassManagerBuilderUseInlinerWithThreshold(0 as *mut _, 0 as c_uint);\n-    LLVMWriteBitcodeToFile(0 as *mut _, 0 as *const _);\n+    LLVMPassManagerBuilderPopulateModulePassManager(ptr::null_mut(), ptr::null_mut());\n+    LLVMPassManagerBuilderPopulateLTOPassManager(ptr::null_mut(), ptr::null_mut(), False, False);\n+    LLVMPassManagerBuilderPopulateFunctionPassManager(ptr::null_mut(), ptr::null_mut());\n+    LLVMPassManagerBuilderSetOptLevel(ptr::null_mut(), 0 as c_uint);\n+    LLVMPassManagerBuilderUseInlinerWithThreshold(ptr::null_mut(), 0 as c_uint);\n+    LLVMWriteBitcodeToFile(ptr::null_mut(), ptr::null());\n     LLVMPassManagerBuilderCreate();\n-    LLVMPassManagerBuilderDispose(0 as *mut _);\n+    LLVMPassManagerBuilderDispose(ptr::null_mut());\n \n-    LLVMRustLinkInExternalBitcode(0 as *mut _, 0 as *const _, 0 as size_t);\n+    LLVMRustLinkInExternalBitcode(ptr::null_mut(), ptr::null(), 0 as size_t);\n \n     LLVMLinkInMCJIT();\n     LLVMLinkInInterpreter();"}, {"sha": "414dbb9626347598b19b54c2cdaef306cfb9baf3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 37, "deletions": 59, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -830,6 +830,38 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &ast::Item) {\n+        match item.node {\n+            ast::ItemUse(ref vpath) => {\n+                match vpath.node {\n+                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n+                    ast::ViewPathList(ref prefix, ref list) => {\n+                        for pid in list.iter() {\n+                            match pid.node {\n+                                ast::PathListIdent { id, name } => {\n+                                    debug!(\"privacy - ident item {}\", id);\n+                                    let seg = ast::PathSegment {\n+                                        identifier: name,\n+                                        parameters: ast::PathParameters::none(),\n+                                    };\n+                                    let segs = vec![seg];\n+                                    let path = ast::Path {\n+                                        global: false,\n+                                        span: pid.span,\n+                                        segments: segs,\n+                                    };\n+                                    self.check_path(pid.span, id, &path);\n+                                }\n+                                ast::PathListMod { id } => {\n+                                    debug!(\"privacy - mod item {}\", id);\n+                                    self.check_path(pid.span, id, prefix);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n         let orig_curitem = replace(&mut self.curitem, item.id);\n         visit::walk_item(self, item);\n         self.curitem = orig_curitem;\n@@ -926,42 +958,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n         visit::walk_expr(self, expr);\n     }\n \n-    fn visit_view_item(&mut self, a: &ast::ViewItem) {\n-        match a.node {\n-            ast::ViewItemExternCrate(..) => {}\n-            ast::ViewItemUse(ref vpath) => {\n-                match vpath.node {\n-                    ast::ViewPathSimple(..) | ast::ViewPathGlob(..) => {}\n-                    ast::ViewPathList(ref prefix, ref list, _) => {\n-                        for pid in list.iter() {\n-                            match pid.node {\n-                                ast::PathListIdent { id, name } => {\n-                                    debug!(\"privacy - ident item {}\", id);\n-                                    let seg = ast::PathSegment {\n-                                        identifier: name,\n-                                        parameters: ast::PathParameters::none(),\n-                                    };\n-                                    let segs = vec![seg];\n-                                    let path = ast::Path {\n-                                        global: false,\n-                                        span: pid.span,\n-                                        segments: segs,\n-                                    };\n-                                    self.check_path(pid.span, id, &path);\n-                                }\n-                                ast::PathListMod { id } => {\n-                                    debug!(\"privacy - mod item {}\", id);\n-                                    self.check_path(pid.span, id, prefix);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, a);\n-    }\n-\n     fn visit_pat(&mut self, pattern: &ast::Pat) {\n         // Foreign functions do not have their patterns mapped in the def_map,\n         // and there's nothing really relevant there anyway, so don't bother\n@@ -1069,23 +1065,6 @@ impl<'a, 'tcx, 'v> Visitor<'v> for SanePrivacyVisitor<'a, 'tcx> {\n         visit::walk_fn(self, fk, fd, b, s);\n         self.in_fn = orig_in_fn;\n     }\n-\n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.vis {\n-            ast::Inherited => {}\n-            ast::Public => {\n-                if self.in_fn {\n-                    self.tcx.sess.span_err(i.span, \"unnecessary `pub`, imports \\\n-                                                    in functions are never \\\n-                                                    reachable\");\n-                } else if let ast::ViewItemExternCrate(..) = i.node {\n-                    self.tcx.sess.span_err(i.span, \"`pub` visibility \\\n-                                                    is not allowed\");\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i);\n-    }\n }\n \n impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n@@ -1162,7 +1141,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n             ast::ItemConst(..) | ast::ItemStatic(..) | ast::ItemStruct(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n-            ast::ItemMac(..) => {}\n+            ast::ItemExternCrate(_) | ast::ItemUse(_) | ast::ItemMac(..) => {}\n         }\n     }\n \n@@ -1219,6 +1198,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemExternCrate(_) | ast::ItemUse(_) |\n             ast::ItemStatic(..) | ast::ItemConst(..) |\n             ast::ItemFn(..) | ast::ItemMod(..) | ast::ItemTy(..) |\n             ast::ItemMac(..) => {}\n@@ -1521,11 +1501,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n \n \n     // we don't need to introspect into these at all: an\n-    // expression/block context can't possibly contain exported\n-    // things, and neither do view_items. (Making them no-ops stops us\n-    // from traversing the whole AST without having to be super\n-    // careful about our `walk_...` calls above.)\n-    fn visit_view_item(&mut self, _: &ast::ViewItem) {}\n+    // expression/block context can't possibly contain exported things.\n+    // (Making them no-ops stops us from traversing the whole AST without\n+    // having to be super careful about our `walk_...` calls above.)\n     fn visit_block(&mut self, _: &ast::Block) {}\n     fn visit_expr(&mut self, _: &ast::Expr) {}\n }"}, {"sha": "65bd83d7937fb5bc43c08c78f855562b7979653a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 131, "deletions": 153, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -39,9 +39,9 @@ use rustc::middle::subst::FnSpace;\n use syntax::ast::{Block, Crate};\n use syntax::ast::{DeclItem, DefId};\n use syntax::ast::{ForeignItem, ForeignItemFn, ForeignItemStatic};\n-use syntax::ast::{Item, ItemConst, ItemEnum, ItemFn};\n+use syntax::ast::{Item, ItemConst, ItemEnum, ItemExternCrate, ItemFn};\n use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n use syntax::ast::{MethodImplItem, Name, NamedField, NodeId};\n use syntax::ast::{PathListIdent, PathListMod};\n use syntax::ast::{Public, SelfStatic};\n@@ -50,8 +50,7 @@ use syntax::ast::StructVariantKind;\n use syntax::ast::TupleVariantKind;\n use syntax::ast::TyObjectSum;\n use syntax::ast::{TypeImplItem, UnnamedField};\n-use syntax::ast::{Variant, ViewItem, ViewItemExternCrate};\n-use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Variant, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::ast::{Visibility};\n use syntax::ast::TyPath;\n use syntax::ast;\n@@ -238,11 +237,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n     }\n \n     fn block_needs_anonymous_module(&mut self, block: &Block) -> bool {\n-        // If the block has view items, we need an anonymous module.\n-        if block.view_items.len() > 0 {\n-            return true;\n-        }\n-\n         // Check each statement.\n         for statement in block.stmts.iter() {\n             match statement.node {\n@@ -262,7 +256,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             }\n         }\n \n-        // If we found neither view items nor items, we don't need to create\n+        // If we found no items, we don't need to create\n         // an anonymous module.\n \n         return false;\n@@ -280,6 +274,133 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n         let modifiers = if is_public { PUBLIC } else { DefModifiers::empty() } | IMPORTABLE;\n \n         match item.node {\n+            ItemUse(ref view_path) => {\n+                // Extract and intern the module part of the path. For\n+                // globs and lists, the path is found directly in the AST;\n+                // for simple paths we have to munge the path a little.\n+                let module_path = match view_path.node {\n+                    ViewPathSimple(_, ref full_path) => {\n+                        full_path.segments\n+                            .init()\n+                            .iter().map(|ident| ident.identifier.name)\n+                            .collect()\n+                    }\n+\n+                    ViewPathGlob(ref module_ident_path) |\n+                    ViewPathList(ref module_ident_path, _) => {\n+                        module_ident_path.segments\n+                            .iter().map(|ident| ident.identifier.name).collect()\n+                    }\n+                };\n+\n+                // Build up the import directives.\n+                let shadowable = item.attrs.iter().any(|attr| {\n+                    attr.name() == token::get_name(special_idents::prelude_import.name)\n+                });\n+                let shadowable = if shadowable {\n+                    Shadowable::Always\n+                } else {\n+                    Shadowable::Never\n+                };\n+\n+                match view_path.node {\n+                    ViewPathSimple(binding, ref full_path) => {\n+                        let source_name =\n+                            full_path.segments.last().unwrap().identifier.name;\n+                        if token::get_name(source_name).get() == \"mod\" ||\n+                           token::get_name(source_name).get() == \"self\" {\n+                            self.resolve_error(view_path.span,\n+                                \"`self` imports are only allowed within a { } list\");\n+                        }\n+\n+                        let subclass = SingleImport(binding.name,\n+                                                    source_name);\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    subclass,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                    ViewPathList(_, ref source_items) => {\n+                        // Make sure there's at most one `mod` import in the list.\n+                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n+                            PathListMod { .. } => Some(item.span),\n+                            _ => None\n+                        }).collect::<Vec<Span>>();\n+                        if mod_spans.len() > 1 {\n+                            self.resolve_error(mod_spans[0],\n+                                \"`self` import can only appear once in the list\");\n+                            for other_span in mod_spans.iter().skip(1) {\n+                                self.session.span_note(*other_span,\n+                                    \"another `self` import appears here\");\n+                            }\n+                        }\n+\n+                        for source_item in source_items.iter() {\n+                            let (module_path, name) = match source_item.node {\n+                                PathListIdent { name, .. } =>\n+                                    (module_path.clone(), name.name),\n+                                PathListMod { .. } => {\n+                                    let name = match module_path.last() {\n+                                        Some(name) => *name,\n+                                        None => {\n+                                            self.resolve_error(source_item.span,\n+                                                \"`self` import can only appear in an import list \\\n+                                                 with a non-empty prefix\");\n+                                            continue;\n+                                        }\n+                                    };\n+                                    let module_path = module_path.init();\n+                                    (module_path.to_vec(), name)\n+                                }\n+                            };\n+                            self.build_import_directive(\n+                                &**parent,\n+                                module_path,\n+                                SingleImport(name, name),\n+                                source_item.span,\n+                                source_item.node.id(),\n+                                is_public,\n+                                shadowable);\n+                        }\n+                    }\n+                    ViewPathGlob(_) => {\n+                        self.build_import_directive(&**parent,\n+                                                    module_path,\n+                                                    GlobImport,\n+                                                    view_path.span,\n+                                                    item.id,\n+                                                    is_public,\n+                                                    shadowable);\n+                    }\n+                }\n+                parent.clone()\n+            }\n+\n+            ItemExternCrate(_) => {\n+                // n.b. we don't need to look at the path option here, because cstore already did\n+                for &crate_id in self.session.cstore\n+                                     .find_extern_mod_stmt_cnum(item.id).iter() {\n+                    let def_id = DefId { krate: crate_id, node: 0 };\n+                    self.external_exports.insert(def_id);\n+                    let parent_link = ModuleParentLink(parent.downgrade(), name);\n+                    let external_module = Rc::new(Module::new(parent_link,\n+                                                              Some(def_id),\n+                                                              NormalModuleKind,\n+                                                              false,\n+                                                              true));\n+                    debug!(\"(build reduced graph for item) found extern `{}`\",\n+                            self.module_to_string(&*external_module));\n+                    self.check_for_conflicts_between_external_crates(&**parent, name, sp);\n+                    parent.external_module_children.borrow_mut()\n+                          .insert(name, external_module.clone());\n+                    self.build_reduced_graph_for_external_crate(&external_module);\n+                }\n+                parent.clone()\n+            }\n+\n             ItemMod(..) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateModules, sp);\n \n@@ -650,145 +771,6 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                           variant.span, PUBLIC | IMPORTABLE);\n     }\n \n-    /// Constructs the reduced graph for one 'view item'. View items consist\n-    /// of imports and use directives.\n-    fn build_reduced_graph_for_view_item(&mut self, view_item: &ViewItem, parent: &Rc<Module>) {\n-        match view_item.node {\n-            ViewItemUse(ref view_path) => {\n-                // Extract and intern the module part of the path. For\n-                // globs and lists, the path is found directly in the AST;\n-                // for simple paths we have to munge the path a little.\n-                let module_path = match view_path.node {\n-                    ViewPathSimple(_, ref full_path, _) => {\n-                        full_path.segments\n-                            .init()\n-                            .iter().map(|ident| ident.identifier.name)\n-                            .collect()\n-                    }\n-\n-                    ViewPathGlob(ref module_ident_path, _) |\n-                    ViewPathList(ref module_ident_path, _, _) => {\n-                        module_ident_path.segments\n-                            .iter().map(|ident| ident.identifier.name).collect()\n-                    }\n-                };\n-\n-                // Build up the import directives.\n-                let is_public = view_item.vis == ast::Public;\n-                let shadowable =\n-                    view_item.attrs\n-                             .iter()\n-                             .any(|attr| {\n-                                 attr.name() == token::get_name(\n-                                    special_idents::prelude_import.name)\n-                             });\n-                let shadowable = if shadowable {\n-                    Shadowable::Always\n-                } else {\n-                    Shadowable::Never\n-                };\n-\n-                match view_path.node {\n-                    ViewPathSimple(binding, ref full_path, id) => {\n-                        let source_name =\n-                            full_path.segments.last().unwrap().identifier.name;\n-                        if token::get_name(source_name).get() == \"mod\" ||\n-                           token::get_name(source_name).get() == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n-                        }\n-\n-                        let subclass = SingleImport(binding.name,\n-                                                    source_name);\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    subclass,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                    ViewPathList(_, ref source_items, _) => {\n-                        // Make sure there's at most one `mod` import in the list.\n-                        let mod_spans = source_items.iter().filter_map(|item| match item.node {\n-                            PathListMod { .. } => Some(item.span),\n-                            _ => None\n-                        }).collect::<Vec<Span>>();\n-                        if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n-                            for other_span in mod_spans.iter().skip(1) {\n-                                self.session.span_note(*other_span,\n-                                    \"another `self` import appears here\");\n-                            }\n-                        }\n-\n-                        for source_item in source_items.iter() {\n-                            let (module_path, name) = match source_item.node {\n-                                PathListIdent { name, .. } =>\n-                                    (module_path.clone(), name.name),\n-                                PathListMod { .. } => {\n-                                    let name = match module_path.last() {\n-                                        Some(name) => *name,\n-                                        None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n-                                            continue;\n-                                        }\n-                                    };\n-                                    let module_path = module_path.init();\n-                                    (module_path.to_vec(), name)\n-                                }\n-                            };\n-                            self.build_import_directive(\n-                                &**parent,\n-                                module_path,\n-                                SingleImport(name, name),\n-                                source_item.span,\n-                                source_item.node.id(),\n-                                is_public,\n-                                shadowable);\n-                        }\n-                    }\n-                    ViewPathGlob(_, id) => {\n-                        self.build_import_directive(&**parent,\n-                                                    module_path,\n-                                                    GlobImport,\n-                                                    view_path.span,\n-                                                    id,\n-                                                    is_public,\n-                                                    shadowable);\n-                    }\n-                }\n-            }\n-\n-            ViewItemExternCrate(name, _, node_id) => {\n-                // n.b. we don't need to look at the path option here, because cstore already did\n-                for &crate_id in self.session.cstore\n-                                     .find_extern_mod_stmt_cnum(node_id).iter() {\n-                    let def_id = DefId { krate: crate_id, node: 0 };\n-                    self.external_exports.insert(def_id);\n-                    let parent_link = ModuleParentLink(parent.downgrade(), name.name);\n-                    let external_module = Rc::new(Module::new(parent_link,\n-                                                              Some(def_id),\n-                                                              NormalModuleKind,\n-                                                              false,\n-                                                              true));\n-                    debug!(\"(build reduced graph for item) found extern `{}`\",\n-                            self.module_to_string(&*external_module));\n-                    self.check_for_conflicts_between_external_crates(\n-                        &**parent,\n-                        name.name,\n-                        view_item.span);\n-                    parent.external_module_children.borrow_mut()\n-                          .insert(name.name, external_module.clone());\n-                    self.build_reduced_graph_for_external_crate(&external_module);\n-                }\n-            }\n-        }\n-    }\n-\n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item<F>(&mut self,\n                                                foreign_item: &ForeignItem,\n@@ -1270,10 +1252,6 @@ impl<'a, 'b, 'v, 'tcx> Visitor<'v> for BuildReducedGraphVisitor<'a, 'b, 'tcx> {\n         })\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        self.builder.build_reduced_graph_for_view_item(view_item, &self.parent);\n-    }\n-\n     fn visit_block(&mut self, block: &Block) {\n         let np = self.builder.build_reduced_graph_for_block(block, &self.parent);\n         let old_parent = replace(&mut self.parent, np);"}, {"sha": "97370112ab40f422af7504dad50f23f71d84709a", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -25,7 +25,6 @@ use Namespace::{TypeNS, ValueNS};\n use rustc::lint;\n use rustc::middle::privacy::{DependsOn, LastImport, Used, Unused};\n use syntax::ast;\n-use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse};\n use syntax::ast::{ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::codemap::{Span, DUMMY_SP};\n use syntax::visit::{self, Visitor};\n@@ -109,53 +108,54 @@ impl<'a, 'b, 'tcx> UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n }\n \n impl<'a, 'b, 'v, 'tcx> Visitor<'v> for UnusedImportCheckVisitor<'a, 'b, 'tcx> {\n-    fn visit_view_item(&mut self, vi: &ViewItem) {\n+    fn visit_item(&mut self, item: &ast::Item) {\n         // Ignore is_public import statements because there's no way to be sure\n         // whether they're used or not. Also ignore imports with a dummy span\n         // because this means that they were generated in some fashion by the\n         // compiler and we don't need to consider them.\n-        if vi.vis == ast::Public || vi.span == DUMMY_SP {\n-            visit::walk_view_item(self, vi);\n+        if item.vis == ast::Public || item.span == DUMMY_SP {\n+            visit::walk_item(self, item);\n             return;\n         }\n \n-        match vi.node {\n-            ViewItemExternCrate(_, _, id) => {\n-                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(id) {\n+        match item.node {\n+            ast::ItemExternCrate(_) => {\n+                if let Some(crate_num) = self.session.cstore.find_extern_mod_stmt_cnum(item.id) {\n                     if !self.used_crates.contains(&crate_num) {\n                         self.session.add_lint(lint::builtin::UNUSED_EXTERN_CRATES,\n-                                              id,\n-                                              vi.span,\n+                                              item.id,\n+                                              item.span,\n                                               \"unused extern crate\".to_string());\n                     }\n                 }\n             },\n-            ViewItemUse(ref p) => {\n+            ast::ItemUse(ref p) => {\n                 match p.node {\n-                    ViewPathSimple(_, _, id) => {\n-                        self.finalize_import(id, p.span)\n+                    ViewPathSimple(_, _) => {\n+                        self.finalize_import(item.id, p.span)\n                     }\n \n-                    ViewPathList(_, ref list, _) => {\n+                    ViewPathList(_, ref list) => {\n                         for i in list.iter() {\n                             self.finalize_import(i.node.id(), i.span);\n                         }\n                     }\n-                    ViewPathGlob(_, id) => {\n-                        if !self.used_imports.contains(&(id, TypeNS)) &&\n-                           !self.used_imports.contains(&(id, ValueNS)) {\n+                    ViewPathGlob(_) => {\n+                        if !self.used_imports.contains(&(item.id, TypeNS)) &&\n+                           !self.used_imports.contains(&(item.id, ValueNS)) {\n                             self.session\n                                 .add_lint(lint::builtin::UNUSED_IMPORTS,\n-                                          id,\n+                                          item.id,\n                                           p.span,\n                                           \"unused import\".to_string());\n                         }\n                     }\n                 }\n             }\n+            _ => {}\n         }\n \n-        visit::walk_view_item(self, vi);\n+        visit::walk_item(self, item);\n     }\n }\n "}, {"sha": "dd9ccfbda7ca6a438ee6f4f57edc9126dfbc42a6", "filename": "src/librustc_resolve/diagnostics.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_snake_case)]\n+\n+register_diagnostics! {\n+    E0154,\n+    E0157,\n+    E0153,\n+    E0251, // a named type or value has already been imported in this module\n+    E0252, // a named type or value has already been imported in this module\n+    E0253, // not directly importable\n+    E0254, // import conflicts with imported crate in this module\n+    E0255, // import conflicts with value in this module\n+    E0256, // import conflicts with type in this module\n+    E0257, // inherent implementations are only allowen on types defined in the current module\n+    E0258, // import conflicts with existing submodule\n+    E0259, // an extern crate has already been imported into this module\n+    E0260 // name conflicts with an external crate that has been imported into this module\n+}\n+\n+__build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "94801545c2f03bb84097b0442bad9b5ff2f39394", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 50, "deletions": 44, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -65,10 +65,10 @@ use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n-use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemFn};\n-use syntax::ast::{ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n-use syntax::ast::{ItemStruct, ItemTrait, ItemTy, Local, LOCAL_CRATE};\n-use syntax::ast::{MethodImplItem, Mod, Name, NodeId};\n+use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};\n+use syntax::ast::{ItemFn, ItemForeignMod, ItemImpl, ItemMac, ItemMod, ItemStatic};\n+use syntax::ast::{ItemStruct, ItemTrait, ItemTy, ItemUse};\n+use syntax::ast::{Local, MethodImplItem, Mod, Name, NodeId};\n use syntax::ast::{Pat, PatEnum, PatIdent, PatLit};\n use syntax::ast::{PatRange, PatStruct, Path};\n use syntax::ast::{PolyTraitRef, PrimTy, SelfExplicit};\n@@ -97,6 +97,10 @@ use std::mem::replace;\n use std::rc::{Rc, Weak};\n use std::uint;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod check_unused;\n mod record_exports;\n mod build_reduced_graph;\n@@ -536,7 +540,7 @@ impl Module {\n     }\n }\n \n-impl fmt::Show for Module {\n+impl fmt::Debug for Module {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:?}, kind: {:?}, {}\",\n                self.def_id,\n@@ -1139,7 +1143,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     }\n \n     fn get_trait_name(&self, did: DefId) -> Name {\n-        if did.krate == LOCAL_CRATE {\n+        if did.krate == ast::LOCAL_CRATE {\n             self.ast_map.expect_item(did.node).ident.name\n         } else {\n             csearch::get_trait_name(&self.session.cstore, did)\n@@ -1718,7 +1722,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                            in this module\",\n                                           namespace_name,\n                                           token::get_name(name).get());\n-                        self.session.span_err(import_directive.span, msg.as_slice());\n+                        span_err!(self.session, import_directive.span, E0251, \"{}\", msg.as_slice());\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n                                                  name_bindings.clone(),\n@@ -1748,10 +1752,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     import_span: Span,\n                                     name: Name,\n                                     namespace: Namespace) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n                token::get_name(name).get(),\n                target.is_some());\n@@ -1765,7 +1765,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, &msg[]);\n+                span_err!(self.session, import_span, E0252, \"{}\", &msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1780,7 +1780,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, &msg[]);\n+            span_err!(self.session, import_span, E0253, \"{}\", &msg[]);\n         }\n     }\n \n@@ -1791,10 +1791,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                      &ImportResolution,\n                                                      import_span: Span,\n                                                      name: Name) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         // First, check for conflicts between imports and `extern crate`s.\n         if module.external_module_children\n                  .borrow()\n@@ -1805,7 +1801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0254, \"{}\", &msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1827,7 +1823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, &msg[]);\n+                    span_err!(self.session, import_span, E0255, \"{}\", &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1845,7 +1841,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, &msg[]);\n+                            span_err!(self.session, import_span, E0256, \"{}\", &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1858,7 +1854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, &msg[]);\n+                                        span_err!(self.session, span, E0257, \"{}\", &msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1867,7 +1863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, &msg[]);\n+                                    span_err!(self.session, import_span, E0258, \"{}\", &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1888,16 +1884,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                    module: &Module,\n                                                    name: Name,\n                                                    span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"an external crate named `{}` has already \\\n+                span_err!(self.session, span, E0259,\n+                          \"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n \n@@ -1906,17 +1897,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                              module: &Module,\n                                                              name: Name,\n                                                              span: Span) {\n-        if self.session.features.borrow().import_shadowing {\n-            return\n-        }\n-\n         if module.external_module_children.borrow().contains_key(&name) {\n-            self.session\n-                .span_err(span,\n-                          &format!(\"the name `{}` conflicts with an external \\\n+                span_err!(self.session, span, E0260,\n+                          \"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get())[]);\n+                                  token::get_name(name).get());\n         }\n     }\n \n@@ -1965,7 +1951,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n                     let msg = if \"???\" == &module_name[] {\n-                        span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n+                        span.hi = span.lo + Pos::from_usize(segment_name.get().len());\n \n                         match search_parent_externals(name,\n                                                      &self.current_module) {\n@@ -2083,8 +2069,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            &mpath[(idx + 1)..],\n-                                            &mpath[..(idx - 1)]);\n+                                            &mpath[idx + 1..],\n+                                            &mpath[..idx - 1]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2760,7 +2746,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(&ribs[(i + 1)..], def_like, span);\n+                    return self.upvarify(&ribs[i + 1..], def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2982,9 +2968,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 });\n             }\n \n-           ItemMac(..) => {\n+            ItemExternCrate(_) | ItemUse(_) | ItemMac(..) => {\n                 // do nothing, these are just around to be encoded\n-           }\n+            }\n         }\n     }\n \n@@ -3525,6 +3511,26 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n         }\n \n+        // Check for imports appearing after non-item statements.\n+        let mut found_non_item = false;\n+        for statement in block.stmts.iter() {\n+            if let ast::StmtDecl(ref declaration, _) = statement.node {\n+                if let ast::DeclItem(ref i) = declaration.node {\n+                    match i.node {\n+                        ItemExternCrate(_) | ItemUse(_) if found_non_item => {\n+                            span_err!(self.session, i.span, E0154,\n+                                \"imports are not allowed after non-item statements\");\n+                        }\n+                        _ => {}\n+                    }\n+                } else {\n+                    found_non_item = true\n+                }\n+            } else {\n+                found_non_item = true;\n+            }\n+        }\n+\n         // Descend into the block.\n         visit::walk_block(self, block);\n "}, {"sha": "eedfc9407515c99d000276da650b57ef03b4ae54", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -178,7 +178,7 @@ pub fn build_link_meta(sess: &Session, krate: &ast::Crate,\n fn truncated_hash_result(symbol_hasher: &mut Sha256) -> String {\n     let output = symbol_hasher.result_bytes();\n     // 64 bits should be enough to avoid collisions.\n-    output.slice_to(8).to_hex().to_string()\n+    output[.. 8].to_hex().to_string()\n }\n \n \n@@ -779,22 +779,22 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     }\n \n     if sess.opts.debugging_opts.print_link_args {\n-        println!(\"{}\", &cmd);\n+        println!(\"{:?}\", &cmd);\n     }\n \n     // May have not found libraries in the right formats.\n     sess.abort_if_errors();\n \n     // Invoke the system linker\n-    debug!(\"{}\", &cmd);\n+    debug!(\"{:?}\", &cmd);\n     let prog = time(sess.time_passes(), \"running linker\", (), |()| cmd.output());\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n                                  prog.status)[]);\n-                sess.note(&format!(\"{}\", &cmd)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n                 output.push_all(&prog.output[]);\n                 sess.note(str::from_utf8(&output[]).unwrap());\n@@ -1183,7 +1183,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = &name[3..(name.len() - 5)]; // chop off lib/.rlib\n+            let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n             time(sess.time_passes(),\n                  &format!(\"altering {}.rlib\", name)[],\n                  (), |()| {"}, {"sha": "590354ab54e0af5c99f3eb40eeea62bea81eaa2c", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -60,7 +60,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = &file[3..(file.len() - 5)]; // chop off lib/.rlib\n+        let file = &file[3..file.len() - 5]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n@@ -201,7 +201,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = &bytes[position_in_bytes..(position_in_bytes + mem::size_of::<T>())];\n+    let byte_data = &bytes[position_in_bytes..position_in_bytes + mem::size_of::<T>()];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "b07c2060e692f043bff622efb6dc8f93dc3dc16e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -67,11 +67,11 @@ pub fn write_output_file(\n         output: &Path,\n         file_type: llvm::FileType) {\n     unsafe {\n-        let output = CString::from_slice(output.as_vec());\n+        let output_c = CString::from_slice(output.as_vec());\n         let result = llvm::LLVMRustWriteOutputFile(\n-                target, pm, m, output.as_ptr(), file_type);\n+                target, pm, m, output_c.as_ptr(), file_type);\n         if !result {\n-            llvm_err(handler, \"could not write output\".to_string());\n+            llvm_err(handler, format!(\"could not write output to {}\", output.display()));\n         }\n     }\n }\n@@ -716,7 +716,7 @@ pub fn run_passes(sess: &Session,\n         cmd.args(&sess.target.target.options.post_link_args[]);\n \n         if sess.opts.debugging_opts.print_link_args {\n-            println!(\"{}\", &cmd);\n+            println!(\"{:?}\", &cmd);\n         }\n \n         cmd.stdin(::std::io::process::Ignored)\n@@ -725,7 +725,7 @@ pub fn run_passes(sess: &Session,\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {\n-                    sess.err(&format!(\"linking of {} with `{}` failed\",\n+                    sess.err(&format!(\"linking of {} with `{:?}` failed\",\n                                      output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n@@ -953,15 +953,15 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n-    debug!(\"{}\", &cmd);\n+    debug!(\"{:?}\", &cmd);\n \n     match cmd.output() {\n         Ok(prog) => {\n             if !prog.status.success() {\n                 sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n                                  prog.status)[]);\n-                sess.note(&format!(\"{}\", &cmd)[]);\n+                sess.note(&format!(\"{:?}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n                 note.push_all(&prog.output[]);\n                 sess.note(str::from_utf8(&note[]).unwrap());"}, {"sha": "4aec53711ad8af02b250b6e40edfff9b522d3747", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 107, "deletions": 116, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -157,7 +157,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             return;\n         }\n \n-        let sub_paths = sub_paths.slice(0, len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n@@ -174,7 +174,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 1 {\n             return;\n         }\n-        let sub_paths = sub_paths.slice_to(len-1);\n+        let sub_paths = &sub_paths[.. (len-1)];\n \n         // write the trait part of the sub-path\n         let (ref span, ref qualname) = sub_paths[len-2];\n@@ -186,7 +186,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = &sub_paths[..(len-2)];\n+        let sub_paths = &sub_paths[..len-2];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n@@ -1037,6 +1037,110 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n \n         match item.node {\n+            ast::ItemUse(ref use_item) => {\n+                match use_item.node {\n+                    ast::ViewPathSimple(ident, ref path) => {\n+                        let sub_span = self.span.span_for_last_ident(path.span);\n+                        let mod_id = match self.lookup_type_ref(item.id) {\n+                            Some(def_id) => {\n+                                match self.lookup_def_kind(item.id, path.span) {\n+                                    Some(kind) => self.fmt.ref_str(kind,\n+                                                                   path.span,\n+                                                                   sub_span,\n+                                                                   def_id,\n+                                                                   self.cur_scope),\n+                                    None => {},\n+                                }\n+                                Some(def_id)\n+                            },\n+                            None => None,\n+                        };\n+\n+                        // 'use' always introduces an alias, if there is not an explicit\n+                        // one, there is an implicit one.\n+                        let sub_span =\n+                            match self.span.sub_span_after_keyword(use_item.span, keywords::As) {\n+                                Some(sub_span) => Some(sub_span),\n+                                None => sub_span,\n+                            };\n+\n+                        self.fmt.use_alias_str(path.span,\n+                                               sub_span,\n+                                               item.id,\n+                                               mod_id,\n+                                               get_ident(ident).get(),\n+                                               self.cur_scope);\n+                        self.write_sub_paths_truncated(path);\n+                    }\n+                    ast::ViewPathGlob(ref path) => {\n+                        // Make a comma-separated list of names of imported modules.\n+                        let mut name_string = String::new();\n+                        let glob_map = &self.analysis.glob_map;\n+                        let glob_map = glob_map.as_ref().unwrap();\n+                        if glob_map.contains_key(&item.id) {\n+                            for n in glob_map[item.id].iter() {\n+                                if name_string.len() > 0 {\n+                                    name_string.push_str(\", \");\n+                                }\n+                                name_string.push_str(n.as_str());\n+                            }\n+                        }\n+\n+                        let sub_span = self.span.sub_span_of_token(path.span,\n+                                                                   token::BinOp(token::Star));\n+                        self.fmt.use_glob_str(path.span,\n+                                              sub_span,\n+                                              item.id,\n+                                              name_string.as_slice(),\n+                                              self.cur_scope);\n+                        self.write_sub_paths(path);\n+                    }\n+                    ast::ViewPathList(ref path, ref list) => {\n+                        for plid in list.iter() {\n+                            match plid.node {\n+                                ast::PathListIdent { id, .. } => {\n+                                    match self.lookup_type_ref(id) {\n+                                        Some(def_id) =>\n+                                            match self.lookup_def_kind(id, plid.span) {\n+                                                Some(kind) => {\n+                                                    self.fmt.ref_str(\n+                                                        kind, plid.span,\n+                                                        Some(plid.span),\n+                                                        def_id, self.cur_scope);\n+                                                }\n+                                                None => ()\n+                                            },\n+                                        None => ()\n+                                    }\n+                                },\n+                                ast::PathListMod { .. } => ()\n+                            }\n+                        }\n+\n+                        self.write_sub_paths(path);\n+                    }\n+                }\n+            }\n+            ast::ItemExternCrate(ref s) => {\n+                let name = get_ident(item.ident);\n+                let name = name.get();\n+                let s = match *s {\n+                    Some((ref s, _)) => s.get().to_string(),\n+                    None => name.to_string(),\n+                };\n+                let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Crate);\n+                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => 0,\n+                };\n+                self.fmt.extern_crate_str(item.span,\n+                                          sub_span,\n+                                          item.id,\n+                                          cnum,\n+                                          name,\n+                                          &s[],\n+                                          self.cur_scope);\n+            }\n             ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, mt, ref expr) =>\n@@ -1160,119 +1264,6 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        if generated_code(i.span) {\n-            return\n-        }\n-\n-        match i.node {\n-            ast::ViewItemUse(ref item) => {\n-                match item.node {\n-                    ast::ViewPathSimple(ident, ref path, id) => {\n-                        let sub_span = self.span.span_for_last_ident(path.span);\n-                        let mod_id = match self.lookup_type_ref(id) {\n-                            Some(def_id) => {\n-                                match self.lookup_def_kind(id, path.span) {\n-                                    Some(kind) => self.fmt.ref_str(kind,\n-                                                                   path.span,\n-                                                                   sub_span,\n-                                                                   def_id,\n-                                                                   self.cur_scope),\n-                                    None => {},\n-                                }\n-                                Some(def_id)\n-                            },\n-                            None => None,\n-                        };\n-\n-                        // 'use' always introduces an alias, if there is not an explicit\n-                        // one, there is an implicit one.\n-                        let sub_span =\n-                            match self.span.sub_span_after_keyword(item.span, keywords::As) {\n-                                Some(sub_span) => Some(sub_span),\n-                                None => sub_span,\n-                            };\n-\n-                        self.fmt.use_alias_str(path.span,\n-                                               sub_span,\n-                                               id,\n-                                               mod_id,\n-                                               get_ident(ident).get(),\n-                                               self.cur_scope);\n-                        self.write_sub_paths_truncated(path);\n-                    }\n-                    ast::ViewPathGlob(ref path, id) => {\n-                        // Make a comma-separated list of names of imported modules.\n-                        let mut name_string = String::new();\n-                        let glob_map = &self.analysis.glob_map;\n-                        let glob_map = glob_map.as_ref().unwrap();\n-                        if glob_map.contains_key(&id) {\n-                            for n in glob_map[id].iter() {\n-                                if name_string.len() > 0 {\n-                                    name_string.push_str(\", \");\n-                                }\n-                                name_string.push_str(n.as_str());\n-                            }\n-                        }\n-\n-                        let sub_span = self.span.sub_span_of_token(path.span,\n-                                                                   token::BinOp(token::Star));\n-                        self.fmt.use_glob_str(path.span,\n-                                              sub_span,\n-                                              id,\n-                                              name_string.as_slice(),\n-                                              self.cur_scope);\n-                        self.write_sub_paths(path);\n-                    }\n-                    ast::ViewPathList(ref path, ref list, _) => {\n-                        for plid in list.iter() {\n-                            match plid.node {\n-                                ast::PathListIdent { id, .. } => {\n-                                    match self.lookup_type_ref(id) {\n-                                        Some(def_id) =>\n-                                            match self.lookup_def_kind(id, plid.span) {\n-                                                Some(kind) => {\n-                                                    self.fmt.ref_str(\n-                                                        kind, plid.span,\n-                                                        Some(plid.span),\n-                                                        def_id, self.cur_scope);\n-                                                }\n-                                                None => ()\n-                                            },\n-                                        None => ()\n-                                    }\n-                                },\n-                                ast::PathListMod { .. } => ()\n-                            }\n-                        }\n-\n-                        self.write_sub_paths(path);\n-                    }\n-                }\n-            },\n-            ast::ViewItemExternCrate(ident, ref s, id) => {\n-                let name = get_ident(ident);\n-                let name = name.get();\n-                let s = match *s {\n-                    Some((ref s, _)) => s.get().to_string(),\n-                    None => name.to_string(),\n-                };\n-                let sub_span = self.span.sub_span_after_keyword(i.span, keywords::Crate);\n-                let cnum = match self.sess.cstore.find_extern_mod_stmt_cnum(id) {\n-                    Some(cnum) => cnum,\n-                    None => 0,\n-                };\n-                self.fmt.extern_crate_str(i.span,\n-                                          sub_span,\n-                                          id,\n-                                          cnum,\n-                                          name,\n-                                          &s[],\n-                                          self.cur_scope);\n-            },\n-        }\n-    }\n-\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         if generated_code(t.span) {\n             return"}, {"sha": "97b3cda006bf7b36441b53b188ac58aacd105c8b", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -40,8 +40,8 @@ impl<'a> SpanUtils<'a> {\n         format!(\"file_name,{},file_line,{},file_col,{},extent_start,{},extent_start_bytes,{},\\\n                  file_line_end,{},file_col_end,{},extent_end,{},extent_end_bytes,{}\",\n                 lo_loc.file.name,\n-                lo_loc.line, lo_loc.col.to_uint(), lo_pos.to_uint(), lo_pos_byte.to_uint(),\n-                hi_loc.line, hi_loc.col.to_uint(), hi_pos.to_uint(), hi_pos_byte.to_uint())\n+                lo_loc.line, lo_loc.col.to_usize(), lo_pos.to_usize(), lo_pos_byte.to_usize(),\n+                hi_loc.line, hi_loc.col.to_usize(), hi_pos.to_usize(), hi_pos_byte.to_usize())\n     }\n \n     // sub_span starts at span.lo, so we need to adjust the positions etc."}, {"sha": "dcb0b0ef4ea378c993cea041eb799c131addcd8d", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -208,10 +208,10 @@ use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::expr::{self, Dest};\n use trans::tvec;\n use trans::type_of;\n-use trans::debuginfo;\n use middle::ty::{self, Ty};\n use session::config::FullDebugInfo;\n use util::common::indenter;\n@@ -472,7 +472,7 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n             let mut r = pats[..col].to_vec();\n-            r.push_all(&pats[(col + 1)..]);\n+            r.push_all(&pats[col + 1..]);\n             Some(r)\n         } else {\n             None\n@@ -632,7 +632,7 @@ fn bind_subslice_pat(bcx: Block,\n \n     let slice_begin = InBoundsGEP(bcx, base, &[C_uint(bcx.ccx(), offset_left)]);\n     let slice_len_offset = C_uint(bcx.ccx(), offset_left + offset_right);\n-    let slice_len = Sub(bcx, len, slice_len_offset);\n+    let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n                                 bcx.tcx().mk_region(ty::ReStatic),\n                                 ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n@@ -656,7 +656,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     elems.extend(range(0, before).map(|i| GEPi(bcx, base, &[i])));\n     elems.extend(range(0, after).rev().map(|i| {\n         InBoundsGEP(bcx, base, &[\n-            Sub(bcx, len, C_uint(bcx.ccx(), i + 1))\n+            Sub(bcx, len, C_uint(bcx.ccx(), i + 1), DebugLoc::None)\n         ])\n     }));\n     ExtractedBlock { vals: elems, bcx: bcx }\n@@ -731,7 +731,7 @@ impl FailureHandler {\n             Infallible =>\n                 panic!(\"attempted to panic in a non-panicking panic handler!\"),\n             JumpToBasicBlock(basic_block) =>\n-                Br(bcx, basic_block),\n+                Br(bcx, basic_block, DebugLoc::None),\n             Unreachable =>\n                 build::Unreachable(bcx)\n         }\n@@ -889,7 +889,7 @@ fn compile_guard<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    with_cond(bcx, Not(bcx, val), |bcx| {\n+    with_cond(bcx, Not(bcx, val, guard_expr.debug_loc()), |bcx| {\n         // Guard does not match: remove all bindings from the lllocals table\n         for (_, &binding_info) in data.bindings_map.iter() {\n             call_lifetime_end(bcx, binding_info.llmatch);\n@@ -966,7 +966,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n                 _ => ()\n             }\n-            Br(bcx, data.bodycx.llbb);\n+            Br(bcx, data.bodycx.llbb, DebugLoc::None);\n         }\n     }\n }\n@@ -983,7 +983,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let dm = &tcx.def_map;\n \n     let mut vals_left = vals[0u..col].to_vec();\n-    vals_left.push_all(&vals[(col + 1u)..]);\n+    vals_left.push_all(&vals[col + 1u..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1096,7 +1096,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         if !exhaustive || i + 1 < len {\n             opt_cx = bcx.fcx.new_temp_block(\"match_case\");\n             match kind {\n-                Single => Br(bcx, opt_cx.llbb),\n+                Single => Br(bcx, opt_cx.llbb, DebugLoc::None),\n                 Switch => {\n                     match opt.trans(bcx) {\n                         SingleResult(r) => {\n@@ -1131,7 +1131,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                     compare_scalar_types(\n                                     bcx, test_val, vend,\n                                     t, ast::BiLe);\n-                                Result::new(bcx, And(bcx, llge, llle))\n+                                Result::new(bcx, And(bcx, llge, llle, DebugLoc::None))\n                             }\n                             LowerBound(Result { bcx, val }) => {\n                                 compare_scalar_types(bcx, test_val, val, t, ast::BiGe)\n@@ -1149,12 +1149,12 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                     if i + 1 < len && (guarded || multi_pats || kind == CompareSliceLength) {\n                         branch_chk = Some(JumpToBasicBlock(bcx.llbb));\n                     }\n-                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n+                    CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb, DebugLoc::None);\n                 }\n                 _ => ()\n             }\n         } else if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n \n         let mut size = 0u;\n@@ -1194,7 +1194,7 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // Compile the fall-through case, if any\n     if !exhaustive && kind != Single {\n         if kind == Compare || kind == CompareSliceLength {\n-            Br(bcx, else_cx.llbb);\n+            Br(bcx, else_cx.llbb, DebugLoc::None);\n         }\n         match chk {\n             // If there is only one default arm left, move on to the next"}, {"sha": "c98515cff6857e38017a8466246ab32378d1fc75", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -62,6 +62,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n+use trans::debuginfo::DebugLoc;\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -979,7 +980,7 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n-                Br(variant_cx, bcx_next.llbb);\n+                Br(variant_cx, bcx_next.llbb, DebugLoc::None);\n             }\n \n             bcx_next"}, {"sha": "572dfd165eedabe1c19ea63af49216edce041838", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 40, "deletions": 52, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -57,7 +57,7 @@ use trans::closure;\n use trans::common::{Block, C_bool, C_bytes_in_context, C_i32, C_integral};\n use trans::common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use trans::common::{CrateContext, ExternMap, FunctionContext};\n-use trans::common::{NodeInfo, Result};\n+use trans::common::{Result};\n use trans::common::{node_id_type, return_type_is_void};\n use trans::common::{tydesc_info, type_is_immediate};\n use trans::common::{type_is_zero_size, val_ty};\n@@ -66,7 +66,7 @@ use trans::consts;\n use trans::context::SharedCrateContext;\n use trans::controlflow;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::foreign;\n use trans::glue;\n@@ -362,18 +362,6 @@ pub fn get_extern_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n     }\n }\n \n-// Returns a pointer to the body for the box. The box may be an opaque\n-// box. The result will be casted to the type of body_t, if it is statically\n-// known.\n-pub fn at_box_body<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               body_t: Ty<'tcx>, boxptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"at_box_body\");\n-    let ccx = bcx.ccx();\n-    let ty = Type::at_box(ccx, type_of(ccx, body_t));\n-    let boxptr = PointerCast(bcx, boxptr, ty.ptr_to());\n-    GEPi(bcx, boxptr, &[0u, abi::BOX_FIELD_BODY])\n-}\n-\n fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 info_ty: Ty<'tcx>, it: LangItem) -> ast::DefId {\n     match bcx.tcx().lang_items.require(it) {\n@@ -792,7 +780,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                                        &**variant,\n                                        substs,\n                                        &mut f);\n-                      Br(variant_cx, next_cx.llbb);\n+                      Br(variant_cx, next_cx.llbb, DebugLoc::None);\n                   }\n                   cx = next_cx;\n               }\n@@ -957,7 +945,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                           llfn: ValueRef,\n                           llargs: &[ValueRef],\n                           fn_ty: Ty<'tcx>,\n-                          call_info: Option<NodeInfo>)\n+                          debug_loc: DebugLoc)\n                           -> (ValueRef, Block<'blk, 'tcx>) {\n     let _icx = push_ctxt(\"invoke_\");\n     if bcx.unreachable.get() {\n@@ -983,30 +971,25 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let normal_bcx = bcx.fcx.new_temp_block(\"normal-return\");\n         let landing_pad = bcx.fcx.get_landing_pad();\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n         let llresult = Invoke(bcx,\n                               llfn,\n                               &llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n-                              Some(attributes));\n+                              Some(attributes),\n+                              debug_loc);\n         return (llresult, normal_bcx);\n     } else {\n         debug!(\"calling {} at {:?}\", bcx.val_to_string(llfn), bcx.llbb);\n         for &llarg in llargs.iter() {\n             debug!(\"arg: {}\", bcx.val_to_string(llarg));\n         }\n \n-        match call_info {\n-            Some(info) => debuginfo::set_source_location(bcx.fcx, info.id, info.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        let llresult = Call(bcx, llfn, &llargs[], Some(attributes));\n+        let llresult = Call(bcx,\n+                            llfn,\n+                            &llargs[],\n+                            Some(attributes),\n+                            debug_loc);\n         return (llresult, bcx);\n     }\n }\n@@ -1094,10 +1077,10 @@ pub fn with_cond<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let fcx = bcx.fcx;\n     let next_cx = fcx.new_temp_block(\"next\");\n     let cond_cx = fcx.new_temp_block(\"cond\");\n-    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb);\n+    CondBr(bcx, val, cond_cx.llbb, next_cx.llbb, DebugLoc::None);\n     let after_cx = f(cond_cx);\n     if !after_cx.terminated.get() {\n-        Br(after_cx, next_cx.llbb);\n+        Br(after_cx, next_cx.llbb, DebugLoc::None);\n     }\n     next_cx\n }\n@@ -1113,7 +1096,7 @@ pub fn call_lifetime_start(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_start = ccx.get_intrinsic(&\"llvm.lifetime.start\");\n-    Call(cx, lifetime_start, &[llsize, ptr], None);\n+    Call(cx, lifetime_start, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n@@ -1127,7 +1110,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n     let llsize = C_u64(ccx, machine::llsize_of_alloc(ccx, val_ty(ptr).element_type()));\n     let ptr = PointerCast(cx, ptr, Type::i8p(ccx));\n     let lifetime_end = ccx.get_intrinsic(&\"llvm.lifetime.end\");\n-    Call(cx, lifetime_end, &[llsize, ptr], None);\n+    Call(cx, lifetime_end, &[llsize, ptr], None, DebugLoc::None);\n }\n \n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n@@ -1144,7 +1127,7 @@ pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let size = IntCast(cx, n_bytes, ccx.int_type());\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n-    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);\n+    Call(cx, memcpy, &[dst_ptr, src_ptr, size, align, volatile], None, DebugLoc::None);\n }\n \n pub fn memcpy_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n@@ -1697,13 +1680,14 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n // and builds the return block.\n pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n                              last_bcx: Block<'blk, 'tcx>,\n-                             retty: ty::FnOutput<'tcx>) {\n+                             retty: ty::FnOutput<'tcx>,\n+                             ret_debug_loc: DebugLoc) {\n     let _icx = push_ctxt(\"finish_fn\");\n \n     let ret_cx = match fcx.llreturn.get() {\n         Some(llreturn) => {\n             if !last_bcx.terminated.get() {\n-                Br(last_bcx, llreturn);\n+                Br(last_bcx, llreturn, DebugLoc::None);\n             }\n             raw_block(fcx, false, llreturn)\n         }\n@@ -1713,7 +1697,7 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n     // This shouldn't need to recompute the return type,\n     // as new_fn_ctxt did it already.\n     let substd_retty = fcx.monomorphize(&retty);\n-    build_return_block(fcx, ret_cx, substd_retty);\n+    build_return_block(fcx, ret_cx, substd_retty, ret_debug_loc);\n \n     debuginfo::clear_source_location(fcx);\n     fcx.cleanup();\n@@ -1722,10 +1706,11 @@ pub fn finish_fn<'blk, 'tcx>(fcx: &'blk FunctionContext<'blk, 'tcx>,\n // Builds the return block for a function.\n pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                                       ret_cx: Block<'blk, 'tcx>,\n-                                      retty: ty::FnOutput<'tcx>) {\n+                                      retty: ty::FnOutput<'tcx>,\n+                                      ret_debug_location: DebugLoc) {\n     if fcx.llretslotptr.get().is_none() ||\n        (!fcx.needs_ret_allocas && fcx.caller_expects_out_pointer) {\n-        return RetVoid(ret_cx);\n+        return RetVoid(ret_cx, ret_debug_location);\n     }\n \n     let retslot = if fcx.needs_ret_allocas {\n@@ -1755,26 +1740,26 @@ pub fn build_return_block<'blk, 'tcx>(fcx: &FunctionContext<'blk, 'tcx>,\n                 if let ty::FnConverging(retty) = retty {\n                     store_ty(ret_cx, retval, get_param(fcx.llfn, 0), retty);\n                 }\n-                RetVoid(ret_cx)\n+                RetVoid(ret_cx, ret_debug_location)\n             } else {\n-                Ret(ret_cx, retval)\n+                Ret(ret_cx, retval, ret_debug_location)\n             }\n         }\n         // Otherwise, copy the return value to the ret slot\n         None => match retty {\n             ty::FnConverging(retty) => {\n                 if fcx.caller_expects_out_pointer {\n                     memcpy_ty(ret_cx, get_param(fcx.llfn, 0), retslot, retty);\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, load_ty(ret_cx, retslot, retty))\n+                    Ret(ret_cx, load_ty(ret_cx, retslot, retty), ret_debug_location)\n                 }\n             }\n             ty::FnDiverging => {\n                 if fcx.caller_expects_out_pointer {\n-                    RetVoid(ret_cx)\n+                    RetVoid(ret_cx, ret_debug_location)\n                 } else {\n-                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)))\n+                    Ret(ret_cx, C_undef(Type::nil(fcx.ccx)), ret_debug_location)\n                 }\n             }\n         }\n@@ -1832,7 +1817,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                    .map(|arg| node_id_type(bcx, arg.id))\n                    .collect::<Vec<_>>();\n     let monomorphized_arg_types = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             monomorphized_arg_types\n         }\n \n@@ -1859,7 +1844,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     };\n \n     bcx = match closure_env.kind {\n-        closure::NotClosure | closure::BoxedClosure(..) => {\n+        closure::NotClosure => {\n             copy_args_to_allocas(bcx,\n                                  arg_scope,\n                                  &decl.inputs[],\n@@ -1905,7 +1890,7 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     match fcx.llreturn.get() {\n         Some(_) => {\n-            Br(bcx, fcx.return_exit_block());\n+            Br(bcx, fcx.return_exit_block(), DebugLoc::None);\n             fcx.pop_custom_cleanup_scope(arg_scope);\n         }\n         None => {\n@@ -1924,8 +1909,11 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n+    let ret_debug_loc = DebugLoc::At(fn_cleanup_debug_loc.id,\n+                                     fn_cleanup_debug_loc.span);\n+\n     // Insert the mandatory first few basic blocks before lltop.\n-    finish_fn(&fcx, bcx, output_type);\n+    finish_fn(&fcx, bcx, output_type, ret_debug_loc);\n }\n \n // trans_fn: creates an LLVM function corresponding to a source language\n@@ -1977,7 +1965,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                                  disr: ty::Disr,\n                                                  args: callee::CallArgs,\n                                                  dest: expr::Dest,\n-                                                 call_info: Option<NodeInfo>)\n+                                                 debug_loc: DebugLoc)\n                                                  -> Result<'blk, 'tcx> {\n \n     let ccx = bcx.fcx.ccx;\n@@ -2016,7 +2004,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                       &fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n-                                      call_info);\n+                                      debug_loc);\n             }\n             _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")\n         }\n@@ -2027,7 +2015,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let bcx = match dest {\n         expr::SaveIn(_) => bcx,\n         expr::Ignore => {\n-            glue::drop_ty(bcx, llresult, result_ty, call_info)\n+            glue::drop_ty(bcx, llresult, result_ty, debug_loc)\n         }\n     };\n \n@@ -2094,7 +2082,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         adt::trans_set_discr(bcx, &*repr, dest, disr);\n     }\n \n-    finish_fn(&fcx, bcx, result_ty);\n+    finish_fn(&fcx, bcx, result_ty, DebugLoc::None);\n }\n \n fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span, id: ast::NodeId) {"}, {"sha": "7acac5a12ebd216c8e1132b477881b5512a8a17e", "filename": "src/librustc_trans/trans/build.rs", "status": "modified", "additions": 318, "deletions": 80, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuild.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -20,6 +20,7 @@ use syntax::codemap::Span;\n \n use trans::builder::Builder;\n use trans::type_::Type;\n+use trans::debuginfo::DebugLoc;\n \n use libc::{c_uint, c_char};\n \n@@ -48,41 +49,59 @@ pub fn B<'blk, 'tcx>(cx: Block<'blk, 'tcx>) -> Builder<'blk, 'tcx> {\n // for (panic/break/return statements, call to diverging functions, etc), and\n // further instructions to the block should simply be ignored.\n \n-pub fn RetVoid(cx: Block) {\n-    if cx.unreachable.get() { return; }\n+pub fn RetVoid(cx: Block, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"RetVoid\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret_void();\n }\n \n-pub fn Ret(cx: Block, v: ValueRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Ret(cx: Block, v: ValueRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Ret\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).ret(v);\n }\n \n-pub fn AggregateRet(cx: Block, ret_vals: &[ValueRef]) {\n-    if cx.unreachable.get() { return; }\n+pub fn AggregateRet(cx: Block,\n+                    ret_vals: &[ValueRef],\n+                    debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"AggregateRet\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).aggregate_ret(ret_vals);\n }\n \n-pub fn Br(cx: Block, dest: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+pub fn Br(cx: Block, dest: BasicBlockRef, debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"Br\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).br(dest);\n }\n \n pub fn CondBr(cx: Block,\n               if_: ValueRef,\n               then: BasicBlockRef,\n-              else_: BasicBlockRef) {\n-    if cx.unreachable.get() { return; }\n+              else_: BasicBlockRef,\n+              debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"CondBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).cond_br(if_, then, else_);\n }\n \n@@ -101,10 +120,16 @@ pub fn AddCase(s: ValueRef, on_val: ValueRef, dest: BasicBlockRef) {\n     }\n }\n \n-pub fn IndirectBr(cx: Block, addr: ValueRef, num_dests: uint) {\n-    if cx.unreachable.get() { return; }\n+pub fn IndirectBr(cx: Block,\n+                  addr: ValueRef,\n+                  num_dests: uint,\n+                  debug_loc: DebugLoc) {\n+    if cx.unreachable.get() {\n+        return;\n+    }\n     check_not_terminated(cx);\n     terminate(cx, \"IndirectBr\");\n+    debug_loc.apply(cx.fcx);\n     B(cx).indirect_br(addr, num_dests);\n }\n \n@@ -113,7 +138,8 @@ pub fn Invoke(cx: Block,\n               args: &[ValueRef],\n               then: BasicBlockRef,\n               catch: BasicBlockRef,\n-              attributes: Option<AttrBuilder>)\n+              attributes: Option<AttrBuilder>,\n+              debug_loc: DebugLoc)\n               -> ValueRef {\n     if cx.unreachable.get() {\n         return C_null(Type::i8(cx.ccx()));\n@@ -123,6 +149,7 @@ pub fn Invoke(cx: Block,\n     debug!(\"Invoke({} with arguments ({}))\",\n            cx.val_to_string(fn_),\n            args.iter().map(|a| cx.val_to_string(*a)).collect::<Vec<String>>().connect(\", \"));\n+    debug_loc.apply(cx.fcx);\n     B(cx).invoke(fn_, args, then, catch, attributes)\n }\n \n@@ -143,176 +170,378 @@ pub fn _Undef(val: ValueRef) -> ValueRef {\n }\n \n /* Arithmetic */\n-pub fn Add(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Add(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).add(lhs, rhs)\n }\n \n-pub fn NSWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswadd(lhs, rhs)\n }\n \n-pub fn NUWAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWAdd(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwadd(lhs, rhs)\n }\n \n-pub fn FAdd(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FAdd(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fadd(lhs, rhs)\n }\n \n-pub fn Sub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Sub(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sub(lhs, rhs)\n }\n \n-pub fn NSWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswsub(lhs, rhs)\n }\n \n-pub fn NUWSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWSub(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwsub(lhs, rhs)\n }\n \n-pub fn FSub(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FSub(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fsub(lhs, rhs)\n }\n \n-pub fn Mul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Mul(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).mul(lhs, rhs)\n }\n \n-pub fn NSWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NSWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswmul(lhs, rhs)\n }\n \n-pub fn NUWMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn NUWMul(cx: Block,\n+              lhs: ValueRef,\n+              rhs: ValueRef,\n+              debug_loc: DebugLoc)\n+              -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwmul(lhs, rhs)\n }\n \n-pub fn FMul(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FMul(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fmul(lhs, rhs)\n }\n \n-pub fn UDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn UDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).udiv(lhs, rhs)\n }\n \n-pub fn SDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).sdiv(lhs, rhs)\n }\n \n-pub fn ExactSDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn ExactSDiv(cx: Block,\n+                 lhs: ValueRef,\n+                 rhs: ValueRef,\n+                 debug_loc: DebugLoc)\n+                 -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).exactsdiv(lhs, rhs)\n }\n \n-pub fn FDiv(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FDiv(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fdiv(lhs, rhs)\n }\n \n-pub fn URem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn URem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).urem(lhs, rhs)\n }\n \n-pub fn SRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn SRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).srem(lhs, rhs)\n }\n \n-pub fn FRem(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn FRem(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).frem(lhs, rhs)\n }\n \n-pub fn Shl(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Shl(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).shl(lhs, rhs)\n }\n \n-pub fn LShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn LShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).lshr(lhs, rhs)\n }\n \n-pub fn AShr(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn AShr(cx: Block,\n+            lhs: ValueRef,\n+            rhs: ValueRef,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).ashr(lhs, rhs)\n }\n \n-pub fn And(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn And(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).and(lhs, rhs)\n }\n \n-pub fn Or(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Or(cx: Block,\n+          lhs: ValueRef,\n+          rhs: ValueRef,\n+          debug_loc: DebugLoc)\n+          -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).or(lhs, rhs)\n }\n \n-pub fn Xor(cx: Block, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+pub fn Xor(cx: Block,\n+           lhs: ValueRef,\n+           rhs: ValueRef,\n+           debug_loc: DebugLoc)\n+           -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).xor(lhs, rhs)\n }\n \n-pub fn BinOp(cx: Block, op: Opcode, lhs: ValueRef, rhs: ValueRef)\n+pub fn BinOp(cx: Block,\n+             op: Opcode,\n+             lhs: ValueRef,\n+             rhs: ValueRef,\n+             debug_loc: DebugLoc)\n           -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(lhs); }\n+    if cx.unreachable.get() {\n+        return _Undef(lhs);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).binop(op, lhs, rhs)\n }\n \n-pub fn Neg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Neg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).neg(v)\n }\n \n-pub fn NSWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NSWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nswneg(v)\n }\n \n-pub fn NUWNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn NUWNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).nuwneg(v)\n }\n-pub fn FNeg(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn FNeg(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).fneg(v)\n }\n \n-pub fn Not(cx: Block, v: ValueRef) -> ValueRef {\n-    if cx.unreachable.get() { return _Undef(v); }\n+pub fn Not(cx: Block, v: ValueRef, debug_loc: DebugLoc) -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _Undef(v);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).not(v)\n }\n \n /* Memory */\n-pub fn Malloc(cx: Block, ty: Type) -> ValueRef {\n+pub fn Malloc(cx: Block, ty: Type, debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).malloc(ty)\n     }\n }\n \n-pub fn ArrayMalloc(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n+pub fn ArrayMalloc(cx: Block,\n+                   ty: Type,\n+                   val: ValueRef,\n+                   debug_loc: DebugLoc) -> ValueRef {\n     unsafe {\n         if cx.unreachable.get() {\n             return llvm::LLVMGetUndef(Type::i8p(cx.ccx()).to_ref());\n         }\n+        debug_loc.apply(cx.fcx);\n         B(cx).array_malloc(ty, val)\n     }\n }\n@@ -327,6 +556,7 @@ pub fn Alloca(cx: Block, ty: Type, name: &str) -> ValueRef {\n pub fn AllocaFcx(fcx: &FunctionContext, ty: Type, name: &str) -> ValueRef {\n     let b = fcx.ccx.builder();\n     b.position_before(fcx.alloca_insert_pt.get().unwrap());\n+    DebugLoc::None.apply(fcx);\n     b.alloca(ty, name)\n }\n \n@@ -335,6 +565,7 @@ pub fn ArrayAlloca(cx: Block, ty: Type, val: ValueRef) -> ValueRef {\n         if cx.unreachable.get() { return llvm::LLVMGetUndef(ty.ptr_to().to_ref()); }\n         let b = cx.fcx.ccx.builder();\n         b.position_before(cx.fcx.alloca_insert_pt.get().unwrap());\n+        DebugLoc::None.apply(cx.fcx);\n         b.array_alloca(ty, val)\n     }\n }\n@@ -680,9 +911,16 @@ pub fn InlineAsmCall(cx: Block, asm: *const c_char, cons: *const c_char,\n     B(cx).inline_asm_call(asm, cons, inputs, output, volatile, alignstack, dia)\n }\n \n-pub fn Call(cx: Block, fn_: ValueRef, args: &[ValueRef],\n-            attributes: Option<AttrBuilder>) -> ValueRef {\n-    if cx.unreachable.get() { return _UndefReturn(cx, fn_); }\n+pub fn Call(cx: Block,\n+            fn_: ValueRef,\n+            args: &[ValueRef],\n+            attributes: Option<AttrBuilder>,\n+            debug_loc: DebugLoc)\n+            -> ValueRef {\n+    if cx.unreachable.get() {\n+        return _UndefReturn(cx, fn_);\n+    }\n+    debug_loc.apply(cx.fcx);\n     B(cx).call(fn_, args, attributes)\n }\n "}, {"sha": "3c0530bbb9a6497b74f9d01ee7c811db1a14e5d0", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -361,7 +361,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                     }\n                     _ => unreachable!(),\n                 };\n-                let vec_len = llvec_len(&cls[(i + 1u)..]);\n+                let vec_len = llvec_len(&cls[i + 1u..]);\n                 let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "7ed4727404e10557c960976b787ec3aacee1a240", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -40,6 +40,7 @@ use trans::common;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::glue;\n use trans::inline;\n@@ -356,7 +357,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            ArgVals(&llargs[]),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n \n@@ -646,7 +647,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// For non-lang items, `dest` is always Some, and hence the result is written into memory\n /// somewhere. Nonetheless we return the actual return value of the function.\n pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                           call_info: Option<NodeInfo>,\n+                                           call_info: Option<NodeIdAndSpan>,\n                                            callee_ty: Ty<'tcx>,\n                                            get_callee: F,\n                                            args: CallArgs<'a, 'tcx>,\n@@ -703,7 +704,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                                        disr,\n                                                        args,\n                                                        dest.unwrap(),\n-                                                       call_info);\n+                                                       call_info.debug_loc());\n         }\n     };\n \n@@ -781,7 +782,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n                                       llfn,\n                                       &llargs[],\n                                       callee_ty,\n-                                      call_info);\n+                                      call_info.debug_loc());\n         bcx = b;\n         llresult = llret;\n \n@@ -828,7 +829,10 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     match (dest, opt_llretslot, ret_ty) {\n         (Some(expr::Ignore), Some(llretslot), ty::FnConverging(ret_ty)) => {\n             // drop the value if it is not being saved.\n-            bcx = glue::drop_ty(bcx, llretslot, ret_ty, call_info);\n+            bcx = glue::drop_ty(bcx,\n+                                llretslot,\n+                                ret_ty,\n+                                call_info.debug_loc());\n             call_lifetime_end(bcx, llretslot);\n         }\n         _ => {}"}, {"sha": "a25f4f778ab7ac34f903801b12ebe240e59976be", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,8 +21,8 @@ use trans::base;\n use trans::build;\n use trans::callee;\n use trans::common;\n-use trans::common::{Block, FunctionContext, ExprId, NodeInfo};\n-use trans::debuginfo;\n+use trans::common::{Block, FunctionContext, ExprId, NodeIdAndSpan};\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::glue;\n use middle::region;\n use trans::type_::Type;\n@@ -44,7 +44,7 @@ pub struct CleanupScope<'blk, 'tcx: 'blk> {\n \n     // The debug location any drop calls generated for this scope will be\n     // associated with.\n-    debug_loc: Option<NodeInfo>,\n+    debug_loc: DebugLoc,\n \n     cached_early_exits: Vec<CachedEarlyExit>,\n     cached_landing_pad: Option<BasicBlockRef>,\n@@ -65,7 +65,7 @@ pub enum CleanupScopeKind<'blk, 'tcx: 'blk> {\n     LoopScopeKind(ast::NodeId, [Block<'blk, 'tcx>; EXIT_MAX])\n }\n \n-impl<'blk, 'tcx: 'blk> fmt::Show for CleanupScopeKind<'blk, 'tcx> {\n+impl<'blk, 'tcx: 'blk> fmt::Debug for CleanupScopeKind<'blk, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             CustomScopeKind => write!(f, \"CustomScopeKind\"),\n@@ -100,7 +100,7 @@ pub trait Cleanup<'tcx> {\n     fn is_lifetime_end(&self) -> bool;\n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx>;\n }\n \n@@ -114,7 +114,7 @@ pub enum ScopeId {\n \n impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n     /// Invoked when we start to trans the code contained within a new cleanup scope.\n-    fn push_ast_cleanup_scope(&self, debug_loc: NodeInfo) {\n+    fn push_ast_cleanup_scope(&self, debug_loc: NodeIdAndSpan) {\n         debug!(\"push_ast_cleanup_scope({})\",\n                self.ccx.tcx().map.node_to_string(debug_loc.id));\n \n@@ -139,7 +139,7 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         }\n \n         self.push_scope(CleanupScope::new(AstScopeKind(debug_loc.id),\n-                                          Some(debug_loc)));\n+                                          debug_loc.debug_loc()));\n     }\n \n     fn push_loop_cleanup_scope(&self,\n@@ -168,19 +168,20 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n                             .borrow()\n                             .last()\n                             .map(|opt_scope| opt_scope.debug_loc)\n-                            .unwrap_or(None);\n+                            .unwrap_or(DebugLoc::None);\n \n         self.push_scope(CleanupScope::new(CustomScopeKind, debug_loc));\n         CustomScopeIndex { index: index }\n     }\n \n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex {\n         let index = self.scopes_len();\n         debug!(\"push_custom_cleanup_scope(): {}\", index);\n \n-        self.push_scope(CleanupScope::new(CustomScopeKind, Some(debug_loc)));\n+        self.push_scope(CleanupScope::new(CustomScopeKind,\n+                                          debug_loc.debug_loc()));\n         CustomScopeIndex { index: index }\n     }\n \n@@ -664,7 +665,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                                                 scope.debug_loc);\n                     }\n                 }\n-                build::Br(bcx_out, prev_llbb);\n+                build::Br(bcx_out, prev_llbb, DebugLoc::None);\n                 prev_llbb = bcx_in.llbb;\n             } else {\n                 debug!(\"no suitable cleanups in {}\",\n@@ -766,15 +767,15 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n \n         // Generate the cleanup block and branch to it.\n         let cleanup_llbb = self.trans_cleanups_to_exit_scope(UnwindExit);\n-        build::Br(pad_bcx, cleanup_llbb);\n+        build::Br(pad_bcx, cleanup_llbb, DebugLoc::None);\n \n         return pad_bcx.llbb;\n     }\n }\n \n impl<'blk, 'tcx> CleanupScope<'blk, 'tcx> {\n     fn new(kind: CleanupScopeKind<'blk, 'tcx>,\n-           debug_loc: Option<NodeInfo>)\n+           debug_loc: DebugLoc)\n         -> CleanupScope<'blk, 'tcx> {\n         CleanupScope {\n             kind: kind,\n@@ -896,7 +897,7 @@ impl<'tcx> Cleanup<'tcx> for DropValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n         let bcx = if self.is_immediate {\n             glue::drop_ty_immediate(bcx, self.val, self.ty, debug_loc)\n@@ -937,9 +938,9 @@ impl<'tcx> Cleanup<'tcx> for FreeValue<'tcx> {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -972,9 +973,9 @@ impl<'tcx> Cleanup<'tcx> for FreeSlice {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n \n         match self.heap {\n             HeapExchange => {\n@@ -1004,9 +1005,9 @@ impl<'tcx> Cleanup<'tcx> for LifetimeEnd {\n \n     fn trans<'blk>(&self,\n                    bcx: Block<'blk, 'tcx>,\n-                   debug_loc: Option<NodeInfo>)\n+                   debug_loc: DebugLoc)\n                    -> Block<'blk, 'tcx> {\n-        apply_debug_loc(bcx.fcx, debug_loc);\n+        debug_loc.apply(bcx.fcx);\n         base::call_lifetime_end(bcx, self.ptr);\n         bcx\n     }\n@@ -1041,33 +1042,22 @@ fn cleanup_is_suitable_for(c: &Cleanup,\n     !label.is_unwind() || c.clean_on_unwind()\n }\n \n-fn apply_debug_loc(fcx: &FunctionContext, debug_loc: Option<NodeInfo>) {\n-    match debug_loc {\n-        Some(ref src_loc) => {\n-            debuginfo::set_source_location(fcx, src_loc.id, src_loc.span);\n-        }\n-        None => {\n-            debuginfo::clear_source_location(fcx);\n-        }\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // These traits just exist to put the methods into this file.\n \n pub trait CleanupMethods<'blk, 'tcx> {\n-    fn push_ast_cleanup_scope(&self, id: NodeInfo);\n+    fn push_ast_cleanup_scope(&self, id: NodeIdAndSpan);\n     fn push_loop_cleanup_scope(&self,\n                                id: ast::NodeId,\n                                exits: [Block<'blk, 'tcx>; EXIT_MAX]);\n     fn push_custom_cleanup_scope(&self) -> CustomScopeIndex;\n     fn push_custom_cleanup_scope_with_debug_loc(&self,\n-                                                debug_loc: NodeInfo)\n+                                                debug_loc: NodeIdAndSpan)\n                                                 -> CustomScopeIndex;\n     fn pop_and_trans_ast_cleanup_scope(&self,\n-                                              bcx: Block<'blk, 'tcx>,\n-                                              cleanup_scope: ast::NodeId)\n-                                              -> Block<'blk, 'tcx>;\n+                                       bcx: Block<'blk, 'tcx>,\n+                                       cleanup_scope: ast::NodeId)\n+                                       -> Block<'blk, 'tcx>;\n     fn pop_loop_cleanup_scope(&self,\n                               cleanup_scope: ast::NodeId);\n     fn pop_custom_cleanup_scope(&self,"}, {"sha": "7a6c0c50dd1ffed8223b22dc095396016fe1900f", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 319, "changes": 322, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -10,278 +10,34 @@\n \n pub use self::ClosureKind::*;\n \n-use back::abi;\n use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::cleanup::{CleanupMethods, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, Lvalue, rvalue_scratch_datum};\n+use trans::datum::{Datum, rvalue_scratch_datum};\n use trans::datum::{Rvalue, ByValue};\n use trans::debuginfo;\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n-use trans::type_::Type;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::{self, UnboxedClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n-use util::ppaux::ty_to_string;\n \n use syntax::ast;\n use syntax::ast_util;\n \n-// ___Good to know (tm)__________________________________________________\n-//\n-// The layout of a closure environment in memory is\n-// roughly as follows:\n-//\n-// struct rust_opaque_box {         // see rust_internal.h\n-//   unsigned ref_count;            // obsolete (part of @T's header)\n-//   fn(void*) *drop_glue;          // destructor (for proc)\n-//   rust_opaque_box *prev;         // obsolete (part of @T's header)\n-//   rust_opaque_box *next;         // obsolete (part of @T's header)\n-//   struct closure_data {\n-//       upvar1_t upvar1;\n-//       ...\n-//       upvarN_t upvarN;\n-//    }\n-// };\n-//\n-// Note that the closure is itself a rust_opaque_box.  This is true\n-// even for ~fn and ||, because we wish to keep binary compatibility\n-// between all kinds of closures.  The allocation strategy for this\n-// closure depends on the closure type.  For a sendfn, the closure\n-// (and the referenced type descriptors) will be allocated in the\n-// exchange heap.  For a fn, the closure is allocated in the task heap\n-// and is reference counted.  For a block, the closure is allocated on\n-// the stack.\n-//\n-// ## Opaque closures and the embedded type descriptor ##\n-//\n-// One interesting part of closures is that they encapsulate the data\n-// that they close over.  So when I have a ptr to a closure, I do not\n-// know how many type descriptors it contains nor what upvars are\n-// captured within.  That means I do not know precisely how big it is\n-// nor where its fields are located.  This is called an \"opaque\n-// closure\".\n-//\n-// Typically an opaque closure suffices because we only manipulate it\n-// by ptr.  The routine Type::at_box().ptr_to() returns an appropriate\n-// type for such an opaque closure; it allows access to the box fields,\n-// but not the closure_data itself.\n-//\n-// But sometimes, such as when cloning or freeing a closure, we need\n-// to know the full information.  That is where the type descriptor\n-// that defines the closure comes in handy.  We can use its take and\n-// drop glue functions to allocate/free data as needed.\n-//\n-// ## Subtleties concerning alignment ##\n-//\n-// It is important that we be able to locate the closure data *without\n-// knowing the kind of data that is being bound*.  This can be tricky\n-// because the alignment requirements of the bound data affects the\n-// alignment requires of the closure_data struct as a whole.  However,\n-// right now this is a non-issue in any case, because the size of the\n-// rust_opaque_box header is always a multiple of 16-bytes, which is\n-// the maximum alignment requirement we ever have to worry about.\n-//\n-// The only reason alignment matters is that, in order to learn what data\n-// is bound, we would normally first load the type descriptors: but their\n-// location is ultimately depend on their content!  There is, however, a\n-// workaround.  We can load the tydesc from the rust_opaque_box, which\n-// describes the closure_data struct and has self-contained derived type\n-// descriptors, and read the alignment from there.   It's just annoying to\n-// do.  Hopefully should this ever become an issue we'll have monomorphized\n-// and type descriptors will all be a bad dream.\n-//\n-// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-\n-#[derive(Copy)]\n-pub struct EnvValue<'tcx> {\n-    action: ast::CaptureClause,\n-    datum: Datum<'tcx, Lvalue>\n-}\n-\n-impl<'tcx> EnvValue<'tcx> {\n-    pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"{:?}({})\", self.action, self.datum.to_string(ccx))\n-    }\n-}\n-\n-// Given a closure ty, emits a corresponding tuple ty\n-pub fn mk_closure_tys<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            bound_values: &[EnvValue<'tcx>])\n-                            -> Ty<'tcx> {\n-    // determine the types of the values in the env.  Note that this\n-    // is the actual types that will be stored in the map, not the\n-    // logical types as the user sees them, so by-ref upvars must be\n-    // converted to ptrs.\n-    let bound_tys = bound_values.iter().map(|bv| {\n-        match bv.action {\n-            ast::CaptureByValue => bv.datum.ty,\n-            ast::CaptureByRef => ty::mk_mut_ptr(tcx, bv.datum.ty)\n-        }\n-    }).collect();\n-    let cdata_ty = ty::mk_tup(tcx, bound_tys);\n-    debug!(\"cdata_ty={}\", ty_to_string(tcx, cdata_ty));\n-    return cdata_ty;\n-}\n-\n-fn tuplify_box_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Ty<'tcx> {\n-    let ptr = ty::mk_imm_ptr(tcx, tcx.types.i8);\n-    ty::mk_tup(tcx, vec!(tcx.types.uint, ty::mk_nil_ptr(tcx), ptr, ptr, t))\n-}\n-\n-pub struct ClosureResult<'blk, 'tcx: 'blk> {\n-    llbox: ValueRef,        // llvalue of ptr to closure\n-    cdata_ty: Ty<'tcx>,     // type of the closure data\n-    bcx: Block<'blk, 'tcx>  // final bcx\n-}\n-\n-// Given a block context and a list of tydescs and values to bind\n-// construct a closure out of them. If copying is true, it is a\n-// heap allocated closure that copies the upvars into environment.\n-// Otherwise, it is stack allocated and copies pointers to the upvars.\n-pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                     bound_values: Vec<EnvValue<'tcx>>)\n-                                     -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::store_environment\");\n-    let ccx = bcx.ccx();\n-    let tcx = ccx.tcx();\n-\n-    // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, &bound_values[]);\n-\n-    // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n-    // tuple.  This could be a ptr in uniq or a box or on stack,\n-    // whatever.\n-    let cbox_ty = tuplify_box_ty(tcx, cdata_ty);\n-    let cboxptr_ty = ty::mk_ptr(tcx, ty::mt {ty:cbox_ty, mutbl:ast::MutImmutable});\n-    let llboxptr_ty = type_of(ccx, cboxptr_ty);\n-\n-    // If there are no bound values, no point in allocating anything.\n-    if bound_values.is_empty() {\n-        return ClosureResult {llbox: C_null(llboxptr_ty),\n-                              cdata_ty: cdata_ty,\n-                              bcx: bcx};\n-    }\n-\n-    // allocate closure in the heap\n-    let llbox = alloc_ty(bcx, cbox_ty, \"__closure\");\n-\n-    let llbox = PointerCast(bcx, llbox, llboxptr_ty);\n-    debug!(\"tuplify_box_ty = {}\", ty_to_string(tcx, cbox_ty));\n-\n-    // Copy expr values into boxed bindings.\n-    let mut bcx = bcx;\n-    for (i, bv) in bound_values.into_iter().enumerate() {\n-        debug!(\"Copy {} into closure\", bv.to_string(ccx));\n-\n-        if ccx.sess().asm_comments() {\n-            add_comment(bcx, &format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx))[]);\n-        }\n-\n-        let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n-\n-        match bv.action {\n-            ast::CaptureByValue => {\n-                bcx = bv.datum.store_to(bcx, bound_data);\n-            }\n-            ast::CaptureByRef => {\n-                Store(bcx, bv.datum.to_llref(), bound_data);\n-            }\n-        }\n-    }\n-\n-    ClosureResult { llbox: llbox, cdata_ty: cdata_ty, bcx: bcx }\n-}\n-\n-// Given a context and a list of upvars, build a closure. This just\n-// collects the upvars and packages them up for store_environment.\n-fn build_closure<'blk, 'tcx>(bcx0: Block<'blk, 'tcx>,\n-                             freevar_mode: ast::CaptureClause,\n-                             freevars: &Vec<ty::Freevar>)\n-                             -> ClosureResult<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::build_closure\");\n-\n-    // If we need to, package up the iterator body to call\n-    let bcx = bcx0;\n-\n-    // Package up the captured upvars\n-    let mut env_vals = Vec::new();\n-    for freevar in freevars.iter() {\n-        let datum = expr::trans_local_var(bcx, freevar.def);\n-        env_vals.push(EnvValue {action: freevar_mode, datum: datum});\n-    }\n-\n-    store_environment(bcx, env_vals)\n-}\n-\n-// Given an enclosing block context, a new function context, a closure type,\n-// and a list of upvars, generate code to load and populate the environment\n-// with the upvars and type descriptors.\n-fn load_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                cdata_ty: Ty<'tcx>,\n-                                freevars: &[ty::Freevar],\n-                                store: ty::TraitStore)\n-                                -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n-\n-    // Load a pointer to the closure data, skipping over the box header:\n-    let llcdata = at_box_body(bcx, cdata_ty, bcx.fcx.llenv.unwrap());\n-\n-    // Store the pointer to closure data in an alloca for debug info because that's what the\n-    // llvm.dbg.declare intrinsic expects\n-    let env_pointer_alloca = if bcx.sess().opts.debuginfo == FullDebugInfo {\n-        let alloc = alloc_ty(bcx, ty::mk_mut_ptr(bcx.tcx(), cdata_ty), \"__debuginfo_env_ptr\");\n-        Store(bcx, llcdata, alloc);\n-        Some(alloc)\n-    } else {\n-        None\n-    };\n-\n-    // Populate the upvars from the environment\n-    let mut i = 0u;\n-    for freevar in freevars.iter() {\n-        let mut upvarptr = GEPi(bcx, llcdata, &[0u, i]);\n-        let captured_by_ref = match store {\n-            ty::RegionTraitStore(..) => {\n-                upvarptr = Load(bcx, upvarptr);\n-                true\n-            }\n-            ty::UniqTraitStore => false\n-        };\n-        let def_id = freevar.def.def_id();\n-\n-        bcx.fcx.llupvars.borrow_mut().insert(def_id.node, upvarptr);\n-        if let Some(env_pointer_alloca) = env_pointer_alloca {\n-            debuginfo::create_captured_var_metadata(\n-                bcx,\n-                def_id.node,\n-                env_pointer_alloca,\n-                i,\n-                captured_by_ref,\n-                freevar.span);\n-        }\n-\n-        i += 1u;\n-    }\n-\n-    bcx\n-}\n \n fn load_unboxed_closure_environment<'blk, 'tcx>(\n                                     bcx: Block<'blk, 'tcx>,\n                                     arg_scope_id: ScopeId,\n                                     freevar_mode: ast::CaptureClause,\n                                     freevars: &[ty::Freevar])\n                                     -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::load_environment\");\n+    let _icx = push_ctxt(\"closure::load_unboxed_closure_environment\");\n \n     // Special case for small by-value selfs.\n     let closure_id = ast_util::local_def(bcx.fcx.id);\n@@ -341,17 +97,9 @@ fn load_unboxed_closure_environment<'blk, 'tcx>(\n     bcx\n }\n \n-fn fill_fn_pair(bcx: Block, pair: ValueRef, llfn: ValueRef, llenvptr: ValueRef) {\n-    Store(bcx, llfn, GEPi(bcx, pair, &[0u, abi::FAT_PTR_ADDR]));\n-    let llenvptr = PointerCast(bcx, llenvptr, Type::i8p(bcx.ccx()));\n-    Store(bcx, llenvptr, GEPi(bcx, pair, &[0u, abi::FAT_PTR_EXTRA]));\n-}\n-\n #[derive(PartialEq)]\n pub enum ClosureKind<'tcx> {\n     NotClosure,\n-    // See load_environment.\n-    BoxedClosure(Ty<'tcx>, ty::TraitStore),\n     // See load_unboxed_closure_environment.\n     UnboxedClosure(ast::CaptureClause)\n }\n@@ -379,77 +127,13 @@ impl<'a, 'tcx> ClosureEnv<'a, 'tcx> {\n \n         match self.kind {\n             NotClosure => bcx,\n-            BoxedClosure(cdata_ty, store) => {\n-                load_environment(bcx, cdata_ty, self.freevars, store)\n-            }\n             UnboxedClosure(freevar_mode) => {\n                 load_unboxed_closure_environment(bcx, arg_scope, freevar_mode, self.freevars)\n             }\n         }\n     }\n }\n \n-/// Translates the body of a closure expression.\n-///\n-/// - `store`\n-/// - `decl`\n-/// - `body`\n-/// - `id`: The id of the closure expression.\n-/// - `cap_clause`: information about captured variables, if any.\n-/// - `dest`: where to write the closure value, which must be a\n-///   (fn ptr, env) pair\n-pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 store: ty::TraitStore,\n-                                 decl: &ast::FnDecl,\n-                                 body: &ast::Block,\n-                                 id: ast::NodeId,\n-                                 dest: expr::Dest)\n-                                 -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"closure::trans_expr_fn\");\n-\n-    let dest_addr = match dest {\n-        expr::SaveIn(p) => p,\n-        expr::Ignore => {\n-            return bcx; // closure construction is non-side-effecting\n-        }\n-    };\n-\n-    let ccx = bcx.ccx();\n-    let tcx = bcx.tcx();\n-    let fty = node_id_type(bcx, id);\n-    let s = tcx.map.with_path(id, |path| {\n-        mangle_internal_name_by_path_and_seq(path, \"closure\")\n-    });\n-    let llfn = decl_internal_rust_fn(ccx, fty, &s[]);\n-\n-    // set an inline hint for all closures\n-    set_inline_hint(llfn);\n-\n-    let freevar_mode = tcx.capture_mode(id);\n-    let freevars: Vec<ty::Freevar> =\n-        ty::with_freevars(tcx, id, |fv| fv.iter().map(|&fv| fv).collect());\n-\n-    let ClosureResult {\n-        llbox,\n-        cdata_ty,\n-        bcx\n-    } = build_closure(bcx, freevar_mode, &freevars);\n-\n-    trans_closure(ccx,\n-                  decl,\n-                  body,\n-                  llfn,\n-                  bcx.fcx.param_substs,\n-                  id,\n-                  &[],\n-                  ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n-                  ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(&freevars[],\n-                                  BoxedClosure(cdata_ty, store)));\n-    fill_fn_pair(bcx, dest_addr, llfn, llbox);\n-    bcx\n-}\n-\n /// Returns the LLVM function declaration for an unboxed closure, creating it\n /// if necessary. If the ID does not correspond to a closure ID, returns None.\n pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "3bc851c55953772c02278130695d3ebf70da5885", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -30,7 +30,7 @@ use trans::build;\n use trans::cleanup;\n use trans::consts;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc};\n use trans::machine;\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -275,7 +275,7 @@ pub fn return_type_is_void(ccx: &CrateContext, ty: Ty) -> bool {\n /// Generates a unique symbol based off the name given. This is used to create\n /// unique symbols for things like closures.\n pub fn gensym_name(name: &str) -> PathElem {\n-    let num = token::gensym(name).uint();\n+    let num = token::gensym(name).usize();\n     // use one colon which will get translated to a period by the mangler, and\n     // we're guaranteed that `num` is globally unique for this crate.\n     PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n@@ -317,13 +317,13 @@ pub struct tydesc_info<'tcx> {\n */\n \n #[derive(Copy)]\n-pub struct NodeInfo {\n+pub struct NodeIdAndSpan {\n     pub id: ast::NodeId,\n     pub span: Span,\n }\n \n-pub fn expr_info(expr: &ast::Expr) -> NodeInfo {\n-    NodeInfo { id: expr.id, span: expr.span }\n+pub fn expr_info(expr: &ast::Expr) -> NodeIdAndSpan {\n+    NodeIdAndSpan { id: expr.id, span: expr.span }\n }\n \n pub struct BuilderRef_res {\n@@ -517,7 +517,7 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n         let mut reachable = false;\n         for bcx in in_cxs.iter() {\n             if !bcx.unreachable.get() {\n-                build::Br(*bcx, out.llbb);\n+                build::Br(*bcx, out.llbb, DebugLoc::None);\n                 reachable = true;\n             }\n         }\n@@ -848,7 +848,7 @@ pub fn C_cstr(cx: &CrateContext, s: InternedString, null_terminated: bool) -> Va\n                                                 !null_terminated as Bool);\n \n         let gsym = token::gensym(\"str\");\n-        let buf = CString::from_vec(format!(\"str{}\", gsym.uint()).into_bytes());\n+        let buf = CString::from_vec(format!(\"str{}\", gsym.usize()).into_bytes());\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(sc).to_ref(), buf.as_ptr());\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -873,7 +873,7 @@ pub fn C_binary_slice(cx: &CrateContext, data: &[u8]) -> ValueRef {\n         let lldata = C_bytes(cx, data);\n \n         let gsym = token::gensym(\"binary\");\n-        let name = format!(\"binary{}\", gsym.uint());\n+        let name = format!(\"binary{}\", gsym.usize());\n         let name = CString::from_vec(name.into_bytes());\n         let g = llvm::LLVMAddGlobal(cx.llmod(), val_ty(lldata).to_ref(),\n                                     name.as_ptr());"}, {"sha": "bea8a75997152ba8a4932f98a5b7864ceb100e83", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 39, "deletions": 34, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,6 +22,7 @@ use trans::common::*;\n use trans::consts;\n use trans::datum;\n use trans::debuginfo;\n+use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n use trans::meth;\n use trans::type_::Type;\n@@ -188,20 +189,22 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n+    let cond_source_loc = cond.debug_loc();\n+\n     let next_bcx;\n     match els {\n         Some(elexpr) => {\n             let else_bcx_in = bcx.fcx.new_id_block(\"else-block\", elexpr.id);\n             let else_bcx_out = expr::trans_into(else_bcx_in, &*elexpr, dest);\n             next_bcx = bcx.fcx.join_blocks(if_id,\n                                            &[then_bcx_out, else_bcx_out]);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, else_bcx_in.llbb, cond_source_loc);\n         }\n \n         None => {\n             next_bcx = bcx.fcx.new_id_block(\"next-block\", if_id);\n-            Br(then_bcx_out, next_bcx.llbb);\n-            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb);\n+            Br(then_bcx_out, next_bcx.llbb, DebugLoc::None);\n+            CondBr(bcx, cond_val, then_bcx_in.llbb, next_bcx.llbb, cond_source_loc);\n         }\n     }\n \n@@ -213,7 +216,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n }\n \n pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               loop_id: ast::NodeId,\n+                               loop_expr: &ast::Expr,\n                                cond: &ast::Expr,\n                                body: &ast::Block)\n                                -> Block<'blk, 'tcx> {\n@@ -231,33 +234,34 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     //    |           body_bcx_out --+\n     // next_bcx_in\n \n-    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_id);\n+    let next_bcx_in = fcx.new_id_block(\"while_exit\", loop_expr.id);\n     let cond_bcx_in = fcx.new_id_block(\"while_cond\", cond.id);\n     let body_bcx_in = fcx.new_id_block(\"while_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, cond_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, cond_bcx_in]);\n \n-    Br(bcx, cond_bcx_in.llbb);\n+    Br(bcx, cond_bcx_in.llbb, loop_expr.debug_loc());\n \n     // compile the block where we will handle loop cleanups\n-    let cleanup_llbb = fcx.normal_exit_block(loop_id, cleanup::EXIT_BREAK);\n+    let cleanup_llbb = fcx.normal_exit_block(loop_expr.id, cleanup::EXIT_BREAK);\n \n     // compile the condition\n     let Result {bcx: cond_bcx_out, val: cond_val} =\n         expr::trans(cond_bcx_in, cond).to_llbool();\n-    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb);\n+\n+    CondBr(cond_bcx_out, cond_val, body_bcx_in.llbb, cleanup_llbb, cond.debug_loc());\n \n     // loop body:\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, cond_bcx_in.llbb);\n+    Br(body_bcx_out, cond_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n     return next_bcx_in;\n }\n \n /// Translates a `for` loop.\n pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeInfo,\n+                             loop_info: NodeIdAndSpan,\n                              pat: &ast::Pat,\n                              head: &ast::Expr,\n                              body: &ast::Block)\n@@ -292,7 +296,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n     bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n                                     [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb);\n+    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n     let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n                                                  cleanup::EXIT_BREAK);\n \n@@ -347,7 +351,7 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                               None);\n     let i1_type = Type::i1(loopback_bcx_out.ccx());\n     let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb);\n+    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n \n     // Now we're in the body. Unpack the `Option` value into the programmer-\n     // supplied pattern.\n@@ -377,15 +381,15 @@ pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         body_bcx_out.fcx\n                     .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n                                                         option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb);\n+    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n \n     // Codegen cleanups and leave.\n     next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n     next_bcx_in\n }\n \n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              loop_id: ast::NodeId,\n+                              loop_expr: &ast::Expr,\n                               body: &ast::Block)\n                               -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_loop\");\n@@ -402,22 +406,22 @@ pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Links between body_bcx_in and next_bcx are created by\n     // break statements.\n \n-    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_id);\n+    let next_bcx_in = bcx.fcx.new_id_block(\"loop_exit\", loop_expr.id);\n     let body_bcx_in = bcx.fcx.new_id_block(\"loop_body\", body.id);\n \n-    fcx.push_loop_cleanup_scope(loop_id, [next_bcx_in, body_bcx_in]);\n+    fcx.push_loop_cleanup_scope(loop_expr.id, [next_bcx_in, body_bcx_in]);\n \n-    Br(bcx, body_bcx_in.llbb);\n+    Br(bcx, body_bcx_in.llbb, loop_expr.debug_loc());\n     let body_bcx_out = trans_block(body_bcx_in, body, expr::Ignore);\n-    Br(body_bcx_out, body_bcx_in.llbb);\n+    Br(body_bcx_out, body_bcx_in.llbb, DebugLoc::None);\n \n-    fcx.pop_loop_cleanup_scope(loop_id);\n+    fcx.pop_loop_cleanup_scope(loop_expr.id);\n \n     return next_bcx_in;\n }\n \n pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    expr_id: ast::NodeId,\n+                                    expr: &ast::Expr,\n                                     opt_label: Option<Ident>,\n                                     exit: uint)\n                                     -> Block<'blk, 'tcx> {\n@@ -432,7 +436,7 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let loop_id = match opt_label {\n         None => fcx.top_loop_scope(),\n         Some(_) => {\n-            match bcx.tcx().def_map.borrow().get(&expr_id) {\n+            match bcx.tcx().def_map.borrow().get(&expr.id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n                     bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n@@ -444,39 +448,40 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Generate appropriate cleanup code and branch\n     let cleanup_llbb = fcx.normal_exit_block(loop_id, exit);\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, expr.debug_loc());\n     Unreachable(bcx); // anything afterwards should be ignored\n     return bcx;\n }\n \n pub fn trans_break<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                               expr_id: ast::NodeId,\n+                               expr: &ast::Expr,\n                                label_opt: Option<Ident>)\n                                -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_BREAK);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_BREAK);\n }\n \n pub fn trans_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              expr_id: ast::NodeId,\n+                              expr: &ast::Expr,\n                               label_opt: Option<Ident>)\n                               -> Block<'blk, 'tcx> {\n-    return trans_break_cont(bcx, expr_id, label_opt, cleanup::EXIT_LOOP);\n+    return trans_break_cont(bcx, expr, label_opt, cleanup::EXIT_LOOP);\n }\n \n pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             e: Option<&ast::Expr>)\n+                             return_expr: &ast::Expr,\n+                             retval_expr: Option<&ast::Expr>)\n                              -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_ret\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n-    let dest = match (fcx.llretslotptr.get(), e) {\n-        (Some(_), Some(e)) => {\n-            let ret_ty = expr_ty(bcx, &*e);\n+    let dest = match (fcx.llretslotptr.get(), retval_expr) {\n+        (Some(_), Some(retval_expr)) => {\n+            let ret_ty = expr_ty(bcx, &*retval_expr);\n             expr::SaveIn(fcx.get_ret_slot(bcx, ty::FnConverging(ret_ty), \"ret_slot\"))\n         }\n         _ => expr::Ignore,\n     };\n-    if let Some(x) = e {\n+    if let Some(x) = retval_expr {\n         bcx = expr::trans_into(bcx, &*x, dest);\n         match dest {\n             expr::SaveIn(slot) if fcx.needs_ret_allocas => {\n@@ -486,7 +491,7 @@ pub fn trans_ret<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     }\n     let cleanup_llbb = fcx.return_exit_block();\n-    Br(bcx, cleanup_llbb);\n+    Br(bcx, cleanup_llbb, return_expr.debug_loc());\n     Unreachable(bcx);\n     return bcx;\n }"}, {"sha": "cba12babb9b105aa674f179c3f139f7528f3673d", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -481,7 +481,7 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n }\n \n /// Generic methods applicable to any sort of datum.\n-impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n+impl<'tcx, K: KindOps + fmt::Debug> Datum<'tcx, K> {\n     pub fn new(val: ValueRef, ty: Ty<'tcx>, kind: K) -> Datum<'tcx, K> {\n         Datum { val: val, ty: ty, kind: kind }\n     }\n@@ -591,7 +591,7 @@ impl<'blk, 'tcx, K> DatumBlock<'blk, 'tcx, K> {\n     }\n }\n \n-impl<'blk, 'tcx, K: KindOps + fmt::Show> DatumBlock<'blk, 'tcx, K> {\n+impl<'blk, 'tcx, K: KindOps + fmt::Debug> DatumBlock<'blk, 'tcx, K> {\n     pub fn to_expr_datumblock(self) -> DatumBlock<'blk, 'tcx, Expr> {\n         DatumBlock::new(self.bcx, self.datum.to_expr_datum())\n     }"}, {"sha": "9df1b236fe8f64fbac2a725f610516004d65f4a6", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 71, "deletions": 52, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -188,15 +188,16 @@ use self::MemberOffset::*;\n use self::MemberDescriptionFactory::*;\n use self::RecursiveTypeDescription::*;\n use self::EnumDiscriminantInfo::*;\n-use self::DebugLocation::*;\n+use self::InternalDebugLocation::*;\n \n use llvm;\n use llvm::{ModuleRef, ContextRef, ValueRef};\n use llvm::debuginfo::*;\n use metadata::csearch;\n use middle::subst::{self, Substs};\n use trans::{self, adt, machine, type_of};\n-use trans::common::*;\n+use trans::common::{self, NodeIdAndSpan, CrateContext, FunctionContext, Block,\n+                    C_bytes, C_i32, C_i64, NormalizingUnboxedClosureTyper};\n use trans::_match::{BindingInfo, TrByCopy, TrByMove, TrByRef};\n use trans::monomorphize;\n use trans::type_::Type;\n@@ -551,28 +552,14 @@ impl<'tcx> TypeMap<'tcx> {\n                                               closure_ty: ty::ClosureTy<'tcx>,\n                                               unique_type_id: &mut String) {\n         let ty::ClosureTy { unsafety,\n-                            onceness,\n-                            store,\n-                            ref bounds,\n                             ref sig,\n                             abi: _ } = closure_ty;\n+\n         if unsafety == ast::Unsafety::Unsafe {\n             unique_type_id.push_str(\"unsafe \");\n         }\n \n-        if onceness == ast::Once {\n-            unique_type_id.push_str(\"once \");\n-        }\n-\n-        match store {\n-            ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n-            ty::RegionTraitStore(_, ast::MutMutable) => {\n-                unique_type_id.push_str(\"&mut|\")\n-            }\n-            ty::RegionTraitStore(_, ast::MutImmutable) => {\n-                unique_type_id.push_str(\"&|\")\n-            }\n-        };\n+        unique_type_id.push_str(\"|\");\n \n         let sig = ty::erase_late_bound_regions(cx.tcx(), sig);\n \n@@ -601,18 +588,6 @@ impl<'tcx> TypeMap<'tcx> {\n                 unique_type_id.push_str(\"!\");\n             }\n         }\n-\n-        unique_type_id.push(':');\n-\n-        for bound in bounds.builtin_bounds.iter() {\n-            match bound {\n-                ty::BoundSend => unique_type_id.push_str(\"Send\"),\n-                ty::BoundSized => unique_type_id.push_str(\"Sized\"),\n-                ty::BoundCopy => unique_type_id.push_str(\"Copy\"),\n-                ty::BoundSync => unique_type_id.push_str(\"Sync\"),\n-            };\n-            unique_type_id.push('+');\n-        }\n     }\n \n     // Get the UniqueTypeId for an enum variant. Enum variants are not really\n@@ -650,7 +625,7 @@ macro_rules! return_if_metadata_created_in_meantime {\n pub struct CrateDebugContext<'tcx> {\n     llcontext: ContextRef,\n     builder: DIBuilderRef,\n-    current_debug_location: Cell<DebugLocation>,\n+    current_debug_location: Cell<InternalDebugLocation>,\n     created_files: RefCell<FnvHashMap<String, DIFile>>,\n     created_enum_disr_types: RefCell<DefIdMap<DIType>>,\n \n@@ -940,13 +915,14 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }\n     };\n \n-    let variable_type = node_id_type(bcx, node_id);\n+    let variable_type = common::node_id_type(bcx, node_id);\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n     // env_pointer is the alloca containing the pointer to the environment,\n     // so it's type is **EnvironmentType. In order to find out the type of\n     // the environment we have to \"dereference\" two times.\n-    let llvm_env_data_type = val_ty(env_pointer).element_type().element_type();\n+    let llvm_env_data_type = common::val_ty(env_pointer).element_type()\n+                                                        .element_type();\n     let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n                                                               llvm_env_data_type,\n                                                               env_index);\n@@ -1123,7 +1099,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,\n                                                     is_block: bool)\n-                                                 -> NodeInfo {\n+                                                 -> NodeIdAndSpan {\n     // A debug location needs two things:\n     // (1) A span (of which only the beginning will actually be used)\n     // (2) An AST node-id which will be used to look up the lexical scope\n@@ -1163,7 +1139,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Some(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && &bytes[(bytes.len()-1)..] == b\"}\" {\n+            if bytes.len() > 0 && &bytes[bytes.len()-1..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -1173,12 +1149,56 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     }\n \n-    NodeInfo {\n+    NodeIdAndSpan {\n         id: node_id,\n         span: cleanup_span\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+pub enum DebugLoc {\n+    At(ast::NodeId, Span),\n+    None\n+}\n+\n+impl DebugLoc {\n+    pub fn apply(&self, fcx: &FunctionContext) {\n+        match *self {\n+            DebugLoc::At(node_id, span) => {\n+                set_source_location(fcx, node_id, span);\n+            }\n+            DebugLoc::None => {\n+                clear_source_location(fcx);\n+            }\n+        }\n+    }\n+}\n+\n+pub trait ToDebugLoc {\n+    fn debug_loc(&self) -> DebugLoc;\n+}\n+\n+impl ToDebugLoc for ast::Expr {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for NodeIdAndSpan {\n+    fn debug_loc(&self) -> DebugLoc {\n+        DebugLoc::At(self.id, self.span)\n+    }\n+}\n+\n+impl ToDebugLoc for Option<NodeIdAndSpan> {\n+    fn debug_loc(&self) -> DebugLoc {\n+        match *self {\n+            Some(NodeIdAndSpan { id, span }) => DebugLoc::At(id, span),\n+            None => DebugLoc::None\n+        }\n+    }\n+}\n+\n /// Sets the current debug location at the beginning of the span.\n ///\n /// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n@@ -1202,9 +1222,9 @@ pub fn set_source_location(fcx: &FunctionContext,\n                 let loc = span_start(cx, span);\n                 let scope = scope_metadata(fcx, node_id, span);\n \n-                set_debug_location(cx, DebugLocation::new(scope,\n-                                                          loc.line,\n-                                                          loc.col.to_uint()));\n+                set_debug_location(cx, InternalDebugLocation::new(scope,\n+                                                                  loc.line,\n+                                                                  loc.col.to_usize()));\n             } else {\n                 set_debug_location(cx, UnknownLocation);\n             }\n@@ -1615,8 +1635,8 @@ fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                         let prefix: &[u8] = &[dotdot[0], ::std::path::SEP_BYTE];\n                         let mut path_bytes = p.as_vec().to_vec();\n \n-                        if path_bytes.slice_to(2) != prefix &&\n-                           path_bytes.slice_to(2) != dotdot {\n+                        if &path_bytes[..2] != prefix &&\n+                           &path_bytes[..2] != dotdot {\n                             path_bytes.insert(0, prefix[0]);\n                             path_bytes.insert(1, prefix[1]);\n                         }\n@@ -1714,9 +1734,9 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         )\n     };\n \n-    set_debug_location(cx, DebugLocation::new(scope_metadata,\n-                                              loc.line,\n-                                              loc.col.to_uint()));\n+    set_debug_location(cx, InternalDebugLocation::new(scope_metadata,\n+                                                      loc.line,\n+                                                      loc.col.to_usize()));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -1752,7 +1772,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            &full_path[(work_dir.len() + 1u)..full_path.len()]\n+            &full_path[work_dir.len() + 1u..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -3095,13 +3115,13 @@ impl MetadataCreationResult {\n }\n \n #[derive(Copy, PartialEq)]\n-enum DebugLocation {\n+enum InternalDebugLocation {\n     KnownLocation { scope: DIScope, line: uint, col: uint },\n     UnknownLocation\n }\n \n-impl DebugLocation {\n-    fn new(scope: DIScope, line: uint, col: uint) -> DebugLocation {\n+impl InternalDebugLocation {\n+    fn new(scope: DIScope, line: uint, col: uint) -> InternalDebugLocation {\n         KnownLocation {\n             scope: scope,\n             line: line,\n@@ -3110,7 +3130,7 @@ impl DebugLocation {\n     }\n }\n \n-fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n+fn set_debug_location(cx: &CrateContext, debug_location: InternalDebugLocation) {\n     if debug_location == debug_context(cx).current_debug_location.get() {\n         return;\n     }\n@@ -3279,7 +3299,7 @@ fn create_scope_map(cx: &CrateContext,\n                 parent_scope,\n                 file_metadata,\n                 loc.line as c_uint,\n-                loc.col.to_uint() as c_uint)\n+                loc.col.to_usize() as c_uint)\n         };\n \n         scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata,\n@@ -3401,7 +3421,7 @@ fn create_scope_map(cx: &CrateContext,\n                                 parent_scope,\n                                 file_metadata,\n                                 loc.line as c_uint,\n-                                loc.col.to_uint() as c_uint)\n+                                loc.col.to_usize() as c_uint)\n                         };\n \n                         scope_stack.push(ScopeStackEntry {\n@@ -4122,4 +4142,3 @@ fn needs_gdb_debug_scripts_section(ccx: &CrateContext) -> bool {\n     !ccx.sess().target.target.options.is_like_windows &&\n     ccx.sess().opts.debuginfo != NoDebugInfo\n }\n-"}, {"sha": "4ebaf91d111737bf06a2e43cc896040b3bf9d56f", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 55, "deletions": 60, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -46,7 +46,7 @@ use trans::build::*;\n use trans::cleanup::{self, CleanupMethods};\n use trans::common::*;\n use trans::datum::*;\n-use trans::debuginfo;\n+use trans::debuginfo::{self, DebugLoc, ToDebugLoc};\n use trans::glue;\n use trans::machine;\n use trans::meth;\n@@ -65,7 +65,6 @@ use trans::machine::{llsize_of, llsize_of_alloc};\n use trans::type_::Type;\n \n use syntax::{ast, ast_util, codemap};\n-use syntax::print::pprust::{expr_to_string};\n use syntax::ptr::P;\n use syntax::parse::token;\n use std::rc::Rc;\n@@ -779,7 +778,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let expected = Call(bcx,\n                                 expect,\n                                 &[bounds_check, C_bool(ccx, false)],\n-                                None);\n+                                None,\n+                                index_expr.debug_loc());\n             bcx = with_cond(bcx, expected, |bcx| {\n                 controlflow::trans_fail_bounds_check(bcx,\n                                                      index_expr.span,\n@@ -890,10 +890,10 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_into(bcx, &**e, Ignore)\n         }\n         ast::ExprBreak(label_opt) => {\n-            controlflow::trans_break(bcx, expr.id, label_opt)\n+            controlflow::trans_break(bcx, expr, label_opt)\n         }\n         ast::ExprAgain(label_opt) => {\n-            controlflow::trans_cont(bcx, expr.id, label_opt)\n+            controlflow::trans_cont(bcx, expr, label_opt)\n         }\n         ast::ExprRet(ref ex) => {\n             // Check to see if the return expression itself is reachable.\n@@ -905,7 +905,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             };\n \n             if reachable {\n-                controlflow::trans_ret(bcx, ex.as_ref().map(|e| &**e))\n+                controlflow::trans_ret(bcx, expr, ex.as_ref().map(|e| &**e))\n             } else {\n                 // If it's not reachable, just translate the inner expression\n                 // directly. This avoids having to manage a return slot when\n@@ -921,7 +921,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n         }\n         ast::ExprWhile(ref cond, ref body, _) => {\n-            controlflow::trans_while(bcx, expr.id, &**cond, &**body)\n+            controlflow::trans_while(bcx, expr, &**cond, &**body)\n         }\n         ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n             controlflow::trans_for(bcx,\n@@ -931,7 +931,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                    &**body)\n         }\n         ast::ExprLoop(ref body, _) => {\n-            controlflow::trans_loop(bcx, expr.id, &**body)\n+            controlflow::trans_loop(bcx, expr, &**body)\n         }\n         ast::ExprAssign(ref dst, ref src) => {\n             let src_datum = unpack_datum!(bcx, trans(bcx, &**src));\n@@ -960,7 +960,7 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 bcx = glue::drop_ty(bcx,\n                                     dst_datum.val,\n                                     dst_datum.ty,\n-                                    Some(NodeInfo { id: expr.id, span: expr.span }));\n+                                    expr.debug_loc());\n                 src_datum.store_to(bcx, dst_datum.val)\n             } else {\n                 src_datum.store_to(bcx, dst_datum.val)\n@@ -1078,7 +1078,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                       &numbered_fields[],\n                       None,\n                       dest,\n-                      Some(NodeInfo { id: expr.id, span: expr.span }))\n+                      expr.debug_loc())\n         }\n         ast::ExprLit(ref lit) => {\n             match lit.node {\n@@ -1102,17 +1102,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             // closure or an older, legacy style closure. Store this\n             // into a variable to ensure the the RefCell-lock is\n             // released before we recurse.\n-            let is_unboxed_closure =\n-                bcx.tcx().unboxed_closures.borrow().contains_key(&ast_util::local_def(expr.id));\n-            if is_unboxed_closure {\n-                closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n-            } else {\n-                let expr_ty = expr_ty(bcx, expr);\n-                let store = ty::ty_closure_store(expr_ty);\n-                debug!(\"translating block function {} with type {}\",\n-                       expr_to_string(expr), expr_ty.repr(tcx));\n-                closure::trans_expr_fn(bcx, store, &**decl, &**body, expr.id, dest)\n-            }\n+            closure::trans_unboxed_closure(bcx, &**decl, &**body, expr.id, dest)\n         }\n         ast::ExprCall(ref f, ref args) => {\n             if bcx.tcx().is_method_call(expr.id) {\n@@ -1417,7 +1407,7 @@ fn trans_struct<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   numbered_fields.as_slice(),\n                   optbase,\n                   dest,\n-                  Some(NodeInfo { id: expr_id, span: expr_span }))\n+                  DebugLoc::At(expr_id, expr_span))\n     })\n }\n \n@@ -1448,18 +1438,13 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                  fields: &[(uint, &ast::Expr)],\n                                  optbase: Option<StructBaseInfo<'a, 'tcx>>,\n                                  dest: Dest,\n-                                 source_location: Option<NodeInfo>)\n+                                 debug_location: DebugLoc)\n                                  -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n     let repr = adt::represent_type(bcx.ccx(), ty);\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     // If we don't care about the result, just make a\n     // temporary stack slot\n@@ -1494,12 +1479,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n     }\n \n-    match source_location {\n-        Some(src_loc) => debuginfo::set_source_location(bcx.fcx,\n-                                                        src_loc.id,\n-                                                        src_loc.span),\n-        None => {}\n-    };\n+    debug_location.apply(bcx.fcx);\n \n     if ty::type_is_simd(bcx.tcx(), ty) {\n         // This is the constructor of a SIMD type, such types are\n@@ -1540,7 +1520,7 @@ pub fn trans_adt<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     match dest {\n         SaveIn(_) => bcx,\n         Ignore => {\n-            bcx = glue::drop_ty(bcx, addr, ty, source_location);\n+            bcx = glue::drop_ty(bcx, addr, ty, debug_location);\n             base::call_lifetime_end(bcx, addr);\n             bcx\n         }\n@@ -1579,20 +1559,22 @@ fn trans_unary<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let un_ty = expr_ty(bcx, expr);\n \n+    let debug_loc = expr.debug_loc();\n+\n     match op {\n         ast::UnNot => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n-            let llresult = Not(bcx, datum.to_llscalarish(bcx));\n+            let llresult = Not(bcx, datum.to_llscalarish(bcx), debug_loc);\n             immediate_rvalue_bcx(bcx, llresult, un_ty).to_expr_datumblock()\n         }\n         ast::UnNeg => {\n             let datum = unpack_datum!(bcx, trans(bcx, sub_expr));\n             let val = datum.to_llscalarish(bcx);\n             let llneg = {\n                 if ty::type_is_fp(un_ty) {\n-                    FNeg(bcx, val)\n+                    FNeg(bcx, val, debug_loc)\n                 } else {\n-                    Neg(bcx, val)\n+                    Neg(bcx, val, debug_loc)\n                 }\n             };\n             immediate_rvalue_bcx(bcx, llneg, un_ty).to_expr_datumblock()\n@@ -1691,56 +1673,69 @@ fn trans_eager_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let rhs = base::cast_shift_expr_rhs(bcx, op, lhs, rhs);\n \n+    let binop_debug_loc = binop_expr.debug_loc();\n+\n     let mut bcx = bcx;\n     let val = match op {\n       ast::BiAdd => {\n-        if is_float { FAdd(bcx, lhs, rhs) }\n-        else { Add(bcx, lhs, rhs) }\n+        if is_float {\n+            FAdd(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Add(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiSub => {\n-        if is_float { FSub(bcx, lhs, rhs) }\n-        else { Sub(bcx, lhs, rhs) }\n+        if is_float {\n+            FSub(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Sub(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiMul => {\n-        if is_float { FMul(bcx, lhs, rhs) }\n-        else { Mul(bcx, lhs, rhs) }\n+        if is_float {\n+            FMul(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            Mul(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiDiv => {\n         if is_float {\n-            FDiv(bcx, lhs, rhs)\n+            FDiv(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp /0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SDiv(bcx, lhs, rhs)\n+                SDiv(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                UDiv(bcx, lhs, rhs)\n+                UDiv(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n       ast::BiRem => {\n         if is_float {\n-            FRem(bcx, lhs, rhs)\n+            FRem(bcx, lhs, rhs, binop_debug_loc)\n         } else {\n             // Only zero-check integers; fp %0 is NaN\n             bcx = base::fail_if_zero_or_overflows(bcx, binop_expr.span,\n                                                   op, lhs, rhs, rhs_t);\n             if is_signed {\n-                SRem(bcx, lhs, rhs)\n+                SRem(bcx, lhs, rhs, binop_debug_loc)\n             } else {\n-                URem(bcx, lhs, rhs)\n+                URem(bcx, lhs, rhs, binop_debug_loc)\n             }\n         }\n       }\n-      ast::BiBitOr => Or(bcx, lhs, rhs),\n-      ast::BiBitAnd => And(bcx, lhs, rhs),\n-      ast::BiBitXor => Xor(bcx, lhs, rhs),\n-      ast::BiShl => Shl(bcx, lhs, rhs),\n+      ast::BiBitOr => Or(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitAnd => And(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiBitXor => Xor(bcx, lhs, rhs, binop_debug_loc),\n+      ast::BiShl => Shl(bcx, lhs, rhs, binop_debug_loc),\n       ast::BiShr => {\n         if is_signed {\n-            AShr(bcx, lhs, rhs)\n-        } else { LShr(bcx, lhs, rhs) }\n+            AShr(bcx, lhs, rhs, binop_debug_loc)\n+        } else {\n+            LShr(bcx, lhs, rhs, binop_debug_loc)\n+        }\n       }\n       ast::BiEq | ast::BiNe | ast::BiLt | ast::BiGe | ast::BiLe | ast::BiGt => {\n         if ty::type_is_scalar(rhs_t) {\n@@ -1786,8 +1781,8 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let before_rhs = fcx.new_id_block(\"before_rhs\", b.id);\n \n     match op {\n-      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb),\n-      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb)\n+      lazy_and => CondBr(past_lhs, lhs, before_rhs.llbb, join.llbb, DebugLoc::None),\n+      lazy_or => CondBr(past_lhs, lhs, join.llbb, before_rhs.llbb, DebugLoc::None)\n     }\n \n     let DatumBlock {bcx: past_rhs, datum: rhs} = trans(before_rhs, b);\n@@ -1797,7 +1792,7 @@ fn trans_lazy_binop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return immediate_rvalue_bcx(join, lhs, binop_ty).to_expr_datumblock();\n     }\n \n-    Br(past_rhs, join.llbb);\n+    Br(past_rhs, join.llbb, DebugLoc::None);\n     let phi = Phi(join, Type::i1(bcx.ccx()), &[lhs, rhs],\n                   &[past_lhs.llbb, past_rhs.llbb]);\n "}, {"sha": "fb2ee55940d0956d94c2423705243b9d33959682", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -29,7 +29,7 @@ use trans::cleanup::CleanupMethods;\n use trans::consts;\n use trans::common::*;\n use trans::datum;\n-use trans::debuginfo;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n use trans::tvec;\n@@ -106,7 +106,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                            v: ValueRef,\n                            t: Ty<'tcx>,\n-                           source_location: Option<NodeInfo>)\n+                           debug_loc: DebugLoc)\n                            -> Block<'blk, 'tcx> {\n     // NB: v is an *alias* of type t here, not a direct value.\n     debug!(\"drop_ty(t={})\", t.repr(bcx.tcx()));\n@@ -121,25 +121,20 @@ pub fn drop_ty<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             v\n         };\n \n-        match source_location {\n-            Some(sl) => debuginfo::set_source_location(bcx.fcx, sl.id, sl.span),\n-            None => debuginfo::clear_source_location(bcx.fcx)\n-        };\n-\n-        Call(bcx, glue, &[ptr], None);\n+        Call(bcx, glue, &[ptr], None, debug_loc);\n     }\n     bcx\n }\n \n pub fn drop_ty_immediate<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      v: ValueRef,\n                                      t: Ty<'tcx>,\n-                                     source_location: Option<NodeInfo>)\n+                                     debug_loc: DebugLoc)\n                                      -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"drop_ty_immediate\");\n     let vp = alloca(bcx, type_of(bcx.ccx(), t), \"\");\n     store_ty(bcx, v, vp, t);\n-    drop_ty(bcx, vp, t, source_location)\n+    drop_ty(bcx, vp, t, debug_loc)\n }\n \n pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> ValueRef {\n@@ -295,7 +290,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, DebugLoc::None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -331,7 +326,7 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let (unsized_size, unsized_align) = size_and_align_of_dst(bcx, field_ty, info);\n \n             // Return the sum of sizes and max of aligns.\n-            let size = Add(bcx, sized_size, unsized_size);\n+            let size = Add(bcx, sized_size, unsized_size, DebugLoc::None);\n             let align = Select(bcx,\n                                ICmp(bcx, llvm::IntULT, sized_align, unsized_align),\n                                sized_align,\n@@ -353,7 +348,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let llunit_ty = sizing_type_of(bcx.ccx(), unit_ty);\n             let unit_align = llalign_of_min(bcx.ccx(), llunit_ty);\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n-            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), unit_align))\n+            (Mul(bcx, info, C_uint(bcx.ccx(), unit_size), DebugLoc::None),\n+             C_uint(bcx.ccx(), unit_align))\n         }\n         _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n                                     bcx.ty_to_string(t))[])\n@@ -384,7 +380,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                         Call(bcx,\n                              dtor,\n                              &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             None);\n+                             None,\n+                             DebugLoc::None);\n                         bcx\n                     })\n                 }\n@@ -393,7 +390,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty, None);\n+                        let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n                         let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n                         let info = Load(bcx, info);\n                         let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n@@ -406,7 +403,7 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     let llbox = Load(bcx, llval);\n                     let not_null = IsNotNull(bcx, llbox);\n                     with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty, None);\n+                        let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n                         trans_exchange_free_ty(bcx, llbox, content_ty)\n                     })\n                 }\n@@ -437,14 +434,16 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n                 ty::NoDtor => {\n                     // No dtor? Just the default case\n-                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+                    iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n                 }\n             }\n         }\n-        ty::ty_unboxed_closure(..) => iter_structural_ty(bcx,\n-                                                         v0,\n-                                                         t,\n-                                                         |bb, vv, tt| drop_ty(bb, vv, tt, None)),\n+        ty::ty_unboxed_closure(..) => {\n+            iter_structural_ty(bcx,\n+                               v0,\n+                               t,\n+                               |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n+        }\n         ty::ty_trait(..) => {\n             // No need to do a null check here (as opposed to the Box<trait case\n             // above), because this happens for a trait field in an unsized\n@@ -456,7 +455,8 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n             Call(bcx,\n                  dtor,\n                  &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n-                 None);\n+                 None,\n+                 DebugLoc::None);\n             bcx\n         },\n         ty::ty_vec(_, None) | ty::ty_str => {\n@@ -465,9 +465,11 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n         },\n         _ => {\n             assert!(type_is_sized(bcx.tcx(), t));\n-            if type_needs_drop(bcx.tcx(), t) &&\n-                ty::type_is_structural(t) {\n-                iter_structural_ty(bcx, v0, t, |bb, vv, tt| drop_ty(bb, vv, tt, None))\n+            if type_needs_drop(bcx.tcx(), t) && ty::type_is_structural(t) {\n+                iter_structural_ty(bcx,\n+                                   v0,\n+                                   t,\n+                                   |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n             } else {\n                 bcx\n             }\n@@ -559,7 +561,7 @@ fn make_generic_glue<'a, 'tcx, F>(ccx: &CrateContext<'a, 'tcx>,\n \n     let llrawptr0 = get_param(llfn, fcx.arg_pos(0) as c_uint);\n     let bcx = helper(bcx, llrawptr0, t);\n-    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())));\n+    finish_fn(&fcx, bcx, ty::FnConverging(ty::mk_nil(ccx.tcx())), DebugLoc::None);\n \n     llfn\n }"}, {"sha": "9bee2c5bbc61c69ecd3410f4c0297d645cf3e4ba", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 279, "deletions": 93, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::glue;\n use trans::type_of::*;\n@@ -149,9 +150,8 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                                             args: callee::CallArgs<'a, 'tcx>,\n                                             dest: expr::Dest,\n                                             substs: subst::Substs<'tcx>,\n-                                            call_info: NodeInfo)\n-                                            -> Result<'blk, 'tcx>\n-{\n+                                            call_info: NodeIdAndSpan)\n+                                            -> Result<'blk, 'tcx> {\n     let fcx = bcx.fcx;\n     let ccx = fcx.ccx;\n     let tcx = bcx.tcx();\n@@ -270,10 +270,12 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n \n     fcx.pop_custom_cleanup_scope(cleanup_scope);\n \n+    let call_debug_location = DebugLoc::At(call_info.id, call_info.span);\n+\n     // These are the only intrinsic functions that diverge.\n     if name.get() == \"abort\" {\n         let llfn = ccx.get_intrinsic(&(\"llvm.trap\"));\n-        Call(bcx, llfn, &[], None);\n+        Call(bcx, llfn, &[], None, call_debug_location);\n         Unreachable(bcx);\n         return Result::new(bcx, C_undef(Type::nil(ccx).ptr_to()));\n     } else if name.get() == \"unreachable\" {\n@@ -304,11 +306,11 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let simple = get_simple_intrinsic(ccx, &*foreign_item);\n     let llval = match (simple, name.get()) {\n         (Some(llfn), _) => {\n-            Call(bcx, llfn, llargs.as_slice(), None)\n+            Call(bcx, llfn, llargs.as_slice(), None, call_debug_location)\n         }\n         (_, \"breakpoint\") => {\n             let llfn = ccx.get_intrinsic(&(\"llvm.debugtrap\"));\n-            Call(bcx, llfn, &[], None)\n+            Call(bcx, llfn, &[], None, call_debug_location)\n         }\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n@@ -384,29 +386,63 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n \n         (_, \"copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"copy_memory\") => {\n-            copy_intrinsic(bcx, true, false, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           false,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"set_memory\") => {\n-            memset_intrinsic(bcx, false, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             false,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n \n         (_, \"volatile_copy_nonoverlapping_memory\") => {\n-            copy_intrinsic(bcx, false, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           false,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_copy_memory\") => {\n-            copy_intrinsic(bcx, true, true, *substs.types.get(FnSpace, 0),\n-                           llargs[0], llargs[1], llargs[2])\n+            copy_intrinsic(bcx,\n+                           true,\n+                           true,\n+                           *substs.types.get(FnSpace, 0),\n+                           llargs[0],\n+                           llargs[1],\n+                           llargs[2],\n+                           call_debug_location)\n         }\n         (_, \"volatile_set_memory\") => {\n-            memset_intrinsic(bcx, true, *substs.types.get(FnSpace, 0),\n-                             llargs[0], llargs[1], llargs[2])\n+            memset_intrinsic(bcx,\n+                             true,\n+                             *substs.types.get(FnSpace, 0),\n+                             llargs[0],\n+                             llargs[1],\n+                             llargs[2],\n+                             call_debug_location)\n         }\n         (_, \"volatile_load\") => {\n             VolatileLoad(bcx, llargs[0])\n@@ -416,93 +452,208 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             C_nil(ccx)\n         },\n \n-        (_, \"ctlz8\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i8\", llargs[0]),\n-        (_, \"ctlz16\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i16\", llargs[0]),\n-        (_, \"ctlz32\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i32\", llargs[0]),\n-        (_, \"ctlz64\") => count_zeros_intrinsic(bcx, \"llvm.ctlz.i64\", llargs[0]),\n-        (_, \"cttz8\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i8\", llargs[0]),\n-        (_, \"cttz16\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i16\", llargs[0]),\n-        (_, \"cttz32\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i32\", llargs[0]),\n-        (_, \"cttz64\") => count_zeros_intrinsic(bcx, \"llvm.cttz.i64\", llargs[0]),\n+        (_, \"ctlz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.ctlz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"ctlz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"ctlz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.ctlz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz8\") => count_zeros_intrinsic(bcx,\n+                                              \"llvm.cttz.i8\",\n+                                              llargs[0],\n+                                              call_debug_location),\n+        (_, \"cttz16\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i16\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz32\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i32\",\n+                                               llargs[0],\n+                                               call_debug_location),\n+        (_, \"cttz64\") => count_zeros_intrinsic(bcx,\n+                                               \"llvm.cttz.i64\",\n+                                               llargs[0],\n+                                               call_debug_location),\n \n         (_, \"i8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.sadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.sadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n \n         (_, \"u8_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_add_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.uadd.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.uadd.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.ssub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.ssub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_sub_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.usub.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.usub.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i8\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i16\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i32\", ret_ty,\n-                                   llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"i64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.smul.with.overflow.i64\", ret_ty,\n-                                   llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.smul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u8_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i8\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i8\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u16_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i16\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i16\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u32_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i32\", ret_ty,\n-                                    llargs[0], llargs[1]),\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i32\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"u64_mul_with_overflow\") =>\n-            with_overflow_intrinsic(bcx, \"llvm.umul.with.overflow.i64\", ret_ty,\n-                                    llargs[0], llargs[1]),\n-\n+            with_overflow_intrinsic(bcx,\n+                                    \"llvm.umul.with.overflow.i64\",\n+                                    ret_ty,\n+                                    llargs[0],\n+                                    llargs[1],\n+                                    call_debug_location),\n         (_, \"return_address\") => {\n             if !fcx.caller_expects_out_pointer {\n                 tcx.sess.span_err(call_info.span,\n@@ -609,7 +760,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     // If we made a temporary stack slot, let's clean it up\n     match dest {\n         expr::Ignore => {\n-            bcx = glue::drop_ty(bcx, llresult, ret_ty, Some(call_info));\n+            bcx = glue::drop_ty(bcx, llresult, ret_ty, call_debug_location);\n         }\n         expr::SaveIn(_) => {}\n     }\n@@ -618,8 +769,14 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n }\n \n fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                              allow_overlap: bool, volatile: bool, tp_ty: Ty<'tcx>,\n-                              dst: ValueRef, src: ValueRef, count: ValueRef) -> ValueRef {\n+                              allow_overlap: bool,\n+                              volatile: bool,\n+                              tp_ty: Ty<'tcx>,\n+                              dst: ValueRef,\n+                              src: ValueRef,\n+                              count: ValueRef,\n+                              call_debug_location: DebugLoc)\n+                              -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -643,12 +800,25 @@ fn copy_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let src_ptr = PointerCast(bcx, src, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, src_ptr, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           src_ptr,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: Ty<'tcx>,\n-                                dst: ValueRef, val: ValueRef, count: ValueRef) -> ValueRef {\n+fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                volatile: bool,\n+                                tp_ty: Ty<'tcx>,\n+                                dst: ValueRef,\n+                                val: ValueRef,\n+                                count: ValueRef,\n+                                call_debug_location: DebugLoc)\n+                                -> ValueRef {\n     let ccx = bcx.ccx();\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n     let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n@@ -662,22 +832,38 @@ fn memset_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, volatile: bool, tp_ty: T\n     let dst_ptr = PointerCast(bcx, dst, Type::i8p(ccx));\n     let llfn = ccx.get_intrinsic(&name);\n \n-    Call(bcx, llfn, &[dst_ptr, val, Mul(bcx, size, count), align,\n-                      C_bool(ccx, volatile)], None)\n+    Call(bcx,\n+         llfn,\n+         &[dst_ptr,\n+           val,\n+           Mul(bcx, size, count, DebugLoc::None),\n+           align,\n+           C_bool(ccx, volatile)],\n+         None,\n+         call_debug_location)\n }\n \n-fn count_zeros_intrinsic(bcx: Block, name: &'static str, val: ValueRef) -> ValueRef {\n+fn count_zeros_intrinsic(bcx: Block,\n+                         name: &'static str,\n+                         val: ValueRef,\n+                         call_debug_location: DebugLoc)\n+                         -> ValueRef {\n     let y = C_bool(bcx.ccx(), false);\n     let llfn = bcx.ccx().get_intrinsic(&name);\n-    Call(bcx, llfn, &[val, y], None)\n+    Call(bcx, llfn, &[val, y], None, call_debug_location)\n }\n \n-fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, name: &'static str,\n-                                       t: Ty<'tcx>, a: ValueRef, b: ValueRef) -> ValueRef {\n+fn with_overflow_intrinsic<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                       name: &'static str,\n+                                       t: Ty<'tcx>,\n+                                       a: ValueRef,\n+                                       b: ValueRef,\n+                                       call_debug_location: DebugLoc)\n+                                       -> ValueRef {\n     let llfn = bcx.ccx().get_intrinsic(&name);\n \n     // Convert `i1` to a `bool`, and write it to the out parameter\n-    let val = Call(bcx, llfn, &[a, b], None);\n+    let val = Call(bcx, llfn, &[a, b], None, call_debug_location);\n     let result = ExtractValue(bcx, val, 0);\n     let overflow = ZExt(bcx, ExtractValue(bcx, val, 1), Type::bool(bcx.ccx()));\n     let ret = C_undef(type_of::type_of(bcx.ccx(), t));"}, {"sha": "c2f19670e4f1558234e15fa575fb7174cd0eabfd", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -24,6 +24,7 @@ use trans::callee;\n use trans::cleanup;\n use trans::common::*;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{SaveIn, Ignore};\n use trans::expr;\n use trans::glue;\n@@ -494,7 +495,7 @@ pub fn trans_trait_callee_from_llval<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         ty::ty_bare_fn(_, ref f) if f.abi == Rust || f.abi == RustCall => {\n             let fake_sig =\n                 ty::Binder(ty::FnSig {\n-                    inputs: f.sig.0.inputs.slice_from(1).to_vec(),\n+                    inputs: f.sig.0.inputs[1..].to_vec(),\n                     output: f.sig.0.output,\n                     variadic: f.sig.0.variadic,\n                 });\n@@ -634,7 +635,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n             }\n             _ => {\n                 // skip the self parameter:\n-                sig.inputs.slice_from(1)\n+                &sig.inputs[1..]\n             }\n         };\n \n@@ -676,7 +677,7 @@ pub fn trans_object_shim<'a, 'tcx>(\n                            ArgVals(llargs.as_slice()),\n                            dest).bcx;\n \n-    finish_fn(&fcx, bcx, sig.output);\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n     (llfn, method_bare_fn_ty)\n }\n@@ -785,7 +786,7 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     unsafe {\n         let tbl = C_struct(ccx, &components[], false);\n         let sym = token::gensym(\"vtable\");\n-        let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n+        let buf = CString::from_vec(format!(\"vtable{}\", sym.usize()).into_bytes());\n         let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),\n                                           buf.as_ptr());\n         llvm::LLVMSetInitializer(vt_gvar, tbl);"}, {"sha": "93076260349abd5c81aee5d5801823a800ec4a2d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -274,7 +274,6 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeArg(..) |\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n-        ast_map::NodeViewItem(..) |\n         ast_map::NodeLocal(..) => {\n             ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n                                    map_node)[])"}, {"sha": "06bc19f45a47e6bbd305ebc5cae8f10f6903d37a", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,6 +21,7 @@ use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n+use trans::debuginfo::DebugLoc;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n use trans::glue;\n@@ -58,7 +59,11 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let dataptr = get_dataptr(bcx, vptr);\n         let bcx = if type_needs_drop(tcx, unit_ty) {\n             let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx, dataptr, unit_ty, len, |bb, vv, tt| glue::drop_ty(bb, vv, tt, None))\n+            iter_vec_raw(bcx,\n+                         dataptr,\n+                         unit_ty,\n+                         len,\n+                         |bb, vv, tt| glue::drop_ty(bb, vv, tt, DebugLoc::None))\n         } else {\n             bcx\n         };\n@@ -71,7 +76,7 @@ pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 let not_empty = ICmp(bcx, llvm::IntNE, len, C_uint(ccx, 0u));\n                 with_cond(bcx, not_empty, |bcx| {\n                     let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n-                    let size = Mul(bcx, C_uint(ccx, unit_size), len);\n+                    let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n                     glue::trans_exchange_free_dyn(bcx, dataptr, size, llalign)\n                 })\n             } else {\n@@ -420,14 +425,14 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let cond_bcx = fcx.new_temp_block(\"expr_repeat: loop cond\");\n     let body_bcx = fcx.new_temp_block(\"expr_repeat: body: set\");\n     let inc_bcx = fcx.new_temp_block(\"expr_repeat: body: inc\");\n-    Br(bcx, loop_bcx.llbb);\n+    Br(bcx, loop_bcx.llbb, DebugLoc::None);\n \n     let loop_counter = {\n         // i = 0\n         let i = alloca(loop_bcx, bcx.ccx().int_type(), \"__i\");\n         Store(loop_bcx, C_uint(bcx.ccx(), 0u), i);\n \n-        Br(loop_bcx, cond_bcx.llbb);\n+        Br(loop_bcx, cond_bcx.llbb, DebugLoc::None);\n         i\n     };\n \n@@ -436,7 +441,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let rhs = count;\n         let cond_val = ICmp(cond_bcx, llvm::IntULT, lhs, rhs);\n \n-        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(cond_bcx, cond_val, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n     }\n \n     { // loop body\n@@ -448,15 +453,15 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         };\n         let body_bcx = f(body_bcx, lleltptr, vt.unit_ty);\n \n-        Br(body_bcx, inc_bcx.llbb);\n+        Br(body_bcx, inc_bcx.llbb, DebugLoc::None);\n     }\n \n     { // i += 1\n         let i = Load(inc_bcx, loop_counter);\n-        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u));\n+        let plusone = Add(inc_bcx, i, C_uint(bcx.ccx(), 1u), DebugLoc::None);\n         Store(inc_bcx, plusone, loop_counter);\n \n-        Br(inc_bcx, cond_bcx.llbb);\n+        Br(inc_bcx, cond_bcx.llbb, DebugLoc::None);\n     }\n \n     next_bcx\n@@ -484,19 +489,19 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         // Now perform the iteration.\n         let header_bcx = fcx.new_temp_block(\"iter_vec_loop_header\");\n-        Br(bcx, header_bcx.llbb);\n+        Br(bcx, header_bcx.llbb, DebugLoc::None);\n         let data_ptr =\n             Phi(header_bcx, val_ty(data_ptr), &[data_ptr], &[bcx.llbb]);\n         let not_yet_at_end =\n             ICmp(header_bcx, llvm::IntULT, data_ptr, data_end_ptr);\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n-        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb);\n+        CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n         let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                &[C_int(bcx.ccx(), 1i)]),\n                          body_bcx.llbb);\n-        Br(body_bcx, header_bcx.llbb);\n+        Br(body_bcx, header_bcx.llbb, DebugLoc::None);\n         next_bcx\n     }\n }"}, {"sha": "9640443f4f7a642265898dd1e40fe630c2993a30", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,6 +21,7 @@ use syntax::ast;\n \n use std::ffi::CString;\n use std::mem;\n+use std::ptr;\n use std::cell::RefCell;\n use std::iter::repeat;\n \n@@ -227,14 +228,6 @@ impl Type {\n         Type::vec(ccx, &Type::i8(ccx))\n     }\n \n-    // The box pointed to by @T.\n-    pub fn at_box(ccx: &CrateContext, ty: Type) -> Type {\n-        Type::struct_(ccx, &[\n-            ccx.int_type(), Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to(),\n-            Type::i8p(ccx), Type::i8p(ccx), ty\n-        ], false)\n-    }\n-\n     pub fn vtable_ptr(ccx: &CrateContext) -> Type {\n         Type::glue_fn(ccx, Type::i8p(ccx)).ptr_to().ptr_to()\n     }\n@@ -303,7 +296,7 @@ impl Type {\n             if n_elts == 0 {\n                 return Vec::new();\n             }\n-            let mut elts: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_elts).collect();\n+            let mut elts: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_elts).collect();\n             llvm::LLVMGetStructElementTypes(self.to_ref(),\n                                             elts.as_mut_ptr() as *mut TypeRef);\n             elts\n@@ -317,7 +310,7 @@ impl Type {\n     pub fn func_params(&self) -> Vec<Type> {\n         unsafe {\n             let n_args = llvm::LLVMCountParamTypes(self.to_ref()) as uint;\n-            let mut args: Vec<_> = repeat(Type { rf: 0 as TypeRef }).take(n_args).collect();\n+            let mut args: Vec<_> = repeat(Type { rf: ptr::null_mut() }).take(n_args).collect();\n             llvm::LLVMGetParamTypes(self.to_ref(),\n                                     args.as_mut_ptr() as *mut TypeRef);\n             args"}, {"sha": "921ed505fa3af3517fadc1d4ba1818a23748c865", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 64, "deletions": 84, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -100,8 +100,7 @@ pub trait AstConv<'tcx> {\n                                         -> Ty<'tcx>\n     {\n         if ty::binds_late_bound_regions(self.tcx(), &poly_trait_ref) {\n-            self.tcx().sess.span_err(\n-                span,\n+            span_err!(self.tcx().sess, span, E0212,\n                 \"cannot extract an associated type from a higher-ranked trait bound \\\n                  in this context\");\n             self.tcx().types.err\n@@ -119,8 +118,7 @@ pub trait AstConv<'tcx> {\n                     _item_name: ast::Name)\n                     -> Ty<'tcx>\n     {\n-        self.tcx().sess.span_err(\n-            span,\n+        span_err!(self.tcx().sess, span, E0213,\n             \"associated types are not accepted in this context\");\n \n         self.tcx().types.err\n@@ -268,8 +266,7 @@ pub fn ast_path_substs_for_ty<'tcx>(\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            tcx.sess.span_err(\n-                path.span,\n+            span_err!(tcx.sess, path.span, E0214,\n                 \"parenthesized parameters may only be used with a trait\");\n             (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n@@ -342,22 +339,22 @@ fn create_substs_for_ast_path<'tcx>(\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0243,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(span,\n-                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n+        span_fatal!(this.tcx().sess, span, E0244,\n+                                   \"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count)[]);\n+                                           supplied_ty_param_count);\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -560,10 +557,9 @@ pub fn instantiate_trait_ref<'tcx>(\n             trait_ref\n         }\n         _ => {\n-            this.tcx().sess.span_fatal(\n-                ast_trait_ref.path.span,\n-                &format!(\"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx()))[]);\n+            span_fatal!(this.tcx().sess, ast_trait_ref.path.span, E0245,\n+                \"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx()));\n         }\n     }\n }\n@@ -610,7 +606,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_some()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0215,\n                                          \"angle-bracket notation is not stable when \\\n                                          used with the `Fn` family of traits, use parentheses\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -626,7 +622,7 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n             if !this.tcx().sess.features.borrow().unboxed_closures &&\n                 this.tcx().lang_items.fn_trait_kind(trait_def_id).is_none()\n             {\n-                this.tcx().sess.span_err(path.span,\n+                span_err!(this.tcx().sess, path.span, E0216,\n                                          \"parenthetical notation is only stable when \\\n                                          used with the `Fn` family of traits\");\n                 span_help!(this.tcx().sess, path.span,\n@@ -738,32 +734,29 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     }\n \n     if candidates.len() > 1 {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n+        span_err!(tcx.sess, binding.span, E0217,\n+            \"ambiguous associated type: `{}` defined in multiple supertraits `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidates.user_string(tcx)).as_slice());\n+                    candidates.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n     let candidate = match candidates.pop() {\n         Some(c) => c,\n         None => {\n-            tcx.sess.span_err(\n-                binding.span,\n-                format!(\"no associated type `{}` defined in `{}`\",\n+            span_err!(tcx.sess, binding.span, E0218,\n+                \"no associated type `{}` defined in `{}`\",\n                         token::get_name(binding.item_name),\n-                        trait_ref.user_string(tcx)).as_slice());\n+                        trait_ref.user_string(tcx));\n             return Err(ErrorReported);\n         }\n     };\n \n     if ty::binds_late_bound_regions(tcx, &candidate) {\n-        tcx.sess.span_err(\n-            binding.span,\n-            format!(\"associated type `{}` defined in higher-ranked supertrait `{}`\",\n+        span_err!(tcx.sess, binding.span, E0219,\n+            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n                     token::get_name(binding.item_name),\n-                    candidate.user_string(tcx)).as_slice());\n+                    candidate.user_string(tcx));\n         return Err(ErrorReported);\n     }\n \n@@ -893,14 +886,14 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                       pprust::ty_to_string(ty));\n             match ty.node {\n                 ast::TyRptr(None, ref mut_ty) => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{}({} +{})`? (per RFC 438)\",\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n                                pprust::ty_to_string(&*mut_ty.ty),\n                                pprust::bounds_to_string(bounds));\n                 }\n                ast::TyRptr(Some(ref lt), ref mut_ty) => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you meant `&{} {}({} +{})`? (per RFC 438)\",\n                                pprust::lifetime_to_string(lt),\n                                ppaux::mutability_to_string(mut_ty.mutbl),\n@@ -909,7 +902,7 @@ fn ast_ty_to_trait_ref<'tcx>(this: &AstConv<'tcx>,\n                 }\n \n                 _ => {\n-                    span_note!(this.tcx().sess, ty.span,\n+                    span_help!(this.tcx().sess, ty.span,\n                                \"perhaps you forgot parentheses? (per RFC 438)\");\n                 }\n             }\n@@ -964,18 +957,18 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n \n     if suitable_bounds.len() == 0 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"associated type `{}` not found for type parameter `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0220,\n+                          \"associated type `{}` not found for type parameter `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n         return this.tcx().types.err;\n     }\n \n     if suitable_bounds.len() > 1 {\n-        tcx.sess.span_err(ast_ty.span,\n-                          format!(\"ambiguous associated type `{}` in bounds of `{}`\",\n+        span_err!(tcx.sess, ast_ty.span, E0221,\n+                          \"ambiguous associated type `{}` in bounds of `{}`\",\n                                   token::get_name(assoc_name),\n-                                  token::get_name(ty_param_name)).as_slice());\n+                                  token::get_name(ty_param_name));\n \n         for suitable_bound in suitable_bounds.iter() {\n             span_note!(this.tcx().sess, ast_ty.span,\n@@ -1042,7 +1035,7 @@ pub fn ast_ty_to_ty<'tcx>(\n     match ast_ty_to_ty_cache.get(&ast_ty.id) {\n         Some(&ty::atttce_resolved(ty)) => return ty,\n         Some(&ty::atttce_unresolved) => {\n-            tcx.sess.span_fatal(ast_ty.span,\n+            span_fatal!(tcx.sess, ast_ty.span, E0246,\n                                 \"illegal recursive type; insert an enum \\\n                                  or struct in the cycle, if this is \\\n                                  desired\");\n@@ -1093,7 +1086,7 @@ pub fn ast_ty_to_ty<'tcx>(\n             ast::TyParen(ref typ) => ast_ty_to_ty(this, rscope, &**typ),\n             ast::TyBareFn(ref bf) => {\n                 if bf.decl.variadic && bf.abi != abi::C {\n-                    tcx.sess.span_err(ast_ty.span,\n+                    span_err!(tcx.sess, ast_ty.span, E0222,\n                                       \"variadic function must have C calling convention\");\n                 }\n                 let bare_fn = ty_of_bare_fn(this, bf.unsafety, bf.abi, &*bf.decl);\n@@ -1142,18 +1135,18 @@ pub fn ast_ty_to_ty<'tcx>(\n                         ty::mk_self_type(tcx)\n                     }\n                     def::DefMod(id) => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                            &format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node))[]);\n+                        span_fatal!(tcx.sess, ast_ty.span, E0247,\n+                            \"found module name used as a type: {}\",\n+                                    tcx.map.node_to_string(id.node));\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n                     def::DefAssociatedTy(trait_type_id) => {\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n-                        tcx.sess.span_err(ast_ty.span,\n-                                          &format!(\"ambiguous associated \\\n+                        span_err!(tcx.sess, ast_ty.span, E0223,\n+                                          \"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1163,17 +1156,17 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get())[]);\n+                                                  .get());\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n-                        tcx.sess.span_fatal(ast_ty.span,\n-                                            &format!(\"found value name used \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0248,\n+                                            \"found value name used \\\n                                                      as a type: {:?}\",\n-                                                    a_def)[]);\n+                                                    a_def);\n                     }\n                 }\n             }\n@@ -1191,17 +1184,16 @@ pub fn ast_ty_to_ty<'tcx>(\n                                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty),\n                                            Some(i as uint)),\n                             _ => {\n-                                tcx.sess.span_fatal(\n-                                    ast_ty.span, \"expected constant expr for array length\");\n+                                span_fatal!(tcx.sess, ast_ty.span, E0249,\n+                                            \"expected constant expr for array length\");\n                             }\n                         }\n                     }\n                     Err(ref r) => {\n-                        tcx.sess.span_fatal(\n-                            ast_ty.span,\n-                            &format!(\"expected constant expr for array \\\n+                        span_fatal!(tcx.sess, ast_ty.span, E0250,\n+                            \"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r)[]);\n+                                    *r);\n                     }\n                 }\n             }\n@@ -1321,7 +1313,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n \n     // HACK(eddyb) replace the fake self type in the AST with the actual type.\n     let input_params = if self_ty.is_some() {\n-        decl.inputs.slice_from(1)\n+        &decl.inputs[1..]\n     } else {\n         &decl.inputs[]\n     };\n@@ -1339,9 +1331,9 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let lifetimes_for_params = if implied_output_region.is_none() {\n         let input_tys = if self_ty.is_some() {\n             // Skip the first argument if `self` is present.\n-            self_and_input_tys.slice_from(1)\n+            &self_and_input_tys[1..]\n         } else {\n-            self_and_input_tys.slice_from(0)\n+            &self_and_input_tys[]\n         };\n \n         let (ior, lfp) = find_implied_output_region(input_tys, input_pats);\n@@ -1457,9 +1449,6 @@ fn determine_explicit_self_category<'a, 'tcx>(this: &AstConv<'tcx>,\n pub fn ty_of_closure<'tcx>(\n     this: &AstConv<'tcx>,\n     unsafety: ast::Unsafety,\n-    onceness: ast::Onceness,\n-    bounds: ty::ExistentialBounds<'tcx>,\n-    store: ty::TraitStore,\n     decl: &ast::FnDecl,\n     abi: abi::Abi,\n     expected_sig: Option<ty::FnSig<'tcx>>)\n@@ -1509,9 +1498,6 @@ pub fn ty_of_closure<'tcx>(\n \n     ty::ClosureTy {\n         unsafety: unsafety,\n-        onceness: onceness,\n-        store: store,\n-        bounds: bounds,\n         abi: abi,\n         sig: ty::Binder(ty::FnSig {inputs: input_tys,\n                                    output: output_ty,\n@@ -1557,8 +1543,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n                                         None,\n                                         &mut projection_bounds))\n     } else {\n-        this.tcx().sess.span_err(\n-            span,\n+        span_err!(this.tcx().sess, span, E0224,\n             \"at least one non-builtin trait is required for an object type\");\n         None\n     };\n@@ -1593,10 +1578,9 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n-        this.tcx().sess.span_err(\n-            b.trait_ref.path.span,\n-            &format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\")[]);\n+        span_err!(this.tcx().sess, b.trait_ref.path.span, E0225,\n+            \"only the builtin traits can be used \\\n+                     as closure or object bounds\");\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1633,9 +1617,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n            builtin_bounds.repr(tcx));\n \n     if explicit_region_bounds.len() > 1 {\n-        tcx.sess.span_err(\n-            explicit_region_bounds[1].span,\n-            format!(\"only a single explicit lifetime bound is permitted\").as_slice());\n+        span_err!(tcx.sess, explicit_region_bounds[1].span, E0226,\n+            \"only a single explicit lifetime bound is permitted\");\n     }\n \n     if explicit_region_bounds.len() != 0 {\n@@ -1665,11 +1648,10 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // of derived region bounds. If so, use that. Otherwise, report an\n     // error.\n     let r = derived_region_bounds[0];\n-    if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n-        tcx.sess.span_err(\n-            span,\n-            &format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\")[]);\n+    if derived_region_bounds[1..].iter().any(|r1| r != *r1) {\n+        span_err!(tcx.sess, span, E0227,\n+            \"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\");\n     }\n     return Some(r);\n }\n@@ -1693,9 +1675,8 @@ fn compute_region_bound<'tcx>(\n             match rscope.default_region_bound(span) {\n                 Some(r) => { r }\n                 None => {\n-                    this.tcx().sess.span_err(\n-                        span,\n-                        &format!(\"explicit lifetime bound required\")[]);\n+                    span_err!(this.tcx().sess, span, E0228,\n+                        \"explicit lifetime bound required\");\n                     ty::ReStatic\n                 }\n             }\n@@ -1779,8 +1760,7 @@ fn prohibit_projections<'tcx>(tcx: &ty::ctxt<'tcx>,\n                               bindings: &[ConvertedBinding<'tcx>])\n {\n     for binding in bindings.iter().take(1) {\n-        tcx.sess.span_err(\n-            binding.span,\n+        span_err!(tcx.sess, binding.span, E0229,\n             \"associated type bindings are not allowed here\");\n     }\n }"}, {"sha": "ffec1421f9289ae9512607c3f485c352b460d302", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -50,10 +50,9 @@ pub fn check_expr_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n \n                     check_unboxed_closure(fcx, expr, kind, decl, body, None);\n \n-                    fcx.ccx.tcx.sess.span_err(\n-                        expr.span,\n-                        \"can't infer the \\\"kind\\\" of the closure, explicitly annotate it. e.g. \\\n-                        `|&:| {}`\");\n+                    span_err!(fcx.ccx.tcx.sess, expr.span, E0187,\n+                        \"can't infer the \\\"kind\\\" of the closure; explicitly annotate it; e.g. \\\n+                        `|&:| {{}}`\");\n                 },\n                 Some((sig, kind)) => {\n                     check_unboxed_closure(fcx, expr, kind, decl, body, Some(sig));\n@@ -89,15 +88,6 @@ fn check_unboxed_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n     let mut fn_ty = astconv::ty_of_closure(\n         fcx,\n         ast::Unsafety::Normal,\n-        ast::Many,\n-\n-        // The `RegionTraitStore` and region_existential_bounds\n-        // are lies, but we ignore them so it doesn't matter.\n-        //\n-        // FIXME(pcwalton): Refactor this API.\n-        ty::region_existential_bound(ty::ReStatic),\n-        ty::RegionTraitStore(ty::ReStatic, ast::MutImmutable),\n-\n         decl,\n         abi::RustCall,\n         expected_sig);"}, {"sha": "e3e5d67869fa47afb4a6f93ced61ad4d33505a98", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -59,23 +59,21 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory,\n          &ty::StaticExplicitSelfCategory) => {}\n         (&ty::StaticExplicitSelfCategory, _) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+            span_err!(tcx.sess, impl_m_span, E0185,\n+                \"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).as_slice());\n+                            &impl_m.explicit_self));\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n-            tcx.sess.span_err(\n-                impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+            span_err!(tcx.sess, impl_m_span, E0186,\n+                \"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).as_slice());\n+                            &trait_m.explicit_self));\n             return;\n         }\n         _ => {\n@@ -400,11 +398,10 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         // are zero. Since I don't quite know how to phrase things at\n         // the moment, give a kind of vague error message.\n         if trait_params.len() != impl_params.len() {\n-            tcx.sess.span_err(\n-                span,\n-                &format!(\"lifetime parameters or bounds on method `{}` do \\\n+            span_err!(tcx.sess, span, E0195,\n+                \"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                         token::get_name(impl_m.name))[]);\n+                         token::get_name(impl_m.name));\n             return false;\n         }\n "}, {"sha": "3cf9a1a945668d624e1e8d12c65ab2a21d01366b", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -145,6 +145,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n         candidates.sort();\n+        candidates.dedup();\n         let msg = format!(\n             \"methods from traits can only be called if the trait is in scope; \\\n              the following {traits_are} implemented but not in scope, \\\n@@ -172,6 +173,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     if candidates.len() > 0 {\n         // sort from most relevant to least relevant\n         candidates.sort_by(|a, b| a.cmp(b).reverse());\n+        candidates.dedup();\n \n         let msg = format!(\n             \"methods from traits can only be called if the trait is implemented and in scope; \\"}, {"sha": "db4962b0d22db299b517bf75c1c9750a23a86131", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -801,24 +801,23 @@ fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                         }) {\n                             Some(_) => (),\n                             None => {\n-                                ccx.tcx.sess.span_err(attr.span,\n-                                                 format!(\"there is no type parameter \\\n+                                span_err!(ccx.tcx.sess, attr.span, E0230,\n+                                                 \"there is no type parameter \\\n                                                           {} on trait {}\",\n-                                                           s, item.ident.as_str())\n-                                            .as_slice());\n+                                                           s, item.ident.as_str());\n                             }\n                         },\n                         // `{:1}` and `{}` are not to be used\n                         Position::ArgumentIs(_) | Position::ArgumentNext => {\n-                            ccx.tcx.sess.span_err(attr.span,\n+                            span_err!(ccx.tcx.sess, attr.span, E0231,\n                                                   \"only named substitution \\\n                                                    parameters are allowed\");\n                         }\n                     }\n                 }\n             }\n         } else {\n-            ccx.tcx.sess.span_err(attr.span,\n+            span_err!(ccx.tcx.sess, attr.span, E0232,\n                                   \"this attribute must have a value, \\\n                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\")\n         }\n@@ -2099,8 +2098,8 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n-            fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    &err_string[]);\n+            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n+                                    \"{}\", &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2123,11 +2122,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        &format!(\"`for` loop expression has type `{}` which does \\\n+                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n+                                        \"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\",\n-                                                ty_string)[]);\n+                                                maybe try .iter()\", ty_string);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2162,11 +2160,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx().types.err\n                 }\n                 _ => {\n-                    fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            &format!(\"`next` method of the `Iterator` \\\n+                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n+                                            \"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type))\n-                                            []);\n+                                                    fcx.infcx().ty_to_string(return_type));\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -3880,18 +3877,16 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 Err(type_error) => {\n                     let type_error_description =\n                         ty::type_err_to_str(tcx, &type_error);\n-                    fcx.tcx()\n-                       .sess\n-                       .span_err(path.span,\n-                                 &format!(\"structure constructor specifies a \\\n+                    span_err!(fcx.tcx().sess, path.span, E0235,\n+                                 \"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description)[]);\n+                                         type_error_description);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4012,7 +4007,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0236, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4022,7 +4017,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     let substs = Substs::new_type(vec![], vec![]);\n                     ty::mk_struct(tcx, did, tcx.mk_substs(substs))\n                 } else {\n-                    tcx.sess.span_err(expr.span, \"No lang item for range syntax\");\n+                    span_err!(tcx.sess, expr.span, E0237, \"no lang item for range syntax\");\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -4872,8 +4867,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n-                fcx.tcx().sess.span_err(\n-                    span,\n+                span_err!(fcx.tcx().sess, span, E0238,\n                     \"parenthesized parameters may only be used with a trait\");\n                 push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     fcx, space, span, type_defs, data, substs);\n@@ -5230,7 +5224,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, &s[]); }\n+                  Err(s) => { span_fatal!(tcx.sess, it.span, E0240, \"{}\", &s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,"}, {"sha": "56b700663d419de034e65b6abca9ef55d4597809", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 93, "deletions": 3, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -297,14 +297,25 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n     fn visit_region_obligations(&mut self, node_id: ast::NodeId)\n     {\n         debug!(\"visit_region_obligations: node_id={}\", node_id);\n-        let fulfillment_cx = self.fcx.inh.fulfillment_cx.borrow();\n-        for r_o in fulfillment_cx.region_obligations(node_id).iter() {\n+\n+        // Make a copy of the region obligations vec because we'll need\n+        // to be able to borrow the fulfillment-cx below when projecting.\n+        let region_obligations =\n+            self.fcx.inh.fulfillment_cx.borrow()\n+                                       .region_obligations(node_id)\n+                                       .to_vec();\n+\n+        for r_o in region_obligations.iter() {\n             debug!(\"visit_region_obligations: r_o={}\",\n                    r_o.repr(self.tcx()));\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = infer::RelateRegionParamBound(r_o.cause.span);\n             type_must_outlive(self, origin, sup_type, r_o.sub_region);\n         }\n+\n+        // Processing the region obligations should not cause the list to grow further:\n+        assert_eq!(region_obligations.len(),\n+                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed\n@@ -531,7 +542,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n \n         ast::ExprMethodCall(_, _, ref args) => {\n             constrain_call(rcx, expr, Some(&*args[0]),\n-                           args.slice_from(1).iter().map(|e| &**e), false);\n+                           args[1..].iter().map(|e| &**e), false);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -1480,6 +1491,15 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                    generic.to_ty(rcx.tcx()),\n                                    param_env.caller_bounds.predicates.as_slice().to_vec());\n \n+    // In the case of a projection T::Foo, we may be able to extract bounds from the trait def:\n+    match *generic {\n+        GenericKind::Param(..) => { }\n+        GenericKind::Projection(ref projection_ty) => {\n+            param_bounds.push_all(\n+                &projection_bounds(rcx, origin.span(), projection_ty)[]);\n+        }\n+    }\n+\n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n     param_bounds.push(param_env.implicit_region_bound);\n@@ -1511,3 +1531,73 @@ fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          region,\n                                          param_bounds);\n }\n+\n+fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n+                              span: Span,\n+                              projection_ty: &ty::ProjectionTy<'tcx>)\n+                              -> Vec<ty::Region>\n+{\n+    let fcx = rcx.fcx;\n+    let tcx = fcx.tcx();\n+    let infcx = fcx.infcx();\n+\n+    debug!(\"projection_bounds(projection_ty={})\",\n+           projection_ty.repr(tcx));\n+\n+    let ty = ty::mk_projection(tcx, projection_ty.trait_ref.clone(), projection_ty.item_name);\n+\n+    // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n+    // in looking for a trait definition like:\n+    //\n+    // ```\n+    // trait SomeTrait<'a> {\n+    //     type SomeType : 'a;\n+    // }\n+    // ```\n+    //\n+    // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n+    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    traits::elaborate_predicates(tcx, predicates)\n+        .filter_map(|predicate| {\n+            // we're only interesting in `T : 'a` style predicates:\n+            let outlives = match predicate {\n+                ty::Predicate::TypeOutlives(data) => data,\n+                _ => { return None; }\n+            };\n+\n+            debug!(\"projection_bounds: outlives={} (1)\",\n+                   outlives.repr(tcx));\n+\n+            // apply the substitutions (and normalize any projected types)\n+            let outlives = fcx.instantiate_type_scheme(span,\n+                                                       projection_ty.trait_ref.substs,\n+                                                       &outlives);\n+\n+            debug!(\"projection_bounds: outlives={} (2)\",\n+                   outlives.repr(tcx));\n+\n+            let region_result = infcx.try(|_| {\n+                let (outlives, _) =\n+                    infcx.replace_late_bound_regions_with_fresh_var(\n+                        span,\n+                        infer::AssocTypeProjection(projection_ty.item_name),\n+                        &outlives);\n+\n+                debug!(\"projection_bounds: outlives={} (3)\",\n+                       outlives.repr(tcx));\n+\n+                // check whether this predicate applies to our current projection\n+                match infer::mk_eqty(infcx, false, infer::Misc(span), ty, outlives.0) {\n+                    Ok(()) => { Ok(outlives.1) }\n+                    Err(_) => { Err(()) }\n+                }\n+            });\n+\n+            debug!(\"projection_bounds: region_result={}\",\n+                   region_result.repr(tcx));\n+\n+            region_result.ok()\n+        })\n+        .collect()\n+}"}, {"sha": "41b63830279a8f1b8109d993f0c49a9019771758", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -51,7 +51,7 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         {\n             let object_trait = object_trait(&object_trait_ty);\n             if !mutability_allowed(referent_mutbl, target_mutbl) {\n-                fcx.tcx().sess.span_err(source_expr.span,\n+                span_err!(fcx.tcx().sess, source_expr.span, E0188,\n                                         \"types differ in mutability\");\n             } else {\n                 // Ensure that if &'a T is cast to &'b Trait, then T : Trait\n@@ -70,19 +70,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         (_, &ty::ty_uniq(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast an boxed pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0189,\n+                \"can only cast a boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                      ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n-            fcx.ccx.tcx.sess.span_err(\n-                source_expr.span,\n-                &format!(\"can only cast a &-pointer \\\n+            span_err!(fcx.ccx.tcx.sess, source_expr.span, E0190,\n+                \"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n+                        ty::ty_sort_string(fcx.tcx(), source_ty));\n         }\n \n         _ => {\n@@ -272,11 +270,10 @@ fn check_object_type_binds_all_associated_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n \n     for (trait_def_id, name) in associated_types.into_iter() {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n+        span_err!(tcx.sess, span, E0191,\n+            \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n                     name.user_string(tcx),\n-                    ty::item_path_str(tcx, trait_def_id)).as_slice());\n+                    ty::item_path_str(tcx, trait_def_id));\n     }\n }\n "}, {"sha": "60284433ffe457f44cbfe52ccaa410a01ca50059", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -81,10 +81,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}\n                     Some(_) | None => {\n-                        ccx.tcx.sess.span_err(\n-                            item.span,\n-                            format!(\"negative impls are currently \\\n-                                     allowed just for `Send` and `Sync`\").as_slice())\n+                        span_err!(ccx.tcx.sess, item.span, E0192,\n+                            \"negative impls are currently \\\n+                                     allowed just for `Send` and `Sync`\")\n                     }\n                 }\n             }\n@@ -302,12 +301,11 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n     fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n                           span: Span,\n                           bounded_ty: ty::Ty<'t>) {\n-        tcx.sess.span_err(\n-            span,\n-            format!(\"cannot bound type `{}`, where clause \\\n+        span_err!(tcx.sess, span, E0193,\n+            \"cannot bound type `{}`, where clause \\\n                 bounds may only be attached to types involving \\\n                 type parameters\",\n-                bounded_ty.repr(tcx)).as_slice())\n+                bounded_ty.repr(tcx))\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -326,10 +324,9 @@ fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n     for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n         if impl_params.contains(&method_param.name) {\n-            tcx.sess.span_err(\n-                span,\n-                &*format!(\"type parameter `{}` shadows another type parameter of the same name\",\n-                          token::get_name(method_param.name)));\n+            span_err!(tcx.sess, span, E0194,\n+                \"type parameter `{}` shadows another type parameter of the same name\",\n+                          token::get_name(method_param.name));\n         }\n     }\n }"}, {"sha": "52e81585875abe1a3dce1ba4bb9473f32666c29f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -416,7 +416,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx> {\n \n                 ResolvingUnboxedClosure(_) => {\n                     let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.span_err(span,\n+                    span_err!(self.tcx.sess, span, E0196,\n                                            \"cannot determine a type for this \\\n                                             unboxed closure\")\n                 }"}, {"sha": "e535b86a7bfd1e0cfa72c2cb8e74ed84fcc3e261", "filename": "src/librustc_typeck/coherence/impls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fimpls.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -34,10 +34,9 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for ImplsChecker<'cx, 'tcx> {\n                     match trait_ref.self_ty().sty {\n                         ty::ty_struct(..) | ty::ty_enum(..) => {}\n                         _ => {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                &format!(\"builtin traits can only be \\\n-                                          implemented on structs or enums\")[]);\n+                            span_err!(self.tcx.sess, item.span, E0209,\n+                                \"builtin traits can only be \\\n+                                          implemented on structs or enums\");\n                         }\n                     }\n                 }"}, {"sha": "7d59c3f9d3ff5f8d785daeeea2259dee3eb0f0c3", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -490,24 +490,21 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match ty::can_type_implement_copy(&param_env, span, self_type) {\n                 Ok(()) => {}\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0204,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n-                    tcx.sess\n-                       .span_err(span,\n-                                 &format!(\"the trait `Copy` may not be \\\n+                       span_err!(tcx.sess, span, E0205,\n+                                 \"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name))[])\n+                                         token::get_name(name))\n                 }\n                 Err(ty::TypeIsStructural) => {\n-                    tcx.sess\n-                       .span_err(span,\n+                       span_err!(tcx.sess, span, E0206,\n                                  \"the trait `Copy` may not be implemented \\\n                                   for this type; type is not a structure or \\\n                                   enumeration\")"}, {"sha": "60b1fa5f4cf5d1068b3a9479ee321270d351ce0c", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -89,13 +89,11 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n                         if !ty::has_attr(self.tcx, trait_def_id, \"old_orphan_check\") {\n-                            self.tcx.sess.span_err(\n-                                item.span,\n-                                format!(\n+                            span_err!(self.tcx.sess, item.span, E0210,\n                                     \"type parameter `{}` is not constrained by any local type; \\\n                                      only traits defined in the current crate can be implemented \\\n                                      for a type parameter\",\n-                                    param_ty.user_string(self.tcx)).as_slice());\n+                                    param_ty.user_string(self.tcx));\n                             self.tcx.sess.span_note(\n                                 item.span,\n                                 format!(\"for a limited time, you can add \\"}, {"sha": "a7bad3dc789aaadcf981e58d42add7d394d6ffca", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -65,7 +65,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n                 continue;\n             }\n \n-            for &impl2_def_id in trait_impls.slice_from(i+1).iter() {\n+            for &impl2_def_id in trait_impls[(i+1)..].iter() {\n                 self.check_if_impls_overlap(trait_def_id,\n                                             impl1_def_id,\n                                             impl2_def_id);"}, {"sha": "867dea9588568b515c68d7f699b258505e9da37c", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -37,8 +37,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match unsafety {\n                             ast::Unsafety::Normal => { /* OK */ }\n                             ast::Unsafety::Unsafe => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n+                                span_err!(self.tcx.sess, item.span, E0197,\n                                     \"inherent impls cannot be declared as unsafe\");\n                             }\n                         }\n@@ -49,24 +48,21 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n                         match (trait_def.unsafety, unsafety, polarity) {\n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Unsafe, ast::ImplPolarity::Negative) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"negative implementations are not unsafe\").as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0198,\n+                                    \"negative implementations are not unsafe\");\n                             }\n \n                             (ast::Unsafety::Normal, ast::Unsafety::Unsafe, _) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"implementing the trait `{}` is not unsafe\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0199,\n+                                    \"implementing the trait `{}` is not unsafe\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,\n                              ast::Unsafety::Normal, ast::ImplPolarity::Positive) => {\n-                                self.tcx.sess.span_err(\n-                                    item.span,\n-                                    format!(\"the trait `{}` requires an `unsafe impl` declaration\",\n-                                            trait_ref.user_string(self.tcx)).as_slice());\n+                                span_err!(self.tcx.sess, item.span, E0200,\n+                                    \"the trait `{}` requires an `unsafe impl` declaration\",\n+                                            trait_ref.user_string(self.tcx));\n                             }\n \n                             (ast::Unsafety::Unsafe,"}, {"sha": "8158b8da86dfd6f149da7c5b76c95dae73faa269", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -452,7 +452,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut seen_methods = FnvHashSet();\n     for m in ms {\n         if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n-            tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n+            span_err!(tcx.sess, m.span, E0201, \"duplicate method in trait impl\");\n         }\n \n         let m_def_id = local_def(m.id);\n@@ -555,6 +555,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n         // These don't define types.\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemForeignMod(_) | ast::ItemMod(_) | ast::ItemMac(_) => {}\n         ast::ItemEnum(ref enum_definition, ref generics) => {\n             let scheme = ty_of_item(ccx, it);\n@@ -608,7 +609,7 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n                         if opt_trait_ref.is_none() {\n-                            tcx.sess.span_err(typedef.span,\n+                            span_err!(tcx.sess, typedef.span, E0202,\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n@@ -1004,6 +1005,7 @@ fn ty_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item)\n             tcx.tcache.borrow_mut().insert(local_def(it.id), scheme.clone());\n             return scheme;\n         }\n+        ast::ItemExternCrate(_) | ast::ItemUse(_) |\n         ast::ItemImpl(..) | ast::ItemMod(_) |\n         ast::ItemForeignMod(_) | ast::ItemMac(_) => panic!(),\n     }\n@@ -1160,7 +1162,8 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                ccx.tcx.sess.span_err(span, \"type parameter has more than one relaxed default \\\n+                span_err!(ccx.tcx.sess, span, E0203,\n+                          \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n@@ -1690,11 +1693,10 @@ fn enforce_impl_ty_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                              impl trait, self type, or predicates\",\n                             param_ty.user_string(tcx)).as_slice());\n             } else {\n-                tcx.sess.span_err(\n-                    ty_param.span,\n-                    format!(\"the type parameter `{}` is not constrained by the \\\n+                span_err!(tcx.sess, ty_param.span, E0207,\n+                    \"the type parameter `{}` is not constrained by the \\\n                              impl trait, self type, or predicates\",\n-                            param_ty.user_string(tcx)).as_slice());\n+                            param_ty.user_string(tcx));\n                 tcx.sess.span_help(\n                     ty_param.span,\n                     format!(\"you can temporarily opt out of this rule by placing \\"}, {"sha": "3627fa41160608adf2778a3593e93737fc780277", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 59, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -10,38 +10,7 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic! {\n-    E0001,\n-r##\"\n-    This error suggests that the expression arm corresponding to the noted pattern\n-    will never be reached as for all possible values of the expression being matched,\n-    one of the preceeding patterns will match.\n-\n-    This means that perhaps some of the preceeding patterns are too general, this\n-    one is too specific or the ordering is incorrect.\n-\"## }\n-\n register_diagnostics! {\n-    E0002,\n-    E0003,\n-    E0004,\n-    E0005,\n-    E0006,\n-    E0007,\n-    E0008,\n-    E0009,\n-    E0010,\n-    E0011,\n-    E0012,\n-    E0013,\n-    E0014,\n-    E0015,\n-    E0016,\n-    E0017,\n-    E0018,\n-    E0019,\n-    E0020,\n-    E0022,\n     E0023,\n     E0024,\n     E0025,\n@@ -61,12 +30,9 @@ register_diagnostics! {\n     E0046,\n     E0049,\n     E0050,\n-    E0051,\n-    E0052,\n     E0053,\n     E0054,\n     E0055,\n-    E0056,\n     E0057,\n     E0059,\n     E0060,\n@@ -101,16 +67,12 @@ register_diagnostics! {\n     E0092,\n     E0093,\n     E0094,\n-    E0100,\n     E0101,\n     E0102,\n     E0103,\n     E0104,\n     E0106,\n     E0107,\n-    E0108,\n-    E0109,\n-    E0110,\n     E0116,\n     E0117,\n     E0118,\n@@ -125,38 +87,92 @@ register_diagnostics! {\n     E0130,\n     E0131,\n     E0132,\n-    E0133,\n-    E0134,\n-    E0135,\n-    E0136,\n-    E0137,\n-    E0138,\n-    E0139,\n-    E0140,\n     E0141,\n-    E0152,\n-    E0153,\n-    E0157,\n-    E0158,\n     E0159,\n-    E0161,\n-    E0162,\n     E0163,\n     E0164,\n-    E0165,\n     E0166,\n     E0167,\n     E0168,\n-    E0169,\n-    E0171,\n     E0172,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n-    E0177,\n     E0178,\n-    E0180,\n-    E0181,\n     E0182,\n     E0183,\n-    E0184\n+    E0184,\n+    E0185,\n+    E0186,\n+    E0187, // can't infer the kind of the closure\n+    E0188, // types differ in mutability\n+    E0189, // can only cast a boxed pointer to a boxed object\n+    E0190, // can only cast a &-pointer to an &-object\n+    E0191, // value of the associated type must be specified\n+    E0192, // negative imples are allowed just fo `Send` and `Sync`\n+    E0193, // cannot bound type where clause bounds may only be attached to types\n+           // involving type parameters\n+    E0194,\n+    E0195, // lifetime parameters or bounds on method do not match the trait declaration\n+    E0196, // cannot determine a type for this unboxed closure\n+    E0197, // inherent impls cannot be declared as unsafe\n+    E0198, // negative implementations are not unsafe\n+    E0199, // implementing trait is not unsafe\n+    E0200, // trait requires an `unsafe impl` declaration\n+    E0201, // duplicate method in trait impl\n+    E0202, // associated items are not allowed in inherint impls\n+    E0203, // type parameter has more than one relaxed default bound,\n+           // and only one is supported\n+    E0204, // trait `Copy` may not be implemented for this type; field\n+           // does not implement `Copy`\n+    E0205, // trait `Copy` may not be implemented for this type; variant\n+           // does not implement `copy`\n+    E0206, // trait `Copy` may not be implemented for this type; type is\n+           // not a structure or enumeration\n+    E0207, // type parameter is not constrained by the impl trait, self type, or predicate\n+    E0208,\n+    E0209, // builtin traits can only be implemented on structs or enums\n+    E0210, // type parameter is not constrained by any local type\n+    E0211,\n+    E0212, // cannot extract an associated type from a higher-ranked trait bound\n+    E0213, // associated types are not accepted in this context\n+    E0214, // parenthesized parameters may only be used with a trait\n+    E0215, // angle-bracket notation is not stable with `Fn`\n+    E0216, // parenthetical notation is only stable with `Fn`\n+    E0217, // ambiguous associated type, defined in multiple supertraits\n+    E0218, // no associated type defined\n+    E0219, // associated type defined in higher-ranked supertrait\n+    E0220, // associated type not found for type parameter\n+    E0221, // ambiguous associated type in bounds\n+    E0222, // variadic function must have C calling convention\n+    E0223, // ambiguous associated type\n+    E0224, // at least one non-builtin train is required for an object type\n+    E0225, // only the builtin traits can be used as closure or object bounds\n+    E0226, // only a single explicit lifetime bound is permitted\n+    E0227, // ambiguous lifetime bound, explicit lifetime bound required\n+    E0228, // explicit lifetime bound required\n+    E0229, // associated type bindings are not allowed here\n+    E0230, // there is no type parameter on trait\n+    E0231, // only named substitution parameters are allowed\n+    E0232, // this attribute must have a value\n+    E0233,\n+    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0235, // structure constructor specifies a structure of type but\n+    E0236, // no lang item for range syntax\n+    E0237, // no lang item for range syntax\n+    E0238, // parenthesized parameters may only be used with a trait\n+    E0239, // `next` method of `Iterator` trait has unexpected type\n+    E0240,\n+    E0241,\n+    E0242, // internal error looking up a definition\n+    E0243, // wrong number of type arguments\n+    E0244, // wrong number of type arguments\n+    E0245, // not a trait\n+    E0246, // illegal recursive type\n+    E0247, // found module name used as a type\n+    E0248, // found value name used as a type\n+    E0249, // expected constant expr for array length\n+    E0250  // expected constant expr for array length\n }\n+\n+__build_diagnostic_array! { DIAGNOSTICS }\n+"}, {"sha": "78007f3552ece5b61d336e719d5f0a4d6b286186", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -111,6 +111,10 @@ use syntax::ast_util::local_def;\n \n use std::cell::RefCell;\n \n+// NB: This module needs to be declared first so diagnostics are\n+// registered before they are used.\n+pub mod diagnostics;\n+\n mod check;\n mod rscope;\n mod astconv;\n@@ -158,7 +162,7 @@ fn lookup_def_tcx(tcx:&ty::ctxt, sp: Span, id: ast::NodeId) -> def::Def {\n     match tcx.def_map.borrow().get(&id) {\n         Some(x) => x.clone(),\n         _ => {\n-            tcx.sess.span_fatal(sp, \"internal error looking up a definition\")\n+            span_fatal!(tcx.sess, sp, E0242, \"internal error looking up a definition\")\n         }\n     }\n }\n@@ -202,11 +206,11 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n     match result {\n         Ok(_) => true,\n         Err(ref terr) => {\n-            tcx.sess.span_err(span,\n-                              &format!(\"{}: {}\",\n+            span_err!(tcx.sess, span, E0211,\n+                              \"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr))[]);\n+                                                          terr));\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }"}, {"sha": "6ed18368738e0b7985cc9bbeb62fcc2d62248a0f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -240,7 +240,7 @@ enum VarianceTerm<'a> {\n     InferredTerm(InferredIndex),\n }\n \n-impl<'a> fmt::Show for VarianceTerm<'a> {\n+impl<'a> fmt::Debug for VarianceTerm<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ConstantTerm(c1) => write!(f, \"{:?}\", c1),\n@@ -380,6 +380,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for TermsContext<'a, 'tcx> {\n                 visit::walk_item(self, item);\n             }\n \n+            ast::ItemExternCrate(_) |\n+            ast::ItemUse(_) |\n             ast::ItemImpl(..) |\n             ast::ItemStatic(..) |\n             ast::ItemConst(..) |\n@@ -532,6 +534,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                 }\n             }\n \n+            ast::ItemExternCrate(_) |\n+            ast::ItemUse(_) |\n             ast::ItemStatic(..) |\n             ast::ItemConst(..) |\n             ast::ItemFn(..) |\n@@ -1055,7 +1059,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), &found[]);\n+                span_err!(tcx.sess, tcx.map.span(item_id), E0208, \"{}\", &found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "6e79bd9bebda1003233dfa0a9b8ce95d06e125f7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -147,14 +147,22 @@ pub fn record_extern_fqn(cx: &DocContext, did: ast::DefId, kind: clean::TypeKind\n \n pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n                             did: ast::DefId) -> clean::Trait {\n+    use clean::TraitMethod;\n+\n     let def = ty::lookup_trait_def(tcx, did);\n     let trait_items = ty::trait_items(tcx, did).clean(cx);\n     let provided = ty::provided_trait_methods(tcx, did);\n     let items = trait_items.into_iter().map(|trait_item| {\n-        if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n-            clean::ProvidedMethod(trait_item)\n-        } else {\n-            clean::RequiredMethod(trait_item)\n+        match trait_item.inner {\n+            clean::TyMethodItem(_) => {\n+                if provided.iter().any(|a| a.def_id == trait_item.def_id) {\n+                    TraitMethod::ProvidedMethod(trait_item)\n+                } else {\n+                    TraitMethod::RequiredMethod(trait_item)\n+                }\n+            },\n+            clean::AssociatedTypeItem(_) => TraitMethod::TypeTraitItem(trait_item),\n+            _ => unreachable!()\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n@@ -311,12 +319,25 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                 };\n                 Some(item)\n             }\n-            ty::TypeTraitItem(_) => {\n-                // FIXME(pcwalton): Implement.\n-                None\n+            ty::TypeTraitItem(ref assoc_ty) => {\n+                let did = assoc_ty.def_id;\n+                let type_scheme = ty::lookup_item_type(tcx, did);\n+                // Not sure the choice of ParamSpace actually matters here, because an\n+                // associated type won't have generics on the LHS\n+                let typedef = (type_scheme, subst::ParamSpace::TypeSpace).clean(cx);\n+                Some(clean::Item {\n+                    name: Some(assoc_ty.name.clean(cx)),\n+                    inner: clean::TypedefItem(typedef),\n+                    source: clean::Span::empty(),\n+                    attrs: vec![],\n+                    visibility: None,\n+                    stability: stability::lookup(tcx, did).clean(cx),\n+                    def_id: did\n+                })\n             }\n         }\n     }).collect();\n+    let polarity = csearch::get_impl_polarity(tcx, did);\n     return Some(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             derived: clean::detect_derived(attrs.as_slice()),\n@@ -329,6 +350,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             for_: ty.ty.clean(cx),\n             generics: (&ty.generics, subst::TypeSpace).clean(cx),\n             items: trait_items,\n+            polarity: polarity.map(|p| { p.clean(cx) }),\n         }),\n         source: clean::Span::empty(),\n         name: None,"}, {"sha": "203d9758c579d5dfa0231338a0293eac3ef78de4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 146, "deletions": 146, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -18,8 +18,7 @@ pub use self::TypeKind::*;\n pub use self::StructField::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n-pub use self::ViewItemInner::*;\n-pub use self::ViewPath::*;\n+pub use self::Import::*;\n pub use self::ItemEnum::*;\n pub use self::Attribute::*;\n pub use self::TyParamBound::*;\n@@ -45,7 +44,6 @@ use rustc::middle::def;\n use rustc::middle::subst::{self, ParamSpace, VecPerParamSpace};\n use rustc::middle::ty;\n use rustc::middle::stability;\n-use rustc::session::config;\n \n use std::rc::Rc;\n use std::u32;\n@@ -116,7 +114,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for syntax::owned_slice::OwnedSlice<T> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Crate {\n     pub name: String,\n     pub src: FsPath,\n@@ -127,15 +125,17 @@ pub struct Crate {\n \n impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n+        use rustc::session::config::Input;\n+\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean(cx)));\n         });\n         externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n-        let input = config::Input::File(cx.src.clone());\n-        let name = link::find_crate_name(None, self.attrs.as_slice(), &input);\n+        let input = &cx.input;\n+        let name = link::find_crate_name(None, self.attrs.as_slice(), input);\n \n         // Clean the crate, translating the entire libsyntax AST to one that is\n         // understood by rustdoc.\n@@ -188,17 +188,22 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             m.items.extend(tmp.into_iter());\n         }\n \n+        let src = match cx.input {\n+            Input::File(ref path) => path.clone(),\n+            Input::Str(_) => FsPath::new(\"\") // FIXME: this is wrong\n+        };\n+\n         Crate {\n             name: name.to_string(),\n-            src: cx.src.clone(),\n+            src: src,\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ExternalCrate {\n     pub name: String,\n     pub attrs: Vec<Attribute>,\n@@ -231,7 +236,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n /// Anything with a source location and set of attributes and, optionally, a\n /// name. That is, anything that can be documented. This doesn't correspond\n /// directly to the AST's concept of an item; it's a strict superset.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Item {\n     /// Stringified span\n     pub source: Span,\n@@ -307,8 +312,10 @@ impl Item {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ItemEnum {\n+    ExternCrateItem(String, Option<String>),\n+    ImportItem(Import),\n     StructItem(Struct),\n     EnumItem(Enum),\n     FunctionItem(Function),\n@@ -318,8 +325,6 @@ pub enum ItemEnum {\n     ConstantItem(Constant),\n     TraitItem(Trait),\n     ImplItem(Impl),\n-    /// `use` and `extern crate`\n-    ViewItemItem(ViewItem),\n     /// A method signature only. Used for required methods in traits (ie,\n     /// non-default-methods).\n     TyMethodItem(TyMethod),\n@@ -336,7 +341,7 @@ pub enum ItemEnum {\n     AssociatedTypeItem(TyParam),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Module {\n     pub items: Vec<Item>,\n     pub is_crate: bool,\n@@ -349,27 +354,21 @@ impl Clean<Item> for doctree::Module {\n         } else {\n             \"\".to_string()\n         };\n-        let mut foreigns = Vec::new();\n-        for subforeigns in self.foreigns.clean(cx).into_iter() {\n-            for foreign in subforeigns.into_iter() {\n-                foreigns.push(foreign)\n-            }\n-        }\n-        let items: Vec<Vec<Item> > = vec!(\n-            self.structs.clean(cx),\n-            self.enums.clean(cx),\n-            self.fns.clean(cx),\n-            foreigns,\n-            self.mods.clean(cx),\n-            self.typedefs.clean(cx),\n-            self.statics.clean(cx),\n-            self.constants.clean(cx),\n-            self.traits.clean(cx),\n-            self.impls.clean(cx),\n-            self.view_items.clean(cx).into_iter()\n-                           .flat_map(|s| s.into_iter()).collect(),\n-            self.macros.clean(cx),\n-        );\n+        let items: Vec<Item> =\n+                   self.extern_crates.iter().map(|x| x.clean(cx))\n+            .chain(self.imports.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.structs.iter().map(|x| x.clean(cx)))\n+            .chain(self.enums.iter().map(|x| x.clean(cx)))\n+            .chain(self.fns.iter().map(|x| x.clean(cx)))\n+            .chain(self.foreigns.iter().flat_map(|x| x.clean(cx).into_iter()))\n+            .chain(self.mods.iter().map(|x| x.clean(cx)))\n+            .chain(self.typedefs.iter().map(|x| x.clean(cx)))\n+            .chain(self.statics.iter().map(|x| x.clean(cx)))\n+            .chain(self.constants.iter().map(|x| x.clean(cx)))\n+            .chain(self.traits.iter().map(|x| x.clean(cx)))\n+            .chain(self.impls.iter().map(|x| x.clean(cx)))\n+            .chain(self.macros.iter().map(|x| x.clean(cx)))\n+            .collect();\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -395,9 +394,7 @@ impl Clean<Item> for doctree::Module {\n             def_id: ast_util::local_def(self.id),\n             inner: ModuleItem(Module {\n                is_crate: self.is_crate,\n-               items: items.iter()\n-                           .flat_map(|x| x.iter().map(|x| (*x).clone()))\n-                           .collect(),\n+               items: items\n             })\n         }\n     }\n@@ -938,7 +935,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Method {\n     pub generics: Generics,\n     pub self_: SelfTy,\n@@ -977,7 +974,7 @@ impl Clean<Item> for ast::Method {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct TyMethod {\n     pub unsafety: ast::Unsafety,\n     pub decl: FnDecl,\n@@ -1015,7 +1012,7 @@ impl Clean<Item> for ast::TypeMethod {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Show)]\n pub enum SelfTy {\n     SelfStatic,\n     SelfValue,\n@@ -1036,7 +1033,7 @@ impl Clean<SelfTy> for ast::ExplicitSelf_ {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n@@ -1155,7 +1152,7 @@ impl Clean<FunctionRetTy> for ast::FunctionRetTy {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Trait {\n     pub unsafety: ast::Unsafety,\n     pub items: Vec<TraitMethod>,\n@@ -1199,11 +1196,11 @@ impl Clean<PolyTrait> for ast::PolyTraitRef {\n \n /// An item belonging to a trait, whether a method or associated. Could be named\n /// TraitItem except that's already taken by an exported enum variant.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum TraitMethod {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n-    TypeTraitItem(Item),\n+    TypeTraitItem(Item), // an associated type\n }\n \n impl TraitMethod {\n@@ -1244,7 +1241,7 @@ impl Clean<TraitMethod> for ast::TraitItem {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum ImplMethod {\n     MethodImplItem(Item),\n     TypeImplItem(Item),\n@@ -1380,7 +1377,7 @@ pub enum PrimitiveType {\n     PrimitiveTuple,\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Copy)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Copy, Show)]\n pub enum TypeKind {\n     TypeEnum,\n     TypeFunction,\n@@ -1623,7 +1620,7 @@ impl Clean<Type> for ast::QPath {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum StructField {\n     HiddenStructField, // inserted later by strip passes\n     TypedStructField(Type),\n@@ -1682,7 +1679,7 @@ impl Clean<Option<Visibility>> for ast::Visibility {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Struct {\n     pub struct_type: doctree::StructType,\n     pub generics: Generics,\n@@ -1712,7 +1709,7 @@ impl Clean<Item> for doctree::Struct {\n /// This is a more limited form of the standard Struct, different in that\n /// it lacks the things most items have (name, id, parameterization). Found\n /// only as a variant in an enum.\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct VariantStruct {\n     pub struct_type: doctree::StructType,\n     pub fields: Vec<Item>,\n@@ -1729,7 +1726,7 @@ impl Clean<VariantStruct> for syntax::ast::StructDef {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Enum {\n     pub variants: Vec<Item>,\n     pub generics: Generics,\n@@ -1754,7 +1751,7 @@ impl Clean<Item> for doctree::Enum {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Variant {\n     pub kind: VariantKind,\n }\n@@ -1822,7 +1819,7 @@ impl<'tcx> Clean<Item> for ty::VariantInfo<'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub enum VariantKind {\n     CLikeVariant,\n     TupleVariant(Vec<Type>),\n@@ -1872,9 +1869,9 @@ impl Clean<Span> for syntax::codemap::Span {\n         Span {\n             filename: filename.to_string(),\n             loline: lo.line,\n-            locol: lo.col.to_uint(),\n+            locol: lo.col.to_usize(),\n             hiline: hi.line,\n-            hicol: hi.col.to_uint(),\n+            hicol: hi.col.to_usize(),\n         }\n     }\n }\n@@ -1969,7 +1966,7 @@ impl Clean<String> for ast::Name {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Typedef {\n     pub type_: Type,\n     pub generics: Generics,\n@@ -2082,13 +2079,29 @@ impl Clean<Mutability> for ast::Mutability {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Copy, Show)]\n+pub enum ImplPolarity {\n+    Positive,\n+    Negative,\n+}\n+\n+impl Clean<ImplPolarity> for ast::ImplPolarity {\n+    fn clean(&self, _: &DocContext) -> ImplPolarity {\n+        match self {\n+            &ast::ImplPolarity::Positive => ImplPolarity::Positive,\n+            &ast::ImplPolarity::Negative => ImplPolarity::Negative,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Impl {\n     pub generics: Generics,\n     pub trait_: Option<Type>,\n     pub for_: Type,\n     pub items: Vec<Item>,\n     pub derived: bool,\n+    pub polarity: Option<ImplPolarity>,\n }\n \n fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n@@ -2115,17 +2128,27 @@ impl Clean<Item> for doctree::Impl {\n                         }\n                     }).collect(),\n                 derived: detect_derived(self.attrs.as_slice()),\n+                polarity: Some(self.polarity.clean(cx)),\n             }),\n         }\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub struct ViewItem {\n-    pub inner: ViewItemInner,\n+impl Clean<Item> for doctree::ExternCrate {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ExternCrateItem(self.name.clean(cx), self.path.clone())\n+        }\n+    }\n }\n \n-impl Clean<Vec<Item>> for ast::ViewItem {\n+impl Clean<Vec<Item>> for doctree::Import {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         // We consider inlining the documentation of `pub use` statements, but we\n         // forcefully don't inline if this is not public or if the\n@@ -2136,81 +2159,63 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 None => false,\n             }\n         });\n-        let convert = |&: node: &ast::ViewItem_| {\n-            Item {\n-                name: None,\n-                attrs: self.attrs.clean(cx),\n-                source: self.span.clean(cx),\n-                def_id: ast_util::local_def(0),\n-                visibility: self.vis.clean(cx),\n-                stability: None,\n-                inner: ViewItemItem(ViewItem { inner: node.clean(cx) }),\n+        let (mut ret, inner) = match self.node {\n+            ast::ViewPathGlob(ref p) => {\n+                (vec![], GlobImport(resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        };\n-        let mut ret = Vec::new();\n-        match self.node {\n-            ast::ViewItemUse(ref path) if !denied => {\n-                match path.node {\n-                    ast::ViewPathGlob(..) => ret.push(convert(&self.node)),\n-                    ast::ViewPathList(ref a, ref list, ref b) => {\n-                        // Attempt to inline all reexported items, but be sure\n-                        // to keep any non-inlineable reexports so they can be\n-                        // listed in the documentation.\n-                        let remaining = list.iter().filter(|path| {\n-                            match inline::try_inline(cx, path.node.id(), None) {\n-                                Some(items) => {\n-                                    ret.extend(items.into_iter()); false\n-                                }\n-                                None => true,\n+            ast::ViewPathList(ref p, ref list) => {\n+                // Attempt to inline all reexported items, but be sure\n+                // to keep any non-inlineable reexports so they can be\n+                // listed in the documentation.\n+                let mut ret = vec![];\n+                let remaining = if !denied {\n+                    let mut remaining = vec![];\n+                    for path in list.iter() {\n+                        match inline::try_inline(cx, path.node.id(), None) {\n+                            Some(items) => {\n+                                ret.extend(items.into_iter());\n+                            }\n+                            None => {\n+                                remaining.push(path.clean(cx));\n                             }\n-                        }).map(|a| a.clone()).collect::<Vec<ast::PathListItem>>();\n-                        if remaining.len() > 0 {\n-                            let path = ast::ViewPathList(a.clone(),\n-                                                         remaining,\n-                                                         b.clone());\n-                            let path = syntax::codemap::dummy_spanned(path);\n-                            ret.push(convert(&ast::ViewItemUse(P(path))));\n-                        }\n-                    }\n-                    ast::ViewPathSimple(ident, _, id) => {\n-                        match inline::try_inline(cx, id, Some(ident)) {\n-                            Some(items) => ret.extend(items.into_iter()),\n-                            None => ret.push(convert(&self.node)),\n                         }\n                     }\n-                }\n-            }\n-            ref n => ret.push(convert(n)),\n-        }\n-        return ret;\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum ViewItemInner {\n-    ExternCrate(String, Option<String>, ast::NodeId),\n-    Import(ViewPath)\n-}\n-\n-impl Clean<ViewItemInner> for ast::ViewItem_ {\n-    fn clean(&self, cx: &DocContext) -> ViewItemInner {\n-        match self {\n-            &ast::ViewItemExternCrate(ref i, ref p, ref id) => {\n-                let string = match *p {\n-                    None => None,\n-                    Some((ref x, _)) => Some(x.get().to_string()),\n+                    remaining\n+                } else {\n+                    list.clean(cx)\n                 };\n-                ExternCrate(i.clean(cx), string, *id)\n+                if remaining.is_empty() {\n+                    return ret;\n+                }\n+                (ret, ImportList(resolve_use_source(cx, p.clean(cx), self.id),\n+                                 remaining))\n             }\n-            &ast::ViewItemUse(ref vp) => {\n-                Import(vp.clean(cx))\n+            ast::ViewPathSimple(i, ref p) => {\n+                if !denied {\n+                    match inline::try_inline(cx, self.id, Some(i)) {\n+                        Some(items) => return items,\n+                        None => {}\n+                    }\n+                }\n+                (vec![], SimpleImport(i.clean(cx),\n+                                      resolve_use_source(cx, p.clean(cx), self.id)))\n             }\n-        }\n+        };\n+        ret.push(Item {\n+            name: None,\n+            attrs: self.attrs.clean(cx),\n+            source: self.whence.clean(cx),\n+            def_id: ast_util::local_def(0),\n+            visibility: self.vis.clean(cx),\n+            stability: None,\n+            inner: ImportItem(inner)\n+        });\n+        ret\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n-pub enum ViewPath {\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n+pub enum Import {\n     // use source as str;\n     SimpleImport(String, ImportSource),\n     // use source::*;\n@@ -2219,28 +2224,13 @@ pub enum ViewPath {\n     ImportList(ImportSource, Vec<ViewListIdent>),\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ImportSource {\n     pub path: Path,\n     pub did: Option<ast::DefId>,\n }\n \n-impl Clean<ViewPath> for ast::ViewPath {\n-    fn clean(&self, cx: &DocContext) -> ViewPath {\n-        match self.node {\n-            ast::ViewPathSimple(ref i, ref p, id) =>\n-                SimpleImport(i.clean(cx), resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathGlob(ref p, id) =>\n-                GlobImport(resolve_use_source(cx, p.clean(cx), id)),\n-            ast::ViewPathList(ref p, ref pl, id) => {\n-                ImportList(resolve_use_source(cx, p.clean(cx), id),\n-                           pl.clean(cx))\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct ViewListIdent {\n     pub name: String,\n     pub source: Option<ast::DefId>,\n@@ -2459,7 +2449,7 @@ fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n     })\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Macro {\n     pub source: String,\n }\n@@ -2480,7 +2470,7 @@ impl Clean<Item> for doctree::Macro {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Show)]\n pub struct Stability {\n     pub level: attr::StabilityLevel,\n     pub text: String\n@@ -2516,14 +2506,14 @@ impl Clean<Item> for ty::AssociatedType {\n             source: DUMMY_SP.clean(cx),\n             name: Some(self.name.clean(cx)),\n             attrs: Vec::new(),\n-            // FIXME(#18048): this is wrong, but cross-crate associated types are broken\n-            // anyway, for the time being.\n             inner: AssociatedTypeItem(TyParam {\n                 name: self.name.clean(cx),\n                 did: ast::DefId {\n                     krate: 0,\n                     node: ast::DUMMY_NODE_ID\n                 },\n+                // FIXME(#20727): bounds are missing and need to be filled in from the\n+                // predicates on the trait itself\n                 bounds: vec![],\n                 default: None,\n             }),\n@@ -2555,6 +2545,16 @@ impl Clean<Item> for ast::Typedef {\n     }\n }\n \n+impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ParamSpace) {\n+    fn clean(&self, cx: &DocContext) -> Typedef {\n+        let (ref ty_scheme, ps) = *self;\n+        Typedef {\n+            type_: ty_scheme.ty.clean(cx),\n+            generics: (&ty_scheme.generics, ps).clean(cx)\n+        }\n+    }\n+}\n+\n fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n                t: ty::Ty, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "04947e41663ece794c6c2c52f3b29ef3950216da", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -12,7 +12,6 @@ pub use self::MaybeTyped::*;\n use rustc_driver::driver;\n use rustc::session::{self, config};\n use rustc::session::config::UnstableFeatures;\n-use rustc::session::search_paths::SearchPaths;\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n use rustc_trans::back::link;\n@@ -27,6 +26,9 @@ use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n \n+pub use rustc::session::config::Input;\n+pub use rustc::session::search_paths::SearchPaths;\n+\n /// Are we generating documentation (`Typed`) or tests (`NotTyped`)?\n pub enum MaybeTyped<'tcx> {\n     Typed(ty::ctxt<'tcx>),\n@@ -39,7 +41,7 @@ pub type ExternalPaths = RefCell<Option<HashMap<ast::DefId,\n pub struct DocContext<'tcx> {\n     pub krate: &'tcx ast::Crate,\n     pub maybe_typed: MaybeTyped<'tcx>,\n-    pub src: Path,\n+    pub input: Input,\n     pub external_paths: ExternalPaths,\n     pub external_traits: RefCell<Option<HashMap<ast::DefId, clean::Trait>>>,\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n@@ -80,12 +82,15 @@ pub struct CrateAnalysis {\n pub type Externs = HashMap<String, Vec<String>>;\n \n pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n-                cpath: &Path, triple: Option<String>)\n+                input: Input, triple: Option<String>)\n                 -> (clean::Crate, CrateAnalysis) {\n \n     // Parse, resolve, and typecheck the given crate.\n \n-    let input = config::Input::File(cpath.clone());\n+    let cpath = match input {\n+        Input::File(ref p) => Some(p.clone()),\n+        _ => None\n+    };\n \n     let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n@@ -107,8 +112,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n \n-    let sess = session::build_session_(sessopts,\n-                                       Some(cpath.clone()),\n+    let sess = session::build_session_(sessopts, cpath,\n                                        span_diagnostic_handler);\n \n     let cfg = config::build_configuration(&sess);\n@@ -136,7 +140,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let ctxt = DocContext {\n         krate: ty_cx.map.krate(),\n         maybe_typed: Typed(ty_cx),\n-        src: cpath.clone(),\n+        input: input,\n         external_traits: RefCell::new(Some(HashMap::new())),\n         external_typarams: RefCell::new(Some(HashMap::new())),\n         external_paths: RefCell::new(Some(HashMap::new())),"}, {"sha": "0e8ab594c20c1e2125f75f67c52f21657da7aa2e", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -25,6 +25,8 @@ pub struct Module {\n     pub attrs: Vec<ast::Attribute>,\n     pub where_outer: Span,\n     pub where_inner: Span,\n+    pub extern_crates: Vec<ExternCrate>,\n+    pub imports: Vec<Import>,\n     pub structs: Vec<Struct>,\n     pub enums: Vec<Enum>,\n     pub fns: Vec<Function>,\n@@ -38,7 +40,6 @@ pub struct Module {\n     pub stab: Option<attr::Stability>,\n     pub impls: Vec<Impl>,\n     pub foreigns: Vec<ast::ForeignMod>,\n-    pub view_items: Vec<ast::ViewItem>,\n     pub macros: Vec<Macro>,\n     pub is_crate: bool,\n }\n@@ -53,6 +54,8 @@ impl Module {\n             where_outer: syntax::codemap::DUMMY_SP,\n             where_inner: syntax::codemap::DUMMY_SP,\n             attrs      : Vec::new(),\n+            extern_crates: Vec::new(),\n+            imports    : Vec::new(),\n             structs    : Vec::new(),\n             enums      : Vec::new(),\n             fns        : Vec::new(),\n@@ -62,7 +65,6 @@ impl Module {\n             constants  : Vec::new(),\n             traits     : Vec::new(),\n             impls      : Vec::new(),\n-            view_items : Vec::new(),\n             foreigns   : Vec::new(),\n             macros     : Vec::new(),\n             is_crate   : false,\n@@ -202,6 +204,22 @@ pub struct Macro {\n     pub stab: Option<attr::Stability>,\n }\n \n+pub struct ExternCrate {\n+    pub name: Ident,\n+    pub path: Option<String>,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub whence: Span,\n+}\n+\n+pub struct Import {\n+    pub id: NodeId,\n+    pub vis: ast::Visibility,\n+    pub attrs: Vec<ast::Attribute>,\n+    pub node: ast::ViewPath_,\n+    pub whence: Span,\n+}\n+\n pub fn struct_type_from_def(sd: &ast::StructDef) -> StructType {\n     if sd.ctor_id.is_some() {\n         // We are in a tuple-struct"}, {"sha": "fe8ac3fde5fcc596e3a2f4f37dd0e09302e7859e", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -19,7 +19,7 @@ use std::fmt;\n /// string when passed to a format string.\n pub struct Escape<'a>(pub &'a str);\n \n-impl<'a> fmt::String for Escape<'a> {\n+impl<'a> fmt::Display for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n@@ -29,7 +29,7 @@ impl<'a> fmt::String for Escape<'a> {\n         for (i, ch) in s.bytes().enumerate() {\n             match ch as char {\n                 '<' | '>' | '&' | '\\'' | '\"' => {\n-                    try!(fmt.write_str(pile_o_bits.slice(last, i)));\n+                    try!(fmt.write_str(&pile_o_bits[last.. i]));\n                     let s = match ch as char {\n                         '>' => \"&gt;\",\n                         '<' => \"&lt;\",\n@@ -46,7 +46,7 @@ impl<'a> fmt::String for Escape<'a> {\n         }\n \n         if last < s.len() {\n-            try!(fmt.write_str(pile_o_bits.slice_from(last)));\n+            try!(fmt.write_str(&pile_o_bits[last..]));\n         }\n         Ok(())\n     }"}, {"sha": "b713032bc05776e29589f66f409aa6d4016bd23a", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -66,7 +66,7 @@ impl UnsafetySpace {\n     }\n }\n \n-impl<'a, T: fmt::String> fmt::String for CommaSep<'a, T> {\n+impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -76,7 +76,7 @@ impl<'a, T: fmt::String> fmt::String for CommaSep<'a, T> {\n     }\n }\n \n-impl<'a> fmt::String for TyParamBounds<'a> {\n+impl<'a> fmt::Display for TyParamBounds<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &TyParamBounds(bounds) = self;\n         for (i, bound) in bounds.iter().enumerate() {\n@@ -89,7 +89,7 @@ impl<'a> fmt::String for TyParamBounds<'a> {\n     }\n }\n \n-impl fmt::String for clean::Generics {\n+impl fmt::Display for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n         try!(f.write_str(\"&lt;\"));\n@@ -126,7 +126,7 @@ impl fmt::String for clean::Generics {\n     }\n }\n \n-impl<'a> fmt::String for WhereClause<'a> {\n+impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &WhereClause(gens) = self;\n         if gens.where_predicates.len() == 0 {\n@@ -163,14 +163,14 @@ impl<'a> fmt::String for WhereClause<'a> {\n     }\n }\n \n-impl fmt::String for clean::Lifetime {\n+impl fmt::Display for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.get_ref()));\n         Ok(())\n     }\n }\n \n-impl fmt::String for clean::PolyTrait {\n+impl fmt::Display for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() > 0 {\n             try!(f.write_str(\"for&lt;\"));\n@@ -186,7 +186,7 @@ impl fmt::String for clean::PolyTrait {\n     }\n }\n \n-impl fmt::String for clean::TyParamBound {\n+impl fmt::Display for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::RegionBound(ref lt) => {\n@@ -203,7 +203,7 @@ impl fmt::String for clean::TyParamBound {\n     }\n }\n \n-impl fmt::String for clean::PathParameters {\n+impl fmt::Display for clean::PathParameters {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::PathParameters::AngleBracketed {\n@@ -257,14 +257,14 @@ impl fmt::String for clean::PathParameters {\n     }\n }\n \n-impl fmt::String for clean::PathSegment {\n+impl fmt::Display for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.name.as_slice()));\n         write!(f, \"{}\", self.params)\n     }\n }\n \n-impl fmt::String for clean::Path {\n+impl fmt::Display for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n             try!(f.write_str(\"::\"))\n@@ -358,7 +358,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         // This is a documented path, link to it!\n         Some((ref fqp, shortty)) if abs_root.is_some() => {\n             let mut url = String::from_str(abs_root.unwrap().as_slice());\n-            let to_link = &fqp[..(fqp.len() - 1)];\n+            let to_link = &fqp[..fqp.len() - 1];\n             for component in to_link.iter() {\n                 url.push_str(component.as_slice());\n                 url.push_str(\"/\");\n@@ -450,7 +450,7 @@ fn tybounds(w: &mut fmt::Formatter,\n     }\n }\n \n-impl fmt::String for clean::Type {\n+impl fmt::Display for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::TyParamBinder(id) => {\n@@ -539,7 +539,7 @@ impl fmt::String for clean::Type {\n     }\n }\n \n-impl fmt::String for clean::Arguments {\n+impl fmt::Display for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n             if i > 0 { try!(write!(f, \", \")); }\n@@ -552,7 +552,7 @@ impl fmt::String for clean::Arguments {\n     }\n }\n \n-impl fmt::String for clean::FunctionRetTy {\n+impl fmt::Display for clean::FunctionRetTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::Return(clean::Tuple(ref tys)) if tys.is_empty() => Ok(()),\n@@ -563,13 +563,13 @@ impl fmt::String for clean::FunctionRetTy {\n     }\n }\n \n-impl fmt::String for clean::FnDecl {\n+impl fmt::Display for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n     }\n }\n \n-impl<'a> fmt::String for Method<'a> {\n+impl<'a> fmt::Display for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n         let mut args = String::new();\n@@ -599,7 +599,7 @@ impl<'a> fmt::String for Method<'a> {\n     }\n }\n \n-impl fmt::String for VisSpace {\n+impl fmt::Display for VisSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             Some(ast::Public) => write!(f, \"pub \"),\n@@ -608,7 +608,7 @@ impl fmt::String for VisSpace {\n     }\n }\n \n-impl fmt::String for UnsafetySpace {\n+impl fmt::Display for UnsafetySpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n             ast::Unsafety::Unsafe => write!(f, \"unsafe \"),\n@@ -617,7 +617,7 @@ impl fmt::String for UnsafetySpace {\n     }\n }\n \n-impl fmt::String for clean::ViewPath {\n+impl fmt::Display for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             clean::SimpleImport(ref name, ref src) => {\n@@ -644,7 +644,7 @@ impl fmt::String for clean::ViewPath {\n     }\n }\n \n-impl fmt::String for clean::ImportSource {\n+impl fmt::Display for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n             Some(did) => resolved_path(f, did, &self.path, true),\n@@ -661,7 +661,7 @@ impl fmt::String for clean::ImportSource {\n     }\n }\n \n-impl fmt::String for clean::ViewListIdent {\n+impl fmt::Display for clean::ViewListIdent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.source {\n             Some(did) => {\n@@ -683,13 +683,13 @@ impl fmt::String for clean::ViewListIdent {\n     }\n }\n \n-impl fmt::String for clean::TypeBinding {\n+impl fmt::Display for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}={}\", self.name, self.ty)\n     }\n }\n \n-impl fmt::String for MutableSpace {\n+impl fmt::Display for MutableSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             MutableSpace(clean::Immutable) => Ok(()),\n@@ -698,7 +698,7 @@ impl fmt::String for MutableSpace {\n     }\n }\n \n-impl fmt::String for RawMutableSpace {\n+impl fmt::Display for RawMutableSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             RawMutableSpace(clean::Immutable) => write!(f, \"const \"),\n@@ -707,7 +707,7 @@ impl fmt::String for RawMutableSpace {\n     }\n }\n \n-impl<'a> fmt::String for Stability<'a> {\n+impl<'a> fmt::Display for Stability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Stability(stab) = *self;\n         match *stab {\n@@ -721,7 +721,7 @@ impl<'a> fmt::String for Stability<'a> {\n     }\n }\n \n-impl<'a> fmt::String for ConciseStability<'a> {\n+impl<'a> fmt::Display for ConciseStability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let ConciseStability(stab) = *self;\n         match *stab {\n@@ -738,7 +738,7 @@ impl<'a> fmt::String for ConciseStability<'a> {\n     }\n }\n \n-impl fmt::String for ModuleSummary {\n+impl fmt::Display for ModuleSummary {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fn fmt_inner<'a>(f: &mut fmt::Formatter,\n                          context: &mut Vec<&'a str>,"}, {"sha": "356be2ffeb04cf4bebaa3dc22425d8d0a282f509", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,29 +22,31 @@ use clean;\n #[derive(Copy, PartialEq, Clone)]\n pub enum ItemType {\n     Module          = 0,\n-    Struct          = 1,\n-    Enum            = 2,\n-    Function        = 3,\n-    Typedef         = 4,\n-    Static          = 5,\n-    Trait           = 6,\n-    Impl            = 7,\n-    ViewItem        = 8,\n-    TyMethod        = 9,\n-    Method          = 10,\n-    StructField     = 11,\n-    Variant         = 12,\n-    // we used to have ForeignFunction and ForeignStatic. they are retired now.\n-    Macro           = 15,\n-    Primitive       = 16,\n-    AssociatedType  = 17,\n-    Constant        = 18,\n+    ExternCrate     = 1,\n+    Import          = 2,\n+    Struct          = 3,\n+    Enum            = 4,\n+    Function        = 5,\n+    Typedef         = 6,\n+    Static          = 7,\n+    Trait           = 8,\n+    Impl            = 9,\n+    TyMethod        = 10,\n+    Method          = 11,\n+    StructField     = 12,\n+    Variant         = 13,\n+    Macro           = 14,\n+    Primitive       = 15,\n+    AssociatedType  = 16,\n+    Constant        = 17,\n }\n \n impl ItemType {\n     pub fn from_item(item: &clean::Item) -> ItemType {\n         match item.inner {\n             clean::ModuleItem(..)          => ItemType::Module,\n+            clean::ExternCrateItem(..)     => ItemType::ExternCrate,\n+            clean::ImportItem(..)          => ItemType::Import,\n             clean::StructItem(..)          => ItemType::Struct,\n             clean::EnumItem(..)            => ItemType::Enum,\n             clean::FunctionItem(..)        => ItemType::Function,\n@@ -53,7 +55,6 @@ impl ItemType {\n             clean::ConstantItem(..)        => ItemType::Constant,\n             clean::TraitItem(..)           => ItemType::Trait,\n             clean::ImplItem(..)            => ItemType::Impl,\n-            clean::ViewItemItem(..)        => ItemType::ViewItem,\n             clean::TyMethodItem(..)        => ItemType::TyMethod,\n             clean::MethodItem(..)          => ItemType::Method,\n             clean::StructFieldItem(..)     => ItemType::StructField,\n@@ -83,14 +84,15 @@ impl ItemType {\n     pub fn to_static_str(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\",\n+            ItemType::ExternCrate     => \"externcrate\",\n+            ItemType::Import          => \"import\",\n             ItemType::Struct          => \"struct\",\n             ItemType::Enum            => \"enum\",\n             ItemType::Function        => \"fn\",\n             ItemType::Typedef         => \"type\",\n             ItemType::Static          => \"static\",\n             ItemType::Trait           => \"trait\",\n             ItemType::Impl            => \"impl\",\n-            ItemType::ViewItem        => \"viewitem\",\n             ItemType::TyMethod        => \"tymethod\",\n             ItemType::Method          => \"method\",\n             ItemType::StructField     => \"structfield\",\n@@ -103,7 +105,7 @@ impl ItemType {\n     }\n }\n \n-impl fmt::String for ItemType {\n+impl fmt::Display for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.to_static_str().fmt(f)\n     }"}, {"sha": "e3bd2b4e27f0074576fdc922561ddea25fa212e4", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -30,7 +30,7 @@ pub struct Page<'a> {\n     pub keywords: &'a str\n }\n \n-pub fn render<T: fmt::String, S: fmt::String>(\n+pub fn render<T: fmt::Display, S: fmt::Display>(\n     dst: &mut io::Writer, layout: &Layout, page: &Page, sidebar: &S, t: &T)\n     -> io::IoResult<()>\n {"}, {"sha": "6f19519ee7cb24171d6250fc66ba78e54ed31b04", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -146,7 +146,7 @@ extern {\n fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n     let trimmed = s.trim();\n     if trimmed.starts_with(\"# \") {\n-        Some(trimmed.slice_from(2))\n+        Some(&trimmed[2..])\n     } else {\n         None\n     }\n@@ -426,7 +426,7 @@ pub fn reset_headers() {\n     USED_HEADER_MAP.with(|s| s.borrow_mut().clear());\n }\n \n-impl<'a> fmt::String for Markdown<'a> {\n+impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n         // This is actually common enough to special-case\n@@ -435,7 +435,7 @@ impl<'a> fmt::String for Markdown<'a> {\n     }\n }\n \n-impl<'a> fmt::String for MarkdownWithToc<'a> {\n+impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;\n         render(fmt, md.as_slice(), true)"}, {"sha": "cd2ed5f0a974b12b0013c55a220e4b61163c39c4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 52, "deletions": 64, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -35,7 +35,7 @@\n pub use self::ExternalLocation::*;\n \n use std::cell::RefCell;\n-use std::cmp::Ordering::{self, Less, Greater, Equal};\n+use std::cmp::Ordering;\n use std::collections::{HashMap, HashSet};\n use std::default::Default;\n use std::fmt;\n@@ -404,7 +404,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n                     search_index.push(IndexItem {\n                         ty: shortty(item),\n                         name: item.name.clone().unwrap(),\n-                        path: fqp[..(fqp.len() - 1)].connect(\"::\"),\n+                        path: fqp[..fqp.len() - 1].connect(\"::\"),\n                         desc: shorter(item.doc_value()).to_string(),\n                         parent: Some(did),\n                     });\n@@ -559,7 +559,7 @@ fn write_shared(cx: &Context,\n         };\n \n         let mut mydst = dst.clone();\n-        for part in remote_path[..(remote_path.len() - 1)].iter() {\n+        for part in remote_path[..remote_path.len() - 1].iter() {\n             mydst.push(part.as_slice());\n             try!(mkdir(&mydst));\n         }\n@@ -749,7 +749,7 @@ impl<'a> SourceCollector<'a> {\n \n         // Remove the utf-8 BOM if any\n         let contents = if contents.starts_with(\"\\u{feff}\") {\n-            contents.slice_from(3)\n+            &contents[3..]\n         } else {\n             contents\n         };\n@@ -842,7 +842,7 @@ impl DocFolder for Cache {\n                 clean::StructFieldItem(..) |\n                 clean::VariantItem(..) => {\n                     ((Some(*self.parent_stack.last().unwrap()),\n-                      Some(&self.stack[..(self.stack.len() - 1)])),\n+                      Some(&self.stack[..self.stack.len() - 1])),\n                      false)\n                 }\n                 clean::MethodItem(..) => {\n@@ -853,13 +853,13 @@ impl DocFolder for Cache {\n                         let did = *last;\n                         let path = match self.paths.get(&did) {\n                             Some(&(_, ItemType::Trait)) =>\n-                                Some(&self.stack[..(self.stack.len() - 1)]),\n+                                Some(&self.stack[..self.stack.len() - 1]),\n                             // The current stack not necessarily has correlation for\n                             // where the type was defined. On the other hand,\n                             // `paths` always has the right information if present.\n                             Some(&(ref fqp, ItemType::Struct)) |\n                             Some(&(ref fqp, ItemType::Enum)) =>\n-                                Some(&fqp[..(fqp.len() - 1)]),\n+                                Some(&fqp[..fqp.len() - 1]),\n                             Some(..) => Some(self.stack.as_slice()),\n                             None => None\n                         };\n@@ -1185,7 +1185,7 @@ impl Context {\n                                            .collect::<String>();\n                 match cache().paths.get(&it.def_id) {\n                     Some(&(ref names, _)) => {\n-                        for name in (&names[..(names.len() - 1)]).iter() {\n+                        for name in (&names[..names.len() - 1]).iter() {\n                             url.push_str(name.as_slice());\n                             url.push_str(\"/\");\n                         }\n@@ -1351,7 +1351,7 @@ impl<'a> Item<'a> {\n }\n \n \n-impl<'a> fmt::String for Item<'a> {\n+impl<'a> fmt::Display for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n         try!(write!(fmt, \"\\n<h1 class='fqn'><span class='in-band'>\"));\n@@ -1469,7 +1469,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     match s {\n         Some(s) => match s.find_str(\"\\n\\n\") {\n-            Some(pos) => s.slice_to(pos),\n+            Some(pos) => &s[..pos],\n             None => s,\n         },\n         None => \"\"\n@@ -1497,18 +1497,19 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     // the order of item types in the listing\n     fn reorder(ty: ItemType) -> u8 {\n         match ty {\n-            ItemType::ViewItem        => 0,\n-            ItemType::Primitive       => 1,\n-            ItemType::Module          => 2,\n-            ItemType::Macro           => 3,\n-            ItemType::Struct          => 4,\n-            ItemType::Enum            => 5,\n-            ItemType::Constant        => 6,\n-            ItemType::Static          => 7,\n-            ItemType::Trait           => 8,\n-            ItemType::Function        => 9,\n-            ItemType::Typedef         => 10,\n-            _                         => 11 + ty as u8,\n+            ItemType::ExternCrate     => 0,\n+            ItemType::Import          => 1,\n+            ItemType::Primitive       => 2,\n+            ItemType::Module          => 3,\n+            ItemType::Macro           => 4,\n+            ItemType::Struct          => 5,\n+            ItemType::Enum            => 6,\n+            ItemType::Constant        => 7,\n+            ItemType::Static          => 8,\n+            ItemType::Trait           => 9,\n+            ItemType::Function        => 10,\n+            ItemType::Typedef         => 12,\n+            _                         => 13 + ty as u8,\n         }\n     }\n \n@@ -1518,25 +1519,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         if ty1 == ty2 {\n             return i1.name.cmp(&i2.name);\n         }\n-\n-        let tycmp = reorder(ty1).cmp(&reorder(ty2));\n-        if let Equal = tycmp {\n-            // for reexports, `extern crate` takes precedence.\n-            match (&i1.inner, &i2.inner) {\n-                (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n-                    match (&a.inner, &b.inner) {\n-                        (&clean::ExternCrate(..), _) => return Less,\n-                        (_, &clean::ExternCrate(..)) => return Greater,\n-                        _ => {}\n-                    }\n-                }\n-                (_, _) => {}\n-            }\n-\n-            idx1.cmp(&idx2)\n-        } else {\n-            tycmp\n-        }\n+        (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n     }\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n@@ -1547,12 +1530,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         let myitem = &items[idx];\n \n         let myty = Some(shortty(myitem));\n-        if myty != curty {\n+        if curty == Some(ItemType::ExternCrate) && myty == Some(ItemType::Import) {\n+            // Put `extern crate` and `use` re-exports in the same section.\n+            curty = myty;\n+        } else if myty != curty {\n             if curty.is_some() {\n                 try!(write!(w, \"</table>\"));\n             }\n             curty = myty;\n             let (short, name) = match myty.unwrap() {\n+                ItemType::ExternCrate |\n+                ItemType::Import          => (\"reexports\", \"Reexports\"),\n                 ItemType::Module          => (\"modules\", \"Modules\"),\n                 ItemType::Struct          => (\"structs\", \"Structs\"),\n                 ItemType::Enum            => (\"enums\", \"Enums\"),\n@@ -1562,7 +1550,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 ItemType::Constant        => (\"constants\", \"Constants\"),\n                 ItemType::Trait           => (\"traits\", \"Traits\"),\n                 ItemType::Impl            => (\"impls\", \"Implementations\"),\n-                ItemType::ViewItem        => (\"reexports\", \"Reexports\"),\n                 ItemType::TyMethod        => (\"tymethods\", \"Type Methods\"),\n                 ItemType::Method          => (\"methods\", \"Methods\"),\n                 ItemType::StructField     => (\"fields\", \"Struct Fields\"),\n@@ -1578,28 +1565,25 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         }\n \n         match myitem.inner {\n-            clean::ViewItemItem(ref item) => {\n-                match item.inner {\n-                    clean::ExternCrate(ref name, ref src, _) => {\n-                        match *src {\n-                            Some(ref src) =>\n-                                try!(write!(w, \"<tr><td><code>extern crate \\\"{}\\\" as {}\",\n-                                            src.as_slice(),\n-                                            name.as_slice())),\n-                            None =>\n-                                try!(write!(w, \"<tr><td><code>extern crate {}\",\n-                                            name.as_slice())),\n-                        }\n-                        try!(write!(w, \";</code></td></tr>\"));\n+            clean::ExternCrateItem(ref name, ref src) => {\n+                match *src {\n+                    Some(ref src) => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate \\\"{}\\\" as {};\",\n+                                    VisSpace(myitem.visibility),\n+                                    src.as_slice(),\n+                                    name.as_slice()))\n                     }\n-\n-                    clean::Import(ref import) => {\n-                        try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                                      VisSpace(myitem.visibility),\n-                                      *import));\n+                    None => {\n+                        try!(write!(w, \"<tr><td><code>{}extern crate {};\",\n+                                    VisSpace(myitem.visibility), name.as_slice()))\n                     }\n                 }\n+                try!(write!(w, \"</code></td></tr>\"));\n+            }\n \n+            clean::ImportItem(ref import) => {\n+                try!(write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                            VisSpace(myitem.visibility), *import));\n             }\n \n             _ => {\n@@ -1626,7 +1610,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n struct Initializer<'a>(&'a str);\n \n-impl<'a> fmt::String for Initializer<'a> {\n+impl<'a> fmt::Display for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n         if s.len() == 0 { return Ok(()); }\n@@ -2085,6 +2069,10 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl) -> fmt::Result {\n     try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n                 ConciseStability(&i.stability),\n                 i.impl_.generics));\n+    match i.impl_.polarity {\n+        Some(clean::ImplPolarity::Negative) => try!(write!(w, \"!\")),\n+        _ => {}\n+    }\n     match i.impl_.trait_ {\n         Some(ref ty) => try!(write!(w, \"{} for \", *ty)),\n         None => {}\n@@ -2188,7 +2176,7 @@ fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n     document(w, it)\n }\n \n-impl<'a> fmt::String for Sidebar<'a> {\n+impl<'a> fmt::Display for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n         let it = self.item;\n@@ -2243,7 +2231,7 @@ impl<'a> fmt::String for Sidebar<'a> {\n     }\n }\n \n-impl<'a> fmt::String for Source<'a> {\n+impl<'a> fmt::Display for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;\n         let lines = s.lines().count();"}, {"sha": "0914f93efd802b406a0f72cac14f4a174150d60b", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -245,7 +245,6 @@ nav.sub {\n .content .highlighted.method { background-color: #c6afb3; }\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #c6afb3; }\n-.content .highlighted.ffi { background-color: #c6afb3; }\n \n .docblock.short.nowrap {\n     display: block;\n@@ -365,7 +364,6 @@ p a:hover { text-decoration: underline; }\n .content span.fn, .content a.fn, .block a.current.fn { color: #8c6067; }\n .content span.method, .content a.method, .block a.current.method { color: #8c6067; }\n .content span.tymethod, .content a.tymethod, .block a.current.tymethod { color: #8c6067; }\n-.content span.ffi, .content a.ffi, .block a.current.ffi { color: #8c6067; }\n .content .fnname { color: #8c6067; }\n \n .search-input {"}, {"sha": "1b0c3b006409952eebf2ce0559d20ea8d77eb14d", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -555,20 +555,19 @@\n         // This mapping table should match the discriminants of\n         // `rustdoc::html::item_type::ItemType` type in Rust.\n         var itemTypes = [\"mod\",\n+                         \"externcrate\",\n+                         \"import\",\n                          \"struct\",\n                          \"enum\",\n                          \"fn\",\n                          \"type\",\n                          \"static\",\n                          \"trait\",\n                          \"impl\",\n-                         \"viewitem\",\n                          \"tymethod\",\n                          \"method\",\n                          \"structfield\",\n                          \"variant\",\n-                         \"ffi\", // retained for backward compatibility\n-                         \"ffs\", // retained for backward compatibility\n                          \"macro\",\n                          \"primitive\",\n                          \"associatedtype\","}, {"sha": "aca6e5bb10ed106c4dc202e2f047be78a83e5541", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -176,13 +176,13 @@ impl TocBuilder {\n     }\n }\n \n-impl fmt::Show for Toc {\n+impl fmt::Debug for Toc {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n-impl fmt::String for Toc {\n+impl fmt::Display for Toc {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(fmt, \"<ul>\"));\n         for entry in self.entries.iter() {"}, {"sha": "849a231fff22f0875b9bbf22615addbc4a6aa019", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -111,7 +111,7 @@ pub fn main() {\n     let res = std::thread::Builder::new().stack_size(STACK_SIZE).scoped(move || {\n         main_args(std::os::args().as_slice())\n     }).join();\n-    std::os::set_exit_status(res.map_err(|_| ()).unwrap());\n+    std::os::set_exit_status(res.ok().unwrap());\n }\n \n pub fn opts() -> Vec<getopts::OptGroup> {\n@@ -351,8 +351,10 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     info!(\"starting to run rustc\");\n \n     let (mut krate, analysis) = std::thread::Thread::scoped(move |:| {\n+        use rustc::session::config::Input;\n+\n         let cr = cr;\n-        core::run_core(paths, cfgs, externs, &cr, triple)\n+        core::run_core(paths, cfgs, externs, Input::File(cr), triple)\n     }).join().map_err(|_| \"rustc failed\").unwrap();\n     info!(\"finished with rustc\");\n     let mut analysis = Some(analysis);"}, {"sha": "594cf3dcd43992d0a6dfeefd17a46fe9f0d11b80", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -28,10 +28,10 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n     for line in s.lines() {\n         if line.starts_with(\"%\") {\n             // remove %<whitespace>\n-            metadata.push(line.slice_from(1).trim_left())\n+            metadata.push(line[1..].trim_left())\n         } else {\n             let line_start_byte = s.subslice_offset(line);\n-            return (metadata, s.slice_from(line_start_byte));\n+            return (metadata, &s[line_start_byte..]);\n         }\n     }\n     // if we're here, then all lines were metadata % lines."}, {"sha": "30b2ad810f1db1ca67ef525cdb65de4437e76b5e", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -149,7 +149,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n                 }\n             }\n \n-            clean::ViewItemItem(..) => {\n+            clean::ExternCrateItem(..) | clean::ImportItem(_) => {\n                 if i.visibility != Some(ast::Public) {\n                     return None\n                 }\n@@ -357,7 +357,7 @@ pub fn unindent(s: &str) -> String {\n                 line.to_string()\n             } else {\n                 assert!(line.len() >= min_indent);\n-                line.slice_from(min_indent).to_string()\n+                line[min_indent..].to_string()\n             }\n         }).collect::<Vec<_>>().as_slice());\n         unindented.connect(\"\\n\")"}, {"sha": "943bc6ec9963445f76f23b0eccfea369d1e68852", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,7 +21,7 @@ use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, TraitMethod, ProvidedMethod, RequiredMethod};\n-use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem, Stability};\n+use clean::{TypeTraitItem, ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n \n use html::render::cache;\n \n@@ -199,7 +199,8 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             }))\n         }\n         // no stability information for the following items:\n-        ViewItemItem(_) | PrimitiveItem(_) => (Counts::zero(), None),\n+        ExternCrateItem(..) | ImportItem(_) |\n+        PrimitiveItem(_) => (Counts::zero(), None),\n         _ => (item_counts, None)\n     }\n }"}, {"sha": "7f1bd9e6d59657ed075659b79b1e868653e4db24", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -79,7 +79,7 @@ pub fn run(input: &str,\n     let ctx = core::DocContext {\n         krate: &krate,\n         maybe_typed: core::NotTyped(sess),\n-        src: input_path,\n+        input: input,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         external_traits: RefCell::new(None),\n         external_typarams: RefCell::new(None),"}, {"sha": "848205f589eda229e137e96d21ab2ade0edeafbc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 62, "deletions": 57, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -20,7 +20,6 @@ use syntax::ast_map;\n use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n \n use rustc::middle::stability;\n \n@@ -142,9 +141,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                               m: &ast::Mod,\n                               name: Option<ast::Ident>) -> Module {\n         let mut om = Module::new(name);\n-        for item in m.view_items.iter() {\n-            self.visit_view_item(item, &mut om);\n-        }\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n@@ -157,68 +153,41 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om\n     }\n \n-    pub fn visit_view_item(&mut self, item: &ast::ViewItem, om: &mut Module) {\n-        if item.vis != ast::Public {\n-            return om.view_items.push(item.clone());\n-        }\n-        let please_inline = item.attrs.iter().any(|item| {\n-            match item.meta_item_list() {\n-                Some(list) => {\n-                    list.iter().any(|i| i.name().get() == \"inline\")\n-                }\n-                None => false,\n-            }\n-        });\n-        let item = match item.node {\n-            ast::ViewItemUse(ref vpath) => {\n-                match self.visit_view_path(&**vpath, om, please_inline) {\n-                    None => return,\n-                    Some(path) => {\n-                        ast::ViewItem {\n-                            node: ast::ViewItemUse(path),\n-                            .. item.clone()\n-                        }\n-                    }\n-                }\n-            }\n-            ast::ViewItemExternCrate(..) => item.clone()\n-        };\n-        om.view_items.push(item);\n-    }\n-\n-    fn visit_view_path(&mut self, path: &ast::ViewPath,\n+    fn visit_view_path(&mut self, path: ast::ViewPath_,\n                        om: &mut Module,\n-                       please_inline: bool) -> Option<P<ast::ViewPath>> {\n-        match path.node {\n-            ast::ViewPathSimple(dst, _, id) => {\n+                       id: ast::NodeId,\n+                       please_inline: bool) -> Option<ast::ViewPath_> {\n+        match path {\n+            ast::ViewPathSimple(dst, base) => {\n                 if self.resolve_id(id, Some(dst), false, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathSimple(dst, base))\n                 }\n             }\n-            ast::ViewPathList(ref p, ref paths, ref b) => {\n-                let mut mine = Vec::new();\n-                for path in paths.iter() {\n-                    if !self.resolve_id(path.node.id(), None, false, om,\n-                                        please_inline) {\n-                        mine.push(path.clone());\n-                    }\n-                }\n+            ast::ViewPathList(p, paths) => {\n+                let mine = paths.into_iter().filter(|path| {\n+                    !self.resolve_id(path.node.id(), None, false, om,\n+                                     please_inline)\n+                }).collect::<Vec<ast::PathListItem>>();\n \n-                if mine.len() == 0 { return None }\n-                return Some(P(::syntax::codemap::Spanned {\n-                    node: ast::ViewPathList(p.clone(), mine, b.clone()),\n-                    span: path.span,\n-                }))\n+                if mine.len() == 0 {\n+                    None\n+                } else {\n+                    Some(ast::ViewPathList(p, mine))\n+                }\n             }\n \n             // these are feature gated anyway\n-            ast::ViewPathGlob(_, id) => {\n+            ast::ViewPathGlob(base) => {\n                 if self.resolve_id(id, None, true, om, please_inline) {\n-                    return None\n+                    None\n+                } else {\n+                    Some(ast::ViewPathGlob(base))\n                 }\n             }\n         }\n-        Some(P(path.clone()))\n+\n     }\n \n     fn resolve_id(&mut self, id: ast::NodeId, renamed: Option<ast::Ident>,\n@@ -242,9 +211,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 if glob {\n                     match it.node {\n                         ast::ItemMod(ref m) => {\n-                            for vi in m.view_items.iter() {\n-                                self.visit_view_item(vi, om);\n-                            }\n                             for i in m.items.iter() {\n                                 self.visit_item(&**i, None, om);\n                             }\n@@ -268,6 +234,45 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident);\n         match item.node {\n+            ast::ItemExternCrate(ref p) => {\n+                let path = match *p {\n+                    None => None,\n+                    Some((ref x, _)) => Some(x.get().to_string()),\n+                };\n+                om.extern_crates.push(ExternCrate {\n+                    name: name,\n+                    path: path,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    whence: item.span,\n+                })\n+            }\n+            ast::ItemUse(ref vpath) => {\n+                let node = vpath.node.clone();\n+                let node = if item.vis == ast::Public {\n+                    let please_inline = item.attrs.iter().any(|item| {\n+                        match item.meta_item_list() {\n+                            Some(list) => {\n+                                list.iter().any(|i| i.name().get() == \"inline\")\n+                            }\n+                            None => false,\n+                        }\n+                    });\n+                    match self.visit_view_path(node, om, item.id, please_inline) {\n+                        None => return,\n+                        Some(p) => p\n+                    }\n+                } else {\n+                    node\n+                };\n+                om.imports.push(Import {\n+                    id: item.id,\n+                    vis: item.vis,\n+                    attrs: item.attrs.clone(),\n+                    node: node,\n+                    whence: item.span,\n+                });\n+            }\n             ast::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),"}, {"sha": "c97d67ba1b9b4229bbe1cf642c8c1efcc1c83aab", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -177,15 +177,15 @@ pub trait FromBase64 {\n }\n \n /// Errors that can occur when decoding a base64 encoded string\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum FromBase64Error {\n     /// The input contained a character not part of the base64 format\n     InvalidBase64Byte(u8, uint),\n     /// The input had an invalid length\n     InvalidBase64Length,\n }\n \n-impl fmt::Show for FromBase64Error {\n+impl fmt::Display for FromBase64Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidBase64Byte(ch, idx) =>\n@@ -202,10 +202,6 @@ impl error::Error for FromBase64Error {\n             InvalidBase64Length => \"invalid length\",\n         }\n     }\n-\n-    fn detail(&self) -> Option<String> {\n-        Some(format!(\"{:?}\", self))\n-    }\n }\n \n impl FromBase64 for str {"}, {"sha": "e477f4418a52ffd8b49fecc66569f01292f440ff", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -61,15 +61,15 @@ pub trait FromHex {\n }\n \n /// Errors that can occur when decoding a hex encoded string\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum FromHexError {\n     /// The input contained a character not part of the hex format\n     InvalidHexCharacter(char, uint),\n     /// The input had an invalid length\n     InvalidHexLength,\n }\n \n-impl fmt::Show for FromHexError {\n+impl fmt::Display for FromHexError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             InvalidHexCharacter(ch, idx) =>\n@@ -86,10 +86,6 @@ impl error::Error for FromHexError {\n             InvalidHexLength => \"invalid length\",\n         }\n     }\n-\n-    fn detail(&self) -> Option<String> {\n-        Some(format!(\"{:?}\", self))\n-    }\n }\n \n "}, {"sha": "5f4ba8ef9fcc743393f4f0ad3077dd19b50c0482", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -235,7 +235,7 @@ pub struct AsJson<'a, T: 'a> { inner: &'a T }\n pub struct AsPrettyJson<'a, T: 'a> { inner: &'a T, indent: Option<uint> }\n \n /// The errors that can arise while parsing a JSON stream.\n-#[derive(Clone, Copy, PartialEq)]\n+#[derive(Clone, Copy, PartialEq, Show)]\n pub enum ErrorCode {\n     InvalidSyntax,\n     InvalidNumber,\n@@ -325,7 +325,7 @@ pub fn encode<T: ::Encodable>(object: &T) -> string::String {\n     s\n }\n \n-impl fmt::Show for ErrorCode {\n+impl fmt::Display for ErrorCode {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         error_str(*self).fmt(f)\n     }\n@@ -335,14 +335,33 @@ fn io_error_to_error(io: io::IoError) -> ParserError {\n     IoError(io.kind, io.desc)\n }\n \n+impl fmt::Display for ParserError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME this should be a nicer error\n+        fmt::Debug::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for DecoderError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME this should be a nicer error\n+        fmt::Debug::fmt(self, f)\n+    }\n+}\n+\n impl std::error::Error for DecoderError {\n     fn description(&self) -> &str { \"decoder error\" }\n-    fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n+}\n+\n+impl fmt::Display for EncoderError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // FIXME this should be a nicer error\n+        fmt::Debug::fmt(self, f)\n+    }\n }\n \n impl std::error::Error for EncoderError {\n     fn description(&self) -> &str { \"encoder error\" }\n-    fn detail(&self) -> Option<std::string::String> { Some(format!(\"{:?}\", self)) }\n }\n \n impl std::error::FromError<fmt::Error> for EncoderError {\n@@ -1298,7 +1317,7 @@ impl Stack {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n                 StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[(start as uint) .. (start as uint + size as uint)])\n+                    &self.str_buffer[start as uint .. start as uint + size as uint])\n                         .unwrap())\n             }\n         }\n@@ -1341,7 +1360,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(StackElement::Key(str::from_utf8(\n-                    &self.str_buffer[(start as uint) .. (start+size) as uint]\n+                    &self.str_buffer[start as uint .. (start+size) as uint]\n                 ).unwrap()))\n             }\n         }\n@@ -2519,7 +2538,7 @@ impl<'a, 'b> fmt::Writer for FormatShim<'a, 'b> {\n     }\n }\n \n-impl fmt::String for Json {\n+impl fmt::Display for Json {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2531,7 +2550,7 @@ impl fmt::String for Json {\n     }\n }\n \n-impl<'a> fmt::String for PrettyJson<'a> {\n+impl<'a> fmt::Display for PrettyJson<'a> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2543,7 +2562,7 @@ impl<'a> fmt::String for PrettyJson<'a> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::String for AsJson<'a, T> {\n+impl<'a, T: Encodable> fmt::Display for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -2563,7 +2582,7 @@ impl<'a, T> AsPrettyJson<'a, T> {\n     }\n }\n \n-impl<'a, T: Encodable> fmt::String for AsPrettyJson<'a, T> {\n+impl<'a, T: Encodable> fmt::Display for AsPrettyJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let mut shim = FormatShim { inner: f };\n@@ -3920,7 +3939,7 @@ mod tests {\n         let mut mem_buf = Vec::new();\n         let mut encoder = Encoder::new(&mut mem_buf as &mut fmt::Writer);\n         let result = hm.encode(&mut encoder);\n-        match result.unwrap_err() {\n+        match result.err().unwrap() {\n             EncoderError::BadHashmapKey => (),\n             _ => panic!(\"expected bad hash map key\")\n         }"}, {"sha": "342d00a23c80116c2408ac1f3c4763e4f6584537", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -18,7 +18,7 @@ use borrow::BorrowFrom;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n-use fmt::{self, Show};\n+use fmt::{self, Debug};\n use hash::{self, Hash, SipHasher};\n use iter::{self, Iterator, ExactSizeIterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n@@ -76,7 +76,7 @@ impl DefaultResizePolicy {\n         // min_capacity(size) must be smaller than the internal capacity,\n         // so that the map is not resized:\n         // `min_capacity(usable_capacity(x)) <= x`.\n-        // The lef-hand side can only be smaller due to flooring by integer\n+        // The left-hand side can only be smaller due to flooring by integer\n         // division.\n         //\n         // This doesn't have to be checked for overflow since allocation size\n@@ -270,7 +270,7 @@ fn test_resize_policy() {\n /// ```\n /// use std::collections::HashMap;\n ///\n-/// #[derive(Hash, Eq, PartialEq, Show)]\n+/// #[derive(Hash, Eq, PartialEq, Debug)]\n /// struct Viking {\n ///     name: String,\n ///     country: String,\n@@ -838,8 +838,8 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// map.insert(\"b\", 2);\n     /// map.insert(\"c\", 3);\n     ///\n-    /// for key in map.values() {\n-    ///     println!(\"{}\", key);\n+    /// for val in map.values() {\n+    ///     println!(\"{}\", val);\n     /// }\n     /// ```\n     #[stable]\n@@ -938,7 +938,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n         search_entry_hashed(&mut self.table, hash, key)\n     }\n \n-    /// Return the number of elements in the map.\n+    /// Returns the number of elements in the map.\n     ///\n     /// # Example\n     ///\n@@ -953,7 +953,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     #[stable]\n     pub fn len(&self) -> uint { self.table.size() }\n \n-    /// Return true if the map contains no elements.\n+    /// Returns true if the map contains no elements.\n     ///\n     /// # Example\n     ///\n@@ -1216,8 +1216,8 @@ impl<K, V, S, H> Eq for HashMap<K, V, S>\n {}\n \n #[stable]\n-impl<K, V, S, H> Show for HashMap<K, V, S>\n-    where K: Eq + Hash<H> + Show, V: Show,\n+impl<K, V, S, H> Debug for HashMap<K, V, S>\n+    where K: Eq + Hash<H> + Debug, V: Debug,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n@@ -1274,7 +1274,7 @@ impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n     }\n }\n \n-/// HashMap iterator\n+/// HashMap iterator.\n #[stable]\n pub struct Iter<'a, K: 'a, V: 'a> {\n     inner: table::Iter<'a, K, V>\n@@ -1289,13 +1289,13 @@ impl<'a, K, V> Clone for Iter<'a, K, V> {\n     }\n }\n \n-/// HashMap mutable values iterator\n+/// HashMap mutable values iterator.\n #[stable]\n pub struct IterMut<'a, K: 'a, V: 'a> {\n     inner: table::IterMut<'a, K, V>\n }\n \n-/// HashMap move iterator\n+/// HashMap move iterator.\n #[stable]\n pub struct IntoIter<K, V> {\n     inner: iter::Map<\n@@ -1306,7 +1306,7 @@ pub struct IntoIter<K, V> {\n     >\n }\n \n-/// HashMap keys iterator\n+/// HashMap keys iterator.\n #[stable]\n pub struct Keys<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a K, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a K>\n@@ -1321,7 +1321,7 @@ impl<'a, K, V> Clone for Keys<'a, K, V> {\n     }\n }\n \n-/// HashMap values iterator\n+/// HashMap values iterator.\n #[stable]\n pub struct Values<'a, K: 'a, V: 'a> {\n     inner: Map<(&'a K, &'a V), &'a V, Iter<'a, K, V>, fn((&'a K, &'a V)) -> &'a V>\n@@ -1336,7 +1336,7 @@ impl<'a, K, V> Clone for Values<'a, K, V> {\n     }\n }\n \n-/// HashMap drain iterator\n+/// HashMap drain iterator.\n #[unstable = \"matches collection reform specification, waiting for dust to settle\"]\n pub struct Drain<'a, K: 'a, V: 'a> {\n     inner: iter::Map<\n@@ -1347,35 +1347,35 @@ pub struct Drain<'a, K: 'a, V: 'a> {\n     >\n }\n \n-/// A view into a single occupied location in a HashMap\n+/// A view into a single occupied location in a HashMap.\n #[unstable = \"precise API still being fleshed out\"]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n-/// A view into a single empty location in a HashMap\n+/// A view into a single empty location in a HashMap.\n #[unstable = \"precise API still being fleshed out\"]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n     key: K,\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n-/// A view into a single location in a map, which may be vacant or occupied\n+/// A view into a single location in a map, which may be vacant or occupied.\n #[unstable = \"precise API still being fleshed out\"]\n pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// An occupied Entry\n+    /// An occupied Entry.\n     Occupied(OccupiedEntry<'a, K, V>),\n-    /// A vacant Entry\n+    /// A vacant Entry.\n     Vacant(VacantEntry<'a, K, V>),\n }\n \n-/// Possible states of a VacantEntry\n+/// Possible states of a VacantEntry.\n enum VacantEntryState<K, V, M> {\n     /// The index is occupied, but the key to insert has precedence,\n-    /// and will kick the current one out on insertion\n+    /// and will kick the current one out on insertion.\n     NeqElem(FullBucket<K, V, M>, uint),\n-    /// The index is genuinely vacant\n+    /// The index is genuinely vacant.\n     NoElem(EmptyBucket<K, V, M>),\n }\n \n@@ -1453,7 +1453,7 @@ impl<'a, K, V> ExactSizeIterator for Drain<'a, K, V> {\n \n #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K, V> Entry<'a, K, V> {\n-    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant\n+    /// Returns a mutable reference to the entry if occupied, or the VacantEntry if vacant.\n     pub fn get(self) -> Result<&'a mut V, VacantEntry<'a, K, V>> {\n         match self {\n             Occupied(entry) => Ok(entry.into_mut()),\n@@ -1464,12 +1464,12 @@ impl<'a, K, V> Entry<'a, K, V> {\n \n #[unstable = \"matches collection reform v2 specification, waiting for dust to settle\"]\n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the value in the entry\n+    /// Gets a reference to the value in the entry.\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n-    /// Gets a mutable reference to the value in the entry\n+    /// Gets a mutable reference to the value in the entry.\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n@@ -1996,8 +1996,8 @@ mod test_map {\n \n         let map_str = format!(\"{:?}\", map);\n \n-        assert!(map_str == \"HashMap {1i: 2i, 3i: 4i}\" ||\n-                map_str == \"HashMap {3i: 4i, 1i: 2i}\");\n+        assert!(map_str == \"HashMap {1: 2, 3: 4}\" ||\n+                map_str == \"HashMap {3: 4, 1: 2}\");\n         assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n     }\n "}, {"sha": "29e247d96d2399982ce2bad0c294158e9452595a", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -15,7 +15,7 @@ use clone::Clone;\n use cmp::{Eq, PartialEq};\n use core::marker::Sized;\n use default::Default;\n-use fmt::Show;\n+use fmt::Debug;\n use fmt;\n use hash::{self, Hash};\n use iter::{Iterator, ExactSizeIterator, IteratorExt, FromIterator, Map, Chain, Extend};\n@@ -71,7 +71,7 @@ use super::state::HashState;\n ///\n /// ```\n /// use std::collections::HashSet;\n-/// #[derive(Hash, Eq, PartialEq, Show)]\n+/// #[derive(Hash, Eq, PartialEq, Debug)]\n /// struct Viking<'a> {\n ///     name: &'a str,\n ///     power: uint,\n@@ -596,8 +596,8 @@ impl<T, S, H> Eq for HashSet<T, S>\n {}\n \n #[stable]\n-impl<T, S, H> fmt::Show for HashSet<T, S>\n-    where T: Eq + Hash<H> + fmt::Show,\n+impl<T, S, H> fmt::Debug for HashSet<T, S>\n+    where T: Eq + Hash<H> + fmt::Debug,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n@@ -1179,7 +1179,7 @@ mod test_set {\n \n         let set_str = format!(\"{:?}\", set);\n \n-        assert!(set_str == \"HashSet {1i, 2i}\" || set_str == \"HashSet {2i, 1i}\");\n+        assert!(set_str == \"HashSet {1, 2}\" || set_str == \"HashSet {2, 1}\");\n         assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n     }\n "}, {"sha": "7d0e42e8e49e82278ccd0e5a07d282bae57d9d79", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -115,11 +115,12 @@ impl Deref for CString {\n     type Target = [libc::c_char];\n \n     fn deref(&self) -> &[libc::c_char] {\n-        self.inner.slice_to(self.inner.len() - 1)\n+        &self.inner[..(self.inner.len() - 1)]\n     }\n }\n \n-impl fmt::Show for CString {\n+#[stable]\n+impl fmt::Debug for CString {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         String::from_utf8_lossy(self.as_bytes()).fmt(f)\n     }\n@@ -215,4 +216,10 @@ mod tests {\n             assert_eq!(s.as_bytes(), b\"\\0\");\n         }\n     }\n+\n+    #[test]\n+    fn formatted() {\n+        let s = CString::from_slice(b\"12\");\n+        assert_eq!(format!(\"{:?}\", s), \"\\\"12\\\"\");\n+    }\n }"}, {"sha": "f3b159cf819c9358508cc76ae39d3e36b9e23267", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -123,8 +123,8 @@\n //! This allows multiple actual types to be formatted via `{:x}` (like `i8` as\n //! well as `int`).  The current mapping of types to traits is:\n //!\n-//! * *nothing* \u21d2 `String`\n-//! * `?` \u21d2 `Show`\n+//! * *nothing* \u21d2 `Display`\n+//! * `?` \u21d2 `Debug`\n //! * `o` \u21d2 `Octal`\n //! * `x` \u21d2 `LowerHex`\n //! * `X` \u21d2 `UpperHex`\n@@ -137,15 +137,15 @@\n //! `std::fmt::Binary` trait can then be formatted with `{:b}`. Implementations\n //! are provided for these traits for a number of primitive types by the\n //! standard library as well. If no format is specified (as in `{}` or `{:6}`),\n-//! then the format trait used is the `String` trait.\n+//! then the format trait used is the `Display` trait.\n //!\n //! When implementing a format trait for your own type, you will have to\n //! implement a method of the signature:\n //!\n //! ```rust\n //! # use std::fmt;\n //! # struct Foo; // our custom type\n-//! # impl fmt::Show for Foo {\n+//! # impl fmt::Display for Foo {\n //! fn fmt(&self, f: &mut std::fmt::Formatter) -> fmt::Result {\n //! # write!(f, \"testing, testing\")\n //! # } }\n@@ -171,13 +171,13 @@\n //! use std::f64;\n //! use std::num::Float;\n //!\n-//! #[derive(Show)]\n+//! #[derive(Debug)]\n //! struct Vector2D {\n //!     x: int,\n //!     y: int,\n //! }\n //!\n-//! impl fmt::String for Vector2D {\n+//! impl fmt::Display for Vector2D {\n //!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n //!         // The `f` value implements the `Writer` trait, which is what the\n //!         // write! macro is expecting. Note that this formatting ignores the\n@@ -211,22 +211,22 @@\n //! }\n //! ```\n //!\n-//! #### fmt::String vs fmt::Show\n+//! #### fmt::Display vs fmt::Debug\n //!\n //! These two formatting traits have distinct purposes:\n //!\n-//! - `fmt::String` implementations assert that the type can be faithfully\n+//! - `fmt::Display` implementations assert that the type can be faithfully\n //!   represented as a UTF-8 string at all times. It is **not** expected that\n-//!   all types implement the `String` trait.\n-//! - `fmt::Show` implementations should be implemented for **all** public types.\n+//!   all types implement the `Display` trait.\n+//! - `fmt::Debug` implementations should be implemented for **all** public types.\n //!   Output will typically represent the internal state as faithfully as possible.\n-//!   The purpose of the `Show` trait is to facilitate debugging Rust code. In\n-//!   most cases, using `#[derive(Show)]` is sufficient and recommended.\n+//!   The purpose of the `Debug` trait is to facilitate debugging Rust code. In\n+//!   most cases, using `#[derive(Debug)]` is sufficient and recommended.\n //!\n //! Some examples of the output from both traits:\n //!\n //! ```\n-//! assert_eq!(format!(\"{} {:?}\", 3i32, 4i32), \"3 4i32\");\n+//! assert_eq!(format!(\"{} {:?}\", 3i32, 4i32), \"3 4\");\n //! assert_eq!(format!(\"{} {:?}\", 'a', 'b'), \"a 'b'\");\n //! assert_eq!(format!(\"{} {:?}\", \"foo\\n\", \"bar\\n\"), \"foo\\n \\\"bar\\\\n\\\"\");\n //! ```\n@@ -409,6 +409,7 @@ use string;\n \n pub use core::fmt::{Formatter, Result, Writer, rt};\n pub use core::fmt::{Show, String, Octal, Binary};\n+pub use core::fmt::{Display, Debug};\n pub use core::fmt::{LowerHex, UpperHex, Pointer};\n pub use core::fmt::{LowerExp, UpperExp};\n pub use core::fmt::Error;"}, {"sha": "73c73209f00fcf3c55f90cc8e888a030f0e6e56c", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -52,7 +52,8 @@ pub struct BufferedReader<R> {\n     cap: uint,\n }\n \n-impl<R> fmt::Show for BufferedReader<R> where R: fmt::Show {\n+#[stable]\n+impl<R> fmt::Debug for BufferedReader<R> where R: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedReader {{ reader: {:?}, buffer: {}/{} }}\",\n                self.inner, self.cap - self.pos, self.buf.len())\n@@ -150,7 +151,8 @@ pub struct BufferedWriter<W> {\n     pos: uint\n }\n \n-impl<W> fmt::Show for BufferedWriter<W> where W: fmt::Show {\n+#[stable]\n+impl<W> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.as_ref().unwrap(), self.pos, self.buf.len())\n@@ -219,7 +221,7 @@ impl<W: Writer> Writer for BufferedWriter<W> {\n         if buf.len() > self.buf.len() {\n             self.inner.as_mut().unwrap().write(buf)\n         } else {\n-            let dst = self.buf.slice_from_mut(self.pos);\n+            let dst = &mut self.buf[self.pos..];\n             slice::bytes::copy_memory(dst, buf);\n             self.pos += buf.len();\n             Ok(())\n@@ -249,7 +251,8 @@ pub struct LineBufferedWriter<W> {\n     inner: BufferedWriter<W>,\n }\n \n-impl<W> fmt::Show for LineBufferedWriter<W> where W: fmt::Show {\n+#[stable]\n+impl<W> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.inner, self.inner.pos, self.inner.buf.len())\n@@ -281,9 +284,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(&buf[..(i + 1)]));\n+                try!(self.inner.write(&buf[..i + 1]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(&buf[(i + 1)..]));\n+                try!(self.inner.write(&buf[i + 1..]));\n                 Ok(())\n             }\n             None => self.inner.write(buf),\n@@ -339,7 +342,8 @@ pub struct BufferedStream<S> {\n     inner: BufferedReader<InternalBufferedWriter<S>>\n }\n \n-impl<S> fmt::Show for BufferedStream<S> where S: fmt::Show {\n+#[stable]\n+impl<S> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;"}, {"sha": "4649012d454b0b99e5f1cbe43b8f4f92c2a5f38a", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -72,7 +72,7 @@ impl Buffer for ChanReader {\n         if self.closed {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n-            Ok(self.buf.slice_from(self.pos))\n+            Ok(&self.buf[self.pos..])\n         }\n     }\n \n@@ -88,7 +88,7 @@ impl Reader for ChanReader {\n         loop {\n             let count = match self.fill_buf().ok() {\n                 Some(src) => {\n-                    let dst = buf.slice_from_mut(num_read);\n+                    let dst = &mut buf[num_read..];\n                     let count = cmp::min(src.len(), dst.len());\n                     bytes::copy_memory(dst, &src[..count]);\n                     count"}, {"sha": "cc36c5640d0a7c224436d24f3e61712201a118bd", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -156,7 +156,7 @@ impl File {\n                 })\n             }\n         }).update_err(\"couldn't open path as file\", |e| {\n-            format!(\"{}; path={:?}; mode={}; access={}\", e, path.display(),\n+            format!(\"{}; path={}; mode={}; access={}\", e, path.display(),\n                 mode_string(mode), access_string(access))\n         })\n     }\n@@ -211,7 +211,7 @@ impl File {\n     pub fn fsync(&mut self) -> IoResult<()> {\n         self.fd.fsync()\n             .update_err(\"couldn't fsync file\",\n-                        |e| format!(\"{}; path={:?}\", e, self.path.display()))\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// This function is similar to `fsync`, except that it may not synchronize\n@@ -221,7 +221,7 @@ impl File {\n     pub fn datasync(&mut self) -> IoResult<()> {\n         self.fd.datasync()\n             .update_err(\"couldn't datasync file\",\n-                        |e| format!(\"{}; path={:?}\", e, self.path.display()))\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     /// Either truncates or extends the underlying file, updating the size of\n@@ -235,7 +235,7 @@ impl File {\n     pub fn truncate(&mut self, size: i64) -> IoResult<()> {\n         self.fd.truncate(size)\n             .update_err(\"couldn't truncate file\", |e|\n-                format!(\"{}; path={:?}; size={:?}\", e, self.path.display(), size))\n+                format!(\"{}; path={}; size={}\", e, self.path.display(), size))\n     }\n \n     /// Returns true if the stream has reached the end of the file.\n@@ -255,7 +255,7 @@ impl File {\n     pub fn stat(&self) -> IoResult<FileStat> {\n         self.fd.fstat()\n             .update_err(\"couldn't fstat file\", |e|\n-                format!(\"{}; path={:?}\", e, self.path.display()))\n+                format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -283,7 +283,7 @@ impl File {\n pub fn unlink(path: &Path) -> IoResult<()> {\n     fs_imp::unlink(path)\n            .update_err(\"couldn't unlink path\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Given a path, query the file system to get information about a file,\n@@ -310,7 +310,7 @@ pub fn unlink(path: &Path) -> IoResult<()> {\n pub fn stat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::stat(path)\n            .update_err(\"couldn't stat path\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Perform the same operation as the `stat` function, except that this\n@@ -324,7 +324,7 @@ pub fn stat(path: &Path) -> IoResult<FileStat> {\n pub fn lstat(path: &Path) -> IoResult<FileStat> {\n     fs_imp::lstat(path)\n            .update_err(\"couldn't lstat path\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Rename a file or directory to a new name.\n@@ -424,14 +424,14 @@ pub fn copy(from: &Path, to: &Path) -> IoResult<()> {\n pub fn chmod(path: &Path, mode: io::FilePermission) -> IoResult<()> {\n     fs_imp::chmod(path, mode.bits() as uint)\n            .update_err(\"couldn't chmod path\", |e|\n-               format!(\"{}; path={:?}; mode={:?}\", e, path.display(), mode))\n+               format!(\"{}; path={}; mode={:?}\", e, path.display(), mode))\n }\n \n /// Change the user and group owners of a file at the specified path.\n pub fn chown(path: &Path, uid: int, gid: int) -> IoResult<()> {\n     fs_imp::chown(path, uid, gid)\n            .update_err(\"couldn't chown path\", |e|\n-               format!(\"{}; path={:?}; uid={}; gid={}\", e, path.display(), uid, gid))\n+               format!(\"{}; path={}; uid={}; gid={}\", e, path.display(), uid, gid))\n }\n \n /// Creates a new hard link on the filesystem. The `dst` path will be a\n@@ -460,7 +460,7 @@ pub fn symlink(src: &Path, dst: &Path) -> IoResult<()> {\n pub fn readlink(path: &Path) -> IoResult<Path> {\n     fs_imp::readlink(path)\n            .update_err(\"couldn't resolve symlink for path\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Create a new, empty directory at the provided path\n@@ -483,7 +483,7 @@ pub fn readlink(path: &Path) -> IoResult<Path> {\n pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n     fs_imp::mkdir(path, mode.bits() as uint)\n            .update_err(\"couldn't create directory\", |e|\n-               format!(\"{}; path={:?}; mode={:?}\", e, path.display(), mode))\n+               format!(\"{}; path={}; mode={}\", e, path.display(), mode))\n }\n \n /// Remove an existing, empty directory\n@@ -505,7 +505,7 @@ pub fn mkdir(path: &Path, mode: FilePermission) -> IoResult<()> {\n pub fn rmdir(path: &Path) -> IoResult<()> {\n     fs_imp::rmdir(path)\n            .update_err(\"couldn't remove directory\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Retrieve a vector containing all entries within a provided directory\n@@ -545,7 +545,7 @@ pub fn rmdir(path: &Path) -> IoResult<()> {\n pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n     fs_imp::readdir(path)\n            .update_err(\"couldn't read directory\",\n-                       |e| format!(\"{}; path={:?}\", e, path.display()))\n+                       |e| format!(\"{}; path={}\", e, path.display()))\n }\n \n /// Returns an iterator that will recursively walk the directory structure\n@@ -555,7 +555,7 @@ pub fn readdir(path: &Path) -> IoResult<Vec<Path>> {\n pub fn walk_dir(path: &Path) -> IoResult<Directories> {\n     Ok(Directories {\n         stack: try!(readdir(path).update_err(\"couldn't walk directory\",\n-                                             |e| format!(\"{}; path={:?}\", e, path.display())))\n+                                             |e| format!(\"{}; path={}\", e, path.display())))\n     })\n }\n \n@@ -605,7 +605,7 @@ pub fn mkdir_recursive(path: &Path, mode: FilePermission) -> IoResult<()> {\n \n         let result = mkdir(&curpath, mode)\n             .update_err(\"couldn't recursively mkdir\",\n-                        |e| format!(\"{}; path={:?}\", e, path.display()));\n+                        |e| format!(\"{}; path={}\", e, path.display()));\n \n         match result {\n             Err(mkdir_err) => {\n@@ -632,7 +632,7 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n     rm_stack.push(path.clone());\n \n     fn rmdir_failed(err: &IoError, path: &Path) -> String {\n-        format!(\"rmdir_recursive failed; path={:?}; cause={}\",\n+        format!(\"rmdir_recursive failed; path={}; cause={}\",\n                 path.display(), err)\n     }\n \n@@ -692,14 +692,14 @@ pub fn rmdir_recursive(path: &Path) -> IoResult<()> {\n pub fn change_file_times(path: &Path, atime: u64, mtime: u64) -> IoResult<()> {\n     fs_imp::utime(path, atime, mtime)\n            .update_err(\"couldn't change_file_times\", |e|\n-               format!(\"{}; path={:?}\", e, path.display()))\n+               format!(\"{}; path={}\", e, path.display()))\n }\n \n impl Reader for File {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         fn update_err<T>(result: IoResult<T>, file: &File) -> IoResult<T> {\n             result.update_err(\"couldn't read file\",\n-                              |e| format!(\"{}; path={:?}\",\n+                              |e| format!(\"{}; path={}\",\n                                           e, file.path.display()))\n         }\n \n@@ -722,15 +722,15 @@ impl Writer for File {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         self.fd.write(buf)\n             .update_err(\"couldn't write to file\",\n-                        |e| format!(\"{}; path={:?}\", e, self.path.display()))\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n impl Seek for File {\n     fn tell(&self) -> IoResult<u64> {\n         self.fd.tell()\n             .update_err(\"couldn't retrieve file cursor (`tell`)\",\n-                        |e| format!(\"{}; path={:?}\", e, self.path.display()))\n+                        |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n@@ -743,7 +743,7 @@ impl Seek for File {\n             Err(e) => Err(e),\n         };\n         err.update_err(\"couldn't seek in file\",\n-                       |e| format!(\"{}; path={:?}\", e, self.path.display()))\n+                       |e| format!(\"{}; path={}\", e, self.path.display()))\n     }\n }\n \n@@ -906,7 +906,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={:?}; mode=open; access=read\", filename.display()));\n+        error!(result, format!(\"path={}; mode=open; access=read\", filename.display()));\n     }\n \n     #[test]\n@@ -920,7 +920,7 @@ mod test {\n         if cfg!(unix) {\n             error!(result, \"no such file or directory\");\n         }\n-        error!(result, format!(\"path={:?}\", filename.display()));\n+        error!(result, format!(\"path={}\", filename.display()));\n     }\n \n     #[test]\n@@ -1188,7 +1188,7 @@ mod test {\n         error!(result, \"couldn't recursively mkdir\");\n         error!(result, \"couldn't create directory\");\n         error!(result, \"mode=0700\");\n-        error!(result, format!(\"path={:?}\", file.display()));\n+        error!(result, format!(\"path={}\", file.display()));\n     }\n \n     #[test]"}, {"sha": "ec4191297ceab8b181217b4fd54a4ad7c00810fd", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -159,8 +159,8 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = &self.buf[self.pos.. (self.pos + write_len)];\n-            let output = buf.slice_to_mut(write_len);\n+            let input = &self.buf[self.pos.. self.pos + write_len];\n+            let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -205,11 +205,11 @@ impl<'a> Reader for &'a [u8] {\n         let write_len = min(buf.len(), self.len());\n         {\n             let input = &self[..write_len];\n-            let output = buf.slice_to_mut(write_len);\n+            let output = &mut buf[.. write_len];\n             slice::bytes::copy_memory(output, input);\n         }\n \n-        *self = self.slice_from(write_len);\n+        *self = &self[write_len..];\n \n         Ok(write_len)\n     }\n@@ -270,7 +270,7 @@ impl<'a> BufWriter<'a> {\n impl<'a> Writer for BufWriter<'a> {\n     #[inline]\n     fn write(&mut self, src: &[u8]) -> IoResult<()> {\n-        let dst = self.buf.slice_from_mut(self.pos);\n+        let dst = &mut self.buf[self.pos..];\n         let dst_len = dst.len();\n \n         if dst_len == 0 {\n@@ -349,8 +349,8 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = &self.buf[self.pos.. (self.pos + write_len)];\n-            let output = buf.slice_to_mut(write_len);\n+            let input = &self.buf[self.pos.. self.pos + write_len];\n+            let output = &mut buf[..write_len];\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -432,8 +432,8 @@ mod test {\n             writer.write(&[]).unwrap();\n             assert_eq!(writer.tell(), Ok(8));\n \n-            assert_eq!(writer.write(&[8, 9]).unwrap_err().kind, io::ShortWrite(1));\n-            assert_eq!(writer.write(&[10]).unwrap_err().kind, io::EndOfFile);\n+            assert_eq!(writer.write(&[8, 9]).err().unwrap().kind, io::ShortWrite(1));\n+            assert_eq!(writer.write(&[10]).err().unwrap().kind, io::EndOfFile);\n         }\n         let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8];\n         assert_eq!(buf, b);"}, {"sha": "f106e9464c52ac9c3fcaecaaca16fdfd65af5862", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 19, "deletions": 37, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -228,13 +228,12 @@ pub use self::FileAccess::*;\n pub use self::IoErrorKind::*;\n \n use char::CharExt;\n-use clone::Clone;\n use default::Default;\n-use error::{FromError, Error};\n+use error::Error;\n use fmt;\n use int;\n use iter::{Iterator, IteratorExt};\n-use marker::{Sized, Send};\n+use marker::Sized;\n use mem::transmute;\n use ops::FnOnce;\n use option::Option;\n@@ -340,7 +339,8 @@ impl IoError {\n     }\n }\n \n-impl fmt::String for IoError {\n+#[stable]\n+impl fmt::Display for IoError {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             IoError { kind: OtherIoError, desc: \"unknown error\", detail: Some(ref detail) } =>\n@@ -354,19 +354,7 @@ impl fmt::String for IoError {\n }\n \n impl Error for IoError {\n-    fn description(&self) -> &str {\n-        self.desc\n-    }\n-\n-    fn detail(&self) -> Option<String> {\n-        self.detail.clone()\n-    }\n-}\n-\n-impl FromError<IoError> for Box<Error + Send> {\n-    fn from_error(err: IoError) -> Box<Error + Send> {\n-        box err\n-    }\n+    fn description(&self) -> &str { self.desc }\n }\n \n /// A list specifying general categories of I/O error.\n@@ -516,7 +504,7 @@ pub trait Reader {\n         while read < min {\n             let mut zeroes = 0;\n             loop {\n-                match self.read(buf.slice_from_mut(read)) {\n+                match self.read(&mut buf[read..]) {\n                     Ok(0) => {\n                         zeroes += 1;\n                         if zeroes >= NO_PROGRESS_LIMIT {\n@@ -1436,33 +1424,31 @@ pub trait Buffer: Reader {\n     fn read_until(&mut self, byte: u8) -> IoResult<Vec<u8>> {\n         let mut res = Vec::new();\n \n-        let mut used;\n         loop {\n-            {\n+            let (done, used) = {\n                 let available = match self.fill_buf() {\n                     Ok(n) => n,\n                     Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n-                        used = 0;\n-                        break\n+                        return Ok(res);\n                     }\n                     Err(e) => return Err(e)\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(&available[..(i + 1)]);\n-                        used = i + 1;\n-                        break\n+                        res.push_all(&available[..i + 1]);\n+                        (true, i + 1)\n                     }\n                     None => {\n                         res.push_all(available);\n-                        used = available.len();\n+                        (false, available.len())\n                     }\n                 }\n-            }\n+            };\n             self.consume(used);\n+            if done {\n+                return Ok(res);\n+            }\n         }\n-        self.consume(used);\n-        Ok(res)\n     }\n \n     /// Reads the next utf8-encoded character from the underlying stream.\n@@ -1481,7 +1467,7 @@ pub trait Buffer: Reader {\n         {\n             let mut start = 1;\n             while start < width {\n-                match try!(self.read(buf.slice_mut(start, width))) {\n+                match try!(self.read(&mut buf[start .. width])) {\n                     n if n == width - start => break,\n                     n if n < width - start => { start += n; }\n                     _ => return Err(standard_error(InvalidInput)),\n@@ -1781,6 +1767,7 @@ pub struct UnstableFileStat {\n bitflags! {\n     /// A set of permissions for a file or directory is represented by a set of\n     /// flags which are or'd together.\n+    #[derive(Show)]\n     flags FilePermission: u32 {\n         const USER_READ     = 0o400,\n         const USER_WRITE    = 0o200,\n@@ -1822,13 +1809,8 @@ impl Default for FilePermission {\n     fn default() -> FilePermission { FilePermission::empty() }\n }\n \n-impl fmt::Show for FilePermission {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::String for FilePermission {\n+#[stable]\n+impl fmt::Display for FilePermission {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{:04o}\", self.bits)\n     }"}, {"sha": "e4622781ae7eaf26ebb29881fee8f2c0358aa349", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -38,7 +38,8 @@ pub enum IpAddr {\n     Ipv6Addr(u16, u16, u16, u16, u16, u16, u16, u16)\n }\n \n-impl fmt::String for IpAddr {\n+#[stable]\n+impl fmt::Display for IpAddr {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             Ipv4Addr(a, b, c, d) =>\n@@ -69,7 +70,8 @@ pub struct SocketAddr {\n     pub port: Port,\n }\n \n-impl fmt::String for SocketAddr {\n+#[stable]\n+impl fmt::Display for SocketAddr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.ip {\n             Ipv4Addr(..) => write!(f, \"{}:{}\", self.ip, self.port),\n@@ -251,7 +253,7 @@ impl<'a> Parser<'a> {\n             assert!(head.len() + tail.len() <= 8);\n             let mut gs = [0u16; 8];\n             gs.clone_from_slice(head);\n-            gs.slice_mut(8 - tail.len(), 8).clone_from_slice(tail);\n+            gs[(8 - tail.len()) .. 8].clone_from_slice(tail);\n             Ipv6Addr(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n         }\n "}, {"sha": "c2f52f5c8a3b45c637a3ab3145b93fda67300cfc", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -21,9 +21,6 @@ use prelude::v1::*;\n use collections::HashMap;\n use ffi::CString;\n use fmt;\n-// NOTE(stage0) remove import after a snapshot\n-#[cfg(stage0)]\n-use hash::Hash;\n use io::pipe::{PipeStream, PipePair};\n use io::{IoResult, IoError};\n use io;\n@@ -397,7 +394,7 @@ impl Command {\n     }\n }\n \n-impl fmt::String for Command {\n+impl fmt::Debug for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement\n     /// character.\n@@ -496,7 +493,7 @@ pub enum StdioContainer {\n \n /// Describes the result of a process after it has terminated.\n /// Note that Windows have no signals, so the result is usually ExitStatus.\n-#[derive(PartialEq, Eq, Clone, Copy)]\n+#[derive(PartialEq, Eq, Clone, Copy, Show)]\n pub enum ProcessExit {\n     /// Normal termination with an exit status.\n     ExitStatus(int),\n@@ -505,15 +502,8 @@ pub enum ProcessExit {\n     ExitSignal(int),\n }\n \n-impl fmt::Show for ProcessExit {\n-    /// Format a ProcessExit enum, to nicely present the information.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n-\n-impl fmt::String for ProcessExit {\n+#[stable]\n+impl fmt::Display for ProcessExit {\n     /// Format a ProcessExit enum, to nicely present the information.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "a5664b9f013776000187bec2d2b5acf7674effe7", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -40,6 +40,7 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use ops::{Deref, DerefMut, FnOnce};\n+use ptr;\n use result::Result::{Ok, Err};\n use rt;\n use slice::SliceExt;\n@@ -238,7 +239,7 @@ pub fn stdin() -> StdinReader {\n             // Make sure to free it at exit\n             rt::at_exit(|| {\n                 mem::transmute::<_, Box<StdinReader>>(STDIN);\n-                STDIN = 0 as *const _;\n+                STDIN = ptr::null();\n             });\n         });\n "}, {"sha": "68ae7d0ff2083d061fca4eec189d2fdb712fa4e5", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -227,6 +227,12 @@ mod test {\n     use thread::Thread;\n     use time::Duration;\n \n+    #[test]\n+    fn test_timer_send() {\n+        let mut timer = Timer::new().unwrap();\n+        Thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n+    }\n+\n     #[test]\n     fn test_io_timer_sleep_simple() {\n         let mut timer = Timer::new().unwrap();"}, {"sha": "e4bf38a9ef5d8e0d7de059153cc00c366aaa5934", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -48,7 +48,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n         }\n \n         let len = cmp::min(self.limit, buf.len());\n-        let res = self.inner.read(buf.slice_to_mut(len));\n+        let res = self.inner.read(&mut buf[..len]);\n         match res {\n             Ok(len) => self.limit -= len,\n             _ => {}"}, {"sha": "9bfc15f14389fc77b7fdcd83397fe02320ff6aaf", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -168,6 +168,7 @@ pub use core::raw;\n pub use core::simd;\n pub use core::result;\n pub use core::option;\n+pub use core::error;\n \n #[cfg(not(test))] pub use alloc::boxed;\n pub use alloc::rc;\n@@ -228,7 +229,6 @@ pub mod thunk;\n \n /* Common traits */\n \n-pub mod error;\n pub mod num;\n \n /* Runtime and platform support */"}, {"sha": "9ced1a7e1301c70a7166f1754503923e65a879c3", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -16,7 +16,7 @@\n #![stable]\n #![allow(missing_docs)]\n \n-#[cfg(test)] use fmt::Show;\n+#[cfg(test)] use fmt::Debug;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n \n use marker::Copy;\n@@ -322,7 +322,7 @@ pub fn test_num<T>(ten: T, two: T) where\n     T: PartialEq + NumCast\n      + Add<Output=T> + Sub<Output=T>\n      + Mul<Output=T> + Div<Output=T>\n-     + Rem<Output=T> + Show\n+     + Rem<Output=T> + Debug\n      + Copy\n {\n     assert_eq!(ten.add(two),  cast(12i).unwrap());"}, {"sha": "1d3bf484edb9ab458150dbd6213b2884fb423da3", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -379,14 +379,14 @@ pub fn float_to_str_bytes_common<T: Float>(\n \n             // only resize buf if we actually remove digits\n             if i < buf_max_i {\n-                buf = buf.slice(0, i + 1).to_vec();\n+                buf = buf[.. (i + 1)].to_vec();\n             }\n         }\n     } // If exact and trailing '.', just cut that\n     else {\n         let max_i = buf.len() - 1;\n         if buf[max_i] == b'.' {\n-            buf = buf.slice(0, max_i).to_vec();\n+            buf = buf[.. max_i].to_vec();\n         }\n     }\n "}, {"sha": "985a8cd32e29d88c478f6f5920d42fdd9fe2fb8f", "filename": "src/libstd/os.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -855,7 +855,7 @@ pub enum MapOption {\n impl Copy for MapOption {}\n \n /// Possible errors when creating a map.\n-#[derive(Copy)]\n+#[derive(Copy, Show)]\n pub enum MapError {\n     /// # The following are POSIX-specific\n     ///\n@@ -900,7 +900,8 @@ pub enum MapError {\n     ErrMapViewOfFile(uint)\n }\n \n-impl fmt::Show for MapError {\n+#[stable]\n+impl fmt::Display for MapError {\n     fn fmt(&self, out: &mut fmt::Formatter) -> fmt::Result {\n         let str = match *self {\n             ErrFdNotAvail => \"fd not available for reading or writing\",\n@@ -934,13 +935,6 @@ impl fmt::Show for MapError {\n \n impl Error for MapError {\n     fn description(&self) -> &str { \"memory map error\" }\n-    fn detail(&self) -> Option<String> { Some(format!(\"{:?}\", self)) }\n-}\n-\n-impl FromError<MapError> for Box<Error + Send> {\n-    fn from_error(err: MapError) -> Box<Error + Send> {\n-        box err\n-    }\n }\n \n // Round up `from` to be divisible by `to`"}, {"sha": "06d930ce50a7973fe1a76370a0be7d726868dcff", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -399,7 +399,7 @@ pub trait GenericPath: Clone + GenericPathUnsafe {\n                 match name.rposition_elem(&dot) {\n                     None | Some(0) => None,\n                     Some(1) if name == b\"..\" => None,\n-                    Some(pos) => Some(&name[(pos+1)..])\n+                    Some(pos) => Some(&name[pos+1..])\n                 }\n             }\n         }\n@@ -823,13 +823,15 @@ pub struct Display<'a, P:'a> {\n     filename: bool\n }\n \n-impl<'a, P: GenericPath> fmt::Show for Display<'a, P> {\n+#[stable]\n+impl<'a, P: GenericPath> fmt::Debug for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Debug::fmt(&self.as_cow(), f)\n     }\n }\n \n-impl<'a, P: GenericPath> fmt::String for Display<'a, P> {\n+#[stable]\n+impl<'a, P: GenericPath> fmt::Display for Display<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.as_cow().fmt(f)\n     }"}, {"sha": "100876271b38f6216e2447db3719ca8d8c316a9b", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -57,9 +57,10 @@ pub fn is_sep(c: char) -> bool {\n     c == SEP\n }\n \n-impl fmt::Show for Path {\n+#[stable]\n+impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(&self.display(), f)\n+        fmt::Debug::fmt(&self.display(), f)\n     }\n }\n \n@@ -126,7 +127,7 @@ impl GenericPathUnsafe for Path {\n             None => {\n                 self.repr = Path::normalize(filename);\n             }\n-            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => {\n+            Some(idx) if &self.repr[idx+1..] == b\"..\" => {\n                 let mut v = Vec::with_capacity(self.repr.len() + 1 + filename.len());\n                 v.push_all(self.repr.as_slice());\n                 v.push(SEP_BYTE);\n@@ -136,7 +137,7 @@ impl GenericPathUnsafe for Path {\n             }\n             Some(idx) => {\n                 let mut v = Vec::with_capacity(idx + 1 + filename.len());\n-                v.push_all(&self.repr[..(idx+1)]);\n+                v.push_all(&self.repr[..idx+1]);\n                 v.push_all(filename);\n                 // FIXME: this is slow\n                 self.repr = Path::normalize(v.as_slice());\n@@ -178,7 +179,7 @@ impl GenericPath for Path {\n             None if b\"..\" == self.repr => self.repr.as_slice(),\n             None => dot_static,\n             Some(0) => &self.repr[..1],\n-            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => self.repr.as_slice(),\n+            Some(idx) if &self.repr[idx+1..] == b\"..\" => self.repr.as_slice(),\n             Some(idx) => &self.repr[..idx]\n         }\n     }\n@@ -188,9 +189,9 @@ impl GenericPath for Path {\n             None if b\".\" == self.repr ||\n                 b\"..\" == self.repr => None,\n             None => Some(self.repr.as_slice()),\n-            Some(idx) if &self.repr[(idx+1)..] == b\"..\" => None,\n+            Some(idx) if &self.repr[idx+1..] == b\"..\" => None,\n             Some(0) if self.repr[1..].is_empty() => None,\n-            Some(idx) => Some(&self.repr[(idx+1)..])\n+            Some(idx) => Some(&self.repr[idx+1..])\n         }\n     }\n "}, {"sha": "bd5f84165778cd1fa69c7dcd0e9463912bedbbe1", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -85,9 +85,10 @@ pub struct Path {\n     sepidx: Option<uint> // index of the final separator in the non-prefix portion of repr\n }\n \n-impl fmt::Show for Path {\n+#[stable]\n+impl fmt::Debug for Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(&self.display(), f)\n+        fmt::Debug::fmt(&self.display(), f)\n     }\n }\n \n@@ -428,10 +429,10 @@ impl GenericPath for Path {\n         if self.prefix.is_some() {\n             Some(Path::new(match self.prefix {\n                 Some(DiskPrefix) if self.is_absolute() => {\n-                    &self.repr[..(self.prefix_len()+1)]\n+                    &self.repr[..self.prefix_len()+1]\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    &self.repr[..(self.prefix_len()+1)]\n+                    &self.repr[..self.prefix_len()+1]\n                 }\n                 _ => &self.repr[..self.prefix_len()]\n             }))\n@@ -635,7 +636,7 @@ impl Path {\n             Some(_) => {\n                 let plen = self.prefix_len();\n                 if repr.len() > plen && repr.as_bytes()[plen] == SEP_BYTE {\n-                    &repr[(plen+1)..]\n+                    &repr[plen+1..]\n                 } else { &repr[plen..] }\n             }\n             None if repr.as_bytes()[0] == SEP_BYTE => &repr[1..],\n@@ -786,9 +787,9 @@ impl Path {\n                             }\n                             Some(UNCPrefix(a,b)) => {\n                                 s.push_str(\"\\\\\\\\\");\n-                                s.push_str(&prefix_[2..(a+2)]);\n+                                s.push_str(&prefix_[2..a+2]);\n                                 s.push(SEP);\n-                                s.push_str(&prefix_[(3+a)..(3+a+b)]);\n+                                s.push_str(&prefix_[3+a..3+a+b]);\n                             }\n                             Some(_) => s.push_str(prefix_),\n                             None => ()\n@@ -813,7 +814,7 @@ impl Path {\n \n     fn update_sepidx(&mut self) {\n         let s = if self.has_nonsemantic_trailing_slash() {\n-                    &self.repr[..(self.repr.len()-1)]\n+                    &self.repr[..self.repr.len()-1]\n                 } else { &self.repr[] };\n         let sep_test: fn(char) -> bool = if !prefix_is_verbatim(self.prefix) {\n             is_sep\n@@ -1029,7 +1030,7 @@ fn parse_prefix<'a>(mut path: &'a str) -> Option<PathPrefix> {\n             None => return None,\n             Some(x) => x\n         };\n-        path = &path[(idx_a+1)..];\n+        path = &path[idx_a+1..];\n         let idx_b = path.find(f).unwrap_or(path.len());\n         Some((idx_a, idx_b))\n     }"}, {"sha": "bafbde2511dec6096816b5fc92e987b0f3cdba4a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -65,7 +65,7 @@ mod imp {\n         let mut read = 0;\n         let len = v.len();\n         while read < len {\n-            let result = getrandom(v.slice_from_mut(read));\n+            let result = getrandom(&mut v[read..]);\n             if result == -1 {\n                 let err = errno() as libc::c_int;\n                 if err == libc::EINTR {"}, {"sha": "4023a0a4c100b3b86f5ee319bf857920048f248f", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -130,7 +130,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n     }\n     impl<'a> fmt::Writer for BufWriter<'a> {\n         fn write_str(&mut self, bytes: &str) -> fmt::Result {\n-            let left = self.buf.slice_from_mut(self.pos);\n+            let left = &mut self.buf[self.pos..];\n             let to_write = &bytes.as_bytes()[..cmp::min(bytes.len(), left.len())];\n             slice::bytes::copy_memory(left, to_write);\n             self.pos += to_write.len();"}, {"sha": "61ffb532d36ad49cb20a97822371d53ac7af5b73", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -14,8 +14,6 @@ use thread::Thread;\n use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n-#[cfg(stage0)] // NOTE remove use after next snapshot\n-use marker::{NoSend, NoSync};\n use mem;\n use clone::Clone;\n \n@@ -32,42 +30,14 @@ pub struct SignalToken {\n     inner: Arc<Inner>,\n }\n \n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct WaitToken {\n     inner: Arc<Inner>,\n-    no_send: NoSend,\n-    no_sync: NoSync,\n }\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct WaitToken {\n-    inner: Arc<Inner>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl !Send for WaitToken {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl !Sync for WaitToken {}\n \n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub fn tokens() -> (WaitToken, SignalToken) {\n-    let inner = Arc::new(Inner {\n-        thread: Thread::current(),\n-        woken: ATOMIC_BOOL_INIT,\n-    });\n-    let wait_token = WaitToken {\n-        inner: inner.clone(),\n-        no_send: NoSend,\n-        no_sync: NoSync,\n-    };\n-    let signal_token = SignalToken {\n-        inner: inner\n-    };\n-    (wait_token, signal_token)\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n         thread: Thread::current(),"}, {"sha": "062bdf346cd44f6a5e406b68e280000b644b69f5", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 25, "deletions": 58, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -319,7 +319,6 @@ use prelude::v1::*;\n \n use sync::Arc;\n use fmt;\n-use marker;\n use mem;\n use cell::UnsafeCell;\n \n@@ -370,44 +369,34 @@ unsafe impl<T:Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct SyncSender<T> {\n-    inner: Arc<RacyCell<sync::Packet<T>>>,\n-    // can't share in an arc\n-    _marker: marker::NoSync,\n+    inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n \n-/// The sending-half of Rust's synchronous channel type. This half can only be\n-/// owned by one task, but it can be cloned to send to other tasks.\n-#[stable]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct SyncSender<T> {\n-    inner: Arc<RacyCell<sync::Packet<T>>>,\n-}\n+unsafe impl<T:Send> Send for SyncSender<T> {}\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-impl<T> !marker::Sync for SyncSender<T> {}\n+impl<T> !Sync for SyncSender<T> {}\n \n /// An error returned from the `send` function on channels.\n ///\n /// A `send` operation can only fail if the receiving end of a channel is\n /// disconnected, implying that the data could never be received. The error\n /// contains the data being sent as a payload so it can be recovered.\n-#[derive(PartialEq, Eq)]\n+#[derive(PartialEq, Eq, Show)]\n #[stable]\n pub struct SendError<T>(pub T);\n \n /// An error returned from the `recv` function on a `Receiver`.\n ///\n /// The `recv` operation can only fail if the sending half of a channel is\n /// disconnected, implying that no further messages will ever be received.\n-#[derive(PartialEq, Eq, Clone, Copy)]\n+#[derive(PartialEq, Eq, Clone, Copy, Show)]\n #[stable]\n pub struct RecvError;\n \n /// This enumeration is the list of the possible reasons that try_recv could not\n /// return data when called.\n-#[derive(PartialEq, Clone, Copy)]\n+#[derive(PartialEq, Clone, Copy, Show)]\n #[stable]\n pub enum TryRecvError {\n     /// This channel is currently empty, but the sender(s) have not yet\n@@ -423,7 +412,7 @@ pub enum TryRecvError {\n \n /// This enumeration is the list of the possible error outcomes for the\n /// `SyncSender::try_send` method.\n-#[derive(PartialEq, Clone)]\n+#[derive(PartialEq, Clone, Show)]\n #[stable]\n pub enum TrySendError<T> {\n     /// The data could not be sent on the channel because it would require that\n@@ -442,10 +431,10 @@ pub enum TrySendError<T> {\n }\n \n enum Flavor<T> {\n-    Oneshot(Arc<RacyCell<oneshot::Packet<T>>>),\n-    Stream(Arc<RacyCell<stream::Packet<T>>>),\n-    Shared(Arc<RacyCell<shared::Packet<T>>>),\n-    Sync(Arc<RacyCell<sync::Packet<T>>>),\n+    Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n+    Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n+    Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n+    Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n@@ -497,7 +486,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// ```\n #[stable]\n pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n-    let a = Arc::new(RacyCell::new(oneshot::Packet::new()));\n+    let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n \n@@ -537,7 +526,7 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n /// ```\n #[stable]\n pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n-    let a = Arc::new(RacyCell::new(sync::Packet::new(bound)));\n+    let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n \n@@ -589,7 +578,7 @@ impl<T: Send> Sender<T> {\n                         return (*p).send(t).map_err(SendError);\n                     } else {\n                         let a =\n-                            Arc::new(RacyCell::new(stream::Packet::new()));\n+                            Arc::new(UnsafeCell::new(stream::Packet::new()));\n                         let rx = Receiver::new(Flavor::Stream(a.clone()));\n                         match (*p).upgrade(rx) {\n                             oneshot::UpSuccess => {\n@@ -631,7 +620,7 @@ impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n-                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n+                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n@@ -643,7 +632,7 @@ impl<T: Send> Clone for Sender<T> {\n                 }\n             }\n             Flavor::Stream(ref p) => {\n-                let a = Arc::new(RacyCell::new(shared::Packet::new()));\n+                let a = Arc::new(UnsafeCell::new(shared::Packet::new()));\n                 unsafe {\n                     let guard = (*a.get()).postinit_lock();\n                     let rx = Receiver::new(Flavor::Shared(a.clone()));\n@@ -689,13 +678,7 @@ impl<T: Send> Drop for Sender<T> {\n ////////////////////////////////////////////////////////////////////////////////\n \n impl<T: Send> SyncSender<T> {\n-    #[cfg(stage0)] // NOTE remove impl after next snapshot\n-    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n-        SyncSender { inner: inner, _marker: marker::NoSync }\n-    }\n-\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-    fn new(inner: Arc<RacyCell<sync::Packet<T>>>) -> SyncSender<T> {\n+    fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner }\n     }\n \n@@ -978,33 +961,15 @@ impl<T: Send> Drop for Receiver<T> {\n     }\n }\n \n-/// A version of `UnsafeCell` intended for use in concurrent data\n-/// structures (for example, you might put it in an `Arc`).\n-struct RacyCell<T>(pub UnsafeCell<T>);\n-\n-impl<T> RacyCell<T> {\n-\n-    fn new(value: T) -> RacyCell<T> {\n-        RacyCell(UnsafeCell { value: value })\n-    }\n-\n-    unsafe fn get(&self) -> *mut T {\n-        self.0.get()\n-    }\n-\n-}\n-\n-unsafe impl<T:Send> Send for RacyCell<T> { }\n-\n-unsafe impl<T> Sync for RacyCell<T> { } // Oh dear\n-\n-impl<T> fmt::Show for SendError<T> {\n+#[stable]\n+impl<T> fmt::Display for SendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"sending on a closed channel\".fmt(f)\n     }\n }\n \n-impl<T> fmt::Show for TrySendError<T> {\n+#[stable]\n+impl<T> fmt::Display for TrySendError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TrySendError::Full(..) => {\n@@ -1017,13 +982,15 @@ impl<T> fmt::Show for TrySendError<T> {\n     }\n }\n \n-impl fmt::Show for RecvError {\n+#[stable]\n+impl fmt::Display for RecvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         \"receiving on a closed channel\".fmt(f)\n     }\n }\n \n-impl fmt::Show for TryRecvError {\n+#[stable]\n+impl fmt::Display for TryRecvError {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             TryRecvError::Empty => {"}, {"sha": "ea81ed30a9c603b6b72e2ca1473c920444916cf4", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -46,6 +46,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::mem;\n+use core::ptr;\n use core::cell::UnsafeCell;\n \n use sync::atomic::{AtomicPtr, Ordering};\n@@ -82,7 +83,7 @@ unsafe impl<T:Send> Sync for Queue<T> { }\n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n         mem::transmute(box Node {\n-            next: AtomicPtr::new(0 as *mut Node<T>),\n+            next: AtomicPtr::new(ptr::null_mut()),\n             value: v,\n         })\n     }"}, {"sha": "f5bacbb8ce2a784f822a8b749c0d9883c4cc835a", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 7, "deletions": 34, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -59,31 +59,20 @@ use core::prelude::*;\n use core::cell::Cell;\n use core::marker;\n use core::mem;\n+use core::ptr;\n use core::uint;\n \n use sync::mpsc::{Receiver, RecvError};\n use sync::mpsc::blocking::{self, SignalToken};\n \n /// The \"receiver set\" of the select interface. This structure is used to manage\n /// a set of receivers which are being selected over.\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct Select {\n     head: *mut Handle<'static, ()>,\n     tail: *mut Handle<'static, ()>,\n     next_id: Cell<uint>,\n-    marker1: marker::NoSend,\n }\n \n-/// The \"receiver set\" of the select interface. This structure is used to manage\n-/// a set of receivers which are being selected over.\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct Select {\n-    head: *mut Handle<'static, ()>,\n-    tail: *mut Handle<'static, ()>,\n-    next_id: Cell<uint>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl !marker::Send for Select {}\n \n /// A handle to a receiver which is currently a member of a `Select` set of\n@@ -126,26 +115,10 @@ impl Select {\n     ///\n     /// Usage of this struct directly can sometimes be burdensome, and usage is\n     /// rather much easier through the `select!` macro.\n-    #[cfg(stage0)] // NOTE remove impl after next snapshot\n-    pub fn new() -> Select {\n-        Select {\n-            marker1: marker::NoSend,\n-            head: 0 as *mut Handle<'static, ()>,\n-            tail: 0 as *mut Handle<'static, ()>,\n-            next_id: Cell::new(1),\n-        }\n-    }\n-\n-    /// Creates a new selection structure. This set is initially empty and\n-    /// `wait` will panic!() if called.\n-    ///\n-    /// Usage of this struct directly can sometimes be burdensome, and usage is\n-    /// rather much easier through the `select!` macro.\n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     pub fn new() -> Select {\n         Select {\n-            head: 0 as *mut Handle<'static, ()>,\n-            tail: 0 as *mut Handle<'static, ()>,\n+            head: ptr::null_mut(),\n+            tail: ptr::null_mut(),\n             next_id: Cell::new(1),\n         }\n     }\n@@ -159,8 +132,8 @@ impl Select {\n         Handle {\n             id: id,\n             selector: self,\n-            next: 0 as *mut Handle<'static, ()>,\n-            prev: 0 as *mut Handle<'static, ()>,\n+            next: ptr::null_mut(),\n+            prev: ptr::null_mut(),\n             added: false,\n             rx: rx,\n             packet: rx,\n@@ -325,8 +298,8 @@ impl<'rx, T: Send> Handle<'rx, T> {\n             (*self.next).prev = self.prev;\n         }\n \n-        self.next = 0 as *mut Handle<'static, ()>;\n-        self.prev = 0 as *mut Handle<'static, ()>;\n+        self.next = ptr::null_mut();\n+        self.prev = ptr::null_mut();\n \n         self.added = false;\n     }"}, {"sha": "8cd88cedf6b7dccfc03a8e23eb861ae823f7f3b5", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -39,6 +39,7 @@ use core::prelude::*;\n \n use alloc::boxed::Box;\n use core::mem;\n+use core::ptr;\n use core::cell::UnsafeCell;\n \n use sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\n@@ -82,7 +83,7 @@ impl<T: Send> Node<T> {\n         unsafe {\n             mem::transmute(box Node {\n                 value: None,\n-                next: AtomicPtr::new(0 as *mut Node<T>),\n+                next: AtomicPtr::new(ptr::null_mut::<Node<T>>()),\n             })\n         }\n     }\n@@ -131,7 +132,7 @@ impl<T: Send> Queue<T> {\n             let n = self.alloc();\n             assert!((*n).value.is_none());\n             (*n).value = Some(t);\n-            (*n).next.store(0 as *mut Node<T>, Ordering::Relaxed);\n+            (*n).next.store(ptr::null_mut(), Ordering::Relaxed);\n             (**self.head.get()).next.store(n, Ordering::Release);\n             *self.head.get() = n;\n         }"}, {"sha": "d38f14a91302fa6fde9b19dfcd819025f739dd68", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -40,6 +40,7 @@ use self::Blocker::*;\n \n use vec::Vec;\n use core::mem;\n+use core::ptr;\n \n use sync::atomic::{Ordering, AtomicUsize};\n use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n@@ -145,8 +146,8 @@ impl<T: Send> Packet<T> {\n                 cap: cap,\n                 canceled: None,\n                 queue: Queue {\n-                    head: 0 as *mut Node,\n-                    tail: 0 as *mut Node,\n+                    head: ptr::null_mut(),\n+                    tail: ptr::null_mut(),\n                 },\n                 buf: Buffer {\n                     buf: range(0, cap + if cap == 0 {1} else {0}).map(|_| None).collect(),\n@@ -160,7 +161,7 @@ impl<T: Send> Packet<T> {\n     // wait until a send slot is available, returning locked access to\n     // the channel state.\n     fn acquire_send_slot(&self) -> MutexGuard<State<T>> {\n-        let mut node = Node { token: None, next: 0 as *mut Node };\n+        let mut node = Node { token: None, next: ptr::null_mut() };\n         loop {\n             let mut guard = self.lock.lock().unwrap();\n             // are we ready to go?\n@@ -343,8 +344,8 @@ impl<T: Send> Packet<T> {\n             Vec::new()\n         };\n         let mut queue = mem::replace(&mut guard.queue, Queue {\n-            head: 0 as *mut Node,\n-            tail: 0 as *mut Node,\n+            head: ptr::null_mut(),\n+            tail: ptr::null_mut(),\n         });\n \n         let waiter = match mem::replace(&mut guard.blocker, NoneBlocked) {\n@@ -453,7 +454,7 @@ impl Queue {\n     fn enqueue(&mut self, node: &mut Node) -> WaitToken {\n         let (wait_token, signal_token) = blocking::tokens();\n         node.token = Some(signal_token);\n-        node.next = 0 as *mut Node;\n+        node.next = ptr::null_mut();\n \n         if self.tail.is_null() {\n             self.head = node as *mut Node;\n@@ -475,10 +476,10 @@ impl Queue {\n         let node = self.head;\n         self.head = unsafe { (*node).next };\n         if self.head.is_null() {\n-            self.tail = 0 as *mut Node;\n+            self.tail = ptr::null_mut();\n         }\n         unsafe {\n-            (*node).next = 0 as *mut Node;\n+            (*node).next = ptr::null_mut();\n             Some((*node).token.take().unwrap())\n         }\n     }"}, {"sha": "6ddfe3e075b8c80272cb3d6c7fcb5060af92e8c5", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -160,33 +160,14 @@ unsafe impl Sync for StaticMutex {}\n /// Deref and DerefMut implementations\n #[must_use]\n #[stable]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct MutexGuard<'a, T: 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n     __lock: &'a StaticMutex,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n-    __marker: marker::NoSend,\n }\n \n-/// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n-/// dropped (falls out of scope), the lock will be unlocked.\n-///\n-/// The data protected by the mutex can be access through this guard via its\n-/// Deref and DerefMut implementations\n-#[must_use]\n-#[stable]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct MutexGuard<'a, T: 'a> {\n-    // funny underscores due to how Deref/DerefMut currently work (they\n-    // disregard field privacy).\n-    __lock: &'a StaticMutex,\n-    __data: &'a UnsafeCell<T>,\n-    __poison: poison::Guard,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n@@ -299,20 +280,7 @@ impl StaticMutex {\n }\n \n impl<'mutex, T> MutexGuard<'mutex, T> {\n-    #[cfg(stage0)] // NOTE remove afte next snapshot\n-    fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n-           -> LockResult<MutexGuard<'mutex, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| {\n-            MutexGuard {\n-                __lock: lock,\n-                __data: data,\n-                __poison: guard,\n-                __marker: marker::NoSend,\n-            }\n-        })\n-    }\n \n-    #[cfg(not(stage0))] // NOTE remove cfg afte next snapshot\n     fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {"}, {"sha": "c97fcf7cefb74a68fb1ef9069377f3b4b3509376", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -53,13 +53,15 @@ pub struct Guard {\n /// is held. The precise semantics for when a lock is poisoned is documented on\n /// each lock, but once a lock is poisoned then all future acquisitions will\n /// return this error.\n+#[derive(Show)]\n #[stable]\n pub struct PoisonError<T> {\n     guard: T,\n }\n \n /// An enumeration of possible errors which can occur while calling the\n /// `try_lock` method.\n+#[derive(Show)]\n #[stable]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another task failed while holding\n@@ -90,7 +92,8 @@ pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n #[stable]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n-impl<T> fmt::Show for PoisonError<T> {\n+#[stable]\n+impl<T> fmt::Display for PoisonError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)\n     }\n@@ -130,7 +133,8 @@ impl<T> FromError<PoisonError<T>> for TryLockError<T> {\n     }\n }\n \n-impl<T> fmt::Show for TryLockError<T> {\n+#[stable]\n+impl<T> fmt::Display for TryLockError<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.description().fmt(f)\n     }"}, {"sha": "35d305466b5554a0a93c82e62639ed170cc0e70d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -110,50 +110,23 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// dropped.\n #[must_use]\n #[stable]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n pub struct RwLockReadGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n-    __marker: marker::NoSend,\n }\n \n-/// RAII structure used to release the shared read access of a lock when\n-/// dropped.\n-#[must_use]\n-#[stable]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n-pub struct RwLockReadGuard<'a, T: 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n-}\n-\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n #[stable]\n-#[cfg(stage0)] // NOTE remove impl after next snapshot\n-pub struct RwLockWriteGuard<'a, T: 'a> {\n-    __lock: &'a StaticRwLock,\n-    __data: &'a UnsafeCell<T>,\n-    __poison: poison::Guard,\n-    __marker: marker::NoSend,\n-}\n-\n-/// RAII structure used to release the exclusive write access of a lock when\n-/// dropped.\n-#[must_use]\n-#[stable]\n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n pub struct RwLockWriteGuard<'a, T: 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n }\n \n-#[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T: Send + Sync> RwLock<T> {\n@@ -332,19 +305,7 @@ impl StaticRwLock {\n }\n \n impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n-    #[cfg(stage0)] // NOTE remove impl after next snapshot\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockReadGuard<'rwlock, T>> {\n-        poison::map_result(lock.poison.borrow(), |_| {\n-            RwLockReadGuard {\n-                __lock: lock,\n-                __data: data,\n-                __marker: marker::NoSend,\n-            }\n-        })\n-    }\n \n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n@@ -356,20 +317,7 @@ impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n     }\n }\n impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n-    #[cfg(stage0)] // NOTE remove impl after next snapshot\n-    fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n-           -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n-        poison::map_result(lock.poison.borrow(), |guard| {\n-            RwLockWriteGuard {\n-                __lock: lock,\n-                __data: data,\n-                __poison: guard,\n-                __marker: marker::NoSend,\n-            }\n-        })\n-    }\n \n-    #[cfg(not(stage0))] // NOTE remove cfg after next snapshot\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {"}, {"sha": "d069d9ee3b8b89889b378c4841db7ae5a8bfc7e7", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -42,10 +42,10 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n     let mut valid = true;\n     let mut inner = s;\n     if s.len() > 4 && s.starts_with(\"_ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(3, s.len() - 1);\n+        inner = &s[3 .. s.len() - 1];\n     // On Windows, dbghelp strips leading underscores, so we accept \"ZN...E\" form too.\n     } else if s.len() > 3 && s.starts_with(\"ZN\") && s.ends_with(\"E\") {\n-        inner = s.slice(2, s.len() - 1);\n+        inner = &s[2 .. s.len() - 1];\n     } else {\n         valid = false;\n     }\n@@ -83,11 +83,11 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             }\n             let mut rest = inner;\n             while rest.char_at(0).is_numeric() {\n-                rest = rest.slice_from(1);\n+                rest = &rest[1..];\n             }\n-            let i: uint = inner.slice_to(inner.len() - rest.len()).parse().unwrap();\n-            inner = rest.slice_from(i);\n-            rest = rest.slice_to(i);\n+            let i: uint = inner[.. (inner.len() - rest.len())].parse().unwrap();\n+            inner = &rest[i..];\n+            rest = &rest[..i];\n             while rest.len() > 0 {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n@@ -128,8 +128,8 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                         None => rest.len(),\n                         Some(i) => i,\n                     };\n-                    try!(writer.write_str(rest.slice_to(idx)));\n-                    rest = rest.slice_from(idx);\n+                    try!(writer.write_str(&rest[..idx]));\n+                    rest = &rest[idx..];\n                 }\n             }\n         }"}, {"sha": "6f6179a436e914c3c77de9384be7e6b41799ea02", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -24,6 +24,7 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use mem;\n+use ptr;\n use rt;\n use sync::{StaticMutex, StaticCondvar};\n use sync::mpsc::{channel, Sender, Receiver};\n@@ -132,7 +133,7 @@ impl<M: Send> Helper<M> {\n \n             // Close the channel by destroying it\n             let chan: Box<Sender<M>> = mem::transmute(*self.chan.get());\n-            *self.chan.get() = 0 as *mut Sender<M>;\n+            *self.chan.get() = ptr::null_mut();\n             drop(chan);\n             helper_signal::signal(*self.signal.get() as helper_signal::signal);\n "}, {"sha": "cb2edf50ebd3ea4ba3bb1ffb14abee25e7f91e8c", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -353,7 +353,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n     if state.is_null() {\n         return output(w, idx, addr, None)\n     }\n-    let mut data = 0 as *const libc::c_char;\n+    let mut data = ptr::null();\n     let data_addr = &mut data as *mut *const libc::c_char;\n     let ret = unsafe {\n         backtrace_syminfo(state, addr as libc::uintptr_t,\n@@ -418,7 +418,7 @@ mod uw {\n                                  trace_argument: *mut libc::c_void)\n                     -> _Unwind_Reason_Code;\n \n-        #[cfg(all(not(target_os = \"android\"),\n+        #[cfg(all(not(all(target_os = \"android\", target_arch = \"arm\")),\n                   not(all(target_os = \"linux\", target_arch = \"arm\"))))]\n         pub fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t;\n \n@@ -431,7 +431,7 @@ mod uw {\n     // On android, the function _Unwind_GetIP is a macro, and this is the\n     // expansion of the macro. This is all copy/pasted directly from the\n     // header file with the definition of _Unwind_GetIP.\n-    #[cfg(any(target_os = \"android\",\n+    #[cfg(any(all(target_os = \"android\", target_arch = \"arm\"),\n               all(target_os = \"linux\", target_arch = \"arm\")))]\n     pub unsafe fn _Unwind_GetIP(ctx: *mut _Unwind_Context) -> libc::uintptr_t {\n         #[repr(C)]"}, {"sha": "3bc414731526300d15d5fa0d0716b132c7d892f6", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -10,6 +10,7 @@\n \n use cell::UnsafeCell;\n use libc;\n+use ptr;\n use std::option::Option::{Some, None};\n use sys::mutex::{self, Mutex};\n use sys::time;\n@@ -62,7 +63,7 @@ impl Condvar {\n         // time.\n         let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         let stable_now = time::SteadyTime::now();\n-        let r = ffi::gettimeofday(&mut sys_now, 0 as *mut _);\n+        let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n         let seconds = NumCast::from(dur.num_seconds());"}, {"sha": "dd478347f819b36d1cd0bc5a7f1632916e75675c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -19,6 +19,7 @@ use io::{Read, Truncate, SeekCur, SeekSet, ReadWrite, SeekEnd, Append};\n use io;\n use libc::{self, c_int, c_void};\n use mem;\n+use ptr;\n use sys::retry;\n use sys_common::{keep_going, eof, mkerr_libc};\n \n@@ -207,7 +208,7 @@ pub fn readdir(p: &Path) -> IoResult<Vec<Path>> {\n \n     if dir_ptr as uint != 0 {\n         let mut paths = vec!();\n-        let mut entry_ptr = 0 as *mut dirent_t;\n+        let mut entry_ptr = ptr::null_mut();\n         while unsafe { readdir_r(dir_ptr, ptr, &mut entry_ptr) == 0 } {\n             if entry_ptr.is_null() { break }\n             paths.push(unsafe {"}, {"sha": "2c25af055ee1c66c0b1cf46d35fbe2dc1b01545a", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -143,7 +143,7 @@ pub unsafe fn get_env_pairs() -> Vec<Vec<u8>> {\n                os::last_os_error());\n     }\n     let mut result = Vec::new();\n-    while *environ != 0 as *const _ {\n+    while *environ != ptr::null() {\n         let env_pair = ffi::c_str_to_bytes(&*environ).to_vec();\n         result.push(env_pair);\n         environ = environ.offset(1);"}, {"sha": "2b4d168d881f6a1c25f6449aed1b3b6d64c5bbcd", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -125,9 +125,9 @@ impl Process {\n                     let mut bytes = [0; 8];\n                     return match input.read(&mut bytes) {\n                         Ok(8) => {\n-                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(bytes.slice(4, 8)),\n+                            assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n                                 \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                            let errno = combine(bytes.slice(0, 4));\n+                            let errno = combine(&bytes[0.. 4]);\n                             assert!(p.wait(0).is_ok(), \"wait(0) should either return Ok or panic\");\n                             Err(super::decode_error(errno))\n                         }\n@@ -251,7 +251,7 @@ impl Process {\n                             fn setgroups(ngroups: libc::c_int,\n                                          ptr: *const libc::c_void) -> libc::c_int;\n                         }\n-                        let _ = setgroups(0, 0 as *const libc::c_void);\n+                        let _ = setgroups(0, ptr::null());\n \n                         if libc::setuid(u as libc::uid_t) != 0 {\n                             fail(&mut output);"}, {"sha": "cba7d81937acde588dca47a03fd2fcf0809ac5c1", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -31,6 +31,7 @@ use mem;\n use ops::Drop;\n use option::Option::{Some, None};\n use path::Path;\n+use ptr;\n use result::Result::{Ok, Err};\n use slice::SliceExt;\n use str::{self, StrExt};\n@@ -327,18 +328,18 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n     let image = arch::init_frame(&mut frame, &context);\n \n     // Initialize this process's symbols\n-    let ret = SymInitialize(process, 0 as *mut libc::c_void, libc::TRUE);\n+    let ret = SymInitialize(process, ptr::null_mut(), libc::TRUE);\n     if ret != libc::TRUE { return Ok(()) }\n     let _c = Cleanup { handle: process, SymCleanup: SymCleanup };\n \n     // And now that we're done with all the setup, do the stack walking!\n     let mut i = 0i;\n     try!(write!(w, \"stack backtrace:\\n\"));\n     while StackWalk64(image, process, thread, &mut frame, &mut context,\n-                      0 as *mut libc::c_void,\n-                      0 as *mut libc::c_void,\n-                      0 as *mut libc::c_void,\n-                      0 as *mut libc::c_void) == libc::TRUE{\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut(),\n+                      ptr::null_mut()) == libc::TRUE{\n         let addr = frame.AddrPC.Offset;\n         if addr == frame.AddrReturn.Offset || addr == 0 ||\n            frame.AddrReturn.Offset == 0 { break }\n@@ -362,7 +363,7 @@ pub fn write(w: &mut Writer) -> IoResult<()> {\n             let bytes = unsafe { ffi::c_str_to_bytes(&ptr) };\n             match str::from_utf8(bytes) {\n                 Ok(s) => try!(demangle(w, s)),\n-                Err(..) => try!(w.write(&bytes[..(bytes.len()-1)])),\n+                Err(..) => try!(w.write(&bytes[..bytes.len()-1])),\n             }\n         }\n         try!(w.write(&['\\n' as u8]));"}, {"sha": "cb8ef7eb66bc414d30658135feef4d382a213930", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -376,7 +376,7 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n     });\n     let ret = match ret {\n         Some(ref s) if s.starts_with(r\"\\\\?\\\") => { // \"\n-            Ok(Path::new(s.slice_from(4)))\n+            Ok(Path::new(&s[4..]))\n         }\n         Some(s) => Ok(Path::new(s)),\n         None => Err(super::last_error()),"}, {"sha": "36dc9b2afe49feb673cfd58081e7634ca22a08c2", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -146,7 +146,7 @@ pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n                 done = true;\n             }\n             if k != 0 && done {\n-                let sub = buf.slice(0, k as uint);\n+                let sub = &buf[.. (k as uint)];\n                 // We want to explicitly catch the case when the\n                 // closure returned invalid UTF-16, rather than\n                 // set `res` to None and continue."}, {"sha": "d148f82184bd4d8b8b99c75c7f54edc444a2eac8", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -13,6 +13,7 @@ use prelude::v1::*;\n use libc::types::os::arch::extra::{DWORD, LPVOID, BOOL};\n \n use mem;\n+use ptr;\n use rt;\n use sys_common::mutex::{MUTEX_INIT, Mutex};\n \n@@ -137,7 +138,7 @@ unsafe fn init_dtors() {\n     rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n-        DTORS = 0 as *mut _;\n+        DTORS = ptr::null_mut();\n         mem::transmute::<_, Box<Vec<(Key, Dtor)>>>(dtors);\n         assert!(DTORS.is_null()); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n@@ -250,7 +251,7 @@ unsafe fn run_dtors() {\n         for &(key, dtor) in dtors.iter() {\n             let ptr = TlsGetValue(key);\n             if !ptr.is_null() {\n-                TlsSetValue(key, 0 as *mut _);\n+                TlsSetValue(key, ptr::null_mut());\n                 dtor(ptr as *mut _);\n                 any_run = true;\n             }"}, {"sha": "12b4e56bf5209f64c9f1e1360ba7218fafda830d", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -48,9 +48,9 @@ pub enum Req {\n     RemoveTimer(libc::HANDLE, Sender<()>),\n }\n \n+unsafe impl Send for Timer {}\n unsafe impl Send for Req {}\n \n-\n fn helper(input: libc::HANDLE, messages: Receiver<Req>, _: ()) {\n     let mut objs = vec![input];\n     let mut chans = vec![];"}, {"sha": "1f181e1fa2af56bcd6b85e9825dfaa5c512872be", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -519,14 +519,14 @@ mod test {\n     fn test_unnamed_thread() {\n         Thread::scoped(move|| {\n             assert!(Thread::current().name().is_none());\n-        }).join().map_err(|_| ()).unwrap();\n+        }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_named_thread() {\n         Builder::new().name(\"ada lovelace\".to_string()).scoped(move|| {\n             assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n-        }).join().map_err(|_| ()).unwrap();\n+        }).join().ok().unwrap();\n     }\n \n     #[test]\n@@ -662,7 +662,7 @@ mod test {\n             Err(e) => {\n                 type T = &'static str;\n                 assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"static string\");\n+                assert_eq!(*e.downcast::<T>().ok().unwrap(), \"static string\");\n             }\n             Ok(()) => panic!()\n         }\n@@ -676,7 +676,7 @@ mod test {\n             Err(e) => {\n                 type T = String;\n                 assert!(e.is::<T>());\n-                assert_eq!(*e.downcast::<T>().unwrap(), \"owned string\".to_string());\n+                assert_eq!(*e.downcast::<T>().ok().unwrap(), \"owned string\".to_string());\n             }\n             Ok(()) => panic!()\n         }\n@@ -690,9 +690,9 @@ mod test {\n             Err(e) => {\n                 type T = Box<Any + Send>;\n                 assert!(e.is::<T>());\n-                let any = e.downcast::<T>().unwrap();\n+                let any = e.downcast::<T>().ok().unwrap();\n                 assert!(any.is::<u16>());\n-                assert_eq!(*any.downcast::<u16>().unwrap(), 413u16);\n+                assert_eq!(*any.downcast::<u16>().ok().unwrap(), 413u16);\n             }\n             Ok(()) => panic!()\n         }"}, {"sha": "f7a2f8e10e9265cea39f0f5c0bfd9ec2d03eea9c", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -425,7 +425,7 @@ mod imp {\n                     dtor(ptr);\n                 }\n                 ptr = DTORS.get();\n-                DTORS.set(0 as *mut _);\n+                DTORS.set(ptr::null_mut());\n             }\n         }\n     }\n@@ -459,6 +459,7 @@ mod imp {\n \n     use cell::UnsafeCell;\n     use mem;\n+    use ptr;\n     use sys_common::thread_local::StaticKey as OsStaticKey;\n \n     #[doc(hidden)]\n@@ -522,7 +523,7 @@ mod imp {\n         let key = ptr.key;\n         key.os.set(1 as *mut u8);\n         drop(ptr);\n-        key.os.set(0 as *mut u8);\n+        key.os.set(ptr::null_mut());\n     }\n }\n "}, {"sha": "2d56a8bcddfb8f66ea3f899d752fd48bc9ba3343", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -334,7 +334,8 @@ impl Div<i32> for Duration {\n     }\n }\n \n-impl fmt::String for Duration {\n+#[stable]\n+impl fmt::Display for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // technically speaking, negative duration is not valid ISO 8601,\n         // but we need to print it anyway."}, {"sha": "5f593ac7081c1a91335290d471ca49cd206deee3", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -15,7 +15,7 @@ pub use self::AbiArchitecture::*;\n \n use std::fmt;\n \n-#[derive(Copy, PartialEq)]\n+#[derive(Copy, PartialEq, Eq, Show)]\n pub enum Os {\n     OsWindows,\n     OsMacos,\n@@ -26,7 +26,7 @@ pub enum Os {\n     OsDragonfly,\n }\n \n-#[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy)]\n+#[derive(PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Clone, Copy, Show)]\n pub enum Abi {\n     // NB: This ordering MUST match the AbiDatas array below.\n     // (This is ensured by the test indices_are_correct().)\n@@ -105,8 +105,8 @@ pub fn all_names() -> Vec<&'static str> {\n \n impl Abi {\n     #[inline]\n-    pub fn index(&self) -> uint {\n-        *self as uint\n+    pub fn index(&self) -> usize {\n+        *self as usize\n     }\n \n     #[inline]\n@@ -119,25 +119,13 @@ impl Abi {\n     }\n }\n \n-impl fmt::Show for Abi {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::String for Abi {\n+impl fmt::Display for Abi {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"\\\"{}\\\"\", self.name())\n     }\n }\n \n-impl fmt::Show for Os {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n-impl fmt::String for Os {\n+impl fmt::Display for Os {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             OsLinux => \"linux\".fmt(f),"}, {"sha": "7111fe3af1fa9e81814b055716997e0f38bbb81d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 47, "deletions": 83, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -53,7 +53,6 @@ pub use self::UnboxedClosureKind::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::VariantKind::*;\n-pub use self::ViewItem_::*;\n pub use self::ViewPath_::*;\n pub use self::Visibility::*;\n pub use self::PathParameters::*;\n@@ -95,33 +94,33 @@ impl Ident {\n \n     pub fn encode_with_hygiene(&self) -> String {\n         format!(\"\\x00name_{},ctxt_{}\\x00\",\n-                self.name.uint(),\n+                self.name.usize(),\n                 self.ctxt)\n     }\n }\n \n-impl fmt::Show for Ident {\n+impl fmt::Debug for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}#{}\", self.name, self.ctxt)\n     }\n }\n \n-impl fmt::String for Ident {\n+impl fmt::Display for Ident {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(&self.name, f)\n+        fmt::Display::fmt(&self.name, f)\n     }\n }\n \n-impl fmt::Show for Name {\n+impl fmt::Debug for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Name(nm) = *self;\n         write!(f, \"{:?}({})\", token::get_name(*self).get(), nm)\n     }\n }\n \n-impl fmt::String for Name {\n+impl fmt::Display for Name {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(token::get_name(*self).get(), f)\n+        fmt::Display::fmt(token::get_name(*self).get(), f)\n     }\n }\n \n@@ -152,7 +151,7 @@ impl PartialEq for Ident {\n \n /// A SyntaxContext represents a chain of macro-expandings\n /// and renamings. Each macro expansion corresponds to\n-/// a fresh uint\n+/// a fresh usize\n \n // I'm representing this syntax context as an index into\n // a table, in order to work around a compiler bug\n@@ -181,9 +180,9 @@ impl Name {\n         }\n     }\n \n-    pub fn uint(&self) -> uint {\n+    pub fn usize(&self) -> usize {\n         let Name(nm) = *self;\n-        nm as uint\n+        nm as usize\n     }\n \n     pub fn ident(&self) -> Ident {\n@@ -511,7 +510,6 @@ impl PartialEq for MetaItem_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct Block {\n-    pub view_items: Vec<ViewItem>,\n     pub stmts: Vec<P<Stmt>>,\n     pub expr: Option<P<Expr>>,\n     pub id: NodeId,\n@@ -740,7 +738,7 @@ pub enum Expr_ {\n     ExprAssign(P<Expr>, P<Expr>),\n     ExprAssignOp(BinOp, P<Expr>, P<Expr>),\n     ExprField(P<Expr>, SpannedIdent),\n-    ExprTupField(P<Expr>, Spanned<uint>),\n+    ExprTupField(P<Expr>, Spanned<usize>),\n     ExprIndex(P<Expr>, P<Expr>),\n     ExprRange(Option<P<Expr>>, Option<P<Expr>>),\n \n@@ -839,7 +837,7 @@ pub struct SequenceRepetition {\n     /// Whether the sequence can be repeated zero (*), or one or more times (+)\n     pub op: KleeneOp,\n     /// The number of `MatchNt`s that appear in the sequence (and subsequences)\n-    pub num_captures: uint,\n+    pub num_captures: usize,\n }\n \n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n@@ -878,7 +876,7 @@ pub enum TokenTree {\n }\n \n impl TokenTree {\n-    pub fn len(&self) -> uint {\n+    pub fn len(&self) -> usize {\n         match *self {\n             TtToken(_, token::DocComment(_)) => 2,\n             TtToken(_, token::SpecialVarNt(..)) => 2,\n@@ -893,7 +891,7 @@ impl TokenTree {\n         }\n     }\n \n-    pub fn get_tt(&self, index: uint) -> TokenTree {\n+    pub fn get_tt(&self, index: usize) -> TokenTree {\n         match (self, index) {\n             (&TtToken(sp, token::DocComment(_)), 0) => {\n                 TtToken(sp, token::Pound)\n@@ -963,7 +961,7 @@ pub enum Mac_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n pub enum StrStyle {\n     CookedStr,\n-    RawStr(uint)\n+    RawStr(usize)\n }\n \n pub type Lit = Spanned<Lit_>;\n@@ -992,7 +990,7 @@ pub enum LitIntType {\n }\n \n impl LitIntType {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             UnsuffixedIntLit(_) => 0,\n             SignedIntLit(s, _) => s.suffix_len(),\n@@ -1100,20 +1098,20 @@ impl PartialEq for IntTy {\n     }\n }\n \n-impl fmt::Show for IntTy {\n+impl fmt::Debug for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n-impl fmt::String for IntTy {\n+impl fmt::Display for IntTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::int_ty_to_string(*self, None))\n     }\n }\n \n impl IntTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyIs(true) /* i */ => 1,\n             TyIs(false) /* is */ | TyI8 => 2,\n@@ -1146,7 +1144,7 @@ impl PartialEq for UintTy {\n }\n \n impl UintTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyUs(true) /* u */ => 1,\n             TyUs(false) /* us */ | TyU8 => 2,\n@@ -1155,13 +1153,13 @@ impl UintTy {\n     }\n }\n \n-impl fmt::Show for UintTy {\n+impl fmt::Debug for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n-impl fmt::String for UintTy {\n+impl fmt::Display for UintTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::uint_ty_to_string(*self, None))\n     }\n@@ -1173,20 +1171,20 @@ pub enum FloatTy {\n     TyF64,\n }\n \n-impl fmt::Show for FloatTy {\n+impl fmt::Debug for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        fmt::Display::fmt(self, f)\n     }\n }\n \n-impl fmt::String for FloatTy {\n+impl fmt::Display for FloatTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"{}\", ast_util::float_ty_to_string(*self))\n     }\n }\n \n impl FloatTy {\n-    pub fn suffix_len(&self) -> uint {\n+    pub fn suffix_len(&self) -> usize {\n         match *self {\n             TyF32 | TyF64 => 3, // add F128 handling here\n         }\n@@ -1222,24 +1220,15 @@ pub enum PrimTy {\n     TyChar\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy, Show)]\n pub enum Onceness {\n     Once,\n     Many\n }\n \n-impl fmt::Show for Onceness {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(match *self {\n-            Once => \"once\",\n-            Many => \"many\",\n-        }, f)\n-    }\n-}\n-\n-impl fmt::String for Onceness {\n+impl fmt::Display for Onceness {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(match *self {\n+        fmt::Display::fmt(match *self {\n             Once => \"once\",\n             Many => \"many\",\n         }, f)\n@@ -1274,7 +1263,7 @@ pub enum Ty_ {\n     TyPtr(MutTy),\n     /// A reference (`&'a T` or `&'a mut T`)\n     TyRptr(Option<Lifetime>, MutTy),\n-    /// A bare function (e.g. `fn(uint) -> bool`)\n+    /// A bare function (e.g. `fn(usize) -> bool`)\n     TyBareFn(P<BareFnTy>),\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(Vec<P<Ty>> ),\n@@ -1358,9 +1347,9 @@ pub enum Unsafety {\n     Normal,\n }\n \n-impl fmt::String for Unsafety {\n+impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(match *self {\n+        fmt::Display::fmt(match *self {\n             Unsafety::Normal => \"normal\",\n             Unsafety::Unsafe => \"unsafe\",\n         }, f)\n@@ -1375,7 +1364,7 @@ pub enum ImplPolarity {\n     Negative,\n }\n \n-impl fmt::Show for ImplPolarity {\n+impl fmt::Debug for ImplPolarity {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             ImplPolarity::Positive => \"positive\".fmt(f),\n@@ -1452,14 +1441,12 @@ pub struct Mod {\n     /// For `mod foo;`, the inner span ranges from the first token\n     /// to the last token in the external file.\n     pub inner: Span,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<Item>>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub struct ForeignMod {\n     pub abi: Abi,\n-    pub view_items: Vec<ViewItem>,\n     pub items: Vec<P<ForeignItem>>,\n }\n \n@@ -1518,44 +1505,13 @@ pub enum ViewPath_ {\n     /// or just\n     ///\n     /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Ident, Path, NodeId),\n+    ViewPathSimple(Ident, Path),\n \n     /// `foo::bar::*`\n-    ViewPathGlob(Path, NodeId),\n+    ViewPathGlob(Path),\n \n     /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, Vec<PathListItem> , NodeId)\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub struct ViewItem {\n-    pub node: ViewItem_,\n-    pub attrs: Vec<Attribute>,\n-    pub vis: Visibility,\n-    pub span: Span,\n-}\n-\n-impl ViewItem {\n-    pub fn id(&self) -> NodeId {\n-        match self.node {\n-            ViewItemExternCrate(_, _, id) => id,\n-            ViewItemUse(ref vp) => match vp.node {\n-                ViewPathSimple(_, _, id) => id,\n-                ViewPathGlob(_, id) => id,\n-                ViewPathList(_, _, id) => id,\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n-pub enum ViewItem_ {\n-    /// Ident: name used to refer to this crate in the code\n-    /// optional (InternedString,StrStyle): if present, this is a location\n-    /// (containing arbitrary characters) from which to fetch the crate sources\n-    /// For example, extern crate whatever = \"github.com/rust-lang/rust\"\n-    ViewItemExternCrate(Ident, Option<(InternedString,StrStyle)>, NodeId),\n-    ViewItemUse(P<ViewPath>),\n+    ViewPathList(Path, Vec<PathListItem>)\n }\n \n /// Meta-data associated with an item\n@@ -1571,7 +1527,7 @@ pub enum AttrStyle {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]\n-pub struct AttrId(pub uint);\n+pub struct AttrId(pub usize);\n \n /// Doc-comments are promoted to attributes that have is_sugared_doc = true\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n@@ -1677,6 +1633,12 @@ pub struct Item {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show)]\n pub enum Item_ {\n+    // Optional location (containing arbitrary characters) from which\n+    // to fetch the crate sources.\n+    // For example, extern crate whatever = \"github.com/rust-lang/rust\".\n+    ItemExternCrate(Option<(InternedString, StrStyle)>),\n+    ItemUse(P<ViewPath>),\n+\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n     ItemConst(P<Ty>, P<Expr>),\n     ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n@@ -1703,6 +1665,8 @@ pub enum Item_ {\n impl Item_ {\n     pub fn descriptive_variant(&self) -> &str {\n         match *self {\n+            ItemExternCrate(..) => \"extern crate\",\n+            ItemUse(..) => \"use\",\n             ItemStatic(..) => \"static item\",\n             ItemConst(..) => \"constant item\",\n             ItemFn(..) => \"function\","}, {"sha": "8a114e4b7487de4ffc804bacd494a45fa01a0124", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -46,7 +46,7 @@ impl PathElem {\n     }\n }\n \n-impl fmt::String for PathElem {\n+impl fmt::Display for PathElem {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let slot = token::get_name(self.name());\n         write!(f, \"{}\", slot)\n@@ -107,7 +107,6 @@ pub fn path_to_string<PI: Iterator<Item=PathElem>>(path: PI) -> String {\n #[derive(Copy, Show)]\n pub enum Node<'ast> {\n     NodeItem(&'ast Item),\n-    NodeViewItem(&'ast ViewItem),\n     NodeForeignItem(&'ast ForeignItem),\n     NodeTraitItem(&'ast TraitItem),\n     NodeImplItem(&'ast ImplItem),\n@@ -134,7 +133,6 @@ enum MapEntry<'ast> {\n \n     /// All the node types, with a parent ID.\n     EntryItem(NodeId, &'ast Item),\n-    EntryViewItem(NodeId, &'ast ViewItem),\n     EntryForeignItem(NodeId, &'ast ForeignItem),\n     EntryTraitItem(NodeId, &'ast TraitItem),\n     EntryImplItem(NodeId, &'ast ImplItem),\n@@ -169,7 +167,6 @@ impl<'ast> MapEntry<'ast> {\n     fn from_node(p: NodeId, node: Node<'ast>) -> MapEntry<'ast> {\n         match node {\n             NodeItem(n) => EntryItem(p, n),\n-            NodeViewItem(n) => EntryViewItem(p, n),\n             NodeForeignItem(n) => EntryForeignItem(p, n),\n             NodeTraitItem(n) => EntryTraitItem(p, n),\n             NodeImplItem(n) => EntryImplItem(p, n),\n@@ -188,7 +185,6 @@ impl<'ast> MapEntry<'ast> {\n     fn parent(self) -> Option<NodeId> {\n         Some(match self {\n             EntryItem(id, _) => id,\n-            EntryViewItem(id, _) => id,\n             EntryForeignItem(id, _) => id,\n             EntryTraitItem(id, _) => id,\n             EntryImplItem(id, _) => id,\n@@ -208,7 +204,6 @@ impl<'ast> MapEntry<'ast> {\n     fn to_node(self) -> Option<Node<'ast>> {\n         Some(match self {\n             EntryItem(_, n) => NodeItem(n),\n-            EntryViewItem(_, n) => NodeViewItem(n),\n             EntryForeignItem(_, n) => NodeForeignItem(n),\n             EntryTraitItem(_, n) => NodeTraitItem(n),\n             EntryImplItem(_, n) => NodeImplItem(n),\n@@ -264,12 +259,12 @@ pub struct Map<'ast> {\n }\n \n impl<'ast> Map<'ast> {\n-    fn entry_count(&self) -> uint {\n+    fn entry_count(&self) -> usize {\n         self.map.borrow().len()\n     }\n \n     fn find_entry(&self, id: NodeId) -> Option<MapEntry<'ast>> {\n-        self.map.borrow().get(id as uint).map(|e| *e)\n+        self.map.borrow().get(id as usize).map(|e| *e)\n     }\n \n     pub fn krate(&self) -> &'ast Crate {\n@@ -341,13 +336,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn expect_view_item(&self, id: NodeId) -> &'ast ViewItem {\n-        match self.find(id) {\n-            Some(NodeViewItem(view_item)) => view_item,\n-            _ => panic!(\"expected view item, found {}\", self.node_to_string(id))\n-        }\n-    }\n-\n     pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {\n@@ -525,15 +513,14 @@ impl<'ast> Map<'ast> {\n         NodesMatchingSuffix {\n             map: self,\n             item_name: parts.last().unwrap(),\n-            in_which: &parts[..(parts.len() - 1)],\n+            in_which: &parts[..parts.len() - 1],\n             idx: 0,\n         }\n     }\n \n     pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n         let sp = match self.find(id) {\n             Some(NodeItem(item)) => item.span,\n-            Some(NodeViewItem(item)) => item.span,\n             Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n             Some(NodeTraitItem(trait_method)) => {\n                 match *trait_method {\n@@ -652,7 +639,7 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n     fn next(&mut self) -> Option<NodeId> {\n         loop {\n             let idx = self.idx;\n-            if idx as uint >= self.map.entry_count() {\n+            if idx as usize >= self.map.entry_count() {\n                 return None;\n             }\n             self.idx += 1;\n@@ -744,10 +731,10 @@ impl<'ast> NodeCollector<'ast> {\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'ast>) {\n         debug!(\"ast_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n-        if id as uint >= len {\n-            self.map.extend(repeat(NotPresent).take(id as uint - len + 1));\n+        if id as usize >= len {\n+            self.map.extend(repeat(NotPresent).take(id as usize - len + 1));\n         }\n-        self.map[id as uint] = entry;\n+        self.map[id as usize] = entry;\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'ast>) {\n@@ -826,11 +813,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.parent = parent;\n     }\n \n-    fn visit_view_item(&mut self, item: &'ast ViewItem) {\n-        self.insert(item.id(), NodeViewItem(item));\n-        visit::walk_view_item(self, item);\n-    }\n-\n     fn visit_pat(&mut self, pat: &'ast Pat) {\n         self.insert(pat.id, match pat.node {\n             // Note: this is at least *potentially* a pattern...\n@@ -904,7 +886,6 @@ pub fn map_crate<'ast, F: FoldOps>(forest: &'ast mut Forest, fold_ops: F) -> Map\n     let krate = mem::replace(&mut forest.krate, Crate {\n         module: Mod {\n             inner: DUMMY_SP,\n-            view_items: vec![],\n             items: vec![],\n         },\n         attrs: vec![],\n@@ -1036,7 +1017,6 @@ impl<'a> NodePrinter for pprust::State<'a> {\n     fn print_node(&mut self, node: &Node) -> IoResult<()> {\n         match *node {\n             NodeItem(a)        => self.print_item(&*a),\n-            NodeViewItem(a)    => self.print_view_item(&*a),\n             NodeForeignItem(a) => self.print_foreign_item(&*a),\n             NodeTraitItem(a)   => self.print_trait_method(&*a),\n             NodeImplItem(a)    => self.print_impl_item(&*a),\n@@ -1065,6 +1045,8 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             let item_str = match item.node {\n+                ItemExternCrate(..) => \"extern crate\",\n+                ItemUse(..) => \"use\",\n                 ItemStatic(..) => \"static\",\n                 ItemConst(..) => \"const\",\n                 ItemFn(..) => \"fn\",\n@@ -1079,9 +1061,6 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n             };\n             format!(\"{} {}{}\", item_str, path_str, id_str)\n         }\n-        Some(NodeViewItem(item)) => {\n-            format!(\"view item {}{}\", pprust::view_item_to_string(&*item), id_str)\n-        }\n         Some(NodeForeignItem(item)) => {\n             let path_str = map.path_to_str_with_ident(id, item.ident);\n             format!(\"foreign item {}{}\", path_str, id_str)"}, {"sha": "892b3c1e7f2b7aee9cfdfffee53261d127de1559", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 29, "deletions": 77, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -156,7 +156,7 @@ pub fn int_ty_max(t: IntTy) -> u64 {\n }\n \n /// Get a string representation of an unsigned int type, with its value.\n-/// We want to avoid \"42uint\" in favor of \"42u\"\n+/// We want to avoid \"42u\" in favor of \"42us\". \"42uint\" is right out.\n pub fn uint_ty_to_string(t: UintTy, val: Option<u64>) -> String {\n     let s = match t {\n         TyUs(true) if val.is_some() => \"u\",\n@@ -319,25 +319,25 @@ pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n }\n \n /// Maps a binary operator to its precedence\n-pub fn operator_prec(op: ast::BinOp) -> uint {\n+pub fn operator_prec(op: ast::BinOp) -> usize {\n   match op {\n       // 'as' sits here with 12\n-      BiMul | BiDiv | BiRem     => 11u,\n-      BiAdd | BiSub             => 10u,\n-      BiShl | BiShr             =>  9u,\n-      BiBitAnd                  =>  8u,\n-      BiBitXor                  =>  7u,\n-      BiBitOr                   =>  6u,\n-      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3u,\n-      BiAnd                     =>  2u,\n-      BiOr                      =>  1u\n+      BiMul | BiDiv | BiRem     => 11us,\n+      BiAdd | BiSub             => 10us,\n+      BiShl | BiShr             =>  9us,\n+      BiBitAnd                  =>  8us,\n+      BiBitXor                  =>  7us,\n+      BiBitOr                   =>  6us,\n+      BiLt | BiLe | BiGe | BiGt | BiEq | BiNe => 3us,\n+      BiAnd                     =>  2us,\n+      BiOr                      =>  1us\n   }\n }\n \n /// Precedence of the `as` operator, which is a binary operator\n /// not appearing in the prior table.\n #[allow(non_upper_case_globals)]\n-pub static as_prec: uint = 12u;\n+pub static as_prec: usize = 12us;\n \n pub fn empty_generics() -> Generics {\n     Generics {\n@@ -410,37 +410,6 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         visit::walk_mod(self, module)\n     }\n \n-    fn visit_view_item(&mut self, view_item: &ViewItem) {\n-        if !self.pass_through_items {\n-            if self.visited_outermost {\n-                return;\n-            } else {\n-                self.visited_outermost = true;\n-            }\n-        }\n-        match view_item.node {\n-            ViewItemExternCrate(_, _, node_id) => {\n-                self.operation.visit_id(node_id)\n-            }\n-            ViewItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ViewPathSimple(_, _, node_id) |\n-                    ViewPathGlob(_, node_id) => {\n-                        self.operation.visit_id(node_id)\n-                    }\n-                    ViewPathList(_, ref paths, node_id) => {\n-                        self.operation.visit_id(node_id);\n-                        for path in paths.iter() {\n-                            self.operation.visit_id(path.node.id())\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, view_item);\n-        self.visited_outermost = false;\n-    }\n-\n     fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n         self.operation.visit_id(foreign_item.id);\n         visit::walk_foreign_item(self, foreign_item)\n@@ -456,10 +425,24 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n \n         self.operation.visit_id(item.id);\n-        if let ItemEnum(ref enum_definition, _) = item.node {\n-            for variant in enum_definition.variants.iter() {\n-                self.operation.visit_id(variant.node.id)\n+        match item.node {\n+            ItemUse(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathSimple(_, _) |\n+                    ViewPathGlob(_) => {}\n+                    ViewPathList(_, ref paths) => {\n+                        for path in paths.iter() {\n+                            self.operation.visit_id(path.node.id())\n+                        }\n+                    }\n+                }\n+            }\n+            ItemEnum(ref enum_definition, _) => {\n+                for variant in enum_definition.variants.iter() {\n+                    self.operation.visit_id(variant.node.id)\n+                }\n             }\n+            _ => {}\n         }\n \n         visit::walk_item(self, item);\n@@ -662,37 +645,6 @@ pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n     walk_pat_(pat, &mut it)\n }\n \n-pub trait EachViewItem {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool;\n-}\n-\n-struct EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    callback: F,\n-}\n-\n-impl<'v, F> Visitor<'v> for EachViewItemData<F> where F: FnMut(&ast::ViewItem) -> bool {\n-    fn visit_view_item(&mut self, view_item: &ast::ViewItem) {\n-        let _ = (self.callback)(view_item);\n-    }\n-}\n-\n-impl EachViewItem for ast::Crate {\n-    fn each_view_item<F>(&self, f: F) -> bool where F: FnMut(&ast::ViewItem) -> bool {\n-        let mut visit = EachViewItemData {\n-            callback: f,\n-        };\n-        visit::walk_crate(&mut visit, self);\n-        true\n-    }\n-}\n-\n-pub fn view_path_id(p: &ViewPath) -> NodeId {\n-    match p.node {\n-        ViewPathSimple(_, _, id) | ViewPathGlob(_, id)\n-        | ViewPathList(_, _, id) => id\n-    }\n-}\n-\n /// Returns true if the given struct def is tuple-like; i.e. that its fields\n /// are unnamed.\n pub fn struct_def_is_tuple_like(struct_def: &ast::StructDef) -> bool {"}, {"sha": "59471488af9ad8045530e86249fb60ff8c29ee3c", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -170,7 +170,7 @@ pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     P(dummy_spanned(MetaWord(name)))\n }\n \n-thread_local! { static NEXT_ATTR_ID: Cell<uint> = Cell::new(0) }\n+thread_local! { static NEXT_ATTR_ID: Cell<usize> = Cell::new(0) }\n \n pub fn mk_attr_id() -> AttrId {\n     let id = NEXT_ATTR_ID.with(|slot| {\n@@ -358,9 +358,9 @@ pub enum StabilityLevel {\n     Locked\n }\n \n-impl fmt::String for StabilityLevel {\n+impl fmt::Display for StabilityLevel {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Show::fmt(self, f)\n+        fmt::Debug::fmt(self, f)\n     }\n }\n "}, {"sha": "a5e10f42750b8be8966895a409774ba9ec98de13", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -30,8 +30,8 @@ use libc::c_uint;\n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n pub trait Pos {\n-    fn from_uint(n: uint) -> Self;\n-    fn to_uint(&self) -> uint;\n+    fn from_usize(n: usize) -> Self;\n+    fn to_usize(&self) -> usize;\n }\n \n /// A byte offset. Keep this small (currently 32-bits), as AST contains\n@@ -43,50 +43,50 @@ pub struct BytePos(pub u32);\n /// is not equivalent to a character offset. The CodeMap will convert BytePos\n /// values to CharPos values as necessary.\n #[derive(Copy, PartialEq, Hash, PartialOrd, Show)]\n-pub struct CharPos(pub uint);\n+pub struct CharPos(pub usize);\n \n // FIXME: Lots of boilerplate in these impls, but so far my attempts to fix\n // have been unsuccessful\n \n impl Pos for BytePos {\n-    fn from_uint(n: uint) -> BytePos { BytePos(n as u32) }\n-    fn to_uint(&self) -> uint { let BytePos(n) = *self; n as uint }\n+    fn from_usize(n: usize) -> BytePos { BytePos(n as u32) }\n+    fn to_usize(&self) -> usize { let BytePos(n) = *self; n as usize }\n }\n \n impl Add for BytePos {\n     type Output = BytePos;\n \n     fn add(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_uint() + rhs.to_uint()) as u32)\n+        BytePos((self.to_usize() + rhs.to_usize()) as u32)\n     }\n }\n \n impl Sub for BytePos {\n     type Output = BytePos;\n \n     fn sub(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_uint() - rhs.to_uint()) as u32)\n+        BytePos((self.to_usize() - rhs.to_usize()) as u32)\n     }\n }\n \n impl Pos for CharPos {\n-    fn from_uint(n: uint) -> CharPos { CharPos(n) }\n-    fn to_uint(&self) -> uint { let CharPos(n) = *self; n }\n+    fn from_usize(n: usize) -> CharPos { CharPos(n) }\n+    fn to_usize(&self) -> usize { let CharPos(n) = *self; n }\n }\n \n impl Add for CharPos {\n     type Output = CharPos;\n \n     fn add(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_uint() + rhs.to_uint())\n+        CharPos(self.to_usize() + rhs.to_usize())\n     }\n }\n \n impl Sub for CharPos {\n     type Output = CharPos;\n \n     fn sub(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_uint() - rhs.to_uint())\n+        CharPos(self.to_usize() - rhs.to_usize())\n     }\n }\n \n@@ -173,7 +173,7 @@ pub struct Loc {\n     /// Information about the original source\n     pub file: Rc<FileMap>,\n     /// The (1-based) line number\n-    pub line: uint,\n+    pub line: usize,\n     /// The (0-based) column offset\n     pub col: CharPos\n }\n@@ -183,13 +183,13 @@ pub struct Loc {\n // perhaps they should just be removed.\n pub struct LocWithOpt {\n     pub filename: FileName,\n-    pub line: uint,\n+    pub line: usize,\n     pub col: CharPos,\n     pub file: Option<Rc<FileMap>>,\n }\n \n // used to be structural records. Better names, anyone?\n-pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: uint }\n+pub struct FileMapAndLine { pub fm: Rc<FileMap>, pub line: usize }\n pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n \n /// The syntax with which a macro was invoked.\n@@ -258,7 +258,7 @@ pub type FileName = String;\n \n pub struct FileLines {\n     pub file: Rc<FileMap>,\n-    pub lines: Vec<uint>\n+    pub lines: Vec<usize>\n }\n \n /// Identifies an offset of a multi-byte character in a FileMap\n@@ -267,7 +267,7 @@ pub struct MultiByteChar {\n     /// The absolute offset of the character in the CodeMap\n     pub pos: BytePos,\n     /// The number of bytes, >=2\n-    pub bytes: uint,\n+    pub bytes: usize,\n }\n \n /// A single source in the CodeMap\n@@ -306,11 +306,11 @@ impl FileMap {\n \n     /// get a line from the list of pre-computed line-beginnings\n     ///\n-    pub fn get_line(&self, line_number: uint) -> Option<String> {\n+    pub fn get_line(&self, line_number: usize) -> Option<String> {\n         let lines = self.lines.borrow();\n         lines.get(line_number).map(|&line| {\n             let begin: BytePos = line - self.start_pos;\n-            let begin = begin.to_uint();\n+            let begin = begin.to_usize();\n             let slice = &self.src[begin..];\n             match slice.find('\\n') {\n                 Some(e) => &slice[..e],\n@@ -319,7 +319,7 @@ impl FileMap {\n         })\n     }\n \n-    pub fn record_multibyte_char(&self, pos: BytePos, bytes: uint) {\n+    pub fn record_multibyte_char(&self, pos: BytePos, bytes: usize) {\n         assert!(bytes >=2 && bytes <= 4);\n         let mbc = MultiByteChar {\n             pos: pos,\n@@ -351,7 +351,7 @@ impl CodeMap {\n         let mut files = self.files.borrow_mut();\n         let start_pos = match files.last() {\n             None => 0,\n-            Some(last) => last.start_pos.to_uint() + last.src.len(),\n+            Some(last) => last.start_pos.to_usize() + last.src.len(),\n         };\n \n         // Remove utf-8 BOM if any.\n@@ -374,7 +374,7 @@ impl CodeMap {\n         let filemap = Rc::new(FileMap {\n             name: filename,\n             src: src.to_string(),\n-            start_pos: Pos::from_uint(start_pos),\n+            start_pos: Pos::from_usize(start_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),\n         });\n@@ -389,7 +389,7 @@ impl CodeMap {\n         (format!(\"<{}:{}:{}>\",\n                  pos.file.name,\n                  pos.line,\n-                 pos.col.to_uint() + 1)).to_string()\n+                 pos.col.to_usize() + 1)).to_string()\n     }\n \n     /// Lookup source information about a BytePos\n@@ -417,9 +417,9 @@ impl CodeMap {\n         return (format!(\"{}:{}:{}: {}:{}\",\n                         lo.filename,\n                         lo.line,\n-                        lo.col.to_uint() + 1,\n+                        lo.col.to_usize() + 1,\n                         hi.line,\n-                        hi.col.to_uint() + 1)).to_string()\n+                        hi.col.to_usize() + 1)).to_string()\n     }\n \n     pub fn span_to_filename(&self, sp: Span) -> FileName {\n@@ -430,7 +430,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in range(lo.line - 1u, hi.line as uint) {\n+        for i in range(lo.line - 1us, hi.line as usize) {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}\n@@ -447,7 +447,7 @@ impl CodeMap {\n         if begin.fm.start_pos != end.fm.start_pos {\n             None\n         } else {\n-            Some((&begin.fm.src[begin.pos.to_uint()..end.pos.to_uint()]).to_string())\n+            Some((&begin.fm.src[begin.pos.to_usize()..end.pos.to_usize()]).to_string())\n         }\n     }\n \n@@ -484,24 +484,24 @@ impl CodeMap {\n                 total_extra_bytes += mbc.bytes - 1;\n                 // We should never see a byte position in the middle of a\n                 // character\n-                assert!(bpos.to_uint() >= mbc.pos.to_uint() + mbc.bytes);\n+                assert!(bpos.to_usize() >= mbc.pos.to_usize() + mbc.bytes);\n             } else {\n                 break;\n             }\n         }\n \n-        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n-        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n+        assert!(map.start_pos.to_usize() + total_extra_bytes <= bpos.to_usize());\n+        CharPos(bpos.to_usize() - map.start_pos.to_usize() - total_extra_bytes)\n     }\n \n-    fn lookup_filemap_idx(&self, pos: BytePos) -> uint {\n+    fn lookup_filemap_idx(&self, pos: BytePos) -> usize {\n         let files = self.files.borrow();\n         let files = &*files;\n         let len = files.len();\n-        let mut a = 0u;\n+        let mut a = 0us;\n         let mut b = len;\n-        while b - a > 1u {\n-            let m = (a + b) / 2u;\n+        while b - a > 1us {\n+            let m = (a + b) / 2us;\n             if files[m].start_pos > pos {\n                 b = m;\n             } else {\n@@ -520,13 +520,13 @@ impl CodeMap {\n             }\n             if a == 0 {\n                 panic!(\"position {} does not resolve to a source location\",\n-                      pos.to_uint());\n+                      pos.to_usize());\n             }\n             a -= 1;\n         }\n         if a >= len {\n             panic!(\"position {} does not resolve to a source location\",\n-                  pos.to_uint())\n+                  pos.to_usize())\n         }\n \n         return a;\n@@ -537,12 +537,12 @@ impl CodeMap {\n \n         let files = self.files.borrow();\n         let f = (*files)[idx].clone();\n-        let mut a = 0u;\n+        let mut a = 0us;\n         {\n             let lines = f.lines.borrow();\n             let mut b = lines.len();\n-            while b - a > 1u {\n-                let m = (a + b) / 2u;\n+            while b - a > 1us {\n+                let m = (a + b) / 2us;\n                 if (*lines)[m] > pos { b = m; } else { a = m; }\n             }\n         }\n@@ -551,7 +551,7 @@ impl CodeMap {\n \n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n-        let line = a + 1u; // Line numbers start at 1\n+        let line = a + 1us; // Line numbers start at 1\n         let chpos = self.bytepos_to_file_charpos(pos);\n         let linebpos = (*f.lines.borrow())[a];\n         let linechpos = self.bytepos_to_file_charpos(linebpos);\n@@ -579,7 +579,7 @@ impl CodeMap {\n     {\n         match id {\n             NO_EXPANSION => f(None),\n-            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as uint]))\n+            ExpnId(i) => f(Some(&(*self.expansions.borrow())[i as usize]))\n         }\n     }\n \n@@ -762,7 +762,7 @@ mod test {\n \n         assert_eq!(file_lines.file.name, \"blork.rs\");\n         assert_eq!(file_lines.lines.len(), 1);\n-        assert_eq!(file_lines.lines[0], 1u);\n+        assert_eq!(file_lines.lines[0], 1us);\n     }\n \n     #[test]"}, {"sha": "3eaac0fe333e8e3026f69abd6ca6b0f7d8f52653", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 32, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -63,28 +63,13 @@ pub fn strip_items<F>(krate: ast::Crate, in_cfg: F) -> ast::Crate where\n     ctxt.fold_crate(krate)\n }\n \n-fn filter_view_item<F>(cx: &mut Context<F>,\n-                       view_item: ast::ViewItem)\n-                       -> Option<ast::ViewItem> where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    if view_item_in_cfg(cx, &view_item) {\n-        Some(view_item)\n-    } else {\n-        None\n-    }\n-}\n-\n fn fold_mod<F>(cx: &mut Context<F>,\n-               ast::Mod {inner,\n-               view_items, items}: ast::Mod) -> ast::Mod where\n+               ast::Mod {inner, items}: ast::Mod)\n+               -> ast::Mod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::Mod {\n         inner: inner,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter().flat_map(|a| {\n             cx.fold_item(a).into_iter()\n         }).collect()\n@@ -104,15 +89,12 @@ fn filter_foreign_item<F>(cx: &mut Context<F>,\n }\n \n fn fold_foreign_mod<F>(cx: &mut Context<F>,\n-                       ast::ForeignMod {abi, view_items, items}: ast::ForeignMod)\n+                       ast::ForeignMod {abi, items}: ast::ForeignMod)\n                        -> ast::ForeignMod where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n     ast::ForeignMod {\n         abi: abi,\n-        view_items: view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect(),\n         items: items.into_iter()\n                     .filter_map(|a| filter_foreign_item(cx, a))\n                     .collect()\n@@ -216,18 +198,14 @@ fn retain_stmt<F>(cx: &mut Context<F>, stmt: &ast::Stmt) -> bool where\n fn fold_block<F>(cx: &mut Context<F>, b: P<ast::Block>) -> P<ast::Block> where\n     F: FnMut(&[ast::Attribute]) -> bool\n {\n-    b.map(|ast::Block {id, view_items, stmts, expr, rules, span}| {\n+    b.map(|ast::Block {id, stmts, expr, rules, span}| {\n         let resulting_stmts: Vec<P<ast::Stmt>> =\n             stmts.into_iter().filter(|a| retain_stmt(cx, &**a)).collect();\n         let resulting_stmts = resulting_stmts.into_iter()\n             .flat_map(|stmt| cx.fold_stmt(stmt).into_iter())\n             .collect();\n-        let filtered_view_items = view_items.into_iter().filter_map(|a| {\n-            filter_view_item(cx, a).map(|x| cx.fold_view_item(x))\n-        }).collect();\n         ast::Block {\n             id: id,\n-            view_items: filtered_view_items,\n             stmts: resulting_stmts,\n             expr: expr.map(|x| cx.fold_expr(x)),\n             rules: rules,\n@@ -267,12 +245,6 @@ fn foreign_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ForeignItem) -> bool\n     return (cx.in_cfg)(item.attrs.as_slice());\n }\n \n-fn view_item_in_cfg<F>(cx: &mut Context<F>, item: &ast::ViewItem) -> bool where\n-    F: FnMut(&[ast::Attribute]) -> bool\n-{\n-    return (cx.in_cfg)(item.attrs.as_slice());\n-}\n-\n fn trait_method_in_cfg<F>(cx: &mut Context<F>, meth: &ast::TraitItem) -> bool where\n     F: FnMut(&[ast::Attribute]) -> bool\n {"}, {"sha": "0c7f6befc4e3e1b884c5a95df1828e5f050c559b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -26,7 +26,7 @@ use term::WriterWrapper;\n use term;\n \n /// maximum number of lines we will print for each error; arbitrary.\n-static MAX_LINES: uint = 6u;\n+static MAX_LINES: usize = 6us;\n \n #[derive(Clone, Copy)]\n pub enum RenderSpan {\n@@ -92,6 +92,10 @@ impl SpanHandler {\n         self.handler.emit(Some((&self.cm, sp)), msg, Fatal);\n         panic!(FatalError);\n     }\n+    pub fn span_fatal_with_code(&self, sp: Span, msg: &str, code: &str) -> ! {\n+        self.handler.emit_with_code(Some((&self.cm, sp)), msg, code, Fatal);\n+        panic!(FatalError);\n+    }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n         self.handler.emit(Some((&self.cm, sp)), msg, Error);\n         self.handler.bump_err_count();\n@@ -137,7 +141,7 @@ impl SpanHandler {\n /// (fatal, bug, unimpl) may cause immediate exit,\n /// others log errors for later reporting.\n pub struct Handler {\n-    err_count: Cell<uint>,\n+    err_count: Cell<usize>,\n     emit: RefCell<Box<Emitter + Send>>,\n }\n \n@@ -151,20 +155,20 @@ impl Handler {\n         self.bump_err_count();\n     }\n     pub fn bump_err_count(&self) {\n-        self.err_count.set(self.err_count.get() + 1u);\n+        self.err_count.set(self.err_count.get() + 1us);\n     }\n-    pub fn err_count(&self) -> uint {\n+    pub fn err_count(&self) -> usize {\n         self.err_count.get()\n     }\n     pub fn has_errors(&self) -> bool {\n-        self.err_count.get()> 0u\n+        self.err_count.get() > 0us\n     }\n     pub fn abort_if_errors(&self) {\n         let s;\n         match self.err_count.get() {\n-          0u => return,\n-          1u => s = \"aborting due to previous error\".to_string(),\n-          _  => {\n+          0us => return,\n+          1us => s = \"aborting due to previous error\".to_string(),\n+          _   => {\n             s = format!(\"aborting due to {} previous errors\",\n                         self.err_count.get());\n           }\n@@ -235,9 +239,9 @@ pub enum Level {\n     Help,\n }\n \n-impl fmt::String for Level {\n+impl fmt::Display for Level {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        use std::fmt::String;\n+        use std::fmt::Display;\n \n         match *self {\n             Bug => \"error: internal compiler error\".fmt(f),\n@@ -280,7 +284,7 @@ fn print_maybe_styled(w: &mut EmitterWriter,\n             // to be miscolored. We assume this is rare enough that we don't\n             // have to worry about it.\n             if msg.ends_with(\"\\n\") {\n-                try!(t.write_str(&msg[..(msg.len()-1)]));\n+                try!(t.write_str(&msg[..msg.len()-1]));\n                 try!(t.reset());\n                 try!(t.write_str(\"\\n\"));\n             } else {\n@@ -448,7 +452,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n     let mut elided = false;\n     let mut display_lines = &lines.lines[];\n     if display_lines.len() > MAX_LINES {\n-        display_lines = &display_lines[0u..MAX_LINES];\n+        display_lines = &display_lines[0us..MAX_LINES];\n         elided = true;\n     }\n     // Print the offending lines\n@@ -459,32 +463,32 @@ fn highlight_lines(err: &mut EmitterWriter,\n         }\n     }\n     if elided {\n-        let last_line = display_lines[display_lines.len() - 1u];\n-        let s = format!(\"{}:{} \", fm.name, last_line + 1u);\n+        let last_line = display_lines[display_lines.len() - 1us];\n+        let s = format!(\"{}:{} \", fm.name, last_line + 1us);\n         try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n     }\n \n     // FIXME (#3260)\n     // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1u {\n+    if lines.lines.len() == 1us {\n         let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0u;\n-        let mut num = (lines.lines[0] + 1u) / 10u;\n+        let mut digits = 0us;\n+        let mut num = (lines.lines[0] + 1us) / 10us;\n \n         // how many digits must be indent past?\n-        while num > 0u { num /= 10u; digits += 1u; }\n+        while num > 0us { num /= 10us; digits += 1us; }\n \n         // indent past |name:## | and the 0-offset column location\n-        let left = fm.name.len() + digits + lo.col.to_uint() + 3u;\n+        let left = fm.name.len() + digits + lo.col.to_usize() + 3us;\n         let mut s = String::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.len() + digits + 3u;\n+        let skip = fm.name.len() + digits + 3us;\n         for _ in range(0, skip) {\n             s.push(' ');\n         }\n         if let Some(orig) = fm.get_line(lines.lines[0]) {\n-            for pos in range(0u, left - skip) {\n+            for pos in range(0us, left - skip) {\n                 let cur_char = orig.as_bytes()[pos] as char;\n                 // Whenever a tab occurs on the previous line, we insert one on\n                 // the error-point-squiggly-line as well (instead of a space).\n@@ -502,7 +506,7 @@ fn highlight_lines(err: &mut EmitterWriter,\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n-            let num_squigglies = hi.col.to_uint() - lo.col.to_uint() - 1u;\n+            let num_squigglies = hi.col.to_usize() - lo.col.to_usize() - 1us;\n             for _ in range(0, num_squigglies) {\n                 s.push('~');\n             }\n@@ -551,7 +555,7 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1]+1);\n     let hi = cm.lookup_char_pos(sp.hi);\n     // Span seems to use half-opened interval, so subtract 1\n-    let skip = last_line_start.len() + hi.col.to_uint() - 1;\n+    let skip = last_line_start.len() + hi.col.to_usize() - 1;\n     let mut s = String::new();\n     for _ in range(0, skip) {\n         s.push(' ');"}, {"sha": "9321d3ca3df1141196a45917db933c208d3fb56d", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -14,6 +14,14 @@ macro_rules! register_diagnostic {\n     ($code:tt) => (__register_diagnostic! { $code })\n }\n \n+#[macro_export]\n+macro_rules! span_fatal {\n+    ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n+        __diagnostic_used!($code);\n+        $session.span_fatal_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n+    })\n+}\n+\n #[macro_export]\n macro_rules! span_err {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n@@ -51,3 +59,9 @@ macro_rules! register_diagnostics {\n     )\n }\n \n+#[macro_export]\n+macro_rules! register_long_diagnostics {\n+    ($($code:tt: $description:tt),*) => (\n+        $(register_diagnostic! { $code, $description })*\n+    )\n+}"}, {"sha": "bd5247bbad6a78f9b6e4e2335afd910f0a9b174a", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::cell::RefCell;\n-use std::collections::HashMap;\n+use std::collections::BTreeMap;\n use ast;\n use ast::{Ident, Name, TokenTree};\n use codemap::Span;\n@@ -19,26 +19,26 @@ use parse::token;\n use ptr::P;\n \n thread_local! {\n-    static REGISTERED_DIAGNOSTICS: RefCell<HashMap<Name, Option<Name>>> = {\n-        RefCell::new(HashMap::new())\n+    static REGISTERED_DIAGNOSTICS: RefCell<BTreeMap<Name, Option<Name>>> = {\n+        RefCell::new(BTreeMap::new())\n     }\n }\n thread_local! {\n-    static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n-        RefCell::new(HashMap::new())\n+    static USED_DIAGNOSTICS: RefCell<BTreeMap<Name, Span>> = {\n+        RefCell::new(BTreeMap::new())\n     }\n }\n \n fn with_registered_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut HashMap<Name, Option<Name>>) -> T,\n+    F: FnOnce(&mut BTreeMap<Name, Option<Name>>) -> T,\n {\n     REGISTERED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n     })\n }\n \n fn with_used_diagnostics<T, F>(f: F) -> T where\n-    F: FnOnce(&mut HashMap<Name, Span>) -> T,\n+    F: FnOnce(&mut BTreeMap<Name, Span>) -> T,\n {\n     USED_DIAGNOSTICS.with(move |slot| {\n         f(&mut *slot.borrow_mut())\n@@ -65,6 +65,13 @@ pub fn expand_diagnostic_used<'cx>(ecx: &'cx mut ExtCtxt,\n         }\n         ()\n     });\n+    with_registered_diagnostics(|diagnostics| {\n+        if !diagnostics.contains_key(&code.name) {\n+            ecx.span_err(span, &format!(\n+                \"used diagnostic code {} not registered\", token::get_ident(code).get()\n+            )[]);\n+        }\n+    });\n     MacExpr::new(quote_expr!(ecx, ()))\n }\n "}, {"sha": "9128bc05f6f3d48f038d3de752499281cfa77511", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -548,7 +548,7 @@ pub struct ExtCtxt<'a> {\n     pub exported_macros: Vec<ast::MacroDef>,\n \n     pub syntax_env: SyntaxEnv,\n-    pub recursion_count: uint,\n+    pub recursion_count: usize,\n }\n \n impl<'a> ExtCtxt<'a> {"}, {"sha": "92619cf42e4d197a517990dddd2f78abb5de6f6d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 45, "deletions": 50, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -97,7 +97,6 @@ pub trait AstBuilder {\n              expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block>;\n     fn block_all(&self, span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block>;\n \n@@ -116,7 +115,7 @@ pub trait AstBuilder {\n     fn expr_mut_addr_of(&self, sp: Span, e: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_field_access(&self, span: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr>;\n     fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>,\n-                             idx: uint) -> P<ast::Expr>;\n+                             idx: usize) -> P<ast::Expr>;\n     fn expr_call(&self, span: Span, expr: P<ast::Expr>, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_call_ident(&self, span: Span, id: ast::Ident, args: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_call_global(&self, sp: Span, fn_path: Vec<ast::Ident>,\n@@ -134,8 +133,8 @@ pub trait AstBuilder {\n \n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr>;\n \n-    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr>;\n-    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr>;\n+    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;\n+    fn expr_int(&self, sp: Span, i: isize) -> P<ast::Expr>;\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n \n@@ -242,7 +241,7 @@ pub trait AstBuilder {\n \n     fn item_mod(&self, span: Span, inner_span: Span,\n                 name: Ident, attrs: Vec<ast::Attribute>,\n-                vi: Vec<ast::ViewItem> , items: Vec<P<ast::Item>> ) -> P<ast::Item>;\n+                items: Vec<P<ast::Item>>) -> P<ast::Item>;\n \n     fn item_static(&self,\n                    span: Span,\n@@ -280,15 +279,15 @@ pub trait AstBuilder {\n                        value: ast::Lit_)\n                        -> P<ast::MetaItem>;\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem;\n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem;\n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem;\n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem;\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item>;\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item>;\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item>;\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item>;\n }\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n@@ -519,7 +518,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn block(&self, span: Span, stmts: Vec<P<ast::Stmt>>,\n              expr: Option<P<Expr>>) -> P<ast::Block> {\n-        self.block_all(span, Vec::new(), stmts, expr)\n+        self.block_all(span, stmts, expr)\n     }\n \n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> P<ast::Stmt> {\n@@ -528,15 +527,13 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn block_expr(&self, expr: P<ast::Expr>) -> P<ast::Block> {\n-        self.block_all(expr.span, Vec::new(), Vec::new(), Some(expr))\n+        self.block_all(expr.span, Vec::new(), Some(expr))\n     }\n     fn block_all(&self,\n                  span: Span,\n-                 view_items: Vec<ast::ViewItem>,\n                  stmts: Vec<P<ast::Stmt>>,\n                  expr: Option<P<ast::Expr>>) -> P<ast::Block> {\n             P(ast::Block {\n-               view_items: view_items,\n                stmts: stmts,\n                expr: expr,\n                id: ast::DUMMY_NODE_ID,\n@@ -579,17 +576,17 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_field_access(&self, sp: Span, expr: P<ast::Expr>, ident: ast::Ident) -> P<ast::Expr> {\n         let field_name = token::get_ident(ident);\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_uint(field_name.get().len()),\n+            lo: sp.lo - Pos::from_usize(field_name.get().len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };\n \n         let id = Spanned { node: ident, span: field_span };\n         self.expr(sp, ast::ExprField(expr, id))\n     }\n-    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: uint) -> P<ast::Expr> {\n+    fn expr_tup_field_access(&self, sp: Span, expr: P<ast::Expr>, idx: usize) -> P<ast::Expr> {\n         let field_span = Span {\n-            lo: sp.lo - Pos::from_uint(idx.to_string().len()),\n+            lo: sp.lo - Pos::from_usize(idx.to_string().len()),\n             hi: sp.hi,\n             expn_id: sp.expn_id,\n         };\n@@ -641,10 +638,10 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_lit(&self, sp: Span, lit: ast::Lit_) -> P<ast::Expr> {\n         self.expr(sp, ast::ExprLit(P(respan(sp, lit))))\n     }\n-    fn expr_uint(&self, span: Span, i: uint) -> P<ast::Expr> {\n+    fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n         self.expr_lit(span, ast::LitInt(i as u64, ast::UnsignedIntLit(ast::TyUs(false))))\n     }\n-    fn expr_int(&self, sp: Span, i: int) -> P<ast::Expr> {\n+    fn expr_int(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs(false),\n                                                                   ast::Sign::new(i))))\n     }\n@@ -710,7 +707,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n         let expr_file = self.expr_str(span,\n                                       token::intern_and_get_ident(&loc.file.name[]));\n-        let expr_line = self.expr_uint(span, loc.line);\n+        let expr_line = self.expr_usize(span, loc.line);\n         let expr_file_line_tuple = self.expr_tuple(span, vec!(expr_file, expr_line));\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n         self.expr_call_global(\n@@ -1031,16 +1028,14 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn item_mod(&self, span: Span, inner_span: Span, name: Ident,\n-                attrs: Vec<ast::Attribute> ,\n-                vi: Vec<ast::ViewItem> ,\n-                items: Vec<P<ast::Item>> ) -> P<ast::Item> {\n+                attrs: Vec<ast::Attribute>,\n+                items: Vec<P<ast::Item>>) -> P<ast::Item> {\n         self.item(\n             span,\n             name,\n             attrs,\n             ast::ItemMod(ast::Mod {\n                 inner: inner_span,\n-                view_items: vi,\n                 items: items,\n             })\n         )\n@@ -1101,47 +1096,47 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         P(respan(sp, ast::MetaNameValue(name, respan(sp, value))))\n     }\n \n-    fn view_use(&self, sp: Span,\n-                vis: ast::Visibility, vp: P<ast::ViewPath>) -> ast::ViewItem {\n-        ast::ViewItem {\n-            node: ast::ViewItemUse(vp),\n-            attrs: Vec::new(),\n+    fn item_use(&self, sp: Span,\n+                vis: ast::Visibility, vp: P<ast::ViewPath>) -> P<ast::Item> {\n+        P(ast::Item {\n+            id: ast::DUMMY_NODE_ID,\n+            ident: special_idents::invalid,\n+            attrs: vec![],\n+            node: ast::ItemUse(vp),\n             vis: vis,\n             span: sp\n-        }\n+        })\n     }\n \n-    fn view_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> ast::ViewItem {\n+    fn item_use_simple(&self, sp: Span, vis: ast::Visibility, path: ast::Path) -> P<ast::Item> {\n         let last = path.segments.last().unwrap().identifier;\n-        self.view_use_simple_(sp, vis, last, path)\n+        self.item_use_simple_(sp, vis, last, path)\n     }\n \n-    fn view_use_simple_(&self, sp: Span, vis: ast::Visibility,\n-                        ident: ast::Ident, path: ast::Path) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_simple_(&self, sp: Span, vis: ast::Visibility,\n+                        ident: ast::Ident, path: ast::Path) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathSimple(ident,\n-                                                   path,\n-                                                   ast::DUMMY_NODE_ID))))\n+                                                   path))))\n     }\n \n-    fn view_use_list(&self, sp: Span, vis: ast::Visibility,\n-                     path: Vec<ast::Ident> , imports: &[ast::Ident]) -> ast::ViewItem {\n+    fn item_use_list(&self, sp: Span, vis: ast::Visibility,\n+                     path: Vec<ast::Ident>, imports: &[ast::Ident]) -> P<ast::Item> {\n         let imports = imports.iter().map(|id| {\n             respan(sp, ast::PathListIdent { name: *id, id: ast::DUMMY_NODE_ID })\n         }).collect();\n \n-        self.view_use(sp, vis,\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n                                ast::ViewPathList(self.path(sp, path),\n-                                                 imports,\n-                                                 ast::DUMMY_NODE_ID))))\n+                                                 imports))))\n     }\n \n-    fn view_use_glob(&self, sp: Span,\n-                     vis: ast::Visibility, path: Vec<ast::Ident> ) -> ast::ViewItem {\n-        self.view_use(sp, vis,\n+    fn item_use_glob(&self, sp: Span,\n+                     vis: ast::Visibility, path: Vec<ast::Ident>) -> P<ast::Item> {\n+        self.item_use(sp, vis,\n                       P(respan(sp,\n-                               ast::ViewPathGlob(self.path(sp, path), ast::DUMMY_NODE_ID))))\n+                               ast::ViewPathGlob(self.path(sp, path)))))\n     }\n }"}, {"sha": "e458bd58e8b6a8cb51a1865f7bdc033f565d9330", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -114,7 +114,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 cx.expr_try(span,\n                     cx.expr_method_call(span, blkdecoder.clone(), read_struct_field,\n                                         vec!(cx.expr_str(span, name),\n-                                          cx.expr_uint(span, field),\n+                                          cx.expr_usize(span, field),\n                                           exprdecode.clone())))\n             });\n             let result = cx.expr_ok(trait_span, result);\n@@ -123,7 +123,7 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 cx.ident_of(\"read_struct\"),\n                                 vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n-                cx.expr_uint(trait_span, nfields),\n+                cx.expr_usize(trait_span, nfields),\n                 cx.lambda_expr_1(trait_span, result, blkarg)\n             ))\n         }\n@@ -143,14 +143,14 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    path,\n                                                    parts,\n                                                    |cx, span, _, field| {\n-                    let idx = cx.expr_uint(span, field);\n+                    let idx = cx.expr_usize(span, field);\n                     cx.expr_try(span,\n                         cx.expr_method_call(span, blkdecoder.clone(), rvariant_arg,\n                                             vec!(idx, exprdecode.clone())))\n                 });\n \n                 arms.push(cx.arm(v_span,\n-                                 vec!(cx.pat_lit(v_span, cx.expr_uint(v_span, i))),\n+                                 vec!(cx.pat_lit(v_span, cx.expr_usize(v_span, i))),\n                                  decoded));\n             }\n \n@@ -179,14 +179,14 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n \n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_path` is the path to this enum variant/struct\n-/// - `getarg` should retrieve the `uint`-th field with name `@str`.\n+/// - `getarg` should retrieve the `usize`-th field with name `@str`.\n fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            outer_pat_path: ast::Path,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr> where\n-    F: FnMut(&mut ExtCtxt, Span, InternedString, uint) -> P<Expr>,\n+    F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>,\n {\n     match *fields {\n         Unnamed(ref fields) => {"}, {"sha": "f8fdd8575bd67dce5246129daa8c631d277ab422", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -79,7 +79,7 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n         StaticEnum(..) => {\n             cx.span_err(trait_span, \"`Default` cannot be derived for enums, only structs\");\n             // let compilation continue\n-            cx.expr_uint(trait_span, 0)\n+            cx.expr_usize(trait_span, 0)\n         }\n         _ => cx.span_bug(trait_span, \"Non-static method in `derive(Default)`\")\n     };"}, {"sha": "4c78a7b6a0cfefaf7cb6b7840cd5ac964e885e93", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -16,7 +16,7 @@\n //!\n //! ```ignore\n //! #[derive(Encodable, Decodable)]\n-//! struct Node { id: uint }\n+//! struct Node { id: usize }\n //! ```\n //!\n //! would generate two implementations like:\n@@ -27,7 +27,7 @@\n //!         s.emit_struct(\"Node\", 1, |this| {\n //!             this.emit_struct_field(\"id\", 0, |this| {\n //!                 Encodable::encode(&self.id, this)\n-//!                 /* this.emit_uint(self.id) can also be used */\n+//!                 /* this.emit_usize(self.id) can also be used */\n //!             })\n //!         })\n //!     }\n@@ -192,7 +192,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_struct_field,\n                                                vec!(cx.expr_str(span, name),\n-                                                 cx.expr_uint(span, i),\n+                                                 cx.expr_usize(span, i),\n                                                  lambda));\n \n                 // last call doesn't need a try!\n@@ -218,7 +218,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                 cx.ident_of(\"emit_struct\"),\n                                 vec!(\n                 cx.expr_str(trait_span, token::get_ident(substr.type_ident)),\n-                cx.expr_uint(trait_span, fields.len()),\n+                cx.expr_usize(trait_span, fields.len()),\n                 blk\n             ))\n         }\n@@ -239,7 +239,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder.clone(),\n                                                emit_variant_arg,\n-                                               vec!(cx.expr_uint(span, i),\n+                                               vec!(cx.expr_usize(span, i),\n                                                  lambda));\n                 let call = if i != last {\n                     cx.expr_try(span, call)\n@@ -262,8 +262,8 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let call = cx.expr_method_call(trait_span, blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n                                            vec!(name,\n-                                             cx.expr_uint(trait_span, idx),\n-                                             cx.expr_uint(trait_span, fields.len()),\n+                                             cx.expr_usize(trait_span, idx),\n+                                             cx.expr_usize(trait_span, fields.len()),\n                                              blk));\n             let blk = cx.lambda_expr_1(trait_span, call, blkarg);\n             let ret = cx.expr_method_call(trait_span,"}, {"sha": "272b0464010114d0c708b19b461d300ff691c871", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -28,7 +28,7 @@\n //! arguments:\n //!\n //! - `Struct`, when `Self` is a struct (including tuple structs, e.g\n-//!   `struct T(int, char)`).\n+//!   `struct T(i32, char)`).\n //! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n //!   same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n //! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n@@ -54,17 +54,17 @@\n //! following snippet\n //!\n //! ```rust\n-//! struct A { x : int }\n+//! struct A { x : i32 }\n //!\n-//! struct B(int);\n+//! struct B(i32);\n //!\n //! enum C {\n-//!     C0(int),\n-//!     C1 { x: int }\n+//!     C0(i32),\n+//!     C1 { x: i32 }\n //! }\n //! ```\n //!\n-//! The `int`s in `B` and `C0` don't have an identifier, so the\n+//! The `i32`s in `B` and `C0` don't have an identifier, so the\n //! `Option<ident>`s would be `None` for them.\n //!\n //! In the static cases, the structure is summarised, either into the just\n@@ -90,8 +90,8 @@\n //! trait PartialEq {\n //!     fn eq(&self, other: &Self);\n //! }\n-//! impl PartialEq for int {\n-//!     fn eq(&self, other: &int) -> bool {\n+//! impl PartialEq for i32 {\n+//!     fn eq(&self, other: &i32) -> bool {\n //!         *self == *other\n //!     }\n //! }\n@@ -117,7 +117,7 @@\n //!\n //! ```{.text}\n //! Struct(vec![FieldInfo {\n-//!           span: <span of `int`>,\n+//!           span: <span of `i32`>,\n //!           name: None,\n //!           self_: <expr for &a>\n //!           other: vec![<expr for &b>]\n@@ -132,7 +132,7 @@\n //! ```{.text}\n //! EnumMatching(0, <ast::Variant for C0>,\n //!              vec![FieldInfo {\n-//!                 span: <span of int>\n+//!                 span: <span of i32>\n //!                 name: None,\n //!                 self_: <expr for &a>,\n //!                 other: vec![<expr for &b>]\n@@ -179,7 +179,7 @@\n //! StaticStruct(<ast::StructDef of B>, Unnamed(vec![<span of x>]))\n //!\n //! StaticEnum(<ast::EnumDef of C>,\n-//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of int>])),\n+//!            vec![(<ident of C0>, <span of C0>, Unnamed(vec![<span of i32>])),\n //!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n //! ```\n \n@@ -294,7 +294,7 @@ pub enum SubstructureFields<'a> {\n     /// Matching variants of the enum: variant index, ast::Variant,\n     /// fields: the field name is only non-`None` in the case of a struct\n     /// variant.\n-    EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n+    EnumMatching(usize, &'a ast::Variant, Vec<FieldInfo>),\n \n     /// Non-matching variants of the enum, but with all state hidden from\n     /// the consequent code.  The first component holds `Ident`s for all of\n@@ -719,7 +719,7 @@ impl<'a> MethodDef<'a> {\n \n     /// ```\n     /// #[derive(PartialEq)]\n-    /// struct A { x: int, y: int }\n+    /// struct A { x: i32, y: i32 }\n     ///\n     /// // equivalent to:\n     /// impl PartialEq for A {\n@@ -748,7 +748,7 @@ impl<'a> MethodDef<'a> {\n         let mut raw_fields = Vec::new(); // ~[[fields of self],\n                                  // [fields of next Self arg], [etc]]\n         let mut patterns = Vec::new();\n-        for i in range(0u, self_args.len()) {\n+        for i in range(0us, self_args.len()) {\n             let struct_path= cx.path(DUMMY_SP, vec!( type_ident ));\n             let (pat, ident_expr) =\n                 trait_.create_struct_pattern(cx,\n@@ -825,7 +825,7 @@ impl<'a> MethodDef<'a> {\n     /// #[derive(PartialEq)]\n     /// enum A {\n     ///     A1,\n-    ///     A2(int)\n+    ///     A2(i32)\n     /// }\n     ///\n     /// // is equivalent to\n@@ -837,8 +837,8 @@ impl<'a> MethodDef<'a> {\n     ///             (&A2(ref __self_0),\n     ///              &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n     ///             _ => {\n-    ///                 let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n-    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+    ///                 let __self_vi = match *self { A1(..) => 0us, A2(..) => 1us };\n+    ///                 let __arg_1_vi = match *__arg_1 { A1(..) => 0us, A2(..) => 1us };\n     ///                 false\n     ///             }\n     ///         }\n@@ -882,8 +882,8 @@ impl<'a> MethodDef<'a> {\n     ///   (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n     ///   ...\n     ///   _ => {\n-    ///     let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n-    ///     let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+    ///     let __this_vi = match this { Variant1 => 0us, Variant2 => 1us, ... };\n+    ///     let __that_vi = match that { Variant1 => 0us, Variant2 => 1us, ... };\n     ///     ... // catch-all remainder can inspect above variant index values.\n     ///   }\n     /// }\n@@ -915,7 +915,7 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to a uint\n+        // a series of let statements mapping each self_arg to a usize\n         // corresponding to its variant index.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[]);\n@@ -1039,19 +1039,19 @@ impl<'a> MethodDef<'a> {\n                 }).collect();\n \n             // Build a series of let statements mapping each self_arg\n-            // to a uint corresponding to its variant index.\n+            // to a usize corresponding to its variant index.\n             // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //\n             // ```\n             // let __self0_vi = match   self {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // let __self1_vi = match __arg1 {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // let __self2_vi = match __arg2 {\n-            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            //     A => 0us, B(..) => 1us, C(..) => 2us\n             // };\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n@@ -1073,7 +1073,7 @@ impl<'a> MethodDef<'a> {\n             //   <delegated expression referring to __self0_vi, et al.>\n             // }\n             let arm_expr = cx.expr_block(\n-                cx.block_all(sp, Vec::new(), index_let_stmts, Some(arm_expr)));\n+                cx.block_all(sp, index_let_stmts, Some(arm_expr)));\n \n             // Builds arm:\n             // _ => { let __self0_vi = ...;"}, {"sha": "85682d41b5ff65cffcdb971ca178d9d9d10c244e", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -32,7 +32,7 @@ pub enum PtrTy<'a> {\n     Raw(ast::Mutability),\n }\n \n-/// A path, e.g. `::std::option::Option::<int>` (global). Has support\n+/// A path, e.g. `::std::option::Option::<i32>` (global). Has support\n /// for type parameters and a lifetime.\n #[derive(Clone)]\n pub struct Path<'a> {\n@@ -91,7 +91,7 @@ pub enum Ty<'a> {\n     /// &/Box/ Ty\n     Ptr(Box<Ty<'a>>, PtrTy<'a>),\n     /// mod::mod::Type<[lifetime], [Params...]>, including a plain type\n-    /// parameter, and things like `int`\n+    /// parameter, and things like `i32`\n     Literal(Path<'a>),\n     /// includes unit\n     Tuple(Vec<Ty<'a>> )"}, {"sha": "8dac864c2ae3b689b9a89e38b3faa13f57c44b4d", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -89,7 +89,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n             // iteration function.\n             let discriminant = match variant.node.disr_expr {\n                 Some(ref d) => d.clone(),\n-                None => cx.expr_uint(trait_span, index)\n+                None => cx.expr_usize(trait_span, index)\n             };\n \n             stmts.push(call_hash(trait_span, discriminant));"}, {"sha": "e52a2b513ce1f3582a793c50045767a2b07d7676", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -99,7 +99,9 @@ pub fn expand_meta_derive(cx: &mut ExtCtxt,\n \n                             \"Rand\" => expand!(rand::expand_deriving_rand),\n \n+                            // NOTE(stage0): remove \"Show\"\n                             \"Show\" => expand!(show::expand_deriving_show),\n+                            \"Debug\" => expand!(show::expand_deriving_show),\n \n                             \"Default\" => expand!(default::expand_deriving_default),\n "}, {"sha": "bb902d7059c87b8aeacd4bd5eaa76e51f37b48b1", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -80,10 +80,10 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n             if variants.is_empty() {\n                 cx.span_err(trait_span, \"`Rand` cannot be derived for enums with no variants\");\n                 // let compilation continue\n-                return cx.expr_uint(trait_span, 0);\n+                return cx.expr_usize(trait_span, 0);\n             }\n \n-            let variant_count = cx.expr_uint(trait_span, variants.len());\n+            let variant_count = cx.expr_usize(trait_span, variants.len());\n \n             let rand_name = cx.path_all(trait_span,\n                                         true,\n@@ -115,7 +115,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                               variant_count);\n \n             let mut arms = variants.iter().enumerate().map(|(i, &(ident, v_span, ref summary))| {\n-                let i_expr = cx.expr_uint(v_span, i);\n+                let i_expr = cx.expr_usize(v_span, i);\n                 let pat = cx.pat_lit(v_span, i_expr);\n \n                 let path = cx.path(v_span, vec![substr.type_ident, ident]);"}, {"sha": "f5b5d4dda199c90ea1eeb4c014d5ab3ece96ac71", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -35,7 +35,7 @@ pub fn expand_deriving_show<F>(cx: &mut ExtCtxt,\n     let trait_def = TraitDef {\n         span: span,\n         attributes: Vec::new(),\n-        path: Path::new(vec!(\"std\", \"fmt\", \"Show\")),\n+        path: Path::new(vec!(\"std\", \"fmt\", \"Debug\")),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         methods: vec!(\n@@ -67,7 +67,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n         EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n-            cx.span_bug(span, \"nonsensical .fields in `#[derive(Show)]`\")\n+            cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\")\n         }\n     };\n "}, {"sha": "9f6bf352b040443609c0c30943259b5f8b0656d7", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -104,7 +104,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let e = match os::getenv(var.get()) {\n         None => {\n             cx.span_err(sp, msg.get());\n-            cx.expr_uint(sp, 0)\n+            cx.expr_usize(sp, 0)\n         }\n         Some(s) => cx.expr_str(sp, token::intern_and_get_ident(&s[]))\n     };"}, {"sha": "629991799e73de2d4638eb849521244acad18cb5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -206,7 +206,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                     // wrap the if-let expr in a block\n                     let span = els.span;\n                     let blk = P(ast::Block {\n-                        view_items: vec![],\n                         stmts: vec![],\n                         expr: Some(P(els)),\n                         id: ast::DUMMY_NODE_ID,\n@@ -273,7 +272,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac, span: codemap::Span,\n         // in this file.\n         // Token-tree macros:\n         MacInvocTT(pth, tts, _) => {\n-            if pth.segments.len() > 1u {\n+            if pth.segments.len() > 1us {\n                 fld.cx.span_err(pth.span,\n                                 \"expected macro name without module \\\n                                 separators\");\n@@ -799,8 +798,7 @@ pub fn expand_block(blk: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n \n // expand the elements of a block.\n pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| {\n-        let new_view_items = view_items.into_iter().map(|x| fld.fold_view_item(x)).collect();\n+    b.map(|Block {id, stmts, expr, rules, span}| {\n         let new_stmts = stmts.into_iter().flat_map(|x| {\n             // perform all pending renames\n             let renamed_stmt = {\n@@ -821,7 +819,6 @@ pub fn expand_block_elts(b: P<Block>, fld: &mut MacroExpander) -> P<Block> {\n         });\n         Block {\n             id: fld.new_id(id),\n-            view_items: new_view_items,\n             stmts: new_stmts,\n             expr: new_expr,\n             rules: rules,\n@@ -844,7 +841,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n             },\n             _ => unreachable!()\n         };\n-        if pth.segments.len() > 1u {\n+        if pth.segments.len() > 1us {\n             fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n             return DummyResult::raw_pat(span);\n         }\n@@ -1311,7 +1308,7 @@ fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n pub struct ExpansionConfig {\n     pub crate_name: String,\n     pub enable_quotes: bool,\n-    pub recursion_limit: uint,\n+    pub recursion_limit: usize,\n }\n \n impl ExpansionConfig {\n@@ -1507,7 +1504,7 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n         let src = \"fn bogus() {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1521,7 +1518,7 @@ mod test {\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n         let src = \"mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1533,7 +1530,7 @@ mod test {\n     // macro_use modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n         let src = \"#[macro_use] mod foo {macro_rules! z (() => (3+4));}\\\n-                   fn inty() -> int { z!() }\".to_string();\n+                   fn inty() -> i32 { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n             \"<test>\".to_string(),\n@@ -1564,8 +1561,8 @@ mod test {\n     // should be able to use a bound identifier as a literal in a macro definition:\n     #[test] fn self_macro_parsing(){\n         expand_crate_str(\n-            \"macro_rules! foo ((zz) => (287u;));\n-            fn f(zz : int) {foo!(zz);}\".to_string()\n+            \"macro_rules! foo ((zz) => (287;));\n+            fn f(zz: i32) {foo!(zz);}\".to_string()\n             );\n     }\n \n@@ -1595,29 +1592,29 @@ mod test {\n     // in principle, you might want to control this boolean on a per-varref basis,\n     // but that would make things even harder to understand, and might not be\n     // necessary for thorough testing.\n-    type RenamingTest = (&'static str, Vec<Vec<uint>>, bool);\n+    type RenamingTest = (&'static str, Vec<Vec<usize>>, bool);\n \n     #[test]\n     fn automatic_renaming () {\n         let tests: Vec<RenamingTest> =\n             vec!(// b & c should get new names throughout, in the expr too:\n-                (\"fn a() -> int { let b = 13; let c = b; b+c }\",\n+                (\"fn a() -> i32 { let b = 13; let c = b; b+c }\",\n                  vec!(vec!(0,1),vec!(2)), false),\n                 // both x's should be renamed (how is this causing a bug?)\n-                (\"fn main () {let x: int = 13;x;}\",\n+                (\"fn main () {let x: i32 = 13;x;}\",\n                  vec!(vec!(0)), false),\n                 // the use of b after the + should be renamed, the other one not:\n-                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> int { let b = 13; f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> i32 { let b = 13; f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the b before the plus should not be renamed (requires marks)\n-                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> int { f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> i32 { f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n                 (\"macro_rules! letty(($x:ident) => (let $x = 15;));\n                   macro_rules! user(($x:ident) => ({letty!($x); $x}));\n-                  fn main() -> int {user!(z)}\",\n+                  fn main() -> i32 {user!(z)}\",\n                  vec!(vec!(0)), false)\n                 );\n         for (idx,s) in tests.iter().enumerate() {\n@@ -1680,13 +1677,13 @@ mod test {\n     // can't write this test case until we have macro-generating macros.\n \n     // method arg hygiene\n-    // method expands to fn get_x(&self_0, x_1:int) {self_0 + self_2 + x_3 + x_1}\n+    // method expands to fn get_x(&self_0, x_1: i32) {self_0 + self_2 + x_3 + x_1}\n     #[test] fn method_arg_hygiene(){\n         run_renaming_test(\n             &(\"macro_rules! inject_x (()=>(x));\n               macro_rules! inject_self (()=>(self));\n               struct A;\n-              impl A{fn get_x(&self, x: int) {self + inject_self!() + inject_x!() + x;} }\",\n+              impl A{fn get_x(&self, x: i32) {self + inject_self!() + inject_x!() + x;} }\",\n               vec!(vec!(0),vec!(3)),\n               true),\n             0)\n@@ -1706,21 +1703,21 @@ mod test {\n     }\n \n     // item fn hygiene\n-    // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n+    // expands to fn q(x_1: i32){fn g(x_2: i32){x_2 + x_1};}\n     #[test] fn issue_9383(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x:int){ x + $ex }));\n-              fn q(x:int) { bad_macro!(x); }\",\n+            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x: i32){ x + $ex }));\n+              fn q(x: i32) { bad_macro!(x); }\",\n               vec!(vec!(1),vec!(0)),true),\n             0)\n     }\n \n     // closure arg hygiene (ExprClosure)\n-    // expands to fn f(){(|x_1 : int| {(x_2 + x_1)})(3);}\n+    // expands to fn f(){(|x_1 : i32| {(x_2 + x_1)})(3);}\n     #[test] fn closure_arg_hygiene(){\n         run_renaming_test(\n             &(\"macro_rules! inject_x (()=>(x));\n-            fn f(){(|x : int| {(inject_x!() + x)})(3);}\",\n+            fn f(){(|x : i32| {(inject_x!() + x)})(3);}\",\n               vec!(vec!(1)),\n               true),\n             0)\n@@ -1729,7 +1726,7 @@ mod test {\n     // macro_rules in method position. Sadly, unimplemented.\n     #[test] fn macro_in_method_posn(){\n         expand_crate_str(\n-            \"macro_rules! my_method (() => (fn thirteen(&self) -> int {13}));\n+            \"macro_rules! my_method (() => (fn thirteen(&self) -> i32 {13}));\n             struct A;\n             impl A{ my_method!(); }\n             fn f(){A.thirteen;}\".to_string());\n@@ -1749,7 +1746,7 @@ mod test {\n     }\n \n     // run one of the renaming tests\n-    fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n+    fn run_renaming_test(t: &RenamingTest, test_idx: usize) {\n         let invalid_name = token::special_idents::invalid.name;\n         let (teststr, bound_connections, bound_ident_check) = match *t {\n             (ref str,ref conns, bic) => (str.to_string(), conns.clone(), bic)\n@@ -1876,7 +1873,7 @@ foo_module!();\n     // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n     #[test]\n     fn crate_bindings_test(){\n-        let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n+        let the_crate = string_to_crate(\"fn main (a: i32) -> i32 {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n         let idents = crate_bindings(&the_crate);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n@@ -1885,10 +1882,10 @@ foo_module!();\n     // test the IdentRenamer directly\n     #[test]\n     fn ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"int\");\n+        let int_ident = token::str_to_ident(\"i32\");\n         let renames = vec!((x_ident,Name(16)));\n         let mut renamer = IdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);\n@@ -1900,10 +1897,10 @@ foo_module!();\n     // test the PatIdentRenamer; only PatIdents get renamed\n     #[test]\n     fn pat_ident_renamer_test () {\n-        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let the_crate = string_to_crate(\"fn f(x: i32){let x = x; x}\".to_string());\n         let f_ident = token::str_to_ident(\"f\");\n         let x_ident = token::str_to_ident(\"x\");\n-        let int_ident = token::str_to_ident(\"int\");\n+        let int_ident = token::str_to_ident(\"i32\");\n         let renames = vec!((x_ident,Name(16)));\n         let mut renamer = PatIdentRenamer{renames: &renames};\n         let renamed_crate = renamer.fold_crate(the_crate);"}, {"sha": "8ea9d6168ef4130d90faa68776e2f59cf67ddc6f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -31,7 +31,7 @@ enum ArgumentType {\n }\n \n enum Position {\n-    Exact(uint),\n+    Exact(usize),\n     Named(String),\n }\n \n@@ -61,11 +61,11 @@ struct Context<'a, 'b:'a> {\n     /// Stays `true` if all formatting parameters are default (as in \"{}{}\").\n     all_pieces_simple: bool,\n \n-    name_positions: HashMap<String, uint>,\n+    name_positions: HashMap<String, usize>,\n \n     /// Updated as arguments are consumed or methods are entered\n-    nest_level: uint,\n-    next_arg: uint,\n+    nest_level: usize,\n+    next_arg: usize,\n }\n \n /// Parses the arguments from the given list of tokens, returning None\n@@ -326,11 +326,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         match c {\n             parse::CountIs(i) => {\n                 self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIs\"),\n-                                          vec!(self.ecx.expr_uint(sp, i)))\n+                                          vec!(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountIsParam(i) => {\n                 self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_uint(sp, i)))\n+                                          vec!(self.ecx.expr_usize(sp, i)))\n             }\n             parse::CountImplied => {\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx,\n@@ -349,7 +349,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 };\n                 let i = i + self.args.len();\n                 self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"CountIsParam\"),\n-                                          vec!(self.ecx.expr_uint(sp, i)))\n+                                          vec!(self.ecx.expr_usize(sp, i)))\n             }\n         }\n     }\n@@ -382,7 +382,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                     parse::ArgumentIs(i) => {\n                         self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_uint(sp, i)))\n+                                                  vec!(self.ecx.expr_usize(sp, i)))\n                     }\n                     // Named arguments are converted to positional arguments at\n                     // the end of the list of arguments\n@@ -393,7 +393,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         };\n                         let i = i + self.args.len();\n                         self.ecx.expr_call_global(sp, Context::rtpath(self.ecx, \"ArgumentIs\"),\n-                                                  vec!(self.ecx.expr_uint(sp, i)))\n+                                                  vec!(self.ecx.expr_usize(sp, i)))\n                     }\n                 };\n \n@@ -432,7 +432,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     }\n                 };\n                 let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_uint(sp, arg.format.flags);\n+                let flags = self.ecx.expr_usize(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n@@ -603,8 +603,8 @@ impl<'a, 'b> Context<'a, 'b> {\n         let trait_ = match *ty {\n             Known(ref tyname) => {\n                 match &tyname[] {\n-                    \"\"  => \"String\",\n-                    \"?\" => \"Show\",\n+                    \"\"  => \"Display\",\n+                    \"?\" => \"Debug\",\n                     \"e\" => \"LowerExp\",\n                     \"E\" => \"UpperExp\",\n                     \"o\" => \"Octal\","}, {"sha": "7adc443759fe87624bd861e6a4ad1cab2af74ed5", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -187,7 +187,7 @@ fn resolve_internal(id: Ident,\n     }\n \n     let resolved = {\n-        let result = (*table.table.borrow())[id.ctxt as uint];\n+        let result = (*table.table.borrow())[id.ctxt as usize];\n         match result {\n             EmptyCtxt => id.name,\n             // ignore marks here:\n@@ -231,7 +231,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n     let mut result = Vec::new();\n     let mut loopvar = ctxt;\n     loop {\n-        let table_entry = (*table.table.borrow())[loopvar as uint];\n+        let table_entry = (*table.table.borrow())[loopvar as usize];\n         match table_entry {\n             EmptyCtxt => {\n                 return result;\n@@ -258,7 +258,7 @@ fn marksof_internal(ctxt: SyntaxContext,\n /// FAILS when outside is not a mark.\n pub fn outer_mark(ctxt: SyntaxContext) -> Mrk {\n     with_sctable(|sctable| {\n-        match (*sctable.table.borrow())[ctxt as uint] {\n+        match (*sctable.table.borrow())[ctxt as usize] {\n             Mark(mrk, _) => mrk,\n             _ => panic!(\"can't retrieve outer mark when outside is not a mark\")\n         }\n@@ -330,7 +330,7 @@ mod tests {\n         let mut result = Vec::new();\n         loop {\n             let table = table.table.borrow();\n-            match (*table)[sc as uint] {\n+            match (*table)[sc as usize] {\n                 EmptyCtxt => {return result;},\n                 Mark(mrk,tail) => {\n                     result.push(M(mrk));\n@@ -398,7 +398,7 @@ mod tests {\n          assert_eq! (marksof_internal (ans, stopname,&t), vec!(16));}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n-                        R(id(name1.uint() as u32,\n+                        R(id(name1.usize() as u32,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           Name(100101102)),\n                         M(14));\n@@ -407,7 +407,7 @@ mod tests {\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n-                       R(id(name1.uint() as u32, name1sc),\n+                       R(id(name1.usize() as u32, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);"}, {"sha": "7e345a2d078ffa1aff57d20a375d14763f9b90b3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -352,18 +352,11 @@ pub mod rt {\n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n \n         fn parse_item(&self, s: String) -> P<ast::Item> {\n-            let res = parse::parse_item_from_source_str(\n+            parse::parse_item_from_source_str(\n                 \"<quote expansion>\".to_string(),\n                 s,\n                 self.cfg(),\n-                self.parse_sess());\n-            match res {\n-                Some(ast) => ast,\n-                None => {\n-                    error!(\"parse error\");\n-                    panic!()\n-                }\n-            }\n+                self.parse_sess()).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> P<ast::Stmt> {\n@@ -588,7 +581,7 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> P<ast::Expr> {\n         }\n \n         token::Literal(token::StrRaw(ident, n), suf) => {\n-            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ident.ident()), cx.expr_uint(sp, n))\n+            return mk_lit!(\"StrRaw\", suf, mk_name(cx, sp, ident.ident()), cx.expr_usize(sp, n))\n         }\n \n         token::Ident(ident, style) => {\n@@ -716,7 +709,7 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     // try removing it when enough of them are gone.\n \n     let mut p = cx.new_parser_from_tts(tts);\n-    p.quote_depth += 1u;\n+    p.quote_depth += 1us;\n \n     let cx_expr = p.parse_expr();\n     if !p.eat(&token::Comma) {\n@@ -767,7 +760,6 @@ fn expand_tts(cx: &ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     vector.extend(mk_tts(cx, &tts[]).into_iter());\n     let block = cx.expr_block(\n         cx.block_all(sp,\n-                     Vec::new(),\n                      vector,\n                      Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n \n@@ -778,18 +770,18 @@ fn expand_wrapper(cx: &ExtCtxt,\n                   sp: Span,\n                   cx_expr: P<ast::Expr>,\n                   expr: P<ast::Expr>) -> P<ast::Expr> {\n-    let uses = [\n-        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n-    ].iter().map(|path| {\n-        let path = path.iter().map(|s| s.to_string()).collect();\n-        cx.view_use_glob(sp, ast::Inherited, ids_ext(path))\n-    }).collect();\n-\n     // Explicitly borrow to avoid moving from the invoker (#16992)\n     let cx_expr_borrow = cx.expr_addr_of(sp, cx.expr_deref(sp, cx_expr));\n     let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr_borrow);\n \n-    cx.expr_block(cx.block_all(sp, uses, vec!(stmt_let_ext_cx), Some(expr)))\n+    let stmts = [\n+        &[\"syntax\", \"ext\", \"quote\", \"rt\"],\n+    ].iter().map(|path| {\n+        let path = path.iter().map(|s| s.to_string()).collect();\n+        cx.stmt_item(sp, cx.item_use_glob(sp, ast::Inherited, ids_ext(path)))\n+    }).chain(Some(stmt_let_ext_cx).into_iter()).collect();\n+\n+    cx.expr_block(cx.block_all(sp, stmts, Some(expr)))\n }\n \n fn expand_parse_call(cx: &ExtCtxt,"}, {"sha": "a74adbf40851565929b38512893cbc2fef3b5965", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -35,7 +35,7 @@ pub fn expand_line(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n \n-    base::MacExpr::new(cx.expr_uint(topmost, loc.line))\n+    base::MacExpr::new(cx.expr_usize(topmost, loc.line))\n }\n \n /* column!(): expands to the current column number */\n@@ -45,7 +45,7 @@ pub fn expand_column(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n \n     let topmost = cx.original_span_in_file();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    base::MacExpr::new(cx.expr_uint(topmost, loc.col.to_uint()))\n+    base::MacExpr::new(cx.expr_usize(topmost, loc.col.to_usize()))\n }\n \n /// file!(): expands to the current filename */"}, {"sha": "d115f2ed6208265b7b69646471585caffe173f9d", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -110,14 +110,14 @@ enum TokenTreeOrTokenTreeVec {\n }\n \n impl TokenTreeOrTokenTreeVec {\n-    fn len(&self) -> uint {\n+    fn len(&self) -> usize {\n         match self {\n             &TtSeq(ref v) => v.len(),\n             &Tt(ref tt) => tt.len(),\n         }\n     }\n \n-    fn get_tt(&self, index: uint) -> TokenTree {\n+    fn get_tt(&self, index: usize) -> TokenTree {\n         match self {\n             &TtSeq(ref v) => v[index].clone(),\n             &Tt(ref tt) => tt.get_tt(index),\n@@ -129,24 +129,24 @@ impl TokenTreeOrTokenTreeVec {\n #[derive(Clone)]\n struct MatcherTtFrame {\n     elts: TokenTreeOrTokenTreeVec,\n-    idx: uint,\n+    idx: usize,\n }\n \n #[derive(Clone)]\n pub struct MatcherPos {\n     stack: Vec<MatcherTtFrame>,\n     top_elts: TokenTreeOrTokenTreeVec,\n     sep: Option<Token>,\n-    idx: uint,\n+    idx: usize,\n     up: Option<Box<MatcherPos>>,\n     matches: Vec<Vec<Rc<NamedMatch>>>,\n-    match_lo: uint,\n-    match_cur: uint,\n-    match_hi: uint,\n+    match_lo: usize,\n+    match_cur: usize,\n+    match_hi: usize,\n     sp_lo: BytePos,\n }\n \n-pub fn count_names(ms: &[TokenTree]) -> uint {\n+pub fn count_names(ms: &[TokenTree]) -> usize {\n     ms.iter().fold(0, |count, elt| {\n         count + match elt {\n             &TtSequence(_, ref seq) => {\n@@ -171,11 +171,11 @@ pub fn initial_matcher_pos(ms: Rc<Vec<TokenTree>>, sep: Option<Token>, lo: ByteP\n         stack: vec![],\n         top_elts: TtSeq(ms),\n         sep: sep,\n-        idx: 0u,\n+        idx: 0us,\n         up: None,\n         matches: matches,\n-        match_lo: 0u,\n-        match_cur: 0u,\n+        match_lo: 0us,\n+        match_cur: 0us,\n         match_hi: match_idx_hi,\n         sp_lo: lo\n     }\n@@ -206,7 +206,7 @@ pub enum NamedMatch {\n pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n             -> HashMap<Ident, Rc<NamedMatch>> {\n     fn n_rec(p_s: &ParseSess, m: &TokenTree, res: &[Rc<NamedMatch>],\n-             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut uint) {\n+             ret_val: &mut HashMap<Ident, Rc<NamedMatch>>, idx: &mut usize) {\n         match m {\n             &TtSequence(_, ref seq) => {\n                 for next_m in seq.tts.iter() {\n@@ -238,7 +238,7 @@ pub fn nameize(p_s: &ParseSess, ms: &[TokenTree], res: &[Rc<NamedMatch>])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    let mut idx = 0u;\n+    let mut idx = 0us;\n     for m in ms.iter() { n_rec(p_s, m, res, &mut ret_val, &mut idx) }\n     ret_val\n }\n@@ -383,7 +383,7 @@ pub fn parse(sess: &ParseSess,\n                         if seq.op == ast::ZeroOrMore {\n                             let mut new_ei = ei.clone();\n                             new_ei.match_cur += seq.num_captures;\n-                            new_ei.idx += 1u;\n+                            new_ei.idx += 1us;\n                             //we specifically matched zero repeats.\n                             for idx in range(ei.match_cur, ei.match_cur + seq.num_captures) {\n                                 (&mut new_ei.matches[idx]).push(Rc::new(MatchedSeq(vec![], sp)));\n@@ -398,7 +398,7 @@ pub fn parse(sess: &ParseSess,\n                         cur_eis.push(box MatcherPos {\n                             stack: vec![],\n                             sep: seq.separator.clone(),\n-                            idx: 0u,\n+                            idx: 0us,\n                             matches: matches,\n                             match_lo: ei_t.match_cur,\n                             match_cur: ei_t.match_cur,\n@@ -442,20 +442,20 @@ pub fn parse(sess: &ParseSess,\n \n         /* error messages here could be improved with links to orig. rules */\n         if token_name_eq(&tok, &token::Eof) {\n-            if eof_eis.len() == 1u {\n+            if eof_eis.len() == 1us {\n                 let mut v = Vec::new();\n                 for dv in (&mut eof_eis[0]).matches.iter_mut() {\n                     v.push(dv.pop().unwrap());\n                 }\n                 return Success(nameize(sess, ms, &v[]));\n-            } else if eof_eis.len() > 1u {\n+            } else if eof_eis.len() > 1us {\n                 return Error(sp, \"ambiguity: multiple successful parses\".to_string());\n             } else {\n                 return Failure(sp, \"unexpected end of macro invocation\".to_string());\n             }\n         } else {\n-            if (bb_eis.len() > 0u && next_eis.len() > 0u)\n-                || bb_eis.len() > 1u {\n+            if (bb_eis.len() > 0us && next_eis.len() > 0us)\n+                || bb_eis.len() > 1us {\n                 let nts = bb_eis.iter().map(|ei| {\n                     match ei.top_elts.get_tt(ei.idx) {\n                       TtToken(_, MatchNt(bind, name, _, _)) => {\n@@ -469,12 +469,12 @@ pub fn parse(sess: &ParseSess,\n                     \"local ambiguity: multiple parsing options: \\\n                      built-in NTs {} or {} other options.\",\n                     nts, next_eis.len()).to_string());\n-            } else if bb_eis.len() == 0u && next_eis.len() == 0u {\n+            } else if bb_eis.len() == 0us && next_eis.len() == 0us {\n                 return Failure(sp, format!(\"no rules expected the token `{}`\",\n                             pprust::token_to_string(&tok)).to_string());\n-            } else if next_eis.len() > 0u {\n+            } else if next_eis.len() > 0us {\n                 /* Now process the next token */\n-                while next_eis.len() > 0u {\n+                while next_eis.len() > 0us {\n                     cur_eis.push(next_eis.pop().unwrap());\n                 }\n                 rdr.next_token();\n@@ -488,7 +488,7 @@ pub fn parse(sess: &ParseSess,\n                     let match_cur = ei.match_cur;\n                     (&mut ei.matches[match_cur]).push(Rc::new(MatchedNonterminal(\n                         parse_nt(&mut rust_parser, name_string.get()))));\n-                    ei.idx += 1u;\n+                    ei.idx += 1us;\n                     ei.match_cur += 1;\n                   }\n                   _ => panic!()\n@@ -501,16 +501,16 @@ pub fn parse(sess: &ParseSess,\n             }\n         }\n \n-        assert!(cur_eis.len() > 0u);\n+        assert!(cur_eis.len() > 0us);\n     }\n }\n \n pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n     match name {\n         \"tt\" => {\n-            p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n+            p.quote_depth += 1us; //but in theory, non-quoted tts might be useful\n             let res = token::NtTT(P(p.parse_token_tree()));\n-            p.quote_depth -= 1u;\n+            p.quote_depth -= 1us;\n             return res;\n         }\n         _ => {}"}, {"sha": "8350e0222ef898f4c082eec9234d0ece8c68c0e3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -8,8 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::{TokenTree, TtDelimited, TtSequence, TtToken};\n-use ast;\n+use ast::{self, TokenTree, TtDelimited, TtSequence, TtToken};\n use codemap::{Span, DUMMY_SP};\n use ext::base::{ExtCtxt, MacResult, SyntaxExtension};\n use ext::base::{NormalTT, TTMacroExpander};\n@@ -19,9 +18,8 @@ use ext::tt::macro_parser::{parse, parse_or_else};\n use parse::lexer::{new_tt_reader, new_tt_reader_with_doc_flag};\n use parse::parser::Parser;\n use parse::attr::ParserAttr;\n-use parse::token::{special_idents, gensym_ident, NtTT, Token};\n+use parse::token::{self, special_idents, gensym_ident, NtTT, Token};\n use parse::token::Token::*;\n-use parse::token;\n use print;\n use ptr::P;\n \n@@ -336,16 +334,20 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n \n                 let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n                 // If T' is in the set FOLLOW(NT), continue. Else, reject.\n-                match &next_token {\n-                    &Eof => return Some((sp, tok.clone())),\n-                    _ if is_in_follow(cx, &next_token, frag_spec.as_str()) => continue,\n-                    next => {\n+                match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n+                    (&Eof, _) => return Some((sp, tok.clone())),\n+                    (_, Ok(true)) => continue,\n+                    (next, Ok(false)) => {\n                         cx.span_err(sp, format!(\"`${0}:{1}` is followed by `{2}`, which \\\n                                                  is not allowed for `{1}` fragments\",\n                                                  name.as_str(), frag_spec.as_str(),\n                                                  token_to_string(next)).as_slice());\n                         continue\n                     },\n+                    (_, Err(msg)) => {\n+                        cx.span_err(sp, msg.as_slice());\n+                        continue\n+                    }\n                 }\n             },\n             TtSequence(sp, ref seq) => {\n@@ -412,51 +414,50 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n     last\n }\n \n-fn is_in_follow(cx: &ExtCtxt, tok: &Token, frag: &str) -> bool {\n+fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n     if let &CloseDelim(_) = tok {\n-        return true;\n-    }\n-\n-    match frag {\n-        \"item\" => {\n-            // since items *must* be followed by either a `;` or a `}`, we can\n-            // accept anything after them\n-            true\n-        },\n-        \"block\" => {\n-            // anything can follow block, the braces provide a easy boundary to\n-            // maintain\n-            true\n-        },\n-        \"stmt\" | \"expr\"  => {\n-            match *tok {\n-                FatArrow | Comma | Semi => true,\n-                _ => false\n-            }\n-        },\n-        \"pat\" => {\n-            match *tok {\n-                FatArrow | Comma | Eq => true,\n-                _ => false\n-            }\n-        },\n-        \"path\" | \"ty\" => {\n-            match *tok {\n-                Comma | FatArrow | Colon | Eq | Gt => true,\n-                Ident(i, _) if i.as_str() == \"as\" => true,\n-                _ => false\n-            }\n-        },\n-        \"ident\" => {\n-            // being a single token, idents are harmless\n-            true\n-        },\n-        \"meta\" | \"tt\" => {\n-            // being either a single token or a delimited sequence, tt is\n-            // harmless\n-            true\n-        },\n-        _ => cx.bug(format!(\"unrecognized builtin nonterminal {}\",\n-                            frag).as_slice()),\n+        Ok(true)\n+    } else {\n+        match frag {\n+            \"item\" => {\n+                // since items *must* be followed by either a `;` or a `}`, we can\n+                // accept anything after them\n+                Ok(true)\n+            },\n+            \"block\" => {\n+                // anything can follow block, the braces provide a easy boundary to\n+                // maintain\n+                Ok(true)\n+            },\n+            \"stmt\" | \"expr\"  => {\n+                match *tok {\n+                    FatArrow | Comma | Semi => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n+            \"pat\" => {\n+                match *tok {\n+                    FatArrow | Comma | Eq => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n+            \"path\" | \"ty\" => {\n+                match *tok {\n+                    Comma | FatArrow | Colon | Eq | Gt => Ok(true),\n+                    Ident(i, _) if i.as_str() == \"as\" => Ok(true),\n+                    _ => Ok(false)\n+                }\n+            },\n+            \"ident\" => {\n+                // being a single token, idents are harmless\n+                Ok(true)\n+            },\n+            \"meta\" | \"tt\" => {\n+                // being either a single token or a delimited sequence, tt is\n+                // harmless\n+                Ok(true)\n+            },\n+            _ => Err(format!(\"unrecognized builtin nonterminal `{}`\", frag))\n+        }\n     }\n }"}, {"sha": "0bf20b8f3e1514c829ede4aa92a71b27e1349970", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -27,7 +27,7 @@ use std::collections::HashMap;\n #[derive(Clone)]\n struct TtFrame {\n     forest: TokenTree,\n-    idx: uint,\n+    idx: usize,\n     dotdotdoted: bool,\n     sep: Option<Token>,\n }\n@@ -43,8 +43,8 @@ pub struct TtReader<'a> {\n \n     // Some => return imported_from as the next token\n     crate_name_next: Option<Span>,\n-    repeat_idx: Vec<uint>,\n-    repeat_len: Vec<uint>,\n+    repeat_idx: Vec<usize>,\n+    repeat_len: Vec<usize>,\n     /* cached: */\n     pub cur_tok: Token,\n     pub cur_span: Span,\n@@ -124,7 +124,7 @@ fn lookup_cur_matched(r: &TtReader, name: Ident) -> Option<Rc<NamedMatch>> {\n #[derive(Clone)]\n enum LockstepIterSize {\n     LisUnconstrained,\n-    LisConstraint(uint, Ident),\n+    LisConstraint(usize, Ident),\n     LisContradiction(String),\n }\n \n@@ -223,7 +223,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.repeat_len.pop();\n             }\n         } else { /* repeat */\n-            *r.repeat_idx.last_mut().unwrap() += 1u;\n+            *r.repeat_idx.last_mut().unwrap() += 1us;\n             r.stack.last_mut().unwrap().idx = 0;\n             match r.stack.last().unwrap().sep.clone() {\n                 Some(tk) => {"}, {"sha": "762a1dcbfc34b7323e3b0fe5ba2b9b26efaeb0c3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 9, "deletions": 20, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -64,7 +64,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n \n     (\"rustc_diagnostic_macros\", Active),\n     (\"unboxed_closures\", Active),\n-    (\"import_shadowing\", Active),\n+    (\"import_shadowing\", Removed),\n     (\"advanced_slice_patterns\", Active),\n     (\"tuple_indexing\", Accepted),\n     (\"associated_types\", Accepted),\n@@ -127,7 +127,6 @@ enum Status {\n pub struct Features {\n     pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n-    pub import_shadowing: bool,\n     pub visible_private_types: bool,\n     pub quote: bool,\n     pub old_orphan_check: bool,\n@@ -139,7 +138,6 @@ impl Features {\n         Features {\n             unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n-            import_shadowing: false,\n             visible_private_types: false,\n             quote: false,\n             old_orphan_check: false,\n@@ -228,22 +226,6 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n         }\n     }\n \n-    fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        match i.node {\n-            ast::ViewItemUse(..) => {}\n-            ast::ViewItemExternCrate(..) => {\n-                for attr in i.attrs.iter() {\n-                    if attr.check_name(\"plugin\") {\n-                        self.gate_feature(\"plugin\", attr.span,\n-                                          \"compiler plugins are experimental \\\n-                                           and possibly buggy\");\n-                    }\n-                }\n-            }\n-        }\n-        visit::walk_view_item(self, i)\n-    }\n-\n     fn visit_item(&mut self, i: &ast::Item) {\n         for attr in i.attrs.iter() {\n             if attr.name() == \"thread_local\" {\n@@ -262,6 +244,14 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n             }\n         }\n         match i.node {\n+            ast::ItemExternCrate(_) => {\n+                if attr::contains_name(&i.attrs[], \"plugin\") {\n+                    self.gate_feature(\"plugin\", i.span,\n+                                      \"compiler plugins are experimental \\\n+                                       and possibly buggy\");\n+                }\n+            }\n+\n             ast::ItemForeignMod(ref foreign_module) => {\n                 if attr::contains_name(&i.attrs[], \"link_args\") {\n                     self.gate_feature(\"link_args\", i.span,\n@@ -537,7 +527,6 @@ fn check_crate_inner<F>(cm: &CodeMap, span_handler: &SpanHandler, krate: &ast::C\n     (Features {\n         unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n-        import_shadowing: cx.has_feature(\"import_shadowing\"),\n         visible_private_types: cx.has_feature(\"visible_private_types\"),\n         quote: cx.has_feature(\"quote\"),\n         old_orphan_check: cx.has_feature(\"old_orphan_check\"),"}, {"sha": "9f8427cc8aed0f16b317f3ccbdcd9d57aa3e1907", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 19, "deletions": 45, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -78,10 +78,6 @@ pub trait Folder : Sized {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: ViewItem) -> ViewItem {\n-        noop_fold_view_item(vi, self)\n-    }\n-\n     fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n         noop_fold_foreign_item(ni, self)\n     }\n@@ -174,8 +170,8 @@ pub trait Folder : Sized {\n         noop_fold_ident(i, self)\n     }\n \n-    fn fold_uint(&mut self, i: uint) -> uint {\n-        noop_fold_uint(i, self)\n+    fn fold_usize(&mut self, i: usize) -> usize {\n+        noop_fold_usize(i, self)\n     }\n \n     fn fold_path(&mut self, p: Path) -> Path {\n@@ -349,16 +345,13 @@ pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T\n pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n     view_path.map(|Spanned {node, span}| Spanned {\n         node: match node {\n-            ViewPathSimple(ident, path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathSimple(ident, fld.fold_path(path), id)\n+            ViewPathSimple(ident, path) => {\n+                ViewPathSimple(ident, fld.fold_path(path))\n             }\n-            ViewPathGlob(path, node_id) => {\n-                let id = fld.new_id(node_id);\n-                ViewPathGlob(fld.fold_path(path), id)\n+            ViewPathGlob(path) => {\n+                ViewPathGlob(fld.fold_path(path))\n             }\n-            ViewPathList(path, path_list_idents, node_id) => {\n-                let id = fld.new_id(node_id);\n+            ViewPathList(path, path_list_idents) => {\n                 ViewPathList(fld.fold_path(path),\n                              path_list_idents.move_map(|path_list_ident| {\n                                 Spanned {\n@@ -373,8 +366,7 @@ pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<\n                                     },\n                                     span: fld.new_span(path_list_ident.span)\n                                 }\n-                             }),\n-                             id)\n+                             }))\n             }\n         },\n         span: fld.new_span(span)\n@@ -470,11 +462,10 @@ pub fn noop_fold_qpath<T: Folder>(qpath: P<QPath>, fld: &mut T) -> P<QPath> {\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, items}: ForeignMod,\n                                         fld: &mut T) -> ForeignMod {\n     ForeignMod {\n         abi: abi,\n-        view_items: view_items.move_map(|x| fld.fold_view_item(x)),\n         items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n@@ -505,7 +496,7 @@ pub fn noop_fold_ident<T: Folder>(i: Ident, _: &mut T) -> Ident {\n     i\n }\n \n-pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n+pub fn noop_fold_usize<T: Folder>(i: usize, _: &mut T) -> usize {\n     i\n }\n \n@@ -953,28 +944,9 @@ fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mu\n     }\n }\n \n-pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewItem,\n-                                      folder: &mut T) -> ViewItem {\n-    ViewItem {\n-        node: match node {\n-            ViewItemExternCrate(ident, string, node_id) => {\n-                ViewItemExternCrate(ident, string,\n-                                    folder.new_id(node_id))\n-            }\n-            ViewItemUse(view_path) => {\n-                ViewItemUse(folder.fold_view_path(view_path))\n-            }\n-        },\n-        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n-        vis: vis,\n-        span: folder.new_span(span)\n-    }\n-}\n-\n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n+    b.map(|Block {id, stmts, expr, rules, span}| Block {\n         id: folder.new_id(id),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         stmts: stmts.into_iter().flat_map(|s| folder.fold_stmt(s).into_iter()).collect(),\n         expr: expr.map(|x| folder.fold_expr(x)),\n         rules: rules,\n@@ -984,6 +956,10 @@ pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n \n pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n     match i {\n+        ItemExternCrate(string) => ItemExternCrate(string),\n+        ItemUse(view_path) => {\n+            ItemUse(folder.fold_view_path(view_path))\n+        }\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n@@ -1103,10 +1079,9 @@ pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMetho\n     }\n }\n \n-pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mut T) -> Mod {\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, items}: Mod, folder: &mut T) -> Mod {\n     Mod {\n         inner: folder.new_span(inner),\n-        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n         items: items.into_iter().flat_map(|x| folder.fold_item(x).into_iter()).collect(),\n     }\n }\n@@ -1137,9 +1112,8 @@ pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, mut exported_mac\n         }\n         None => (ast::Mod {\n             inner: span,\n-            view_items: Vec::new(),\n-            items: Vec::new(),\n-        }, Vec::new(), span)\n+            items: vec![],\n+        }, vec![], span)\n     };\n \n     for def in exported_macros.iter_mut() {\n@@ -1371,7 +1345,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) ->\n             }\n             ExprTupField(el, ident) => {\n                 ExprTupField(folder.fold_expr(el),\n-                             respan(ident.span, folder.fold_uint(ident.node)))\n+                             respan(ident.span, folder.fold_usize(ident.node)))\n             }\n             ExprIndex(el, er) => {\n                 ExprIndex(folder.fold_expr(el), folder.fold_expr(er))"}, {"sha": "872354024e93c319bec2e6da8b7444f9e9a6d99e", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,7 +22,7 @@ pub struct OwnedSlice<T> {\n     data: Box<[T]>\n }\n \n-impl<T:fmt::Show> fmt::Show for OwnedSlice<T> {\n+impl<T:fmt::Debug> fmt::Debug for OwnedSlice<T> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         self.data.fmt(fmt)\n     }"}, {"sha": "c58136b30aa1aeec67bcc26bf77e008369f8849f", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -22,7 +22,7 @@ use print::pprust;\n use std::io;\n use std::str;\n use std::string::String;\n-use std::uint;\n+use std::usize;\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum CommentStyle {\n@@ -62,7 +62,7 @@ pub fn doc_comment_style(comment: &str) -> ast::AttrStyle {\n pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     /// remove whitespace-only lines from the start/end of lines\n     fn vertical_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = 0u;\n+        let mut i = 0us;\n         let mut j = lines.len();\n         // first line of all-stars should be omitted\n         if lines.len() > 0 &&\n@@ -87,7 +87,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n     /// remove a \"[ \\t]*\\*\" block from each line, if possible\n     fn horizontal_trim(lines: Vec<String> ) -> Vec<String> {\n-        let mut i = uint::MAX;\n+        let mut i = usize::MAX;\n         let mut can_trim = true;\n         let mut first = true;\n         for line in lines.iter() {\n@@ -116,7 +116,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n \n         if can_trim {\n             lines.iter().map(|line| {\n-                (&line[(i + 1)..line.len()]).to_string()\n+                (&line[i + 1..line.len()]).to_string()\n             }).collect()\n         } else {\n             lines\n@@ -132,7 +132,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n     }\n \n     if comment.starts_with(\"/*\") {\n-        let lines = comment[3u..(comment.len() - 2u)]\n+        let lines = comment[3..comment.len() - 2]\n             .lines_any()\n             .map(|s| s.to_string())\n             .collect::<Vec<String> >();\n@@ -158,7 +158,7 @@ fn push_blank_line_comment(rdr: &StringReader, comments: &mut Vec<Comment>) {\n fn consume_whitespace_counting_blank_lines(rdr: &mut StringReader,\n                                            comments: &mut Vec<Comment>) {\n     while is_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == CharPos(0u) && rdr.curr_is('\\n') {\n+        if rdr.col == CharPos(0us) && rdr.curr_is('\\n') {\n             push_blank_line_comment(rdr, &mut *comments);\n         }\n         rdr.bump();\n@@ -206,10 +206,10 @@ fn read_line_comments(rdr: &mut StringReader, code_to_the_left: bool,\n /// Returns None if the first col chars of s contain a non-whitespace char.\n /// Otherwise returns Some(k) where k is first char offset after that leading\n /// whitespace.  Note k may be outside bounds of s.\n-fn all_whitespace(s: &str, col: CharPos) -> Option<uint> {\n+fn all_whitespace(s: &str, col: CharPos) -> Option<usize> {\n     let len = s.len();\n-    let mut col = col.to_uint();\n-    let mut cursor: uint = 0;\n+    let mut col = col.to_usize();\n+    let mut cursor: usize = 0;\n     while col > 0 && cursor < len {\n         let r: str::CharRange = s.char_range_at(cursor);\n         if !r.ch.is_whitespace() {\n@@ -267,7 +267,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         assert!(!curr_line.contains_char('\\n'));\n         lines.push(curr_line);\n     } else {\n-        let mut level: int = 1;\n+        let mut level: isize = 1;\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n@@ -305,7 +305,7 @@ fn read_block_comment(rdr: &mut StringReader,\n \n     let mut style = if code_to_the_left { Trailing } else { Isolated };\n     rdr.consume_non_eol_whitespace();\n-    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1u {\n+    if !rdr.is_eof() && !rdr.curr_is('\\n') && lines.len() == 1us {\n         style = Mixed;\n     }\n     debug!(\"<<< block comment\");\n@@ -399,9 +399,9 @@ mod test {\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n-        let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n+        let comment = \"/**\\n let a: *i32;\\n *a = 5;\\n*/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped, \" let a: *int;\\n *a = 5;\");\n+        assert_eq!(stripped, \" let a: *i32;\\n *a = 5;\");\n     }\n \n     #[test] fn test_block_doc_comment_4() {"}, {"sha": "3b9dcf53009866c9a65091edc508e3c54b634343", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "patch": "@@ -212,8 +212,8 @@ impl<'a> StringReader<'a> {\n     /// offending string to the error message\n     fn fatal_span_verbose(&self, from_pos: BytePos, to_pos: BytePos, mut m: String) -> ! {\n         m.push_str(\": \");\n-        let from = self.byte_offset(from_pos).to_uint();\n-        let to = self.byte_offset(to_pos).to_uint();\n+        let from = self.byte_offset(from_pos).to_usize();\n+        let to = self.byte_offset(to_pos).to_usize();\n         m.push_str(&self.filemap.src[from..to]);\n         self.fatal_span_(from_pos, to_pos, &m[]);\n     }\n@@ -271,15 +271,15 @@ impl<'a> StringReader<'a> {\n     fn with_str_from_to<T, F>(&self, start: BytePos, end: BytePos, f: F) -> T where\n         F: FnOnce(&str) -> T,\n     {\n-        f(self.filemap.src.slice(\n-                self.byte_offset(start).to_uint(),\n-                self.byte_offset(end).to_uint()))\n+        f(&self.filemap.src[\n+                self.byte_offset(start).to_usize()..\n+                self.byte_offset(end).to_usize()])\n     }\n \n     /// Converts CRLF to LF in the given string, raising an error on bare CR.\n     fn translate_crlf<'b>(&self, start: BytePos,\n                           s: &'b str, errmsg: &'b str) -> CowString<'b> {\n-        let mut i = 0u;\n+        let mut i = 0us;\n         while i < s.len() {\n             let str::CharRange { ch, next } = s.char_range_at(i);\n             if ch == '\\r' {\n@@ -295,7 +295,7 @@ impl<'a> StringReader<'a> {\n         return s.into_cow();\n \n         fn translate_crlf_(rdr: &StringReader, start: BytePos,\n-                        s: &str, errmsg: &str, mut i: uint) -> String {\n+                        s: &str, errmsg: &str, mut i: usize) -> String {\n             let mut buf = String::with_capacity(s.len());\n             let mut j = 0;\n             while i < s.len() {\n@@ -321,20 +321,20 @@ impl<'a> StringReader<'a> {\n     /// discovered, add it to the FileMap's list of line start offsets.\n     pub fn bump(&mut self) {\n         self.last_pos = self.pos;\n-        let current_byte_offset = self.byte_offset(self.pos).to_uint();\n+        let current_byte_offset = self.byte_offset(self.pos).to_usize();\n         if current_byte_offset < self.filemap.src.len() {\n             assert!(self.curr.is_some());\n             let last_char = self.curr.unwrap();\n             let next = self.filemap\n                           .src\n                           .char_range_at(current_byte_offset);\n             let byte_offset_diff = next.next - current_byte_offset;\n-            self.pos = self.pos + Pos::from_uint(byte_offset_diff);\n+            self.pos = self.pos + Pos::from_usize(byte_offset_diff);\n             self.curr = Some(next.ch);\n-            self.col = self.col + CharPos(1u);\n+            self.col = self.col + CharPos(1us);\n             if last_char == '\\n' {\n                 self.filemap.next_line(self.last_pos);\n-                self.col = CharPos(0u);\n+                self.col = CharPos(0us);\n             }\n \n             if byte_offset_diff > 1 {\n@@ -346,7 +346,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.pos).to_uint();\n+        let offset = self.byte_offset(self.pos).to_usize();\n         if offset < self.filemap.src.len() {\n             Some(self.filemap.src.char_at(offset))\n         } else {\n@@ -359,7 +359,7 @@ impl<'a> StringReader<'a> {\n     }\n \n     pub fn nextnextch(&self) -> Option<char> {\n-        let offset = self.byte_offset(self.pos).to_uint();\n+        let offset = self.byte_offset(self.pos).to_usize();\n         let s = self.filemap.src.as_slice();\n         if offset >= s.len() { return None }\n         let str::CharRange { next, .. } = s.char_range_at(offset);\n@@ -472,7 +472,7 @@ impl<'a> StringReader<'a> {\n                 cmap.files.borrow_mut().push(self.filemap.clone());\n                 let loc = cmap.lookup_char_pos_adj(self.last_pos);\n                 debug!(\"Skipping a shebang\");\n-                if loc.line == 1u && loc.col == CharPos(0u) {\n+                if loc.line == 1us && loc.col == CharPos(0us) {\n                     // FIXME: Add shebang \"token\", return it\n                     let start = self.last_pos;\n                     while !self.curr_is('\\n') && !self.is_eof() { self.bump(); }\n@@ -519,7 +519,7 @@ impl<'a> StringReader<'a> {\n         let is_doc_comment = self.curr_is('*') || self.curr_is('!');\n         let start_bpos = self.last_pos - BytePos(2);\n \n-        let mut level: int = 1;\n+        let mut level: isize = 1;\n         let mut has_cr = false;\n         while level > 0 {\n             if self.is_eof() {\n@@ -586,10 +586,10 @@ impl<'a> StringReader<'a> {\n     /// `\\x00` marker.\n     #[inline(never)]\n     fn scan_embedded_hygienic_ident(&mut self) -> ast::Ident {\n-        fn bump_expecting_char<'a,D:fmt::Show>(r: &mut StringReader<'a>,\n-                                               c: char,\n-                                               described_c: D,\n-                                               whence: &str) {\n+        fn bump_expecting_char<'a,D:fmt::Debug>(r: &mut StringReader<'a>,\n+                                                c: char,\n+                                                described_c: D,\n+                                                whence: &str) {\n             match r.curr {\n                 Some(r_c) if r_c == c => r.bump(),\n                 Some(r_c) => panic!(\"expected {:?}, hit {:?}, {}\", described_c, r_c, whence),\n@@ -645,8 +645,8 @@ impl<'a> StringReader<'a> {\n \n     /// Scan through any digits (base `radix`) or underscores, and return how\n     /// many digits there were.\n-    fn scan_digits(&mut self, radix: uint) -> uint {\n-        let mut len = 0u;\n+    fn scan_digits(&mut self, radix: usize) -> usize {\n+        let mut len = 0us;\n         loop {\n             let c = self.curr;\n             if c == Some('_') { debug!(\"skipping a _\"); self.bump(); continue; }\n@@ -724,7 +724,7 @@ impl<'a> StringReader<'a> {\n     /// Scan over `n_digits` hex digits, stopping at `delim`, reporting an\n     /// error if too many or too few digits are encountered.\n     fn scan_hex_digits(&mut self,\n-                       n_digits: uint,\n+                       n_digits: usize,\n                        delim: char,\n                        below_0x7f_only: bool)\n                        -> bool {\n@@ -799,14 +799,14 @@ impl<'a> StringReader<'a> {\n                                 if self.curr == Some('{') {\n                                     self.scan_unicode_escape(delim)\n                                 } else {\n-                                    let res = self.scan_hex_digits(4u, delim, false);\n+                                    let res = self.scan_hex_digits(4us, delim, false);\n                                     let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                     self.old_escape_warning(sp);\n                                     res\n                                 }\n                             }\n                             'U' if !ascii_only => {\n-                                let res = self.scan_hex_digits(8u, delim, false);\n+                                let res = self.scan_hex_digits(8us, delim, false);\n                                 let sp = codemap::mk_sp(escaped_pos, self.last_pos);\n                                 self.old_escape_warning(sp);\n                                 res\n@@ -877,7 +877,7 @@ impl<'a> StringReader<'a> {\n     fn scan_unicode_escape(&mut self, delim: char) -> bool {\n         self.bump(); // past the {\n         let start_bpos = self.last_pos;\n-        let mut count: uint = 0;\n+        let mut count = 0us;\n         let mut accum_int = 0;\n \n         while !self.curr_is('}') && count <= 6 {\n@@ -935,13 +935,13 @@ impl<'a> StringReader<'a> {\n \n     /// Check that a base is valid for a floating literal, emitting a nice\n     /// error if it isn't.\n-    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: uint) {\n+    fn check_float_base(&mut self, start_bpos: BytePos, last_bpos: BytePos, base: usize) {\n         match base {\n-            16u => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n-                                 supported\"),\n-            8u => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n-            2u => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n-            _ => ()\n+            16us => self.err_span_(start_bpos, last_bpos, \"hexadecimal float literal is not \\\n+                                   supported\"),\n+            8us => self.err_span_(start_bpos, last_bpos, \"octal float literal is not supported\"),\n+            2us => self.err_span_(start_bpos, last_bpos, \"binary float literal is not supported\"),\n+            _   => ()\n         }\n     }\n \n@@ -1189,7 +1189,7 @@ impl<'a> StringReader<'a> {\n           'r' => {\n             let start_bpos = self.last_pos;\n             self.bump();\n-            let mut hash_count = 0u;\n+            let mut hash_count = 0us;\n             while self.curr_is('#') {\n                 self.bump();\n                 hash_count += 1;\n@@ -1374,7 +1374,7 @@ impl<'a> StringReader<'a> {\n     fn scan_raw_byte_string(&mut self) -> token::Lit {\n         let start_bpos = self.last_pos;\n         self.bump();\n-        let mut hash_count = 0u;\n+        let mut hash_count = 0us;\n         while self.curr_is('#') {\n             self.bump();\n             hash_count += 1;\n@@ -1616,9 +1616,9 @@ mod test {\n         test!(\"1.0\", Float, \"1.0\");\n         test!(\"1.0e10\", Float, \"1.0e10\");\n \n-        assert_eq!(setup(&mk_sh(), \"2u\".to_string()).next_token().tok,\n+        assert_eq!(setup(&mk_sh(), \"2us\".to_string()).next_token().tok,\n                    token::Literal(token::Integer(token::intern(\"2\")),\n-                                  Some(token::intern(\"u\"))));\n+                                  Some(token::intern(\"us\"))));\n         assert_eq!(setup(&mk_sh(), \"r###\\\"raw\\\"###suffix\".to_string()).next_token().tok,\n                    token::Literal(token::StrRaw(token::intern(\"raw\"), 3),\n                                   Some(token::intern(\"suffix\"))));"}, {"sha": "8cb7ee5b33746e95ca8b43dd9d5d61a0f9cbbefd", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "a3600506057af8737ff9b1e3c7b73d73005f6bfb", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "fc02cb4acb82415146cfacb5e8d58903cb10db2e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 164, "deletions": 360, "changes": 524, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "a129fd19d94054ae64dfa79b98bd790f78207b0d", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "0b1bd282941084fa59c3d5a3c923ea130c2c8e7a", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "42f156d6a112daa4be2ce5972520ee2d8ffcece1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 72, "deletions": 90, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "01f3839b0390ef3a2293af2198bbac377c08201c", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "d75fbcf199dbe1d8b187dedf6ff4896ea08f4cb9", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "e5d8e4e5143a778a665b8a603fce4af62b6cb24e", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "1b35b1b04a313e872c72ecf0f868a6ea4d5f51ca", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "89854f5d979a159218c93a60595dff55f145f34d", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "d8bac19805b27eb5000e74292a159a7443b0ab98", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "eb906788aa7f4125da1e1fece56bae7a6608a554", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "2ef0bca3785cbc43ba1d6b81b46abeb030125d20", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "0b51a976c0e8d96137ab15d9134586db121ca3d2", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "eb300beae9fa87cb302cbece81afea11f75303be", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "98e031f863e859912a3c5508fd18a2e63b7139b7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 12, "deletions": 360, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "cd461cf5766d65dfabedb2814ff2bce5490e5356", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "66cdf03a51ea6656b6c68d68b47da578028e1b57", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "03cd3fd6b88ea45fcec630a09da75ff76fe4fc31", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "8b50278573346c9883dab7bc683b55322993f5fd", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "f129b4b77bb9fca5937b16de164527e36c6ef5c1", "filename": "src/test/auxiliary/blind-item-mixed-crate-use-item-foo.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "previous_filename": "src/test/run-make/dep-info-custom/foo.rs"}, {"sha": "91fa912455109d658c09344263de1903c4830f44", "filename": "src/test/auxiliary/blind-item-mixed-crate-use-item-foo2.rs", "status": "renamed", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fblind-item-mixed-crate-use-item-foo2.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c", "previous_filename": "src/test/run-make/dep-info-custom/bar.rs"}, {"sha": "a4edc607279012f3d21a180f3a0bf7d816658e86", "filename": "src/test/auxiliary/roman_numerals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fauxiliary%2Froman_numerals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Froman_numerals.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}, {"sha": "4182f8b651b2eaf1fec970b70fa031de789457ce", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d2056a7e3e52b2aec41662cfd960e0eafe8494c/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=5d2056a7e3e52b2aec41662cfd960e0eafe8494c"}]}