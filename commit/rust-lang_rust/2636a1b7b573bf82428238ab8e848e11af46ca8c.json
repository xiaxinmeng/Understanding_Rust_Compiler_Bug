{"sha": "2636a1b7b573bf82428238ab8e848e11af46ca8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2MzZhMWI3YjU3M2JmODI0MjgyMzhhYjhlODQ4ZTExYWY0NmNhOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-11T08:29:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-11T08:29:52Z"}, "message": "Auto merge of #7663 - Jarcho:rsplit_once_order, r=llogiq\n\nFix result order for `manual_split_once` when `rsplitn` is used\n\nfixes: #7656\n\nchangelog: Fix result order for `manual_split_once` when `rsplitn` is used", "tree": {"sha": "34ba37fa718be64266768f7926f26a5e3a78bd53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34ba37fa718be64266768f7926f26a5e3a78bd53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2636a1b7b573bf82428238ab8e848e11af46ca8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2636a1b7b573bf82428238ab8e848e11af46ca8c", "html_url": "https://github.com/rust-lang/rust/commit/2636a1b7b573bf82428238ab8e848e11af46ca8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2636a1b7b573bf82428238ab8e848e11af46ca8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8cd4e5bf01b736382237c33fa820940f2811753", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8cd4e5bf01b736382237c33fa820940f2811753", "html_url": "https://github.com/rust-lang/rust/commit/e8cd4e5bf01b736382237c33fa820940f2811753"}, {"sha": "4c1b6a28e4c7b932b077c03e7a0f100b791391d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c1b6a28e4c7b932b077c03e7a0f100b791391d7", "html_url": "https://github.com/rust-lang/rust/commit/4c1b6a28e4c7b932b077c03e7a0f100b791391d7"}], "stats": {"total": 110, "additions": 72, "deletions": 38}, "files": [{"sha": "8440f2918592fd954f74ebcc563f3f5104c9f64a", "filename": "clippy_lints/src/methods/manual_split_once.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/2636a1b7b573bf82428238ab8e848e11af46ca8c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2636a1b7b573bf82428238ab8e848e11af46ca8c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_split_once.rs?ref=2636a1b7b573bf82428238ab8e848e11af46ca8c", "patch": "@@ -17,32 +17,25 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n     }\n \n     let ctxt = expr.span.ctxt();\n-    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id)) {\n+    let (method_name, msg, reverse) = if method_name == \"splitn\" {\n+        (\"split_once\", \"manual implementation of `split_once`\", false)\n+    } else {\n+        (\"rsplit_once\", \"manual implementation of `rsplit_once`\", true)\n+    };\n+    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), reverse) {\n         Some(x) => x,\n         None => return,\n     };\n-    let (method_name, msg) = if method_name == \"splitn\" {\n-        (\"split_once\", \"manual implementation of `split_once`\")\n-    } else {\n-        (\"rsplit_once\", \"manual implementation of `rsplit_once`\")\n-    };\n \n     let mut app = Applicability::MachineApplicable;\n     let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n     let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n \n-    match usage.kind {\n+    let sugg = match usage.kind {\n         IterUsageKind::NextTuple => {\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_SPLIT_ONCE,\n-                usage.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.{}({})\", self_snip, method_name, pat_snip),\n-                app,\n-            );\n+            format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n         },\n+        IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n         IterUsageKind::Next => {\n             let self_deref = {\n                 let adjust = cx.typeck_results().expr_adjustments(self_arg);\n@@ -58,7 +51,7 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                     \"*\".repeat(adjust.len() - 2)\n                 }\n             };\n-            let sugg = if usage.unwrap_kind.is_some() {\n+            if usage.unwrap_kind.is_some() {\n                 format!(\n                     \"{}.{}({}).map_or({}{}, |x| x.0)\",\n                     &self_snip, method_name, pat_snip, self_deref, &self_snip\n@@ -68,33 +61,26 @@ pub(super) fn check(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, se\n                     \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n                     &self_snip, method_name, pat_snip, self_deref, &self_snip\n                 )\n-            };\n-\n-            span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n+            }\n         },\n         IterUsageKind::Second => {\n             let access_str = match usage.unwrap_kind {\n                 Some(UnwrapKind::Unwrap) => \".unwrap().1\",\n                 Some(UnwrapKind::QuestionMark) => \"?.1\",\n                 None => \".map(|x| x.1)\",\n             };\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_SPLIT_ONCE,\n-                usage.span,\n-                msg,\n-                \"try this\",\n-                format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str),\n-                app,\n-            );\n+            format!(\"{}.{}({}){}\", self_snip, method_name, pat_snip, access_str)\n         },\n-    }\n+    };\n+\n+    span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n enum IterUsageKind {\n     Next,\n     Second,\n     NextTuple,\n+    RNextTuple,\n }\n \n enum UnwrapKind {\n@@ -108,10 +94,12 @@ struct IterUsage {\n     span: Span,\n }\n \n+#[allow(clippy::too_many_lines)]\n fn parse_iter_usage(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n+    reverse: bool,\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n@@ -124,20 +112,30 @@ fn parse_iter_usage(\n             let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n \n             match (&*name.ident.as_str(), args) {\n-                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Next, e.span),\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n+                    if reverse {\n+                        (IterUsageKind::Second, e.span)\n+                    } else {\n+                        (IterUsageKind::Next, e.span)\n+                    }\n+                },\n                 (\"next_tuple\", []) => {\n-                    if_chain! {\n+                    return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n                         if let ty::Adt(adt_def, subs) = cx.typeck_results().expr_ty(e).kind();\n                         if cx.tcx.is_diagnostic_item(sym::option_type, adt_def.did);\n                         if let ty::Tuple(subs) = subs.type_at(0).kind();\n                         if subs.len() == 2;\n                         then {\n-                            return Some(IterUsage { kind: IterUsageKind::NextTuple, span: e.span, unwrap_kind: None });\n+                            Some(IterUsage {\n+                                kind: if reverse { IterUsageKind::RNextTuple } else { IterUsageKind::NextTuple },\n+                                span: e.span,\n+                                unwrap_kind: None\n+                            })\n                         } else {\n-                            return None;\n+                            None\n                         }\n-                    }\n+                    };\n                 },\n                 (\"nth\" | \"skip\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n                     if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n@@ -158,7 +156,7 @@ fn parse_iter_usage(\n                                 }\n                             }\n                         };\n-                        match idx {\n+                        match if reverse { idx ^ 1 } else { idx } {\n                             0 => (IterUsageKind::Next, span),\n                             1 => (IterUsageKind::Second, span),\n                             _ => return None,"}, {"sha": "992baf1f185a710ae1d7d3ba70207821ee9044b0", "filename": "tests/ui/manual_split_once.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=2636a1b7b573bf82428238ab8e848e11af46ca8c", "patch": "@@ -36,6 +36,12 @@ fn main() {\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+\n+    // `rsplitn` gives the results in the reverse order of `rsplit_once`\n+    let _ = \"key=value\".rsplit_once('=').unwrap().1;\n+    let _ = \"key=value\".rsplit_once('=').map_or(\"key=value\", |x| x.0);\n+    let _ = \"key=value\".rsplit_once('=').map(|x| x.1);\n+    let (_, _) = \"key=value\".rsplit_once('=').map(|(x, y)| (y, x)).unwrap();\n }\n \n fn _msrv_1_51() {"}, {"sha": "4f92ab6b812bd87fe642d43e2fceff2d963e8116", "filename": "tests/ui/manual_split_once.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=2636a1b7b573bf82428238ab8e848e11af46ca8c", "patch": "@@ -36,6 +36,12 @@ fn main() {\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n+\n+    // `rsplitn` gives the results in the reverse order of `rsplit_once`\n+    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n+    let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n+    let _ = \"key=value\".rsplitn(2, '=').nth(0);\n+    let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n }\n \n fn _msrv_1_51() {"}, {"sha": "7bea2303d9213ab9d49c0d7cae676ce730738f60", "filename": "tests/ui/manual_split_once.stderr", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2636a1b7b573bf82428238ab8e848e11af46ca8c/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=2636a1b7b573bf82428238ab8e848e11af46ca8c", "patch": "@@ -72,11 +72,35 @@ error: manual implementation of `split_once`\n LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n \n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:41:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').unwrap().1`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:42:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map_or(\"key=value\", |x| x.0)`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:43:13\n+   |\n+LL |     let _ = \"key=value\".rsplitn(2, '=').nth(0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|x| x.1)`\n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:44:18\n+   |\n+LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n+\n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:49:13\n+  --> $DIR/manual_split_once.rs:55:13\n    |\n LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 17 previous errors\n "}]}