{"sha": "3cf74564b8fbe1a5a179333a533851815879ff46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjZjc0NTY0YjhmYmUxYTVhMTc5MzMzYTUzMzg1MTgxNTg3OWZmNDY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T16:14:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-08-23T19:38:18Z"}, "message": "update liveness to camel-cased conventions, silence warnings", "tree": {"sha": "856e58ea535420d95f8a7a22ad4e3d6c8366c7a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/856e58ea535420d95f8a7a22ad4e3d6c8366c7a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cf74564b8fbe1a5a179333a533851815879ff46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cf74564b8fbe1a5a179333a533851815879ff46", "html_url": "https://github.com/rust-lang/rust/commit/3cf74564b8fbe1a5a179333a533851815879ff46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cf74564b8fbe1a5a179333a533851815879ff46/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "129c4b694b753ed3dbe67d5e2787e0ede01263e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/129c4b694b753ed3dbe67d5e2787e0ede01263e9", "html_url": "https://github.com/rust-lang/rust/commit/129c4b694b753ed3dbe67d5e2787e0ede01263e9"}], "stats": {"total": 536, "additions": 278, "deletions": 258}, "files": [{"sha": "4f15e3b1a9aa8f319acb8cf041a507da49db9eb5", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 267, "deletions": 249, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=3cf74564b8fbe1a5a179333a533851815879ff46", "patch": "@@ -66,13 +66,13 @@\n  * At each live node `N`, we track three pieces of information for each\n  * variable `V` (these are encapsulated in the `users` struct):\n  *\n- * - `reader`: the `live_node` ID of some node which will read the value\n+ * - `reader`: the `LiveNode` ID of some node which will read the value\n  *    that `V` holds on entry to `N`.  Formally: a node `M` such\n  *    that there exists a path `P` from `N` to `M` where `P` does not\n  *    write `V`.  If the `reader` is `invalid_node()`, then the current\n  *    value will never be read (the variable is dead, essentially).\n  *\n- * - `writer`: the `live_node` ID of some node which will write the\n+ * - `writer`: the `LiveNode` ID of some node which will write the\n  *    variable `V` and which is reachable from `N`.  Formally: a node `M`\n  *    such that there exists a path `P` from `N` to `M` and `M` writes\n  *    `V`.  If the `writer` is `invalid_node()`, then there is no writer\n@@ -124,14 +124,14 @@ export last_use_map;\n // if it detects an outstanding loan (that is, the addr is taken).\n type last_use_map = hashmap<node_id, @DVec<node_id>>;\n \n-enum variable = uint;\n-enum live_node = uint;\n+enum Variable = uint;\n+enum LiveNode = uint;\n \n-enum live_node_kind {\n-    lnk_freevar(span),\n-    lnk_expr(span),\n-    lnk_vdef(span),\n-    lnk_exit\n+enum LiveNodeKind {\n+    FreeVarNode(span),\n+    ExprNode(span),\n+    VarDefNode(span),\n+    ExitNode\n }\n \n fn check_crate(tcx: ty::ctxt,\n@@ -145,18 +145,17 @@ fn check_crate(tcx: ty::ctxt,\n     });\n \n     let last_use_map = int_hash();\n-    let initial_maps = @ir_maps(tcx, method_map,\n-                                last_use_map);\n+    let initial_maps = @IrMaps(tcx, method_map, last_use_map);\n     visit::visit_crate(*crate, initial_maps, visitor);\n     tcx.sess.abort_if_errors();\n     return last_use_map;\n }\n \n-impl live_node: to_str::ToStr {\n+impl LiveNode: to_str::ToStr {\n     fn to_str() -> ~str { fmt!(\"ln(%u)\", *self) }\n }\n \n-impl variable: to_str::ToStr {\n+impl Variable: to_str::ToStr {\n     fn to_str() -> ~str { fmt!(\"v(%u)\", *self) }\n }\n \n@@ -182,64 +181,74 @@ impl variable: to_str::ToStr {\n // variable must not be assigned if there is some successor\n // assignment.  And so forth.\n \n-impl live_node {\n+impl LiveNode {\n     pure fn is_valid() -> bool { *self != uint::max_value }\n }\n \n-fn invalid_node() -> live_node { live_node(uint::max_value) }\n+fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n \n-enum relevant_def { rdef_var(node_id), rdef_self }\n+enum RelevantDef { RelevantVar(node_id), RelevantSelf }\n \n-type capture_info = {ln: live_node, is_move: bool, rv: relevant_def};\n+type CaptureInfo = {ln: LiveNode, is_move: bool, rv: RelevantDef};\n \n-enum var_kind {\n-    vk_arg(node_id, ident, rmode),\n-    vk_local(node_id, ident),\n-    vk_field(ident),\n-    vk_self,\n-    vk_implicit_ret\n+struct LocalInfo {\n+    id: node_id;\n+    ident: ident;\n+    is_mutbl: bool;\n+    initialized: bool;\n }\n \n-fn relevant_def(def: def) -> option<relevant_def> {\n+enum VarKind {\n+    Arg(node_id, ident, rmode),\n+    Local(LocalInfo),\n+    Field(ident),\n+    Self,\n+    ImplicitRet\n+}\n+\n+fn relevant_def(def: def) -> option<RelevantDef> {\n     match def {\n-      def_self(_) => some(rdef_self),\n-      def_arg(nid, _) | def_local(nid, _) => some(rdef_var(nid)),\n+      def_self(_) => some(RelevantSelf),\n+      def_arg(nid, _) | def_local(nid, _) => some(RelevantVar(nid)),\n       _ => none\n     }\n }\n \n-struct ir_maps {\n-    let tcx: ty::ctxt;\n-    let method_map: typeck::method_map;\n-    let last_use_map: last_use_map;\n-\n-    let mut num_live_nodes: uint;\n-    let mut num_vars: uint;\n-    let live_node_map: hashmap<node_id, live_node>;\n-    let variable_map: hashmap<node_id, variable>;\n-    let field_map: hashmap<ident, variable>;\n-    let capture_map: hashmap<node_id, @~[capture_info]>;\n-    let mut var_kinds: ~[var_kind];\n-    let mut lnks: ~[live_node_kind];\n-\n-    new(tcx: ty::ctxt, method_map: typeck::method_map,\n-        last_use_map: last_use_map) {\n-        self.tcx = tcx;\n-        self.method_map = method_map;\n-        self.last_use_map = last_use_map;\n-\n-        self.num_live_nodes = 0u;\n-        self.num_vars = 0u;\n-        self.live_node_map = int_hash();\n-        self.variable_map = int_hash();\n-        self.capture_map = int_hash();\n-        self.field_map = uint_hash();\n-        self.var_kinds = ~[];\n-        self.lnks = ~[];\n-    }\n-\n-    fn add_live_node(lnk: live_node_kind) -> live_node {\n-        let ln = live_node(self.num_live_nodes);\n+struct IrMaps {\n+    tcx: ty::ctxt;\n+    method_map: typeck::method_map;\n+    last_use_map: last_use_map;\n+\n+    mut num_live_nodes: uint;\n+    mut num_vars: uint;\n+    live_node_map: hashmap<node_id, LiveNode>;\n+    variable_map: hashmap<node_id, Variable>;\n+    field_map: hashmap<ident, Variable>;\n+    capture_map: hashmap<node_id, @~[CaptureInfo]>;\n+    mut var_kinds: ~[VarKind];\n+    mut lnks: ~[LiveNodeKind];\n+}\n+\n+fn IrMaps(tcx: ty::ctxt, method_map: typeck::method_map,\n+          last_use_map: last_use_map) -> IrMaps {\n+    IrMaps {\n+        tcx: tcx,\n+        method_map: method_map,\n+        last_use_map: last_use_map,\n+        num_live_nodes: 0u,\n+        num_vars: 0u,\n+        live_node_map: int_hash(),\n+        variable_map: int_hash(),\n+        capture_map: int_hash(),\n+        field_map: uint_hash(),\n+        var_kinds: ~[],\n+        lnks: ~[]\n+    }\n+}\n+\n+impl IrMaps {\n+    fn add_live_node(lnk: LiveNodeKind) -> LiveNode {\n+        let ln = LiveNode(self.num_live_nodes);\n         vec::push(self.lnks, lnk);\n         self.num_live_nodes += 1u;\n \n@@ -248,26 +257,27 @@ struct ir_maps {\n         ln\n     }\n \n-    fn add_live_node_for_node(node_id: node_id, lnk: live_node_kind) {\n+    fn add_live_node_for_node(node_id: node_id, lnk: LiveNodeKind) {\n         let ln = self.add_live_node(lnk);\n         self.live_node_map.insert(node_id, ln);\n \n         debug!(\"%s is node %d\", ln.to_str(), node_id);\n     }\n \n-    fn add_variable(vk: var_kind) -> variable {\n-        let v = variable(self.num_vars);\n+    fn add_variable(vk: VarKind) -> Variable {\n+        let v = Variable(self.num_vars);\n         vec::push(self.var_kinds, vk);\n         self.num_vars += 1u;\n \n         match vk {\n-          vk_local(node_id, _) | vk_arg(node_id, _, _) => {\n+          Local(LocalInfo {id:node_id, _}) |\n+          Arg(node_id, _, _) => {\n             self.variable_map.insert(node_id, v);\n           }\n-          vk_field(name) => {\n+          Field(name) => {\n             self.field_map.insert(name, v);\n           }\n-          vk_self | vk_implicit_ret => {\n+          Self | ImplicitRet => {\n           }\n         }\n \n@@ -276,7 +286,7 @@ struct ir_maps {\n         v\n     }\n \n-    fn variable(node_id: node_id, span: span) -> variable {\n+    fn variable(node_id: node_id, span: span) -> Variable {\n         match self.variable_map.find(node_id) {\n           some(var) => var,\n           none => {\n@@ -286,20 +296,21 @@ struct ir_maps {\n         }\n     }\n \n-    fn variable_name(var: variable) -> ~str {\n+    fn variable_name(var: Variable) -> ~str {\n         match copy self.var_kinds[*var] {\n-          vk_local(_, nm) | vk_arg(_, nm, _) => self.tcx.sess.str_of(nm),\n-          vk_field(nm) => ~\"self.\" + self.tcx.sess.str_of(nm),\n-          vk_self => ~\"self\",\n-          vk_implicit_return => ~\"<implicit-ret>\"\n+          Local(LocalInfo {ident: nm, _}) |\n+          Arg(_, nm, _) => self.tcx.sess.str_of(nm),\n+          Field(nm) => ~\"self.\" + self.tcx.sess.str_of(nm),\n+          Self => ~\"self\",\n+          ImplicitRet => ~\"<implicit-ret>\"\n         }\n     }\n \n-    fn set_captures(node_id: node_id, +cs: ~[capture_info]) {\n+    fn set_captures(node_id: node_id, +cs: ~[CaptureInfo]) {\n         self.capture_map.insert(node_id, @cs);\n     }\n \n-    fn captures(expr: @expr) -> @~[capture_info] {\n+    fn captures(expr: @expr) -> @~[CaptureInfo] {\n         match self.capture_map.find(expr.id) {\n           some(caps) => caps,\n           none => {\n@@ -308,17 +319,17 @@ struct ir_maps {\n         }\n     }\n \n-    fn lnk(ln: live_node) -> live_node_kind {\n+    fn lnk(ln: LiveNode) -> LiveNodeKind {\n         self.lnks[*ln]\n     }\n \n-    fn add_last_use(expr_id: node_id, var: variable) {\n+    fn add_last_use(expr_id: node_id, var: Variable) {\n         let vk = self.var_kinds[*var];\n         debug!(\"Node %d is a last use of variable %?\", expr_id, vk);\n         match vk {\n-          vk_arg(id, name, by_move) |\n-          vk_arg(id, name, by_copy) |\n-          vk_local(id, name) => {\n+          Arg(id, name, by_move) |\n+          Arg(id, name, by_copy) |\n+          Local(LocalInfo {id:id, ident:name, _}) => {\n             let v = match self.last_use_map.find(expr_id) {\n               some(v) => v,\n               none => {\n@@ -330,29 +341,29 @@ struct ir_maps {\n \n             (*v).push(id);\n           }\n-          vk_arg(_, _, by_ref) | vk_arg(_, _, by_mutbl_ref) |\n-          vk_arg(_, _, by_val) | vk_self | vk_field(_) | vk_implicit_ret => {\n+          Arg(_, _, by_ref) | Arg(_, _, by_mutbl_ref) |\n+          Arg(_, _, by_val) | Self | Field(_) | ImplicitRet => {\n             debug!(\"--but it is not owned\");\n           }\n         }\n     }\n }\n \n fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n-            sp: span, id: node_id, &&self: @ir_maps, v: vt<@ir_maps>) {\n+            sp: span, id: node_id, &&self: @IrMaps, v: vt<@IrMaps>) {\n     debug!(\"visit_fn: id=%d\", id);\n     let _i = util::common::indenter();\n \n     // swap in a new set of IR maps for this function body:\n-    let fn_maps = @ir_maps(self.tcx, self.method_map,\n-                           self.last_use_map);\n+    let fn_maps = @IrMaps(self.tcx, self.method_map,\n+                          self.last_use_map);\n \n     debug!(\"creating fn_maps: %x\", ptr::addr_of(*fn_maps) as uint);\n \n     for decl.inputs.each |arg| {\n         debug!(\"adding argument %d\", arg.id);\n         let mode = ty::resolved_mode(self.tcx, arg.mode);\n-        (*fn_maps).add_variable(vk_arg(arg.id, arg.ident, mode));\n+        (*fn_maps).add_variable(Arg(arg.id, arg.ident, mode));\n     };\n \n     // gather up the various local variables, significant expressions,\n@@ -371,14 +382,14 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     // - implicit_ret_var is a pseudo-variable that represents\n     //   an implicit return\n     let specials = {\n-        exit_ln: (*fn_maps).add_live_node(lnk_exit),\n-        fallthrough_ln: (*fn_maps).add_live_node(lnk_exit),\n-        no_ret_var: (*fn_maps).add_variable(vk_implicit_ret),\n-        self_var: (*fn_maps).add_variable(vk_self)\n+        exit_ln: (*fn_maps).add_live_node(ExitNode),\n+        fallthrough_ln: (*fn_maps).add_live_node(ExitNode),\n+        no_ret_var: (*fn_maps).add_variable(ImplicitRet),\n+        self_var: (*fn_maps).add_variable(Self)\n     };\n \n     // compute liveness\n-    let lsets = @liveness(fn_maps, specials);\n+    let lsets = @Liveness(fn_maps, specials);\n     let entry_ln = (*lsets).compute(decl, body);\n \n     // check for various error conditions\n@@ -394,33 +405,38 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     lsets.warn_about_unused_args(sp, decl, entry_ln);\n }\n \n-fn add_class_fields(self: @ir_maps, did: def_id) {\n+fn add_class_fields(self: @IrMaps, did: def_id) {\n     for ty::lookup_class_fields(self.tcx, did).each |field_ty| {\n         assert field_ty.id.crate == local_crate;\n-        let var = (*self).add_variable(vk_field(field_ty.ident));\n+        let var = self.add_variable(Field(field_ty.ident));\n         self.field_map.insert(field_ty.ident, var);\n     }\n }\n \n-fn visit_local(local: @local, &&self: @ir_maps, vt: vt<@ir_maps>) {\n+fn visit_local(local: @local, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     let def_map = self.tcx.def_map;\n     do pat_util::pat_bindings(def_map, local.node.pat) |_bm, p_id, sp, path| {\n         debug!(\"adding local variable %d\", p_id);\n         let name = ast_util::path_to_ident(path);\n-        (*self).add_live_node_for_node(p_id, lnk_vdef(sp));\n-        (*self).add_variable(vk_local(p_id, name));\n+        self.add_live_node_for_node(p_id, VarDefNode(sp));\n+        self.add_variable(Local(LocalInfo {\n+            id: p_id,\n+            ident: name,\n+            is_mutbl: local.node.is_mutbl,\n+            initialized: local.node.init.is_some()\n+        }));\n     }\n     visit::visit_local(local, self, vt);\n }\n \n-fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n+fn visit_expr(expr: @expr, &&self: @IrMaps, vt: vt<@IrMaps>) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n       expr_path(_) => {\n         let def = self.tcx.def_map.get(expr.id);\n         debug!(\"expr %d: path that leads to %?\", expr.id, def);\n         if relevant_def(def).is_some() {\n-            (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+            self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         visit::visit_expr(expr, self, vt);\n       }\n@@ -437,7 +453,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n         for cvs.each |cv| {\n             match relevant_def(cv.def) {\n               some(rv) => {\n-                let cv_ln = (*self).add_live_node(lnk_freevar(cv.span));\n+                let cv_ln = self.add_live_node(FreeVarNode(cv.span));\n                 let is_move = match cv.mode {\n                   cap_move | cap_drop => true, // var must be dead afterwards\n                   cap_copy | cap_ref => false // var can still be used\n@@ -447,18 +463,18 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n               none => {}\n             }\n         }\n-        (*self).set_captures(expr.id, call_caps);\n+        self.set_captures(expr.id, call_caps);\n \n         visit::visit_expr(expr, self, vt);\n       }\n \n       // live nodes required for interesting control flow:\n       expr_if(*) | expr_match(*) | expr_while(*) | expr_loop(*) => {\n-        (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+        self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::visit_expr(expr, self, vt);\n       }\n       expr_binary(op, _, _) if ast_util::lazy_binop(op) => {\n-        (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n+        self.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::visit_expr(expr, self, vt);\n       }\n \n@@ -485,54 +501,56 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n // the same basic propagation framework in all cases.\n \n type users = {\n-    reader: live_node,\n-    writer: live_node,\n+    reader: LiveNode,\n+    writer: LiveNode,\n     used: bool\n };\n \n fn invalid_users() -> users {\n     {reader: invalid_node(), writer: invalid_node(), used: false}\n }\n \n-type specials = {\n-    exit_ln: live_node,\n-    fallthrough_ln: live_node,\n-    no_ret_var: variable,\n-    self_var: variable\n+type Specials = {\n+    exit_ln: LiveNode,\n+    fallthrough_ln: LiveNode,\n+    no_ret_var: Variable,\n+    self_var: Variable\n };\n \n const ACC_READ: uint = 1u;\n const ACC_WRITE: uint = 2u;\n const ACC_USE: uint = 4u;\n \n-struct liveness {\n+struct Liveness {\n     let tcx: ty::ctxt;\n-    let ir: @ir_maps;\n-    let s: specials;\n-    let successors: ~[mut live_node];\n+    let ir: @IrMaps;\n+    let s: Specials;\n+    let successors: ~[mut LiveNode];\n     let users: ~[mut users];\n-    let mut break_ln: live_node;\n-    let mut cont_ln: live_node;\n-\n-    new(ir: @ir_maps, specials: specials) {\n-        self.ir = ir;\n-        self.tcx = ir.tcx;\n-        self.s = specials;\n-        self.successors =\n+    let mut break_ln: LiveNode;\n+    let mut cont_ln: LiveNode;\n+}\n+\n+fn Liveness(ir: @IrMaps, specials: Specials) -> Liveness {\n+    Liveness {\n+        ir: ir,\n+        tcx: ir.tcx,\n+        s: specials,\n+        successors:\n             vec::to_mut(\n-                vec::from_elem(self.ir.num_live_nodes,\n-                               invalid_node()));\n-        self.users =\n+                vec::from_elem(ir.num_live_nodes,\n+                               invalid_node())),\n+        users:\n             vec::to_mut(\n-                vec::from_elem(self.ir.num_live_nodes * self.ir.num_vars,\n-                               invalid_users()));\n-        self.break_ln = invalid_node();\n-        self.cont_ln = invalid_node();\n+                vec::from_elem(ir.num_live_nodes * ir.num_vars,\n+                               invalid_users())),\n+        break_ln: invalid_node(),\n+        cont_ln: invalid_node()\n     }\n+}\n \n-    // _______________________________________________________________________\n-\n-    fn live_node(node_id: node_id, span: span) -> live_node {\n+impl Liveness {\n+    fn live_node(node_id: node_id, span: span) -> LiveNode {\n         match self.ir.live_node_map.find(node_id) {\n           some(ln) => ln,\n           none => {\n@@ -547,14 +565,14 @@ struct liveness {\n         }\n     }\n \n-    fn variable_from_rdef(rv: relevant_def, span: span) -> variable {\n+    fn variable_from_rdef(rv: RelevantDef, span: span) -> Variable {\n         match rv {\n-          rdef_self => self.s.self_var,\n-          rdef_var(nid) => self.variable(nid, span)\n+          RelevantSelf => self.s.self_var,\n+          RelevantVar(nid) => self.variable(nid, span)\n         }\n     }\n \n-    fn variable_from_path(expr: @expr) -> option<variable> {\n+    fn variable_from_path(expr: @expr) -> option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(expr.id);\n@@ -566,12 +584,12 @@ struct liveness {\n         }\n     }\n \n-    fn variable(node_id: node_id, span: span) -> variable {\n+    fn variable(node_id: node_id, span: span) -> Variable {\n         (*self.ir).variable(node_id, span)\n     }\n \n     fn variable_from_def_map(node_id: node_id,\n-                             span: span) -> option<variable> {\n+                             span: span) -> option<Variable> {\n         match self.tcx.def_map.find(node_id) {\n           some(def) => {\n             relevant_def(def).map(\n@@ -585,7 +603,7 @@ struct liveness {\n         }\n     }\n \n-    fn pat_bindings(pat: @pat, f: fn(live_node, variable, span)) {\n+    fn pat_bindings(pat: @pat, f: fn(LiveNode, Variable, span)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -594,73 +612,73 @@ struct liveness {\n         }\n     }\n \n-    fn idx(ln: live_node, var: variable) -> uint {\n+    fn idx(ln: LiveNode, var: Variable) -> uint {\n         *ln * self.ir.num_vars + *var\n     }\n \n-    fn live_on_entry(ln: live_node, var: variable)\n-        -> option<live_node_kind> {\n+    fn live_on_entry(ln: LiveNode, var: Variable)\n+        -> option<LiveNodeKind> {\n \n         assert ln.is_valid();\n         let reader = self.users[self.idx(ln, var)].reader;\n         if reader.is_valid() {some((*self.ir).lnk(reader))} else {none}\n     }\n \n-    fn live_on_exit(ln: live_node, var: variable)\n-        -> option<live_node_kind> {\n+    fn live_on_exit(ln: LiveNode, var: Variable)\n+        -> option<LiveNodeKind> {\n \n         self.live_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn used_on_entry(ln: live_node, var: variable) -> bool {\n+    fn used_on_entry(ln: LiveNode, var: Variable) -> bool {\n         assert ln.is_valid();\n         self.users[self.idx(ln, var)].used\n     }\n \n-    fn assigned_on_entry(ln: live_node, var: variable)\n-        -> option<live_node_kind> {\n+    fn assigned_on_entry(ln: LiveNode, var: Variable)\n+        -> option<LiveNodeKind> {\n \n         assert ln.is_valid();\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {some((*self.ir).lnk(writer))} else {none}\n     }\n \n-    fn assigned_on_exit(ln: live_node, var: variable)\n-        -> option<live_node_kind> {\n+    fn assigned_on_exit(ln: LiveNode, var: Variable)\n+        -> option<LiveNodeKind> {\n \n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn indices(ln: live_node, op: fn(uint)) {\n-        let node_base_idx = self.idx(ln, variable(0u));\n+    fn indices(ln: LiveNode, op: fn(uint)) {\n+        let node_base_idx = self.idx(ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n         }\n     }\n \n-    fn indices2(ln: live_node, succ_ln: live_node,\n+    fn indices2(ln: LiveNode, succ_ln: LiveNode,\n                 op: fn(uint, uint)) {\n-        let node_base_idx = self.idx(ln, variable(0u));\n-        let succ_base_idx = self.idx(succ_ln, variable(0u));\n+        let node_base_idx = self.idx(ln, Variable(0u));\n+        let succ_base_idx = self.idx(succ_ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx, succ_base_idx + var_idx);\n         }\n     }\n \n     fn write_vars(wr: io::Writer,\n-                  ln: live_node,\n-                  test: fn(uint) -> live_node) {\n-        let node_base_idx = self.idx(ln, variable(0u));\n+                  ln: LiveNode,\n+                  test: fn(uint) -> LiveNode) {\n+        let node_base_idx = self.idx(ln, Variable(0u));\n         for uint::range(0u, self.ir.num_vars) |var_idx| {\n             let idx = node_base_idx + var_idx;\n             if test(idx).is_valid() {\n                 wr.write_str(~\" \");\n-                wr.write_str(variable(var_idx).to_str());\n+                wr.write_str(Variable(var_idx).to_str());\n             }\n         }\n     }\n \n-    fn ln_str(ln: live_node) -> ~str {\n+    fn ln_str(ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(~\"[ln(\");\n             wr.write_uint(*ln);\n@@ -677,7 +695,7 @@ struct liveness {\n         }\n     }\n \n-    fn init_empty(ln: live_node, succ_ln: live_node) {\n+    fn init_empty(ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[*ln] = succ_ln;\n \n         // It is not necessary to initialize the\n@@ -690,7 +708,7 @@ struct liveness {\n         // }\n     }\n \n-    fn init_from_succ(ln: live_node, succ_ln: live_node) {\n+    fn init_from_succ(ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[*ln] = succ_ln;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n@@ -700,7 +718,7 @@ struct liveness {\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    fn merge_from_succ(ln: live_node, succ_ln: live_node,\n+    fn merge_from_succ(ln: LiveNode, succ_ln: LiveNode,\n                        first_merge: bool) -> bool {\n         if ln == succ_ln { return false; }\n \n@@ -720,7 +738,7 @@ struct liveness {\n                ln.to_str(), self.ln_str(succ_ln), first_merge, changed);\n         return changed;\n \n-        fn copy_if_invalid(src: live_node, &dst: live_node) -> bool {\n+        fn copy_if_invalid(src: LiveNode, &dst: LiveNode) -> bool {\n             if src.is_valid() {\n                 if !dst.is_valid() {\n                     dst = src;\n@@ -734,7 +752,7 @@ struct liveness {\n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n-    fn define(writer: live_node, var: variable) {\n+    fn define(writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n@@ -744,7 +762,7 @@ struct liveness {\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    fn acc(ln: live_node, var: variable, acc: uint) {\n+    fn acc(ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n         let user = &mut self.users[idx];\n \n@@ -769,11 +787,11 @@ struct liveness {\n \n     // _______________________________________________________________________\n \n-    fn compute(decl: fn_decl, body: blk) -> live_node {\n+    fn compute(decl: fn_decl, body: blk) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n-        let entry_ln: live_node =\n+        let entry_ln: LiveNode =\n             self.with_loop_nodes(self.s.exit_ln, self.s.exit_ln, || {\n                 self.propagate_through_fn_block(decl, body)\n             });\n@@ -782,7 +800,7 @@ struct liveness {\n         debug!(\"^^ liveness computation results for body %d (entry=%s)\",\n                {\n                    for uint::range(0u, self.ir.num_live_nodes) |ln_idx| {\n-                       #debug[\"%s\", self.ln_str(live_node(ln_idx))];\n+                       #debug[\"%s\", self.ln_str(LiveNode(ln_idx))];\n                    }\n                    body.node.id\n                },\n@@ -791,7 +809,7 @@ struct liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> live_node {\n+    fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> LiveNode {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n             match ty::resolved_mode(self.tcx, arg.mode) {\n@@ -828,14 +846,14 @@ struct liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(blk: blk, succ: live_node) -> live_node {\n+    fn propagate_through_block(blk: blk, succ: LiveNode) -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(stmt, succ)\n         }\n     }\n \n-    fn propagate_through_stmt(stmt: @stmt, succ: live_node) -> live_node {\n+    fn propagate_through_stmt(stmt: @stmt, succ: LiveNode) -> LiveNode {\n         match stmt.node {\n           stmt_decl(decl, _) => {\n             return self.propagate_through_decl(decl, succ);\n@@ -847,7 +865,7 @@ struct liveness {\n         }\n     }\n \n-    fn propagate_through_decl(decl: @decl, succ: live_node) -> live_node {\n+    fn propagate_through_decl(decl: @decl, succ: LiveNode) -> LiveNode {\n         match decl.node {\n           decl_local(locals) => {\n             do locals.foldr(succ) |local, succ| {\n@@ -860,7 +878,7 @@ struct liveness {\n         }\n     }\n \n-    fn propagate_through_local(local: @local, succ: live_node) -> live_node {\n+    fn propagate_through_local(local: @local, succ: LiveNode) -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n         // the live variable as defined if it was initialized, and then we\n@@ -886,20 +904,20 @@ struct liveness {\n     }\n \n     fn propagate_through_exprs(exprs: ~[@expr],\n-                               succ: live_node) -> live_node {\n+                               succ: LiveNode) -> LiveNode {\n         do exprs.foldr(succ) |expr, succ| {\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n \n     fn propagate_through_opt_expr(opt_expr: option<@expr>,\n-                                  succ: live_node) -> live_node {\n+                                  succ: LiveNode) -> LiveNode {\n         do opt_expr.foldl(succ) |succ, expr| {\n             self.propagate_through_expr(expr, succ)\n         }\n     }\n \n-    fn propagate_through_expr(expr: @expr, succ: live_node) -> live_node {\n+    fn propagate_through_expr(expr: @expr, succ: LiveNode) -> LiveNode {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n@@ -1142,7 +1160,7 @@ struct liveness {\n     }\n \n     fn propagate_through_lvalue_components(expr: @expr,\n-                                           succ: live_node) -> live_node {\n+                                           succ: LiveNode) -> LiveNode {\n         // # Lvalues\n         //\n         // In general, the full flow graph structure for an\n@@ -1205,8 +1223,8 @@ struct liveness {\n \n     // see comment on propagate_through_lvalue()\n     fn write_lvalue(expr: @expr,\n-                    succ: live_node,\n-                    acc: uint) -> live_node {\n+                    succ: LiveNode,\n+                    acc: uint) -> LiveNode {\n         match expr.node {\n           expr_path(_) => self.access_path(expr, succ, acc),\n           expr_field(e, nm, _) => match self.as_self_field(e, nm) {\n@@ -1226,10 +1244,10 @@ struct liveness {\n         }\n     }\n \n-    fn access_path(expr: @expr, succ: live_node, acc: uint) -> live_node {\n+    fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n         let def = self.tcx.def_map.get(expr.id);\n         match relevant_def(def) {\n-          some(rdef_self) => {\n+          some(RelevantSelf) => {\n             // Accessing `self` is like accessing every field of\n             // the current object. This allows something like\n             // `self = ...;` (it will be considered a write to\n@@ -1249,7 +1267,7 @@ struct liveness {\n             }\n             ln\n           }\n-          some(rdef_var(nid)) => {\n+          some(RelevantVar(nid)) => {\n             let ln = self.live_node(expr.id, expr.span);\n             if acc != 0u {\n                 self.init_from_succ(ln, succ);\n@@ -1263,7 +1281,7 @@ struct liveness {\n     }\n \n     fn as_self_field(expr: @expr,\n-                     fld: ident) -> option<(live_node,variable)> {\n+                     fld: ident) -> option<(LiveNode,Variable)> {\n         // If we checking a constructor, then we treat self.f as a\n         // variable.  we use the live_node id that will be assigned to\n         // the reference to self but the variable id for `f`.\n@@ -1288,7 +1306,7 @@ struct liveness {\n     fn propagate_through_loop(expr: @expr,\n                               cond: option<@expr>,\n                               body: blk,\n-                              succ: live_node) -> live_node {\n+                              succ: LiveNode) -> LiveNode {\n \n         /*\n \n@@ -1336,8 +1354,8 @@ struct liveness {\n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(break_ln: live_node,\n-                          cont_ln: live_node,\n+    fn with_loop_nodes<R>(break_ln: LiveNode,\n+                          cont_ln: LiveNode,\n                           f: fn() -> R) -> R {\n         let bl = self.break_ln, cl = self.cont_ln;\n         self.break_ln = break_ln;\n@@ -1352,7 +1370,7 @@ struct liveness {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n+fn check_local(local: @local, &&self: @Liveness, vt: vt<@Liveness>) {\n     match local.node.init {\n       some({op: op, expr: expr}) => {\n \n@@ -1373,14 +1391,14 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n         // should not be live at this point.\n \n         debug!(\"check_local() with no initializer\");\n-        do (*self).pat_bindings(local.node.pat) |ln, var, sp| {\n+        do self.pat_bindings(local.node.pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n-                match (*self).live_on_exit(ln, var) {\n+                match self.live_on_exit(ln, var) {\n                   none => { /* not live: good */ }\n                   some(lnk) => {\n                     self.report_illegal_read(\n                         local.span, lnk, var,\n-                        possibly_uninitialized_variable);\n+                        PossiblyUninitializedVariable);\n                   }\n                 }\n             }\n@@ -1391,11 +1409,11 @@ fn check_local(local: @local, &&self: @liveness, vt: vt<@liveness>) {\n     visit::visit_local(local, self, vt);\n }\n \n-fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n+fn check_expr(expr: @expr, &&self: @Liveness, vt: vt<@Liveness>) {\n     match expr.node {\n       expr_path(_) => {\n-        for (*self).variable_from_def_map(expr.id, expr.span).each |var| {\n-            let ln = (*self).live_node(expr.id, expr.span);\n+        for self.variable_from_def_map(expr.id, expr.span).each |var| {\n+            let ln = self.live_node(expr.id, expr.span);\n             self.consider_last_use(expr, ln, var);\n         }\n \n@@ -1405,7 +1423,7 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       expr_fn(_, _, _, cap_clause) | expr_fn_block(_, _, cap_clause) => {\n         let caps = (*self.ir).captures(expr);\n         for (*caps).each |cap| {\n-            let var = (*self).variable_from_rdef(cap.rv, expr.span);\n+            let var = self.variable_from_rdef(cap.rv, expr.span);\n             self.consider_last_use(expr, cap.ln, var);\n             if cap.is_move {\n                 self.check_move_from_var(expr.span, cap.ln, var);\n@@ -1475,37 +1493,37 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n \n fn check_fn(_fk: visit::fn_kind, _decl: fn_decl,\n             _body: blk, _sp: span, _id: node_id,\n-            &&_self: @liveness, _v: vt<@liveness>) {\n+            &&_self: @Liveness, _v: vt<@Liveness>) {\n     // do not check contents of nested fns\n }\n \n-enum read_kind {\n-    possibly_uninitialized_variable,\n-    possibly_uninitialized_field,\n-    moved_variable\n+enum ReadKind {\n+    PossiblyUninitializedVariable,\n+    PossiblyUninitializedField,\n+    MovedVariable\n }\n \n-impl @liveness {\n-    fn check_fields(sp: span, entry_ln: live_node) {\n+impl @Liveness {\n+    fn check_fields(sp: span, entry_ln: LiveNode) {\n         for self.ir.field_map.each |nm, var| {\n-            match (*self).live_on_entry(entry_ln, var) {\n+            match self.live_on_entry(entry_ln, var) {\n               none => { /* ok */ }\n-              some(lnk_exit) => {\n+              some(ExitNode) => {\n                 self.tcx.sess.span_err(\n                     sp, fmt!(\"field `self.%s` is never initialized\",\n                              self.tcx.sess.str_of(nm)));\n               }\n               some(lnk) => {\n                 self.report_illegal_read(\n-                    sp, lnk, var, possibly_uninitialized_field);\n+                    sp, lnk, var, PossiblyUninitializedField);\n               }\n             }\n         }\n     }\n \n     fn check_ret(id: node_id, sp: span, fk: visit::fn_kind,\n-                 entry_ln: live_node) {\n-        if (*self).live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n+                 entry_ln: LiveNode) {\n+        if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n             // function without any kind of return expression:\n \n@@ -1530,24 +1548,24 @@ impl @liveness {\n         }\n     }\n \n-    fn check_move_from_var(span: span, ln: live_node, var: variable) {\n+    fn check_move_from_var(span: span, ln: LiveNode, var: Variable) {\n         debug!(\"check_move_from_var(%s, %s)\",\n                ln.to_str(), var.to_str());\n \n-        match (*self).live_on_exit(ln, var) {\n+        match self.live_on_exit(ln, var) {\n           none => {}\n           some(lnk) => self.report_illegal_move(span, lnk, var)\n         }\n     }\n \n-    fn consider_last_use(expr: @expr, ln: live_node, var: variable) {\n-        match (*self).live_on_exit(ln, var) {\n+    fn consider_last_use(expr: @expr, ln: LiveNode, var: Variable) {\n+        match self.live_on_exit(ln, var) {\n           some(_) => {}\n           none => (*self.ir).add_last_use(expr.id, var)\n        }\n     }\n \n-    fn check_move_from_expr(expr: @expr, vt: vt<@liveness>) {\n+    fn check_move_from_expr(expr: @expr, vt: vt<@Liveness>) {\n         debug!(\"check_move_from_expr(node %d: %s)\",\n                expr.id, expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1558,9 +1576,9 @@ impl @liveness {\n \n         match expr.node {\n           expr_path(_) => {\n-            match (*self).variable_from_path(expr) {\n+            match self.variable_from_path(expr) {\n               some(var) => {\n-                let ln = (*self).live_node(expr.id, expr.span);\n+                let ln = self.live_node(expr.id, expr.span);\n                 self.check_move_from_var(expr.span, ln, var);\n               }\n               none => {}\n@@ -1590,26 +1608,26 @@ impl @liveness {\n        }\n     }\n \n-    fn check_lvalue(expr: @expr, vt: vt<@liveness>) {\n+    fn check_lvalue(expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get(expr.id) {\n               def_local(nid, false) => {\n                 // Assignment to an immutable variable or argument:\n                 // only legal if there is no later assignment.\n-                let ln = (*self).live_node(expr.id, expr.span);\n-                let var = (*self).variable(nid, expr.span);\n+                let ln = self.live_node(expr.id, expr.span);\n+                let var = self.variable(nid, expr.span);\n                 self.check_for_reassignment(ln, var, expr.span);\n                 self.warn_about_dead_assign(expr.span, ln, var);\n               }\n               def => {\n                 match relevant_def(def) {\n-                  some(rdef_var(nid)) => {\n-                    let ln = (*self).live_node(expr.id, expr.span);\n-                    let var = (*self).variable(nid, expr.span);\n+                  some(RelevantVar(nid)) => {\n+                    let ln = self.live_node(expr.id, expr.span);\n+                    let var = self.variable(nid, expr.span);\n                     self.warn_about_dead_assign(expr.span, ln, var);\n                   }\n-                  some(rdef_self) => {}\n+                  some(RelevantSelf) => {}\n                   none => {}\n                 }\n               }\n@@ -1625,15 +1643,15 @@ impl @liveness {\n     }\n \n     fn check_for_reassignments_in_pat(pat: @pat) {\n-        do (*self).pat_bindings(pat) |ln, var, sp| {\n+        do self.pat_bindings(pat) |ln, var, sp| {\n             self.check_for_reassignment(ln, var, sp);\n         }\n     }\n \n-    fn check_for_reassignment(ln: live_node, var: variable,\n+    fn check_for_reassignment(ln: LiveNode, var: Variable,\n                               orig_span: span) {\n-        match (*self).assigned_on_exit(ln, var) {\n-          some(lnk_expr(span)) => {\n+        match self.assigned_on_exit(ln, var) {\n+          some(ExprNode(span)) => {\n             self.tcx.sess.span_err(\n                 span,\n                 ~\"re-assignment of immutable variable\");\n@@ -1652,37 +1670,37 @@ impl @liveness {\n     }\n \n     fn report_illegal_move(move_span: span,\n-                           lnk: live_node_kind,\n-                           var: variable) {\n+                           lnk: LiveNodeKind,\n+                           var: Variable) {\n \n         // the only time that it is possible to have a moved variable\n-        // used by lnk_exit would be arguments or fields in a ctor.\n+        // used by ExitNode would be arguments or fields in a ctor.\n         // we give a slightly different error message in those cases.\n-        if lnk == lnk_exit {\n+        if lnk == ExitNode {\n             let vk = self.ir.var_kinds[*var];\n             match vk {\n-              vk_arg(_, name, _) => {\n+              Arg(_, name, _) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     fmt!(\"illegal move from argument `%s`, which is not \\\n                           copy or move mode\", self.tcx.sess.str_of(name)));\n                 return;\n               }\n-              vk_field(name) => {\n+              Field(name) => {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     fmt!(\"illegal move from field `%s`\",\n                          self.tcx.sess.str_of(name)));\n                 return;\n               }\n-              vk_self => {\n+              Self => {\n                 self.tcx.sess.span_err(\n                     move_span,\n                     ~\"illegal move from self (cannot move out of a field of \\\n                        self)\");\n                 return;\n               }\n-              vk_local(*) | vk_implicit_ret => {\n+              Local(*) | ImplicitRet => {\n                 self.tcx.sess.span_bug(\n                     move_span,\n                     fmt!(\"illegal reader (%?) for `%?`\",\n@@ -1691,59 +1709,59 @@ impl @liveness {\n             }\n         }\n \n-        self.report_illegal_read(move_span, lnk, var, moved_variable);\n+        self.report_illegal_read(move_span, lnk, var, MovedVariable);\n         self.tcx.sess.span_note(\n             move_span, ~\"move of variable occurred here\");\n \n     }\n \n     fn report_illegal_read(chk_span: span,\n-                           lnk: live_node_kind,\n-                           var: variable,\n-                           rk: read_kind) {\n+                           lnk: LiveNodeKind,\n+                           var: Variable,\n+                           rk: ReadKind) {\n         let msg = match rk {\n-          possibly_uninitialized_variable => {\n+          PossiblyUninitializedVariable => {\n             ~\"possibly uninitialized variable\"\n           }\n-          possibly_uninitialized_field => ~\"possibly uninitialized field\",\n-          moved_variable => ~\"moved variable\"\n+          PossiblyUninitializedField => ~\"possibly uninitialized field\",\n+          MovedVariable => ~\"moved variable\"\n         };\n         let name = (*self.ir).variable_name(var);\n         match lnk {\n-          lnk_freevar(span) => {\n+          FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n                 fmt!(\"capture of %s: `%s`\", msg, name));\n           }\n-          lnk_expr(span) => {\n+          ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n                 fmt!(\"use of %s: `%s`\", msg, name));\n           }\n-          lnk_exit |\n-          lnk_vdef(_) => {\n+          ExitNode |\n+          VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n                 chk_span,\n                 fmt!(\"illegal reader: %?\", lnk));\n           }\n         }\n     }\n \n-    fn should_warn(var: variable) -> option<~str> {\n+    fn should_warn(var: Variable) -> option<~str> {\n         let name = (*self.ir).variable_name(var);\n         if name[0] == ('_' as u8) {none} else {some(name)}\n     }\n \n-    fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: live_node) {\n+    fn warn_about_unused_args(sp: span, decl: fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n-            let var = (*self).variable(arg.id, arg.ty.span);\n+            let var = self.variable(arg.id, arg.ty.span);\n             match ty::resolved_mode(self.tcx, arg.mode) {\n               by_mutbl_ref => {\n                 // for mutable reference arguments, something like\n                 //    x = 1;\n                 // is not worth warning about, as it has visible\n                 // side effects outside the fn.\n-                match (*self).assigned_on_entry(entry_ln, var) {\n+                match self.assigned_on_entry(entry_ln, var) {\n                   some(_) => { /*ok*/ }\n                   none => {\n                     // but if it is not written, it ought to be used\n@@ -1759,15 +1777,15 @@ impl @liveness {\n     }\n \n     fn warn_about_unused_or_dead_vars_in_pat(pat: @pat) {\n-        do (*self).pat_bindings(pat) |ln, var, sp| {\n+        do self.pat_bindings(pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 self.warn_about_dead_assign(sp, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(sp: span, ln: live_node, var: variable) -> bool {\n-        if !(*self).used_on_entry(ln, var) {\n+    fn warn_about_unused(sp: span, ln: LiveNode, var: Variable) -> bool {\n+        if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n \n                 // annoying: for parameters in funcs like `fn(x: int)\n@@ -1776,7 +1794,7 @@ impl @liveness {\n                 let is_assigned = if ln == self.s.exit_ln {\n                     false\n                 } else {\n-                    (*self).assigned_on_exit(ln, var).is_some()\n+                    self.assigned_on_exit(ln, var).is_some()\n                 };\n \n                 if is_assigned {\n@@ -1793,8 +1811,8 @@ impl @liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(sp: span, ln: live_node, var: variable) {\n-        if (*self).live_on_exit(ln, var).is_none() {\n+    fn warn_about_dead_assign(sp: span, ln: LiveNode, var: Variable) {\n+        if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n                 self.tcx.sess.span_warn(\n                     sp,"}, {"sha": "9fe6b8b8407bdb042875fe36daf000b5791cbdf9", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=3cf74564b8fbe1a5a179333a533851815879ff46", "patch": "@@ -1,4 +1,4 @@\n-#[warn(deprecated_mode)];\n+// #[warn(deprecated_mode)];\n #[warn(deprecated_pattern)];\n \n import std::{map, smallintmap};"}, {"sha": "7920286fcddba020f21e274fee7689e0e3e0e3b5", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cf74564b8fbe1a5a179333a533851815879ff46/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=3cf74564b8fbe1a5a179333a533851815879ff46", "patch": "@@ -705,12 +705,13 @@ impl @fn_ctxt {\n     }\n \n     fn region_var_if_parameterized(rp: option<ty::region_variance>,\n-                                   span: span)\n-        -> option<ty::region> {\n-        match rp {\n-          some(_) => some(self.infcx.next_region_var_nb(span)),\n-          none => none\n-        }\n+                                   span: span,\n+                                   lower_bound: ty::region)\n+        -> option<ty::region>\n+    {\n+        rp.map(\n+            |_rp| self.infcx.next_region_var_with_lb(span,\n+                                                     lower_bound))\n     }\n }\n \n@@ -1877,7 +1878,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Generate the struct type.\n         let self_region =\n             fcx.region_var_if_parameterized(region_parameterized,\n-                                            expr.span);\n+                                            expr.span,\n+                                            ty::re_scope(expr.id));\n         let type_parameters = fcx.infcx.next_ty_vars(type_parameter_count);\n         let substitutions = {\n             self_r: self_region,\n@@ -2373,7 +2375,7 @@ fn instantiate_path(fcx: @fn_ctxt,\n       }\n       none => {\n         fcx.region_var_if_parameterized(\n-            tpt.region_param, span)\n+            tpt.region_param, span, region_lb)\n       }\n     };\n "}]}