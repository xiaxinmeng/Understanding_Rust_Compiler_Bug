{"sha": "81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZGNjYjFhNWM3YjY3YzYxY2I3ZWI0MjExNTBjNjcxZDZlMWE3ZGU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-02-07T14:01:23Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2020-02-10T14:46:41Z"}, "message": "self-profile: Support arguments for generic_activities.", "tree": {"sha": "02d567fd5b0b653fc7b68fd372933a296e499222", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02d567fd5b0b653fc7b68fd372933a296e499222"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "html_url": "https://github.com/rust-lang/rust/commit/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871", "html_url": "https://github.com/rust-lang/rust/commit/b5e21dbb5cabdaaadc47a4d8e3f59979dcad2871"}], "stats": {"total": 287, "additions": 169, "deletions": 118}, "files": [{"sha": "01f684dc65c30998b1959e262ae98e10fd3412bb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -1053,8 +1053,10 @@ where\n     Q: super::config::QueryDescription<'tcx, Value: Encodable>,\n     E: 'a + TyEncoder,\n {\n-    let desc = &format!(\"encode_query_results_for_{}\", ::std::any::type_name::<Q>());\n-    let _timer = tcx.sess.prof.extra_verbose_generic_activity(desc);\n+    let _timer = tcx\n+        .sess\n+        .prof\n+        .extra_verbose_generic_activity(\"encode_query_results_for\", ::std::any::type_name::<Q>());\n \n     let shards = Q::query_cache(tcx).lock_shards();\n     assert!(shards.iter().all(|shard| shard.active.is_empty()));"}, {"sha": "76a6ffbb1c5b2049cf6620166288b53bb51d38fb", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -110,23 +110,21 @@ fn prepare_lto(\n                 symbol_white_list.extend(exported_symbols[&cnum].iter().filter_map(symbol_filter));\n             }\n \n-            let _timer = cgcx.prof.generic_activity(\"LLVM_lto_load_upstream_bitcode\");\n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n             let bytecodes = archive\n                 .iter()\n                 .filter_map(|child| child.ok().and_then(|c| c.name().map(|name| (name, c))))\n                 .filter(|&(name, _)| name.ends_with(RLIB_BYTECODE_EXTENSION));\n             for (name, data) in bytecodes {\n+                let _timer =\n+                    cgcx.prof.generic_activity_with_arg(\"LLVM_lto_load_upstream_bitcode\", name);\n                 info!(\"adding bytecode {}\", name);\n                 let bc_encoded = data.data();\n \n-                let (bc, id) = cgcx\n-                    .prof\n-                    .extra_verbose_generic_activity(&format!(\"decode {}\", name))\n-                    .run(|| match DecodedBytecode::new(bc_encoded) {\n-                        Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n-                        Err(e) => Err(diag_handler.fatal(&e)),\n-                    })?;\n+                let (bc, id) = match DecodedBytecode::new(bc_encoded) {\n+                    Ok(b) => Ok((b.bytecode(), b.identifier().to_string())),\n+                    Err(e) => Err(diag_handler.fatal(&e)),\n+                }?;\n                 let bc = SerializedModule::FromRlib(bc);\n                 upstream_modules.push((bc, CString::new(id).unwrap()));\n             }\n@@ -281,14 +279,14 @@ fn fat_lto(\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_fat_lto_link_module\", format!(\"{:?}\", name));\n             info!(\"linking {:?}\", name);\n-            cgcx.prof.extra_verbose_generic_activity(&format!(\"ll link {:?}\", name)).run(|| {\n-                let data = bc_decoded.data();\n-                linker.add(&data).map_err(|()| {\n-                    let msg = format!(\"failed to load bc of {:?}\", name);\n-                    write::llvm_err(&diag_handler, &msg)\n-                })\n+            let data = bc_decoded.data();\n+            linker.add(&data).map_err(|()| {\n+                let msg = format!(\"failed to load bc of {:?}\", name);\n+                write::llvm_err(&diag_handler, &msg)\n             })?;\n             serialized_bitcode.push(bc_decoded);\n         }\n@@ -577,6 +575,8 @@ pub(crate) fn run_pass_manager(\n     config: &ModuleConfig,\n     thin: bool,\n ) {\n+    let _timer = cgcx.prof.extra_verbose_generic_activity(\"LLVM_lto_optimize\", &module.name[..]);\n+\n     // Now we have one massive module inside of llmod. Time to run the\n     // LTO-specific optimization passes that LLVM provides.\n     //\n@@ -634,9 +634,7 @@ pub(crate) fn run_pass_manager(\n             llvm::LLVMRustAddPass(pm, pass.unwrap());\n         }\n \n-        cgcx.prof\n-            .extra_verbose_generic_activity(\"LTO_passes\")\n-            .run(|| llvm::LLVMRunPassManager(pm, module.module_llvm.llmod()));\n+        llvm::LLVMRunPassManager(pm, module.module_llvm.llmod());\n \n         llvm::LLVMDisposePassManager(pm);\n     }\n@@ -760,7 +758,9 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_remove_landing_pads\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_remove_landing_pads\", thin_module.name());\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n         }\n@@ -774,7 +774,8 @@ pub unsafe fn optimize_thin_module(\n         // You can find some more comments about these functions in the LLVM\n         // bindings we've got (currently `PassWrapper.cpp`)\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_rename\");\n+            let _timer =\n+                cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_rename\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -783,7 +784,9 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_resolve_weak\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_resolve_weak\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -792,7 +795,9 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_internalize\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_internalize\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -801,7 +806,8 @@ pub unsafe fn optimize_thin_module(\n         }\n \n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_import\");\n+            let _timer =\n+                cgcx.prof.generic_activity_with_arg(\"LLVM_thin_lto_import\", thin_module.name());\n             if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n                 let msg = \"failed to prepare thin LTO module\";\n                 return Err(write::llvm_err(&diag_handler, msg));\n@@ -839,7 +845,9 @@ pub unsafe fn optimize_thin_module(\n         // so it appears). Hopefully we can remove this once upstream bugs are\n         // fixed in LLVM.\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_patch_debuginfo\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_thin_lto_patch_debuginfo\", thin_module.name());\n             llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n         }\n@@ -850,7 +858,6 @@ pub unsafe fn optimize_thin_module(\n         // populate a thin-specific pass manager, which presumably LLVM treats a\n         // little differently.\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_optimize\");\n             info!(\"running thin lto passes over {}\", module.name);\n             let config = cgcx.config(module.kind);\n             run_pass_manager(cgcx, &module, config, true);"}, {"sha": "7dd57da90c3d60f40372332e88757c520ced5733", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 37, "deletions": 32, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -310,7 +310,7 @@ pub(crate) unsafe fn optimize(\n     module: &ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n ) -> Result<(), FatalError> {\n-    let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize\");\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_optimize\", &module.name[..]);\n \n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n@@ -424,23 +424,17 @@ pub(crate) unsafe fn optimize(\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n-            let desc = &format!(\"llvm function passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_function_passes\",\n+                &module.name[..],\n+            );\n             llvm::LLVMRustRunFunctionPassManager(fpm, llmod);\n         }\n         {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n-            let desc = &format!(\"llvm module passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n+            let _timer = cgcx.prof.extra_verbose_generic_activity(\n+                \"LLVM_module_optimize_module_passes\",\n+                &module.name[..],\n+            );\n             llvm::LLVMRunPassManager(mpm, llmod);\n         }\n \n@@ -480,7 +474,7 @@ pub(crate) unsafe fn codegen(\n     module: ModuleCodegen<ModuleLlvm>,\n     config: &ModuleConfig,\n ) -> Result<CompiledModule, FatalError> {\n-    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen\");\n+    let _timer = cgcx.prof.generic_activity_with_arg(\"LLVM_module_codegen\", &module.name[..]);\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -533,26 +527,36 @@ pub(crate) unsafe fn codegen(\n         let obj_out = cgcx.output_filenames.temp_path(OutputType::Object, module_name);\n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_make_bitcode\");\n+            let _timer = cgcx\n+                .prof\n+                .generic_activity_with_arg(\"LLVM_module_codegen_make_bitcode\", &module.name[..]);\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n             if write_bc {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_emit_bitcode\",\n+                    &module.name[..],\n+                );\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n                     diag_handler.err(&msg);\n                 }\n             }\n \n             if config.embed_bitcode {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_embed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_embed_bitcode\",\n+                    &module.name[..],\n+                );\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n \n             if config.emit_bc_compressed {\n-                let _timer =\n-                    cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_compressed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity_with_arg(\n+                    \"LLVM_module_codegen_emit_compressed_bitcode\",\n+                    &module.name[..],\n+                );\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n@@ -565,15 +569,10 @@ pub(crate) unsafe fn codegen(\n         }\n \n         {\n-            let desc = &format!(\"codegen passes [{}]\", module_name.unwrap());\n-            let _timer = if config.time_module {\n-                Some(cgcx.prof.extra_verbose_generic_activity(desc))\n-            } else {\n-                None\n-            };\n-\n             if config.emit_ir {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_ir\", &module.name[..]);\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out_c = path_to_c_string(&out);\n \n@@ -618,7 +617,9 @@ pub(crate) unsafe fn codegen(\n             }\n \n             if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_asm\", &module.name[..]);\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -638,7 +639,9 @@ pub(crate) unsafe fn codegen(\n             }\n \n             if write_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_emit_obj\", &module.name[..]);\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(\n                         diag_handler,\n@@ -650,7 +653,9 @@ pub(crate) unsafe fn codegen(\n                     )\n                 })?;\n             } else if asm_to_obj {\n-                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n+                let _timer = cgcx\n+                    .prof\n+                    .generic_activity_with_arg(\"LLVM_module_codegen_asm_to_obj\", &module.name[..]);\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n "}, {"sha": "d3b8f7ea33fab46971bbb567c9e0a0fa293675b0", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -1648,7 +1648,7 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = cratepath.file_name().unwrap().to_str().unwrap();\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n-        sess.prof.extra_verbose_generic_activity(&format!(\"altering {}.rlib\", name)).run(|| {\n+        sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n             let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n             archive.update_symbols();\n "}, {"sha": "9905b3a56c0fa1b7c936c858d1d044052b343e86", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -21,6 +21,7 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfilerRef;\n+use rustc_data_structures::profiling::TimingGuard;\n use rustc_data_structures::profiling::VerboseTimingGuard;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -691,11 +692,17 @@ impl<B: WriteBackendMethods> WorkItem<B> {\n         }\n     }\n \n-    fn profiling_event_id(&self) -> &'static str {\n+    fn start_profiling<'a>(&self, cgcx: &'a CodegenContext<B>) -> TimingGuard<'a> {\n         match *self {\n-            WorkItem::Optimize(_) => \"codegen_module_optimize\",\n-            WorkItem::CopyPostLtoArtifacts(_) => \"codegen_copy_artifacts_from_incr_cache\",\n-            WorkItem::LTO(_) => \"codegen_module_perform_lto\",\n+            WorkItem::Optimize(ref m) => {\n+                cgcx.prof.generic_activity_with_arg(\"codegen_module_optimize\", &m.name[..])\n+            }\n+            WorkItem::CopyPostLtoArtifacts(ref m) => cgcx\n+                .prof\n+                .generic_activity_with_arg(\"codegen_copy_artifacts_from_incr_cache\", &m.name[..]),\n+            WorkItem::LTO(ref m) => {\n+                cgcx.prof.generic_activity_with_arg(\"codegen_module_perform_lto\", m.name())\n+            }\n         }\n     }\n }\n@@ -1520,7 +1527,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         llvm_start_time: &mut Option<VerboseTimingGuard<'a>>,\n     ) {\n         if config.time_module && llvm_start_time.is_none() {\n-            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\"));\n+            *llvm_start_time = Some(prof.extra_verbose_generic_activity(\"LLVM_passes\", \"crate\"));\n         }\n     }\n }\n@@ -1575,7 +1582,7 @@ fn spawn_work<B: ExtraBackendMethods>(cgcx: CodegenContext<B>, work: WorkItem<B>\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let _prof_timer = cgcx.prof.generic_activity(work.profiling_event_id());\n+            let _prof_timer = work.start_profiling(&cgcx);\n             Some(execute_work_item(&cgcx, work))\n         };\n     });"}, {"sha": "debda9f0a0a24f409701eedb3e7d945f124803cc", "filename": "src/librustc_data_structures/profiling.rs", "status": "modified", "additions": 73, "deletions": 34, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_data_structures%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_data_structures%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fprofiling.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -83,6 +83,9 @@\n \n use crate::fx::FxHashMap;\n \n+use std::borrow::Borrow;\n+use std::collections::hash_map::Entry;\n+use std::convert::Into;\n use std::error::Error;\n use std::fs;\n use std::path::Path;\n@@ -123,11 +126,14 @@ bitflags::bitflags! {\n         const INCR_CACHE_LOADS   = 1 << 4;\n \n         const QUERY_KEYS         = 1 << 5;\n+        const FUNCTION_ARGS      = 1 << 6;\n \n         const DEFAULT = Self::GENERIC_ACTIVITIES.bits |\n                         Self::QUERY_PROVIDERS.bits |\n                         Self::QUERY_BLOCKED.bits |\n                         Self::INCR_CACHE_LOADS.bits;\n+\n+        const ARGS = Self::QUERY_KEYS.bits | Self::FUNCTION_ARGS.bits;\n     }\n }\n \n@@ -142,6 +148,8 @@ const EVENT_FILTERS_BY_NAME: &[(&str, EventFilter)] = &[\n     (\"query-blocked\", EventFilter::QUERY_BLOCKED),\n     (\"incr-cache-load\", EventFilter::INCR_CACHE_LOADS),\n     (\"query-keys\", EventFilter::QUERY_KEYS),\n+    (\"function-args\", EventFilter::FUNCTION_ARGS),\n+    (\"args\", EventFilter::ARGS),\n ];\n \n /// Something that uniquely identifies a query invocation.\n@@ -216,43 +224,68 @@ impl SelfProfilerRef {\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime or -Ztime-passes.\n-    #[inline(always)]\n     pub fn verbose_generic_activity<'a>(\n         &'a self,\n-        event_id: &'static str,\n+        event_label: &'static str,\n     ) -> VerboseTimingGuard<'a> {\n-        VerboseTimingGuard::start(\n-            event_id,\n-            self.print_verbose_generic_activities,\n-            self.generic_activity(event_id),\n-        )\n+        let message =\n+            if self.print_verbose_generic_activities { Some(event_label.to_owned()) } else { None };\n+\n+        VerboseTimingGuard::start(message, self.generic_activity(event_label))\n     }\n \n     /// Start profiling a extra verbose generic activity. Profiling continues until the\n     /// VerboseTimingGuard returned from this call is dropped. In addition to recording\n     /// a measureme event, \"extra verbose\" generic activities also print a timing entry to\n     /// stdout if the compiler is invoked with -Ztime-passes.\n-    #[inline(always)]\n-    pub fn extra_verbose_generic_activity<'a>(\n+    pub fn extra_verbose_generic_activity<'a, A>(\n         &'a self,\n-        event_id: &'a str,\n-    ) -> VerboseTimingGuard<'a> {\n-        // FIXME: This does not yet emit a measureme event\n-        // because callers encode arguments into `event_id`.\n-        VerboseTimingGuard::start(\n-            event_id,\n-            self.print_extra_verbose_generic_activities,\n-            TimingGuard::none(),\n-        )\n+        event_label: &'static str,\n+        event_arg: A,\n+    ) -> VerboseTimingGuard<'a>\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n+        let message = if self.print_extra_verbose_generic_activities {\n+            Some(format!(\"{}({})\", event_label, event_arg.borrow()))\n+        } else {\n+            None\n+        };\n+\n+        VerboseTimingGuard::start(message, self.generic_activity_with_arg(event_label, event_arg))\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_activity(&self, event_label: &'static str) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+            let event_id = EventId::from_label(event_label);\n+            TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n+        })\n     }\n \n     /// Start profiling a generic activity. Profiling continues until the\n     /// TimingGuard returned from this call is dropped.\n     #[inline(always)]\n-    pub fn generic_activity(&self, event_id: &'static str) -> TimingGuard<'_> {\n+    pub fn generic_activity_with_arg<A>(\n+        &self,\n+        event_label: &'static str,\n+        event_arg: A,\n+    ) -> TimingGuard<'_>\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n         self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n-            let event_id = profiler.get_or_alloc_cached_string(event_id);\n-            let event_id = EventId::from_label(event_id);\n+            let builder = EventIdBuilder::new(&profiler.profiler);\n+            let event_label = profiler.get_or_alloc_cached_string(event_label);\n+            let event_id = if profiler.event_filter_mask.contains(EventFilter::FUNCTION_ARGS) {\n+                let event_arg = profiler.get_or_alloc_cached_string(event_arg);\n+                builder.from_label_and_arg(event_label, event_arg)\n+            } else {\n+                builder.from_label(event_label)\n+            };\n             TimingGuard::start(profiler, profiler.generic_activity_event_kind, event_id)\n         })\n     }\n@@ -337,7 +370,7 @@ pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n \n-    string_cache: RwLock<FxHashMap<&'static str, StringId>>,\n+    string_cache: RwLock<FxHashMap<String, StringId>>,\n \n     query_event_kind: StringId,\n     generic_activity_event_kind: StringId,\n@@ -419,21 +452,30 @@ impl SelfProfiler {\n     /// Gets a `StringId` for the given string. This method makes sure that\n     /// any strings going through it will only be allocated once in the\n     /// profiling data.\n-    pub fn get_or_alloc_cached_string(&self, s: &'static str) -> StringId {\n+    pub fn get_or_alloc_cached_string<A>(&self, s: A) -> StringId\n+    where\n+        A: Borrow<str> + Into<String>,\n+    {\n         // Only acquire a read-lock first since we assume that the string is\n         // already present in the common case.\n         {\n             let string_cache = self.string_cache.read();\n \n-            if let Some(&id) = string_cache.get(s) {\n+            if let Some(&id) = string_cache.get(s.borrow()) {\n                 return id;\n             }\n         }\n \n         let mut string_cache = self.string_cache.write();\n         // Check if the string has already been added in the small time window\n         // between dropping the read lock and acquiring the write lock.\n-        *string_cache.entry(s).or_insert_with(|| self.profiler.alloc_string(s))\n+        match string_cache.entry(s.into()) {\n+            Entry::Occupied(e) => *e.get(),\n+            Entry::Vacant(e) => {\n+                let string_id = self.profiler.alloc_string(&e.key()[..]);\n+                *e.insert(string_id)\n+            }\n+        }\n     }\n \n     pub fn map_query_invocation_id_to_string(&self, from: QueryInvocationId, to: StringId) {\n@@ -498,18 +540,13 @@ impl<'a> TimingGuard<'a> {\n \n #[must_use]\n pub struct VerboseTimingGuard<'a> {\n-    event_id: &'a str,\n-    start: Option<Instant>,\n+    start_and_message: Option<(Instant, String)>,\n     _guard: TimingGuard<'a>,\n }\n \n impl<'a> VerboseTimingGuard<'a> {\n-    pub fn start(event_id: &'a str, verbose: bool, _guard: TimingGuard<'a>) -> Self {\n-        VerboseTimingGuard {\n-            event_id,\n-            _guard,\n-            start: if unlikely!(verbose) { Some(Instant::now()) } else { None },\n-        }\n+    pub fn start(message: Option<String>, _guard: TimingGuard<'a>) -> Self {\n+        VerboseTimingGuard { _guard, start_and_message: message.map(|msg| (Instant::now(), msg)) }\n     }\n \n     #[inline(always)]\n@@ -521,7 +558,9 @@ impl<'a> VerboseTimingGuard<'a> {\n \n impl Drop for VerboseTimingGuard<'_> {\n     fn drop(&mut self) {\n-        self.start.map(|start| print_time_passes_entry(true, self.event_id, start.elapsed()));\n+        if let Some((start, ref message)) = self.start_and_message {\n+            print_time_passes_entry(true, &message[..], start.elapsed());\n+        }\n     }\n }\n "}, {"sha": "27781eb41d28d4a2a5bef8f804b6fc72082faeff", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -342,10 +342,8 @@ pub fn check_ast_crate<T: EarlyLintPass>(\n         }\n     } else {\n         for pass in &mut passes {\n-            buffered = sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\"running lint: {}\", pass.name()))\n-                .run(|| {\n+            buffered =\n+                sess.prof.extra_verbose_generic_activity(\"run_lint\", pass.name()).run(|| {\n                     early_lint_crate(\n                         sess,\n                         lint_store,"}, {"sha": "b3d5cdf15c933773e04c27fafbbaa32cc6e0539d", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81dccb1a5c7b67c61cb7eb421150c671d6e1a7de/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=81dccb1a5c7b67c61cb7eb421150c671d6e1a7de", "patch": "@@ -441,27 +441,20 @@ fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, b\n         late_lint_pass_crate(tcx, builtin_lints);\n     } else {\n         for pass in &mut passes {\n-            tcx.sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\"running late lint: {}\", pass.name()))\n-                .run(|| {\n-                    late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                });\n+            tcx.sess.prof.extra_verbose_generic_activity(\"run_late_lint\", pass.name()).run(|| {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n         }\n \n         let mut passes: Vec<_> =\n             unerased_lint_store(tcx).late_module_passes.iter().map(|pass| (pass)()).collect();\n \n         for pass in &mut passes {\n-            tcx.sess\n-                .prof\n-                .extra_verbose_generic_activity(&format!(\n-                    \"running late module lint: {}\",\n-                    pass.name()\n-                ))\n-                .run(|| {\n+            tcx.sess.prof.extra_verbose_generic_activity(\"run_late_module_lint\", pass.name()).run(\n+                || {\n                     late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-                });\n+                },\n+            );\n         }\n     }\n }"}]}