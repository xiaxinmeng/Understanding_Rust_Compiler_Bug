{"sha": "5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "node_id": "C_kwDOAAsO6NoAKDUxOTdjOTZjNDlmYzNiN2RlM2NlOWEzMWY3Y2M2MmQyY2JkMWY3MGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T09:50:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-10T09:50:21Z"}, "message": "Auto merge of #101483 - oli-obk:guaranteed_opt, r=fee1-dead\n\nThe `<*const T>::guaranteed_*` methods now return an option for the unknown case\n\ncc https://github.com/rust-lang/rust/issues/53020#issuecomment-1236932443\n\nI chose `0` for \"not equal\" and `1` for \"equal\" and left `2` for the unknown case so backends can just forward to raw pointer equality and it works \u2728\n\nr? `@fee1-dead` or `@lcnr`\n\ncc `@rust-lang/wg-const-eval`", "tree": {"sha": "f0dbcfb3f47bd0bf298f4804f50cd954dc781c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0dbcfb3f47bd0bf298f4804f50cd954dc781c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "html_url": "https://github.com/rust-lang/rust/commit/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db9d86b58dff2a19d84d5e557641dfbb4cbb3a8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/db9d86b58dff2a19d84d5e557641dfbb4cbb3a8d", "html_url": "https://github.com/rust-lang/rust/commit/db9d86b58dff2a19d84d5e557641dfbb4cbb3a8d"}, {"sha": "f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/f632dbe46fb0041c786450f7a3c37a1a5b7208a9", "html_url": "https://github.com/rust-lang/rust/commit/f632dbe46fb0041c786450f7a3c37a1a5b7208a9"}], "stats": {"total": 257, "additions": 119, "deletions": 138}, "files": [{"sha": "2e4ca594f91bb1b63e775902e2ce9ffe2f772232", "filename": "compiler/rustc_codegen_cranelift/src/intrinsics/mod.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fintrinsics%2Fmod.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -816,20 +816,13 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_eq => {\n+        sym::ptr_guaranteed_cmp => {\n             intrinsic_args!(fx, args => (a, b); intrinsic);\n \n             let val = crate::num::codegen_ptr_binop(fx, BinOp::Eq, a, b);\n             ret.write_cvalue(fx, val);\n         }\n \n-        sym::ptr_guaranteed_ne => {\n-            intrinsic_args!(fx, args => (a, b); intrinsic);\n-\n-            let val = crate::num::codegen_ptr_binop(fx, BinOp::Ne, a, b);\n-            ret.write_cvalue(fx, val);\n-        }\n-\n         sym::caller_location => {\n             intrinsic_args!(fx, args => (); intrinsic);\n "}, {"sha": "215edbe02c08e95244984fdf3ca817459f31ab73", "filename": "compiler/rustc_codegen_ssa/src/mir/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fintrinsic.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -551,14 +551,10 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 return;\n             }\n \n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = args[0].immediate();\n                 let b = args[1].immediate();\n-                if name == sym::ptr_guaranteed_eq {\n-                    bx.icmp(IntPredicate::IntEQ, a, b)\n-                } else {\n-                    bx.icmp(IntPredicate::IntNE, a, b)\n-                }\n+                bx.icmp(IntPredicate::IntEQ, a, b)\n             }\n \n             sym::ptr_offset_from | sym::ptr_offset_from_unsigned => {"}, {"sha": "e5acacd9188888f670ec6498d97aee5b7e8558e8", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -191,34 +191,35 @@ impl interpret::MayLeak for ! {\n }\n \n impl<'mir, 'tcx: 'mir> CompileTimeEvalContext<'mir, 'tcx> {\n-    fn guaranteed_eq(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n+    /// See documentation on the `ptr_guaranteed_cmp` intrinsic.\n+    fn guaranteed_cmp(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, u8> {\n         Ok(match (a, b) {\n             // Comparisons between integers are always known.\n-            (Scalar::Int { .. }, Scalar::Int { .. }) => a == b,\n-            // Equality with integers can never be known for sure.\n-            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => false,\n-            // FIXME: return `true` for when both sides are the same pointer, *except* that\n-            // some things (like functions and vtables) do not have stable addresses\n-            // so we need to be careful around them (see e.g. #73722).\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n-        })\n-    }\n-\n-    fn guaranteed_ne(&mut self, a: Scalar, b: Scalar) -> InterpResult<'tcx, bool> {\n-        Ok(match (a, b) {\n-            // Comparisons between integers are always known.\n-            (Scalar::Int(_), Scalar::Int(_)) => a != b,\n+            (Scalar::Int { .. }, Scalar::Int { .. }) => {\n+                if a == b {\n+                    1\n+                } else {\n+                    0\n+                }\n+            }\n             // Comparisons of abstract pointers with null pointers are known if the pointer\n             // is in bounds, because if they are in bounds, the pointer can't be null.\n             // Inequality with integers other than null can never be known for sure.\n             (Scalar::Int(int), ptr @ Scalar::Ptr(..))\n-            | (ptr @ Scalar::Ptr(..), Scalar::Int(int)) => {\n-                int.is_null() && !self.scalar_may_be_null(ptr)?\n+            | (ptr @ Scalar::Ptr(..), Scalar::Int(int))\n+                if int.is_null() && !self.scalar_may_be_null(ptr)? =>\n+            {\n+                0\n             }\n-            // FIXME: return `true` for at least some comparisons where we can reliably\n+            // Equality with integers can never be known for sure.\n+            (Scalar::Int { .. }, Scalar::Ptr(..)) | (Scalar::Ptr(..), Scalar::Int { .. }) => 2,\n+            // FIXME: return a `1` for when both sides are the same pointer, *except* that\n+            // some things (like functions and vtables) do not have stable addresses\n+            // so we need to be careful around them (see e.g. #73722).\n+            // FIXME: return `0` for at least some comparisons where we can reliably\n             // determine the result of runtime inequality tests at compile-time.\n             // Examples include comparison of addresses in different static items.\n-            (Scalar::Ptr(..), Scalar::Ptr(..)) => false,\n+            (Scalar::Ptr(..), Scalar::Ptr(..)) => 2,\n         })\n     }\n }\n@@ -329,15 +330,11 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             throw_unsup_format!(\"intrinsic `{intrinsic_name}` is not supported at compile-time\");\n         };\n         match intrinsic_name {\n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n+            sym::ptr_guaranteed_cmp => {\n                 let a = ecx.read_scalar(&args[0])?;\n                 let b = ecx.read_scalar(&args[1])?;\n-                let cmp = if intrinsic_name == sym::ptr_guaranteed_eq {\n-                    ecx.guaranteed_eq(a, b)?\n-                } else {\n-                    ecx.guaranteed_ne(a, b)?\n-                };\n-                ecx.write_scalar(Scalar::from_bool(cmp), dest)?;\n+                let cmp = ecx.guaranteed_cmp(a, b)?;\n+                ecx.write_scalar(Scalar::from_u8(cmp), dest)?;\n             }\n             sym::const_allocate => {\n                 let size = ecx.read_scalar(&args[0])?.to_machine_usize(ecx)?;"}, {"sha": "a964fe8465eeceefb96a68077e1297f34b577195", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -97,7 +97,7 @@ pub(crate) fn const_to_valtree_inner<'tcx>(\n         }\n \n         // Raw pointers are not allowed in type level constants, as we cannot properly test them for\n-        // equality at compile-time (see `ptr_guaranteed_eq`/`_ne`).\n+        // equality at compile-time (see `ptr_guaranteed_cmp`).\n         // Technically we could allow function pointers (represented as `ty::Instance`), but this is not guaranteed to\n         // agree with runtime equality tests.\n         ty::FnPtr(_) | ty::RawPtr(_) => Err(ValTreeCreationError::NonSupportedType),"}, {"sha": "9c3d99deae06d5b1de3332074f7061f02c327fc7", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -1117,8 +1117,7 @@ symbols! {\n         profiler_builtins,\n         profiler_runtime,\n         ptr,\n-        ptr_guaranteed_eq,\n-        ptr_guaranteed_ne,\n+        ptr_guaranteed_cmp,\n         ptr_mask,\n         ptr_null,\n         ptr_null_mut,"}, {"sha": "4fa33da50c9e0b1e2e3dbc52dcf4646bd55ff4a9", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -95,8 +95,7 @@ pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n         | sym::type_id\n         | sym::likely\n         | sym::unlikely\n-        | sym::ptr_guaranteed_eq\n-        | sym::ptr_guaranteed_ne\n+        | sym::ptr_guaranteed_cmp\n         | sym::minnumf32\n         | sym::minnumf64\n         | sym::maxnumf32\n@@ -302,8 +301,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n-            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n-                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n+            sym::ptr_guaranteed_cmp => {\n+                (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.u8)\n             }\n \n             sym::const_allocate => {"}, {"sha": "11c75e2c912412181236d55e5267154fef642fe9", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -2013,21 +2013,24 @@ extern \"rust-intrinsic\" {\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n+    /// Returns `2` if the result is unknown.\n+    /// Returns `1` if the pointers are guaranteed equal\n+    /// Returns `0` if the pointers are guaranteed inequal\n     ///\n     /// Note that, unlike most intrinsics, this is safe to call;\n     /// it does not require an `unsafe` block.\n     /// Therefore, implementations must not require the user to uphold\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(not(bootstrap))]\n+    pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n+\n+    #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(bootstrap)]\n     pub fn ptr_guaranteed_eq<T>(ptr: *const T, other: *const T) -> bool;\n \n-    /// See documentation of `<*const T>::guaranteed_ne` for details.\n-    ///\n-    /// Note that, unlike most intrinsics, this is safe to call;\n-    /// it does not require an `unsafe` block.\n-    /// Therefore, implementations must not require the user to uphold\n-    /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n+    #[cfg(bootstrap)]\n     pub fn ptr_guaranteed_ne<T>(ptr: *const T, other: *const T) -> bool;\n \n     /// Allocates a block of memory at compile time.\n@@ -2213,6 +2216,16 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n     diff >= size\n }\n \n+#[cfg(bootstrap)]\n+pub const fn ptr_guaranteed_cmp(a: *const (), b: *const ()) -> u8 {\n+    match (ptr_guaranteed_eq(a, b), ptr_guaranteed_ne(a, b)) {\n+        (false, false) => 2,\n+        (true, false) => 1,\n+        (false, true) => 0,\n+        (true, true) => unreachable!(),\n+    }\n+}\n+\n /// Copies `count * size_of::<T>()` bytes from `src` to `dst`. The source\n /// and destination must *not* overlap.\n ///"}, {"sha": "fcdf69a7aaa40026e72ae3de3a8936ee54e86d7e", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -36,7 +36,10 @@ impl<T: ?Sized> *const T {\n     pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *const u8).guaranteed_eq(null())\n+        match (self as *const u8).guaranteed_eq(null()) {\n+            None => false,\n+            Some(res) => res,\n+        }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -770,20 +773,16 @@ impl<T: ?Sized> *const T {\n \n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n-    /// At runtime this function behaves like `self == other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine equality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be equal.\n-    /// But when it returns `true`, the pointers are guaranteed to be equal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n+    /// spuriously return `None` for pointers that later actually turn out to have its equality known.\n+    /// But when it returns `Some`, the pointers' equality is guaranteed to be known.\n     ///\n-    /// [`guaranteed_ne`]: #method.guaranteed_ne\n-    ///\n-    /// The return value may change depending on the compiler version and unsafe code must not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -792,29 +791,28 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_eq(self, other: *const T) -> bool\n+    pub const fn guaranteed_eq(self, other: *const T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_eq(self, other)\n+        match intrinsics::ptr_guaranteed_cmp(self as _, other as _) {\n+            2 => None,\n+            other => Some(other == 1),\n+        }\n     }\n \n-    /// Returns whether two pointers are guaranteed to be unequal.\n+    /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `self != other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n-    /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n+    /// it is not always possible to determine inequality of two pointers, so this function may\n+    /// spuriously return `None` for pointers that later actually turn out to have its inequality known.\n+    /// But when it returns `Some`, the pointers' inequality is guaranteed to be known.\n     ///\n-    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_eq`]: #method.guaranteed_eq\n-    ///\n-    /// The return value may change depending on the compiler version and unsafe code must not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -823,11 +821,14 @@ impl<T: ?Sized> *const T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_ne(self, other: *const T) -> bool\n+    pub const fn guaranteed_ne(self, other: *const T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_ne(self, other)\n+        match self.guaranteed_eq(other) {\n+            None => None,\n+            Some(eq) => Some(!eq),\n+        }\n     }\n \n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`)."}, {"sha": "460f3df5feeabed4151b054c5c87369e94718950", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -35,7 +35,10 @@ impl<T: ?Sized> *mut T {\n     pub const fn is_null(self) -> bool {\n         // Compare via a cast to a thin pointer, so fat pointers are only\n         // considering their \"data\" part for null-ness.\n-        (self as *mut u8).guaranteed_eq(null_mut())\n+        match (self as *mut u8).guaranteed_eq(null_mut()) {\n+            None => false,\n+            Some(res) => res,\n+        }\n     }\n \n     /// Casts to a pointer of another type.\n@@ -697,20 +700,16 @@ impl<T: ?Sized> *mut T {\n \n     /// Returns whether two pointers are guaranteed to be equal.\n     ///\n-    /// At runtime this function behaves like `self == other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n     /// it is not always possible to determine equality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be equal.\n-    /// But when it returns `true`, the pointers are guaranteed to be equal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_ne`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_ne`]: #method.guaranteed_ne\n+    /// spuriously return `None` for pointers that later actually turn out to have its equality known.\n+    /// But when it returns `Some`, the pointers' equality is guaranteed to be known.\n     ///\n-    /// The return value may change depending on the compiler version and unsafe code might not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -719,29 +718,25 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const fn guaranteed_eq(self, other: *mut T) -> bool\n+    pub const fn guaranteed_eq(self, other: *mut T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_eq(self as *const _, other as *const _)\n+        (self as *const T).guaranteed_eq(other as _)\n     }\n \n-    /// Returns whether two pointers are guaranteed to be unequal.\n+    /// Returns whether two pointers are guaranteed to be inequal.\n     ///\n-    /// At runtime this function behaves like `self != other`.\n+    /// At runtime this function behaves like `Some(self == other)`.\n     /// However, in some contexts (e.g., compile-time evaluation),\n-    /// it is not always possible to determine the inequality of two pointers, so this function may\n-    /// spuriously return `false` for pointers that later actually turn out to be unequal.\n-    /// But when it returns `true`, the pointers are guaranteed to be unequal.\n-    ///\n-    /// This function is the mirror of [`guaranteed_eq`], but not its inverse. There are pointer\n-    /// comparisons for which both functions return `false`.\n-    ///\n-    /// [`guaranteed_eq`]: #method.guaranteed_eq\n+    /// it is not always possible to determine inequality of two pointers, so this function may\n+    /// spuriously return `None` for pointers that later actually turn out to have its inequality known.\n+    /// But when it returns `Some`, the pointers' inequality is guaranteed to be known.\n     ///\n-    /// The return value may change depending on the compiler version and unsafe code might not\n+    /// The return value may change from `Some` to `None` and vice versa depending on the compiler\n+    /// version and unsafe code must not\n     /// rely on the result of this function for soundness. It is suggested to only use this function\n-    /// for performance optimizations where spurious `false` return values by this function do not\n+    /// for performance optimizations where spurious `None` return values by this function do not\n     /// affect the outcome, but just the performance.\n     /// The consequences of using this method to make runtime and compile-time code behave\n     /// differently have not been explored. This method should not be used to introduce such\n@@ -750,11 +745,11 @@ impl<T: ?Sized> *mut T {\n     #[unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[inline]\n-    pub const unsafe fn guaranteed_ne(self, other: *mut T) -> bool\n+    pub const fn guaranteed_ne(self, other: *mut T) -> Option<bool>\n     where\n         T: Sized,\n     {\n-        intrinsics::ptr_guaranteed_ne(self as *const _, other as *const _)\n+        (self as *const T).guaranteed_ne(other as _)\n     }\n \n     /// Calculates the distance between two pointers. The returned value is in"}, {"sha": "83e10bf1213ea17ff075ab78e2628f623cf7561f", "filename": "src/test/ui/consts/miri_unleashed/slice_eq.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fslice_eq.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -4,14 +4,10 @@\n #![feature(const_raw_ptr_comparison)]\n \n const EMPTY_SLICE: &[i32] = &[];\n-const EMPTY_EQ: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n-const EMPTY_EQ2: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[] as *const _);\n-const EMPTY_NE: bool = EMPTY_SLICE.as_ptr().guaranteed_ne(&[1] as *const _);\n-const EMPTY_NE2: bool = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n+const EMPTY_EQ: Option<bool> = EMPTY_SLICE.as_ptr().guaranteed_eq(&[] as *const _);\n+const EMPTY_EQ2: Option<bool> = EMPTY_SLICE.as_ptr().guaranteed_eq(&[1] as *const _);\n \n fn main() {\n-    assert!(!EMPTY_EQ);\n-    assert!(!EMPTY_EQ2);\n-    assert!(!EMPTY_NE);\n-    assert!(!EMPTY_NE2);\n+    assert!(EMPTY_EQ.is_none());\n+    assert!(EMPTY_EQ2.is_none());\n }"}, {"sha": "0a3c2d4bedcbd5f8122efbfe5a5eae0c7f7443aa", "filename": "src/test/ui/consts/ptr_comparisons.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.rs?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -14,38 +14,30 @@ const FOO: &usize = &42;\n macro_rules! check {\n     (eq, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 1);\n     };\n     (ne, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 0);\n     };\n-    (!eq, $a:expr, $b:expr) => {\n+    (!, $a:expr, $b:expr) => {\n         pub const _: () =\n-            assert!(!std::intrinsics::ptr_guaranteed_eq($a as *const u8, $b as *const u8));\n-    };\n-    (!ne, $a:expr, $b:expr) => {\n-        pub const _: () =\n-            assert!(!std::intrinsics::ptr_guaranteed_ne($a as *const u8, $b as *const u8));\n+            assert!(std::intrinsics::ptr_guaranteed_cmp($a as *const u8, $b as *const u8) == 2);\n     };\n }\n \n check!(eq, 0, 0);\n check!(ne, 0, 1);\n-check!(!eq, 0, 1);\n-check!(!ne, 0, 0);\n check!(ne, FOO as *const _, 0);\n-check!(!eq, FOO as *const _, 0);\n+check!(ne, unsafe { (FOO as *const usize).offset(1) }, 0);\n+check!(ne, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n+\n // We want pointers to be equal to themselves, but aren't checking this yet because\n // there are some open questions (e.g. whether function pointers to the same function\n // compare equal, they don't necessarily at runtime).\n // The case tested here should work eventually, but does not work yet.\n-check!(!eq, FOO as *const _, FOO as *const _);\n-check!(ne, unsafe { (FOO as *const usize).offset(1) }, 0);\n-check!(!eq, unsafe { (FOO as *const usize).offset(1) }, 0);\n+check!(!, FOO as *const _, FOO as *const _);\n \n-check!(ne, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n-check!(!eq, unsafe { (FOO as *const usize as *const u8).offset(3) }, 0);\n \n ///////////////////////////////////////////////////////////////////////////////\n // If any of the below start compiling, make sure to add a `check` test for it."}, {"sha": "3de2aba5b05e1f1af758fdc770a5bac28d97754a", "filename": "src/test/ui/consts/ptr_comparisons.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fptr_comparisons.stderr?ref=5197c96c49fc3b7de3ce9a31f7cc62d2cbd1f70c", "patch": "@@ -7,19 +7,19 @@ LL |         unsafe { intrinsics::offset(self, count) }\n    |                  out-of-bounds pointer arithmetic: alloc3 has size $WORD, so pointer to $TWO_WORDS bytes starting at offset 0 is out-of-bounds\n    |                  inside `ptr::const_ptr::<impl *const usize>::offset` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n    |\n-  ::: $DIR/ptr_comparisons.rs:58:34\n+  ::: $DIR/ptr_comparisons.rs:50:34\n    |\n LL | const _: *const usize = unsafe { (FOO as *const usize).offset(2) };\n-   |                                  ------------------------------- inside `_` at $DIR/ptr_comparisons.rs:58:34\n+   |                                  ------------------------------- inside `_` at $DIR/ptr_comparisons.rs:50:34\n \n error[E0080]: evaluation of constant value failed\n-  --> $DIR/ptr_comparisons.rs:61:33\n+  --> $DIR/ptr_comparisons.rs:53:33\n    |\n LL |     unsafe { std::ptr::addr_of!((*(FOO as *const usize as *const [u8; 1000]))[999]) };\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ dereferencing pointer failed: alloc3 has size $WORD, so pointer to 1000 bytes starting at offset 0 is out-of-bounds\n \n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:65:27\n+  --> $DIR/ptr_comparisons.rs:57:27\n    |\n LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -31,7 +31,7 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n    = help: the absolute address of a pointer is not known at compile-time, so such operations are not supported\n \n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:70:27\n+  --> $DIR/ptr_comparisons.rs:62:27\n    |\n LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -46,7 +46,7 @@ error: aborting due to 4 previous errors\n For more information about this error, try `rustc --explain E0080`.\n Future incompatibility report: Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:65:27\n+  --> $DIR/ptr_comparisons.rs:57:27\n    |\n LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes\n@@ -59,7 +59,7 @@ LL | const _: usize = unsafe { std::mem::transmute::<*const usize, usize>(FOO) +\n \n Future breakage diagnostic:\n error: any use of this value will cause an error\n-  --> $DIR/ptr_comparisons.rs:70:27\n+  --> $DIR/ptr_comparisons.rs:62:27\n    |\n LL | const _: usize = unsafe { *std::mem::transmute::<&&usize, &usize>(&FOO) + 4 };\n    | --------------            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unable to turn pointer into raw bytes"}]}