{"sha": "018784afc968f6aac9cf62b9339f07f1c06e45cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODc4NGFmYzk2OGY2YWFjOWNmNjJiOTMzOWYwN2YxYzA2ZTQ1Y2I=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-07-05T12:52:18Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-16T14:08:28Z"}, "message": "MIR based borrow check (opt-in).\n\nOne can either use `-Z borrowck-mir` or add the `#[rustc_mir_borrowck]` attribute\nto opt into MIR based borrow checking.\n\nNote that regardless of whether one opts in or not, AST-based borrow\ncheck will still run as well.  The errors emitted from AST-based\nborrow check will include a \"(Ast)\" suffix in their error message,\nwhile the errors emitted from MIR-based borrow check will include a\n\"(Mir)\" suffix.\n\npost-rebase: removed check for intra-statement mutual conflict;\nreplaced with assertion checking that at most one borrow is generated\nper statement.\n\npost-rebase: removed dead code: `IdxSet::pairs` and supporting stuff.", "tree": {"sha": "fa53a30265ea752925d89f7d2b7b92e9f1c0a998", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa53a30265ea752925d89f7d2b7b92e9f1c0a998"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018784afc968f6aac9cf62b9339f07f1c06e45cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018784afc968f6aac9cf62b9339f07f1c06e45cb", "html_url": "https://github.com/rust-lang/rust/commit/018784afc968f6aac9cf62b9339f07f1c06e45cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018784afc968f6aac9cf62b9339f07f1c06e45cb/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "869f05a5215242d90733bb6cb5455959f01effcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/869f05a5215242d90733bb6cb5455959f01effcd", "html_url": "https://github.com/rust-lang/rust/commit/869f05a5215242d90733bb6cb5455959f01effcd"}], "stats": {"total": 1426, "additions": 1422, "deletions": 4}, "files": [{"sha": "5985dcb97c739b170ccceed2c727824dceb10691", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -918,6 +918,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"when debug-printing compiler state, do not include spans\"), // o/w tests have closure@path\n     identify_regions: bool = (false, parse_bool, [UNTRACKED],\n         \"make unnamed regions display as '# (where # is some non-ident unique id)\"),\n+    borrowck_mir: bool = (false, parse_bool, [UNTRACKED],\n+        \"implicitly treat functions as if they have `#[rustc_mir_borrowck]` attribute\"),\n     time_passes: bool = (false, parse_bool, [UNTRACKED],\n         \"measure time of each rustc pass\"),\n     count_llvm_insns: bool = (false, parse_bool,"}, {"sha": "9cb6806e9ade5b831b605b9cdaa607a980d2ca71", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -159,6 +159,36 @@ impl<T: Idx> IdxSet<T> {\n     pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n         each_bit(self, max_bits, f)\n     }\n+\n+    /// Removes all elements from this set.\n+    pub fn reset_to_empty(&mut self) {\n+        for word in self.words_mut() { *word = 0; }\n+    }\n+\n+    pub fn elems(&self, universe_size: usize) -> Elems<T> {\n+        Elems { i: 0, set: self, universe_size: universe_size }\n+    }\n+}\n+\n+pub struct Elems<'a, T: Idx> { i: usize, set: &'a IdxSet<T>, universe_size: usize }\n+\n+impl<'a, T: Idx> Iterator for Elems<'a, T> {\n+    type Item = T;\n+    fn next(&mut self) -> Option<T> {\n+        if self.i >= self.universe_size { return None; }\n+        let mut i = self.i;\n+        loop {\n+            if i >= self.universe_size {\n+                self.i = i; // (mark iteration as complete.)\n+                return None;\n+            }\n+            if self.set.contains(&T::new(i)) {\n+                self.i = i + 1; // (next element to start at.)\n+                return Some(T::new(i));\n+            }\n+            i = i + 1;\n+        }\n+    }\n }\n \n fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {"}, {"sha": "0e4fb075b9c85ffa16743c81576fc1c1c7e2cfbc", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -970,6 +970,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     // We compute \"constant qualifications\" between MIR_CONST and MIR_VALIDATED.\n \n     // What we need to run borrowck etc.\n+    passes.push_pass(MIR_CONST, mir::transform::borrow_check::BorrowckMir);\n     passes.push_pass(MIR_VALIDATED, mir::transform::qualify_consts::QualifyAndPromoteConstants);\n     passes.push_pass(MIR_VALIDATED,\n                      mir::transform::simplify_branches::SimplifyBranches::new(\"initial\"));"}, {"sha": "18a81093a43344a82f8ee0c6f6d662d401c7c3a5", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 112, "deletions": 4, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -15,7 +15,7 @@ use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::bitslice::{bitwise, BitwiseOperator};\n \n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{self, Mir, BasicBlock, Location};\n+use rustc::mir::{self, Mir, BasicBlock, BasicBlockData, Location, Statement, Terminator};\n use rustc::session::Session;\n \n use std::fmt::{self, Debug};\n@@ -47,7 +47,19 @@ pub(crate) struct DataflowBuilder<'a, 'tcx: 'a, BD> where BD: BitDenotation\n }\n \n pub trait Dataflow<BD: BitDenotation> {\n-    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug;\n+    /// Sets up and runs the dataflow problem, using `p` to render results if\n+    /// implementation so chooses.\n+    fn dataflow<P>(&mut self, p: P) where P: Fn(&BD, BD::Idx) -> &Debug {\n+        let _ = p; // default implementation does not instrument process.\n+        self.build_sets();\n+        self.propagate();\n+    }\n+\n+    /// Sets up the entry, gen, and kill sets for this instance of a dataflow problem.\n+    fn build_sets(&mut self);\n+\n+    /// Finds a fixed-point solution to this instance of a dataflow problem.\n+    fn propagate(&mut self);\n }\n \n impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD>\n@@ -59,6 +71,9 @@ impl<'a, 'tcx: 'a, BD> Dataflow<BD> for DataflowBuilder<'a, 'tcx, BD>\n         self.flow_state.propagate();\n         self.post_dataflow_instrumentation(|c,i| p(c,i)).unwrap();\n     }\n+\n+    fn build_sets(&mut self) { self.flow_state.build_sets(); }\n+    fn propagate(&mut self) { self.flow_state.propagate(); }\n }\n \n pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<MetaItem> {\n@@ -254,6 +269,93 @@ impl<E:Idx> Bits<E> {\n     }\n }\n \n+/// DataflowResultsConsumer abstracts over walking the MIR with some\n+/// already constructed dataflow results.\n+///\n+/// It abstracts over the FlowState and also completely hides the\n+/// underlying flow analysis results, because it needs to handle cases\n+/// where we are combining the results of *multiple* flow analyses\n+/// (e.g. borrows + inits + uninits).\n+pub trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n+    type FlowState;\n+\n+    // Observation Hooks: override (at least one of) these to get analysis feedback.\n+    fn visit_block_entry(&mut self,\n+                         _bb: BasicBlock,\n+                         _flow_state: &Self::FlowState) {}\n+\n+    fn visit_statement_entry(&mut self,\n+                             _loc: Location,\n+                             _stmt: &Statement<'tcx>,\n+                             _flow_state: &Self::FlowState) {}\n+\n+    fn visit_terminator_entry(&mut self,\n+                              _loc: Location,\n+                              _term: &Terminator<'tcx>,\n+                              _flow_state: &Self::FlowState) {}\n+\n+    // Main entry point: this drives the processing of results.\n+\n+    fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n+        let flow = flow_uninit;\n+        for bb in self.mir().basic_blocks().indices() {\n+            self.reset_to_entry_of(bb, flow);\n+            self.process_basic_block(bb, flow);\n+        }\n+    }\n+\n+    fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } =\n+            self.mir()[bb];\n+        let mut location = Location { block: bb, statement_index: 0 };\n+        for stmt in statements.iter() {\n+            self.reconstruct_statement_effect(location, flow_state);\n+            self.visit_statement_entry(location, stmt, flow_state);\n+            self.apply_local_effect(location, flow_state);\n+            location.statement_index += 1;\n+        }\n+\n+        if let Some(ref term) = *terminator {\n+            self.reconstruct_terminator_effect(location, flow_state);\n+            self.visit_terminator_entry(location, term, flow_state);\n+\n+            // We don't need to apply the effect of the terminator,\n+            // since we are only visiting dataflow state on control\n+            // flow entry to the various nodes. (But we still need to\n+            // reconstruct the effect, because the visit method might\n+            // inspect it.)\n+        }\n+    }\n+\n+    // Delegated Hooks: Provide access to the MIR and process the flow state.\n+\n+    fn mir(&self) -> &'a Mir<'tcx>;\n+\n+    // reset the state bitvector to represent the entry to block `bb`.\n+    fn reset_to_entry_of(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &mut Self::FlowState);\n+\n+    // build gen + kill sets for statement at `loc`.\n+    fn reconstruct_statement_effect(&mut self,\n+                                    loc: Location,\n+                                    flow_state: &mut Self::FlowState);\n+\n+    // build gen + kill sets for terminator for `loc`.\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     loc: Location,\n+                                     flow_state: &mut Self::FlowState);\n+\n+    // apply current gen + kill sets to `flow_state`.\n+    //\n+    // (`bb` and `stmt_idx` parameters can be ignored if desired by\n+    // client. For the terminator, the `stmt_idx` will be the number\n+    // of statements in the block.)\n+    fn apply_local_effect(&mut self,\n+                          loc: Location,\n+                          flow_state: &mut Self::FlowState);\n+}\n+\n pub struct DataflowAnalysis<'a, 'tcx: 'a, O>\n     where O: BitDenotation\n {\n@@ -269,6 +371,8 @@ impl<'a, 'tcx: 'a, O> DataflowAnalysis<'a, 'tcx, O>\n         DataflowResults(self.flow_state)\n     }\n \n+    pub fn flow_state(&self) -> &DataflowState<O> { &self.flow_state }\n+\n     pub fn mir(&self) -> &'a Mir<'tcx> { self.mir }\n }\n \n@@ -278,10 +382,14 @@ impl<O: BitDenotation> DataflowResults<O> {\n     pub fn sets(&self) -> &AllSets<O::Idx> {\n         &self.0.sets\n     }\n+\n+    pub fn operator(&self) -> &O {\n+        &self.0.operator\n+    }\n }\n \n-// FIXME: This type shouldn't be public, but the graphviz::MirWithFlowState trait\n-// references it in a method signature. Look into using `pub(crate)` to address this.\n+/// State of a dataflow analysis; couples a collection of bit sets\n+/// with operator used to initialize and merge bits during analysis.\n pub struct DataflowState<O: BitDenotation>\n {\n     /// All the sets for the analysis. (Factored into its"}, {"sha": "d2d80649846823c8390061c51ef0dd574f1c0d27", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -108,6 +108,12 @@ impl<'tcx> fmt::Debug for MovePath<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for MovePath<'tcx> {\n+    fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+        write!(w, \"{:?}\", self.lvalue)\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MoveData<'tcx> {\n     pub move_paths: IndexVec<MovePathIndex, MovePath<'tcx>>,"}, {"sha": "2676fdbb9b476e96b8cb46d00fc0be5ad4e737d9", "filename": "src/librustc_mir/transform/borrow_check.rs", "status": "added", "additions": 1270, "deletions": 0, "changes": 1270, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fborrow_check.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -0,0 +1,1270 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass borrow-checks the MIR to (further) ensure it is not broken.\n+\n+use rustc::infer::{InferCtxt};\n+use rustc::ty::{self, TyCtxt, ParamEnv};\n+use rustc::mir::{AssertMessage, BasicBlock, BorrowKind, Location, Lvalue};\n+use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n+use rustc::mir::{Statement, StatementKind, Terminator, TerminatorKind};\n+use rustc::mir::transform::{MirPass, MirSource};\n+\n+use rustc_data_structures::indexed_set::{self, IdxSetBuf};\n+use rustc_data_structures::indexed_vec::{Idx};\n+\n+use syntax::ast::{self};\n+use syntax_pos::{DUMMY_SP, Span};\n+\n+use dataflow::{do_dataflow};\n+use dataflow::{MoveDataParamEnv};\n+use dataflow::{BitDenotation, BlockSets, DataflowResults, DataflowResultsConsumer};\n+use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MovingOutStatements};\n+use dataflow::{Borrows, BorrowData, BorrowIndex};\n+use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+\n+use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::ConsumeKind::{Consume};\n+\n+pub struct BorrowckMir;\n+\n+impl MirPass for BorrowckMir {\n+    fn run_pass<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &mut Mir<'tcx>) {\n+\n+        // let err_count = tcx.sess.err_count();\n+        // if err_count > 0 {\n+        //     // compiling a broken program can obviously result in a\n+        //     // broken MIR, so try not to report duplicate errors.\n+        //     debug!(\"skipping BorrowckMir: {} due to {} previous errors\",\n+        //            tcx.node_path_str(src.item_id()), err_count);\n+        //     return;\n+        // }\n+\n+        debug!(\"run_pass BorrowckMir: {}\", tcx.node_path_str(src.item_id()));\n+\n+        let def_id = tcx.hir.local_def_id(src.item_id());\n+        if tcx.has_attr(def_id, \"rustc_mir_borrowck\") || tcx.sess.opts.debugging_opts.borrowck_mir {\n+            borrowck_mir(tcx, src, mir);\n+        }\n+    }\n+}\n+\n+fn borrowck_mir<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, src: MirSource, mir: &Mir<'tcx>)\n+{\n+    let id = src.item_id();\n+    let def_id = tcx.hir.local_def_id(id);\n+    debug!(\"borrowck_mir({}) UNIMPLEMENTED\", tcx.item_path_str(def_id));\n+\n+    let attributes = tcx.get_attrs(def_id);\n+    let param_env = tcx.param_env(def_id);\n+    tcx.infer_ctxt().enter(|_infcx| {\n+\n+        let move_data = MoveData::gather_moves(mir, tcx, param_env);\n+        let mdpe = MoveDataParamEnv { move_data: move_data, param_env: param_env };\n+        let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n+        let flow_borrows = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       Borrows::new(tcx, mir),\n+                                       |bd, i| bd.location(i));\n+        let flow_inits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                     MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                                     |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_uninits = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                       MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                                       |bd, i| &bd.move_data().move_paths[i]);\n+        let flow_move_outs = do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n+                                         MovingOutStatements::new(tcx, mir, &mdpe),\n+                                         |bd, i| &bd.move_data().moves[i]);\n+\n+        let mut mbcx = MirBorrowckCtxt {\n+            tcx: tcx,\n+            mir: mir,\n+            node_id: id,\n+            move_data: &mdpe.move_data,\n+            param_env: param_env,\n+            fake_infer_ctxt: &_infcx,\n+        };\n+\n+        let mut state = InProgress::new(flow_borrows,\n+                                        flow_inits,\n+                                        flow_uninits,\n+                                        flow_move_outs);\n+\n+        mbcx.analyze_results(&mut state); // entry point for DataflowResultsConsumer\n+    });\n+\n+    debug!(\"borrowck_mir done\");\n+}\n+\n+#[allow(dead_code)]\n+pub struct MirBorrowckCtxt<'c, 'b, 'a: 'b+'c, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'gcx, 'gcx>,\n+    mir: &'b Mir<'gcx>,\n+    node_id: ast::NodeId,\n+    move_data: &'b MoveData<'gcx>,\n+    param_env: ParamEnv<'tcx>,\n+    fake_infer_ctxt: &'c InferCtxt<'c, 'gcx, 'tcx>,\n+}\n+\n+// (forced to be `pub` due to its use as an associated type below.)\n+pub struct InProgress<'b, 'tcx: 'b> {\n+    borrows: FlowInProgress<Borrows<'b, 'tcx>>,\n+    inits: FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>,\n+    uninits: FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>,\n+    move_outs: FlowInProgress<MovingOutStatements<'b, 'tcx>>,\n+}\n+\n+struct FlowInProgress<BD> where BD: BitDenotation {\n+    base_results: DataflowResults<BD>,\n+    curr_state: IdxSetBuf<BD::Idx>,\n+    stmt_gen: IdxSetBuf<BD::Idx>,\n+    stmt_kill: IdxSetBuf<BD::Idx>,\n+}\n+\n+// Check that:\n+// 1. assignments are always made to mutable locations (FIXME: does that still really go here?)\n+// 2. loans made in overlapping scopes do not conflict\n+// 3. assignments do not affect things loaned out as immutable\n+// 4. moves do not affect things loaned out in any way\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n+    for MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n+{\n+    type FlowState = InProgress<'b, 'gcx>;\n+\n+    fn mir(&self) -> &'b Mir<'gcx> { self.mir }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reset_to_entry_of(bb),\n+                             |i| i.reset_to_entry_of(bb),\n+                             |u| u.reset_to_entry_of(bb));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self,\n+                                    location: Location,\n+                                    flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_statement_effect(location),\n+                             |i| i.reconstruct_statement_effect(location),\n+                             |u| u.reconstruct_statement_effect(location));\n+    }\n+\n+    fn apply_local_effect(&mut self,\n+                          _location: Location,\n+                          flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.apply_local_effect(),\n+                             |i| i.apply_local_effect(),\n+                             |u| u.apply_local_effect());\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self,\n+                                     location: Location,\n+                                     flow_state: &mut Self::FlowState) {\n+        flow_state.each_flow(|b| b.reconstruct_terminator_effect(location),\n+                             |i| i.reconstruct_terminator_effect(location),\n+                             |u| u.reconstruct_terminator_effect(location));\n+    }\n+\n+    fn visit_block_entry(&mut self,\n+                         bb: BasicBlock,\n+                         flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_block({:?}): {}\", bb, summary);\n+    }\n+\n+    fn visit_statement_entry(&mut self,\n+                             location: Location,\n+                             stmt: &Statement<'gcx>,\n+                             flow_state: &Self::FlowState) {\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_statement({:?}, {:?}): {}\", location, stmt, summary);\n+        let span = stmt.source_info.span;\n+        match stmt.kind {\n+            StatementKind::Assign(ref lhs, ref rhs) => {\n+                self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n+                                   (lhs, span), JustWrite, flow_state);\n+                self.consume_rvalue(ContextKind::AssignRhs.new(location),\n+                                    (rhs, span), location, flow_state);\n+            }\n+            StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n+                // FIXME: should this count as a mutate from borrowck POV?\n+                self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n+                                   (lvalue, span), JustWrite, flow_state);\n+            }\n+            StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n+                for (o, output) in asm.outputs.iter().zip(outputs) {\n+                    if o.is_indirect {\n+                        self.consume_lvalue(ContextKind::InlineAsm.new(location),\n+                                            Consume,\n+                                            (output, span),\n+                                            flow_state);\n+                    } else {\n+                        self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n+                                           (output, span),\n+                                           if o.is_rw { WriteAndRead } else { JustWrite },\n+                                           flow_state);\n+                    }\n+                }\n+                for input in inputs {\n+                    self.consume_operand(ContextKind::InlineAsm.new(location),\n+                                         Consume,\n+                                         (input, span), flow_state);\n+                }\n+            }\n+            StatementKind::EndRegion(ref _rgn) => {\n+                // ignored when consuming results (update to\n+                // flow_state already handled).\n+            }\n+            StatementKind::Nop |\n+            StatementKind::Validate(..) |\n+            StatementKind::StorageLive(..) |\n+            StatementKind::StorageDead(..) => {\n+                // ignored by borrowck\n+            }\n+        }\n+    }\n+\n+    fn visit_terminator_entry(&mut self,\n+                              location: Location,\n+                              term: &Terminator<'gcx>,\n+                              flow_state: &Self::FlowState) {\n+        let loc = location;\n+        let summary = flow_state.summary();\n+        debug!(\"MirBorrowckCtxt::process_terminator({:?}, {:?}): {}\", location, term, summary);\n+        let span = term.source_info.span;\n+        match term.kind {\n+            TerminatorKind::SwitchInt { ref discr, switch_ty: _, values: _, targets: _ } => {\n+                self.consume_operand(ContextKind::SwitchInt.new(loc),\n+                                     Consume,\n+                                     (discr, span), flow_state);\n+            }\n+            TerminatorKind::Drop { location: ref drop_lvalue, target: _, unwind: _ } => {\n+                self.consume_lvalue(ContextKind::Drop.new(loc),\n+                                    ConsumeKind::Drop,\n+                                    (drop_lvalue, span), flow_state);\n+            }\n+            TerminatorKind::DropAndReplace { location: ref drop_lvalue,\n+                                             value: ref new_value,\n+                                             target: _,\n+                                             unwind: _ } => {\n+                self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n+                                   (drop_lvalue, span), JustWrite, flow_state);\n+                self.consume_operand(ContextKind::DropAndReplace.new(loc),\n+                                     ConsumeKind::Drop,\n+                                     (new_value, span), flow_state);\n+            }\n+            TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n+                self.consume_operand(ContextKind::CallOperator.new(loc),\n+                                     Consume,\n+                                     (func, span), flow_state);\n+                for arg in args {\n+                    self.consume_operand(ContextKind::CallOperand.new(loc),\n+                                         Consume,\n+                                         (arg, span), flow_state);\n+                }\n+                if let Some((ref dest, _/*bb*/)) = *destination {\n+                    self.mutate_lvalue(ContextKind::CallDest.new(loc),\n+                                       (dest, span), JustWrite, flow_state);\n+                }\n+            }\n+            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+                self.consume_operand(ContextKind::Assert.new(loc),\n+                                     Consume,\n+                                     (cond, span), flow_state);\n+                match *msg {\n+                    AssertMessage::BoundsCheck { ref len, ref index } => {\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (len, span), flow_state);\n+                        self.consume_operand(ContextKind::Assert.new(loc),\n+                                             Consume,\n+                                             (index, span), flow_state);\n+                    }\n+                    AssertMessage::Math(_/*const_math_err*/) => {}\n+                }\n+            }\n+\n+            TerminatorKind::Goto { target: _ } |\n+            TerminatorKind::Resume |\n+            TerminatorKind::Return |\n+            TerminatorKind::Unreachable => {\n+                // no data used, thus irrelevant to borrowck\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum MutateMode { JustWrite, WriteAndRead }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ConsumeKind { Drop, Consume }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum Control { Continue, Break }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn mutate_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     mode: MutateMode,\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n+        match mode {\n+            MutateMode::WriteAndRead => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+            MutateMode::JustWrite => {\n+                self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+\n+        // check we don't invalidate any outstanding loans\n+        self.each_borrow_involving_path(context,\n+                                        lvalue_span.0, flow_state, |this, _index, _data| {\n+                                            this.report_illegal_mutation_of_borrowed(context,\n+                                                                                     lvalue_span);\n+                                            Control::Break\n+                                        });\n+\n+        // check for reassignments to immutable local variables\n+        self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n+    }\n+\n+    fn consume_rvalue(&mut self,\n+                      context: Context,\n+                      (rvalue, span): (&Rvalue<'gcx>, Span),\n+                      location: Location,\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        match *rvalue {\n+            Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n+                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+            }\n+\n+            Rvalue::Use(ref operand) |\n+            Rvalue::Repeat(ref operand, _) |\n+            Rvalue::UnaryOp(_/*un_op*/, ref operand) |\n+            Rvalue::Cast(_/*cast_kind*/, ref operand, _/*ty*/) => {\n+                self.consume_operand(context, Consume, (operand, span), flow_state)\n+            }\n+\n+            Rvalue::Len(ref lvalue) |\n+            Rvalue::Discriminant(ref lvalue) => {\n+                // len(_)/discriminant(_) merely read, not consume.\n+                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+            }\n+\n+            Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n+            Rvalue::CheckedBinaryOp(_bin_op, ref operand1, ref operand2) => {\n+                self.consume_operand(context, Consume, (operand1, span), flow_state);\n+                self.consume_operand(context, Consume, (operand2, span), flow_state);\n+            }\n+\n+            Rvalue::NullaryOp(_op, _ty) => {\n+                // nullary ops take no dynamic input; no borrowck effect.\n+                //\n+                // FIXME: is above actually true? Do we want to track\n+                // the fact that uninitialized data can be created via\n+                // `NullOp::Box`?\n+            }\n+\n+            Rvalue::Aggregate(ref _aggregate_kind, ref operands) => {\n+                for operand in operands {\n+                    self.consume_operand(context, Consume, (operand, span), flow_state);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn consume_operand(&mut self,\n+                       context: Context,\n+                       consume_via_drop: ConsumeKind,\n+                       (operand, span): (&Operand<'gcx>, Span),\n+                       flow_state: &InProgress<'b, 'gcx>) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) =>\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Constant(_) => {}\n+        }\n+    }\n+\n+    fn consume_lvalue(&mut self,\n+                      context: Context,\n+                      consume_via_drop: ConsumeKind,\n+                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                      flow_state: &InProgress<'b, 'gcx>) {\n+        let lvalue = lvalue_span.0;\n+        let ty = lvalue.ty(self.mir, self.tcx).to_ty(self.tcx);\n+        let moves_by_default =\n+            self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n+        if moves_by_default {\n+            // move of lvalue: check if this is move of already borrowed path\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Mut) {\n+                        this.report_move_out_while_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        } else {\n+            // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n+            self.each_borrow_involving_path(\n+                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n+                    if !borrow.compatible_with(BorrowKind::Shared) {\n+                        this.report_use_while_mutably_borrowed(context, lvalue_span);\n+                        Control::Break\n+                    } else {\n+                        Control::Continue\n+                    }\n+                });\n+        }\n+\n+        // Finally, check if path was already moved.\n+        match consume_via_drop {\n+            ConsumeKind::Drop => {\n+                // If path is merely being dropped, then we'll already\n+                // check the drop flag to see if it is moved (thus we\n+                // skip this check in that case).\n+            }\n+            ConsumeKind::Consume => {\n+                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+            }\n+        }\n+    }\n+\n+    fn borrow(&mut self,\n+              context: Context,\n+              location: Location,\n+              bk: BorrowKind,\n+              lvalue_span: (&Lvalue<'gcx>, Span),\n+              flow_state: &InProgress<'b, 'gcx>) {\n+        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n+               location, lvalue_span.0, lvalue_span.1);\n+        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn check_if_reassignment_to_immutable_state(&mut self,\n+                                                context: Context,\n+                                                (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                                flow_state: &InProgress<'b, 'gcx>) {\n+        let move_data = flow_state.inits.base_results.operator().move_data();\n+\n+        // determine if this path has a non-mut owner (and thus needs checking).\n+        let mut l = lvalue;\n+        loop {\n+            match *l {\n+                Lvalue::Projection(ref proj) => {\n+                    l = &proj.base;\n+                    continue;\n+                }\n+                Lvalue::Local(local) => {\n+                    match self.mir.local_decls[local].mutability {\n+                        Mutability::Not => break, // needs check\n+                        Mutability::Mut => return,\n+                    }\n+                }\n+                Lvalue::Static(_) => {\n+                    // mutation of non-mut static is always illegal,\n+                    // independent of dataflow.\n+                    self.report_assignment_to_static(context, (lvalue, span));\n+                    return;\n+                }\n+            }\n+        }\n+\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if flow_state.inits.curr_state.contains(&mpi) {\n+                // may already be assigned before reaching this statement;\n+                // report error.\n+                self.report_illegal_reassignment(context, (lvalue, span));\n+            }\n+        }\n+    }\n+\n+    fn check_if_path_is_moved(&mut self,\n+                              context: Context,\n+                              lvalue_span: (&Lvalue<'gcx>, Span),\n+                              flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path ... but is that what we want here?\n+        let lvalue = self.base_path(lvalue_span.0);\n+\n+        let maybe_uninits = &flow_state.uninits;\n+        let move_data = maybe_uninits.base_results.operator().move_data();\n+        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+            if maybe_uninits.curr_state.contains(&mpi) {\n+                // find and report move(s) that could cause this to be uninitialized\n+\n+                // FIXME: for each move in flow_state.move_outs ...\n+                &flow_state.move_outs;\n+\n+                self.report_use_of_moved(context, lvalue_span);\n+            } else {\n+                // sanity check: initialized on *some* path, right?\n+                assert!(flow_state.inits.curr_state.contains(&mpi));\n+            }\n+        }\n+    }\n+\n+    fn move_path_for_lvalue(&mut self,\n+                            _context: Context,\n+                            move_data: &MoveData<'gcx>,\n+                            lvalue: &Lvalue<'gcx>)\n+                            -> Option<MovePathIndex>\n+    {\n+        // If returns None, then there is no move path corresponding\n+        // to a direct owner of `lvalue` (which means there is nothing\n+        // that borrowck tracks for its analysis).\n+\n+        match move_data.rev_lookup.find(lvalue) {\n+            LookupResult::Parent(_) => None,\n+            LookupResult::Exact(mpi) => Some(mpi),\n+        }\n+    }\n+\n+    fn check_if_assigned_path_is_moved(&mut self,\n+                                       context: Context,\n+                                       (lvalue, span): (&Lvalue<'gcx>, Span),\n+                                       flow_state: &InProgress<'b, 'gcx>) {\n+        // recur down lvalue; dispatch to check_if_path_is_moved when necessary\n+        let mut lvalue = lvalue;\n+        loop {\n+            match *lvalue {\n+                Lvalue::Local(_) | Lvalue::Static(_) => {\n+                    // assigning to `x` does not require `x` be initialized.\n+                    break;\n+                }\n+                Lvalue::Projection(ref proj) => {\n+                    let Projection { ref base, ref elem } = **proj;\n+                    match *elem {\n+                        ProjectionElem::Deref |\n+                        // assigning to *P requires `P` initialized.\n+                        ProjectionElem::Index(_/*operand*/) |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        // assigning to P[i] requires `P` initialized.\n+                        ProjectionElem::Downcast(_/*adt_def*/, _/*variant_idx*/) =>\n+                        // assigning to (P->variant) is okay if assigning to `P` is okay\n+                        //\n+                        // FIXME: is this true even if P is a adt with a dtor?\n+                        { }\n+\n+                        ProjectionElem::Subslice { .. } => {\n+                            panic!(\"we dont allow assignments to subslices, context: {:?}\",\n+                                   context);\n+                        }\n+\n+                        ProjectionElem::Field(..) => {\n+                            // if type of `P` has a dtor, then\n+                            // assigning to `P.f` requires `P` itself\n+                            // be already initialized\n+                            let tcx = self.tcx;\n+                            match base.ty(self.mir, tcx).to_ty(tcx).sty {\n+                                ty::TyAdt(def, _) if def.has_dtor(tcx) => {\n+\n+                                    // FIXME: analogous code in\n+                                    // check_loans.rs first maps\n+                                    // `base` to its base_path.\n+\n+                                    self.check_if_path_is_moved(context,\n+                                                                (base, span), flow_state);\n+\n+                                    // (base initialized; no need to\n+                                    // recur further)\n+                                    break;\n+                                }\n+                                _ => {}\n+                            }\n+                        }\n+                    }\n+\n+                    lvalue = base;\n+                    continue;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_for_conflicting_loans(&mut self,\n+                                   context: Context,\n+                                   _location: Location,\n+                                   _bk: BorrowKind,\n+                                   lvalue_span: (&Lvalue<'gcx>, Span),\n+                                   flow_state: &InProgress<'b, 'gcx>) {\n+        // NOTE FIXME: The analogous code in old borrowck\n+        // check_loans.rs is careful to iterate over every *issued*\n+        // loan, as opposed to just the in scope ones.\n+        //\n+        // (Or if you prefer, all the *other* iterations over loans\n+        // only consider loans that are in scope of some given\n+        // CodeExtent)\n+        //\n+        // The (currently skeletal) code here does not encode such a\n+        // distinction, which means it is almost certainly over\n+        // looking something.\n+        //\n+        // (It is probably going to reject code that should be\n+        // accepted, I suspect, by treated issued-but-out-of-scope\n+        // loans as issued-and-in-scope, and thus causing them to\n+        // interfere with other loans.)\n+        //\n+        // However, I just want to get something running, especially\n+        // since I am trying to move into new territory with NLL, so\n+        // lets get this going first, and then address the issued vs\n+        // in-scope distinction later.\n+\n+        let state = &flow_state.borrows;\n+        let data = &state.base_results.operator().borrows();\n+\n+        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n+\n+        // does any loan generated here conflict with a previously issued loan?\n+        let mut loans_generated = 0;\n+        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n+            loans_generated += 1;\n+            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n+                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n+                       (g, gen, self.base_path(&gen.lvalue),\n+                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n+                       (i, issued, self.base_path(&issued.lvalue),\n+                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n+                       self.conflicts_with(gen, issued));\n+                if self.conflicts_with(gen, issued) {\n+                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n+                }\n+            }\n+        }\n+\n+        // MIR statically ensures each statement gens *at most one*\n+        // loan; mutual conflict (within a statement) can't arise.\n+        //\n+        // As safe-guard, assert that above property actually holds.\n+        assert!(loans_generated <= 1);\n+    } }\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn each_borrow_involving_path<F>(&mut self,\n+                                     _context: Context,\n+                                     lvalue: &Lvalue<'gcx>,\n+                                     flow_state: &InProgress<'b, 'gcx>,\n+                                     mut op: F)\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+    {\n+        // FIXME: analogous code in check_loans first maps `lvalue` to\n+        // its base_path.\n+\n+        let domain = flow_state.borrows.base_results.operator();\n+        let data = domain.borrows();\n+\n+        // check for loan restricting path P being used. Accounts for\n+        // borrows of P, P.a.b, etc.\n+        for i in flow_state.borrows.elems_incoming() {\n+            // FIXME: check_loans.rs filtered this to \"in scope\"\n+            // loans; i.e. it took a scope S and checked that each\n+            // restriction's kill_scope was a superscope of S.\n+            let borrowed = &data[i];\n+            for restricted in self.restrictions(&borrowed.lvalue) {\n+                if restricted == lvalue {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+        }\n+\n+        // check for loans (not restrictions) on any base path.\n+        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n+        // since that moves out of borrowed path `a.b`.\n+        //\n+        // Limiting to loans (not restrictions) keeps this one\n+        // working: `{ let x = &mut a.b; let y = a.c; }`\n+        let mut cursor = lvalue;\n+        loop {\n+            // FIXME: check_loans.rs invoked `op` *before* cursor\n+            // shift here.  Might just work (and even avoid redundant\n+            // errors?) given code above?  But for now, I want to try\n+            // doing what I think is more \"natural\" check.\n+            for i in flow_state.borrows.elems_incoming() {\n+                let borrowed = &data[i];\n+                if borrowed.lvalue == *cursor {\n+                    let ctrl = op(self, i, borrowed);\n+                    if ctrl == Control::Break { return; }\n+                }\n+            }\n+\n+            match *cursor {\n+                Lvalue::Local(_) | Lvalue::Static(_) => break,\n+                Lvalue::Projection(ref proj) => cursor = &proj.base,\n+            }\n+        }\n+    }\n+}\n+\n+mod restrictions {\n+    use super::MirBorrowckCtxt;\n+\n+    use rustc::hir;\n+    use rustc::ty::{self, TyCtxt};\n+    use rustc::mir::{Lvalue, Mir, Operand, ProjectionElem};\n+\n+    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+        mir: &'c Mir<'tcx>,\n+        tcx: TyCtxt<'c, 'tcx, 'tcx>,\n+        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+    }\n+\n+    impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        pub(super) fn restrictions<'d>(&self,\n+                                       lvalue: &'d Lvalue<'gcx>)\n+                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        {\n+            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n+            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+        }\n+\n+        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n+            let mut cursor = lvalue;\n+            loop {\n+                let proj = match *cursor {\n+                    Lvalue::Local(_) => return true,\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => proj,\n+                };\n+                match proj.elem {\n+                    ProjectionElem::Index(..) |\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Downcast(..) |\n+                    ProjectionElem::Subslice { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        cursor = &proj.base;\n+                        continue;\n+                    }\n+                    ProjectionElem::Deref => {\n+                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                        match ty.sty {\n+                            ty::TyRawPtr(_) => {\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                                // FIXME: do I need to check validity of\n+                                // region here though? (I think the original\n+                                // check_loans code did, like readme says)\n+                                return false;\n+                            }\n+                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            ty::TyAdt(..) if ty.is_box() => {\n+                                cursor = &proj.base;\n+                                continue;\n+                            }\n+                            _ => {\n+                                panic!(\"unknown type fed to Projection Deref.\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            'pop: loop {\n+                let lvalue = match self.lvalue_stack.pop() {\n+                    None => return None,\n+                    Some(lvalue) => lvalue,\n+                };\n+\n+                // `lvalue` may not be a restriction itself, but may\n+                // hold one further down (e.g. we never return\n+                // downcasts here, but may return a base of a\n+                // downcast).\n+                //\n+                // Also, we need to enqueue any additional\n+                // subrestrictions that it implies, since we can only\n+                // return from from this call alone.\n+\n+                let mut cursor = lvalue;\n+                'cursor: loop {\n+                    let proj = match *cursor {\n+                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n+                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n+                        Lvalue::Projection(ref proj) => proj,\n+                    };\n+\n+                    match proj.elem {\n+                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                            // FIXME: add union handling\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor);\n+                        }\n+                        ProjectionElem::Downcast(..) |\n+                        ProjectionElem::Subslice { .. } |\n+                        ProjectionElem::ConstantIndex { .. } |\n+                        ProjectionElem::Index(Operand::Constant(..)) => {\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Index(Operand::Consume(ref index)) => {\n+                            self.lvalue_stack.push(index); // FIXME: did old borrowck do this?\n+                            cursor = &proj.base;\n+                            continue 'cursor;\n+                        }\n+                        ProjectionElem::Deref => {\n+                            // (handled below)\n+                        }\n+                    }\n+\n+                    assert_eq!(proj.elem, ProjectionElem::Deref);\n+\n+                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                    match ty.sty {\n+                        ty::TyRawPtr(_) => {\n+                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n+                            continue 'pop;\n+                        }\n+                        // R-Deref-Imm-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                            // immutably-borrowed referents do not\n+                            // have recursively-implied restrictions\n+                            // (because preventing actions on `*LV`\n+                            // does nothing about aliases like `*LV1`)\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // (And do I *really* not have to\n+                            // recursively process the `base` as a\n+                            // further search here? Leaving this `if\n+                            // false` here as a hint to look at this\n+                            // again later.\n+                            //\n+                            // Ah, it might be because the\n+                            // restrictions are distinct from the path\n+                            // substructure. Note that there is a\n+                            // separate loop over the path\n+                            // substructure in fn\n+                            // each_borrow_involving_path, for better\n+                            // or for worse.\n+\n+                            if false {\n+                                cursor = &proj.base;\n+                                continue 'cursor;\n+                            } else {\n+                                continue 'pop;\n+                            }\n+                        }\n+\n+                        // R-Deref-Mut-Borrowed\n+                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                            // mutably-borrowed referents are\n+                            // themselves restricted.\n+\n+                            // FIXME: do I need to check validity of\n+                            // `_r` here though? (I think the original\n+                            // check_loans code did, like the readme\n+                            // says)\n+\n+                            // schedule base for future iteration.\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        // R-Deref-Send-Pointer\n+                        ty::TyAdt(..) if ty.is_box() => {\n+                            // borrowing interior of a box implies that\n+                            // its base can no longer be mutated (o/w box\n+                            // storage would be freed)\n+                            self.lvalue_stack.push(&proj.base);\n+                            return Some(cursor); // search yielded interior node\n+                        }\n+\n+                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn report_use_of_moved(&mut self,\n+                           _context: Context,\n+                           (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_act_on_uninitialized_variable(\n+            span, \"use\", &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span_label for use of uninitialized variable\n+        err.emit();\n+    }\n+\n+    fn report_move_out_while_borrowed(&mut self,\n+                                      _context: Context,\n+                                      (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_move_when_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"move out of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_use_while_mutably_borrowed(&mut self,\n+                                         _context: Context,\n+                                         (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_use_when_mutably_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME 1: add span_label for \"borrow of `()` occurs here\"\n+        // FIXME 2: add span_label for \"use of `{}` occurs here\"\n+        err.emit();\n+    }\n+\n+    fn report_conflicting_borrow(&mut self,\n+                                 _context: Context,\n+                                 (lvalue, span): (&Lvalue, Span),\n+                                 loan1: &BorrowData,\n+                                 loan2: &BorrowData) {\n+        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n+        assert_eq!(loan1.lvalue, loan2.lvalue);\n+\n+        // FIXME: supply non-\"\" `opt_via` when appropriate\n+        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n+                             loan2.kind, \"immutable\", \"mutable\") {\n+            (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n+            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+                self.tcx.cannot_reborrow_already_borrowed(\n+                    span, &self.describe_lvalue(lvalue),\n+                    \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n+\n+            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n+                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            // FIXME: add span labels for first and second mutable borrows, as well as\n+            // end point for first.\n+        };\n+        err.emit();\n+    }\n+\n+    fn report_illegal_mutation_of_borrowed(&mut self, _: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_to_borrowed(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_illegal_reassignment(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_reassign_immutable(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+\n+    fn report_assignment_to_static(&mut self, _context: Context, (lvalue, span): (&Lvalue, Span)) {\n+        let mut err = self.tcx.cannot_assign_static(\n+            span, &self.describe_lvalue(lvalue), Origin::Mir);\n+        // FIXME: add span labels for borrow and assignment points\n+        err.emit();\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // End-user visible description of `lvalue`\n+    fn describe_lvalue(&self, lvalue: &Lvalue) -> String {\n+        let mut buf = String::new();\n+        self.append_lvalue_to_string(lvalue, &mut buf);\n+        buf\n+    }\n+\n+    // Appends end-user visible description of `lvalue` to `buf`.\n+    fn append_lvalue_to_string(&self, lvalue: &Lvalue, buf: &mut String) {\n+        match *lvalue {\n+            Lvalue::Local(local) => {\n+                let local = &self.mir.local_decls[local];\n+                match local.name {\n+                    Some(name) => buf.push_str(&format!(\"{}\", name)),\n+                    None => buf.push_str(\"_\"),\n+                }\n+            }\n+            Lvalue::Static(ref static_) => {\n+                buf.push_str(&format!(\"{}\", &self.tcx.item_name(static_.def_id)));\n+            }\n+            Lvalue::Projection(ref proj) => {\n+                let (prefix, suffix, index_operand) = match proj.elem {\n+                    ProjectionElem::Deref =>\n+                        (\"(*\", format!(\")\"), None),\n+                    ProjectionElem::Downcast(..) =>\n+                        (\"\",   format!(\"\"), None), // (dont emit downcast info)\n+                    ProjectionElem::Field(field, _ty) =>\n+                        (\"\",   format!(\".{}\", field.index()), None),\n+                    ProjectionElem::Index(ref index) =>\n+                        (\"\",   format!(\"\"), Some(index)),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n+                        (\"\",   format!(\"[{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n+                        (\"\",   format!(\"[-{} of {}]\", offset, min_length), None),\n+                    ProjectionElem::Subslice { from, to: 0 } =>\n+                        (\"\",   format!(\"[{}:]\", from), None),\n+                    ProjectionElem::Subslice { from: 0, to } =>\n+                        (\"\",   format!(\"[:-{}]\", to), None),\n+                    ProjectionElem::Subslice { from, to } =>\n+                        (\"\",   format!(\"[{}:-{}]\", from, to), None),\n+                };\n+                buf.push_str(prefix);\n+                self.append_lvalue_to_string(&proj.base, buf);\n+                if let Some(index) = index_operand {\n+                    buf.push_str(\"[\");\n+                    self.append_operand_to_string(index, buf);\n+                    buf.push_str(\"]\");\n+                } else {\n+                    buf.push_str(&suffix);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    fn append_operand_to_string(&self, operand: &Operand, buf: &mut String) {\n+        match *operand {\n+            Operand::Consume(ref lvalue) => {\n+                self.append_lvalue_to_string(lvalue, buf);\n+            }\n+            Operand::Constant(ref constant) => {\n+                buf.push_str(&format!(\"{:?}\", constant));\n+            }\n+        }\n+    }\n+}\n+\n+impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    // FIXME: needs to be able to express errors analogous to check_loans.rs\n+    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n+        if loan1.compatible_with(loan2.kind) { return false; }\n+\n+        let loan2_base_path = self.base_path(&loan2.lvalue);\n+        for restricted in self.restrictions(&loan1.lvalue) {\n+            if restricted != loan2_base_path { continue; }\n+            return true;\n+        }\n+\n+        let loan1_base_path = self.base_path(&loan1.lvalue);\n+        for restricted in self.restrictions(&loan2.lvalue) {\n+            if restricted != loan1_base_path { continue; }\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    // FIXME (#16118): function intended to allow the borrow checker\n+    // to be less precise in its handling of Box while still allowing\n+    // moves out of a Box. They should be removed when/if we stop\n+    // treating Box specially (e.g. when/if DerefMove is added...)\n+\n+    fn base_path<'d>(&self, lvalue: &'d Lvalue<'gcx>) -> &'d Lvalue<'gcx> {\n+        //! Returns the base of the leftmost (deepest) dereference of an\n+        //! Box in `lvalue`. If there is no dereference of an Box\n+        //! in `lvalue`, then it just returns `lvalue` itself.\n+\n+        let mut cursor = lvalue;\n+        let mut deepest = lvalue;\n+        loop {\n+            let proj = match *cursor {\n+                Lvalue::Local(..) | Lvalue::Static(..) => return deepest,\n+                Lvalue::Projection(ref proj) => proj,\n+            };\n+            if proj.elem == ProjectionElem::Deref &&\n+                lvalue.ty(self.mir, self.tcx).to_ty(self.tcx).is_box()\n+            {\n+                deepest = &proj.base;\n+            }\n+            cursor = &proj.base;\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+struct Context {\n+    kind: ContextKind,\n+    loc: Location,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ContextKind {\n+    AssignLhs,\n+    AssignRhs,\n+    SetDiscrim,\n+    InlineAsm,\n+    SwitchInt,\n+    Drop,\n+    DropAndReplace,\n+    CallOperator,\n+    CallOperand,\n+    CallDest,\n+    Assert,\n+}\n+\n+impl ContextKind {\n+    fn new(self, loc: Location) -> Context { Context { kind: self, loc: loc } }\n+}\n+\n+impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n+    pub(super) fn new(borrows: DataflowResults<Borrows<'b, 'tcx>>,\n+                      inits: DataflowResults<MaybeInitializedLvals<'b, 'tcx>>,\n+                      uninits: DataflowResults<MaybeUninitializedLvals<'b, 'tcx>>,\n+                      move_outs: DataflowResults<MovingOutStatements<'b, 'tcx>>) -> Self {\n+        InProgress {\n+            borrows: FlowInProgress::new(borrows),\n+            inits: FlowInProgress::new(inits),\n+            uninits: FlowInProgress::new(uninits),\n+            move_outs: FlowInProgress::new(move_outs),\n+        }\n+    }\n+\n+    fn each_flow<XB, XI, XU>(&mut self,\n+                             mut xform_borrows: XB,\n+                             mut xform_inits: XI,\n+                             mut xform_uninits: XU) where\n+        XB: FnMut(&mut FlowInProgress<Borrows<'b, 'tcx>>),\n+        XI: FnMut(&mut FlowInProgress<MaybeInitializedLvals<'b, 'tcx>>),\n+        XU: FnMut(&mut FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>>),\n+    {\n+        xform_borrows(&mut self.borrows);\n+        xform_inits(&mut self.inits);\n+        xform_uninits(&mut self.uninits);\n+    }\n+\n+    fn summary(&self) -> String {\n+        let mut s = String::new();\n+\n+        s.push_str(\"borrows in effect: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_state_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"borrows generated: [\");\n+        let mut saw_one = false;\n+        self.borrows.each_gen_bit(|borrow| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let borrow_data = &self.borrows.base_results.operator().borrows()[borrow];\n+            s.push_str(&format!(\"{}\", borrow_data));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"inits: [\");\n+        let mut saw_one = false;\n+        self.inits.each_state_bit(|mpi_init| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.inits.base_results.operator().move_data().move_paths[mpi_init];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"] \");\n+\n+        s.push_str(\"uninits: [\");\n+        let mut saw_one = false;\n+        self.uninits.each_state_bit(|mpi_uninit| {\n+            if saw_one { s.push_str(\", \"); };\n+            saw_one = true;\n+            let move_path =\n+                &self.uninits.base_results.operator().move_data().move_paths[mpi_uninit];\n+            s.push_str(&format!(\"{}\", move_path));\n+        });\n+        s.push_str(\"]\");\n+\n+        return s;\n+    }\n+}\n+\n+impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n+    fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn each_gen_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n+        self.stmt_gen.each_bit(self.base_results.operator().bits_per_block(), f)\n+    }\n+\n+    fn new(results: DataflowResults<BD>) -> Self {\n+        let bits_per_block = results.sets().bits_per_block();\n+        let curr_state = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_gen = IdxSetBuf::new_empty(bits_per_block);\n+        let stmt_kill = IdxSetBuf::new_empty(bits_per_block);\n+        FlowInProgress {\n+            base_results: results,\n+            curr_state: curr_state,\n+            stmt_gen: stmt_gen,\n+            stmt_kill: stmt_kill,\n+        }\n+    }\n+\n+    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n+        (*self.curr_state).clone_from(self.base_results.sets().on_entry_set_for(bb.index()));\n+    }\n+\n+    fn reconstruct_statement_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().statement_effect(&mut sets, loc);\n+    }\n+\n+    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n+        self.stmt_gen.reset_to_empty();\n+        self.stmt_kill.reset_to_empty();\n+        let mut ignored = IdxSetBuf::new_empty(0);\n+        let mut sets = BlockSets {\n+            on_entry: &mut ignored, gen_set: &mut self.stmt_gen, kill_set: &mut self.stmt_kill,\n+        };\n+        self.base_results.operator().terminator_effect(&mut sets, loc);\n+    }\n+\n+    fn apply_local_effect(&mut self) {\n+        self.curr_state.union(&self.stmt_gen);\n+        self.curr_state.subtract(&self.stmt_kill);\n+    }\n+\n+    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.stmt_gen.elems(univ)\n+    }\n+\n+    fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n+        let univ = self.base_results.sets().bits_per_block();\n+        self.curr_state.elems(univ)\n+    }\n+}\n+\n+impl<'tcx> BorrowData<'tcx> {\n+    fn compatible_with(&self, bk: BorrowKind) -> bool {\n+        match (self.kind, bk) {\n+            (BorrowKind::Shared, BorrowKind::Shared) => true,\n+\n+            (BorrowKind::Mut, _) |\n+            (BorrowKind::Unique, _) |\n+            (_, BorrowKind::Mut) |\n+            (_, BorrowKind::Unique) => false,\n+        }\n+    }\n+}"}, {"sha": "38070a4b4858a7bd2392742f5fd5161665d2dfa8", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018784afc968f6aac9cf62b9339f07f1c06e45cb/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=018784afc968f6aac9cf62b9339f07f1c06e45cb", "patch": "@@ -31,6 +31,7 @@ pub mod simplify;\n pub mod erase_regions;\n pub mod no_landing_pads;\n pub mod type_check;\n+pub mod borrow_check;\n pub mod rustc_peek;\n pub mod elaborate_drops;\n pub mod add_call_guards;"}]}