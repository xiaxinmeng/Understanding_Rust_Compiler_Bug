{"sha": "aca207a65c82d7581076772846ef424f1a64449b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYTIwN2E2NWM4MmQ3NTgxMDc2NzcyODQ2ZWY0MjRmMWE2NDQ0OWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-19T16:44:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-19T16:44:52Z"}, "message": "Auto merge of #25605 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #25452, #25512, #25551, #25556, #25562, #25575, #25576, #25580, #25587, #25590, #25591\n- Failed merges: #25585", "tree": {"sha": "005ebc2ac79e462ce96cb8d40ca33a7ae3b4eeb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/005ebc2ac79e462ce96cb8d40ca33a7ae3b4eeb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aca207a65c82d7581076772846ef424f1a64449b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aca207a65c82d7581076772846ef424f1a64449b", "html_url": "https://github.com/rust-lang/rust/commit/aca207a65c82d7581076772846ef424f1a64449b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aca207a65c82d7581076772846ef424f1a64449b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c47ebb00abecf2b2fe7fa0b0ea059c8327b40f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c47ebb00abecf2b2fe7fa0b0ea059c8327b40f2", "html_url": "https://github.com/rust-lang/rust/commit/9c47ebb00abecf2b2fe7fa0b0ea059c8327b40f2"}, {"sha": "3bb54a3362a5eae45b345b6cfa690dd863f80fdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bb54a3362a5eae45b345b6cfa690dd863f80fdd", "html_url": "https://github.com/rust-lang/rust/commit/3bb54a3362a5eae45b345b6cfa690dd863f80fdd"}], "stats": {"total": 478, "additions": 329, "deletions": 149}, "files": [{"sha": "7dbd3604e491088b6518dd1b3118f52f2d12d73a", "filename": "RELEASES.md", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -23,7 +23,7 @@ Language\n * Digits of binary and octal literals are [lexed more eagerly][lex] to\n   improve error messages and macro behavior. For example, `0b1234` is\n   now lexed as `0b1234` instead of two tokens, `0b1` and `234`.\n-* Trait bounds [are always invariant][inv], eleminating the need for\n+* Trait bounds [are always invariant][inv], eliminating the need for\n   the `PhantomFn` and `MarkerTrait` lang items, which have been\n   removed.\n * [\"-\" is no longer a valid character in crate names][cr], the `extern crate\n@@ -162,7 +162,7 @@ Misc\n \n \n Version 1.0.0-alpha.2 (February 2015)\n--------------------------------------\n+=====================================\n \n * ~1300 changes, numerous bugfixes\n \n@@ -260,8 +260,9 @@ Version 1.0.0-alpha.2 (February 2015)\n [ufcs-rfc]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md\n [un]: https://github.com/rust-lang/rust/pull/22256\n \n+\n Version 1.0.0-alpha (January 2015)\n-----------------------------------\n+==================================\n \n   * ~2400 changes, numerous bugfixes\n \n@@ -446,8 +447,9 @@ Version 1.0.0-alpha (January 2015)\n [trpl]: http://doc.rust-lang.org/book/index.html\n [rbe]: http://rustbyexample.com/\n \n+\n Version 0.12.0 (October 2014)\n------------------------------\n+=============================\n \n   * ~1900 changes, numerous bugfixes\n \n@@ -568,8 +570,9 @@ Version 0.12.0 (October 2014)\n     * Official Rust binaries on Linux are more compatible with older\n       kernels and distributions, built on CentOS 5.10.\n \n+\n Version 0.11.0 (July 2014)\n--------------------------\n+==========================\n \n   * ~1700 changes, numerous bugfixes\n \n@@ -700,8 +703,9 @@ Version 0.11.0 (July 2014)\n     * Error message related to non-exhaustive match expressions have been\n       greatly improved.\n \n+\n Version 0.10 (April 2014)\n--------------------------\n+=========================\n \n   * ~1500 changes, numerous bugfixes\n \n@@ -866,8 +870,9 @@ Version 0.10 (April 2014)\n       * search works across crates that have been rendered to the same output\n         directory.\n \n+\n Version 0.9 (January 2014)\n---------------------------\n+==========================\n \n    * ~1800 changes, numerous bugfixes\n \n@@ -1031,8 +1036,9 @@ Version 0.9 (January 2014)\n       * `rustc` adds a `--dep-info` flag for communicating dependencies to\n         build tools.\n \n+\n Version 0.8 (September 2013)\n---------------------------\n+============================\n \n    * ~2200 changes, numerous bugfixes\n \n@@ -1186,8 +1192,9 @@ Version 0.8 (September 2013)\n       * A new documentation backend, rustdoc_ng, is available for use. It is\n         still invoked through the normal `rustdoc` command.\n \n+\n Version 0.7 (July 2013)\n------------------------\n+=======================\n \n    * ~2000 changes, numerous bugfixes\n \n@@ -1302,8 +1309,9 @@ Version 0.7 (July 2013)\n       * Various improvements to rustdoc.\n       * Improvements to rustpkg (see the detailed release notes).\n \n+\n Version 0.6 (April 2013)\n-------------------------\n+========================\n \n    * ~2100 changes, numerous bugfixes\n \n@@ -1404,8 +1412,9 @@ Version 0.6 (April 2013)\n       * Rust code may be embedded in foreign code under limited circumstances\n       * Inline assembler supported by new asm!() syntax extension.\n \n+\n Version 0.5 (December 2012)\n----------------------------\n+===========================\n \n    * ~900 changes, numerous bugfixes\n \n@@ -1460,8 +1469,9 @@ Version 0.5 (December 2012)\n       * Added a preliminary REPL, `rusti`\n       * License changed from MIT to dual MIT/APL2\n \n+\n Version 0.4 (October 2012)\n---------------------------\n+==========================\n \n    * ~2000 changes, numerous bugfixes\n \n@@ -1515,8 +1525,9 @@ Version 0.4 (October 2012)\n         Rust-based (visitor) code\n       * All hash functions and tables converted to secure, randomized SipHash\n \n+\n Version 0.3  (July 2012)\n-------------------------\n+========================\n \n    * ~1900 changes, numerous bugfixes\n \n@@ -1573,8 +1584,9 @@ Version 0.3  (July 2012)\n    * Tool improvements\n       * Cargo automatically resolves dependencies\n \n+\n Version 0.2  (March 2012)\n--------------------------\n+=========================\n \n    * >1500 changes, numerous bugfixes\n \n@@ -1613,8 +1625,9 @@ Version 0.2  (March 2012)\n       * Merged per-platform std::{os*, fs*} to core::{libc, os}\n       * Extensive cleanup, regularization in libstd, libcore\n \n+\n Version 0.1  (January 20, 2012)\n--------------------------------\n+===============================\n \n    * Most language features work, including:\n       * Unique pointers, unique closures, move semantics"}, {"sha": "797ec94774d7d7c893f36313718959c6bcad4f48", "filename": "src/doc/trpl/benchmark-tests.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbenchmark-tests.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -3,7 +3,7 @@\n Rust supports benchmark tests, which can test the performance of your\n code. Let's make our `src/lib.rs` look like this (comments elided):\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;\n@@ -77,7 +77,7 @@ the benchmark is no longer benchmarking what one expects. For example, the\n compiler might recognize that some calculation has no external effects and\n remove it entirely.\n \n-```{rust,ignore}\n+```rust,ignore\n #![feature(test)]\n \n extern crate test;"}, {"sha": "1cfeb2620bd08d6fc16b5ae1a7779af4f4366822", "filename": "src/doc/trpl/borrow-and-asref.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fborrow-and-asref.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -47,11 +47,11 @@ This is because the standard library has `impl Borrow<str> for String`.\n \n For most types, when you want to take an owned or borrowed type, a `&T` is\n enough. But one area where `Borrow` is effective is when there\u2019s more than one\n-kind of borrowed value. Slices are an area where this is especially true: you\n-can have both an `&[T]` or a `&mut [T]`. If we wanted to accept both of these\n-types, `Borrow` is up for it:\n+kind of borrowed value. This is especially true of references and slices: you\n+can have both an `&T` or a `&mut T`. If we wanted to accept both of these types,\n+`Borrow` is up for it:\n \n-```\n+```rust\n use std::borrow::Borrow;\n use std::fmt::Display;\n "}, {"sha": "1cf84bfd658c04b9facbbbf9f5e63e6d76d4705a", "filename": "src/doc/trpl/box-syntax-and-patterns.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbox-syntax-and-patterns.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -5,7 +5,7 @@ Also it is not possible in stable Rust to destructure a `Box` in a match\n pattern. The unstable `box` keyword can be used to both create and destructure\n a `Box`. An example usage would be:\n \n-```\n+```rust\n #![feature(box_syntax, box_patterns)]\n \n fn main() {\n@@ -34,7 +34,7 @@ because the syntax may still change in the future.\n In many languages with pointers, you'd return a pointer from a function\n so as to avoid copying a large data structure. For example:\n \n-```{rust}\n+```rust\n struct BigStruct {\n     one: i32,\n     two: i32,"}, {"sha": "ccd769089d2519b60218ed8a346f251d72b7f66b", "filename": "src/doc/trpl/concurrency.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fconcurrency.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fconcurrency.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -59,7 +59,7 @@ place!\n Rust's standard library provides a library for threads, which allow you to\n run Rust code in parallel. Here's a basic example of using `std::thread`:\n \n-```\n+```rust\n use std::thread;\n \n fn main() {\n@@ -73,7 +73,7 @@ The `thread::spawn()` method accepts a closure, which is executed in a\n new thread. It returns a handle to the thread, that can be used to\n wait for the child thread to finish and extract its result:\n \n-```\n+```rust\n use std::thread;\n \n fn main() {\n@@ -189,7 +189,7 @@ guard across thread boundaries, which gives us our error.\n \n We can use `Arc<T>` to fix this. Here's the working version:\n \n-```\n+```rust\n use std::sync::{Arc, Mutex};\n use std::thread;\n \n@@ -248,7 +248,7 @@ threads with each other. Let's talk about one of them: channels.\n Here's a version of our code that uses channels for synchronization, rather\n than waiting for a specific time:\n \n-```\n+```rust\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::sync::mpsc;\n@@ -281,7 +281,7 @@ a simple `()` down the channel, and then wait for ten of them to come back.\n While this channel is just sending a generic signal, we can send any data that\n is `Send` over the channel!\n \n-```\n+```rust\n use std::thread;\n use std::sync::mpsc;\n \n@@ -311,7 +311,7 @@ the answer, and then it `send()`s us the answer over the channel.\n A `panic!` will crash the currently executing thread. You can use Rust's\n threads as a simple isolation mechanism:\n \n-```\n+```rust\n use std::thread;\n \n let result = thread::spawn(move || {"}, {"sha": "63fdef0760febf66cc5ef05a79341136b67ac3d1", "filename": "src/doc/trpl/crates-and-modules.md", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fcrates-and-modules.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -75,7 +75,7 @@ above.\n To define each of our modules, we use the `mod` keyword. Let\u2019s make our\n `src/lib.rs` look like this:\n \n-```\n+```rust\n mod english {\n     mod greetings {\n     }\n@@ -126,15 +126,15 @@ ways.\n \n Instead of declaring a module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english {\n     // contents of our module go here\n }\n ```\n \n We can instead declare our module like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n ```\n \n@@ -173,7 +173,7 @@ $ tree .\n \n `src/lib.rs` is our crate root, and looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod english;\n mod japanese;\n ```\n@@ -184,7 +184,7 @@ on our preference. In this case, because our modules have sub-modules, we\u2019ve\n chosen the second. Both `src/english/mod.rs` and `src/japanese/mod.rs` look\n like this:\n \n-```{rust,ignore}\n+```rust,ignore\n mod greetings;\n mod farewells;\n ```\n@@ -297,7 +297,7 @@ public, and so private is the default. To make things public, you use the `pub`\n keyword. Let\u2019s focus on the `english` module first, so let\u2019s reduce our `src/main.rs`\n to just this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n fn main() {\n@@ -308,29 +308,29 @@ fn main() {\n \n In our `src/lib.rs`, let\u2019s add `pub` to the `english` module declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n mod japanese;\n ```\n \n And in our `src/english/mod.rs`, let\u2019s make both `pub`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod greetings;\n pub mod farewells;\n ```\n \n In our `src/english/greetings.rs`, let\u2019s add `pub` to our `fn` declaration:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"Hello!\".to_string()\n }\n ```\n \n And also in `src/english/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"Goodbye.\".to_string()\n }\n@@ -365,7 +365,7 @@ refer to them with shorter names. Let\u2019s talk about `use`.\n Rust has a `use` keyword, which allows us to import names into our local scope.\n Let\u2019s change our `src/main.rs` to look like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings;\n@@ -382,7 +382,7 @@ the functions by a much shorter name. By convention, when importing functions, i\n considered best practice to import the module, rather than the function directly. In\n other words, you _can_ do this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -400,7 +400,7 @@ becomes a problem. If we have conflicting names, Rust will give a compilation\n error. For example, if we made the `japanese` functions public, and tried to do\n this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::greetings::hello;\n@@ -426,14 +426,14 @@ Could not compile `phrases`.\n If we\u2019re importing multiple names from the same module, we don\u2019t have to type it out\n twice. Instead of this:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::greetings;\n use phrases::english::farewells;\n ```\n \n We can use this shortcut:\n \n-```{rust,ignore}\n+```rust,ignore\n use phrases::english::{greetings, farewells};\n ```\n \n@@ -445,7 +445,7 @@ interface that may not directly map to your internal code organization.\n \n Let\u2019s look at an example. Modify your `src/main.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate phrases;\n \n use phrases::english::{greetings,farewells};\n@@ -462,30 +462,30 @@ fn main() {\n \n Then, modify your `src/lib.rs` to make the `japanese` mod public:\n \n-```{rust,ignore}\n+```rust,ignore\n pub mod english;\n pub mod japanese;\n ```\n \n Next, make the two functions public, first in `src/japanese/greetings.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn hello() -> String {\n     \"\u3053\u3093\u306b\u3061\u306f\".to_string()\n }\n ```\n \n And then in `src/japanese/farewells.rs`:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn goodbye() -> String {\n     \"\u3055\u3088\u3046\u306a\u3089\".to_string()\n }\n ```\n \n Finally, modify your `src/japanese/mod.rs` to read like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub use self::greetings::hello;\n pub use self::farewells::goodbye;\n "}, {"sha": "cb02072566eae12257c4ad350d2ae991ebbc2e3a", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -18,7 +18,7 @@ called \u2018the dining philosophers\u2019. It was originally conceived by Dijkstra in\n > in his own chair, picked up his own fork on his left, and plunged it into the\n > spaghetti. But such is the tangled nature of spaghetti that a second fork is\n > required to carry it to the mouth. The philosopher therefore had also to pick\n-> up the fork on his right. When we was finished he would put down both his\n+> up the fork on his right. When he was finished he would put down both his\n > forks, get up from his chair, and continue thinking. Of course, a fork can be\n > used by only one philosopher at a time. If the other philosopher wants it, he\n > just has to wait until the fork is available again."}, {"sha": "4accba90e6cdbd6cc5491af8a0919c57fc13de34", "filename": "src/doc/trpl/documentation.md", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdocumentation.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -42,7 +42,7 @@ Documentation comments are written in Markdown.\n Rust keeps track of these comments, and uses them when generating\n documentation. This is important when documenting things like enums:\n \n-```\n+```rust\n /// The `Option` type. See [the module level documentation](../) for more.\n enum Option<T> {\n     /// No value\n@@ -80,15 +80,15 @@ thing after that last comment.\n \n Anyway, let's cover each part of this comment in detail:\n \n-```\n+```rust\n /// Constructs a new `Rc<T>`.\n # fn foo() {}\n ```\n \n The first line of a documentation comment should be a short summary of its\n functionality. One sentence. Just the basics. High level.\n \n-```\n+```rust\n ///\n /// Other details about constructing `Rc<T>`s, maybe describing complicated\n /// semantics, maybe additional options, all kinds of stuff.\n@@ -101,7 +101,7 @@ we could have added more explanation in a new paragraph.\n \n #### Special sections\n \n-```\n+```rust\n /// # Examples\n # fn foo() {}\n ```\n@@ -110,7 +110,7 @@ Next, are special sections. These are indicated with a header, `#`. There\n are three kinds of headers that are commonly used. They aren't special syntax,\n just convention, for now.\n \n-```\n+```rust\n /// # Panics\n # fn foo() {}\n ```\n@@ -120,7 +120,7 @@ usually indicated by panics, which kill the whole current thread at the very\n least. If your function has a non-trivial contract like this, that is\n detected/enforced by panics, documenting it is very important.\n \n-```\n+```rust\n /// # Failures\n # fn foo() {}\n ```\n@@ -130,15 +130,15 @@ conditions under which it returns `Err(E)` is a nice thing to do. This is\n slightly less important than `Panics`, because failure is encoded into the type\n system, but it's still a good thing to do.\n \n-```\n+```rust\n /// # Safety\n # fn foo() {}\n ```\n \n If your function is `unsafe`, you should explain which invariants the caller is\n responsible for upholding.\n \n-```\n+```rust\n /// # Examples\n ///\n /// ```\n@@ -154,7 +154,7 @@ method, and your users will love you for it. These examples go inside of\n code block annotations, which we'll talk about in a moment, and can have\n more than one section:\n \n-```\n+```rust\n /// # Examples\n ///\n /// Simple `&str` patterns:\n@@ -179,7 +179,7 @@ Let's discuss the details of these code blocks.\n \n To write some Rust code in a comment, use the triple graves:\n \n-```\n+```rust\n /// ```\n /// println!(\"Hello, world\");\n /// ```\n@@ -188,7 +188,7 @@ To write some Rust code in a comment, use the triple graves:\n \n If you want something that's not Rust code, you can add an annotation:\n \n-```\n+```rust\n /// ```c\n /// printf(\"Hello, world\\n\");\n /// ```\n@@ -208,7 +208,7 @@ generate the documentation.\n \n Let's discuss our sample example documentation:\n \n-```\n+```rust\n /// ```\n /// println!(\"Hello, world\");\n /// ```\n@@ -219,7 +219,7 @@ You'll notice that you don't need a `fn main()` or anything here. `rustdoc` will\n automatically add a main() wrapper around your code, and in the right place.\n For example:\n \n-```\n+```rust\n /// ```\n /// use std::rc::Rc;\n ///\n@@ -230,7 +230,7 @@ For example:\n \n This will end up testing:\n \n-```\n+```rust\n fn main() {\n     use std::rc::Rc;\n     let five = Rc::new(5);\n@@ -259,7 +259,7 @@ with `///` we've been talking about? The raw text:\n \n looks different than the output:\n \n-```\n+```rust\n /// Some documentation.\n # fn foo() {}\n ```\n@@ -274,7 +274,7 @@ it makes the example more clear. You can use this technique to explain\n longer examples in detail, while still preserving the testability of your\n documentation. For example, this code:\n \n-```\n+```rust\n let x = 5;\n let y = 6;\n println!(\"{}\", x + y);\n@@ -284,23 +284,23 @@ Here's an explanation, rendered:\n \n First, we set `x` to five:\n \n-```\n+```rust\n let x = 5;\n # let y = 6;\n # println!(\"{}\", x + y);\n ```\n \n Next, we set `y` to six:\n \n-```\n+```rust\n # let x = 5;\n let y = 6;\n # println!(\"{}\", x + y);\n ```\n \n Finally, we print the sum of `x` and `y`:\n \n-```\n+```rust\n # let x = 5;\n # let y = 6;\n println!(\"{}\", x + y);\n@@ -340,7 +340,7 @@ explanation.\n \n Here\u2019s an example of documenting a macro:\n \n-```\n+```rust\n /// Panic with a given message unless an expression evaluates to true.\n ///\n /// # Examples\n@@ -388,7 +388,7 @@ but with a binary, there\u2019s nothing to link to.\n There are a few more annotations that are useful to help `rustdoc` do the right\n thing when testing your code:\n \n-```\n+```rust\n /// ```ignore\n /// fn foo() {\n /// ```\n@@ -400,7 +400,7 @@ what you want, as it's the most generic. Instead, consider annotating it\n with `text` if it's not code, or using `#`s to get a working example that\n only shows the part you care about.\n \n-```\n+```rust\n /// ```should_panic\n /// assert!(false);\n /// ```\n@@ -410,7 +410,7 @@ only shows the part you care about.\n `should_panic` tells `rustdoc` that the code should compile correctly, but\n not actually pass as a test.\n \n-```\n+```rust\n /// ```no_run\n /// loop {\n ///     println!(\"Hello, world\");\n@@ -427,7 +427,7 @@ which you would want to make sure compile, but might run in an infinite loop!\n \n Rust has another kind of doc comment, `//!`. This comment doesn't document the next item, but the enclosing item. In other words:\n \n-```\n+```rust\n mod foo {\n     //! This is documentation for the `foo` module.\n     //!\n@@ -440,7 +440,7 @@ mod foo {\n This is where you'll see `//!` used most often: for module documentation. If\n you have a module in `foo.rs`, you'll often open its code and see this:\n \n-```\n+```rust\n //! A module for using `foo`s.\n //!\n //! The `foo` module contains a lot of useful functionality blah blah blah\n@@ -461,7 +461,7 @@ are written in Markdown, they're often `.md` files.\n When you write documentation in Markdown files, you don't need to prefix\n the documentation with comments. For example:\n \n-```\n+```rust\n /// # Examples\n ///\n /// ```\n@@ -499,7 +499,7 @@ This `%` line needs to be the very first line of the file.\n \n At a deeper level, documentation comments are sugar for documentation attributes:\n \n-```\n+```rust\n /// this\n # fn foo() {}\n \n@@ -509,7 +509,7 @@ At a deeper level, documentation comments are sugar for documentation attributes\n \n are the same, as are these:\n \n-```\n+```rust\n //! this\n \n #![doc=\"/// this\"]\n@@ -546,7 +546,7 @@ pub use foo::bar;\n You can control a few aspects of the HTML that `rustdoc` generates through the\n `#![doc]` version of the attribute:\n \n-```\n+```rust\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/\")];"}, {"sha": "7b47559e0fce05f51b6dfd4d79bab2357d74843a", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -49,7 +49,7 @@ We use `assert!` to declare that something is true. If it's not true, something\n is very wrong. Wrong enough that we can't continue with things in the current\n state. Another example is using the `unreachable!()` macro:\n \n-```{rust,ignore}\n+```rust,ignore\n enum Event {\n     NewRelease,\n }\n@@ -188,7 +188,7 @@ The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum\n In the case of an error that is unexpected and not recoverable, the `panic!`\n macro will induce a panic. This will crash the current thread, and give an error:\n \n-```{rust,ignore}\n+```rust,ignore\n panic!(\"boom\");\n ```\n \n@@ -212,7 +212,7 @@ handle and possibly recover from error.\n If we don't want to handle this error, and would rather just abort the program,\n we can use the `unwrap()` method:\n \n-```{rust,ignore}\n+```rust,ignore\n io::stdin().read_line(&mut buffer).unwrap();\n ```\n \n@@ -223,7 +223,7 @@ shorter. Sometimes, just crashing is appropriate.\n \n There's another way of doing this that's a bit nicer than `unwrap()`:\n \n-```{rust,ignore}\n+```rust,ignore\n let mut buffer = String::new();\n let input = io::stdin().read_line(&mut buffer)\n                        .ok()"}, {"sha": "9ede835e521c9a7e26212cec3c96392f537269be", "filename": "src/doc/trpl/ffi.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fffi.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -81,7 +81,7 @@ vectors as pointers to memory. Rust's vectors are guaranteed to be a contiguous\n length is number of elements currently contained, and the capacity is the total size in elements of\n the allocated memory. The length is less than or equal to the capacity.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{c_int, size_t};\n@@ -106,7 +106,7 @@ required capacity to hold the compressed output. The vector can then be passed t\n `snappy_compress` function as an output parameter. An output parameter is also passed to retrieve\n the true length after compression for setting the length.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n@@ -133,7 +133,7 @@ pub fn compress(src: &[u8]) -> Vec<u8> {\n Decompression is similar, because snappy stores the uncompressed size as part of the compression\n format and `snappy_uncompressed_length` will retrieve the exact buffer size required.\n \n-```\n+```rust\n # #![feature(libc)]\n # extern crate libc;\n # use libc::{size_t, c_int};\n@@ -375,7 +375,7 @@ the compiler that the unsafety does not leak out of the block.\n Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like\n this:\n \n-```\n+```rust\n unsafe fn kaboom(ptr: *const i32) -> i32 { *ptr }\n ```\n \n@@ -439,7 +439,7 @@ Most foreign code exposes a C ABI, and Rust uses the platform's C calling conven\n calling foreign functions. Some foreign functions, most notably the Windows API, use other calling\n conventions. Rust provides a way to tell the compiler which convention to use:\n \n-```\n+```rust\n # #![feature(libc)]\n extern crate libc;\n \n@@ -516,7 +516,7 @@ function pointer using the C ABI.\n You may wish to compile Rust code in a way so that it can be called from C. This is\n fairly easy, but requires a few things:\n \n-```\n+```rust\n #[no_mangle]\n pub extern fn hello_rust() -> *const u8 {\n     \"Hello, world!\\0\".as_ptr()"}, {"sha": "21a29f005998717c2b2084ce0c5e0b57d1d11561", "filename": "src/doc/trpl/functions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ffunctions.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ffunctions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ffunctions.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -146,7 +146,7 @@ expression, although its value is not particularly useful. Unlike other\n languages where an assignment evaluates to the assigned value (e.g. `5` in the\n previous example), in Rust the value of an assignment is an empty tuple `()`:\n \n-```\n+```rust\n let mut y = 5;\n \n let x = (y = 6);  // x has the value `()`, not `6`\n@@ -204,7 +204,7 @@ time.\n Rust has some special syntax for \u2018diverging functions\u2019, which are functions that\n do not return:\n \n-```\n+```rust\n fn diverges() -> ! {\n     panic!(\"This function never returns!\");\n }"}, {"sha": "f8f1962e0cf5565bb6342f1bf538b39b7229186b", "filename": "src/doc/trpl/generics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fgenerics.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fgenerics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fgenerics.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -110,7 +110,7 @@ Generic functions are most useful with \u2018trait bounds\u2019, which we\u2019ll cover i\n \n You can store a generic type in a `struct` as well:\n \n-```\n+```rust\n struct Point<T> {\n     x: T,\n     y: T,"}, {"sha": "4220b4d04afa25c8b0d6f09b60f9d16e27955b3b", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -151,7 +151,7 @@ take a name on the left hand side, it actually accepts a\n \u2018[pattern][patterns]\u2019. We\u2019ll use patterns more later. It\u2019s easy enough\n to use for now:\n \n-```\n+```rust\n let foo = 5; // immutable.\n let mut bar = 5; // mutable\n ```"}, {"sha": "4d9166d63bfb7e81b36c316effcde41382c63c6b", "filename": "src/doc/trpl/inline-assembly.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Finline-assembly.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Finline-assembly.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -25,7 +25,7 @@ crate to allow) and of course requires an `unsafe` block.\n The `assembly template` is the only required parameter and must be a\n literal string (i.e. `\"\"`)\n \n-```\n+```rust\n #![feature(asm)]\n \n #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n@@ -51,7 +51,7 @@ fn main() {\n Output operands, input operands, clobbers and options are all optional\n but you must add the right number of `:` if you skip them:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -65,7 +65,7 @@ asm!(\"xor %eax, %eax\"\n \n Whitespace also doesn't matter:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -79,7 +79,7 @@ Input and output operands follow the same format: `:\n \"constraints1\"(expr1), \"constraints2\"(expr2), ...\"`. Output operand\n expressions must be mutable lvalues, or not yet assigned:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n fn add(a: i32, b: i32) -> i32 {\n@@ -106,7 +106,7 @@ you want, and you are required to put the specific size of the\n operand. This is useful for very low level programming, where \n which register you use is important:\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # unsafe fn read_byte_in(port: u16) -> u8 {\n@@ -123,7 +123,7 @@ different values so we use the clobbers list to indicate to the\n compiler not to assume any values loaded into those registers will\n stay valid.\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() { unsafe {\n@@ -155,7 +155,7 @@ Current valid options are:\n    the compiler to insert its usual stack alignment code\n 3. *intel* - use intel syntax instead of the default AT&T.\n \n-```\n+```rust\n # #![feature(asm)]\n # #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n # fn main() {"}, {"sha": "e0a8bb59e346a042119896a727cc0d0d986246ff", "filename": "src/doc/trpl/intrinsics.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fintrinsics.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fintrinsics.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -10,7 +10,7 @@ context, but wished to be able to `transmute` between types, and\n perform efficient pointer arithmetic, one would import those functions\n via a declaration like\n \n-```\n+```rust\n # #![feature(intrinsics)]\n # fn main() {}\n "}, {"sha": "80c0def285ab534163150f1e09b30ac2c9795588", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -116,7 +116,7 @@ A *consumer* operates on an iterator, returning some kind of value or values.\n The most common consumer is `collect()`. This code doesn't quite compile,\n but it shows the intention:\n \n-```{rust,ignore}\n+```rust,ignore\n let one_to_one_hundred = (1..101).collect();\n ```\n \n@@ -253,7 +253,7 @@ we need to talk about with regards to iterators. Let's get to it!\n *Iterator adapters* take an iterator and modify it somehow, producing\n a new iterator. The simplest one is called `map`:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| x + 1);\n ```\n \n@@ -272,7 +272,7 @@ warning: unused result which must be used: iterator adaptors are lazy and\n Laziness strikes again! That closure will never execute. This example\n doesn't print any numbers:\n \n-```{rust,ignore}\n+```rust,ignore\n (1..100).map(|x| println!(\"{}\", x));\n ```\n "}, {"sha": "8e7504c2f18ea5eb76bba3b5f02857ae98a5e17c", "filename": "src/doc/trpl/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Flang-items.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -15,7 +15,7 @@ For example, `Box` pointers require two lang items, one for allocation\n and one for deallocation. A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n-```\n+```rust\n #![feature(lang_items, box_syntax, start, no_std, libc)]\n #![no_std]\n "}, {"sha": "ce06987013d3ccd22913a30b736a5e4d95b3e250", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -698,6 +698,7 @@ assert_eq!(5, 3 + 2);\n assert!(5 < 3);\n assert_eq!(5, 3);\n ```\n+\n ## try!\n \n `try!` is used for error handling. It takes something that can return a"}, {"sha": "e5f490e15e13e64a8b0dd102bd1197a244ebdd2b", "filename": "src/doc/trpl/method-syntax.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmethod-syntax.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -89,7 +89,7 @@ So, now we know how to call a method, such as `foo.bar()`. But what about our\n original example, `foo.bar().baz()`? This is called \u2018method chaining\u2019, and we\n can do it by returning `self`.\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,\n@@ -117,7 +117,7 @@ fn main() {\n \n Check the return type:\n \n-```\n+```rust\n # struct Circle;\n # impl Circle {\n fn grow(&self) -> Circle {\n@@ -167,7 +167,7 @@ and `y` attributes will be `0.0`, and the `radius` will be `1.0`. Rust doesn\u2019t\n have method overloading, named arguments, or variable arguments. We employ\n the builder pattern instead. It looks like this:\n \n-```\n+```rust\n struct Circle {\n     x: f64,\n     y: f64,"}, {"sha": "fe41def4d7cc3265150ed97aa987285b52fa24be", "filename": "src/doc/trpl/mutability.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmutability.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fmutability.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmutability.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -161,7 +161,7 @@ b.x = 10; // error: cannot assign to immutable field `b.x`\n \n However, by using `Cell<T>`, you can emulate field-level mutability:\n \n-```\n+```rust\n use std::cell::Cell;\n \n struct Point {"}, {"sha": "0a985334b5e4b694d797eb673986bc4fdebbbbe2", "filename": "src/doc/trpl/no-stdlib.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fno-stdlib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fno-stdlib.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -20,7 +20,7 @@ default shim for the C `main` function with your own.\n The function marked `#[start]` is passed the command line parameters\n in the same format as C:\n \n-```\n+```rust\n #![feature(lang_items, start, no_std, libc)]\n #![no_std]\n "}, {"sha": "027909dd058769c70031e0d32a8424a803c5e58b", "filename": "src/doc/trpl/primitive-types.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fprimitive-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fprimitive-types.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -251,7 +251,7 @@ This pattern is very powerful, and we\u2019ll see it repeated more later.\n You can disambiguate a single-element tuple from a value in parentheses with a\n comma:\n \n-```\n+```rust\n (0,); // single-element tuple\n (0); // zero in parentheses\n ```\n@@ -283,7 +283,7 @@ documentation][tuple].\n \n Functions also have a type! They look like this:\n \n-```\n+```rust\n fn foo(x: i32) -> i32 { x }\n \n let x: fn(i32) -> i32 = foo;"}, {"sha": "abe17a96b39a622edc648310cd74a57e4bc3a04b", "filename": "src/doc/trpl/strings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fstrings.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fstrings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fstrings.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -38,7 +38,7 @@ println!(\"{}\", s);\n \n `String`s will coerce into `&str` with an `&`:\n \n-```\n+```rust\n fn takes_slice(slice: &str) {\n     println!(\"Got: {}\", slice);\n }"}, {"sha": "759543140b5769fd65925aa3785d1cc98ad49846", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -195,7 +195,7 @@ parameter can be added to the `should_panic` attribute. The test harness will\n make sure that the failure message contains the provided text. A safer version\n of the example above would be:\n \n-```\n+```rust\n #[test]\n #[should_panic(expected = \"assertion failed\")]\n fn it_works() {\n@@ -205,7 +205,7 @@ fn it_works() {\n \n That's all there is to the basics! Let's write one 'real' test:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -225,7 +225,7 @@ There is one way in which our existing example is not idiomatic: it's\n missing the `tests` module. The idiomatic way of writing our example\n looks like this:\n \n-```{rust,ignore}\n+```rust,ignore\n pub fn add_two(a: i32) -> i32 {\n     a + 2\n }\n@@ -253,7 +253,7 @@ we need to bring our test function into scope. This can be annoying if you have\n a large module, and so this is a common use of the `glob` feature. Let's change\n our `src/lib.rs` to make use of it:\n \n-```{rust,ignore}\n+```rust,ignore\n \n pub fn add_two(a: i32) -> i32 {\n     a + 2\n@@ -302,7 +302,7 @@ the `tests` directory\n To write an integration test, let's make a `tests` directory, and\n put a `tests/lib.rs` file inside, with this as its contents:\n \n-```{rust,ignore}\n+```rust,ignore\n extern crate adder;\n \n #[test]\n@@ -359,7 +359,7 @@ documentation has been written. To this end, Rust supports automatically\n running examples in your documentation. Here's a fleshed-out `src/lib.rs`\n with examples:\n \n-```{rust,ignore}\n+```rust,ignore\n //! The `adder` crate provides functions that add numbers to other numbers.\n //!\n //! # Examples"}, {"sha": "efa16f2942f06d9637c79af40a7c5017d31f3777", "filename": "src/doc/trpl/traits.md", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ftraits.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Ftraits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftraits.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -183,17 +183,17 @@ won\u2019t have its methods:\n \n ```rust,ignore\n let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n-let result = f.write(\"whatever\".as_bytes());\n+let buf = b\"whatever\"; // byte string literal. buf: &[u8; 8]\n+let result = f.write(buf);\n # result.unwrap(); // ignore the error\n ```\n \n Here\u2019s the error:\n \n ```text\n error: type `std::fs::File` does not implement any method in scope named `write`\n-\n-let result = f.write(b\"whatever\");\n-               ^~~~~~~~~~~~~~~~~~\n+let result = f.write(buf);\n+               ^~~~~~~~~~\n ```\n \n We need to `use` the `Write` trait first:\n@@ -202,7 +202,8 @@ We need to `use` the `Write` trait first:\n use std::io::Write;\n \n let mut f = std::fs::File::open(\"foo.txt\").ok().expect(\"Couldn\u2019t open foo.txt\");\n-let result = f.write(\"whatever\".as_bytes());\n+let buf = b\"whatever\";\n+let result = f.write(buf);\n # result.unwrap(); // ignore the error\n ```\n \n@@ -252,7 +253,7 @@ Writing functions with only a few generic types and a small number of trait\n bounds isn\u2019t too bad, but as the number increases, the syntax gets increasingly\n awkward:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n@@ -267,7 +268,7 @@ far right. The bounds are getting in the way.\n \n Rust has a solution, and it\u2019s called a \u2018`where` clause\u2019:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn foo<T: Clone, K: Clone + Debug>(x: T, y: K) {\n@@ -293,7 +294,7 @@ All you need to do is leave off the bounds when defining your type parameters,\n and then add `where` after the parameter list. For longer lists, whitespace can\n be added:\n \n-```\n+```rust\n use std::fmt::Debug;\n \n fn bar<T, K>(x: T, y: K)\n@@ -310,7 +311,7 @@ This flexibility can add clarity in complex situations.\n \n `where` is also more powerful than the simpler syntax. For example:\n \n-```\n+```rust\n trait ConvertTo<Output> {\n     fn convert(&self) -> Output;\n }"}, {"sha": "d8b894a2f6522ba45b78b6debf369e3b4edbd587", "filename": "src/doc/trpl/vectors.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fvectors.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fvectors.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fvectors.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -16,7 +16,7 @@ this is just convention.)\n \n There\u2019s an alternate form of `vec!` for repeating an initial value:\n \n-```\n+```rust\n let v = vec![0; 10]; // ten zeroes\n ```\n "}, {"sha": "0f5c3c64a4b17e1665b9b0a7d0941360e684785e", "filename": "src/doc/trpl/while-loops.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Fdoc%2Ftrpl%2Fwhile-loops.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fwhile-loops.md?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -2,7 +2,7 @@\n \n Rust also has a `while` loop. It looks like this:\n \n-```{rust}\n+```rust\n let mut x = 5; // mut x: i32\n let mut done = false; // mut done: bool\n "}, {"sha": "ed7cdbbb6e2e0e5d72f17c9d5a23d6d644cf0130", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -3114,7 +3114,7 @@ pub mod order {\n     }\n \n     /// Returns `a` < `b` lexicographically (Using partial order, `PartialOrd`)\n-    pub fn lt<R: Iterator, L: Iterator>(mut a: L, mut b: R) -> bool where\n+    pub fn lt<L: Iterator, R: Iterator>(mut a: L, mut b: R) -> bool where\n         L::Item: PartialOrd<R::Item>,\n     {\n         loop {"}, {"sha": "67e637198b405bfc8f0c0888c8b3225b2017cce0", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 158, "deletions": 6, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -12,6 +12,164 @@\n \n register_long_diagnostics! {\n \n+E0023: r##\"\n+A pattern used to match against an enum variant must provide a sub-pattern for\n+each field of the enum variant. This error indicates that a pattern attempted to\n+extract an incorrect number of fields from a variant.\n+\n+```\n+enum Fruit {\n+    Apple(String, String)\n+    Pear(u32)\n+}\n+```\n+\n+Here the `Apple` variant has two fields, and should be matched against like so:\n+\n+```\n+// Correct.\n+match x {\n+    Apple(a, b) => ...\n+}\n+```\n+\n+Matching with the wrong number of fields has no sensible interpretation:\n+\n+```\n+// Incorrect.\n+match x {\n+    Apple(a) => ...,\n+    Apple(a, b, c) => ...\n+}\n+```\n+\n+Check how many fields the enum was declared with and ensure that your pattern\n+uses the same number.\n+\"##,\n+\n+E0024: r##\"\n+This error indicates that a pattern attempted to extract the fields of an enum\n+variant with no fields. Here's a tiny example of this error:\n+\n+```\n+// This enum has two variants.\n+enum Number {\n+    // This variant has no fields.\n+    Zero,\n+    // This variant has one field.\n+    One(u32)\n+}\n+\n+// Assuming x is a Number we can pattern match on its contents.\n+match x {\n+    Zero(inside) => ...,\n+    One(inside) => ...\n+}\n+```\n+\n+The pattern match `Zero(inside)` is incorrect because the `Zero` variant\n+contains no fields, yet the `inside` name attempts to bind the first field of\n+the enum.\n+\"##,\n+\n+E0025: r##\"\n+Each field of a struct can only be bound once in a pattern. Each occurrence of a\n+field name binds the value of that field, so to fix this error you will have to\n+remove or alter the duplicate uses of the field name. Perhaps you misspelt\n+another field name?\n+\"##,\n+\n+E0026: r##\"\n+This error indicates that a struct pattern attempted to extract a non-existant\n+field from a struct. Struct fields are identified by the name used before the\n+colon `:` so struct patterns should resemble the declaration of the struct type\n+being matched.\n+\n+```\n+// Correct matching.\n+struct Thing {\n+    x: u32,\n+    y: u32\n+}\n+\n+let thing = Thing { x: 1, y: 2 };\n+match thing {\n+    Thing { x: xfield, y: yfield } => ...\n+}\n+```\n+\n+If you are using shorthand field patterns but want to refer to the struct field\n+by a different name, you should rename it explicitly.\n+\n+```\n+// Change this:\n+match thing {\n+    Thing { x, z } => ...\n+}\n+\n+// To this:\n+match thing {\n+    Thing { x, y: z } => ...\n+}\n+```\n+\"##,\n+\n+E0027: r##\"\n+This error indicates that a pattern for a struct fails to specify a sub-pattern\n+for every one of the struct's fields. Ensure that each field from the struct's\n+definition is mentioned in the pattern, or use `..` to ignore unwanted fields.\n+\n+For example:\n+\n+```\n+struct Dog {\n+    name: String,\n+    age: u32\n+}\n+\n+let d = Dog { name: \"Rusty\".to_string(), age: 8 };\n+\n+// This is incorrect.\n+match d {\n+    Dog { age: x } => ...\n+}\n+\n+// This is correct (explicit).\n+match d {\n+    Dog { name: n, age: x } => ...\n+}\n+\n+// This is also correct (ignore unused fields).\n+match d {\n+    Dog { age: x, .. } => ...\n+}\n+```\n+\"##,\n+\n+E0033: r##\"\n+This error indicates that a pointer to a trait type cannot be implicitly\n+dereferenced by a pattern. Every trait defines a type, but because the\n+size of trait implementors isn't fixed, this type has no compile-time size.\n+Therefore, all accesses to trait types must be through pointers. If you\n+encounter this error you should try to avoid dereferencing the pointer.\n+\n+```\n+let trait_obj: &SomeTrait = ...;\n+\n+// This tries to implicitly dereference to create an unsized local variable.\n+let &invalid = trait_obj;\n+\n+// You can call methods without binding to the value being pointed at.\n+trait_obj.method_one();\n+trait_obj.method_two();\n+```\n+\n+You can read more about trait objects in the Trait Object section of the\n+Reference:\n+\n+http://doc.rust-lang.org/reference.html#trait-objects\n+\"##,\n+\n E0046: r##\"\n When trying to make some type implement a trait `Foo`, you must, at minimum,\n provide implementations for all of `Foo`'s required methods (meaning the\n@@ -758,15 +916,9 @@ safety.md\n }\n \n register_diagnostics! {\n-    E0023,\n-    E0024,\n-    E0025,\n-    E0026,\n-    E0027,\n     E0029,\n     E0030,\n     E0031,\n-    E0033,\n     E0034, // multiple applicable methods in scope\n     E0035, // does not take type parameters\n     E0036, // incorrect number of type parameters given for this method"}, {"sha": "957ed27db4c021d386039db079a2f2d67da7e9c1", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -348,7 +348,7 @@ nav.sub {\n .content .impl-items .docblock, .content .impl-items .stability {\n     margin-left: 40px;\n }\n-.content .impl-items .method, .content .impl-items .type {\n+.content .impl-items .method, .content .impl-items > .type {\n     margin-left: 20px;\n }\n "}, {"sha": "cb59f020e29dec7204f3da0d1bfdda858ec67a92", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -1177,8 +1177,9 @@ impl Iterator for WalkDir {\n \n /// Utility methods for paths.\n #[unstable(feature = \"path_ext\",\n-           reason = \"the precise set of methods exposed on this trait may \\\n-                     change and some methods may be removed\")]\n+           reason = \"The precise set of methods exposed on this trait may \\\n+                     change and some methods may be removed.  For stable code, \\\n+                     see the std::fs::metadata function.\")]\n pub trait PathExt {\n     /// Gets information on the file, directory, etc at this path.\n     ///"}, {"sha": "31c973214a1c944aac7d567dd312eb2fe693e45c", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -37,27 +37,34 @@ pub fn parse_cmd(name: &str) -> Option<Box<Subcommand>> {\n     }\n }\n \n-fn write_toc(book: &Book, path_to_root: &Path, out: &mut Write) -> io::Result<()> {\n+fn write_toc(book: &Book, current_page: &BookItem, out: &mut Write) -> io::Result<()> {\n     fn walk_items(items: &[BookItem],\n                   section: &str,\n-                  path_to_root: &Path,\n+                  current_page: &BookItem,\n                   out: &mut Write) -> io::Result<()> {\n         for (i, item) in items.iter().enumerate() {\n-            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], path_to_root, out));\n+            try!(walk_item(item, &format!(\"{}{}.\", section, i + 1)[..], current_page, out));\n         }\n         Ok(())\n     }\n     fn walk_item(item: &BookItem,\n                  section: &str,\n-                 path_to_root: &Path,\n+                 current_page: &BookItem,\n                  out: &mut Write) -> io::Result<()> {\n-        try!(writeln!(out, \"<li><a href='{}'><b>{}</b> {}</a>\",\n-                 path_to_root.join(&item.path.with_extension(\"html\")).display(),\n+        let class_string = if item.path == current_page.path {\n+          \"class='active'\"\n+        } else {\n+        \"\"\n+        };\n+\n+        try!(writeln!(out, \"<li><a {} href='{}'><b>{}</b> {}</a>\",\n+                 class_string,\n+                 item.path_to_root.join(&item.path.with_extension(\"html\")).display(),\n                  section,\n                  item.title));\n         if !item.children.is_empty() {\n             try!(writeln!(out, \"<ul class='section'>\"));\n-            let _ = walk_items(&item.children[..], section, path_to_root, out);\n+            let _ = walk_items(&item.children[..], section, current_page, out);\n             try!(writeln!(out, \"</ul>\"));\n         }\n         try!(writeln!(out, \"</li>\"));\n@@ -67,7 +74,7 @@ fn write_toc(book: &Book, path_to_root: &Path, out: &mut Write) -> io::Result<()\n \n     try!(writeln!(out, \"<div id='toc' class='mobile-hidden'>\"));\n     try!(writeln!(out, \"<ul class='chapter'>\"));\n-    try!(walk_items(&book.chapters[..], \"\", path_to_root, out));\n+    try!(walk_items(&book.chapters[..], \"\", &current_page, out));\n     try!(writeln!(out, \"</ul>\"));\n     try!(writeln!(out, \"</div>\"));\n \n@@ -115,7 +122,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n                   <span class=\"bar\"></span>\n                 </button>\n               </div>\"#));\n-            let _ = write_toc(book, &item.path_to_root, &mut toc);\n+            let _ = write_toc(book, &item, &mut toc);\n             try!(writeln!(&mut toc, \"<div id='page-wrapper'>\"));\n             try!(writeln!(&mut toc, \"<div id='page'>\"));\n         }"}, {"sha": "aae5f21a73dc653f0e7b7e37bde2095ae0a2f666", "filename": "src/rustbook/css.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aca207a65c82d7581076772846ef424f1a64449b/src%2Frustbook%2Fcss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aca207a65c82d7581076772846ef424f1a64449b/src%2Frustbook%2Fcss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fcss.rs?ref=aca207a65c82d7581076772846ef424f1a64449b", "patch": "@@ -97,6 +97,11 @@ body {\n     color: #000000;\n }\n \n+.chapter li a.active {\n+    text-decoration: underline;\n+    font-weight: bold;\n+}\n+\n #toggle-nav {\n     height: 20px;\n     width:  30px;"}]}