{"sha": "14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "node_id": "C_kwDOAAsO6NoAKDE0ZmYzZDdlNWZmNWM0MjYxY2U0YjFiMzVlZjYzZDEyOTRiYTkzYzI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-20T12:49:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-20T12:49:48Z"}, "message": "Merge #11065\n\n11065: internal: Don't kick off inference in `Semantics::descend_into_macros_impl` r=Veykril a=Veykril\n\nWe do not need inference info here so there is no point in calculating it\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "f8d281e4bc3edead1fc15643484f5ae41499af64", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8d281e4bc3edead1fc15643484f5ae41499af64"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhwHvsCRBK7hj4Ov3rIwAA2O0IAI3OpSvMJdDyqeRtbTTPPgon\nvbHWYcVSP7LJCR+cLwxg3fXnHAKlOLUHRoNPAsRAlrZn6CEh2WNGnNfkTUR0OWUe\nfPnwSnR9Y0htHtueKN1/i1PBKD//t63b2GI1wZzD1/mQALSxcLMKQ1KB3IFL0NY8\nuk1nkVwAssK9sdcnlXaXPv+ixGoghp0nDZpP37bSUm+NzegrLBpxLBOA3TFP90ZG\nGhb3h7/jn1SZVBEGAJBJ6JV21m8HBXv9jw82ZLIuG113OzlKu83oIP6plcf1StjM\njryiENczbFV6eO43rmz7Q2i1ykXNg350pQIuzijA6afMZixgto7sYSOyYvQOHG8=\n=Vhj8\n-----END PGP SIGNATURE-----\n", "payload": "tree f8d281e4bc3edead1fc15643484f5ae41499af64\nparent 48d6cef43691d6c65f495f66c5a4d3ef3a618f7b\nparent a574434c3f0d963392113d4f6aa80872d9c49d16\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1640004588 +0000\ncommitter GitHub <noreply@github.com> 1640004588 +0000\n\nMerge #11065\n\n11065: internal: Don't kick off inference in `Semantics::descend_into_macros_impl` r=Veykril a=Veykril\n\nWe do not need inference info here so there is no point in calculating it\r\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "html_url": "https://github.com/rust-lang/rust/commit/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b", "html_url": "https://github.com/rust-lang/rust/commit/48d6cef43691d6c65f495f66c5a4d3ef3a618f7b"}, {"sha": "a574434c3f0d963392113d4f6aa80872d9c49d16", "url": "https://api.github.com/repos/rust-lang/rust/commits/a574434c3f0d963392113d4f6aa80872d9c49d16", "html_url": "https://github.com/rust-lang/rust/commit/a574434c3f0d963392113d4f6aa80872d9c49d16"}], "stats": {"total": 275, "additions": 148, "deletions": 127}, "files": [{"sha": "a299aa449888ff0c981f2719e07bad760496032f", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "patch": "@@ -528,7 +528,7 @@ impl<'db> SemanticsImpl<'db> {\n         if first == last {\n             self.descend_into_macros_impl(\n                 first,\n-                |InFile { value, .. }| {\n+                &mut |InFile { value, .. }| {\n                     if let Some(node) = value.ancestors().find_map(N::cast) {\n                         res.push(node)\n                     }\n@@ -540,7 +540,7 @@ impl<'db> SemanticsImpl<'db> {\n             let mut scratch: SmallVec<[_; 1]> = smallvec![];\n             self.descend_into_macros_impl(\n                 first,\n-                |token| {\n+                &mut |token| {\n                     scratch.push(token);\n                 },\n                 false,\n@@ -549,7 +549,7 @@ impl<'db> SemanticsImpl<'db> {\n             let mut scratch = scratch.into_iter();\n             self.descend_into_macros_impl(\n                 last,\n-                |InFile { value: last, file_id: last_fid }| {\n+                &mut |InFile { value: last, file_id: last_fid }| {\n                     if let Some(InFile { value: first, file_id: first_fid }) = scratch.next() {\n                         if first_fid == last_fid {\n                             if let Some(p) = first.parent() {\n@@ -574,28 +574,28 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn descend_into_macros(&self, token: SyntaxToken) -> SmallVec<[SyntaxToken; 1]> {\n         let mut res = smallvec![];\n-        self.descend_into_macros_impl(token, |InFile { value, .. }| res.push(value), false);\n+        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| res.push(value), false);\n         res\n     }\n \n     fn descend_into_macros_single(&self, token: SyntaxToken) -> SyntaxToken {\n         let mut res = token.clone();\n-        self.descend_into_macros_impl(token, |InFile { value, .. }| res = value, true);\n+        self.descend_into_macros_impl(token, &mut |InFile { value, .. }| res = value, true);\n         res\n     }\n \n     fn descend_into_macros_impl(\n         &self,\n         token: SyntaxToken,\n-        mut f: impl FnMut(InFile<SyntaxToken>),\n+        f: &mut dyn FnMut(InFile<SyntaxToken>),\n         single: bool,\n     ) {\n         let _p = profile::span(\"descend_into_macros\");\n         let parent = match token.parent() {\n             Some(it) => it,\n             None => return,\n         };\n-        let sa = self.analyze(&parent);\n+        let sa = self.analyze_no_infer(&parent);\n         let mut stack: SmallVec<[_; 4]> = smallvec![InFile::new(sa.file_id, token)];\n         let mut cache = self.expansion_info_cache.borrow_mut();\n         let mut mcache = self.macro_call_cache.borrow_mut();\n@@ -927,14 +927,23 @@ impl<'db> SemanticsImpl<'db> {\n     }\n \n     fn analyze(&self, node: &SyntaxNode) -> SourceAnalyzer {\n-        self.analyze_impl(node, None)\n+        self.analyze_impl(node, None, true)\n     }\n \n     fn analyze_with_offset(&self, node: &SyntaxNode, offset: TextSize) -> SourceAnalyzer {\n-        self.analyze_impl(node, Some(offset))\n+        self.analyze_impl(node, Some(offset), true)\n     }\n \n-    fn analyze_impl(&self, node: &SyntaxNode, offset: Option<TextSize>) -> SourceAnalyzer {\n+    fn analyze_no_infer(&self, node: &SyntaxNode) -> SourceAnalyzer {\n+        self.analyze_impl(node, None, false)\n+    }\n+\n+    fn analyze_impl(\n+        &self,\n+        node: &SyntaxNode,\n+        offset: Option<TextSize>,\n+        infer_body: bool,\n+    ) -> SourceAnalyzer {\n         let _p = profile::span(\"Semantics::analyze_impl\");\n         let node = self.find_file(node.clone());\n         let node = node.as_ref();\n@@ -946,7 +955,11 @@ impl<'db> SemanticsImpl<'db> {\n \n         let resolver = match container {\n             ChildContainer::DefWithBodyId(def) => {\n-                return SourceAnalyzer::new_for_body(self.db, def, node, offset)\n+                return if infer_body {\n+                    SourceAnalyzer::new_for_body(self.db, def, node, offset)\n+                } else {\n+                    SourceAnalyzer::new_for_body_no_infer(self.db, def, node, offset)\n+                }\n             }\n             ChildContainer::TraitId(it) => it.resolver(self.db.upcast()),\n             ChildContainer::ImplId(it) => it.resolver(self.db.upcast()),\n@@ -1117,6 +1130,7 @@ to_def_impls![\n     (crate::TypeParam, ast::TypeParam, type_param_to_def),\n     (crate::LifetimeParam, ast::LifetimeParam, lifetime_param_to_def),\n     (crate::ConstParam, ast::ConstParam, const_param_to_def),\n+    (crate::GenericParam, ast::GenericParam, generic_param_to_def),\n     (crate::MacroDef, ast::Macro, macro_to_def),\n     (crate::Local, ast::IdentPat, bind_pat_to_def),\n     (crate::Local, ast::SelfParam, self_param_to_def),"}, {"sha": "9b8e5635923bccecb1c424c97e0482534214a6d0", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "patch": "@@ -92,8 +92,8 @@ use hir_def::{\n     expr::{LabelId, PatId},\n     keys::{self, Key},\n     AdtId, ConstId, ConstParamId, DefWithBodyId, EnumId, EnumVariantId, FieldId, FunctionId,\n-    GenericDefId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId, TypeAliasId,\n-    TypeParamId, UnionId, VariantId,\n+    GenericDefId, GenericParamId, ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId,\n+    TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::AsName, AstId, HirFileId, MacroCallId, MacroDefId, MacroDefKind};\n use rustc_hash::FxHashMap;\n@@ -299,6 +299,23 @@ impl SourceToDefCtx<'_, '_> {\n         dyn_map[keys::CONST_PARAM].get(&src).copied()\n     }\n \n+    pub(super) fn generic_param_to_def(\n+        &mut self,\n+        InFile { file_id, value }: InFile<ast::GenericParam>,\n+    ) -> Option<GenericParamId> {\n+        match value {\n+            ast::GenericParam::ConstParam(it) => {\n+                self.const_param_to_def(InFile::new(file_id, it)).map(GenericParamId::ConstParamId)\n+            }\n+            ast::GenericParam::LifetimeParam(it) => self\n+                .lifetime_param_to_def(InFile::new(file_id, it))\n+                .map(GenericParamId::LifetimeParamId),\n+            ast::GenericParam::TypeParam(it) => {\n+                self.type_param_to_def(InFile::new(file_id, it)).map(GenericParamId::TypeParamId)\n+            }\n+        }\n+    }\n+\n     pub(super) fn macro_to_def(&mut self, src: InFile<ast::Macro>) -> Option<MacroDefId> {\n         let makro = self.dyn_map(src.as_ref()).and_then(|it| it[keys::MACRO].get(&src).copied());\n         if let res @ Some(_) = makro {"}, {"sha": "2d779393f0950601f7e420698cc63c3c222d45bb", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "patch": "@@ -50,7 +50,7 @@ impl SourceAnalyzer {\n     pub(crate) fn new_for_body(\n         db: &dyn HirDatabase,\n         def: DefWithBodyId,\n-        node: InFile<&SyntaxNode>,\n+        node @ InFile { file_id, .. }: InFile<&SyntaxNode>,\n         offset: Option<TextSize>,\n     ) -> SourceAnalyzer {\n         let (body, source_map) = db.body_with_source_map(def);\n@@ -65,7 +65,29 @@ impl SourceAnalyzer {\n             body: Some(body),\n             body_source_map: Some(source_map),\n             infer: Some(db.infer(def)),\n-            file_id: node.file_id,\n+            file_id,\n+        }\n+    }\n+\n+    pub(crate) fn new_for_body_no_infer(\n+        db: &dyn HirDatabase,\n+        def: DefWithBodyId,\n+        node @ InFile { file_id, .. }: InFile<&SyntaxNode>,\n+        offset: Option<TextSize>,\n+    ) -> SourceAnalyzer {\n+        let (body, source_map) = db.body_with_source_map(def);\n+        let scopes = db.expr_scopes(def);\n+        let scope = match offset {\n+            None => scope_for(&scopes, &source_map, node),\n+            Some(offset) => scope_for_offset(db, &scopes, &source_map, node.with_value(offset)),\n+        };\n+        let resolver = resolver_for_scope(db.upcast(), def, scope);\n+        SourceAnalyzer {\n+            resolver,\n+            body: Some(body),\n+            body_source_map: Some(source_map),\n+            infer: None,\n+            file_id,\n         }\n     }\n "}, {"sha": "b5a13cea91728d162862284b22893b83edf88031", "filename": "crates/ide_db/src/defs.rs", "status": "modified", "additions": 80, "deletions": 112, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fide_db%2Fsrc%2Fdefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2/crates%2Fide_db%2Fsrc%2Fdefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fdefs.rs?ref=14ff3d7e5ff5c4261ce4b1b35ef63d1294ba93c2", "patch": "@@ -224,125 +224,93 @@ impl NameClass {\n \n         let parent = name.syntax().parent()?;\n \n-        if let Some(bind_pat) = ast::IdentPat::cast(parent.clone()) {\n-            if let Some(def) = sema.resolve_bind_pat_to_const(&bind_pat) {\n+        let def = if let Some(item) = ast::Item::cast(parent.clone()) {\n+            match item {\n+                ast::Item::MacroRules(it) => {\n+                    Definition::Macro(sema.to_def(&ast::Macro::MacroRules(it))?)\n+                }\n+                ast::Item::MacroDef(it) => {\n+                    Definition::Macro(sema.to_def(&ast::Macro::MacroDef(it))?)\n+                }\n+                ast::Item::Const(it) => Definition::Const(sema.to_def(&it)?),\n+                ast::Item::Fn(it) => Definition::Function(sema.to_def(&it)?),\n+                ast::Item::Module(it) => Definition::Module(sema.to_def(&it)?),\n+                ast::Item::Static(it) => Definition::Static(sema.to_def(&it)?),\n+                ast::Item::Trait(it) => Definition::Trait(sema.to_def(&it)?),\n+                ast::Item::TypeAlias(it) => Definition::TypeAlias(sema.to_def(&it)?),\n+                ast::Item::Enum(it) => Definition::Adt(hir::Adt::Enum(sema.to_def(&it)?)),\n+                ast::Item::Struct(it) => Definition::Adt(hir::Adt::Struct(sema.to_def(&it)?)),\n+                ast::Item::Union(it) => Definition::Adt(hir::Adt::Union(sema.to_def(&it)?)),\n+                _ => return None,\n+            }\n+        } else if let Some(it) = ast::IdentPat::cast(parent.clone()) {\n+            if let Some(def) = sema.resolve_bind_pat_to_const(&it) {\n                 return Some(NameClass::ConstReference(Definition::from(def)));\n             }\n-        }\n \n-        match_ast! {\n-            match parent {\n-                ast::Rename(it) => {\n-                    if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n-                        let path = use_tree.path()?;\n-                        let path_segment = path.segment()?;\n-                        let name_ref = path_segment.name_ref()?;\n-                        let name_ref = if name_ref.self_token().is_some() {\n-                             use_tree\n-                                .syntax()\n-                                .parent()\n-                                .as_ref()\n-                                // Skip over UseTreeList\n-                                .and_then(|it| {\n-                                    let use_tree = it.parent().and_then(ast::UseTree::cast)?;\n-                                    let path = use_tree.path()?;\n-                                    let path_segment = path.segment()?;\n-                                    path_segment.name_ref()\n-                                }).unwrap_or(name_ref)\n-                        } else {\n-                            name_ref\n-                        };\n-                        let name_ref_class = NameRefClass::classify(sema, &name_ref)?;\n-\n-                        Some(NameClass::Definition(match name_ref_class {\n-                            NameRefClass::Definition(def) => def,\n-                            NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n-                                Definition::Field(field_ref)\n-                            }\n-                        }))\n-                    } else {\n-                        let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n-                        let krate = sema.resolve_extern_crate(&extern_crate)?;\n-                        let root_module = krate.root_module(sema.db);\n-                        Some(NameClass::Definition(Definition::Module(root_module)))\n+            let local = sema.to_def(&it)?;\n+            let pat_parent = it.syntax().parent();\n+            if let Some(record_pat_field) = pat_parent.and_then(ast::RecordPatField::cast) {\n+                if record_pat_field.name_ref().is_none() {\n+                    if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n+                        return Some(NameClass::PatFieldShorthand {\n+                            local_def: local,\n+                            field_ref: field,\n+                        });\n                     }\n-                },\n-                ast::IdentPat(it) => {\n-                    let local = sema.to_def(&it)?;\n+                }\n+            }\n \n-                    if let Some(record_pat_field) = it.syntax().parent().and_then(ast::RecordPatField::cast) {\n-                        if record_pat_field.name_ref().is_none() {\n-                            if let Some(field) = sema.resolve_record_pat_field(&record_pat_field) {\n-                                return Some(NameClass::PatFieldShorthand { local_def: local, field_ref: field });\n-                            }\n-                        }\n-                    }\n+            Definition::Local(local)\n+        } else if let Some(it) = ast::Rename::cast(parent.clone()) {\n+            if let Some(use_tree) = it.syntax().parent().and_then(ast::UseTree::cast) {\n+                let path = use_tree.path()?;\n+                let path_segment = path.segment()?;\n+                let name_ref = path_segment.name_ref()?;\n+                let name_ref = if name_ref.self_token().is_some() {\n+                    use_tree\n+                        .syntax()\n+                        .parent()\n+                        .as_ref()\n+                        // Skip over UseTreeList\n+                        .and_then(|it| {\n+                            let use_tree = it.parent().and_then(ast::UseTree::cast)?;\n+                            let path = use_tree.path()?;\n+                            let path_segment = path.segment()?;\n+                            path_segment.name_ref()\n+                        })\n+                        .unwrap_or(name_ref)\n+                } else {\n+                    name_ref\n+                };\n+                let name_ref_class = NameRefClass::classify(sema, &name_ref)?;\n \n-                    Some(NameClass::Definition(Definition::Local(local)))\n-                },\n-                ast::SelfParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Local(def)))\n-                },\n-                ast::RecordField(it) => {\n-                    let field: hir::Field = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Field(field)))\n-                },\n-                ast::Module(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Module(def)))\n-                },\n-                ast::Struct(it) => {\n-                    let def: hir::Struct = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Union(it) => {\n-                    let def: hir::Union = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Enum(it) => {\n-                    let def: hir::Enum = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Adt(def.into())))\n-                },\n-                ast::Trait(it) => {\n-                    let def: hir::Trait = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Trait(def)))\n-                },\n-                ast::Static(it) => {\n-                    let def: hir::Static = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Static(def)))\n-                },\n-                ast::Variant(it) => {\n-                    let def: hir::Variant = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Variant(def)))\n-                },\n-                ast::Fn(it) => {\n-                    let def: hir::Function = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Function(def)))\n-                },\n-                ast::Const(it) => {\n-                    let def: hir::Const = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Const(def)))\n-                },\n-                ast::TypeAlias(it) => {\n-                    let def: hir::TypeAlias = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::TypeAlias(def)))\n-                },\n-                ast::Macro(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::Macro(def)))\n-                },\n-                ast::TypeParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::GenericParam(def.into())))\n-                },\n-                ast::ConstParam(it) => {\n-                    let def = sema.to_def(&it)?;\n-                    Some(NameClass::Definition(Definition::GenericParam(def.into())))\n-                },\n-                _ => None,\n+                match name_ref_class {\n+                    NameRefClass::Definition(def) => def,\n+                    NameRefClass::FieldShorthand { local_ref: _, field_ref } => {\n+                        Definition::Field(field_ref)\n+                    }\n+                }\n+            } else {\n+                let extern_crate = it.syntax().parent().and_then(ast::ExternCrate::cast)?;\n+                let krate = sema.resolve_extern_crate(&extern_crate)?;\n+                let root_module = krate.root_module(sema.db);\n+                Definition::Module(root_module)\n             }\n-        }\n+        } else {\n+            match_ast! {\n+                match parent {\n+                    ast::SelfParam(it) => Definition::Local(sema.to_def(&it)?),\n+                    ast::RecordField(it) => Definition::Field(sema.to_def(&it)?),\n+                    ast::Variant(it) => Definition::Variant(sema.to_def(&it)?),\n+                    ast::TypeParam(it) => Definition::GenericParam(sema.to_def(&it)?.into()),\n+                    ast::ConstParam(it) => Definition::GenericParam(sema.to_def(&it)?.into()),\n+                    _ => return None,\n+                }\n+            }\n+        };\n+\n+        Some(NameClass::Definition(def))\n     }\n \n     pub fn classify_lifetime("}]}