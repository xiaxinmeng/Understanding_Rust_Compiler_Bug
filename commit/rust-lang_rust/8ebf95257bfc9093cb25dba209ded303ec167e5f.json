{"sha": "8ebf95257bfc9093cb25dba209ded303ec167e5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlYmY5NTI1N2JmYzkwOTNjYjI1ZGJhMjA5ZGVkMzAzZWMxNjdlNWY=", "commit": {"author": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-06-28T17:36:46Z"}, "committer": {"name": "Eli Friedman", "email": "eli.friedman@gmail.com", "date": "2015-07-25T02:17:45Z"}, "message": "Allow recursive static variables.\n\nThere isn't any particularly good reason for this restriction, so just\nget rid of it, and fix trans to handle this case.", "tree": {"sha": "aaaf49abe71d1d2255b4a1c5ee23e0f85e64b0d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aaaf49abe71d1d2255b4a1c5ee23e0f85e64b0d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8ebf95257bfc9093cb25dba209ded303ec167e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8ebf95257bfc9093cb25dba209ded303ec167e5f", "html_url": "https://github.com/rust-lang/rust/commit/8ebf95257bfc9093cb25dba209ded303ec167e5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8ebf95257bfc9093cb25dba209ded303ec167e5f/comments", "author": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eefriedman", "id": 12769964, "node_id": "MDQ6VXNlcjEyNzY5OTY0", "avatar_url": "https://avatars.githubusercontent.com/u/12769964?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eefriedman", "html_url": "https://github.com/eefriedman", "followers_url": "https://api.github.com/users/eefriedman/followers", "following_url": "https://api.github.com/users/eefriedman/following{/other_user}", "gists_url": "https://api.github.com/users/eefriedman/gists{/gist_id}", "starred_url": "https://api.github.com/users/eefriedman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eefriedman/subscriptions", "organizations_url": "https://api.github.com/users/eefriedman/orgs", "repos_url": "https://api.github.com/users/eefriedman/repos", "events_url": "https://api.github.com/users/eefriedman/events{/privacy}", "received_events_url": "https://api.github.com/users/eefriedman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/82d40cb2ba44a27b7db8ec185b5c532237db4b3e", "html_url": "https://github.com/rust-lang/rust/commit/82d40cb2ba44a27b7db8ec185b5c532237db4b3e"}], "stats": {"total": 155, "additions": 96, "deletions": 59}, "files": [{"sha": "822106c52692e57622bd3ef247a844cf055bef0e", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -13,7 +13,7 @@\n \n use ast_map;\n use session::Session;\n-use middle::def::{DefStatic, DefConst, DefAssociatedConst, DefVariant, DefMap};\n+use middle::def::{DefConst, DefAssociatedConst, DefVariant, DefMap};\n use util::nodemap::NodeMap;\n \n use syntax::{ast, ast_util};\n@@ -37,7 +37,6 @@ struct CheckCrateVisitor<'a, 'ast: 'a> {\n impl<'a, 'ast: 'a> Visitor<'ast> for CheckCrateVisitor<'a, 'ast> {\n     fn visit_item(&mut self, it: &'ast ast::Item) {\n         match it.node {\n-            ast::ItemStatic(..) |\n             ast::ItemConst(..) => {\n                 let mut recursion_visitor =\n                     CheckItemRecursionVisitor::new(self, &it.span);\n@@ -217,7 +216,6 @@ impl<'a, 'ast: 'a> Visitor<'ast> for CheckItemRecursionVisitor<'a, 'ast> {\n         match e.node {\n             ast::ExprPath(..) => {\n                 match self.def_map.borrow().get(&e.id).map(|d| d.base_def) {\n-                    Some(DefStatic(def_id, _)) |\n                     Some(DefAssociatedConst(def_id, _)) |\n                     Some(DefConst(def_id))\n                            if ast_util::is_local(def_id) => {"}, {"sha": "c331bf8d4610132f5254db20faedcd13ec699325", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -2090,7 +2090,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n           let mut v = TransItemVisitor{ ccx: ccx };\n           v.visit_expr(&**expr);\n \n-          let g = consts::trans_static(ccx, m, item.id);\n+          let g = consts::trans_static(ccx, m, expr, item.id, &item.attrs);\n           update_linkage(ccx, g, Some(item.id), OriginalTranslation);\n       },\n       ast::ItemForeignMod(ref foreign_mod) => {\n@@ -2334,44 +2334,25 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = || exported_name(ccx, id, ty, &i.attrs);\n \n             let v = match i.node {\n-                ast::ItemStatic(_, _, ref expr) => {\n+                ast::ItemStatic(..) => {\n                     // If this static came from an external crate, then\n                     // we need to get the symbol from csearch instead of\n                     // using the current crate's name/version\n                     // information in the hash of the symbol\n                     let sym = sym();\n                     debug!(\"making {}\", sym);\n \n-                    // We need the translated value here, because for enums the\n-                    // LLVM type is not fully determined by the Rust type.\n-                    let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs, None);\n-                    ccx.static_values().borrow_mut().insert(id, v);\n-                    unsafe {\n-                        // boolean SSA values are i1, but they have to be stored in i8 slots,\n-                        // otherwise some LLVM optimization passes don't work as expected\n-                        let llty = if ty.is_bool() {\n-                            llvm::LLVMInt8TypeInContext(ccx.llcx())\n-                        } else {\n-                            llvm::LLVMTypeOf(v)\n-                        };\n-\n-                        // FIXME(nagisa): probably should be declare_global, because no definition\n-                        // is happening here, but we depend on it being defined here from\n-                        // const::trans_static. This all logic should be replaced.\n-                        let g = declare::define_global(ccx, &sym[..],\n-                                                       Type::from_ref(llty)).unwrap_or_else(||{\n-                            ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n-                                                                   sym))\n-                        });\n-\n-                        if attr::contains_name(&i.attrs,\n-                                               \"thread_local\") {\n-                            llvm::set_thread_local(g, true);\n-                        }\n-                        ccx.item_symbols().borrow_mut().insert(i.id, sym);\n-                        g\n-                    }\n+                    // Create the global before evaluating the initializer;\n+                    // this is necessary to allow recursive statics.\n+                    let llty = type_of(ccx, ty);\n+                    let g = declare::define_global(ccx, &sym[..],\n+                                                   llty).unwrap_or_else(|| {\n+                        ccx.sess().span_fatal(i.span, &format!(\"symbol `{}` is already defined\",\n+                                                                sym))\n+                    });\n+\n+                    ccx.item_symbols().borrow_mut().insert(i.id, sym);\n+                    g\n                 }\n \n                 ast::ItemFn(_, _, _, abi, _, _) => {\n@@ -2738,6 +2719,13 @@ pub fn trans_crate(tcx: &ty::ctxt, analysis: ty::CrateAnalysis) -> CrateTranslat\n         if ccx.sess().opts.debuginfo != NoDebugInfo {\n             debuginfo::finalize(&ccx);\n         }\n+        for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+            unsafe {\n+                let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                llvm::LLVMDeleteGlobal(old_g);\n+            }\n+        }\n     }\n \n     // Translate the metadata."}, {"sha": "bd9c4a171773c68cb975387da113953a8bb85c7f", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -37,8 +37,9 @@ use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::nodemap::NodeMap;\n \n+use std::ffi::{CStr, CString};\n use libc::c_uint;\n-use syntax::{ast, ast_util};\n+use syntax::{ast, ast_util, attr};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n@@ -898,37 +899,70 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                 \"bad constant expression type in consts::const_expr\"),\n     }\n }\n-\n-pub fn trans_static(ccx: &CrateContext, m: ast::Mutability, id: ast::NodeId) -> ValueRef {\n+pub fn trans_static(ccx: &CrateContext,\n+                    m: ast::Mutability,\n+                    expr: &ast::Expr,\n+                    id: ast::NodeId,\n+                    attrs: &Vec<ast::Attribute>)\n+                    -> ValueRef {\n     unsafe {\n         let _icx = push_ctxt(\"trans_static\");\n         let g = base::get_item_val(ccx, id);\n-        // At this point, get_item_val has already translated the\n-        // constant's initializer to determine its LLVM type.\n-        let v = ccx.static_values().borrow().get(&id).unwrap().clone();\n+\n+        let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n+        let (v, _) = const_expr(ccx, expr, empty_substs, None);\n+\n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n         // otherwise some LLVM optimization passes don't work as expected\n-        let v = if llvm::LLVMTypeOf(v) == Type::i1(ccx).to_ref() {\n-            llvm::LLVMConstZExt(v, Type::i8(ccx).to_ref())\n+        let mut val_llty = llvm::LLVMTypeOf(v);\n+        let v = if val_llty == Type::i1(ccx).to_ref() {\n+            val_llty = Type::i8(ccx).to_ref();\n+            llvm::LLVMConstZExt(v, val_llty)\n         } else {\n             v\n         };\n+\n+        let ty = ccx.tcx().node_id_to_type(id);\n+        let llty = type_of::type_of(ccx, ty);\n+        let g = if val_llty == llty.to_ref() {\n+            g\n+        } else {\n+            // If we created the global with the wrong type,\n+            // correct the type.\n+            let empty_string = CString::new(\"\").unwrap();\n+            let name_str_ref = CStr::from_ptr(llvm::LLVMGetValueName(g));\n+            let name_string = CString::new(name_str_ref.to_bytes()).unwrap();\n+            llvm::LLVMSetValueName(g, empty_string.as_ptr());\n+            let new_g = llvm::LLVMGetOrInsertGlobal(\n+                ccx.llmod(), name_string.as_ptr(), val_llty);\n+            // To avoid breaking any invariants, we leave around the old\n+            // global for the moment; we'll replace all references to it\n+            // with the new global later. (See base::trans_crate.)\n+            ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n+            new_g\n+        };\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n         if m != ast::MutMutable {\n-            let node_ty = ccx.tcx().node_id_to_type(id);\n-            let tcontents = node_ty.type_contents(ccx.tcx());\n+            let tcontents = ty.type_contents(ccx.tcx());\n             if !tcontents.interior_unsafe() {\n-                llvm::LLVMSetGlobalConstant(g, True);\n+                llvm::LLVMSetGlobalConstant(g, llvm::True);\n             }\n         }\n+\n         debuginfo::create_global_var_metadata(ccx, id, g);\n+\n+        if attr::contains_name(attrs,\n+                               \"thread_local\") {\n+            llvm::set_thread_local(g, true);\n+        }\n         g\n     }\n }\n \n+\n fn get_static_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, did: ast::DefId,\n                             ty: Ty<'tcx>) -> ValueRef {\n     if ast_util::is_local(did) { return base::get_item_val(ccx, did.node) }"}, {"sha": "1b6307f28bfdf91bdb62a7c5ed59947f48d76f82", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -118,9 +118,6 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of emitted const values\n     const_values: RefCell<FnvHashMap<(ast::NodeId, &'tcx Substs<'tcx>), ValueRef>>,\n \n-    /// Cache of emitted static values\n-    static_values: RefCell<NodeMap<ValueRef>>,\n-\n     /// Cache of external const values\n     extern_const_values: RefCell<DefIdMap<ValueRef>>,\n \n@@ -129,6 +126,12 @@ pub struct LocalCrateContext<'tcx> {\n     /// Cache of closure wrappers for bare fn's.\n     closure_bare_wrapper_cache: RefCell<FnvHashMap<ValueRef, ValueRef>>,\n \n+    /// List of globals for static variables which need to be passed to the\n+    /// LLVM function ReplaceAllUsesWith (RAUW) when translation is complete.\n+    /// (We have to make sure we don't invalidate any ValueRefs referring\n+    /// to constants.)\n+    statics_to_rauw: RefCell<Vec<(ValueRef, ValueRef)>>,\n+\n     lltypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     llsizingtypes: RefCell<FnvHashMap<Ty<'tcx>, Type>>,\n     adt_reprs: RefCell<FnvHashMap<Ty<'tcx>, Rc<adt::Repr<'tcx>>>>,\n@@ -449,10 +452,10 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                 const_unsized: RefCell::new(FnvHashMap()),\n                 const_globals: RefCell::new(FnvHashMap()),\n                 const_values: RefCell::new(FnvHashMap()),\n-                static_values: RefCell::new(NodeMap()),\n                 extern_const_values: RefCell::new(DefIdMap()),\n                 impl_method_cache: RefCell::new(FnvHashMap()),\n                 closure_bare_wrapper_cache: RefCell::new(FnvHashMap()),\n+                statics_to_rauw: RefCell::new(Vec::new()),\n                 lltypes: RefCell::new(FnvHashMap()),\n                 llsizingtypes: RefCell::new(FnvHashMap()),\n                 adt_reprs: RefCell::new(FnvHashMap()),\n@@ -660,10 +663,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.const_values\n     }\n \n-    pub fn static_values<'a>(&'a self) -> &'a RefCell<NodeMap<ValueRef>> {\n-        &self.local.static_values\n-    }\n-\n     pub fn extern_const_values<'a>(&'a self) -> &'a RefCell<DefIdMap<ValueRef>> {\n         &self.local.extern_const_values\n     }\n@@ -677,6 +676,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.closure_bare_wrapper_cache\n     }\n \n+    pub fn statics_to_rauw<'a>(&'a self) -> &'a RefCell<Vec<(ValueRef, ValueRef)>> {\n+        &self.local.statics_to_rauw\n+    }\n+\n     pub fn lltypes<'a>(&'a self) -> &'a RefCell<FnvHashMap<Ty<'tcx>, Type>> {\n         &self.local.lltypes\n     }"}, {"sha": "7c05a817243b498b20d0f1c0fa03947f350595c8", "filename": "src/test/compile-fail/const-recursive.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-recursive.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: recursive constant\n-static a: isize = b;\n-static b: isize = a;\n+const a: isize = b; //~ ERROR recursive constant\n+const b: isize = a; //~ ERROR recursive constant\n \n fn main() {\n }"}, {"sha": "0c04e295e1458cb24738f68a7c186e846ba30150", "filename": "src/test/compile-fail/issue-17252.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17252.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-static FOO: usize = FOO; //~ ERROR recursive constant\n+const FOO: usize = FOO; //~ ERROR recursive constant\n \n fn main() {\n     let _x: [u8; FOO]; // caused stack overflow prior to fix\n     let _y: usize = 1 + {\n-        static BAR: usize = BAR; //~ ERROR recursive constant\n+        const BAR: usize = BAR; //~ ERROR recursive constant\n         let _z: [u8; BAR]; // caused stack overflow prior to fix\n         1\n     };"}, {"sha": "edb0678cd7838b12725bdac8a80e98fdc90cf8d3", "filename": "src/test/run-pass/static-recursive.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8ebf95257bfc9093cb25dba209ded303ec167e5f/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-recursive.rs?ref=8ebf95257bfc9093cb25dba209ded303ec167e5f", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static mut S: *const u8 = unsafe { &S as *const *const u8 as *const u8 };\n+\n+pub fn main() {\n+    unsafe { assert_eq!(S, *(S as *const *const u8)); }\n+}"}]}