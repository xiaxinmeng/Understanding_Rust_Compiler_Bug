{"sha": "3baa435b705f1e4c8b5233208320c9907c796b46", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiYWE0MzViNzA1ZjFlNGM4YjUyMzMyMDgzMjBjOTkwN2M3OTZiNDY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-01-05T00:00:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-01-05T00:00:28Z"}, "message": "Merge pull request #1419 from Manishearth/rustup\n\nRust upgrade to rustc 1.16.0-nightly (468227129 2017-01-03)", "tree": {"sha": "dfd7cedaf2d1c3514d3702d4883fd1ef0dce2f7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfd7cedaf2d1c3514d3702d4883fd1ef0dce2f7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3baa435b705f1e4c8b5233208320c9907c796b46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3baa435b705f1e4c8b5233208320c9907c796b46", "html_url": "https://github.com/rust-lang/rust/commit/3baa435b705f1e4c8b5233208320c9907c796b46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3baa435b705f1e4c8b5233208320c9907c796b46/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ab332303a2c7c41779436ec1964be07b576062", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ab332303a2c7c41779436ec1964be07b576062", "html_url": "https://github.com/rust-lang/rust/commit/e0ab332303a2c7c41779436ec1964be07b576062"}, {"sha": "ab42f020038da90d4c057b0d1a2d94da43231839", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab42f020038da90d4c057b0d1a2d94da43231839", "html_url": "https://github.com/rust-lang/rust/commit/ab42f020038da90d4c057b0d1a2d94da43231839"}], "stats": {"total": 438, "additions": 265, "deletions": 173}, "files": [{"sha": "97bfbfda7606bf87fd2ead5fdbf4a7e0c92e58d6", "filename": "CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -1,6 +1,12 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.105 \u2014 2016-12-15\n+* Update to *rustc 1.15.0-nightly (8f02c429a 2016-12-15)*\n+* New lints: [`deref_addrof`], [`double_parens`], [`pub_enum_variant_names`]\n+* Fix suggestion in [`new_without_default`]\n+* FP fix in [`absurd_extreme_comparisons`]\n+\n ## 0.0.104 \u2014 2016-12-15\n * Update to *rustc 1.15.0-nightly (8f02c429a 2016-12-15)*\n "}, {"sha": "d614a2389ef2b2b153c19857d02d2d3e970c26ad", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.104\"\n+version = \"0.0.105\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.104\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.105\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "2792ca16d6271e453864d2da219072727b79050e", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.104\"\n+version = \"0.0.105\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "f14268f9b4c1a2f13b55ab517643a24b98ad63b5", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n             // Array with known size can be checked statically\n             let ty = cx.tcx.tables().expr_ty(array);\n             if let ty::TyArray(_, size) = ty.sty {\n-                let size = ConstInt::Infer(size as u64);\n+                let size = ConstInt::Infer(size as u128);\n \n                 // Index is a constant uint\n                 let const_index = eval_const_expr_partial(cx.tcx, index, ExprTypeChecked, None);"}, {"sha": "f5ba053d28cee2ce9acc694ce0c79ab5204417b6", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -157,23 +157,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n     if let ItemFn(_, _, _, _, _, eid) = item.node {\n-        is_relevant_expr(cx, cx.tcx.map.expr(eid))\n+        is_relevant_expr(cx, &cx.tcx.map.body(eid).value)\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n-        MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(eid)) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n+        TraitItemKind::Method(_, TraitMethod::Required(_)) => true,\n+        TraitItemKind::Method(_, TraitMethod::Provided(eid)) => is_relevant_expr(cx, &cx.tcx.map.body(eid).value),\n         _ => false,\n     }\n }"}, {"sha": "1323ce29875b853f984b6062f1556d226a8e694a", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -106,7 +106,7 @@ fn invert_cmp(cmp: BinOp_) -> BinOp_ {\n }\n \n \n-fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64, span: &Span) {\n+fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u128, span: &Span) {\n     if let ExprBinary(ref op, ref left, ref right) = bit_op.node {\n         if op.node != BiBitAnd && op.node != BiBitOr {\n             return;\n@@ -117,7 +117,7 @@ fn check_compare(cx: &LateContext, bit_op: &Expr, cmp_op: BinOp_, cmp_value: u64\n     }\n }\n \n-fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u64, cmp_value: u64, span: &Span) {\n+fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value: u128, cmp_value: u128, span: &Span) {\n     match cmp_op {\n         BiEq | BiNe => {\n             match bit_op {\n@@ -212,7 +212,7 @@ fn check_bit_mask(cx: &LateContext, bit_op: BinOp_, cmp_op: BinOp_, mask_value:\n     }\n }\n \n-fn check_ineffective_lt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n+fn check_ineffective_lt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n     if c.is_power_of_two() && m < c {\n         span_lint(cx,\n                   INEFFECTIVE_BIT_MASK,\n@@ -224,7 +224,7 @@ fn check_ineffective_lt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n     }\n }\n \n-fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str) {\n+fn check_ineffective_gt(cx: &LateContext, span: Span, m: u128, c: u128, op: &str) {\n     if (c + 1).is_power_of_two() && m <= c {\n         span_lint(cx,\n                   INEFFECTIVE_BIT_MASK,\n@@ -236,7 +236,7 @@ fn check_ineffective_gt(cx: &LateContext, span: Span, m: u64, c: u64, op: &str)\n     }\n }\n \n-fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n+fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u128> {\n     match lit.node {\n         ExprLit(ref lit_ptr) => {\n             if let LitKind::Int(value, _) = lit_ptr.node {"}, {"sha": "6a02e69a8818d01d5fad7bf96d5e7012105b62d0", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -57,9 +57,10 @@ struct ExVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if let ExprClosure(_, _, eid, _) = expr.node {\n-            let expr = self.cx.tcx.map.expr(eid);\n-            if matches!(expr.node, ExprBlock(_)) {\n-                self.found_block = Some(expr);\n+            let body = self.cx.tcx.map.body(eid);\n+            let ex = &body.value;\n+            if matches!(ex.node, ExprBlock(_)) {\n+                self.found_block = Some(ex);\n                 return;\n             }\n         }"}, {"sha": "1f31cb0b2ecd2925d165571889e2712d809b9b88", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -74,7 +74,7 @@ impl PartialEq for Constant {\n             (&Constant::Binary(ref l), &Constant::Binary(ref r)) => l == r,\n             (&Constant::Char(l), &Constant::Char(r)) => l == r,\n             (&Constant::Int(l), &Constant::Int(r)) => {\n-                l.is_negative() == r.is_negative() && l.to_u64_unchecked() == r.to_u64_unchecked()\n+                l.is_negative() == r.is_negative() && l.to_u128_unchecked() == r.to_u128_unchecked()\n             },\n             (&Constant::Float(ref ls, _), &Constant::Float(ref rs, _)) => {\n                 // we want `Fw32 == FwAny` and `FwAny == Fw64`, by transitivity we must have\n@@ -110,7 +110,7 @@ impl Hash for Constant {\n                 c.hash(state);\n             },\n             Constant::Int(i) => {\n-                i.to_u64_unchecked().hash(state);\n+                i.to_u128_unchecked().hash(state);\n                 i.is_negative().hash(state);\n             },\n             Constant::Float(ref f, _) => {\n@@ -185,13 +185,15 @@ pub fn lit_to_constant(lit: &LitKind) -> Constant {\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U16)) => Constant::Int(ConstInt::U16(value as u16)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U32)) => Constant::Int(ConstInt::U32(value as u32)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::U64)) => Constant::Int(ConstInt::U64(value as u64)),\n+        LitKind::Int(value, LitIntType::Unsigned(UintTy::U128)) => Constant::Int(ConstInt::U128(value as u128)),\n         LitKind::Int(value, LitIntType::Unsigned(UintTy::Us)) => {\n             Constant::Int(ConstInt::Usize(ConstUsize::Us32(value as u32)))\n         },\n         LitKind::Int(value, LitIntType::Signed(IntTy::I8)) => Constant::Int(ConstInt::I8(value as i8)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I16)) => Constant::Int(ConstInt::I16(value as i16)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I32)) => Constant::Int(ConstInt::I32(value as i32)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::I64)) => Constant::Int(ConstInt::I64(value as i64)),\n+        LitKind::Int(value, LitIntType::Signed(IntTy::I128)) => Constant::Int(ConstInt::I128(value as i128)),\n         LitKind::Int(value, LitIntType::Signed(IntTy::Is)) => {\n             Constant::Int(ConstInt::Isize(ConstIsize::Is32(value as i32)))\n         },\n@@ -258,8 +260,14 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n             ExprArray(ref vec) => self.multi(vec).map(Constant::Vec),\n             ExprTup(ref tup) => self.multi(tup).map(Constant::Tuple),\n-            ExprRepeat(ref value, ref number) => {\n-                self.binop_apply(value, number, |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n+            ExprRepeat(ref value, number_id) => {\n+                if let Some(lcx) = self.lcx {\n+                    self.binop_apply(value,\n+                                     &lcx.tcx.map.body(number_id).value,\n+                                     |v, n| Some(Constant::Repeat(Box::new(v), n.as_u64() as usize)))\n+                } else {\n+                    None\n+                }\n             },\n             ExprUnary(op, ref operand) => {\n                 self.expr(operand).and_then(|o| {"}, {"sha": "f2aabfca69e6f45f9da448dcc4fd6ddc56859a15", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -94,20 +94,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(_, _, _, _, _, eid) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, cx.tcx.map.expr(eid), item.span);\n+                self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n             }\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(_, eid) = item.node {\n-            self.check(cx, cx.tcx.map.expr(eid), item.span);\n+            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n         }\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let MethodTraitItem(_, Some(eid)) = item.node {\n-            self.check(cx, cx.tcx.map.expr(eid), item.span);\n+        if let TraitItemKind::Method(_, TraitMethod::Provided(eid)) = item.node {\n+            self.check(cx, &cx.tcx.map.body(eid).value, item.span);\n         }\n     }\n "}, {"sha": "896efb438458138a03f3a9bed8268566e0fdb9c6", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -42,9 +42,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;\n-                if let Some(ref disr) = variant.disr_expr {\n+                if let Some(body_id) = variant.disr_expr {\n                     use rustc_const_eval::*;\n-                    let bad = match eval_const_expr_partial(cx.tcx, &**disr, EvalHint::ExprTypeChecked, None) {\n+                    let bad = match eval_const_expr_partial(cx.tcx,\n+                                                            &cx.tcx.map.body(body_id).value,\n+                                                            EvalHint::ExprTypeChecked,\n+                                                            None) {\n                         Ok(ConstVal::Integral(Usize(Us64(i)))) => i as u32 as u64 != i,\n                         Ok(ConstVal::Integral(Isize(Is64(i)))) => i as i32 as i64 != i,\n                         _ => false,"}, {"sha": "3384693c51ec9dc3d056ea9ea8d2e479a9803685", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -64,8 +64,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         &mut self,\n         cx: &LateContext<'a, 'tcx>,\n         _: visit::FnKind<'tcx>,\n-        decl: &'tcx FnDecl,\n-        body: &'tcx Expr,\n+        _: &'tcx FnDecl,\n+        body: &'tcx Body,\n         _: Span,\n         id: NodeId\n     ) {\n@@ -82,7 +82,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n         {\n             let mut vis = ExprUseVisitor::new(&mut v, &infcx);\n-            vis.walk_fn(decl, body);\n+            vis.consume_body(body);\n         }\n \n         for node in v.set {"}, {"sha": "19289803299493d6ce5e99e42ad0f15429248594", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -1,7 +1,7 @@\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{snippet_opt, span_lint_and_then, is_adjusted};\n+use utils::{snippet_opt, span_lint_and_then, is_adjusted, iter_input_pats};\n \n #[allow(missing_copy_implementations)]\n pub struct EtaPass;\n@@ -49,7 +49,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n     if let ExprClosure(_, ref decl, eid, _) = expr.node {\n-        let ex = cx.tcx.map.expr(eid);\n+        let body = cx.tcx.map.body(eid);\n+        let ex = &body.value;\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n@@ -71,7 +72,7 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 },\n                 _ => (),\n             }\n-            for (a1, a2) in decl.inputs.iter().zip(args) {\n+            for (a1, a2) in iter_input_pats(decl, body).zip(args) {\n                 if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n                     if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {"}, {"sha": "7194f45d9501a0767459f5cf1198256904445955", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -81,7 +81,7 @@ pub fn get_argument_fmtstr_parts<'a, 'b>(cx: &LateContext<'a, 'b>, expr: &'a Exp\n         let Some(NodeItem(decl)) = cx.tcx.map.find(decl.id),\n         &*decl.name.as_str() == \"__STATIC_FMTSTR\",\n         let ItemStatic(_, _, ref expr) = decl.node,\n-        let ExprAddrOf(_, ref expr) = expr.node, // &[\"\u2026\", \"\u2026\", \u2026]\n+        let ExprAddrOf(_, ref expr) = cx.tcx.map.body(*expr).value.node, // &[\"\u2026\", \"\u2026\", \u2026]\n         let ExprArray(ref exprs) = expr.node,\n     ], {\n         let mut result = Vec::new();"}, {"sha": "2d85f2dd3cbf8afa2158238bccdffd5fb7bdb268", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -6,7 +6,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::abi::Abi;\n use syntax::codemap::Span;\n-use utils::{span_lint, type_is_unsafe_function};\n+use utils::{span_lint, type_is_unsafe_function, iter_input_pats};\n \n /// **What it does:** Checks for functions with too many parameters.\n ///\n@@ -74,7 +74,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n         cx: &LateContext<'a, 'tcx>,\n         kind: intravisit::FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        expr: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         span: Span,\n         nodeid: ast::NodeId\n     ) {\n@@ -102,19 +102,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n+        self.check_raw_ptr(cx, unsafety, decl, body, nodeid);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, eid) = item.node {\n+        if let hir::TraitItemKind::Method(ref sig, ref eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n             if sig.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(eid) = eid {\n-                let expr = cx.tcx.map.expr(eid);\n-                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n+            if let hir::TraitMethod::Provided(eid) = *eid {\n+                let body = cx.tcx.map.body(eid);\n+                self.check_raw_ptr(cx, sig.unsafety, &sig.decl, body, item.id);\n             }\n         }\n     }\n@@ -136,11 +136,15 @@ impl<'a, 'tcx> Functions {\n         cx: &LateContext<'a, 'tcx>,\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n-        expr: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         nodeid: ast::NodeId\n     ) {\n+        let expr = &body.value;\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n-            let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n+            let raw_ptrs = iter_input_pats(decl, body)\n+                .zip(decl.inputs.iter())\n+                .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))\n+                .collect::<HashSet<_>>();\n \n             if !raw_ptrs.is_empty() {\n                 let mut v = DerefVisitor {\n@@ -154,8 +158,8 @@ impl<'a, 'tcx> Functions {\n     }\n }\n \n-fn raw_ptr_arg(_cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+fn raw_ptr_arg(arg: &hir::Arg, ty: &hir::Ty) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &ty.node) {\n         Some(def_id)\n     } else {\n         None"}, {"sha": "fa4a5bf67573dcf03ab5553789fb23ef71758c9c", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -87,23 +87,24 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n     }\n }\n \n-fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItem]) {\n-    fn is_named_self(item: &TraitItem, name: &str) -> bool {\n+fn check_trait_items(cx: &LateContext, item: &Item, trait_items: &[TraitItemRef]) {\n+    fn is_named_self(cx: &LateContext, item: &TraitItemRef, name: &str) -> bool {\n         &*item.name.as_str() == name &&\n-        if let MethodTraitItem(ref sig, _) = item.node {\n-            if sig.decl.has_self() {\n-                sig.decl.inputs.len() == 1\n-            } else {\n-                false\n+        if let AssociatedItemKind::Method { has_self } = item.kind {\n+            has_self &&\n+            {\n+                let did = cx.tcx.map.local_def_id(item.id.node_id);\n+                let impl_ty = cx.tcx.item_type(did);\n+                impl_ty.fn_args().skip_binder().len() == 1\n             }\n         } else {\n             false\n         }\n     }\n \n-    if !trait_items.iter().any(|i| is_named_self(i, \"is_empty\")) {\n-        if let Some(i) = trait_items.iter().find(|i| is_named_self(i, \"len\")) {\n-            if cx.access_levels.is_exported(i.id) {\n+    if !trait_items.iter().any(|i| is_named_self(cx, i, \"is_empty\")) {\n+        if let Some(i) = trait_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n+            if cx.access_levels.is_exported(i.id.node_id) {\n                 span_lint(cx,\n                           LEN_WITHOUT_IS_EMPTY,\n                           i.span,"}, {"sha": "cdcb271d8d7589b1b2881704e0300b13e3c704e8", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -3,10 +3,12 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(custom_attribute)]\n+#![feature(i128_type)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n #![feature(stmt_expr_attributes)]\n #![feature(repeat_str)]\n+#![feature(conservative_impl_trait)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n #![allow(needless_lifetimes)]"}, {"sha": "3006e5fc9b0d191c91f144bfeddae62f8b070ba0", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -70,7 +70,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let MethodTraitItem(ref sig, _) = item.node {\n+        if let TraitItemKind::Method(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n@@ -137,7 +137,7 @@ fn could_use_elision<'a, 'tcx: 'a, T: Iterator<Item = &'tcx Lifetime>>(\n \n     // extract lifetimes in input argument types\n     for arg in &func.inputs {\n-        input_visitor.visit_ty(&arg.ty);\n+        input_visitor.visit_ty(arg);\n     }\n     // extract lifetimes in output type\n     if let Return(ref ty) = func.output {"}, {"sha": "311eb16514b94863a4f8645c693d801ef9f2e04e", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::ast;\n use utils::{is_adjusted, match_path, match_trait_method, match_type, remove_blocks, paths, snippet,\n-            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_help_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, iter_input_pats};\n \n /// **What it does:** Checks for mapping `clone()` over an iterator.\n ///\n@@ -31,18 +31,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n                     ExprClosure(_, ref decl, closure_eid, _) => {\n-                        let closure_expr = remove_blocks(cx.tcx.map.expr(closure_eid));\n+                        let body = cx.tcx.map.body(closure_eid);\n+                        let closure_expr = remove_blocks(&body.value);\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n-                            let Some(arg_ident) = get_arg_name(&*decl.inputs[0].pat),\n+                            let Some(first_arg) = iter_input_pats(decl, body).next(),\n+                            let Some(arg_ident) = get_arg_name(&first_arg.pat),\n                             // the method is being called on a known type (option or iterator)\n                             let Some(type_name) = get_type_name(cx, expr, &args[0])\n                         ], {\n                             // look for derefs, for .map(|x| *x)\n                             if only_derefs(cx, &*closure_expr, arg_ident) &&\n                                 // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&*decl.inputs[0].pat)).1 == 1\n+                                walk_ptrs_ty_depth(cx.tcx.tables().pat_ty(&first_arg.pat)).1 == 1\n                             {\n                                 span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                     \"you seem to be using .map() to clone the contents of an {}, consider \\\n@@ -90,7 +92,7 @@ fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n                                    name: id,\n                                    parameters: PathParameters::none(),\n                                }];\n-            !path.global && path.segments[..] == arg_segment\n+            !path.is_global() && path.segments[..] == arg_segment\n         },\n         _ => false,\n     }"}, {"sha": "f25b5d01cea812921f558e2074662c90b084fcb7", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -219,10 +219,10 @@ fn check_single_match_opt_like(\n             if inner.iter().any(|pat| pat.node != PatKind::Wild) {\n                 return;\n             }\n-            path.to_string()\n+            print::to_string(print::NO_ANN, |s| s.print_qpath(path, false))\n         },\n         PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n-        PatKind::Path(ref path) => path.to_string(),\n+        PatKind::Path(ref path) => print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)),\n         _ => return,\n     };\n "}, {"sha": "8f1c6e4e9d1a852fdfbeb104c07cd639098ee72f", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 49, "deletions": 36, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -1,7 +1,6 @@\n use rustc::hir;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n-use rustc::middle::const_qualif::ConstQualif;\n use rustc::ty;\n use rustc::hir::def::Def;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n@@ -12,7 +11,7 @@ use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path, match_trait_method,\n             match_type, method_chain_args, return_ty, same_tys, snippet, span_lint, span_lint_and_then,\n             span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth, last_path_segment, single_segment_path,\n-            match_def_path};\n+            match_def_path, is_self, is_self_ty, iter_input_pats};\n use utils::paths;\n use utils::sugg;\n \n@@ -637,16 +636,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let parent = cx.tcx.map.get_parent(implitem.id);\n         let item = cx.tcx.map.expect_item(parent);\n         if_let_chain! {[\n-            let hir::ImplItemKind::Method(ref sig, _) = implitem.node,\n-            let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n-            let hir::ItemImpl(_, _, _, None, _, _) = item.node,\n+            let hir::ImplItemKind::Method(ref sig, id) = implitem.node,\n+            let Some(first_arg_ty) = sig.decl.inputs.get(0),\n+            let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.map.body(id)).next(),\n+            let hir::ItemImpl(_, _, _, None, ref self_ty, _) = item.node,\n         ], {\n             // check missing trait implementations\n             for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                 if &*name.as_str() == method_name &&\n                    sig.decl.inputs.len() == n_args &&\n                    out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(&explicit_self, false) {\n+                   self_kind.matches(&first_arg_ty, &first_arg, &self_ty, false) {\n                     span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n                         \"defining a method called `{}` on this type; consider implementing \\\n                          the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n@@ -659,8 +659,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             for &(ref conv, self_kinds) in &CONVENTIONS {\n                 if_let_chain! {[\n                     conv.check(&name.as_str()),\n-                    let Some(explicit_self) = sig.decl.inputs.get(0).and_then(hir::Arg::to_self),\n-                    !self_kinds.iter().any(|k| k.matches(&explicit_self, is_copy)),\n+                    !self_kinds.iter().any(|k| k.matches(&first_arg_ty, &first_arg, &self_ty, is_copy)),\n                 ], {\n                     let lint = if item.vis == hir::Visibility::Public {\n                         WRONG_PUB_SELF_CONVENTION\n@@ -669,7 +668,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                     };\n                     span_lint(cx,\n                               lint,\n-                              explicit_self.span,\n+                              first_arg.pat.span,\n                               &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n                                         ambiguous name\",\n                                        conv,\n@@ -685,7 +684,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                !ret_ty.walk().any(|t| same_tys(cx, t, ty, implitem.id)) {\n                 span_lint(cx,\n                           NEW_RET_NO_SELF,\n-                          explicit_self.span,\n+                          implitem.span,\n                           \"methods called `new` usually return `Self`\");\n             }\n         }}\n@@ -752,11 +751,16 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n     ) {\n         // don't lint for constant values\n         // FIXME: can we `expect` here instead of match?\n-        if let Some(qualif) = cx.tcx.const_qualif_map.borrow().get(&arg.id) {\n-            if !qualif.contains(ConstQualif::NOT_CONST) {\n-                return;\n-            }\n+        let promotable = cx.tcx\n+            .rvalue_promotable_to_static\n+            .borrow()\n+            .get(&arg.id)\n+            .cloned()\n+            .unwrap_or(true);\n+        if promotable {\n+            return;\n         }\n+\n         // (path, fn_has_argument, methods, suffix)\n         let know_types: &[(&[_], _, &[_], _)] =\n             &[(&paths::BTREEMAP_ENTRY, false, &[\"or_insert\"], \"with\"),\n@@ -1338,7 +1342,7 @@ const PATTERN_METHODS: [(&'static str, usize); 17] = [\n ];\n \n \n-#[derive(Clone, Copy)]\n+#[derive(Clone, Copy, PartialEq)]\n enum SelfKind {\n     Value,\n     Ref,\n@@ -1347,27 +1351,36 @@ enum SelfKind {\n }\n \n impl SelfKind {\n-    fn matches(self, slf: &hir::ExplicitSelf, allow_value_for_ref: bool) -> bool {\n-        match (self, &slf.node) {\n-            (SelfKind::Value, &hir::SelfKind::Value(_)) |\n-            (SelfKind::Ref, &hir::SelfKind::Region(_, hir::Mutability::MutImmutable)) |\n-            (SelfKind::RefMut, &hir::SelfKind::Region(_, hir::Mutability::MutMutable)) => true,\n-            (SelfKind::Ref, &hir::SelfKind::Value(_)) |\n-            (SelfKind::RefMut, &hir::SelfKind::Value(_)) => allow_value_for_ref,\n-            (_, &hir::SelfKind::Explicit(ref ty, _)) => self.matches_explicit_type(ty, allow_value_for_ref),\n-\n-            _ => false,\n-        }\n-    }\n-\n-    fn matches_explicit_type(self, ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n-        match (self, &ty.node) {\n-            (SelfKind::Value, &hir::TyPath(..)) |\n-            (SelfKind::Ref, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutImmutable, .. })) |\n-            (SelfKind::RefMut, &hir::TyRptr(_, hir::MutTy { mutbl: hir::Mutability::MutMutable, .. })) => true,\n-            (SelfKind::Ref, &hir::TyPath(..)) |\n-            (SelfKind::RefMut, &hir::TyPath(..)) => allow_value_for_ref,\n-            _ => false,\n+    fn matches(self, ty: &hir::Ty, arg: &hir::Arg, self_ty: &hir::Ty, allow_value_for_ref: bool) -> bool {\n+        // Self types in the HIR are desugared to explicit self types. So it will always be `self:\n+        // SomeType`,\n+        // where SomeType can be `Self` or an explicit impl self type (e.g. `Foo` if the impl is on `Foo`)\n+        // Thus, we only need to test equality against the impl self type or if it is an explicit\n+        // `Self`. Furthermore, the only possible types for `self: ` are `&Self`, `Self`, `&mut Self`,\n+        // and `Box<Self>`, including the equivalent types with `Foo`.\n+        let is_actually_self = |ty| is_self_ty(ty) || ty == self_ty;\n+        if is_self(arg) {\n+            match self {\n+                SelfKind::Value => is_actually_self(ty),\n+                SelfKind::Ref | SelfKind::RefMut if allow_value_for_ref => is_actually_self(ty),\n+                SelfKind::Ref | SelfKind::RefMut => {\n+                    match ty.node {\n+                        hir::TyRptr(_, ref mt_ty) => {\n+                            let mutability_match = if self == SelfKind::Ref {\n+                                mt_ty.mutbl == hir::MutImmutable\n+                            } else {\n+                                mt_ty.mutbl == hir::MutMutable\n+                            };\n+                            is_actually_self(&mt_ty.ty) && mutability_match\n+\n+                        },\n+                        _ => false,\n+                    }\n+                },\n+                _ => false,\n+            }\n+        } else {\n+            self == SelfKind::No\n         }\n     }\n "}, {"sha": "4af47d731726620fdf1d8e4726af6d69b181618e", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -9,7 +9,7 @@ use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment};\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats};\n use utils::sugg::Sugg;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n@@ -175,15 +175,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         cx: &LateContext<'a, 'tcx>,\n         k: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        _: &'tcx Expr,\n+        body: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n         }\n-        for arg in &decl.inputs {\n+        for arg in iter_input_pats(decl, body) {\n             if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,"}, {"sha": "d5be44e8c2b93ec01dc3b9a8e06bc2ede9f330d7", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -136,9 +136,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem) {\n         let desc = match trait_item.node {\n-            hir::ConstTraitItem(..) => \"an associated constant\",\n-            hir::MethodTraitItem(..) => \"a trait method\",\n-            hir::TypeTraitItem(..) => \"an associated type\",\n+            hir::TraitItemKind::Const(..) => \"an associated constant\",\n+            hir::TraitItemKind::Method(..) => \"a trait method\",\n+            hir::TraitItemKind::Type(..) => \"an associated type\",\n         };\n \n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);"}, {"sha": "6e27358836bcb770616de45cd65afeb5c1ee8852", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -42,7 +42,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                     .expect(\"A function with an unknown type is called. If this happened, the compiler would have \\\n                              aborted the compilation long ago\");\n                 if let ExprPath(ref path) = fn_expr.node {\n-                    check_arguments(cx, arguments, function_type, &path.to_string());\n+                    check_arguments(cx,\n+                                    arguments,\n+                                    function_type,\n+                                    &print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n                 }\n             },\n             ExprMethodCall(ref name, _, ref arguments) => {"}, {"sha": "5477204b79c12777a472c146455ad1a25faf7a32", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        _: &'tcx hir::Expr,\n+        _: &'tcx hir::Body,\n         span: Span,\n         id: ast::NodeId\n     ) {"}, {"sha": "ec5da909d60abe39c20fcf7f3e79c60a1b74de46", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         ], {\n             let is_result_type = match_type(cx, cx.tcx.tables().expr_ty(&result_types[0]), &paths::RESULT);\n             let some_expr_string = snippet(cx, y[0].span, \"\");\n-            if print::path_to_string(x) == \"Some\" && is_result_type {\n+            if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n                 span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,\n                 \"Matching on `Some` with `ok()` is redundant\",\n                 &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string));"}, {"sha": "78fdc06708a9b942400ed75bd25020911554bd57", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n-        if let MethodTraitItem(ref sig, _) = item.node {\n+        if let TraitItemKind::Method(ref sig, _) = item.node {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n@@ -99,13 +99,13 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n             if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n                           PTR_ARG,\n-                          arg.ty.span,\n+                          arg.span,\n                           \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n                            with non-Vec-based slices. Consider changing the type to `&[...]`\");\n             } else if match_type(cx, ty, &paths::STRING) {\n                 span_lint(cx,\n                           PTR_ARG,\n-                          arg.ty.span,\n+                          arg.span,\n                           \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n                            Consider changing the type to `&str`\");\n             }"}, {"sha": "a16fe7ae009119acf847587112d696c348fde8a9", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -4,7 +4,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n use rustc::ty;\n use syntax::codemap::Span;\n-use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n+use utils::{higher, in_external_macro, snippet, span_lint_and_then, iter_input_pats};\n \n /// **What it does:** Checks for bindings that shadow other bindings already in\n /// scope, while just changing reference level or mutability.\n@@ -85,25 +85,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         cx: &LateContext<'a, 'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        expr: &'tcx Expr,\n+        body: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n-        if in_external_macro(cx, expr.span) {\n+        if in_external_macro(cx, body.value.span) {\n             return;\n         }\n-        check_fn(cx, decl, expr);\n+        check_fn(cx, decl, body);\n     }\n }\n \n-fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n+fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, body: &'tcx Body) {\n     let mut bindings = Vec::new();\n-    for arg in &decl.inputs {\n+    for arg in iter_input_pats(decl, body) {\n         if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n-    check_expr(cx, expr, &mut bindings);\n+    check_expr(cx, &body.value, &mut bindings);\n }\n \n fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n@@ -341,9 +341,9 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n     match ty.node {\n         TyObjectSum(ref sty, _) |\n         TySlice(ref sty) => check_ty(cx, sty, bindings),\n-        TyArray(ref fty, ref expr) => {\n+        TyArray(ref fty, body_id) => {\n             check_ty(cx, fty, bindings);\n-            check_expr(cx, expr, bindings);\n+            check_expr(cx, &cx.tcx.map.body(body_id).value, bindings);\n         },\n         TyPtr(MutTy { ty: ref mty, .. }) |\n         TyRptr(_, MutTy { ty: ref mty, .. }) => check_ty(cx, mty, bindings),\n@@ -352,7 +352,7 @@ fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut V\n                 check_ty(cx, t, bindings)\n             }\n         },\n-        TyTypeof(ref expr) => check_expr(cx, expr, bindings),\n+        TyTypeof(body_id) => check_expr(cx, &cx.tcx.map.body(body_id).value, bindings),\n         _ => (),\n     }\n }\n@@ -371,7 +371,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n }\n \n fn path_eq_name(name: Name, path: &Path) -> bool {\n-    !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n+    !path.is_global() && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n struct ContainsSelf<'a, 'tcx: 'a> {"}, {"sha": "ae320db63bcd308c5ffd4abcac905b4798a2c3dc", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 36, "deletions": 30, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -70,7 +70,7 @@ impl LintPass for TypePass {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, id: NodeId) {\n+    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Body, _: Span, id: NodeId) {\n         // skip trait implementations, see #605\n         if let Some(map::NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent(id)) {\n             if let ItemImpl(_, _, _, Some(..), _, _) = item.node {\n@@ -87,17 +87,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n         match item.node {\n-            ConstTraitItem(ref ty, _) |\n-            TypeTraitItem(_, Some(ref ty)) => check_ty(cx, ty),\n-            MethodTraitItem(ref sig, _) => check_fn_decl(cx, &sig.decl),\n+            TraitItemKind::Const(ref ty, _) |\n+            TraitItemKind::Type(_, Some(ref ty)) => check_ty(cx, ty),\n+            TraitItemKind::Method(ref sig, _) => check_fn_decl(cx, &sig.decl),\n             _ => (),\n         }\n     }\n }\n \n fn check_fn_decl(cx: &LateContext, decl: &FnDecl) {\n     for input in &decl.inputs {\n-        check_ty(cx, &input.ty);\n+        check_ty(cx, input);\n     }\n \n     if let FunctionRetTy::Return(ref ty) = decl.output {\n@@ -326,7 +326,7 @@ declare_lint! {\n /// **Example:**\n /// ```rust\n /// let y: i8 = -1;\n-/// y as u64  // will return 18446744073709551615\n+/// y as u128  // will return 18446744073709551615\n /// ```\n declare_lint! {\n     pub CAST_SIGN_LOSS,\n@@ -601,7 +601,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n         cx: &LateContext<'a, 'tcx>,\n         _: FnKind<'tcx>,\n         decl: &'tcx FnDecl,\n-        _: &'tcx Expr,\n+        _: &'tcx Body,\n         _: Span,\n         _: NodeId\n     ) {\n@@ -624,9 +624,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         match item.node {\n-            ConstTraitItem(ref ty, _) |\n-            TypeTraitItem(_, Some(ref ty)) => self.check_type(cx, ty),\n-            MethodTraitItem(MethodSig { ref decl, .. }, None) => self.check_fndecl(cx, decl),\n+            TraitItemKind::Const(ref ty, _) |\n+            TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n+            TraitItemKind::Method(MethodSig { ref decl, .. }, TraitMethod::Required(_)) => self.check_fndecl(cx, decl),\n             // methods with default impl are covered by check_fn\n             _ => (),\n         }\n@@ -651,7 +651,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n impl<'a, 'tcx> TypeComplexityPass {\n     fn check_fndecl(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl) {\n         for arg in &decl.inputs {\n-            self.check_type(cx, &arg.ty);\n+            self.check_type(cx, arg);\n         }\n         if let Return(ref ty) = decl.output {\n             self.check_type(cx, ty);\n@@ -889,12 +889,14 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MIN))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MIN))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MIN))) |\n+        (&ty::TyInt(IntTy::I128), Integral(I128(::std::i128::MIN))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MIN)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MIN)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MIN))) |\n         (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MIN))) |\n         (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MIN))) |\n-        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) => Minimum,\n+        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MIN))) |\n+        (&ty::TyUint(UintTy::U128), Integral(U128(::std::u128::MIN))) => Minimum,\n \n         (&ty::TyBool, Bool(true)) |\n         (&ty::TyInt(IntTy::Is), Integral(Isize(Is32(::std::i32::MAX)))) |\n@@ -903,12 +905,14 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n         (&ty::TyInt(IntTy::I16), Integral(I16(::std::i16::MAX))) |\n         (&ty::TyInt(IntTy::I32), Integral(I32(::std::i32::MAX))) |\n         (&ty::TyInt(IntTy::I64), Integral(I64(::std::i64::MAX))) |\n+        (&ty::TyInt(IntTy::I128), Integral(I128(::std::i128::MAX))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us32(::std::u32::MAX)))) |\n         (&ty::TyUint(UintTy::Us), Integral(Usize(Us64(::std::u64::MAX)))) |\n         (&ty::TyUint(UintTy::U8), Integral(U8(::std::u8::MAX))) |\n         (&ty::TyUint(UintTy::U16), Integral(U16(::std::u16::MAX))) |\n         (&ty::TyUint(UintTy::U32), Integral(U32(::std::u32::MAX))) |\n-        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MAX))) => Maximum,\n+        (&ty::TyUint(UintTy::U64), Integral(U64(::std::u64::MAX))) |\n+        (&ty::TyUint(UintTy::U128), Integral(U128(::std::u128::MAX))) => Maximum,\n \n         _ => return None,\n     };\n@@ -985,19 +989,19 @@ impl LintPass for InvalidUpcastComparisons {\n \n #[derive(Copy, Clone, Debug, Eq)]\n enum FullInt {\n-    S(i64),\n-    U(u64),\n+    S(i128),\n+    U(u128),\n }\n \n impl FullInt {\n     #[allow(cast_sign_loss)]\n-    fn cmp_s_u(s: i64, u: u64) -> Ordering {\n+    fn cmp_s_u(s: i128, u: u128) -> Ordering {\n         if s < 0 {\n             Ordering::Less\n-        } else if u > (i64::max_value() as u64) {\n+        } else if u > (i128::max_value() as u128) {\n             Ordering::Greater\n         } else {\n-            (s as u64).cmp(&u)\n+            (s as u128).cmp(&u)\n         }\n     }\n }\n@@ -1034,20 +1038,22 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(\n         match cx.tcx.tables().expr_ty(cast_exp).sty {\n             TyInt(int_ty) => {\n                 Some(match int_ty {\n-                    IntTy::I8 => (FullInt::S(i8::min_value() as i64), FullInt::S(i8::max_value() as i64)),\n-                    IntTy::I16 => (FullInt::S(i16::min_value() as i64), FullInt::S(i16::max_value() as i64)),\n-                    IntTy::I32 => (FullInt::S(i32::min_value() as i64), FullInt::S(i32::max_value() as i64)),\n-                    IntTy::I64 => (FullInt::S(i64::min_value() as i64), FullInt::S(i64::max_value() as i64)),\n-                    IntTy::Is => (FullInt::S(isize::min_value() as i64), FullInt::S(isize::max_value() as i64)),\n+                    IntTy::I8 => (FullInt::S(i8::min_value() as i128), FullInt::S(i8::max_value() as i128)),\n+                    IntTy::I16 => (FullInt::S(i16::min_value() as i128), FullInt::S(i16::max_value() as i128)),\n+                    IntTy::I32 => (FullInt::S(i32::min_value() as i128), FullInt::S(i32::max_value() as i128)),\n+                    IntTy::I64 => (FullInt::S(i64::min_value() as i128), FullInt::S(i64::max_value() as i128)),\n+                    IntTy::I128 => (FullInt::S(i128::min_value() as i128), FullInt::S(i128::max_value() as i128)),\n+                    IntTy::Is => (FullInt::S(isize::min_value() as i128), FullInt::S(isize::max_value() as i128)),\n                 })\n             },\n             TyUint(uint_ty) => {\n                 Some(match uint_ty {\n-                    UintTy::U8 => (FullInt::U(u8::min_value() as u64), FullInt::U(u8::max_value() as u64)),\n-                    UintTy::U16 => (FullInt::U(u16::min_value() as u64), FullInt::U(u16::max_value() as u64)),\n-                    UintTy::U32 => (FullInt::U(u32::min_value() as u64), FullInt::U(u32::max_value() as u64)),\n-                    UintTy::U64 => (FullInt::U(u64::min_value() as u64), FullInt::U(u64::max_value() as u64)),\n-                    UintTy::Us => (FullInt::U(usize::min_value() as u64), FullInt::U(usize::max_value() as u64)),\n+                    UintTy::U8 => (FullInt::U(u8::min_value() as u128), FullInt::U(u8::max_value() as u128)),\n+                    UintTy::U16 => (FullInt::U(u16::min_value() as u128), FullInt::U(u16::max_value() as u128)),\n+                    UintTy::U32 => (FullInt::U(u32::min_value() as u128), FullInt::U(u32::max_value() as u128)),\n+                    UintTy::U64 => (FullInt::U(u64::min_value() as u128), FullInt::U(u64::max_value() as u128)),\n+                    UintTy::U128 => (FullInt::U(u128::min_value() as u128), FullInt::U(u128::max_value() as u128)),\n+                    UintTy::Us => (FullInt::U(usize::min_value() as u128), FullInt::U(usize::max_value() as u128)),\n                 })\n             },\n             _ => None,\n@@ -1067,8 +1073,8 @@ fn node_as_const_fullint(cx: &LateContext, expr: &Expr) -> Option<FullInt> {\n         Ok(val) => {\n             if let Integral(const_int) = val {\n                 Some(match const_int.erase_type() {\n-                    ConstInt::InferSigned(x) => FullInt::S(x as i64),\n-                    ConstInt::Infer(x) => FullInt::U(x as u64),\n+                    ConstInt::InferSigned(x) => FullInt::S(x as i128),\n+                    ConstInt::Infer(x) => FullInt::U(x as u128),\n                     _ => unreachable!(),\n                 })\n             } else {"}, {"sha": "5136a821c546f549fb854375f9b1a88b4ee8ac2f", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -46,7 +46,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n         cx: &LateContext<'a, 'tcx>,\n         kind: FnKind<'tcx>,\n         decl: &'tcx hir::FnDecl,\n-        body: &'tcx hir::Expr,\n+        body: &'tcx hir::Body,\n         span: Span,\n         fn_id: ast::NodeId\n     ) {\n@@ -58,7 +58,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n             cx: cx,\n             labels: HashMap::new(),\n         };\n-        walk_fn(&mut v, kind, decl, body.expr_id(), span, fn_id);\n+        walk_fn(&mut v, kind, decl, body.id(), span, fn_id);\n \n         for (label, span) in v.labels {\n             span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));"}, {"sha": "e330a662f97d5c025f301f5ef4d778aa92ad50a8", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -112,7 +112,10 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 !self.ignore_fn && l_name.node == r_name.node && over(l_tys, r_tys, |l, r| self.eq_ty(l, r)) &&\n                 self.eq_exprs(l_args, r_args)\n             },\n-            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n+            (&ExprRepeat(ref le, ll_id), &ExprRepeat(ref re, rl_id)) => {\n+                self.eq_expr(le, re) &&\n+                self.eq_expr(&self.cx.tcx.map.body(ll_id).value, &self.cx.tcx.map.body(rl_id).value)\n+            },\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n             (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n@@ -183,7 +186,8 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n-        left.global == right.global && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        left.is_global() == right.is_global() &&\n+        over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n     }\n \n     fn eq_path_parameters(&self, left: &PathParameters, right: &PathParameters) -> bool {\n@@ -211,7 +215,10 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n-            (&TyArray(ref lt, ref ll), &TyArray(ref rt, ref rl)) => self.eq_ty(lt, rt) && self.eq_expr(ll, rl),\n+            (&TyArray(ref lt, ll_id), &TyArray(ref rt, rl_id)) => {\n+                self.eq_ty(lt, rt) &&\n+                self.eq_expr(&self.cx.tcx.map.body(ll_id).value, &self.cx.tcx.map.body(rl_id).value)\n+            },\n             (&TyPtr(ref l_mut), &TyPtr(ref r_mut)) => l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty),\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n@@ -363,7 +370,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_expr(self.cx.tcx.map.expr(eid));\n+                self.hash_expr(&self.cx.tcx.map.body(eid).value);\n             },\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;\n@@ -424,11 +431,11 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_name(&name.node);\n                 self.hash_exprs(args);\n             },\n-            ExprRepeat(ref e, ref l) => {\n+            ExprRepeat(ref e, l_id) => {\n                 let c: fn(_, _) -> _ = ExprRepeat;\n                 c.hash(&mut self.s);\n                 self.hash_expr(e);\n-                self.hash_expr(l);\n+                self.hash_expr(&self.cx.tcx.map.body(l_id).value);\n             },\n             ExprRet(ref e) => {\n                 let c: fn(_) -> _ = ExprRet;\n@@ -524,7 +531,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n     }\n \n     pub fn hash_path(&mut self, p: &Path) {\n-        p.global.hash(&mut self.s);\n+        p.is_global().hash(&mut self.s);\n         for p in &p.segments {\n             self.hash_name(&p.name);\n         }"}, {"sha": "457008eb0ef2fbb6174ab6c842055ebcf78cf346", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -4,6 +4,7 @@\n \n use rustc::lint::*;\n use rustc::hir;\n+use rustc::hir::print;\n use syntax::ast::Attribute;\n use syntax::attr;\n \n@@ -52,16 +53,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         match item.vis {\n             hir::Visibility::Public => println!(\"public\"),\n             hir::Visibility::Crate => println!(\"visible crate wide\"),\n-            hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+            hir::Visibility::Restricted { ref path, .. } => {\n+                println!(\"visible in module `{}`\",\n+                         print::to_string(print::NO_ANN, |s| s.print_path(path, false)))\n+            },\n             hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n         }\n         if item.defaultness.is_default() {\n             println!(\"default\");\n         }\n         match item.node {\n-            hir::ImplItemKind::Const(_, ref e) => {\n+            hir::ImplItemKind::Const(_, body_id) => {\n                 println!(\"associated constant\");\n-                print_expr(cx, e, 1);\n+                print_expr(cx, &cx.tcx.map.body(body_id).value, 1);\n             },\n             hir::ImplItemKind::Method(..) => println!(\"method\"),\n             hir::ImplItemKind::Type(_) => println!(\"associated type\"),\n@@ -323,12 +327,12 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n                 print_expr(cx, base, indent + 1);\n             }\n         },\n-        hir::ExprRepeat(ref val, ref n) => {\n+        hir::ExprRepeat(ref val, body_id) => {\n             println!(\"{}Repeat, {}\", ind, ty);\n             println!(\"{}value:\", ind);\n             print_expr(cx, val, indent + 1);\n             println!(\"{}repeat count:\", ind);\n-            print_expr(cx, n, indent + 1);\n+            print_expr(cx, &cx.tcx.map.body(body_id).value, indent + 1);\n         },\n     }\n }\n@@ -339,7 +343,10 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n     match item.vis {\n         hir::Visibility::Public => println!(\"public\"),\n         hir::Visibility::Crate => println!(\"visible crate wide\"),\n-        hir::Visibility::Restricted { ref path, .. } => println!(\"visible in module `{}`\", path),\n+        hir::Visibility::Restricted { ref path, .. } => {\n+            println!(\"visible in module `{}`\",\n+                     print::to_string(print::NO_ANN, |s| s.print_path(path, false)))\n+        },\n         hir::Visibility::Inherited => println!(\"visibility inherited from outer item\"),\n     }\n     match item.node {\n@@ -413,7 +420,9 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::Struct(ref path, ref fields, ignore) => {\n             println!(\"{}Struct\", ind);\n-            println!(\"{}name: {}\", ind, path);\n+            println!(\"{}name: {}\",\n+                     ind,\n+                     print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n             println!(\"{}ignore leftover fields: {}\", ind, ignore);\n             println!(\"{}fields:\", ind);\n             for field in fields {\n@@ -426,7 +435,9 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n         },\n         hir::PatKind::TupleStruct(ref path, ref fields, opt_dots_position) => {\n             println!(\"{}TupleStruct\", ind);\n-            println!(\"{}path: {}\", ind, path);\n+            println!(\"{}path: {}\",\n+                     ind,\n+                     print::to_string(print::NO_ANN, |s| s.print_qpath(path, false)));\n             if let Some(dot_position) = opt_dots_position {\n                 println!(\"{}dot position: {}\", ind, dot_position);\n             }"}, {"sha": "ea7a654ed1f7d0eb7b4c72290699b7359e8e3b21", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -106,15 +106,15 @@ impl LintPass for LintWithoutLintPass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n+        if let ItemStatic(ref ty, MutImmutable, body_id) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n                 let mut collector = LintCollector {\n                     output: &mut self.registered_lints,\n                     cx: cx,\n                 };\n-                collector.visit_expr(expr);\n+                collector.visit_expr(&cx.tcx.map.body(body_id).value);\n             }\n         }\n     }"}, {"sha": "f971779b2edb3e8fe53427b662e8f93f498ba200", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3baa435b705f1e4c8b5233208320c9907c796b46/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=3baa435b705f1e4c8b5233208320c9907c796b46", "patch": "@@ -19,6 +19,7 @@ use syntax::attr;\n use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span, DUMMY_SP};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n+use syntax::symbol::keywords;\n \n pub mod cargo;\n pub mod comparisons;\n@@ -487,7 +488,7 @@ pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeI\n         match node {\n             Node::NodeBlock(block) => Some(block),\n             Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n-                match cx.tcx.map.expr(eid).node {\n+                match cx.tcx.map.body(eid).value.node {\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n@@ -610,7 +611,7 @@ pub fn walk_ptrs_ty_depth(ty: ty::Ty) -> (ty::Ty, usize) {\n }\n \n /// Check whether the given expression is a constant literal of the given value.\n-pub fn is_integer_literal(expr: &Expr, value: u64) -> bool {\n+pub fn is_integer_literal(expr: &Expr, value: u128) -> bool {\n     // FIXME: use constant folding\n     if let ExprLit(ref spanned) = expr.node {\n         if let LitKind::Int(v, _) = spanned.node {\n@@ -896,3 +897,26 @@ pub fn opt_def_id(def: Def) -> Option<DefId> {\n         Def::Label(..) | Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => None,\n     }\n }\n+\n+pub fn is_self(slf: &Arg) -> bool {\n+    if let PatKind::Binding(_, _, name, _) = slf.pat.node {\n+        name.node == keywords::SelfValue.name()\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_self_ty(slf: &Ty) -> bool {\n+    if_let_chain! {[\n+        let TyPath(ref qp) = slf.node,\n+        let QPath::Resolved(None, ref path) = *qp,\n+        let Def::SelfTy(..) = path.def,\n+    ], {\n+        return true\n+    }}\n+    false\n+}\n+\n+pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<Item = &'tcx Arg> {\n+    (0..decl.inputs.len()).map(move |i| &body.arguments[i])\n+}"}]}