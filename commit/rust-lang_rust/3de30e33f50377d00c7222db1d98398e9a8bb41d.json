{"sha": "3de30e33f50377d00c7222db1d98398e9a8bb41d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkZTMwZTMzZjUwMzc3ZDAwYzcyMjJkYjFkOTgzOThlOWE4YmI0MWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T09:34:56Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-06-08T09:34:56Z"}, "message": "no more function pointers", "tree": {"sha": "7dcee72166425c3ae61013a7f171a255b6dacf00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7dcee72166425c3ae61013a7f171a255b6dacf00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3de30e33f50377d00c7222db1d98398e9a8bb41d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXV+bAAAoJEFbW7qD8Z6xG2s8P/iVU4D320nJ5wM2MmnIjVOQc\n83+eHQqAun6v6tdZN8fVCCB50JhkX5rBWSu8Ot3TkH/GMCM4Nsn/V3HFcPm0kN6w\nGUrYurnQcWUO8bDb2hZjDAZm2zQrc33uk+B+1iv2qsG1Hg842MeN5mLps5AXzg5j\n4i/hrmmO7NLTO/qzp7JGcjSOQtZsgzEWZ7Z5vC8rTEzvkqRXw0vFliUKM/o0MSJp\nuhzWrynlb5lrx/SHdRwYhQrRq3tieH8DJzHNmHfKIummJ8wjlY9zuCBzqzm8R9Av\neB14ePszv71eB1Xa28o8b2dv5upz+tQu7THMOgJZhazCeiJSqSWrX9JtO+S0dtOJ\ngq71lQ210FOfUcofBg9dXAT2FJcI8e2I2phVJRJKc2S44xY6nfWtnmYYsahJli9v\nQoHcsMlzVtpzGUO7Sy01LFp0i9EOkq/0elRCDlFWnQTu+AW8cZ57b7lh9IfRJKW8\nnw6kThrqWQI3GYJrudYCi4alBbEKxloYQYcie5g88IFn3Anrjf3+tEnr5cPJPBgk\nH3VywOqiuwjEr879UnsvPvB1MTAAXG8OCZl3HpnL99m7/15TCSwd6Y7Xjggs2MSN\ngbh2RisqTwv6znfgIpG69UGN4hXtkHh9COjiiHSE8drtweLAWK12+280ZSHrDoHL\nzhJeF6hkjOGTpslR8o4u\n=N/+K\n-----END PGP SIGNATURE-----", "payload": "tree 7dcee72166425c3ae61013a7f171a255b6dacf00\nparent 8b25bc8a9a709c516d986193bce7a74ed1861bcc\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465378496 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1465378496 +0200\n\nno more function pointers"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3de30e33f50377d00c7222db1d98398e9a8bb41d", "html_url": "https://github.com/rust-lang/rust/commit/3de30e33f50377d00c7222db1d98398e9a8bb41d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3de30e33f50377d00c7222db1d98398e9a8bb41d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b25bc8a9a709c516d986193bce7a74ed1861bcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b25bc8a9a709c516d986193bce7a74ed1861bcc", "html_url": "https://github.com/rust-lang/rust/commit/8b25bc8a9a709c516d986193bce7a74ed1861bcc"}], "stats": {"total": 90, "additions": 34, "deletions": 56}, "files": [{"sha": "896c740d8007ae063b891d4425fe5eebcd8c18af", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/3de30e33f50377d00c7222db1d98398e9a8bb41d/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de30e33f50377d00c7222db1d98398e9a8bb41d/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=3de30e33f50377d00c7222db1d98398e9a8bb41d", "patch": "@@ -400,22 +400,18 @@ impl<'a, 'b, 'mir, 'tcx> FnEvalContext<'a, 'b, 'mir, 'tcx> {\n \n     fn run(&mut self) -> EvalResult<()> {\n         let mut stepper = stepper::Stepper::new(self);\n-        'outer: loop {\n+        let mut done = false;\n+        while !done {\n             use self::stepper::Event::*;\n-            trace!(\"// {:?}\", stepper.block());\n-\n-            loop {\n-                match stepper.step()? {\n-                    Constant => trace!(\"computing a constant\"),\n-                    Assignment => trace!(\"{:?}\", stepper.stmt()),\n-                    Terminator => {\n-                        trace!(\"{:?}\", stepper.term().kind);\n-                        continue 'outer;\n-                    },\n-                    Done => return Ok(()),\n-                }\n-            }\n+            stepper.step(|event| match event {\n+                Block(b) => trace!(\"// {:?}\", b),\n+                Assignment(a) => trace!(\"{:?}\", a),\n+                Terminator(t) => trace!(\"{:?}\", t.kind),\n+                Done => done = true,\n+                _ => {},\n+            })?;\n         }\n+        Ok(())\n     }\n \n     fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'mir, 'tcx>, substs: &'tcx Substs<'tcx>,"}, {"sha": "d6677c8c319becc5aa3f4424a0fc50b01c5afaf4", "filename": "src/interpreter/stepper.rs", "status": "modified", "additions": 24, "deletions": 42, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/3de30e33f50377d00c7222db1d98398e9a8bb41d/src%2Finterpreter%2Fstepper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3de30e33f50377d00c7222db1d98398e9a8bb41d/src%2Finterpreter%2Fstepper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstepper.rs?ref=3de30e33f50377d00c7222db1d98398e9a8bb41d", "patch": "@@ -14,16 +14,18 @@ use syntax::codemap::Span;\n use std::rc::Rc;\n use memory::Pointer;\n \n-pub enum Event {\n+pub enum Event<'a, 'tcx: 'a> {\n+    Block(mir::BasicBlock),\n+    Return,\n+    Call,\n     Constant,\n-    Assignment,\n-    Terminator,\n+    Assignment(&'a mir::Statement<'tcx>),\n+    Terminator(&'a mir::Terminator<'tcx>),\n     Done,\n }\n \n pub struct Stepper<'fncx, 'a: 'fncx, 'b: 'a + 'mir, 'mir: 'fncx, 'tcx: 'b>{\n     fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>,\n-    process: fn (&mut Stepper<'fncx, 'a, 'b, 'mir, 'tcx>) -> EvalResult<()>,\n \n     // a cache of the constants to be computed before the next statement/terminator\n     // this is an optimization, so we don't have to allocate a new vector for every statement\n@@ -34,51 +36,49 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n     pub(super) fn new(fncx: &'fncx mut FnEvalContext<'a, 'b, 'mir, 'tcx>) -> Self {\n         Stepper {\n             fncx: fncx,\n-            process: Self::dummy,\n             constants: Vec::new(),\n         }\n     }\n \n-    fn dummy(&mut self) -> EvalResult<()> { Ok(()) }\n-\n-    fn statement(&mut self) -> EvalResult<()> {\n+    fn statement<F: for<'f> FnMut(Event<'f, 'tcx>)>(&mut self, mut f: F) -> EvalResult<()> {\n         let mir = self.fncx.mir();\n         let block_data = mir.basic_block_data(self.fncx.frame().next_block);\n         let stmt = &block_data.statements[self.fncx.frame().stmt];\n+        f(Event::Assignment(stmt));\n         let mir::StatementKind::Assign(ref lvalue, ref rvalue) = stmt.kind;\n         let result = self.fncx.eval_assignment(lvalue, rvalue);\n         self.fncx.maybe_report(result)?;\n         self.fncx.frame_mut().stmt += 1;\n         Ok(())\n     }\n \n-    fn terminator(&mut self) -> EvalResult<()> {\n+    fn terminator<F: for<'f> FnMut(Event<'f, 'tcx>)>(&mut self, mut f: F) -> EvalResult<()> {\n         // after a terminator we go to a new block\n         self.fncx.frame_mut().stmt = 0;\n         let term = {\n             let mir = self.fncx.mir();\n             let block_data = mir.basic_block_data(self.fncx.frame().next_block);\n             let terminator = block_data.terminator();\n+            f(Event::Terminator(terminator));\n             let result = self.fncx.eval_terminator(terminator);\n             self.fncx.maybe_report(result)?\n         };\n         match term {\n-            TerminatorTarget::Block => {},\n+            TerminatorTarget::Block => f(Event::Block(self.fncx.frame().next_block)),\n             TerminatorTarget::Return => {\n+                f(Event::Return);\n                 self.fncx.pop_stack_frame();\n             },\n-            TerminatorTarget::Call => {},\n+            TerminatorTarget::Call => f(Event::Call),\n         }\n         Ok(())\n     }\n \n-    pub fn step(&mut self) -> EvalResult<Event> {\n-        (self.process)(self)?;\n-\n+    // returns true as long as there are more things to do\n+    pub fn step<F: for<'f> FnMut(Event<'f, 'tcx>)>(&mut self, mut f: F) -> EvalResult<()> {\n         if self.fncx.stack.is_empty() {\n-            // fuse the iterator\n-            self.process = Self::dummy;\n-            return Ok(Event::Done);\n+            f(Event::Done);\n+            return Ok(());\n         }\n \n         let block = self.fncx.frame().next_block;\n@@ -97,12 +97,9 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n                 mir: &mir,\n             }.visit_statement(block, stmt);\n             if self.constants.is_empty() {\n-                self.process = Self::statement;\n-                return Ok(Event::Assignment);\n+                return self.statement(f);\n             } else {\n-                self.process = Self::statement;\n-                self.extract_constants();\n-                return Ok(Event::Constant);\n+                return self.extract_constants(f);\n             }\n         }\n \n@@ -117,36 +114,21 @@ impl<'fncx, 'a, 'b: 'a + 'mir, 'mir, 'tcx: 'b> Stepper<'fncx, 'a, 'b, 'mir, 'tcx\n             mir: &mir,\n         }.visit_terminator(block, terminator);\n         if self.constants.is_empty() {\n-            self.process = Self::terminator;\n-            Ok(Event::Terminator)\n+            self.terminator(f)\n         } else {\n-            self.process = Self::statement;\n-            self.extract_constants();\n-            Ok(Event::Constant)\n+            self.extract_constants(f)\n         }\n     }\n \n-    fn extract_constants(&mut self) {\n+    fn extract_constants<F: for<'f> FnMut(Event<'f, 'tcx>)>(&mut self, mut f: F) -> EvalResult<()> {\n         assert!(!self.constants.is_empty());\n         for (cid, span, return_ptr, mir) in self.constants.drain(..) {\n             let def_id = cid.def_id();\n             let substs = cid.substs();\n+            f(Event::Constant);\n             self.fncx.push_stack_frame(def_id, span, mir, substs, Some(return_ptr));\n         }\n-    }\n-\n-    /// returns the statement that will be processed next\n-    pub fn stmt(&self) -> &mir::Statement {\n-        &self.fncx.basic_block().statements[self.fncx.frame().stmt]\n-    }\n-\n-    /// returns the terminator of the current block\n-    pub fn term(&self) -> &mir::Terminator {\n-        self.fncx.basic_block().terminator()\n-    }\n-\n-    pub fn block(&self) -> mir::BasicBlock {\n-        self.fncx.frame().next_block\n+        self.step(f)\n     }\n }\n "}]}