{"sha": "390dde571ede57133f249692ab020f83fd5d22ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5MGRkZTU3MWVkZTU3MTMzZjI0OTY5MmFiMDIwZjgzZmQ1ZDIyZWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-12T22:26:19Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-15T19:19:16Z"}, "message": "core::rt: Rename Task to Coroutine", "tree": {"sha": "b71ce5f1e5c4951dbd81b3ee9441e8a900f305a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b71ce5f1e5c4951dbd81b3ee9441e8a900f305a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/390dde571ede57133f249692ab020f83fd5d22ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/390dde571ede57133f249692ab020f83fd5d22ee", "html_url": "https://github.com/rust-lang/rust/commit/390dde571ede57133f249692ab020f83fd5d22ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/390dde571ede57133f249692ab020f83fd5d22ee/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f5746f6d2bcc048aca5ddfbfdf41497ab874836", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5746f6d2bcc048aca5ddfbfdf41497ab874836", "html_url": "https://github.com/rust-lang/rust/commit/7f5746f6d2bcc048aca5ddfbfdf41497ab874836"}], "stats": {"total": 116, "additions": 58, "deletions": 58}, "files": [{"sha": "7a772ff0f3b96adf119f6e5707ed7d1005d80dbf", "filename": "src/libcore/rt/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fmod.rs?ref=390dde571ede57133f249692ab020f83fd5d22ee", "patch": "@@ -67,7 +67,7 @@ use ptr::Ptr;\n /// The global (exchange) heap.\n pub mod global_heap;\n \n-/// The Scheduler and Task types.\n+/// The Scheduler and Coroutine types.\n mod sched;\n \n /// Thread-local access to the current Scheduler.\n@@ -138,14 +138,14 @@ pub mod tube;\n /// The return value is used as the process return code. 0 on success, 101 on error.\n pub fn start(_argc: int, _argv: **u8, crate_map: *u8, main: ~fn()) -> int {\n \n-    use self::sched::{Scheduler, Task};\n+    use self::sched::{Scheduler, Coroutine};\n     use self::uv::uvio::UvEventLoop;\n \n     init(crate_map);\n \n     let loop_ = ~UvEventLoop::new();\n     let mut sched = ~Scheduler::new(loop_);\n-    let main_task = ~Task::new(&mut sched.stack_pool, main);\n+    let main_task = ~Coroutine::new(&mut sched.stack_pool, main);\n \n     sched.enqueue_task(main_task);\n     sched.run();\n@@ -210,15 +210,15 @@ pub fn context() -> RuntimeContext {\n #[test]\n fn test_context() {\n     use unstable::run_in_bare_thread;\n-    use self::sched::{local_sched, Task};\n+    use self::sched::{local_sched, Coroutine};\n     use rt::uv::uvio::UvEventLoop;\n     use cell::Cell;\n \n     assert!(context() == OldTaskContext);\n     do run_in_bare_thread {\n         assert!(context() == GlobalContext);\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~do Task::new(&mut sched.stack_pool) {\n+        let task = ~do Coroutine::new(&mut sched.stack_pool) {\n             assert!(context() == TaskContext);\n             let sched = local_sched::take();\n             do sched.deschedule_running_task_and_then() |task| {"}, {"sha": "d92eaf89e5f3ca128e61d18f71d7009782ce94fe", "filename": "src/libcore/rt/sched.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fsched.rs?ref=390dde571ede57133f249692ab020f83fd5d22ee", "patch": "@@ -26,20 +26,20 @@ use cell::Cell;\n // A more convenient name for external callers, e.g. `local_sched::take()`\n pub mod local_sched;\n \n-/// The Scheduler is responsible for coordinating execution of Tasks\n+/// The Scheduler is responsible for coordinating execution of Coroutines\n /// on a single thread. When the scheduler is running it is owned by\n /// thread local storage and the running task is owned by the\n /// scheduler.\n pub struct Scheduler {\n-    priv work_queue: WorkQueue<~Task>,\n+    priv work_queue: WorkQueue<~Coroutine>,\n     stack_pool: StackPool,\n     /// The event loop used to drive the scheduler and perform I/O\n     event_loop: ~EventLoopObject,\n     /// The scheduler's saved context.\n     /// Always valid when a task is executing, otherwise not\n     priv saved_context: Context,\n     /// The currently executing task\n-    current_task: Option<~Task>,\n+    current_task: Option<~Coroutine>,\n     /// An action performed after a context switch on behalf of the\n     /// code running before the context switch\n     priv cleanup_job: Option<CleanupJob>\n@@ -49,17 +49,17 @@ pub struct Scheduler {\n // complaining\n type UnsafeTaskReceiver = sys::Closure;\n trait ClosureConverter {\n-    fn from_fn(&fn(~Task)) -> Self;\n-    fn to_fn(self) -> &fn(~Task);\n+    fn from_fn(&fn(~Coroutine)) -> Self;\n+    fn to_fn(self) -> &fn(~Coroutine);\n }\n impl ClosureConverter for UnsafeTaskReceiver {\n-    fn from_fn(f: &fn(~Task)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n-    fn to_fn(self) -> &fn(~Task) { unsafe { transmute(self) } }\n+    fn from_fn(f: &fn(~Coroutine)) -> UnsafeTaskReceiver { unsafe { transmute(f) } }\n+    fn to_fn(self) -> &fn(~Coroutine) { unsafe { transmute(self) } }\n }\n \n enum CleanupJob {\n     DoNothing,\n-    GiveTask(~Task, UnsafeTaskReceiver)\n+    GiveTask(~Coroutine, UnsafeTaskReceiver)\n }\n \n pub impl Scheduler {\n@@ -115,7 +115,7 @@ pub impl Scheduler {\n     /// Pushes the task onto the work stealing queue and tells the event loop\n     /// to run it later. Always use this instead of pushing to the work queue\n     /// directly.\n-    fn enqueue_task(&mut self, task: ~Task) {\n+    fn enqueue_task(&mut self, task: ~Coroutine) {\n         self.work_queue.push_front(task);\n         self.event_loop.callback(resume_task_from_queue);\n \n@@ -164,7 +164,7 @@ pub impl Scheduler {\n         abort!(\"control reached end of task\");\n     }\n \n-    fn schedule_new_task(~self, task: ~Task) {\n+    fn schedule_new_task(~self, task: ~Coroutine) {\n         assert!(self.in_task_context());\n \n         do self.switch_running_tasks_and_then(task) |last_task| {\n@@ -177,7 +177,7 @@ pub impl Scheduler {\n \n     // Core scheduling ops\n \n-    fn resume_task_immediately(~self, task: ~Task) {\n+    fn resume_task_immediately(~self, task: ~Coroutine) {\n         let mut this = self;\n         assert!(!this.in_task_context());\n \n@@ -215,15 +215,15 @@ pub impl Scheduler {\n     /// The closure here is a *stack* closure that lives in the\n     /// running task.  It gets transmuted to the scheduler's lifetime\n     /// and called while the task is blocked.\n-    fn deschedule_running_task_and_then(~self, f: &fn(~Task)) {\n+    fn deschedule_running_task_and_then(~self, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"blocking task\");\n \n         unsafe {\n             let blocked_task = this.current_task.swap_unwrap();\n-            let f_fake_region = transmute::<&fn(~Task), &fn(~Task)>(f);\n+            let f_fake_region = transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f);\n             let f_opaque = ClosureConverter::from_fn(f_fake_region);\n             this.enqueue_cleanup_job(GiveTask(blocked_task, f_opaque));\n         }\n@@ -245,14 +245,14 @@ pub impl Scheduler {\n     /// Switch directly to another task, without going through the scheduler.\n     /// You would want to think hard about doing this, e.g. if there are\n     /// pending I/O events it would be a bad idea.\n-    fn switch_running_tasks_and_then(~self, next_task: ~Task, f: &fn(~Task)) {\n+    fn switch_running_tasks_and_then(~self, next_task: ~Coroutine, f: &fn(~Coroutine)) {\n         let mut this = self;\n         assert!(this.in_task_context());\n \n         rtdebug!(\"switching tasks\");\n \n         let old_running_task = this.current_task.swap_unwrap();\n-        let f_fake_region = unsafe { transmute::<&fn(~Task), &fn(~Task)>(f) };\n+        let f_fake_region = unsafe { transmute::<&fn(~Coroutine), &fn(~Coroutine)>(f) };\n         let f_opaque = ClosureConverter::from_fn(f_fake_region);\n         this.enqueue_cleanup_job(GiveTask(old_running_task, f_opaque));\n         this.current_task = Some(next_task);\n@@ -318,7 +318,7 @@ pub impl Scheduler {\n         // because borrowck thinks the three patterns are conflicting\n         // borrows\n         unsafe {\n-            let last_task = transmute::<Option<&Task>, Option<&mut Task>>(last_task);\n+            let last_task = transmute::<Option<&Coroutine>, Option<&mut Coroutine>>(last_task);\n             let last_task_context = match last_task {\n                 Some(t) => Some(&mut t.saved_context), None => None\n             };\n@@ -333,9 +333,9 @@ pub impl Scheduler {\n     }\n }\n \n-static TASK_MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n+static MIN_STACK_SIZE: uint = 10000000; // XXX: Too much stack\n \n-pub struct Task {\n+pub struct Coroutine {\n     /// The segment of stack on which the task is currently running or,\n     /// if the task is blocked, on which the task will resume execution\n     priv current_stack_segment: StackSegment,\n@@ -346,19 +346,19 @@ pub struct Task {\n     local_services: LocalServices\n }\n \n-pub impl Task {\n-    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Task {\n-        Task::with_local(stack_pool, LocalServices::new(), start)\n+pub impl Coroutine {\n+    fn new(stack_pool: &mut StackPool, start: ~fn()) -> Coroutine {\n+        Coroutine::with_local(stack_pool, LocalServices::new(), start)\n     }\n \n     fn with_local(stack_pool: &mut StackPool,\n                   local_services: LocalServices,\n-                  start: ~fn()) -> Task {\n-        let start = Task::build_start_wrapper(start);\n-        let mut stack = stack_pool.take_segment(TASK_MIN_STACK_SIZE);\n+                  start: ~fn()) -> Coroutine {\n+        let start = Coroutine::build_start_wrapper(start);\n+        let mut stack = stack_pool.take_segment(MIN_STACK_SIZE);\n         // NB: Context holds a pointer to that ~fn\n         let initial_context = Context::new(start, &mut stack);\n-        return Task {\n+        return Coroutine {\n             current_stack_segment: stack,\n             saved_context: initial_context,\n             local_services: local_services\n@@ -390,7 +390,7 @@ pub impl Task {\n     /// Destroy the task and try to reuse its components\n     fn recycle(~self, stack_pool: &mut StackPool) {\n         match self {\n-            ~Task {current_stack_segment, _} => {\n+            ~Coroutine {current_stack_segment, _} => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }\n@@ -414,7 +414,7 @@ mod test {\n             let task_ran_ptr: *mut bool = &mut task_ran;\n \n             let mut sched = ~UvEventLoop::new_scheduler();\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *task_ran_ptr = true; }\n             };\n             sched.enqueue_task(task);\n@@ -432,7 +432,7 @@ mod test {\n \n             let mut sched = ~UvEventLoop::new_scheduler();\n             for int::range(0, total) |_| {\n-                let task = ~do Task::new(&mut sched.stack_pool) {\n+                let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                     unsafe { *task_count_ptr = *task_count_ptr + 1; }\n                 };\n                 sched.enqueue_task(task);\n@@ -449,10 +449,10 @@ mod test {\n             let count_ptr: *mut int = &mut count;\n \n             let mut sched = ~UvEventLoop::new_scheduler();\n-            let task1 = ~do Task::new(&mut sched.stack_pool) {\n+            let task1 = ~do Coroutine::new(&mut sched.stack_pool) {\n                 unsafe { *count_ptr = *count_ptr + 1; }\n                 let mut sched = local_sched::take();\n-                let task2 = ~do Task::new(&mut sched.stack_pool) {\n+                let task2 = ~do Coroutine::new(&mut sched.stack_pool) {\n                     unsafe { *count_ptr = *count_ptr + 1; }\n                 };\n                 // Context switch directly to the new task\n@@ -479,7 +479,7 @@ mod test {\n \n             let mut sched = ~UvEventLoop::new_scheduler();\n \n-            let start_task = ~do Task::new(&mut sched.stack_pool) {\n+            let start_task = ~do Coroutine::new(&mut sched.stack_pool) {\n                 run_task(count_ptr);\n             };\n             sched.enqueue_task(start_task);\n@@ -489,7 +489,7 @@ mod test {\n \n             fn run_task(count_ptr: *mut int) {\n                 do local_sched::borrow |sched| {\n-                    let task = ~do Task::new(&mut sched.stack_pool) {\n+                    let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                         unsafe {\n                             *count_ptr = *count_ptr + 1;\n                             if *count_ptr != MAX {\n@@ -507,7 +507,7 @@ mod test {\n     fn test_block_task() {\n         do run_in_bare_thread {\n             let mut sched = ~UvEventLoop::new_scheduler();\n-            let task = ~do Task::new(&mut sched.stack_pool) {\n+            let task = ~do Coroutine::new(&mut sched.stack_pool) {\n                 let sched = local_sched::take();\n                 assert!(sched.in_task_context());\n                 do sched.deschedule_running_task_and_then() |task| {"}, {"sha": "1294b9bcf476573add0d39d15c97f30184f6e7b1", "filename": "src/libcore/rt/test.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftest.rs?ref=390dde571ede57133f249692ab020f83fd5d22ee", "patch": "@@ -18,16 +18,16 @@ use rt::local_services::LocalServices;\n /// will abort the process.\n pub fn run_in_newsched_task(f: ~fn()) {\n     use unstable::run_in_bare_thread;\n-    use super::sched::Task;\n+    use super::sched::Coroutine;\n     use rt::uv::uvio::UvEventLoop;\n \n     let f = Cell(f);\n \n     do run_in_bare_thread {\n         let mut sched = ~UvEventLoop::new_scheduler();\n-        let task = ~Task::with_local(&mut sched.stack_pool,\n-                                     LocalServices::without_unwinding(),\n-                                     f.take());\n+        let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                          LocalServices::without_unwinding(),\n+                                          f.take());\n         sched.enqueue_task(task);\n         sched.run();\n     }\n@@ -38,9 +38,9 @@ pub fn spawntask(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         let sched = local_sched::take();\n@@ -53,9 +53,9 @@ pub fn spawntask_immediately(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n     do sched.switch_running_tasks_and_then(task) |task| {\n         let task = Cell(task);\n         do local_sched::borrow |sched| {\n@@ -69,9 +69,9 @@ pub fn spawntask_later(f: ~fn()) {\n     use super::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n \n     sched.enqueue_task(task);\n     local_sched::put(sched);\n@@ -86,9 +86,9 @@ pub fn spawntask_random(f: ~fn()) {\n     let run_now: bool = Rand::rand(&mut rng);\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::with_local(&mut sched.stack_pool,\n-                                 LocalServices::without_unwinding(),\n-                                 f);\n+    let task = ~Coroutine::with_local(&mut sched.stack_pool,\n+                                      LocalServices::without_unwinding(),\n+                                      f);\n \n     if run_now {\n         do sched.switch_running_tasks_and_then(task) |task| {\n@@ -122,7 +122,7 @@ pub fn spawntask_try(f: ~fn()) -> Result<(), ()> {\n         let old_task = Cell(old_task);\n         let f = f.take();\n         let mut sched = local_sched::take();\n-        let new_task = ~do Task::new(&mut sched.stack_pool) {\n+        let new_task = ~do Coroutine::new(&mut sched.stack_pool) {\n             do (|| {\n                 (f.take())()\n             }).finally {"}, {"sha": "bc9269f08faa938a268d66d0d7e587280bf46f55", "filename": "src/libcore/rt/tube.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Ftube.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Frt%2Ftube.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Ftube.rs?ref=390dde571ede57133f249692ab020f83fd5d22ee", "patch": "@@ -16,14 +16,14 @@\n use option::*;\n use clone::Clone;\n use super::rc::RC;\n-use rt::sched::Task;\n+use rt::sched::Coroutine;\n use rt::{context, TaskContext, SchedulerContext};\n use rt::local_sched;\n use vec::OwnedVector;\n use container::Container;\n \n struct TubeState<T> {\n-    blocked_task: Option<~Task>,\n+    blocked_task: Option<~Coroutine>,\n     buf: ~[T]\n }\n "}, {"sha": "5f9642604d0c14c761c9310d101d1f55eb859a2f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/390dde571ede57133f249692ab020f83fd5d22ee/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=390dde571ede57133f249692ab020f83fd5d22ee", "patch": "@@ -581,7 +581,7 @@ fn spawn_raw_newsched(_opts: TaskOpts, f: ~fn()) {\n     use rt::sched::*;\n \n     let mut sched = local_sched::take();\n-    let task = ~Task::new(&mut sched.stack_pool, f);\n+    let task = ~Coroutine::new(&mut sched.stack_pool, f);\n     sched.schedule_new_task(task);\n }\n "}]}