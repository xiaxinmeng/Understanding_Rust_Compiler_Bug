{"sha": "7ccfe2ff1d59666dc0188dfd5847304fec257565", "node_id": "C_kwDOAAsO6NoAKDdjY2ZlMmZmMWQ1OTY2NmRjMDE4OGRmZDU4NDczMDRmZWMyNTc1NjU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T10:02:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T10:02:26Z"}, "message": "Auto merge of #94129 - cjgillot:rmeta-table, r=petrochenkov\n\nBack more metadata using per-query tables\n\nr? `@ghost`", "tree": {"sha": "48ab85a723d1398aa894f6fe89e88d01986b8f57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48ab85a723d1398aa894f6fe89e88d01986b8f57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ccfe2ff1d59666dc0188dfd5847304fec257565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ccfe2ff1d59666dc0188dfd5847304fec257565", "html_url": "https://github.com/rust-lang/rust/commit/7ccfe2ff1d59666dc0188dfd5847304fec257565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ccfe2ff1d59666dc0188dfd5847304fec257565/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1204400ab8da9830f6f77a5e40e7ad3ea459676a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1204400ab8da9830f6f77a5e40e7ad3ea459676a", "html_url": "https://github.com/rust-lang/rust/commit/1204400ab8da9830f6f77a5e40e7ad3ea459676a"}, {"sha": "7afcf9fcd14af52e53e38ffe60b1eac9b3232b21", "url": "https://api.github.com/repos/rust-lang/rust/commits/7afcf9fcd14af52e53e38ffe60b1eac9b3232b21", "html_url": "https://github.com/rust-lang/rust/commit/7afcf9fcd14af52e53e38ffe60b1eac9b3232b21"}], "stats": {"total": 832, "additions": 342, "deletions": 490}, "files": [{"sha": "aaa44a68dc0c0359b3cc9ec2a92848585cd11fc1", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 128, "deletions": 244, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -11,7 +11,6 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{Lock, LockGuard, Lrc, OnceCell};\n use rustc_data_structures::unhash::UnhashMap;\n-use rustc_errors::ErrorReported;\n use rustc_expand::base::{SyntaxExtension, SyntaxExtensionKind};\n use rustc_expand::proc_macro::{AttrProcMacro, BangProcMacro, ProcMacroDerive};\n use rustc_hir as hir;\n@@ -21,10 +20,11 @@ use rustc_hir::definitions::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc_hir::diagnostic_items::DiagnosticItems;\n use rustc_hir::lang_items;\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_middle::arena::ArenaAllocatable;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n+use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_middle::mir::{self, Body, Promoted};\n use rustc_middle::thir;\n use rustc_middle::ty::codec::TyDecoder;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n@@ -278,6 +278,99 @@ impl<'a: 'x, 'tcx: 'x, 'x, T: Decodable<DecodeContext<'a, 'tcx>>> Lazy<[T]> {\n     }\n }\n \n+trait LazyQueryDecodable<'a, 'tcx, T> {\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> T;\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, T> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> T {\n+        if let Some(l) = self { l.decode((cdata, tcx)) } else { err() }\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx T> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+    T: ArenaAllocatable<'tcx>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        err: impl FnOnce() -> !,\n+    ) -> &'tcx T {\n+        if let Some(l) = self { tcx.arena.alloc(l.decode((cdata, tcx))) } else { err() }\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, Option<T>> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Option<T> {\n+        self.map(|l| l.decode((cdata, tcx)))\n+    }\n+}\n+\n+impl<'a, 'tcx, T, E> LazyQueryDecodable<'a, 'tcx, Result<Option<T>, E>> for Option<Lazy<T>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>>,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Result<Option<T>, E> {\n+        Ok(self.map(|l| l.decode((cdata, tcx))))\n+    }\n+}\n+\n+impl<'a, 'tcx, T> LazyQueryDecodable<'a, 'tcx, &'tcx [T]> for Option<Lazy<[T], usize>>\n+where\n+    T: Decodable<DecodeContext<'a, 'tcx>> + Copy,\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> &'tcx [T] {\n+        if let Some(l) = self { tcx.arena.alloc_from_iter(l.decode((cdata, tcx))) } else { &[] }\n+    }\n+}\n+\n+impl<'a, 'tcx> LazyQueryDecodable<'a, 'tcx, Option<DeprecationEntry>>\n+    for Option<Lazy<attr::Deprecation>>\n+{\n+    fn decode_query(\n+        self,\n+        cdata: CrateMetadataRef<'a>,\n+        tcx: TyCtxt<'tcx>,\n+        _err: impl FnOnce() -> !,\n+    ) -> Option<DeprecationEntry> {\n+        self.map(|l| l.decode((cdata, tcx))).map(DeprecationEntry::external)\n+    }\n+}\n+\n impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n@@ -714,9 +807,17 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         &self.raw_proc_macros.unwrap()[pos]\n     }\n \n+    fn opt_item_name(self, item_index: DefIndex) -> Option<Symbol> {\n+        self.def_key(item_index).disambiguated_data.data.get_opt_name()\n+    }\n+\n+    fn item_name(self, item_index: DefIndex) -> Symbol {\n+        self.opt_item_name(item_index).expect(\"no encoded ident for item\")\n+    }\n+\n     fn opt_item_ident(self, item_index: DefIndex, sess: &Session) -> Option<Ident> {\n-        let name = self.def_key(item_index).disambiguated_data.data.get_opt_name()?;\n-        let span = match self.root.tables.ident_span.get(self, item_index) {\n+        let name = self.opt_item_name(item_index)?;\n+        let span = match self.root.tables.def_ident_span.get(self, item_index) {\n             Some(lazy_span) => lazy_span.decode((self, sess)),\n             None => {\n                 // FIXME: this weird case of a name with no span is specific to `extern crate`\n@@ -750,20 +851,22 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn def_kind(self, item_id: DefIndex) -> DefKind {\n-        self.root.tables.def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(|| {\n-            bug!(\n-                \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n-                item_id,\n-                self.root.name,\n-                self.cnum,\n-            )\n-        })\n+        self.root.tables.opt_def_kind.get(self, item_id).map(|k| k.decode(self)).unwrap_or_else(\n+            || {\n+                bug!(\n+                    \"CrateMetadata::def_kind({:?}): id not found, in crate {:?} with number {}\",\n+                    item_id,\n+                    self.root.name,\n+                    self.cnum,\n+                )\n+            },\n+        )\n     }\n \n     fn get_span(self, index: DefIndex, sess: &Session) -> Span {\n         self.root\n             .tables\n-            .span\n+            .def_span\n             .get(self, index)\n             .unwrap_or_else(|| panic!(\"Missing span for {:?}\", index))\n             .decode((self, sess))\n@@ -831,13 +934,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_variant(\n-        self,\n-        kind: &EntryKind,\n-        index: DefIndex,\n-        parent_did: DefId,\n-        sess: &Session,\n-    ) -> ty::VariantDef {\n+    fn get_variant(self, kind: &EntryKind, index: DefIndex, parent_did: DefId) -> ty::VariantDef {\n         let data = match kind {\n             EntryKind::Variant(data) | EntryKind::Struct(data, _) | EntryKind::Union(data, _) => {\n                 data.decode(self)\n@@ -857,7 +954,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let ctor_did = data.ctor.map(|index| self.local_def_id(index));\n \n         ty::VariantDef::new(\n-            self.item_ident(index, sess).name,\n+            self.item_name(index),\n             variant_did,\n             ctor_did,\n             data.discr,\n@@ -869,7 +966,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .decode(self)\n                 .map(|index| ty::FieldDef {\n                     did: self.local_def_id(index),\n-                    name: self.item_ident(index, sess).name,\n+                    name: self.item_name(index),\n                     vis: self.get_visibility(index),\n                 })\n                 .collect(),\n@@ -899,133 +996,31 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                 .get(self, item_id)\n                 .unwrap_or_else(Lazy::empty)\n                 .decode(self)\n-                .map(|index| self.get_variant(&self.kind(index), index, did, tcx.sess))\n+                .map(|index| self.get_variant(&self.kind(index), index, did))\n                 .collect()\n         } else {\n-            std::iter::once(self.get_variant(&kind, item_id, did, tcx.sess)).collect()\n+            std::iter::once(self.get_variant(&kind, item_id, did)).collect()\n         };\n \n         tcx.alloc_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    fn get_explicit_predicates(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.tables.explicit_predicates.get(self, item_id).unwrap().decode((self, tcx))\n-    }\n-\n-    fn get_inferred_outlives(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-        self.root\n-            .tables\n-            .inferred_outlives\n-            .get(self, item_id)\n-            .map(|predicates| tcx.arena.alloc_from_iter(predicates.decode((self, tcx))))\n-            .unwrap_or_default()\n-    }\n-\n-    fn get_super_predicates(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> ty::GenericPredicates<'tcx> {\n-        self.root.tables.super_predicates.get(self, item_id).unwrap().decode((self, tcx))\n-    }\n-\n-    fn get_explicit_item_bounds(\n-        self,\n-        item_id: DefIndex,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-        self.root\n-            .tables\n-            .explicit_item_bounds\n-            .get(self, item_id)\n-            .map(|bounds| tcx.arena.alloc_from_iter(bounds.decode((self, tcx))))\n-            .unwrap_or_default()\n-    }\n-\n     fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.tables.generics.get(self, item_id).unwrap().decode((self, sess))\n-    }\n-\n-    fn get_type(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n-        self.root\n-            .tables\n-            .ty\n-            .get(self, id)\n-            .unwrap_or_else(|| panic!(\"Not a type: {:?}\", id))\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_stability(self, id: DefIndex) -> Option<attr::Stability> {\n-        self.root.tables.stability.get(self, id).map(|stab| stab.decode(self))\n-    }\n-\n-    fn get_const_stability(self, id: DefIndex) -> Option<attr::ConstStability> {\n-        self.root.tables.const_stability.get(self, id).map(|stab| stab.decode(self))\n-    }\n-\n-    fn get_deprecation(self, id: DefIndex) -> Option<attr::Deprecation> {\n-        self.root.tables.deprecation.get(self, id).map(|depr| depr.decode(self))\n+        self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n     }\n \n     fn get_visibility(self, id: DefIndex) -> ty::Visibility {\n         self.root.tables.visibility.get(self, id).unwrap().decode(self)\n     }\n \n-    fn get_impl_data(self, id: DefIndex) -> ImplData {\n-        match self.kind(id) {\n-            EntryKind::Impl(data) => data.decode(self),\n-            _ => bug!(),\n-        }\n-    }\n-\n-    fn get_parent_impl(self, id: DefIndex) -> Option<DefId> {\n-        self.get_impl_data(id).parent_impl\n-    }\n-\n-    fn get_impl_polarity(self, id: DefIndex) -> ty::ImplPolarity {\n-        self.get_impl_data(id).polarity\n-    }\n-\n-    fn get_impl_defaultness(self, id: DefIndex) -> hir::Defaultness {\n-        self.get_impl_data(id).defaultness\n-    }\n-\n-    fn get_impl_constness(self, id: DefIndex) -> hir::Constness {\n-        self.get_impl_data(id).constness\n-    }\n-\n     fn get_trait_item_def_id(self, id: DefIndex) -> Option<DefId> {\n         self.root.tables.trait_item_def_id.get(self, id).map(|d| d.decode(self))\n     }\n \n-    fn get_coerce_unsized_info(self, id: DefIndex) -> Option<ty::adjustment::CoerceUnsizedInfo> {\n-        self.get_impl_data(id).coerce_unsized_info\n-    }\n-\n-    fn get_impl_trait(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> Option<ty::TraitRef<'tcx>> {\n-        self.root.tables.impl_trait_ref.get(self, id).map(|tr| tr.decode((self, tcx)))\n-    }\n-\n     fn get_expn_that_defined(self, id: DefIndex, sess: &Session) -> ExpnId {\n         self.root.tables.expn_that_defined.get(self, id).unwrap().decode((self, sess))\n     }\n \n-    fn get_const_param_default(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> rustc_middle::ty::Const<'tcx> {\n-        self.root.tables.const_defaults.get(self, id).unwrap().decode((self, tcx))\n-    }\n-\n     /// Iterates over all the stability attributes in the given crate.\n     fn get_lib_features(self, tcx: TyCtxt<'tcx>) -> &'tcx [(Symbol, Option<Symbol>)] {\n         tcx.arena.alloc_from_iter(self.root.lib_features.decode(self))\n@@ -1163,7 +1158,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn is_item_mir_available(self, id: DefIndex) -> bool {\n-        self.root.tables.mir.get(self, id).is_some()\n+        self.root.tables.optimized_mir.get(self, id).is_some()\n     }\n \n     fn module_expansion(self, id: DefIndex, sess: &Session) -> ExpnId {\n@@ -1175,75 +1170,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_optimized_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.root\n-            .tables\n-            .mir\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_optimized_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_mir_for_ctfe(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> Body<'tcx> {\n-        self.root\n-            .tables\n-            .mir_for_ctfe\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_mir_for_ctfe: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n-    fn get_thir_abstract_const(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        id: DefIndex,\n-    ) -> Result<Option<&'tcx [thir::abstract_const::Node<'tcx>]>, ErrorReported> {\n-        self.root\n-            .tables\n-            .thir_abstract_consts\n-            .get(self, id)\n-            .map_or(Ok(None), |v| Ok(Some(v.decode((self, tcx)))))\n-    }\n-\n-    fn get_unused_generic_params(self, id: DefIndex) -> FiniteBitSet<u32> {\n-        self.root\n-            .tables\n-            .unused_generic_params\n-            .get(self, id)\n-            .map(|params| params.decode(self))\n-            .unwrap_or_default()\n-    }\n-\n-    fn get_promoted_mir(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> IndexVec<Promoted, Body<'tcx>> {\n-        self.root\n-            .tables\n-            .promoted_mir\n-            .get(self, id)\n-            .unwrap_or_else(|| {\n-                bug!(\"get_promoted_mir: missing MIR for `{:?}`\", self.local_def_id(id))\n-            })\n-            .decode((self, tcx))\n-    }\n-\n-    fn mir_const_qualif(self, id: DefIndex) -> mir::ConstQualifs {\n-        match self.kind(id) {\n-            EntryKind::AnonConst(qualif, _)\n-            | EntryKind::Const(qualif, _)\n-            | EntryKind::AssocConst(\n-                AssocContainer::ImplDefault\n-                | AssocContainer::ImplFinal\n-                | AssocContainer::TraitWithDefault,\n-                qualif,\n-                _,\n-            ) => qualif,\n-            _ => bug!(\"mir_const_qualif: unexpected kind\"),\n-        }\n-    }\n-\n     fn get_fn_has_self_parameter(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::AssocFn(data) => data.decode(self).has_self,\n@@ -1261,13 +1187,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_associated_item(self, id: DefIndex, sess: &Session) -> ty::AssocItem {\n+    fn get_associated_item(self, id: DefIndex) -> ty::AssocItem {\n         let def_key = self.def_key(id);\n         let parent = self.local_def_id(def_key.parent.unwrap());\n-        let ident = self.item_ident(id, sess);\n+        let name = self.item_name(id);\n \n         let (kind, container, has_self) = match self.kind(id) {\n-            EntryKind::AssocConst(container, _, _) => (ty::AssocKind::Const, container, false),\n+            EntryKind::AssocConst(container) => (ty::AssocKind::Const, container, false),\n             EntryKind::AssocFn(data) => {\n                 let data = data.decode(self);\n                 (ty::AssocKind::Fn, data.container, data.has_self)\n@@ -1277,7 +1203,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         };\n \n         ty::AssocItem {\n-            name: ident.name,\n+            name,\n             kind,\n             vis: self.get_visibility(id),\n             defaultness: container.defaultness(),\n@@ -1288,10 +1214,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_variances(self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n-        self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self)\n-    }\n-\n     fn get_ctor_def_id_and_kind(self, node_id: DefIndex) -> Option<(DefId, CtorKind)> {\n         match self.kind(node_id) {\n             EntryKind::Struct(data, _) | EntryKind::Variant(data) => {\n@@ -1338,7 +1260,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .get(self, id)\n             .unwrap_or_else(Lazy::empty)\n             .decode(self)\n-            .map(move |index| respan(self.get_span(index, sess), self.item_ident(index, sess).name))\n+            .map(move |index| respan(self.get_span(index, sess), self.item_name(index)))\n     }\n \n     fn get_struct_field_visibilities(self, id: DefIndex) -> impl Iterator<Item = Visibility> + 'a {\n@@ -1473,31 +1395,13 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.arena.alloc_from_iter(self.root.lang_items_missing.decode(self))\n     }\n \n-    fn get_fn_param_names(self, tcx: TyCtxt<'tcx>, id: DefIndex) -> &'tcx [Ident] {\n-        let param_names = match self.kind(id) {\n-            EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n-            EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n-            _ => Lazy::empty(),\n-        };\n-        tcx.arena.alloc_from_iter(param_names.decode((self, tcx)))\n-    }\n-\n     fn exported_symbols(\n         self,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportLevel)] {\n         tcx.arena.alloc_from_iter(self.root.exported_symbols.decode((self, tcx)))\n     }\n \n-    fn get_rendered_const(self, id: DefIndex) -> String {\n-        match self.kind(id) {\n-            EntryKind::AnonConst(_, data)\n-            | EntryKind::Const(_, data)\n-            | EntryKind::AssocConst(_, _, data) => data.decode(self).0,\n-            _ => bug!(),\n-        }\n-    }\n-\n     fn get_macro(self, id: DefIndex, sess: &Session) -> MacroDef {\n         match self.kind(id) {\n             EntryKind::MacroDef(macro_def) => macro_def.decode((self, sess)),\n@@ -1518,15 +1422,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         constness == hir::Constness::Const\n     }\n \n-    fn asyncness(self, id: DefIndex) -> hir::IsAsync {\n-        match self.kind(id) {\n-            EntryKind::Fn(data) => data.decode(self).asyncness,\n-            EntryKind::AssocFn(data) => data.decode(self).fn_data.asyncness,\n-            EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n-            _ => bug!(\"asyncness: expected function kind\"),\n-        }\n-    }\n-\n     fn is_foreign_item(self, id: DefIndex) -> bool {\n         match self.kind(id) {\n             EntryKind::ForeignImmStatic | EntryKind::ForeignMutStatic | EntryKind::ForeignFn(_) => {\n@@ -1544,17 +1439,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn generator_kind(self, id: DefIndex) -> Option<hir::GeneratorKind> {\n-        match self.kind(id) {\n-            EntryKind::Generator(data) => Some(data),\n-            _ => None,\n-        }\n-    }\n-\n-    fn fn_sig(self, id: DefIndex, tcx: TyCtxt<'tcx>) -> ty::PolyFnSig<'tcx> {\n-        self.root.tables.fn_sig.get(self, id).unwrap().decode((self, tcx))\n-    }\n-\n     #[inline]\n     fn def_key(self, index: DefIndex) -> DefKey {\n         *self"}, {"sha": "5ae965ff7fadbb78cf59f34e7dd90b69fb2d09db", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 77, "deletions": 67, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -1,3 +1,4 @@\n+use super::LazyQueryDecodable;\n use crate::creader::{CStore, LoadedMacro};\n use crate::foreign_modules;\n use crate::native_libs;\n@@ -8,7 +9,6 @@ use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE}\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::exported_symbols::ExportedSymbol;\n-use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n@@ -23,32 +23,51 @@ use rustc_data_structures::sync::Lrc;\n use smallvec::SmallVec;\n use std::any::Any;\n \n+macro_rules! provide_one {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => { table }) => {\n+        provide_one! {\n+            <$lt> $tcx, $def_id, $other, $cdata, $name => {\n+                $cdata.root.tables.$name.get($cdata, $def_id.index).decode_query(\n+                    $cdata,\n+                    $tcx,\n+                    || panic!(\"{:?} does not have a {:?}\", $def_id, stringify!($name)),\n+                )\n+            }\n+        }\n+    };\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident, $name:ident => $compute:block) => {\n+        fn $name<$lt>(\n+            $tcx: TyCtxt<$lt>,\n+            def_id_arg: ty::query::query_keys::$name<$lt>,\n+        ) -> ty::query::query_values::$name<$lt> {\n+            let _prof_timer =\n+                $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n+\n+            #[allow(unused_variables)]\n+            let ($def_id, $other) = def_id_arg.into_args();\n+            assert!(!$def_id.is_local());\n+\n+            // External query providers call `crate_hash` in order to register a dependency\n+            // on the crate metadata. The exception is `crate_hash` itself, which obviously\n+            // doesn't need to do this (and can't, as it would cause a query cycle).\n+            use rustc_middle::dep_graph::DepKind;\n+            if DepKind::$name != DepKind::crate_hash && $tcx.dep_graph.is_fully_enabled() {\n+                $tcx.ensure().crate_hash($def_id.krate);\n+            }\n+\n+            let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n+\n+            $compute\n+        }\n+    };\n+}\n+\n macro_rules! provide {\n     (<$lt:tt> $tcx:ident, $def_id:ident, $other:ident, $cdata:ident,\n-      $($name:ident => $compute:block)*) => {\n+      $($name:ident => { $($compute:tt)* })*) => {\n         pub fn provide_extern(providers: &mut ExternProviders) {\n-            $(fn $name<$lt>(\n-                $tcx: TyCtxt<$lt>,\n-                def_id_arg: ty::query::query_keys::$name<$lt>,\n-            ) -> ty::query::query_values::$name<$lt> {\n-                let _prof_timer =\n-                    $tcx.prof.generic_activity(concat!(\"metadata_decode_entry_\", stringify!($name)));\n-\n-                #[allow(unused_variables)]\n-                let ($def_id, $other) = def_id_arg.into_args();\n-                assert!(!$def_id.is_local());\n-\n-                // External query providers call `crate_hash` in order to register a dependency\n-                // on the crate metadata. The exception is `crate_hash` itself, which obviously\n-                // doesn't need to do this (and can't, as it would cause a query cycle).\n-                use rustc_middle::dep_graph::DepKind;\n-                if DepKind::$name != DepKind::crate_hash && $tcx.dep_graph.is_fully_enabled() {\n-                    $tcx.ensure().crate_hash($def_id.krate);\n-                }\n-\n-                let $cdata = CStore::from_tcx($tcx).get_crate_data($def_id.krate);\n-\n-                $compute\n+            $(provide_one! {\n+                <$lt> $tcx, $def_id, $other, $cdata, $name => { $($compute)* }\n             })*\n \n             *providers = ExternProviders {\n@@ -90,58 +109,52 @@ impl<'tcx> IntoArgs for ty::InstanceDef<'tcx> {\n }\n \n provide! { <'tcx> tcx, def_id, other, cdata,\n-    type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => { cdata.get_generics(def_id.index, tcx.sess) }\n-    explicit_predicates_of => { cdata.get_explicit_predicates(def_id.index, tcx) }\n-    inferred_outlives_of => { cdata.get_inferred_outlives(def_id.index, tcx) }\n-    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n-    explicit_item_bounds => { cdata.get_explicit_item_bounds(def_id.index, tcx) }\n+    explicit_item_bounds => { table }\n+    explicit_predicates_of => { table }\n+    generics_of => { table }\n+    inferred_outlives_of => { table }\n+    super_predicates_of => { table }\n+    type_of => { table }\n+    variances_of => { table }\n+    fn_sig => { table }\n+    impl_trait_ref => { table }\n+    const_param_default => { table }\n+    thir_abstract_const => { table }\n+    optimized_mir => { table }\n+    mir_for_ctfe => { table }\n+    promoted_mir => { table }\n+    def_span => { table }\n+    def_ident_span => { table }\n+    lookup_stability => { table }\n+    lookup_const_stability => { table }\n+    lookup_deprecation_entry => { table }\n+    visibility => { table }\n+    unused_generic_params => { table }\n+    opt_def_kind => { table }\n+    impl_parent => { table }\n+    impl_polarity => { table }\n+    impl_defaultness => { table }\n+    impl_constness => { table }\n+    coerce_unsized_info => { table }\n+    mir_const_qualif => { table }\n+    rendered_const => { table }\n+    asyncness => { table }\n+    fn_arg_names => { table }\n+    generator_kind => { table }\n+\n     trait_def => { cdata.get_trait_def(def_id.index, tcx.sess) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n         let _ = cdata;\n         tcx.calculate_dtor(def_id, |_,_| Ok(()))\n     }\n-    variances_of => { tcx.arena.alloc_from_iter(cdata.get_item_variances(def_id.index)) }\n     associated_item_def_ids => { cdata.get_associated_item_def_ids(tcx, def_id.index) }\n-    associated_item => { cdata.get_associated_item(def_id.index, tcx.sess) }\n-    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n-    impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n-    coerce_unsized_info => {\n-        cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n-            bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n-        })\n-    }\n-    optimized_mir => { tcx.arena.alloc(cdata.get_optimized_mir(tcx, def_id.index)) }\n-    mir_for_ctfe => { tcx.arena.alloc(cdata.get_mir_for_ctfe(tcx, def_id.index)) }\n-    promoted_mir => { tcx.arena.alloc(cdata.get_promoted_mir(tcx, def_id.index)) }\n-    thir_abstract_const => { cdata.get_thir_abstract_const(tcx, def_id.index) }\n-    unused_generic_params => { cdata.get_unused_generic_params(def_id.index) }\n-    const_param_default => { cdata.get_const_param_default(tcx, def_id.index) }\n-    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n-    fn_sig => { cdata.fn_sig(def_id.index, tcx) }\n+    associated_item => { cdata.get_associated_item(def_id.index) }\n     inherent_impls => { cdata.get_inherent_implementations_for_type(tcx, def_id.index) }\n     is_const_fn_raw => { cdata.is_const_fn_raw(def_id.index) }\n-    asyncness => { cdata.asyncness(def_id.index) }\n     is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n     static_mutability => { cdata.static_mutability(def_id.index) }\n-    generator_kind => { cdata.generator_kind(def_id.index) }\n-    opt_def_kind => { Some(cdata.def_kind(def_id.index)) }\n-    def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-    def_ident_span => { cdata.opt_item_ident(def_id.index, &tcx.sess).map(|ident| ident.span) }\n-    lookup_stability => {\n-        cdata.get_stability(def_id.index).map(|s| tcx.intern_stability(s))\n-    }\n-    lookup_const_stability => {\n-        cdata.get_const_stability(def_id.index).map(|s| tcx.intern_const_stability(s))\n-    }\n-    lookup_deprecation_entry => {\n-        cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n-    }\n     item_attrs => { tcx.arena.alloc_from_iter(cdata.get_item_attrs(def_id.index, tcx.sess)) }\n-    fn_arg_names => { cdata.get_fn_param_names(tcx, def_id.index) }\n-    rendered_const => { cdata.get_rendered_const(def_id.index) }\n-    impl_parent => { cdata.get_parent_impl(def_id.index) }\n     trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n     is_ctfe_mir_available => { cdata.is_ctfe_mir_available(def_id.index) }\n@@ -161,8 +174,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     }\n     is_no_builtins => { cdata.root.no_builtins }\n     symbol_mangling_version => { cdata.root.symbol_mangling_version }\n-    impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n-    impl_constness => { cdata.get_impl_constness(def_id.index) }\n     reachable_non_generics => {\n         let reachable_non_generics = tcx\n             .exported_symbols(cdata.cnum)\n@@ -189,7 +200,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     traits_in_crate => { tcx.arena.alloc_from_iter(cdata.get_traits()) }\n     implementations_of_trait => { cdata.get_implementations_of_trait(tcx, other) }\n \n-    visibility => { cdata.get_visibility(def_id.index) }\n     dep_kind => {\n         let r = *cdata.dep_kind.lock();\n         r"}, {"sha": "da8995df1ac9e43b24b142afed566950ffac3c66", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 77, "deletions": 94, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -983,13 +983,13 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let def_id = local_id.to_def_id();\n             let def_kind = tcx.opt_def_kind(local_id);\n             let Some(def_kind) = def_kind else { continue };\n-            record!(self.tables.def_kind[def_id] <- match def_kind {\n+            record!(self.tables.opt_def_kind[def_id] <- match def_kind {\n                 // Replace Ctor by the enclosing object to avoid leaking details in children crates.\n                 DefKind::Ctor(CtorOf::Struct, _) => DefKind::Struct,\n                 DefKind::Ctor(CtorOf::Variant, _) => DefKind::Variant,\n                 def_kind => def_kind,\n             });\n-            record!(self.tables.span[def_id] <- tcx.def_span(def_id));\n+            record!(self.tables.def_span[def_id] <- tcx.def_span(def_id));\n             record!(self.tables.attributes[def_id] <- tcx.get_attrs(def_id));\n             record!(self.tables.expn_that_defined[def_id] <- self.tcx.expn_that_defined(def_id));\n             if should_encode_visibility(def_kind) {\n@@ -1002,19 +1002,19 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             if should_encode_variances(def_kind) {\n                 let v = self.tcx.variances_of(def_id);\n-                record!(self.tables.variances[def_id] <- v);\n+                record!(self.tables.variances_of[def_id] <- v);\n             }\n             if should_encode_generics(def_kind) {\n                 let g = tcx.generics_of(def_id);\n-                record!(self.tables.generics[def_id] <- g);\n-                record!(self.tables.explicit_predicates[def_id] <- self.tcx.explicit_predicates_of(def_id));\n+                record!(self.tables.generics_of[def_id] <- g);\n+                record!(self.tables.explicit_predicates_of[def_id] <- self.tcx.explicit_predicates_of(def_id));\n                 let inferred_outlives = self.tcx.inferred_outlives_of(def_id);\n                 if !inferred_outlives.is_empty() {\n-                    record!(self.tables.inferred_outlives[def_id] <- inferred_outlives);\n+                    record!(self.tables.inferred_outlives_of[def_id] <- inferred_outlives);\n                 }\n             }\n             if let DefKind::Trait | DefKind::TraitAlias = def_kind {\n-                record!(self.tables.super_predicates[def_id] <- self.tcx.super_predicates_of(def_id));\n+                record!(self.tables.super_predicates_of[def_id] <- self.tcx.super_predicates_of(def_id));\n             }\n         }\n         let inherent_impls = tcx.crate_inherent_impls(());\n@@ -1031,7 +1031,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_item_type(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_item_type({:?})\", def_id);\n-        record!(self.tables.ty[def_id] <- self.tcx.type_of(def_id));\n+        record!(self.tables.type_of[def_id] <- self.tcx.type_of(def_id));\n     }\n \n     fn encode_enum_variant_info(&mut self, def: &ty::AdtDef, index: VariantIdx) {\n@@ -1188,25 +1188,23 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n                     |s| s.print_trait_item(ast_item),\n                 );\n-                let rendered_const = self.lazy(RenderedConst(rendered));\n \n-                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n-                    container,\n-                    Default::default(),\n-                    rendered_const,\n-                ));\n+                record!(self.tables.kind[def_id] <- EntryKind::AssocConst(container));\n+                record!(self.tables.mir_const_qualif[def_id] <- mir::ConstQualifs::default());\n+                record!(self.tables.rendered_const[def_id] <- rendered);\n             }\n             ty::AssocKind::Fn => {\n                 let fn_data = if let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind {\n-                    let param_names = match *m {\n-                        hir::TraitFn::Required(ref names) => self.encode_fn_param_names(names),\n-                        hir::TraitFn::Provided(body) => self.encode_fn_param_names_for_body(body),\n+                    match *m {\n+                        hir::TraitFn::Required(ref names) => {\n+                            record!(self.tables.fn_arg_names[def_id] <- *names)\n+                        }\n+                        hir::TraitFn::Provided(body) => {\n+                            record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body))\n+                        }\n                     };\n-                    FnData {\n-                        asyncness: m_sig.header.asyncness,\n-                        constness: hir::Constness::NotConst,\n-                        param_names,\n-                    }\n+                    record!(self.tables.asyncness[def_id] <- m_sig.header.asyncness);\n+                    FnData { constness: hir::Constness::NotConst }\n                 } else {\n                     bug!()\n                 };\n@@ -1256,27 +1254,26 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             ty::AssocKind::Const => {\n                 if let hir::ImplItemKind::Const(_, body_id) = ast_item.kind {\n                     let qualifs = self.tcx.at(ast_item.span).mir_const_qualif(def_id);\n+                    let const_data = self.encode_rendered_const_for_body(body_id);\n \n-                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(\n-                        container,\n-                        qualifs,\n-                        self.encode_rendered_const_for_body(body_id))\n-                    );\n+                    record!(self.tables.kind[def_id] <- EntryKind::AssocConst(container));\n+                    record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n+                    record!(self.tables.rendered_const[def_id] <- const_data);\n                 } else {\n                     bug!()\n                 }\n             }\n             ty::AssocKind::Fn => {\n                 let fn_data = if let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind {\n+                    record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n+                    record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n                     FnData {\n-                        asyncness: sig.header.asyncness,\n                         // Can be inside `impl const Trait`, so using sig.header.constness is not reliable\n                         constness: if self.tcx.is_const_fn_raw(def_id) {\n                             hir::Constness::Const\n                         } else {\n                             hir::Constness::NotConst\n                         },\n-                        param_names: self.encode_fn_param_names_for_body(body),\n                     }\n                 } else {\n                     bug!()\n@@ -1301,14 +1298,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_fn_param_names_for_body(&mut self, body_id: hir::BodyId) -> Lazy<[Ident]> {\n-        self.lazy(self.tcx.hir().body_param_names(body_id))\n-    }\n-\n-    fn encode_fn_param_names(&mut self, param_names: &[Ident]) -> Lazy<[Ident]> {\n-        self.lazy(param_names.iter())\n-    }\n-\n     fn encode_mir(&mut self) {\n         if self.is_proc_macro {\n             return;\n@@ -1332,15 +1321,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n             debug!(\"EntryBuilder::encode_mir({:?})\", def_id);\n             if encode_opt {\n-                record!(self.tables.mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n+                record!(self.tables.optimized_mir[def_id.to_def_id()] <- self.tcx.optimized_mir(def_id));\n             }\n             if encode_const {\n                 record!(self.tables.mir_for_ctfe[def_id.to_def_id()] <- self.tcx.mir_for_ctfe(def_id));\n \n                 // FIXME(generic_const_exprs): this feels wrong to have in `encode_mir`\n                 let abstract_const = self.tcx.thir_abstract_const(def_id);\n                 if let Ok(Some(abstract_const)) = abstract_const {\n-                    record!(self.tables.thir_abstract_consts[def_id.to_def_id()] <- abstract_const);\n+                    record!(self.tables.thir_abstract_const[def_id.to_def_id()] <- abstract_const);\n                 }\n             }\n             record!(self.tables.promoted_mir[def_id.to_def_id()] <- self.tcx.promoted_mir(def_id));\n@@ -1361,7 +1350,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the stability attributes are even enabled before using their queries.\n         if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n             if let Some(stab) = self.tcx.lookup_stability(def_id) {\n-                record!(self.tables.stability[def_id] <- stab)\n+                record!(self.tables.lookup_stability[def_id] <- stab)\n             }\n         }\n     }\n@@ -1373,26 +1362,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // the stability attributes are even enabled before using their queries.\n         if self.feat.staged_api || self.tcx.sess.opts.debugging_opts.force_unstable_if_unmarked {\n             if let Some(stab) = self.tcx.lookup_const_stability(def_id) {\n-                record!(self.tables.const_stability[def_id] <- stab)\n+                record!(self.tables.lookup_const_stability[def_id] <- stab)\n             }\n         }\n     }\n \n     fn encode_deprecation(&mut self, def_id: DefId) {\n         debug!(\"EncodeContext::encode_deprecation({:?})\", def_id);\n         if let Some(depr) = self.tcx.lookup_deprecation(def_id) {\n-            record!(self.tables.deprecation[def_id] <- depr);\n+            record!(self.tables.lookup_deprecation_entry[def_id] <- depr);\n         }\n     }\n \n-    fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n+    fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> String {\n         let hir = self.tcx.hir();\n         let body = hir.body(body_id);\n-        let rendered = rustc_hir_pretty::to_string(&(&hir as &dyn intravisit::Map<'_>), |s| {\n+        rustc_hir_pretty::to_string(&(&hir as &dyn intravisit::Map<'_>), |s| {\n             s.print_expr(&body.value)\n-        });\n-        let rendered_const = &RenderedConst(rendered);\n-        self.lazy(rendered_const)\n+        })\n     }\n \n     fn encode_info_for_item(&mut self, def_id: DefId, item: &'tcx hir::Item<'tcx>) {\n@@ -1407,14 +1394,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::Static(_, hir::Mutability::Not, _) => EntryKind::ImmStatic,\n             hir::ItemKind::Const(_, body_id) => {\n                 let qualifs = self.tcx.at(item.span).mir_const_qualif(def_id);\n-                EntryKind::Const(qualifs, self.encode_rendered_const_for_body(body_id))\n+                let const_data = self.encode_rendered_const_for_body(body_id);\n+                record!(self.tables.mir_const_qualif[def_id] <- qualifs);\n+                record!(self.tables.rendered_const[def_id] <- const_data);\n+                EntryKind::Const\n             }\n             hir::ItemKind::Fn(ref sig, .., body) => {\n-                let data = FnData {\n-                    asyncness: sig.header.asyncness,\n-                    constness: sig.header.constness,\n-                    param_names: self.encode_fn_param_names_for_body(body),\n-                };\n+                record!(self.tables.asyncness[def_id] <- sig.header.asyncness);\n+                record!(self.tables.fn_arg_names[def_id] <- self.tcx.hir().body_param_names(body));\n+                let data = FnData { constness: sig.header.constness };\n \n                 EntryKind::Fn(self.lazy(data))\n             }\n@@ -1468,39 +1456,31 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 )\n             }\n             hir::ItemKind::Impl(hir::Impl { defaultness, constness, .. }) => {\n+                record!(self.tables.impl_defaultness[def_id] <- defaultness);\n+                record!(self.tables.impl_constness[def_id] <- constness);\n+\n                 let trait_ref = self.tcx.impl_trait_ref(def_id);\n-                let polarity = self.tcx.impl_polarity(def_id);\n-                let parent = if let Some(trait_ref) = trait_ref {\n+                if let Some(trait_ref) = trait_ref {\n                     let trait_def = self.tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(self.tcx, def_id).ok().and_then(|mut an| {\n-                        an.nth(1).and_then(|node| match node {\n-                            specialization_graph::Node::Impl(parent) => Some(parent),\n-                            _ => None,\n-                        })\n-                    })\n-                } else {\n-                    None\n-                };\n+                    if let Some(mut an) = trait_def.ancestors(self.tcx, def_id).ok() {\n+                        if let Some(specialization_graph::Node::Impl(parent)) = an.nth(1) {\n+                            record!(self.tables.impl_parent[def_id] <- parent);\n+                        }\n+                    }\n \n-                // if this is an impl of `CoerceUnsized`, create its\n-                // \"unsized info\", else just store None\n-                let coerce_unsized_info = trait_ref.and_then(|t| {\n-                    if Some(t.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n-                        Some(self.tcx.at(item.span).coerce_unsized_info(def_id))\n-                    } else {\n-                        None\n+                    // if this is an impl of `CoerceUnsized`, create its\n+                    // \"unsized info\", else just store None\n+                    if Some(trait_ref.def_id) == self.tcx.lang_items().coerce_unsized_trait() {\n+                        let coerce_unsized_info =\n+                            self.tcx.at(item.span).coerce_unsized_info(def_id);\n+                        record!(self.tables.coerce_unsized_info[def_id] <- coerce_unsized_info);\n                     }\n-                });\n+                }\n \n-                let data = ImplData {\n-                    polarity,\n-                    defaultness,\n-                    constness,\n-                    parent_impl: parent,\n-                    coerce_unsized_info,\n-                };\n+                let polarity = self.tcx.impl_polarity(def_id);\n+                record!(self.tables.impl_polarity[def_id] <- polarity);\n \n-                EntryKind::Impl(self.lazy(data))\n+                EntryKind::Impl\n             }\n             hir::ItemKind::Trait(..) => {\n                 let trait_def = self.tcx.trait_def(def_id);\n@@ -1589,7 +1569,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         match ty.kind() {\n             ty::Generator(..) => {\n                 let data = self.tcx.generator_kind(def_id).unwrap();\n-                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator(data));\n+                record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::Generator);\n+                record!(self.tables.generator_kind[def_id.to_def_id()] <- data);\n             }\n \n             ty::Closure(..) => {\n@@ -1611,7 +1592,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n-        record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst(qualifs, const_data));\n+        record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst);\n+        record!(self.tables.mir_const_qualif[def_id.to_def_id()] <- qualifs);\n+        record!(self.tables.rendered_const[def_id.to_def_id()] <- const_data);\n         self.encode_item_type(def_id.to_def_id());\n     }\n \n@@ -1661,7 +1644,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let hir = tcx.hir();\n \n             let proc_macro_decls_static = tcx.proc_macro_decls_static(()).unwrap().local_def_index;\n-            let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX)).copied();\n+            let stability = tcx.lookup_stability(DefId::local(CRATE_DEF_INDEX));\n             let macros =\n                 self.lazy(tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index));\n             let spans = self.tcx.sess.parse_sess.proc_macro_quoted_spans();\n@@ -1670,12 +1653,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 self.tables.proc_macro_quoted_spans.set(i, span);\n             }\n \n-            record!(self.tables.def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n-            record!(self.tables.span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n+            record!(self.tables.opt_def_kind[LOCAL_CRATE.as_def_id()] <- DefKind::Mod);\n+            record!(self.tables.def_span[LOCAL_CRATE.as_def_id()] <- tcx.def_span(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.attributes[LOCAL_CRATE.as_def_id()] <- tcx.get_attrs(LOCAL_CRATE.as_def_id()));\n             record!(self.tables.visibility[LOCAL_CRATE.as_def_id()] <- tcx.visibility(LOCAL_CRATE.as_def_id()));\n             if let Some(stability) = stability {\n-                record!(self.tables.stability[LOCAL_CRATE.as_def_id()] <- stability);\n+                record!(self.tables.lookup_stability[LOCAL_CRATE.as_def_id()] <- stability);\n             }\n             self.encode_deprecation(LOCAL_CRATE.as_def_id());\n \n@@ -1711,15 +1694,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 def_key.disambiguated_data.data = DefPathData::MacroNs(name);\n \n                 let def_id = id.to_def_id();\n-                record!(self.tables.def_kind[def_id] <- DefKind::Macro(macro_kind));\n+                record!(self.tables.opt_def_kind[def_id] <- DefKind::Macro(macro_kind));\n                 record!(self.tables.kind[def_id] <- EntryKind::ProcMacro(macro_kind));\n                 record!(self.tables.attributes[def_id] <- attrs);\n                 record!(self.tables.def_keys[def_id] <- def_key);\n-                record!(self.tables.ident_span[def_id] <- span);\n-                record!(self.tables.span[def_id] <- span);\n+                record!(self.tables.def_ident_span[def_id] <- span);\n+                record!(self.tables.def_span[def_id] <- span);\n                 record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n                 if let Some(stability) = stability {\n-                    record!(self.tables.stability[def_id] <- stability);\n+                    record!(self.tables.lookup_stability[def_id] <- stability);\n                 }\n             }\n \n@@ -1885,14 +1868,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         match nitem.kind {\n             hir::ForeignItemKind::Fn(_, ref names, _) => {\n+                record!(self.tables.asyncness[def_id] <- hir::IsAsync::NotAsync);\n+                record!(self.tables.fn_arg_names[def_id] <- *names);\n                 let data = FnData {\n-                    asyncness: hir::IsAsync::NotAsync,\n                     constness: if self.tcx.is_const_fn_raw(def_id) {\n                         hir::Constness::Const\n                     } else {\n                         hir::Constness::NotConst\n                     },\n-                    param_names: self.encode_fn_param_names(names),\n                 };\n                 record!(self.tables.kind[def_id] <- EntryKind::ForeignFn(self.lazy(data)));\n             }\n@@ -1972,7 +1955,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     let def_id = def_id.to_def_id();\n                     self.encode_info_for_generic_param(def_id, EntryKind::ConstParam, true);\n                     if default.is_some() {\n-                        record!(self.tables.const_defaults[def_id] <- self.tcx.const_param_default(def_id))\n+                        record!(self.tables.const_param_default[def_id] <- self.tcx.const_param_default(def_id))\n                     }\n                 }\n             }\n@@ -1986,7 +1969,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_ident_span(&mut self, def_id: DefId, ident: Ident) {\n-        record!(self.tables.ident_span[def_id] <- ident.span);\n+        record!(self.tables.def_ident_span[def_id] <- ident.span);\n     }\n \n     /// In some cases, along with the item itself, we also"}, {"sha": "da17d9d4c6706405b7fc1549b2a1049543aae76b", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 39, "deletions": 45, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -275,35 +275,48 @@ macro_rules! define_tables {\n }\n \n define_tables! {\n-    def_kind: Table<DefIndex, Lazy<DefKind>>,\n     kind: Table<DefIndex, Lazy<EntryKind>>,\n-    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n-    span: Table<DefIndex, Lazy<Span>>,\n-    ident_span: Table<DefIndex, Lazy<Span>>,\n     attributes: Table<DefIndex, Lazy<[ast::Attribute]>>,\n     children: Table<DefIndex, Lazy<[DefIndex]>>,\n-    stability: Table<DefIndex, Lazy<attr::Stability>>,\n-    const_stability: Table<DefIndex, Lazy<attr::ConstStability>>,\n-    deprecation: Table<DefIndex, Lazy<attr::Deprecation>>,\n-    ty: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n+\n+    opt_def_kind: Table<DefIndex, Lazy<DefKind>>,\n+    visibility: Table<DefIndex, Lazy<ty::Visibility>>,\n+    def_span: Table<DefIndex, Lazy<Span>>,\n+    def_ident_span: Table<DefIndex, Lazy<Span>>,\n+    lookup_stability: Table<DefIndex, Lazy<attr::Stability>>,\n+    lookup_const_stability: Table<DefIndex, Lazy<attr::ConstStability>>,\n+    lookup_deprecation_entry: Table<DefIndex, Lazy<attr::Deprecation>>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n+    explicit_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    generics_of: Table<DefIndex, Lazy<ty::Generics>>,\n+    // As an optimization, a missing entry indicates an empty `&[]`.\n+    inferred_outlives_of: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n+    super_predicates_of: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n+    type_of: Table<DefIndex, Lazy!(Ty<'tcx>)>,\n+    variances_of: Table<DefIndex, Lazy<[ty::Variance]>>,\n     fn_sig: Table<DefIndex, Lazy!(ty::PolyFnSig<'tcx>)>,\n     impl_trait_ref: Table<DefIndex, Lazy!(ty::TraitRef<'tcx>)>,\n+    const_param_default: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n+    optimized_mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n+    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n+    thir_abstract_const: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n+    impl_parent: Table<DefIndex, Lazy!(DefId)>,\n+    impl_polarity: Table<DefIndex, Lazy!(ty::ImplPolarity)>,\n+    impl_constness: Table<DefIndex, Lazy!(hir::Constness)>,\n+    impl_defaultness: Table<DefIndex, Lazy!(hir::Defaultness)>,\n+    // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n+    coerce_unsized_info: Table<DefIndex, Lazy!(ty::adjustment::CoerceUnsizedInfo)>,\n+    mir_const_qualif: Table<DefIndex, Lazy!(mir::ConstQualifs)>,\n+    rendered_const: Table<DefIndex, Lazy!(String)>,\n+    asyncness: Table<DefIndex, Lazy!(hir::IsAsync)>,\n+    fn_arg_names: Table<DefIndex, Lazy!([Ident])>,\n+    generator_kind: Table<DefIndex, Lazy!(hir::GeneratorKind)>,\n+\n     trait_item_def_id: Table<DefIndex, Lazy<DefId>>,\n     inherent_impls: Table<DefIndex, Lazy<[DefIndex]>>,\n-    variances: Table<DefIndex, Lazy<[ty::Variance]>>,\n-    generics: Table<DefIndex, Lazy<ty::Generics>>,\n-    explicit_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n     expn_that_defined: Table<DefIndex, Lazy<ExpnId>>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    inferred_outlives: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    super_predicates: Table<DefIndex, Lazy!(ty::GenericPredicates<'tcx>)>,\n-    // As an optimization, a missing entry indicates an empty `&[]`.\n-    explicit_item_bounds: Table<DefIndex, Lazy!([(ty::Predicate<'tcx>, Span)])>,\n-    mir: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    mir_for_ctfe: Table<DefIndex, Lazy!(mir::Body<'tcx>)>,\n-    promoted_mir: Table<DefIndex, Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>,\n-    thir_abstract_consts: Table<DefIndex, Lazy!(&'tcx [thir::abstract_const::Node<'tcx>])>,\n-    const_defaults: Table<DefIndex, Lazy<rustc_middle::ty::Const<'tcx>>>,\n     unused_generic_params: Table<DefIndex, Lazy<FiniteBitSet<u32>>>,\n     // `def_keys` and `def_path_hashes` represent a lazy version of a\n     // `DefPathTable`. This allows us to avoid deserializing an entire\n@@ -316,8 +329,8 @@ define_tables! {\n \n #[derive(Copy, Clone, MetadataEncodable, MetadataDecodable)]\n enum EntryKind {\n-    AnonConst(mir::ConstQualifs, Lazy<RenderedConst>),\n-    Const(mir::ConstQualifs, Lazy<RenderedConst>),\n+    AnonConst,\n+    Const,\n     ImmStatic,\n     MutStatic,\n     ForeignImmStatic,\n@@ -340,25 +353,18 @@ enum EntryKind {\n     MacroDef(Lazy<MacroDef>),\n     ProcMacro(MacroKind),\n     Closure,\n-    Generator(hir::GeneratorKind),\n+    Generator,\n     Trait(Lazy<TraitData>),\n-    Impl(Lazy<ImplData>),\n+    Impl,\n     AssocFn(Lazy<AssocFnData>),\n     AssocType(AssocContainer),\n-    AssocConst(AssocContainer, mir::ConstQualifs, Lazy<RenderedConst>),\n+    AssocConst(AssocContainer),\n     TraitAlias,\n }\n \n-/// Contains a constant which has been rendered to a String.\n-/// Used by rustdoc.\n-#[derive(Encodable, Decodable)]\n-struct RenderedConst(String);\n-\n #[derive(MetadataEncodable, MetadataDecodable)]\n struct FnData {\n-    asyncness: hir::IsAsync,\n     constness: hir::Constness,\n-    param_names: Lazy<[Ident]>,\n }\n \n #[derive(TyEncodable, TyDecodable)]\n@@ -381,18 +387,6 @@ struct TraitData {\n     must_implement_one_of: Option<Box<[Ident]>>,\n }\n \n-#[derive(TyEncodable, TyDecodable)]\n-struct ImplData {\n-    polarity: ty::ImplPolarity,\n-    constness: hir::Constness,\n-    defaultness: hir::Defaultness,\n-    parent_impl: Option<DefId>,\n-\n-    /// This is `Some` only for impls of `CoerceUnsized`.\n-    // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n-    coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n-}\n-\n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\"."}, {"sha": "7a7d24704440bdb9366dcecd615d6f80b8831f12", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -57,11 +57,11 @@ impl DeprecationEntry {\n \n /// A stability index, giving the stability level for items and methods.\n #[derive(HashStable, Debug)]\n-pub struct Index<'tcx> {\n+pub struct Index {\n     /// This is mostly a cache, except the stabilities of local items\n     /// are filled by the annotator.\n-    pub stab_map: FxHashMap<LocalDefId, &'tcx Stability>,\n-    pub const_stab_map: FxHashMap<LocalDefId, &'tcx ConstStability>,\n+    pub stab_map: FxHashMap<LocalDefId, Stability>,\n+    pub const_stab_map: FxHashMap<LocalDefId, ConstStability>,\n     pub depr_map: FxHashMap<LocalDefId, DeprecationEntry>,\n \n     /// Maps for each crate whether it is part of the staged API.\n@@ -71,12 +71,12 @@ pub struct Index<'tcx> {\n     pub active_features: FxHashSet<Symbol>,\n }\n \n-impl<'tcx> Index<'tcx> {\n-    pub fn local_stability(&self, def_id: LocalDefId) -> Option<&'tcx Stability> {\n+impl Index {\n+    pub fn local_stability(&self, def_id: LocalDefId) -> Option<Stability> {\n         self.stab_map.get(&def_id).copied()\n     }\n \n-    pub fn local_const_stability(&self, def_id: LocalDefId) -> Option<&'tcx ConstStability> {\n+    pub fn local_const_stability(&self, def_id: LocalDefId) -> Option<ConstStability> {\n         self.const_stab_map.get(&def_id).copied()\n     }\n \n@@ -416,7 +416,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         match stability {\n-            Some(&Stability {\n+            Some(Stability {\n                 level: attr::Unstable { reason, issue, is_soft }, feature, ..\n             }) => {\n                 if span.allows_unstable(feature) {"}, {"sha": "c299dacfc927a71176199a35b53c1a2a2e08c5d5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -1016,12 +1016,12 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query lookup_stability(def_id: DefId) -> Option<&'tcx attr::Stability> {\n+    query lookup_stability(def_id: DefId) -> Option<attr::Stability> {\n         desc { |tcx| \"looking up stability of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n \n-    query lookup_const_stability(def_id: DefId) -> Option<&'tcx attr::ConstStability> {\n+    query lookup_const_stability(def_id: DefId) -> Option<attr::ConstStability> {\n         desc { |tcx| \"looking up const stability of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n@@ -1636,7 +1636,7 @@ rustc_queries! {\n         desc { |tcx| \"names_imported_by_glob_use for `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n     }\n \n-    query stability_index(_: ()) -> stability::Index<'tcx> {\n+    query stability_index(_: ()) -> stability::Index {\n         storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"calculating the stability index for the local crate\" }"}, {"sha": "7a6a6a00cc755af52ca897bc2c9beb765684a952", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -24,7 +24,6 @@ use crate::ty::{\n     RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar, TyVid, TypeAndMut, UintTy,\n };\n use rustc_ast as ast;\n-use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::memmap::Mmap;\n@@ -115,12 +114,6 @@ pub struct CtxtInterners<'tcx> {\n     bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n     layout: InternedSet<'tcx, Layout>,\n     adt_def: InternedSet<'tcx, AdtDef>,\n-\n-    /// `#[stable]` and `#[unstable]` attributes\n-    stability: InternedSet<'tcx, attr::Stability>,\n-\n-    /// `#[rustc_const_stable]` and `#[rustc_const_unstable]` attributes\n-    const_stability: InternedSet<'tcx, attr::ConstStability>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -141,8 +134,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n             bound_variable_kinds: Default::default(),\n             layout: Default::default(),\n             adt_def: Default::default(),\n-            stability: Default::default(),\n-            const_stability: Default::default(),\n         }\n     }\n \n@@ -1268,7 +1259,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.diagnostic_items(did.krate).name_to_id.get(&name) == Some(&did)\n     }\n \n-    pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n+    pub fn stability(self) -> &'tcx stability::Index {\n         self.stability_index(())\n     }\n \n@@ -1997,12 +1988,6 @@ impl<'tcx> TyCtxt<'tcx> {\n \n                 writeln!(fmt, \"InternalSubsts interner: #{}\", self.0.interners.substs.len())?;\n                 writeln!(fmt, \"Region interner: #{}\", self.0.interners.region.len())?;\n-                writeln!(fmt, \"Stability interner: #{}\", self.0.interners.stability.len())?;\n-                writeln!(\n-                    fmt,\n-                    \"Const Stability interner: #{}\",\n-                    self.0.interners.const_stability.len()\n-                )?;\n                 writeln!(\n                     fmt,\n                     \"Const Allocation interner: #{}\",\n@@ -2190,8 +2175,6 @@ direct_interners_old! {\n     const_allocation: intern_const_alloc(Allocation),\n     layout: intern_layout(Layout),\n     adt_def: intern_adt_def(AdtDef),\n-    stability: intern_stability(attr::Stability),\n-    const_stability: intern_const_stability(attr::ConstStability),\n }\n \n macro_rules! slice_interners {"}, {"sha": "df3853d8744d620017735cba1a82bf4cb4656ae0", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -87,9 +87,9 @@ impl InheritStability {\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    index: &'a mut Index<'tcx>,\n-    parent_stab: Option<&'tcx Stability>,\n-    parent_const_stab: Option<&'tcx ConstStability>,\n+    index: &'a mut Index,\n+    parent_stab: Option<Stability>,\n+    parent_const_stab: Option<ConstStability>,\n     parent_depr: Option<DeprecationEntry>,\n     in_trait_impl: bool,\n }\n@@ -171,7 +171,6 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         let mut const_span = None;\n \n         let const_stab = const_stab.map(|(const_stab, const_span_node)| {\n-            let const_stab = self.tcx.intern_const_stability(const_stab);\n             self.index.const_stab_map.insert(def_id, const_stab);\n             const_span = Some(const_span_node);\n             const_stab\n@@ -228,7 +227,6 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n             }\n \n             debug!(\"annotate: found {:?}\", stab);\n-            let stab = self.tcx.intern_stability(stab);\n \n             // Check if deprecated_since < stable_since. If it is,\n             // this is *almost surely* an accident.\n@@ -299,8 +297,8 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n     fn recurse_with_stability_attrs(\n         &mut self,\n         depr: Option<DeprecationEntry>,\n-        stab: Option<&'tcx Stability>,\n-        const_stab: Option<&'tcx ConstStability>,\n+        stab: Option<Stability>,\n+        const_stab: Option<ConstStability>,\n         f: impl FnOnce(&mut Self),\n     ) {\n         // These will be `Some` if this item changes the corresponding stability attribute.\n@@ -655,7 +653,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     // stable (assuming they have not inherited instability from their parent).\n }\n \n-fn stability_index<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> Index<'tcx> {\n+fn stability_index(tcx: TyCtxt<'_>, (): ()) -> Index {\n     let is_staged_api =\n         tcx.sess.opts.debugging_opts.force_unstable_if_unmarked || tcx.features().staged_api;\n     let mut staged_api = FxHashMap::default();\n@@ -698,14 +696,14 @@ fn stability_index<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> Index<'tcx> {\n             let reason = \"this crate is being loaded from the sysroot, an \\\n                           unstable location; did you mean to load this crate \\\n                           from crates.io via `Cargo.toml` instead?\";\n-            let stability = tcx.intern_stability(Stability {\n+            let stability = Stability {\n                 level: attr::StabilityLevel::Unstable {\n                     reason: Some(Symbol::intern(reason)),\n                     issue: NonZeroU32::new(27812),\n                     is_soft: false,\n                 },\n                 feature: sym::rustc_private,\n-            });\n+            };\n             annotator.parent_stab = Some(stability);\n         }\n "}, {"sha": "467a6940628e7b74f20b959e48d977fdb9836198", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ccfe2ff1d59666dc0188dfd5847304fec257565/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ccfe2ff1d59666dc0188dfd5847304fec257565/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=7ccfe2ff1d59666dc0188dfd5847304fec257565", "patch": "@@ -381,12 +381,12 @@ crate fn rustc_span(def_id: DefId, tcx: TyCtxt<'_>) -> Span {\n }\n \n impl Item {\n-    crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<&'tcx Stability> {\n+    crate fn stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<Stability> {\n         self.def_id.as_def_id().and_then(|did| tcx.lookup_stability(did))\n     }\n \n     crate fn const_stability<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Option<ConstStability> {\n-        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did)).map(|cs| *cs)\n+        self.def_id.as_def_id().and_then(|did| tcx.lookup_const_stability(did))\n     }\n \n     crate fn deprecation(&self, tcx: TyCtxt<'_>) -> Option<Deprecation> {"}]}