{"sha": "fe93f080515512aae38d943d218346d3bd609b2a", "node_id": "C_kwDOAAsO6NoAKGZlOTNmMDgwNTE1NTEyYWFlMzhkOTQzZDIxODM0NmQzYmQ2MDliMmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-19T18:19:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-19T18:19:51Z"}, "message": "Rollup merge of #93065 - dtolnay:ringbuffer, r=lcnr\n\nPretty printer algorithm revamp step 2\n\nThis PR follows #92923 as a second chunk of modernizations backported from https://github.com/dtolnay/prettyplease into rustc_ast_pretty.\n\nI've broken this up into atomic commits that hopefully are sensible in isolation. At every commit, the pretty printer is compilable and has runtime behavior that is identical to before and after the PR. None of the refactoring so far changes behavior.\n\nThe general theme of this chunk of commits is: the logic in the old pretty printer is doing some very basic things (pushing and popping tokens on a ring buffer) but expressed in a too-low-level way that I found makes it quite complicated/subtle to reason about. There are a number of obvious invariants that are \"almost true\" -- things like `self.left == self.buf.offset` and `self.right == self.buf.offset + self.buf.data.len()` and `self.right_total == self.left_total + self.buf.data.sum()`. The reason these things are \"almost true\" is the implementation tends to put updating one side of the invariant unreasonably far apart from updating the other side, leaving the invariant broken while unrelated stuff happens in between. The following code from master is an example of this:\n\nhttps://github.com/rust-lang/rust/blob/e5e2b0be26ea177527b60d355bd8f56cd473bd00/compiler/rustc_ast_pretty/src/pp.rs#L314-L317\n\nIn this code the `advance_right` is reserving an entry into which to write a next token on the right side of the ring buffer, the `check_stack` is doing something totally unrelated to the right boundary of the ring buffer, and the `scan_push` is actually writing the token we previously reserved space for. Much of what this PR is doing is rearranging code to shrink the amount of stuff in between when an invariant is broken to when it is restored, until the whole thing can be factored out into one indivisible method call on the RingBuffer type.\n\nThe end state of the PR is that we can entirely eliminate `self.left` (because it's now just equal to `self.buf.offset` always) and `self.right` (because it's equal to `self.buf.offset + self.buf.data.len()` always) and the whole `Token::Eof` state which used to be the value of tokens that have been reserved space for but not yet written.\n\nI found without these changes the pretty printer implementation to be hard to reason about and I wasn't able to confidently introduce improvements like trailing commas in `prettyplease` until after this refactor. The logic here is 43 years old at this point (Graydon translated it as directly as possible from the 1979 pretty printing paper) and while there are advantages to following the paper as closely as possible, in `prettyplease` I decided if we're going to adapt the algorithm to work better for Rust syntax, it was worthwhile making it easier to follow than the original.", "tree": {"sha": "c4877c832d4b35063503843f1fded5689aafde85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4877c832d4b35063503843f1fded5689aafde85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe93f080515512aae38d943d218346d3bd609b2a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh6FZHCRBK7hj4Ov3rIwAAzE4IADnn5UuA840JUqW9H9PpBDSE\niBFbYeaKDoLPHAPOgEI5JEWQ6cyL42U+70aFSJzNmE1dN6muxDHKlOCG4V4ScqEP\n2BM0sArbMFmVvq0x9RujQZD+bztMCUvhM1XsESvkkosyB9Ek2R14drLQMkpbLdsW\nmrG6/L24k2EC1dyMLjyQK3pDHH/K8FY85C8d92AOg4pfatiuHD6UawUmHiKmiGvt\n0tRrnJsFosaoOic1lXdKBweTLOS2sCPBuAaEBymzIkFEepf050Blut+qiltlKbyg\n98c80UFF9umKx9mg2lnkd9SDoP11/RyvOpl8PI55AoSdvufwSMfFTjIPLPVZ+0Q=\n=fHrV\n-----END PGP SIGNATURE-----\n", "payload": "tree c4877c832d4b35063503843f1fded5689aafde85\nparent 623791df240d99cfb60aae57bdd65f002a9324ad\nparent 4d3faae5cd34cc3a34a7c01fb2f22c68e092e0eb\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1642616391 +0100\ncommitter GitHub <noreply@github.com> 1642616391 +0100\n\nRollup merge of #93065 - dtolnay:ringbuffer, r=lcnr\n\nPretty printer algorithm revamp step 2\n\nThis PR follows #92923 as a second chunk of modernizations backported from https://github.com/dtolnay/prettyplease into rustc_ast_pretty.\n\nI've broken this up into atomic commits that hopefully are sensible in isolation. At every commit, the pretty printer is compilable and has runtime behavior that is identical to before and after the PR. None of the refactoring so far changes behavior.\n\nThe general theme of this chunk of commits is: the logic in the old pretty printer is doing some very basic things (pushing and popping tokens on a ring buffer) but expressed in a too-low-level way that I found makes it quite complicated/subtle to reason about. There are a number of obvious invariants that are \"almost true\" -- things like `self.left == self.buf.offset` and `self.right == self.buf.offset + self.buf.data.len()` and `self.right_total == self.left_total + self.buf.data.sum()`. The reason these things are \"almost true\" is the implementation tends to put updating one side of the invariant unreasonably far apart from updating the other side, leaving the invariant broken while unrelated stuff happens in between. The following code from master is an example of this:\n\nhttps://github.com/rust-lang/rust/blob/e5e2b0be26ea177527b60d355bd8f56cd473bd00/compiler/rustc_ast_pretty/src/pp.rs#L314-L317\n\nIn this code the `advance_right` is reserving an entry into which to write a next token on the right side of the ring buffer, the `check_stack` is doing something totally unrelated to the right boundary of the ring buffer, and the `scan_push` is actually writing the token we previously reserved space for. Much of what this PR is doing is rearranging code to shrink the amount of stuff in between when an invariant is broken to when it is restored, until the whole thing can be factored out into one indivisible method call on the RingBuffer type.\n\nThe end state of the PR is that we can entirely eliminate `self.left` (because it's now just equal to `self.buf.offset` always) and `self.right` (because it's equal to `self.buf.offset + self.buf.data.len()` always) and the whole `Token::Eof` state which used to be the value of tokens that have been reserved space for but not yet written.\n\nI found without these changes the pretty printer implementation to be hard to reason about and I wasn't able to confidently introduce improvements like trailing commas in `prettyplease` until after this refactor. The logic here is 43 years old at this point (Graydon translated it as directly as possible from the 1979 pretty printing paper) and while there are advantages to following the paper as closely as possible, in `prettyplease` I decided if we're going to adapt the algorithm to work better for Rust syntax, it was worthwhile making it easier to follow than the original.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe93f080515512aae38d943d218346d3bd609b2a", "html_url": "https://github.com/rust-lang/rust/commit/fe93f080515512aae38d943d218346d3bd609b2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe93f080515512aae38d943d218346d3bd609b2a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "623791df240d99cfb60aae57bdd65f002a9324ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/623791df240d99cfb60aae57bdd65f002a9324ad", "html_url": "https://github.com/rust-lang/rust/commit/623791df240d99cfb60aae57bdd65f002a9324ad"}, {"sha": "4d3faae5cd34cc3a34a7c01fb2f22c68e092e0eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d3faae5cd34cc3a34a7c01fb2f22c68e092e0eb", "html_url": "https://github.com/rust-lang/rust/commit/4d3faae5cd34cc3a34a7c01fb2f22c68e092e0eb"}], "stats": {"total": 215, "additions": 103, "deletions": 112}, "files": [{"sha": "bdd70148d85a0d483f638aa7184a0a9c1530aaf4", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 61, "deletions": 97, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=fe93f080515512aae38d943d218346d3bd609b2a", "patch": "@@ -167,14 +167,9 @@ pub enum Token {\n     Break(BreakToken),\n     Begin(BeginToken),\n     End,\n-    Eof,\n }\n \n impl Token {\n-    crate fn is_eof(&self) -> bool {\n-        matches!(self, Token::Eof)\n-    }\n-\n     pub fn is_hardbreak_tok(&self) -> bool {\n         matches!(self, Token::Break(BreakToken { offset: 0, blank_space: SIZE_INFINITY }))\n     }\n@@ -187,7 +182,6 @@ impl fmt::Display for Token {\n             Token::Break(_) => f.write_str(\"BREAK\"),\n             Token::Begin(_) => f.write_str(\"BEGIN\"),\n             Token::End => f.write_str(\"END\"),\n-            Token::Eof => f.write_str(\"EOF\"),\n         }\n     }\n }\n@@ -212,10 +206,6 @@ pub struct Printer {\n     margin: isize,\n     /// Number of spaces left on line\n     space: isize,\n-    /// Index of left side of input stream\n-    left: usize,\n-    /// Index of right side of input stream\n-    right: usize,\n     /// Ring-buffer of tokens and calculated sizes\n     buf: RingBuffer<BufEntry>,\n     /// Running size of stream \"...left\"\n@@ -233,6 +223,9 @@ pub struct Printer {\n     print_stack: Vec<PrintStackElem>,\n     /// Buffered indentation to avoid writing trailing whitespace\n     pending_indentation: isize,\n+    /// The token most recently popped from the left boundary of the\n+    /// ring-buffer for printing\n+    last_printed: Option<Token>,\n }\n \n #[derive(Clone)]\n@@ -241,39 +234,34 @@ struct BufEntry {\n     size: isize,\n }\n \n-impl Default for BufEntry {\n-    fn default() -> Self {\n-        BufEntry { token: Token::Eof, size: 0 }\n-    }\n-}\n-\n impl Printer {\n     pub fn new() -> Self {\n         let linewidth = 78;\n-        let mut buf = RingBuffer::new();\n-        buf.advance_right();\n         Printer {\n             out: String::new(),\n             margin: linewidth as isize,\n             space: linewidth as isize,\n-            left: 0,\n-            right: 0,\n-            buf,\n+            buf: RingBuffer::new(),\n             left_total: 0,\n             right_total: 0,\n             scan_stack: VecDeque::new(),\n             print_stack: Vec::new(),\n             pending_indentation: 0,\n+            last_printed: None,\n         }\n     }\n \n-    pub fn last_token(&self) -> Token {\n-        self.buf[self.right].token.clone()\n+    pub fn last_token(&self) -> Option<&Token> {\n+        self.last_token_still_buffered().or_else(|| self.last_printed.as_ref())\n+    }\n+\n+    pub fn last_token_still_buffered(&self) -> Option<&Token> {\n+        self.buf.last().map(|last| &last.token)\n     }\n \n     /// Be very careful with this!\n-    pub fn replace_last_token(&mut self, t: Token) {\n-        self.buf[self.right].token = t;\n+    pub fn replace_last_token_still_buffered(&mut self, t: Token) {\n+        self.buf.last_mut().unwrap().token = t;\n     }\n \n     fn scan_eof(&mut self) {\n@@ -287,89 +275,63 @@ impl Printer {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n-            self.right = self.left;\n-            self.buf.truncate(1);\n-        } else {\n-            self.advance_right();\n+            self.buf.clear();\n         }\n-        self.scan_push(BufEntry { token: Token::Begin(b), size: -self.right_total });\n+        let right = self.buf.push(BufEntry { token: Token::Begin(b), size: -self.right_total });\n+        self.scan_stack.push_front(right);\n     }\n \n     fn scan_end(&mut self) {\n         if self.scan_stack.is_empty() {\n             self.print_end();\n         } else {\n-            self.advance_right();\n-            self.scan_push(BufEntry { token: Token::End, size: -1 });\n+            let right = self.buf.push(BufEntry { token: Token::End, size: -1 });\n+            self.scan_stack.push_front(right);\n         }\n     }\n \n     fn scan_break(&mut self, b: BreakToken) {\n         if self.scan_stack.is_empty() {\n             self.left_total = 1;\n             self.right_total = 1;\n-            self.right = self.left;\n-            self.buf.truncate(1);\n+            self.buf.clear();\n         } else {\n-            self.advance_right();\n+            self.check_stack(0);\n         }\n-        self.check_stack(0);\n-        self.scan_push(BufEntry { token: Token::Break(b), size: -self.right_total });\n+        let right = self.buf.push(BufEntry { token: Token::Break(b), size: -self.right_total });\n+        self.scan_stack.push_front(right);\n         self.right_total += b.blank_space;\n     }\n \n     fn scan_string(&mut self, s: Cow<'static, str>) {\n         if self.scan_stack.is_empty() {\n-            self.print_string(s);\n+            self.print_string(&s);\n         } else {\n-            self.advance_right();\n             let len = s.len() as isize;\n-            self.buf[self.right] = BufEntry { token: Token::String(s), size: len };\n+            self.buf.push(BufEntry { token: Token::String(s), size: len });\n             self.right_total += len;\n             self.check_stream();\n         }\n     }\n \n     fn check_stream(&mut self) {\n-        if self.right_total - self.left_total > self.space {\n-            if Some(&self.left) == self.scan_stack.back() {\n-                let scanned = self.scan_pop_bottom();\n-                self.buf[scanned].size = SIZE_INFINITY;\n+        while self.right_total - self.left_total > self.space {\n+            if *self.scan_stack.back().unwrap() == self.buf.index_of_first() {\n+                self.scan_stack.pop_back().unwrap();\n+                self.buf.first_mut().unwrap().size = SIZE_INFINITY;\n             }\n             self.advance_left();\n-            if self.left != self.right {\n-                self.check_stream();\n+            if self.buf.is_empty() {\n+                break;\n             }\n         }\n     }\n \n-    fn scan_push(&mut self, entry: BufEntry) {\n-        self.buf[self.right] = entry;\n-        self.scan_stack.push_front(self.right);\n-    }\n-\n-    fn scan_pop(&mut self) -> usize {\n-        self.scan_stack.pop_front().unwrap()\n-    }\n-\n-    fn scan_top(&self) -> usize {\n-        *self.scan_stack.front().unwrap()\n-    }\n-\n-    fn scan_pop_bottom(&mut self) -> usize {\n-        self.scan_stack.pop_back().unwrap()\n-    }\n-\n-    fn advance_right(&mut self) {\n-        self.right += 1;\n-        self.buf.advance_right();\n-    }\n-\n     fn advance_left(&mut self) {\n-        let mut left_size = self.buf[self.left].size;\n+        let mut left_size = self.buf.first().unwrap().size;\n \n         while left_size >= 0 {\n-            let left = self.buf[self.left].token.clone();\n+            let left = self.buf.first().unwrap().token.clone();\n \n             let len = match left {\n                 Token::Break(b) => b.blank_space,\n@@ -385,39 +347,38 @@ impl Printer {\n \n             self.left_total += len;\n \n-            if self.left == self.right {\n+            self.buf.advance_left();\n+            if self.buf.is_empty() {\n                 break;\n             }\n \n-            self.buf.advance_left();\n-            self.left += 1;\n-\n-            left_size = self.buf[self.left].size;\n+            left_size = self.buf.first().unwrap().size;\n         }\n     }\n \n-    fn check_stack(&mut self, k: usize) {\n-        if !self.scan_stack.is_empty() {\n-            let x = self.scan_top();\n-            match self.buf[x].token {\n+    fn check_stack(&mut self, mut k: usize) {\n+        while let Some(&x) = self.scan_stack.front() {\n+            let mut entry = &mut self.buf[x];\n+            match entry.token {\n                 Token::Begin(_) => {\n-                    if k > 0 {\n-                        self.scan_pop();\n-                        self.buf[x].size += self.right_total;\n-                        self.check_stack(k - 1);\n+                    if k == 0 {\n+                        break;\n                     }\n+                    self.scan_stack.pop_front().unwrap();\n+                    entry.size += self.right_total;\n+                    k -= 1;\n                 }\n                 Token::End => {\n                     // paper says + not =, but that makes no sense.\n-                    self.scan_pop();\n-                    self.buf[x].size = 1;\n-                    self.check_stack(k + 1);\n+                    self.scan_stack.pop_front().unwrap();\n+                    entry.size = 1;\n+                    k += 1;\n                 }\n                 _ => {\n-                    self.scan_pop();\n-                    self.buf[x].size += self.right_total;\n-                    if k > 0 {\n-                        self.check_stack(k);\n+                    self.scan_stack.pop_front().unwrap();\n+                    entry.size += self.right_total;\n+                    if k == 0 {\n+                        break;\n                     }\n                 }\n             }\n@@ -477,7 +438,7 @@ impl Printer {\n         }\n     }\n \n-    fn print_string(&mut self, s: Cow<'static, str>) {\n+    fn print_string(&mut self, s: &str) {\n         let len = s.len() as isize;\n         // assert!(len <= space);\n         self.space -= len;\n@@ -491,21 +452,21 @@ impl Printer {\n         self.out.reserve(self.pending_indentation as usize);\n         self.out.extend(std::iter::repeat(' ').take(self.pending_indentation as usize));\n         self.pending_indentation = 0;\n-        self.out.push_str(&s);\n+        self.out.push_str(s);\n     }\n \n     fn print(&mut self, token: Token, l: isize) {\n-        match token {\n-            Token::Begin(b) => self.print_begin(b, l),\n+        match &token {\n+            Token::Begin(b) => self.print_begin(*b, l),\n             Token::End => self.print_end(),\n-            Token::Break(b) => self.print_break(b, l),\n+            Token::Break(b) => self.print_break(*b, l),\n             Token::String(s) => {\n                 let len = s.len() as isize;\n                 assert_eq!(len, l);\n                 self.print_string(s);\n             }\n-            Token::Eof => panic!(), // Eof should never get here.\n         }\n+        self.last_printed = Some(token);\n     }\n \n     // Convenience functions to talk to the printer.\n@@ -560,7 +521,10 @@ impl Printer {\n     }\n \n     pub fn is_beginning_of_line(&self) -> bool {\n-        self.last_token().is_eof() || self.last_token().is_hardbreak_tok()\n+        match self.last_token() {\n+            Some(last_token) => last_token.is_hardbreak_tok(),\n+            None => true,\n+        }\n     }\n \n     pub fn hardbreak_tok_offset(off: isize) -> Token {"}, {"sha": "d20142eb591fe65e3b24c731eb7467bf8d80b1ff", "filename": "compiler/rustc_ast_pretty/src/pp/ring.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp%2Fring.rs?ref=fe93f080515512aae38d943d218346d3bd609b2a", "patch": "@@ -22,20 +22,43 @@ impl<T> RingBuffer<T> {\n         RingBuffer { data: VecDeque::new(), offset: 0 }\n     }\n \n-    pub fn advance_right(&mut self)\n-    where\n-        T: Default,\n-    {\n-        self.data.push_back(T::default());\n+    pub fn is_empty(&self) -> bool {\n+        self.data.is_empty()\n+    }\n+\n+    pub fn push(&mut self, value: T) -> usize {\n+        let index = self.offset + self.data.len();\n+        self.data.push_back(value);\n+        index\n     }\n \n     pub fn advance_left(&mut self) {\n         self.data.pop_front().unwrap();\n         self.offset += 1;\n     }\n \n-    pub fn truncate(&mut self, len: usize) {\n-        self.data.truncate(len);\n+    pub fn clear(&mut self) {\n+        self.data.clear();\n+    }\n+\n+    pub fn index_of_first(&self) -> usize {\n+        self.offset\n+    }\n+\n+    pub fn first(&self) -> Option<&T> {\n+        self.data.front()\n+    }\n+\n+    pub fn first_mut(&mut self) -> Option<&mut T> {\n+        self.data.front_mut()\n+    }\n+\n+    pub fn last(&self) -> Option<&T> {\n+        self.data.back()\n+    }\n+\n+    pub fn last_mut(&mut self) -> Option<&mut T> {\n+        self.data.back_mut()\n     }\n }\n "}, {"sha": "1cbc3162d432645a8bb9260fd4c280bc2d62222c", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe93f080515512aae38d943d218346d3bd609b2a/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=fe93f080515512aae38d943d218346d3bd609b2a", "patch": "@@ -328,9 +328,9 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n             CommentStyle::BlankLine => {\n                 // We need to do at least one, possibly two hardbreaks.\n                 let twice = match self.last_token() {\n-                    pp::Token::String(s) => \";\" == s,\n-                    pp::Token::Begin(_) => true,\n-                    pp::Token::End => true,\n+                    Some(pp::Token::String(s)) => \";\" == s,\n+                    Some(pp::Token::Begin(_)) => true,\n+                    Some(pp::Token::End) => true,\n                     _ => false,\n                 };\n                 if twice {\n@@ -686,11 +686,15 @@ pub trait PrintState<'a>: std::ops::Deref<Target = pp::Printer> + std::ops::Dere\n     fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n         if !self.is_beginning_of_line() {\n             self.break_offset(n, off)\n-        } else if off != 0 && self.last_token().is_hardbreak_tok() {\n-            // We do something pretty sketchy here: tuck the nonzero\n-            // offset-adjustment we were going to deposit along with the\n-            // break into the previous hardbreak.\n-            self.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n+        } else if off != 0 {\n+            if let Some(last_token) = self.last_token_still_buffered() {\n+                if last_token.is_hardbreak_tok() {\n+                    // We do something pretty sketchy here: tuck the nonzero\n+                    // offset-adjustment we were going to deposit along with the\n+                    // break into the previous hardbreak.\n+                    self.replace_last_token_still_buffered(pp::Printer::hardbreak_tok_offset(off));\n+                }\n+            }\n         }\n     }\n "}]}