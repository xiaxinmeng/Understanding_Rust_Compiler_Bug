{"sha": "0dad78e03d411a5bae4a7aa20eda93231634a095", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYWQ3OGUwM2Q0MTFhNWJhZTRhN2FhMjBlZGE5MzIzMTYzNGEwOTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-24T00:39:07Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-25T03:45:30Z"}, "message": "Eliminate match checks in trans and typeck", "tree": {"sha": "8215ff6a07d96c8397ae72fb344e3087702510a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8215ff6a07d96c8397ae72fb344e3087702510a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0dad78e03d411a5bae4a7aa20eda93231634a095", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0dad78e03d411a5bae4a7aa20eda93231634a095", "html_url": "https://github.com/rust-lang/rust/commit/0dad78e03d411a5bae4a7aa20eda93231634a095", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0dad78e03d411a5bae4a7aa20eda93231634a095/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18180fd5dac16582474b5ec0fd49ebb03f7f939d", "url": "https://api.github.com/repos/rust-lang/rust/commits/18180fd5dac16582474b5ec0fd49ebb03f7f939d", "html_url": "https://github.com/rust-lang/rust/commit/18180fd5dac16582474b5ec0fd49ebb03f7f939d"}], "stats": {"total": 348, "additions": 216, "deletions": 132}, "files": [{"sha": "ab9efdacc290b24955561eda222363217578a908", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -1 +1 @@\n-Subproject commit b55be285d18e9b3537fc9d29af44e83be2171326\n+Subproject commit ab9efdacc290b24955561eda222363217578a908"}, {"sha": "2f7badd49d1da65ed7d2630208c8483b57de5469", "filename": "src/rustc/driver/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fsession.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -189,7 +189,7 @@ impl session {\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    fn impossible_case(sp: span, msg: ~str) -> ! {\n+    fn impossible_case(sp: span, msg: &str) -> ! {\n         self.span_bug(sp, #fmt(\"Impossible case reached: %s\", msg));\n     }\n     fn ppregions() -> bool { self.debugging_opt(ppregions) }"}, {"sha": "b67e490863de38bcb1c73d1e986ede32d3b8cd1b", "filename": "src/rustc/middle/trans/alt.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Falt.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -305,10 +305,10 @@ fn extract_variant_args(bcx: block, pat_id: ast::node_id,\n    {vals: ~[ValueRef], bcx: block} {\n     let _icx = bcx.insn_ctxt(\"alt::extract_variant_args\");\n     let ccx = bcx.fcx.ccx;\n-    let enum_ty_substs = match check ty::get(node_id_type(bcx, pat_id))\n+    let enum_ty_substs = match ty::get(node_id_type(bcx, pat_id))\n         .struct {\n-\n       ty::ty_enum(id, substs) => { assert id == vdefs.enm; substs.tps }\n+      _ => bcx.sess().bug(~\"extract_variant_args: pattern has non-enum type\")\n     };\n     let mut blobptr = val;\n     let variants = ty::enum_variants(ccx.tcx, vdefs.enm);\n@@ -667,11 +667,13 @@ fn compile_submatch(bcx: block, m: match_, vals: ~[ValueRef],\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n               switch => {\n-                match check trans_opt(bcx, opt) {\n+                match trans_opt(bcx, opt) {\n                   single_result(r) => {\n                     llvm::LLVMAddCase(sw, r.val, opt_cx.llbb);\n                     bcx = r.bcx;\n                   }\n+                  _ => bcx.sess().bug(~\"in compile_submatch, expected \\\n+                         trans_opt to return a single_result\")\n                 }\n               }\n               compare => {\n@@ -892,7 +894,8 @@ fn trans_alt_inner(scope_cx: block, expr: @ast::expr, arms: ~[ast::arm],\n                 let arm_dest = dup_for_join(dest);\n                 vec::push(arm_dests, arm_dest);\n                 let mut arm_cx = trans_block(body_cx, a.body, arm_dest);\n-                arm_cx = trans_block_cleanups(arm_cx, body_cx);\n+                arm_cx = trans_block_cleanups(arm_cx,\n+                                              block_cleanups(body_cx));\n                 vec::push(arm_cxs, arm_cx);\n             }\n         }"}, {"sha": "02f3c74972a582d480ac2ed6b582f06e98cfab89", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 99, "deletions": 64, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -1962,7 +1962,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n     let else_cx = scope_block(bcx, els.info(), ~\"else\");\n     CondBr(bcx, cond_val, then_cx.llbb, else_cx.llbb);\n     let then_bcx = trans_block(then_cx, thn, then_dest);\n-    let then_bcx = trans_block_cleanups(then_bcx, then_cx);\n+    let then_bcx = trans_block_cleanups(then_bcx, block_cleanups(then_cx));\n     // Calling trans_block directly instead of trans_expr\n     // because trans_expr will create another scope block\n     // context for the block, but we've already got the\n@@ -1983,7 +1983,7 @@ fn trans_if(cx: block, cond: @ast::expr, thn: ast::blk,\n       }\n       _ => else_cx\n     };\n-    let else_bcx = trans_block_cleanups(else_bcx, else_cx);\n+    let else_bcx = trans_block_cleanups(else_bcx, block_cleanups(else_cx));\n     return join_returns(cx,\n                      ~[then_bcx, else_bcx], ~[then_dest, else_dest], dest);\n }\n@@ -1998,7 +1998,8 @@ fn trans_while(cx: block, cond: @ast::expr, body: ast::blk)\n     Br(cx, loop_cx.llbb);\n     Br(loop_cx, cond_cx.llbb);\n     let cond_res = trans_temp_expr(cond_cx, cond);\n-    let cond_bcx = trans_block_cleanups(cond_res.bcx, cond_cx);\n+    let cond_bcx = trans_block_cleanups(cond_res.bcx,\n+                                        block_cleanups(cond_cx));\n     CondBr(cond_bcx, cond_res.val, body_cx.llbb, next_cx.llbb);\n     let body_end = trans_block(body_cx, body, ignore);\n     cleanup_and_Br(body_end, body_cx, cond_cx.llbb);\n@@ -2113,19 +2114,19 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                   _ => ()\n                 }\n             }\n-            mono_precise(subst, if v.len() > 0u { some(v) } else { none })\n+            (subst, if v.len() > 0u { some(v) } else { none })\n         })\n       }\n       none => {\n-        vec::map(substs, |subst| mono_precise(subst, none))\n+        vec::map(substs, |subst| (subst, none))\n       }\n     };\n     let param_ids = match param_uses {\n       some(uses) => {\n         vec::map2(precise_param_ids, uses, |id, uses| {\n-            match check id {\n-              mono_precise(_, some(_)) => id,\n-              mono_precise(subst, none) => {\n+            match id {\n+                (a, b@some(_)) => mono_precise(a, b),\n+              (subst, none) => {\n                 if uses == 0u { mono_any }\n                 else if uses == type_use::use_repr &&\n                         !ty::type_needs_drop(ccx.tcx, subst) {\n@@ -2137,12 +2138,13 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: ~[ty::t],\n                     if size == 1u && ty::type_is_nil(subst) {\n                         mono_repr(0u, 0u)\n                     } else { mono_repr(size, align) }\n-                } else { id }\n+                } else { mono_precise(subst, none) }\n               }\n             }\n         })\n       }\n-      none => precise_param_ids\n+      none => precise_param_ids.map(|x| { let (a, b) = x;\n+                mono_precise(a, b) })\n     };\n     @{def: item, params: param_ids}\n }\n@@ -2367,7 +2369,7 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n           csearch::found_parent(parent_id, ast::ii_item(item)) => {\n             ccx.external.insert(parent_id, some(item.id));\n             let mut my_id = 0;\n-            match check item.node {\n+            match item.node {\n               ast::item_enum(_, _) => {\n                 let vs_here = ty::enum_variants(ccx.tcx, local_def(item.id));\n                 let vs_there = ty::enum_variants(ccx.tcx, parent_id);\n@@ -2376,6 +2378,8 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n                     ccx.external.insert(there.id, some(here.id.node));\n                 }\n               }\n+              _ => ccx.sess.bug(~\"maybe_instantiate_inline: item has a \\\n+                    non-enum parent\")\n             }\n             trans_item(ccx, *item);\n             local_def(my_id)\n@@ -2756,7 +2760,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n             let ccx = cx.ccx();\n             let sub = trans_temp_expr(cx, base);\n             let t = expr_ty(cx, base);\n-            let val = match check ty::get(t).struct {\n+            let val = match ty::get(t).struct {\n               ty::ty_box(_) => {\n                 let non_gc_val = non_gc_box_cast(sub.bcx, sub.val);\n                 GEPi(sub.bcx, non_gc_val, ~[0u, abi::box_field_body])\n@@ -2770,7 +2774,9 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n                 let ellty = T_ptr(type_of(ccx, ety));\n                 PointerCast(sub.bcx, sub.val, ellty)\n               }\n-              ty::ty_ptr(_) | ty::ty_rptr(_,_) => sub.val\n+              ty::ty_ptr(_) | ty::ty_rptr(_,_) => sub.val,\n+              _ => cx.sess().impossible_case(e.span, #fmt(\"unary operand \\\n+                may not have type %s\", cx.ty_to_str(t)))\n             };\n             return lval_owned(sub.bcx, val);\n           }\n@@ -2917,22 +2923,13 @@ fn trans_cast(cx: block, e: @ast::expr, id: ast::node_id,\n     return store_in_dest(e_res.bcx, newval, dest);\n }\n \n-fn trans_loop_body(bcx: block, e: @ast::expr, ret_flag: option<ValueRef>,\n+fn trans_loop_body(bcx: block, id: ast::node_id,\n+                   decl: ast::fn_decl, body: ast::blk,\n+                   proto: ty::fn_proto, cap: ast::capture_clause,\n+                   ret_flag: option<ValueRef>,\n                    dest: dest) -> block {\n-    match check e.node {\n-      ast::expr_loop_body(b@@{\n-        node: ast::expr_fn_block(decl, body, cap),\n-        _\n-      }) => {\n-        match check ty::get(expr_ty(bcx, e)).struct {\n-          ty::ty_fn({proto, _}) => {\n-            closure::trans_expr_fn(bcx, proto, decl, body, b.id,\n-                                   cap, some(ret_flag),\n-                                   dest)\n-          }\n-        }\n-      }\n-    }\n+    closure::trans_expr_fn(bcx, proto, decl, body, id,\n+                           cap, some(ret_flag), dest)\n }\n \n // temp_cleanups: cleanups that should run only if failure occurs before the\n@@ -2950,12 +2947,21 @@ fn trans_arg_expr(cx: block, arg: ty::arg, lldestty: TypeRef, e: @ast::expr,\n     // translate the arg expr as an lvalue\n     let lv = match ret_flag {\n       // If there is a ret_flag, this *must* be a loop body\n-      some(_) => match check e.node {\n-        ast::expr_loop_body(blk) => {\n+      some(_) => match e.node {\n+          ast::expr_loop_body(blk@@{node:\n+                  ast::expr_fn_block(decl, body, cap),_}) => {\n             let scratch = alloc_ty(cx, expr_ty(cx, blk));\n-            let bcx = trans_loop_body(cx, e, ret_flag, save_in(scratch));\n+            let proto = match ty::get(expr_ty(cx, e)).struct {\n+                ty::ty_fn({proto, _}) => proto,\n+                _ => cx.sess().impossible_case(e.span, ~\"Loop body has \\\n+                       non-fn ty\")\n+            };\n+            let bcx = trans_loop_body(cx, blk.id, decl, body, proto,\n+                                      cap, ret_flag, save_in(scratch));\n             {bcx: bcx, val: scratch, kind: lv_temporary}\n         }\n+        _ => cx.sess().impossible_case(e.span, ~\"ret_flag with non-loop-\\\n+              body expr\")\n       },\n       none => {\n         trans_temp_lval(cx, e)\n@@ -3462,21 +3468,25 @@ fn trans_tup(bcx: block, elts: ~[@ast::expr], dest: dest) -> block {\n \n fn trans_rec(bcx: block, fields: ~[ast::field],\n              base: option<@ast::expr>, id: ast::node_id,\n-             dest: dest) -> block {\n+             // none = ignore; some(x) = save_in(x)\n+             dest: option<ValueRef>) -> block {\n     let _icx = bcx.insn_ctxt(\"trans_rec\");\n     let t = node_id_type(bcx, id);\n     let mut bcx = bcx;\n-    let addr = match check dest {\n-      ignore => {\n+    let addr = match dest {\n+      none => {\n         for vec::each(fields) |fld| {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n         return bcx;\n       }\n-      save_in(pos) => pos\n+      some(pos) => pos\n     };\n \n-    let ty_fields = match check ty::get(t).struct { ty::ty_rec(f) => f };\n+    let ty_fields = match ty::get(t).struct {\n+        ty::ty_rec(f) => f,\n+        _ => bcx.sess().bug(~\"trans_rec: record has non-record type\")\n+    };\n \n     let mut temp_cleanups = ~[];\n     for fields.each |fld| {\n@@ -3797,7 +3807,13 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             };\n           }\n           ast::expr_rec(args, base) => {\n-            return trans_rec(bcx, args, base, e.id, dest);\n+              let d = match dest {\n+                  ignore => none,\n+                  save_in(p) => some(p),\n+                  _ => bcx.sess().impossible_case(e.span,\n+                        \"trans_expr::unrooted: can't pass a record by val\")\n+              };\n+            return trans_rec(bcx, args, base, e.id, d);\n           }\n           ast::expr_struct(_, fields, base) => {\n             return trans_struct(bcx, e.span, fields, base, e.id, dest);\n@@ -3849,18 +3865,33 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n                                           dest);\n           }\n           ast::expr_fn_block(decl, body, cap_clause) => {\n-            match check ty::get(expr_ty(bcx, e)).struct {\n+            match ty::get(expr_ty(bcx, e)).struct {\n               ty::ty_fn({proto, _}) => {\n                 debug!(\"translating fn_block %s with type %s\",\n                        expr_to_str(e, tcx.sess.intr()),\n                        ppaux::ty_to_str(tcx, expr_ty(bcx, e)));\n                 return closure::trans_expr_fn(bcx, proto, decl, body,\n                                            e.id, cap_clause, none, dest);\n               }\n+              _ =>  bcx.sess().impossible_case(e.span, \"fn_block has \\\n+                         body with a non-fn type\")\n             }\n           }\n-          ast::expr_loop_body(_) => {\n-            return trans_loop_body(bcx, e, none, dest);\n+          ast::expr_loop_body(blk) => {\n+              match ty::get(expr_ty(bcx, e)).struct {\n+                  ty::ty_fn({proto, _}) => {\n+                      match blk.node {\n+                          ast::expr_fn_block(decl, body, cap) =>\n+                            return trans_loop_body(bcx, blk.id, decl, body,\n+                                                   proto, cap, none, dest),\n+                          _ => bcx.sess().impossible_case(e.span, \"loop_body \\\n+                                 has the wrong kind of contents\")\n+                      }\n+\n+                  }\n+                  _ => bcx.sess().impossible_case(e.span, \"loop_body has \\\n+                         body with a non-fn type\")\n+              }\n           }\n           ast::expr_do_body(blk) => {\n             return trans_expr(bcx, blk, dest);\n@@ -4436,19 +4467,18 @@ fn raw_block(fcx: fn_ctxt, is_lpad: bool, llbb: BasicBlockRef) -> block {\n // need to make sure those variables go out of scope when the block ends.  We\n // do that by running a 'cleanup' function for each variable.\n // trans_block_cleanups runs all the cleanup functions for the block.\n-fn trans_block_cleanups(bcx: block, cleanup_cx: block) -> block {\n-    trans_block_cleanups_(bcx, cleanup_cx, false)\n+fn trans_block_cleanups(bcx: block, +cleanups: ~[cleanup]) -> block {\n+    trans_block_cleanups_(bcx, cleanups, false)\n }\n \n-fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n+fn trans_block_cleanups_(bcx: block,\n+                         +cleanups: ~[cleanup],\n+                         /* cleanup_cx: block, */ is_lpad: bool) ->\n    block {\n     let _icx = bcx.insn_ctxt(\"trans_block_cleanups\");\n     if bcx.unreachable { return bcx; }\n     let mut bcx = bcx;\n-    match check cleanup_cx.kind {\n-      block_scope({cleanups, _}) => {\n-        let cleanups = copy cleanups;\n-        do vec::riter(cleanups) |cu| {\n+    do vec::riter(cleanups) |cu| {\n             match cu {\n               clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n@@ -4458,9 +4488,7 @@ fn trans_block_cleanups_(bcx: block, cleanup_cx: block, is_lpad: bool) ->\n                 }\n               }\n             }\n-        }\n-      }\n-    }\n+            }\n     return bcx;\n }\n \n@@ -4491,7 +4519,7 @@ fn cleanup_and_leave(bcx: block, upto: option<BasicBlockRef>,\n             let sub_cx = sub_block(bcx, ~\"cleanup\");\n             Br(bcx, sub_cx.llbb);\n             vec::push(inf.cleanup_paths, {target: leave, dest: sub_cx.llbb});\n-            bcx = trans_block_cleanups_(sub_cx, cur, is_lpad);\n+            bcx = trans_block_cleanups_(sub_cx, block_cleanups(cur), is_lpad);\n           }\n           _ => ()\n         }\n@@ -4906,8 +4934,9 @@ fn trans_enum_variant(ccx: @crate_ctxt,\n         // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n-        let llarg = match check fcx.llargs.find(va.id) {\n-          some(local_mem(x)) => x\n+        let llarg = match fcx.llargs.find(va.id) {\n+            some(local_mem(x)) => x,\n+            _ => fail ~\"trans_enum_variant: how do we know this works?\",\n         };\n         let arg_ty = arg_tys[i].ty;\n         memmove_ty(bcx, lldestptr, llarg, arg_ty);\n@@ -5052,8 +5081,10 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n \n fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n     let _icx = ccx.insn_ctxt(\"trans_item\");\n-    let path = match check ccx.tcx.items.get(item.id) {\n-      ast_map::node_item(_, p) => p\n+    let path = match ccx.tcx.items.get(item.id) {\n+        ast_map::node_item(_, p) => p,\n+        // tjc: ?\n+        _ => fail ~\"trans_item\",\n     };\n     match item.node {\n       ast::item_fn(decl, purity, tps, body) => {\n@@ -5288,8 +5319,10 @@ fn fill_fn_pair(bcx: block, pair: ValueRef, llfn: ValueRef,\n \n fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n     vec::append(\n-        *match check ccx.tcx.items.get(i.id) {\n-            ast_map::node_item(_, p) => p\n+        *match ccx.tcx.items.get(i.id) {\n+            ast_map::node_item(_, p) => p,\n+                // separate map for paths?\n+            _ => fail ~\"item_path\"\n         },\n         ~[path_name(i.ident)])\n }\n@@ -5340,7 +5373,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n         let val = match ccx.tcx.items.get(id) {\n           ast_map::node_item(i, pth) => {\n             let my_path = vec::append(*pth, ~[path_name(i.ident)]);\n-            match check i.node {\n+            match i.node {\n               ast::item_const(_, _) => {\n                 let typ = ty::node_id_to_type(ccx.tcx, i.id);\n                 let s = mangle_exported_name(ccx, my_path, typ);\n@@ -5359,6 +5392,7 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                 set_inline_hint_if_appr(i.attrs, llfn);\n                 llfn\n               }\n+              _ => fail ~\"get_item_val: weird result in table\"\n             }\n           }\n           ast_map::node_trait_method(trait_method, _, pth) => {\n@@ -5417,10 +5451,11 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n                     let pth = vec::append(*pth,\n                                           ~[path_name(enm.ident),\n                                             path_name(v.node.name)]);\n-                    llfn = match check enm.node {\n+                    llfn = match enm.node {\n                       ast::item_enum(_, _) => {\n                         register_fn(ccx, v.span, pth, id)\n                       }\n+                      _ => fail ~\"node_variant, shouldn't happen\"\n                     };\n                 }\n                 ast::struct_variant_kind(_) => {\n@@ -5733,11 +5768,11 @@ fn crate_ctxt_to_encode_parms(cx: @crate_ctxt)\n         for cx.exp_map.each |exp_id, defs| {\n             for defs.each |def| {\n                 if !def.reexp { again; }\n-                let path = match check cx.tcx.items.get(exp_id) {\n-                    ast_map::node_export(_, path) => {\n-                        ast_map::path_to_str(*path,\n-                                             cx.sess.parse_sess.interner)\n-                    }\n+                let path = match cx.tcx.items.get(exp_id) {\n+                  ast_map::node_export(_, path) => {\n+                      ast_map::path_to_str(*path, cx.sess.parse_sess.interner)\n+                  }\n+                  _ => fail ~\"reexports\"\n                 };\n                 vec::push(reexports, (path, def.id));\n             }"}, {"sha": "f5ba581e3fe986bb0595b2195106520b9feeb13f", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -368,6 +368,13 @@ fn revoke_clean(cx: block, val: ValueRef) {\n     }\n }\n \n+fn block_cleanups(bcx: block) -> ~[cleanup] {\n+    match bcx.kind {\n+       block_non_scope  => ~[],\n+       block_scope(inf) => inf.cleanups\n+    }\n+}\n+\n enum block_kind {\n     // A scope at the end of which temporary values created inside of it are\n     // cleaned up. May correspond to an actual block in the language, but also"}, {"sha": "8a2ac2ae156cd0f223e6362f6915751d0431549e", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -399,7 +399,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: ~[ast::ty_field],\n                                line_from_span(cx.sess.codemap,\n                                               span) as int);\n     for fields.each |field| {\n-        let field_t = ty::get_field(t, field.node.ident).mt.ty;\n+        let field_t = ty::get_field(cx.tcx, t, field.node.ident).mt.ty;\n         let ty_md = create_ty(cx, field_t, field.node.mt.ty);\n         let (size, align) = size_and_align_of(cx, field_t);\n         add_member(scx, cx.sess.str_of(field.node.ident),"}, {"sha": "8f7881a4d7a00b24a5eb2cf997469bce479565e9", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -925,8 +925,9 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n         let tp_sz = shape::llsize_of_real(ccx, lltp_ty),\n             out_sz = shape::llsize_of_real(ccx, llout_ty);\n         if tp_sz != out_sz {\n-            let sp = match check ccx.tcx.items.get(option::get(ref_id)) {\n-              ast_map::node_expr(e) => e.span\n+            let sp = match ccx.tcx.items.get(option::get(ref_id)) {\n+              ast_map::node_expr(e) => e.span,\n+              _ => fail ~\"reinterpret_cast or forget has non-expr arg\"\n             };\n             ccx.sess.span_fatal(\n                 sp, fmt!(\"reinterpret_cast called on types \\\n@@ -981,6 +982,8 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                                arg_vals(~[frameaddress_val]), ignore);\n       }\n       _ => {\n+      // Could we make this an enum rather than a string? does it get\n+      // checked earlier?\n           ccx.sess.span_bug(item.span, ~\"unknown intrinsic\");\n       }\n     }\n@@ -1171,8 +1174,10 @@ fn register_foreign_fn(ccx: @crate_ctxt, sp: span,\n fn abi_of_foreign_fn(ccx: @crate_ctxt, i: @ast::foreign_item)\n     -> ast::foreign_abi {\n     match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n-      none => match check ccx.tcx.items.get(i.id) {\n-        ast_map::node_foreign_item(_, abi, _) => abi\n+      none => match ccx.tcx.items.get(i.id) {\n+        ast_map::node_foreign_item(_, abi, _) => abi,\n+        // ??\n+        _ => fail ~\"abi_of_foreign_fn: not foreign\"\n       },\n       some(_) => match attr::foreign_abi(i.attrs) {\n         either::Right(abi) => abi,"}, {"sha": "20e5bee430515b794efa68a69c8fe7a367e8f6ed", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -125,12 +125,14 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n       }\n       typeck::method_param({trait_id:trait_id, method_num:off,\n                             param_num:p, bound_num:b}) => {\n-        match check bcx.fcx.param_substs {\n+        match bcx.fcx.param_substs {\n           some(substs) => {\n             let vtbl = find_vtable_in_fn_ctxt(substs, p, b);\n             trans_monomorphized_callee(bcx, callee_id, self, mentry,\n                                        trait_id, off, vtbl)\n           }\n+          // how to get rid of this?\n+          none => fail ~\"trans_method_callee: missing param_substs\"\n         }\n       }\n       typeck::method_trait(_, off) => {\n@@ -150,10 +152,11 @@ fn trans_static_method_callee(bcx: block, method_id: ast::def_id,\n     let ccx = bcx.ccx();\n \n     let mname = if method_id.crate == ast::local_crate {\n-        match check bcx.tcx().items.get(method_id.node) {\n+        match bcx.tcx().items.get(method_id.node) {\n           ast_map::node_trait_method(trait_method, _, _) => {\n             ast_util::trait_method_to_ty_method(*trait_method).ident\n           }\n+          _ => fail ~\"callee is not a trait method\"\n         }\n     } else {\n         let path = csearch::get_item_path(bcx.tcx(), method_id);\n@@ -200,14 +203,15 @@ fn method_from_methods(ms: ~[@ast::method], name: ast::ident)\n fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n-        match check ccx.tcx.items.get(impl_id.node) {\n+        match ccx.tcx.items.get(impl_id.node) {\n           ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n             method_from_methods(ms, name)\n           }\n           ast_map::node_item(@{node:\n               ast::item_class(struct_def, _), _}, _) => {\n             method_from_methods(struct_def.methods, name)\n           }\n+          _ => fail ~\"method_with_name\"\n         }\n     } else {\n         csearch::get_impl_method(ccx.sess.cstore, impl_id, name)\n@@ -217,8 +221,9 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                          i_id: ast::def_id) -> uint {\n     if m_id.crate == ast::local_crate {\n-        match check ccx.tcx.items.get(m_id.node) {\n+        match ccx.tcx.items.get(m_id.node) {\n           ast_map::node_method(m, _, _) => vec::len(m.tps),\n+          _ => fail ~\"method_ty_param_count\"\n         }\n     } else {\n         csearch::get_type_param_count(ccx.sess.cstore, m_id) -\n@@ -321,18 +326,19 @@ fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::vtable_origin)\n                               resolve_vtables_in_fn_ctxt(fcx, sub))\n       }\n       typeck::vtable_param(n_param, n_bound) => {\n-        match check fcx.param_substs {\n+        match fcx.param_substs {\n           some(substs) => {\n             find_vtable_in_fn_ctxt(substs, n_param, n_bound)\n           }\n+          _ => fail ~\"resolve_vtable_in_fn_ctxt: no substs\"\n         }\n       }\n       _ => vt\n     }\n }\n \n fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n-    match check origin {\n+    match origin {\n       typeck::vtable_static(impl_id, substs, sub_vtables) => {\n         make_mono_id(ccx, impl_id, substs,\n                      if (*sub_vtables).len() == 0u { none }\n@@ -342,6 +348,8 @@ fn vtable_id(ccx: @crate_ctxt, origin: typeck::vtable_origin) -> mono_id {\n         @{def: trait_id,\n           params: vec::map(substs, |t| mono_precise(t, none))}\n       }\n+      // can't this be checked at the callee?\n+      _ => fail ~\"vtable_id\"\n     }\n }\n \n@@ -350,10 +358,11 @@ fn get_vtable(ccx: @crate_ctxt, origin: typeck::vtable_origin)\n     let hash_id = vtable_id(ccx, origin);\n     match ccx.vtables.find(hash_id) {\n       some(val) => val,\n-      none => match check origin {\n+      none => match origin {\n         typeck::vtable_static(id, substs, sub_vtables) => {\n             make_impl_vtable(ccx, id, substs, sub_vtables)\n         }\n+        _ => fail ~\"get_vtable: expected a static origin\"\n       }\n     }\n }"}, {"sha": "0e5997a0d3aeb97521271dd3bc850c22f987f1d0", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -95,13 +95,13 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_estr(ty::vstore_uniq) => {\n         T_unique_ptr(T_unique(cx, T_vec(cx, T_i8())))\n       }\n-      ty::ty_enum(*) => {\n+      ty::ty_enum(did, substs) => {\n         // Only create the named struct, but don't fill it in. We\n         // fill it in *after* placing it into the type cache. This\n         // avoids creating more than one copy of the enum when one\n         // of the enum's variants refers to the enum itself.\n \n-        common::T_named_struct(llvm_type_name(cx, t))\n+        common::T_named_struct(llvm_type_name(cx, an_enum, did, substs.tps))\n       }\n       ty::ty_estr(ty::vstore_box) => {\n         T_box_ptr(T_box(cx, T_vec(cx, T_i8())))\n@@ -158,12 +158,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(tys)\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n-      ty::ty_class(*) => {\n+      ty::ty_class(did, substs) => {\n         // Only create the named struct, but don't fill it in. We fill it\n         // in *after* placing it into the type cache. This prevents\n         // infinite recursion with recursive class types.\n \n-        common::T_named_struct(llvm_type_name(cx, t))\n+        common::T_named_struct(llvm_type_name(cx, a_class, did, substs.tps))\n       }\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_var(_) => cx.tcx.sess.bug(~\"type_of with ty_var\"),\n@@ -223,14 +223,18 @@ fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n     common::set_struct_body(llty, lltys);\n }\n \n-fn llvm_type_name(cx: @crate_ctxt, t: ty::t) -> ~str {\n-    let (name, did, tps) = match check ty::get(t).struct {\n-      ty::ty_enum(did, substs) => (~\"enum\", did, substs.tps),\n-      ty::ty_class(did, substs) => (~\"class\", did, substs.tps)\n-    };\n+// Want refinements! (Or case classes, I guess\n+enum named_ty { a_class, an_enum }\n+\n+fn llvm_type_name(cx: @crate_ctxt,\n+                  what: named_ty,\n+                  did: ast::def_id,\n+                  tps: ~[ty::t]\n+                  ) -> ~str {\n+    let name = match what { a_class => { \"~class\" } an_enum => { \"~enum\" } };\n     return fmt!(\n         \"%s %s[#%d]\",\n-        name,\n+          name,\n         util::ppaux::parameterized(\n             cx.tcx,\n             ty::item_path_str(cx.tcx, did),"}, {"sha": "9b8f6cb96e0d6077e052543fad5f263ff24af7ef", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -97,6 +97,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n               ~\"visit_tydesc\" | ~\"forget\" | ~\"addr_of\" => {\n                 0u\n               }\n+              // would be cool to make these an enum instead of strings!\n               _ => fail ~\"unknown intrinsic in type_use\"\n             };\n             for uint::range(0u, n_tps) |n| { cx.uses[n] |= flags;}\n@@ -255,8 +256,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n             }\n         })\n       }\n-      expr_match(_, _, _) | expr_block(_) | expr_if(_, _, _) |\n-      expr_while(_, _) | expr_fail(_) | expr_break(_) | expr_again(_) |\n+      expr_match(*) | expr_block(_) | expr_if(*) |\n+      expr_while(*) | expr_fail(_) | expr_break(_) | expr_again(_) |\n       expr_unary(_, _) | expr_lit(_) | expr_assert(_) |\n       expr_mac(_) | expr_addr_of(_, _) |\n       expr_ret(_) | expr_loop(_, _) |"}, {"sha": "5cda414f3a91b1235fe0a077a6b087c6b4d03121", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -2503,15 +2503,20 @@ fn field_idx(id: ast::ident, fields: ~[field]) -> option<uint> {\n     return none;\n }\n \n-fn get_field(rec_ty: t, id: ast::ident) -> field {\n-    match check vec::find(get_fields(rec_ty), |f| f.ident == id) {\n-      some(f) => f\n+fn get_field(tcx: ctxt, rec_ty: t, id: ast::ident) -> field {\n+    match vec::find(get_fields(rec_ty), |f| f.ident == id) {\n+      some(f) => f,\n+      // Do we only call this when we know the field is legit?\n+      none => fail (#fmt(\"get_field: ty doesn't have a field %s\",\n+                         tcx.sess.str_of(id)))\n     }\n }\n \n fn get_fields(rec_ty:t) -> ~[field] {\n-    match check get(rec_ty).struct {\n-      ty_rec(fields) => fields\n+    match get(rec_ty).struct {\n+      ty_rec(fields) => fields,\n+      // Can we check at the caller?\n+      _ => fail ~\"get_fields: not a record type\"\n     }\n }\n \n@@ -2805,6 +2810,9 @@ fn trait_methods(cx: ctxt, id: ast::def_id) -> @~[method] {\n     }\n }\n \n+/*\n+  Could this return a list of (def_id, substs) pairs?\n+ */\n fn impl_traits(cx: ctxt, id: ast::def_id) -> ~[t] {\n     if id.crate == ast::local_crate {\n         debug!(\"(impl_traits) searching for trait impl %?\", id);"}, {"sha": "9563163c70647ee79d09755b116b5a60c8c2bcfe", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -177,10 +177,12 @@ fn check_bare_fn(ccx: @crate_ctxt,\n                  id: ast::node_id,\n                  self_info: option<self_info>) {\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n-    match check ty::get(fty).struct {\n+    match ty::get(fty).struct {\n         ty::ty_fn(ref fn_ty) => {\n             check_fn(ccx, self_info, fn_ty, decl, body, false, none)\n         }\n+        _ => ccx.tcx.sess.impossible_case(body.span,\n+                                 \"check_bare_fn: function type expected\")\n     }\n }\n \n@@ -803,7 +805,7 @@ fn impl_self_ty(fcx: @fn_ctxt,\n \n     let {n_tps, region_param, raw_ty} = if did.crate == ast::local_crate {\n         let region_param = fcx.tcx().region_paramd_items.find(did.node);\n-        match check tcx.items.find(did.node) {\n+        match tcx.items.find(did.node) {\n           some(ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                   _}, _)) => {\n             {n_tps: ts.len(),\n@@ -1597,7 +1599,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx.write_ty(id, ty::mk_nil(tcx));\n         bot = !may_break(body);\n       }\n-      ast::expr_match(discrim, arms, _) => {\n+      ast::expr_match(discrim, arms, mode) => {\n         bot = alt::check_alt(fcx, expr, discrim, arms);\n       }\n       ast::expr_fn(proto, decl, body, cap_clause) => {\n@@ -1640,22 +1642,25 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                             type\");\n           }\n         };\n-        match check b.node {\n+        match b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n             check_expr_fn(fcx, b, none,\n                           decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n+          // argh\n+          _ => fail ~\"expr_fn_block\"\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        match check ty::get(block_ty).struct {\n+        match ty::get(block_ty).struct {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, {output: ty::mk_bool(tcx)\n                                                   with fty}));\n           }\n+          _ => fail ~\"expected fn type\"\n         }\n       }\n       ast::expr_do_body(b) => {\n@@ -1670,21 +1675,24 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n               passed to a `do` function\");\n           }\n         };\n-        match check b.node {\n+        match b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n             check_expr_fn(fcx, b, none,\n                           decl, body, true,\n                           some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n+          // argh\n+          _ => fail ~\"expected fn ty\"\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        match check ty::get(block_ty).struct {\n+        match ty::get(block_ty).struct {\n           ty::ty_fn(fty) => {\n             fcx.write_ty(expr.id, ty::mk_fn(tcx, fty));\n           }\n+          _ => fail ~\"expected fn ty\"\n         }\n       }\n       ast::expr_block(b) => {"}, {"sha": "6e254958539f2dd3256ea011cc524b274c4dcf34", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -222,8 +222,9 @@ struct lookup {\n \n     fn report_static_candidate(idx: uint, did: ast::def_id) {\n         let span = if did.crate == ast::local_crate {\n-            match check self.tcx().items.get(did.node) {\n+            match self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) => m.span,\n+              _ => fail ~\"report_static_candidate: bad item\"\n             }\n         } else {\n             self.expr.span\n@@ -297,8 +298,9 @@ struct lookup {\n                 again; /* ok */\n               }\n               ty::bound_trait(bound_t) => {\n-                match check ty::get(bound_t).struct {\n-                  ty::ty_trait(i, substs, _) => (i, substs)\n+                match ty::get(bound_t).struct {\n+                  ty::ty_trait(i, substs, _) => (i, substs),\n+                  _ => fail ~\"add_candidates_from_param: non-trait bound\"\n                 }\n               }\n             };\n@@ -402,11 +404,12 @@ struct lookup {\n     }\n \n     fn ty_from_did(did: ast::def_id) -> ty::t {\n-        match check ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n+        match ty::get(ty::lookup_item_type(self.tcx(), did).ty).struct {\n           ty::ty_fn(fty) => {\n             ty::mk_fn(self.tcx(),\n                       {proto: ty::proto_vstore(ty::vstore_box) with fty})\n           }\n+          _ => fail ~\"ty_from_did: not function ty\"\n         }\n         /*\n         if did.crate == ast::local_crate {"}, {"sha": "fc177c6c8b842c679d34c98eddde95aae847c6b8", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -15,9 +15,9 @@ fn replace_bound_regions_in_fn_ty(\n \n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n-    let self_ty = match self_info {\n-      some(s) => some(s.self_ty),\n-      none => none\n+    let (self_ty, rebuild_self_info) = match self_info {\n+      some(s) => (some(s.self_ty), |t| some({self_ty: t with s})),\n+      none => (none, |_t| none)\n     };\n \n     let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n@@ -59,22 +59,15 @@ fn replace_bound_regions_in_fn_ty(\n \n \n     // Glue updated self_ty back together with its original def_id.\n-    let new_self_info = match self_info {\n-        some(s) => {\n-            match t_self {\n-                some(t) => some({self_ty: t with s}),\n-                none => {\n-                    tcx.sess.bug(~\"unexpected t_self in \\\n-                                   replace_bound_regions_in_fn_ty()\");\n-                }\n-            }\n-        },\n-        none => none\n+    let new_self_info: option<self_info> = match t_self {\n+      none    => none,\n+      some(t) => rebuild_self_info(t)\n     };\n \n     return {isr: isr,\n          self_info: new_self_info,\n-         fn_ty: match check ty::get(t_fn).struct { ty::ty_fn(o) => o }};\n+         fn_ty: match ty::get(t_fn).struct { ty::ty_fn(o) => o,\n+          _ => tcx.sess.bug(~\"replace_bound_regions_in_fn_ty: impossible\")}};\n \n \n     // Takes `isr`, a (possibly empty) mapping from in-scope region"}, {"sha": "e10d7b5c1408e767d110b1aedba5a61d9bf7cb9c", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0dad78e03d411a5bae4a7aa20eda93231634a095/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=0dad78e03d411a5bae4a7aa20eda93231634a095", "patch": "@@ -59,8 +59,9 @@ fn fixup_substs(fcx: @fn_ctxt, expr: @ast::expr,\n     // use a dummy type just to package up the substs that need fixing up\n     let t = ty::mk_trait(tcx, id, substs, ty::vstore_slice(ty::re_static));\n     do fixup_ty(fcx, expr, t, is_early).map |t_f| {\n-        match check ty::get(t_f).struct {\n+        match ty::get(t_f).struct {\n           ty::ty_trait(_, substs_f, _) => substs_f,\n+          _ => fail ~\"t_f should be a trait\"\n         }\n     }\n }\n@@ -88,8 +89,10 @@ fn lookup_vtable(fcx: @fn_ctxt,\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;\n-    let (trait_id, trait_substs) = match check ty::get(trait_ty).struct {\n-      ty::ty_trait(did, substs, _) => (did, substs)\n+    let (trait_id, trait_substs) = match ty::get(trait_ty).struct {\n+      ty::ty_trait(did, substs, _) => (did, substs),\n+      _ => tcx.sess.impossible_case(expr.span, \"lookup_vtable: \\\n+             don't know how to handle a non-trait ty\")\n     };\n     let ty = match fixup_ty(fcx, expr, ty, is_early) {\n       some(ty) => ty,\n@@ -105,15 +108,15 @@ fn lookup_vtable(fcx: @fn_ctxt,\n \n     match ty::get(ty).struct {\n       ty::ty_param({idx: n, def_id: did}) => {\n-        let mut n_bound = 0u;\n+        let mut n_bound = 0;\n         for vec::each(*tcx.ty_param_bounds.get(did.node)) |bound| {\n             match bound {\n               ty::bound_send | ty::bound_copy | ty::bound_const |\n               ty::bound_owned => {\n                 /* ignore */\n               }\n               ty::bound_trait(ity) => {\n-                match check ty::get(ity).struct {\n+                match ty::get(ity).struct {\n                   ty::ty_trait(idid, substs, _) => {\n                     if trait_id == idid {\n                         debug!(\"(checking vtable) @0 relating ty to trait ty\n@@ -122,6 +125,9 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                         return vtable_param(n, n_bound);\n                     }\n                   }\n+                  _ => tcx.sess.impossible_case(expr.span,\n+                         \"lookup_vtable: in loop, \\\n+                         don't know how to handle a non-trait ity\")\n                 }\n                 n_bound += 1u;\n               }\n@@ -277,11 +283,13 @@ fn connect_trait_tps(fcx: @fn_ctxt, expr: @ast::expr, impl_tys: ~[ty::t],\n     let trait_ty = ty::subst_tps(tcx, impl_tys, ity);\n     debug!(\"(connect trait tps) trait type is %?, impl did is %?\",\n            ty::get(trait_ty).struct, impl_did);\n-    match check ty::get(trait_ty).struct {\n-      ty::ty_trait(_, substs, _) => {\n+    match ty::get(trait_ty).struct {\n+     ty::ty_trait(_, substs, _) => {\n         vec::iter2(substs.tps, trait_tys,\n                    |a, b| demand::suptype(fcx, expr.span, a, b));\n       }\n+     _ => tcx.sess.impossible_case(expr.span, \"connect_trait_tps: \\\n+            don't know how to handle a non-trait ty\")\n     }\n }\n "}]}