{"sha": "1aaf9aec95a61b636c21b79702cfd4bd86be9379", "node_id": "C_kwDOAAsO6NoAKDFhYWY5YWVjOTVhNjFiNjM2YzIxYjc5NzAyY2ZkNGJkODZiZTkzNzk", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2022-09-02T09:34:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-02T09:34:48Z"}, "message": "Rollup merge of #100147 - Bryanskiy:private-in-public, r=petrochenkov\n\noptimization of access level table construction\n\nRefactoring which was mentioned in #87487", "tree": {"sha": "a7e639ee6df8f33770b890dbf1e385f4e1ee3cf8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7e639ee6df8f33770b890dbf1e385f4e1ee3cf8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1aaf9aec95a61b636c21b79702cfd4bd86be9379", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjEc44CRBK7hj4Ov3rIwAAcA8IAJF3cgf65SqoaWL133CNrhrb\ndVAusJaRH+g7egI25tOh52ARFk2x9kvS7a0pq4nYJOlSWeoSiNFo63O+DYaXSwhp\n2iHaf47j+12Z7DJqBl0h8ofhMaVtEyb5Fx8Rc+LFCUu/sQw4FLSHhE7sEfHRT5lM\nOewK8caSmAphMiuX+fICjSwzeYSh2FlIb/XDCEwhdu/urx3o2PoSJ5yRzZ6LBvWr\nq7a3nO7S9xNBD1nNGVtA2u5nxx6smtwu9tC+pEBuyIM3w1egWdNl5sV8KPUTH5Yo\n0TbOphIp5JGnbLYoRBv8NmSJLrZmM15fWxshiMbmosaRB/HyJhatISyDtF1mJVw=\n=QYqp\n-----END PGP SIGNATURE-----\n", "payload": "tree a7e639ee6df8f33770b890dbf1e385f4e1ee3cf8\nparent 0e82dc969f714e19278178d199d67b54fb9c0e8e\nparent 0111fb00dac90d67f8d770ca2a25923cfd24e25d\nauthor Guillaume Gomez <guillaume1.gomez@gmail.com> 1662111288 +0200\ncommitter GitHub <noreply@github.com> 1662111288 +0200\n\nRollup merge of #100147 - Bryanskiy:private-in-public, r=petrochenkov\n\noptimization of access level table construction\n\nRefactoring which was mentioned in #87487\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1aaf9aec95a61b636c21b79702cfd4bd86be9379", "html_url": "https://github.com/rust-lang/rust/commit/1aaf9aec95a61b636c21b79702cfd4bd86be9379", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1aaf9aec95a61b636c21b79702cfd4bd86be9379/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e82dc969f714e19278178d199d67b54fb9c0e8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e82dc969f714e19278178d199d67b54fb9c0e8e", "html_url": "https://github.com/rust-lang/rust/commit/0e82dc969f714e19278178d199d67b54fb9c0e8e"}, {"sha": "0111fb00dac90d67f8d770ca2a25923cfd24e25d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0111fb00dac90d67f8d770ca2a25923cfd24e25d", "html_url": "https://github.com/rust-lang/rust/commit/0111fb00dac90d67f8d770ca2a25923cfd24e25d"}], "stats": {"total": 451, "additions": 326, "deletions": 125}, "files": [{"sha": "da987152ff66030dcdbba447d15dce67950c45b9", "filename": "compiler/rustc_error_messages/locales/en-US/privacy.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fprivacy.ftl?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -11,6 +11,8 @@ privacy_in_public_interface = {$vis_descr} {$kind} `{$descr}` in public interfac\n     .label = can't leak {$vis_descr} {$kind}\n     .visibility_label = `{$descr}` declared as {$vis_descr}\n \n+privacy_report_access_level = {$descr}\n+\n privacy_from_private_dep_in_public_interface =\n     {$kind} `{$descr}` from private dependency '{$krate}' in public interface\n "}, {"sha": "0c88379d498994845bee2bc7e019617e471a096b", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -758,6 +758,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // Internal attributes, Testing:\n     // ==========================================================================\n \n+    rustc_attr!(TEST, rustc_access_level, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_outlives, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_capture_analysis, Normal, template!(Word), WarnFollowing),\n     rustc_attr!(TEST, rustc_insignificant_dtor, Normal, template!(Word), WarnFollowing),"}, {"sha": "63f83f8965ec52c8a56e15123549eea3369dfef0", "filename": "compiler/rustc_privacy/src/errors.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Ferrors.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -75,6 +75,14 @@ pub struct InPublicInterface<'a> {\n     pub vis_span: Span,\n }\n \n+#[derive(SessionDiagnostic)]\n+#[diag(privacy::report_access_level)]\n+pub struct ReportAccessLevel {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: String,\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(privacy::from_private_dep_in_public_interface)]\n pub struct FromPrivateDependencyInPublicInterface<'a> {"}, {"sha": "ba69bc23118b2527921188cdf8f7a595a97bef8b", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -33,7 +33,7 @@ use rustc_middle::ty::{self, Const, DefIdTree, GenericParamDefKind};\n use rustc_middle::ty::{TraitRef, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, Ident};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;\n@@ -42,7 +42,8 @@ use std::{cmp, fmt, mem};\n \n use errors::{\n     FieldIsPrivate, FieldIsPrivateLabel, FromPrivateDependencyInPublicInterface, InPublicInterface,\n-    InPublicInterfaceTraits, ItemIsPrivate, PrivateInPublicLint, UnnamedItemIsPrivate,\n+    InPublicInterfaceTraits, ItemIsPrivate, PrivateInPublicLint, ReportAccessLevel,\n+    UnnamedItemIsPrivate,\n };\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -907,6 +908,60 @@ impl<'tcx> DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx>\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+/// Visitor, used for AccessLevels table checking\n+////////////////////////////////////////////////////////////////////////////////\n+pub struct TestReachabilityVisitor<'tcx, 'a> {\n+    tcx: TyCtxt<'tcx>,\n+    access_levels: &'a AccessLevels,\n+}\n+\n+impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n+    fn access_level_diagnostic(&mut self, def_id: LocalDefId) {\n+        if self.tcx.has_attr(def_id.to_def_id(), sym::rustc_access_level) {\n+            let access_level = format!(\"{:?}\", self.access_levels.map.get(&def_id));\n+            let span = self.tcx.def_span(def_id.to_def_id());\n+            self.tcx.sess.emit_err(ReportAccessLevel { span, descr: access_level });\n+        }\n+    }\n+}\n+\n+impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        self.access_level_diagnostic(item.def_id);\n+\n+        match item.kind {\n+            hir::ItemKind::Enum(ref def, _) => {\n+                for variant in def.variants.iter() {\n+                    let variant_id = self.tcx.hir().local_def_id(variant.id);\n+                    self.access_level_diagnostic(variant_id);\n+                    for field in variant.data.fields() {\n+                        let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                        self.access_level_diagnostic(def_id);\n+                    }\n+                }\n+            }\n+            hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n+                for field in def.fields() {\n+                    let def_id = self.tcx.hir().local_def_id(field.hir_id);\n+                    self.access_level_diagnostic(def_id);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem<'tcx>) {\n+        self.access_level_diagnostic(item.def_id);\n+    }\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem<'tcx>) {\n+        self.access_level_diagnostic(item.def_id);\n+    }\n+    fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n+        self.access_level_diagnostic(item.def_id);\n+    }\n+}\n+\n //////////////////////////////////////////////////////////////////////////////////////\n /// Name privacy visitor, checks privacy and reports violations.\n /// Most of name privacy checks are performed during the main resolution phase,\n@@ -2045,6 +2100,9 @@ fn privacy_access_levels(tcx: TyCtxt<'_>, (): ()) -> &AccessLevels {\n         }\n     }\n \n+    let mut check_visitor = TestReachabilityVisitor { tcx, access_levels: &visitor.access_levels };\n+    tcx.hir().visit_all_item_likes_in_crate(&mut check_visitor);\n+\n     tcx.arena.alloc(visitor.access_levels)\n }\n "}, {"sha": "0a3add2e0f5328a7e7ff90ff20630d12408484e1", "filename": "compiler/rustc_resolve/src/access_levels.rs", "status": "modified", "additions": 53, "deletions": 105, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Faccess_levels.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -1,25 +1,21 @@\n+use crate::imports::ImportKind;\n+use crate::NameBinding;\n+use crate::NameBindingKind;\n+use crate::Resolver;\n use rustc_ast::ast;\n use rustc_ast::visit;\n use rustc_ast::visit::Visitor;\n use rustc_ast::Crate;\n use rustc_ast::EnumDef;\n-use rustc_ast::ForeignMod;\n use rustc_ast::NodeId;\n use rustc_hir::def_id::LocalDefId;\n use rustc_hir::def_id::CRATE_DEF_ID;\n use rustc_middle::middle::privacy::AccessLevel;\n-use rustc_middle::ty::Visibility;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n-use crate::imports::ImportKind;\n-use crate::BindingKey;\n-use crate::NameBinding;\n-use crate::NameBindingKind;\n-use crate::Resolver;\n-\n pub struct AccessLevelsVisitor<'r, 'a> {\n     r: &'r mut Resolver<'a>,\n-    prev_level: Option<AccessLevel>,\n     changed: bool,\n }\n \n@@ -28,11 +24,10 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n     /// For now, this doesn't resolve macros (FIXME) and cannot resolve Impl, as we\n     /// need access to a TyCtxt for that.\n     pub fn compute_access_levels<'c>(r: &'r mut Resolver<'a>, krate: &'c Crate) {\n-        let mut visitor =\n-            AccessLevelsVisitor { r, changed: false, prev_level: Some(AccessLevel::Public) };\n+        let mut visitor = AccessLevelsVisitor { r, changed: false };\n \n         visitor.set_access_level_def_id(CRATE_DEF_ID, Some(AccessLevel::Public));\n-        visitor.set_exports_access_level(CRATE_DEF_ID);\n+        visitor.set_bindings_access_level(CRATE_DEF_ID);\n \n         while visitor.changed {\n             visitor.reset();\n@@ -44,15 +39,17 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n \n     fn reset(&mut self) {\n         self.changed = false;\n-        self.prev_level = Some(AccessLevel::Public);\n     }\n \n-    /// Update the access level of the exports of the given module accordingly. The module access\n+    /// Update the access level of the bindings in the given module accordingly. The module access\n     /// level has to be Exported or Public.\n     /// This will also follow `use` chains (see PrivacyVisitor::set_import_binding_access_level).\n-    fn set_exports_access_level(&mut self, module_id: LocalDefId) {\n+    fn set_bindings_access_level(&mut self, module_id: LocalDefId) {\n         assert!(self.r.module_map.contains_key(&&module_id.to_def_id()));\n-\n+        let module_level = self.r.access_levels.map.get(&module_id).copied();\n+        if !module_level.is_some() {\n+            return;\n+        }\n         // Set the given binding access level to `AccessLevel::Public` and\n         // sets the rest of the `use` chain to `AccessLevel::Exported` until\n         // we hit the actual exported item.\n@@ -72,28 +69,20 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n                 }\n             };\n \n-        let module_level = self.r.access_levels.map.get(&module_id).copied();\n-        assert!(module_level >= Some(AccessLevel::Exported));\n-\n-        if let Some(exports) = self.r.reexport_map.get(&module_id) {\n-            let pub_exports = exports\n-                .iter()\n-                .filter(|ex| ex.vis == Visibility::Public)\n-                .cloned()\n-                .collect::<Vec<_>>();\n-\n-            let module = self.r.get_module(module_id.to_def_id()).unwrap();\n-            for export in pub_exports.into_iter() {\n-                if let Some(export_def_id) = export.res.opt_def_id().and_then(|id| id.as_local()) {\n-                    self.set_access_level_def_id(export_def_id, Some(AccessLevel::Exported));\n-                }\n-\n-                if let Some(ns) = export.res.ns() {\n-                    let key = BindingKey { ident: export.ident, ns, disambiguator: 0 };\n-                    let name_res = self.r.resolution(module, key);\n-                    if let Some(binding) = name_res.borrow().binding() {\n-                        set_import_binding_access_level(self, binding, module_level)\n-                    }\n+        let module = self.r.get_module(module_id.to_def_id()).unwrap();\n+        let resolutions = self.r.resolutions(module);\n+\n+        for (.., name_resolution) in resolutions.borrow().iter() {\n+            if let Some(binding) = name_resolution.borrow().binding() && binding.vis.is_public() && !binding.is_ambiguity() {\n+                let access_level = match binding.is_import() {\n+                    true => {\n+                        set_import_binding_access_level(self, binding, module_level);\n+                        Some(AccessLevel::Exported)\n+                    },\n+                    false => module_level,\n+                };\n+                if let Some(def_id) = binding.res().opt_def_id().and_then(|id| id.as_local()) {\n+                    self.set_access_level_def_id(def_id, access_level);\n                 }\n             }\n         }\n@@ -127,97 +116,59 @@ impl<'r, 'a> AccessLevelsVisitor<'r, 'a> {\n \n impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n     fn visit_item(&mut self, item: &'ast ast::Item) {\n-        let inherited_item_level = match item.kind {\n+        let def_id = self.r.local_def_id(item.id);\n+        // Set access level of nested items.\n+        // If it's a mod, also make the visitor walk all of its items\n+        match item.kind {\n             // Resolved in rustc_privacy when types are available\n             ast::ItemKind::Impl(..) => return,\n \n-            // Only exported `macro_rules!` items are public, but they always are\n-            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n-                let is_macro_export =\n-                    item.attrs.iter().any(|attr| attr.has_name(sym::macro_export));\n-                if is_macro_export { Some(AccessLevel::Public) } else { None }\n-            }\n-\n-            // Foreign modules inherit level from parents.\n-            ast::ItemKind::ForeignMod(..) => self.prev_level,\n-\n-            // Other `pub` items inherit levels from parents.\n-            ast::ItemKind::ExternCrate(..)\n-            | ast::ItemKind::Use(..)\n-            | ast::ItemKind::Static(..)\n-            | ast::ItemKind::Const(..)\n-            | ast::ItemKind::Fn(..)\n-            | ast::ItemKind::Mod(..)\n-            | ast::ItemKind::GlobalAsm(..)\n-            | ast::ItemKind::TyAlias(..)\n-            | ast::ItemKind::Enum(..)\n-            | ast::ItemKind::Struct(..)\n-            | ast::ItemKind::Union(..)\n-            | ast::ItemKind::Trait(..)\n-            | ast::ItemKind::TraitAlias(..)\n-            | ast::ItemKind::MacroDef(..) => {\n-                if item.vis.kind.is_pub() {\n-                    self.prev_level\n-                } else {\n-                    None\n-                }\n-            }\n-\n             // Should be unreachable at this stage\n             ast::ItemKind::MacCall(..) => panic!(\n                 \"ast::ItemKind::MacCall encountered, this should not anymore appear at this stage\"\n             ),\n-        };\n \n-        let access_level = self.set_access_level(item.id, inherited_item_level);\n+            // Foreign modules inherit level from parents.\n+            ast::ItemKind::ForeignMod(..) => {\n+                let parent_level =\n+                    self.r.access_levels.map.get(&self.r.local_parent(def_id)).copied();\n+                self.set_access_level(item.id, parent_level);\n+            }\n \n-        // Set access level of nested items.\n-        // If it's a mod, also make the visitor walk all of its items\n-        match item.kind {\n-            ast::ItemKind::Mod(..) => {\n-                if access_level.is_some() {\n-                    self.set_exports_access_level(self.r.local_def_id(item.id));\n+            // Only exported `macro_rules!` items are public, but they always are\n+            ast::ItemKind::MacroDef(ref macro_def) if macro_def.macro_rules => {\n+                if item.attrs.iter().any(|attr| attr.has_name(sym::macro_export)) {\n+                    self.set_access_level(item.id, Some(AccessLevel::Public));\n                 }\n+            }\n \n-                let orig_level = std::mem::replace(&mut self.prev_level, access_level);\n+            ast::ItemKind::Mod(..) => {\n+                self.set_bindings_access_level(def_id);\n                 visit::walk_item(self, item);\n-                self.prev_level = orig_level;\n             }\n \n-            ast::ItemKind::ForeignMod(ForeignMod { ref items, .. }) => {\n-                for nested in items {\n-                    if nested.vis.kind.is_pub() {\n-                        self.set_access_level(nested.id, access_level);\n-                    }\n-                }\n-            }\n             ast::ItemKind::Enum(EnumDef { ref variants }, _) => {\n+                self.set_bindings_access_level(def_id);\n                 for variant in variants {\n-                    let variant_level = self.set_access_level(variant.id, access_level);\n-                    if let Some(ctor_id) = variant.data.ctor_id() {\n-                        self.set_access_level(ctor_id, access_level);\n-                    }\n-\n+                    let variant_def_id = self.r.local_def_id(variant.id);\n+                    let variant_level = self.r.access_levels.map.get(&variant_def_id).copied();\n                     for field in variant.data.fields() {\n                         self.set_access_level(field.id, variant_level);\n                     }\n                 }\n             }\n-            ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n-                if let Some(ctor_id) = def.ctor_id() {\n-                    self.set_access_level(ctor_id, access_level);\n-                }\n \n+            ast::ItemKind::Struct(ref def, _) | ast::ItemKind::Union(ref def, _) => {\n+                let inherited_level = self.r.access_levels.map.get(&def_id).copied();\n                 for field in def.fields() {\n                     if field.vis.kind.is_pub() {\n-                        self.set_access_level(field.id, access_level);\n+                        self.set_access_level(field.id, inherited_level);\n                     }\n                 }\n             }\n-            ast::ItemKind::Trait(ref trait_kind) => {\n-                for nested in trait_kind.items.iter() {\n-                    self.set_access_level(nested.id, access_level);\n-                }\n+\n+            ast::ItemKind::Trait(..) => {\n+                self.set_bindings_access_level(def_id);\n             }\n \n             ast::ItemKind::ExternCrate(..)\n@@ -229,9 +180,6 @@ impl<'r, 'ast> Visitor<'ast> for AccessLevelsVisitor<'ast, 'r> {\n             | ast::ItemKind::TraitAlias(..)\n             | ast::ItemKind::MacroDef(..)\n             | ast::ItemKind::Fn(..) => return,\n-\n-            // Unreachable kinds\n-            ast::ItemKind::Impl(..) | ast::ItemKind::MacCall(..) => unreachable!(),\n         }\n     }\n }"}, {"sha": "27745cee52df7f3243630d103984205ecbb9db78", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -1133,24 +1133,15 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         if let Some(def_id) = module.opt_def_id() {\n             let mut reexports = Vec::new();\n \n-            module.for_each_child(self.r, |_, ident, _, binding| {\n-                // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n-                // into the crate root to actual `NameBindingKind::Import`.\n-                if binding.is_import()\n-                    || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n-                {\n-                    let res = binding.res().expect_non_local();\n-                    // Ambiguous imports are treated as errors at this point and are\n-                    // not exposed to other crates (see #36837 for more details).\n-                    if res != def::Res::Err && !binding.is_ambiguity() {\n-                        reexports.push(ModChild {\n-                            ident,\n-                            res,\n-                            vis: binding.vis,\n-                            span: binding.span,\n-                            macro_rules: false,\n-                        });\n-                    }\n+            module.for_each_child(self.r, |this, ident, _, binding| {\n+                if let Some(res) = this.is_reexport(binding) {\n+                    reexports.push(ModChild {\n+                        ident,\n+                        res,\n+                        vis: binding.vis,\n+                        span: binding.span,\n+                        macro_rules: false,\n+                    });\n                 }\n             });\n "}, {"sha": "a15a0c298a9522940402fda5716bbe39fdeb0933", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -2020,6 +2020,24 @@ impl<'a> Resolver<'a> {\n         }\n         self.main_def = Some(MainDefinition { res, is_import, span });\n     }\n+\n+    // Items that go to reexport table encoded to metadata and visible through it to other crates.\n+    fn is_reexport(&self, binding: &NameBinding<'a>) -> Option<def::Res<!>> {\n+        // FIXME: Consider changing the binding inserted by `#[macro_export] macro_rules`\n+        // into the crate root to actual `NameBindingKind::Import`.\n+        if binding.is_import()\n+            || matches!(binding.kind, NameBindingKind::Res(_, _is_macro_export @ true))\n+        {\n+            let res = binding.res().expect_non_local();\n+            // Ambiguous imports are treated as errors at this point and are\n+            // not exposed to other crates (see #36837 for more details).\n+            if res != def::Res::Err && !binding.is_ambiguity() {\n+                return Some(res);\n+            }\n+        }\n+\n+        return None;\n+    }\n }\n \n fn names_to_string(names: &[Symbol]) -> String {"}, {"sha": "be954334313494da2be6a62ebc78faba2d63cec1", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -1209,6 +1209,7 @@ symbols! {\n         rust_eh_unregister_frames,\n         rust_oom,\n         rustc,\n+        rustc_access_level,\n         rustc_allocator,\n         rustc_allocator_nounwind,\n         rustc_allocator_zeroed,"}, {"sha": "d51d2b57267b6f6686692e252dffac0801642f18", "filename": "src/test/ui/privacy/access_levels.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.rs?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -0,0 +1,49 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_access_level] mod outer { //~ ERROR None\n+    #[rustc_access_level] pub mod inner { //~ ERROR Some(Exported)\n+        #[rustc_access_level]\n+        extern \"C\" { //~ ERROR Some(Exported)\n+            #[rustc_access_level] static a: u8; //~ ERROR None\n+            #[rustc_access_level] pub fn b(); //~ ERROR Some(Exported)\n+        }\n+        #[rustc_access_level]\n+        pub trait Trait { //~ ERROR Some(Exported)\n+            #[rustc_access_level] const A: i32; //~ ERROR Some(Exported)\n+            #[rustc_access_level] type B; //~ ERROR Some(Exported)\n+        }\n+\n+        #[rustc_access_level]\n+        pub struct Struct { //~ ERROR Some(Exported)\n+            #[rustc_access_level] a: u8, //~ ERROR None\n+            #[rustc_access_level] pub b: u8, //~ ERROR Some(Exported)\n+        }\n+\n+        #[rustc_access_level]\n+        pub union Union { //~ ERROR Some(Exported)\n+            #[rustc_access_level] a: u8, //~ ERROR None\n+            #[rustc_access_level] pub b: u8, //~ ERROR Some(Exported)\n+        }\n+\n+        #[rustc_access_level]\n+        pub enum Enum { //~ ERROR Some(Exported)\n+            #[rustc_access_level] A( //~ ERROR Some(Exported)\n+                #[rustc_access_level] Struct, //~ ERROR Some(Exported)\n+                #[rustc_access_level] Union,  //~ ERROR Some(Exported)\n+            ),\n+        }\n+    }\n+\n+    #[rustc_access_level] macro_rules! none_macro { //~ ERROR None\n+        () => {};\n+    }\n+\n+    #[macro_export]\n+    #[rustc_access_level] macro_rules! public_macro { //~ ERROR Some(Public)\n+        () => {};\n+    }\n+}\n+\n+pub use outer::inner;\n+\n+fn main() {}"}, {"sha": "f326293c384a5ae824c03a00cfc400a0c6cd2b0e", "filename": "src/test/ui/privacy/access_levels.stderr", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1aaf9aec95a61b636c21b79702cfd4bd86be9379/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1aaf9aec95a61b636c21b79702cfd4bd86be9379/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Faccess_levels.stderr?ref=1aaf9aec95a61b636c21b79702cfd4bd86be9379", "patch": "@@ -0,0 +1,125 @@\n+error: None\n+  --> $DIR/access_levels.rs:3:23\n+   |\n+LL | #[rustc_access_level] mod outer {\n+   |                       ^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:4:27\n+   |\n+LL |     #[rustc_access_level] pub mod inner {\n+   |                           ^^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:6:9\n+   |\n+LL | /         extern \"C\" {\n+LL | |             #[rustc_access_level] static a: u8;\n+LL | |             #[rustc_access_level] pub fn b();\n+LL | |         }\n+   | |_________^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:11:9\n+   |\n+LL |         pub trait Trait {\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:17:9\n+   |\n+LL |         pub struct Struct {\n+   |         ^^^^^^^^^^^^^^^^^\n+\n+error: None\n+  --> $DIR/access_levels.rs:18:35\n+   |\n+LL |             #[rustc_access_level] a: u8,\n+   |                                   ^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:19:35\n+   |\n+LL |             #[rustc_access_level] pub b: u8,\n+   |                                   ^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:23:9\n+   |\n+LL |         pub union Union {\n+   |         ^^^^^^^^^^^^^^^\n+\n+error: None\n+  --> $DIR/access_levels.rs:24:35\n+   |\n+LL |             #[rustc_access_level] a: u8,\n+   |                                   ^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:25:35\n+   |\n+LL |             #[rustc_access_level] pub b: u8,\n+   |                                   ^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:29:9\n+   |\n+LL |         pub enum Enum {\n+   |         ^^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:30:35\n+   |\n+LL |             #[rustc_access_level] A(\n+   |                                   ^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:31:39\n+   |\n+LL |                 #[rustc_access_level] Struct,\n+   |                                       ^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:32:39\n+   |\n+LL |                 #[rustc_access_level] Union,\n+   |                                       ^^^^^\n+\n+error: None\n+  --> $DIR/access_levels.rs:37:27\n+   |\n+LL |     #[rustc_access_level] macro_rules! none_macro {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Some(Public)\n+  --> $DIR/access_levels.rs:42:27\n+   |\n+LL |     #[rustc_access_level] macro_rules! public_macro {\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:12:35\n+   |\n+LL |             #[rustc_access_level] const A: i32;\n+   |                                   ^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:13:35\n+   |\n+LL |             #[rustc_access_level] type B;\n+   |                                   ^^^^^^\n+\n+error: None\n+  --> $DIR/access_levels.rs:7:35\n+   |\n+LL |             #[rustc_access_level] static a: u8;\n+   |                                   ^^^^^^^^^^^^\n+\n+error: Some(Exported)\n+  --> $DIR/access_levels.rs:8:35\n+   |\n+LL |             #[rustc_access_level] pub fn b();\n+   |                                   ^^^^^^^^^^\n+\n+error: aborting due to 20 previous errors\n+"}]}