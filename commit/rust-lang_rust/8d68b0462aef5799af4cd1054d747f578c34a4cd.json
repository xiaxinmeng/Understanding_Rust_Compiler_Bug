{"sha": "8d68b0462aef5799af4cd1054d747f578c34a4cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNjhiMDQ2MmFlZjU3OTlhZjRjZDEwNTRkNzQ3ZjU3OGMzNGE0Y2Q=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-13T09:33:46Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-13T09:33:46Z"}, "message": "Refactor out some repetetive code in trans_alt", "tree": {"sha": "33f4d51a1a99c824fda59e0a7cebae3b36c70ae9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33f4d51a1a99c824fda59e0a7cebae3b36c70ae9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d68b0462aef5799af4cd1054d747f578c34a4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d68b0462aef5799af4cd1054d747f578c34a4cd", "html_url": "https://github.com/rust-lang/rust/commit/8d68b0462aef5799af4cd1054d747f578c34a4cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d68b0462aef5799af4cd1054d747f578c34a4cd/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be4f7354b475ff8e80a81b495640d7e46d7094cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/be4f7354b475ff8e80a81b495640d7e46d7094cc", "html_url": "https://github.com/rust-lang/rust/commit/be4f7354b475ff8e80a81b495640d7e46d7094cc"}], "stats": {"total": 105, "additions": 46, "deletions": 59}, "files": [{"sha": "d61a72564f6d53a991a093eebcfd6c9e47ac1172", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 46, "deletions": 59, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8d68b0462aef5799af4cd1054d747f578c34a4cd/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d68b0462aef5799af4cd1054d747f578c34a4cd/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=8d68b0462aef5799af4cd1054d747f578c34a4cd", "patch": "@@ -84,63 +84,61 @@ fn bind_for_pat(&@ast::pat p, &match_branch br, ValueRef val) {\n     }\n }\n \n-fn enter_default(&match m, uint col, ValueRef val) -> match {\n+type enter_pat = fn(&@ast::pat) -> option::t[(@ast::pat)[]];\n+\n+fn enter_match(&match m, uint col, ValueRef val, &enter_pat e) -> match {\n     auto result = ~[];\n     for (match_branch br in m) {\n-        if (matches_always(br.pats.(col))) {\n-            auto pats = ivec::slice(br.pats, 0u, col) +\n-                ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n-            auto new_br = @rec(pats=pats with *br);\n-            result += ~[new_br];\n-            bind_for_pat(br.pats.(col), new_br, val);\n+        alt (e(br.pats.(col))) {\n+            some(?sub) {\n+                auto pats = ivec::slice(br.pats, 0u, col) +\n+                    sub + ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n+                auto new_br = @rec(pats=pats with *br);\n+                result += ~[new_br];\n+                bind_for_pat(br.pats.(col), new_br, val);\n+            }\n+            none {}\n         }\n     }\n     ret result;\n }\n \n+fn enter_default(&match m, uint col, ValueRef val) -> match {\n+    fn e(&@ast::pat p) -> option::t[(@ast::pat)[]] {\n+        ret if (matches_always(p)) { some(~[]) }\n+            else { none };\n+    }\n+    ret enter_match(m, col, val, e);\n+}\n+\n fn enter_opt(&@crate_ctxt ccx, &match m, &opt opt,\n              uint col, uint tag_size, ValueRef val) -> match {\n-    auto result = ~[];\n     auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    for (match_branch br in m) {\n-        auto pats = ivec::slice(br.pats, 0u, col);\n-        auto include = true;\n-        alt (br.pats.(col).node) {\n-            ast::pat_tag(?ctor, _) {\n-                include = opt_eq(variant_opt(ccx, br.pats.(col).id), opt);\n+    fn e(&@crate_ctxt ccx, &@ast::pat dummy, &opt opt, uint size,\n+         &@ast::pat p) -> option::t[(@ast::pat)[]] {\n+        alt (p.node) {\n+            ast::pat_tag(?ctor, ?subpats) {\n+                ret if (opt_eq(variant_opt(ccx, p.id), opt)) { some(subpats) }\n+                    else { none };\n             }\n             ast::pat_lit(?l) {\n-                include = opt_eq(lit(l), opt);\n+                ret if (opt_eq(lit(l), opt)) { some(~[]) }\n+                    else { none };\n             }\n-            _ {}\n-        }\n-        if (include) {\n-            alt (br.pats.(col).node) {\n-                ast::pat_tag(_, ?subpats) {\n-                    assert ivec::len(subpats) == tag_size;\n-                    pats += subpats;\n-                }\n-                _ {\n-                    pats += ivec::init_elt(dummy, tag_size);\n-                }\n-            }\n-            pats += ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n-            auto new_br = @rec(pats=pats with *br);\n-            result += ~[new_br];\n-            bind_for_pat(br.pats.(col), new_br, val);\n+            _ { ret some(ivec::init_elt(dummy, size)); }\n         }\n     }\n-    ret result;\n+    ret enter_match(m, col, val, bind e(ccx, dummy, opt, tag_size, _));\n }\n \n-fn enter_rec(&@crate_ctxt ccx, &match m, uint col, &ast::ident[] fields,\n+fn enter_rec(&match m, uint col, &ast::ident[] fields,\n              ValueRef val) -> match {\n-    auto result = ~[];\n     auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    for (match_branch br in m) {\n-        auto pats = ivec::slice(br.pats, 0u, col);\n-        alt (br.pats.(col).node) {\n+    fn e(&@ast::pat dummy, &ast::ident[] fields, &@ast::pat p)\n+        -> option::t[(@ast::pat)[]] {\n+        alt (p.node) {\n             ast::pat_rec(?fpats, _) {\n+                auto pats = ~[];\n                 for (ast::ident fname in fields) {\n                     auto pat = dummy;\n                     for (ast::field_pat fpat in fpats) {\n@@ -151,34 +149,23 @@ fn enter_rec(&@crate_ctxt ccx, &match m, uint col, &ast::ident[] fields,\n                     }\n                     pats += ~[pat];\n                 }\n+                ret some(pats);\n             }\n-            _ {\n-                pats += ivec::init_elt(dummy, ivec::len(fields));\n-            }\n+            _ { ret some(ivec::init_elt(dummy, ivec::len(fields))); }\n         }\n-        pats += ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n-        auto new_br = @rec(pats=pats with *br);\n-        result += ~[new_br];\n-        bind_for_pat(br.pats.(col), new_br, val);\n     }\n-    ret result;\n+    ret enter_match(m, col, val, bind e(dummy, fields, _));\n }\n \n-fn enter_box(&@crate_ctxt ccx, &match m, uint col, ValueRef val) -> match {\n-    auto result = ~[];\n+fn enter_box(&match m, uint col, ValueRef val) -> match {\n     auto dummy = @rec(id=0, node=ast::pat_wild, span=rec(lo=0u, hi=0u));\n-    for (match_branch br in m) {\n-        auto pats = ivec::slice(br.pats, 0u, col);\n-        alt (br.pats.(col).node) {\n-            ast::pat_box(?sub) { pats += ~[sub]; }\n-            _ { pats += ~[dummy]; }\n+    fn e(&@ast::pat dummy, &@ast::pat p) -> option::t[(@ast::pat)[]] {\n+        alt (p.node) {\n+            ast::pat_box(?sub) { ret some(~[sub]); }\n+            _ { ret some(~[dummy]); }\n         }\n-        pats += ivec::slice(br.pats, col + 1u, ivec::len(br.pats));\n-        auto new_br = @rec(pats=pats with *br);\n-        result += ~[new_br];\n-        bind_for_pat(br.pats.(col), new_br, val);\n     }\n-    ret result;\n+    ret enter_match(m, col, val, bind e(dummy, _));\n }\n \n fn get_options(&@crate_ctxt ccx, &match m, uint col) -> opt[] {\n@@ -301,7 +288,7 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n             rec_vals += ~[r.val];\n             bcx = r.bcx;\n         }\n-        compile_submatch(bcx, enter_rec(ccx, m, col, rec_fields, val),\n+        compile_submatch(bcx, enter_rec(m, col, rec_fields, val),\n                          rec_vals + vals_left, f, exits);\n         ret;\n     }\n@@ -311,7 +298,7 @@ fn compile_submatch(@block_ctxt bcx, &match m, ValueRef[] vals, &mk_fail f,\n         auto box = bcx.build.Load(val);\n         auto unboxed = bcx.build.InBoundsGEP\n             (box, ~[C_int(0), C_int(back::abi::box_rc_field_body)]);\n-        compile_submatch(bcx, enter_box(ccx, m, col, val),\n+        compile_submatch(bcx, enter_box(m, col, val),\n                          ~[unboxed] + vals_left, f, exits);\n         ret;\n     }"}]}