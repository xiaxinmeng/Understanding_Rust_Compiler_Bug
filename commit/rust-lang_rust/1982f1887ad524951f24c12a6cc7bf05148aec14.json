{"sha": "1982f1887ad524951f24c12a6cc7bf05148aec14", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5ODJmMTg4N2FkNTI0OTUxZjI0YzEyYTZjYzdiZjA1MTQ4YWVjMTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T03:07:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-10-28T03:07:37Z"}, "message": "Auto merge of #55297 - petrochenkov:uni, r=Mark-Simulacrum\n\nPartial implementation of uniform paths 2.0 to land before beta\n\nReimplementation of uniform paths using in-scope resolution rather than canaries is a minor breaking change due to stricter future-proofing, so it needs to be landed before beta or backported later.\n\nI hope to implement at least something until beta so we have less to backport.\nr? @Mark-Simulacrum", "tree": {"sha": "09fd491cea342d1cd222af768f1ced042b652b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09fd491cea342d1cd222af768f1ced042b652b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1982f1887ad524951f24c12a6cc7bf05148aec14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1982f1887ad524951f24c12a6cc7bf05148aec14", "html_url": "https://github.com/rust-lang/rust/commit/1982f1887ad524951f24c12a6cc7bf05148aec14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1982f1887ad524951f24c12a6cc7bf05148aec14/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18311a6c47899853071cf90e37782d398dffaeed", "url": "https://api.github.com/repos/rust-lang/rust/commits/18311a6c47899853071cf90e37782d398dffaeed", "html_url": "https://github.com/rust-lang/rust/commit/18311a6c47899853071cf90e37782d398dffaeed"}, {"sha": "c57f0a7201860eb87ad8df1f3e63ea1ed03dcb40", "url": "https://api.github.com/repos/rust-lang/rust/commits/c57f0a7201860eb87ad8df1f3e63ea1ed03dcb40", "html_url": "https://github.com/rust-lang/rust/commit/c57f0a7201860eb87ad8df1f3e63ea1ed03dcb40"}], "stats": {"total": 1062, "additions": 518, "deletions": 544}, "files": [{"sha": "9795c0cba61545a36015976b083cbae0a3d14b17", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -3133,7 +3133,8 @@ impl<'a> LoweringContext<'a> {\n                 // Privatize the degenerate import base, used only to check\n                 // the stability of `use a::{};`, to avoid it showing up as\n                 // a re-export by accident when `pub`, e.g. in documentation.\n-                let path = P(self.lower_path(id, &prefix, ParamMode::Explicit));\n+                let def = self.expect_full_def_from_use(id).next().unwrap_or(Def::Err);\n+                let path = P(self.lower_path_extra(def, &prefix, None, ParamMode::Explicit, None));\n                 *vis = respan(prefix.span.shrink_to_lo(), hir::VisibilityKind::Inherited);\n                 hir::ItemKind::Use(path, hir::UseKind::ListStem)\n             }"}, {"sha": "bb451f554d697b6fce15b1cea5dfa9e11d8a8fcd", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 100, "deletions": 88, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -35,7 +35,7 @@ use syntax::ast::{Name, Ident};\n use syntax::attr;\n \n use syntax::ast::{self, Block, ForeignItem, ForeignItemKind, Item, ItemKind, NodeId};\n-use syntax::ast::{Mutability, StmtKind, TraitItem, TraitItemKind, Variant};\n+use syntax::ast::{MetaItemKind, Mutability, StmtKind, TraitItem, TraitItemKind, Variant};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::base::Determinacy::Undetermined;\n use syntax::ext::hygiene::Mark;\n@@ -83,12 +83,6 @@ impl<'a> ToNameBinding<'a> for (Def, ty::Visibility, Span, Mark, IsMacroExport)\n     }\n }\n \n-#[derive(Default, PartialEq, Eq)]\n-struct LegacyMacroImports {\n-    import_all: Option<Span>,\n-    imports: Vec<(Name, Span)>,\n-}\n-\n impl<'a, 'cl> Resolver<'a, 'cl> {\n     /// Defines `name` in namespace `ns` of module `parent` to be `def` if it is not yet defined;\n     /// otherwise, reports an error.\n@@ -117,23 +111,23 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     fn build_reduced_graph_for_use_tree(\n         &mut self,\n-        root_use_tree: &ast::UseTree,\n-        root_id: NodeId,\n+        // This particular use tree\n         use_tree: &ast::UseTree,\n         id: NodeId,\n-        vis: ty::Visibility,\n         parent_prefix: &[Segment],\n-        mut uniform_paths_canary_emitted: bool,\n         nested: bool,\n+        mut uniform_paths_canary_emitted: bool,\n+        // The whole `use` item\n+        parent_scope: ParentScope<'a>,\n         item: &Item,\n-        expansion: Mark,\n+        vis: ty::Visibility,\n+        root_span: Span,\n     ) {\n         debug!(\"build_reduced_graph_for_use_tree(parent_prefix={:?}, \\\n                 uniform_paths_canary_emitted={}, \\\n                 use_tree={:?}, nested={})\",\n                parent_prefix, uniform_paths_canary_emitted, use_tree, nested);\n \n-        let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n         let uniform_paths =\n             self.session.rust_2018() &&\n             self.session.features_untracked().uniform_paths;\n@@ -221,10 +215,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     subclass,\n                     source.ident.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     ty::Visibility::Invisible,\n-                    expansion,\n+                    parent_scope.clone(),\n                     true, // is_uniform_paths_canary\n                 );\n             };\n@@ -259,6 +253,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             uniform_paths_canary_emitted = true;\n         }\n \n+        let empty_for_self = |prefix: &[Segment]| {\n+            prefix.is_empty() ||\n+            prefix.len() == 1 && prefix[0].ident.name == keywords::CrateRoot.name()\n+        };\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 let mut ident = use_tree.ident();\n@@ -271,10 +269,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     if source.ident.name == keywords::SelfValue.name() {\n                         type_ns_only = true;\n \n-                        let empty_prefix = module_path.last().map_or(true, |seg| {\n-                            seg.ident.name == keywords::CrateRoot.name()\n-                        });\n-                        if empty_prefix {\n+                        if empty_for_self(&module_path) {\n                             resolve_error(\n                                 self,\n                                 use_tree.span,\n@@ -351,27 +346,27 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     subclass,\n                     use_tree.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     vis,\n-                    expansion,\n+                    parent_scope,\n                     false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n                 let subclass = GlobImport {\n-                    is_prelude,\n+                    is_prelude: attr::contains_name(&item.attrs, \"prelude_import\"),\n                     max_vis: Cell::new(ty::Visibility::Invisible),\n                 };\n                 self.add_import_directive(\n                     prefix,\n                     subclass,\n                     use_tree.span,\n                     id,\n-                    root_use_tree.span,\n-                    root_id,\n+                    root_span,\n+                    item.id,\n                     vis,\n-                    expansion,\n+                    parent_scope,\n                     false, // is_uniform_paths_canary\n                 );\n             }\n@@ -400,42 +395,55 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n-                        root_use_tree,\n-                        root_id,\n-                        tree,\n-                        id,\n-                        vis,\n-                        &prefix,\n-                        uniform_paths_canary_emitted,\n-                        true,\n-                        item,\n-                        expansion,\n+                        // This particular use tree\n+                        tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        // The whole `use` item\n+                        parent_scope.clone(), item, vis, root_span,\n+                    );\n+                }\n+\n+                // Empty groups `a::b::{}` are turned into synthetic `self` imports\n+                // `a::b::c::{self as _}`, so that their prefixes are correctly\n+                // resolved and checked for privacy/stability/etc.\n+                if items.is_empty() && !empty_for_self(&prefix) {\n+                    let new_span = prefix[prefix.len() - 1].ident.span;\n+                    let tree = ast::UseTree {\n+                        prefix: ast::Path::from_ident(\n+                            Ident::new(keywords::SelfValue.name(), new_span)\n+                        ),\n+                        kind: ast::UseTreeKind::Simple(\n+                            Some(Ident::new(keywords::Underscore.name().gensymed(), new_span)),\n+                            ast::DUMMY_NODE_ID,\n+                            ast::DUMMY_NODE_ID,\n+                        ),\n+                        span: use_tree.span,\n+                    };\n+                    self.build_reduced_graph_for_use_tree(\n+                        // This particular use tree\n+                        &tree, id, &prefix, true, uniform_paths_canary_emitted,\n+                        // The whole `use` item\n+                        parent_scope.clone(), item, ty::Visibility::Invisible, root_span,\n                     );\n                 }\n             }\n         }\n     }\n \n     /// Constructs the reduced graph for one item.\n-    fn build_reduced_graph_for_item(&mut self, item: &Item, expansion: Mark) {\n-        let parent = self.current_module;\n+    fn build_reduced_graph_for_item(&mut self, item: &Item, parent_scope: ParentScope<'a>) {\n+        let parent = parent_scope.module;\n+        let expansion = parent_scope.expansion;\n         let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n \n         match item.node {\n             ItemKind::Use(ref use_tree) => {\n                 self.build_reduced_graph_for_use_tree(\n-                    use_tree,\n-                    item.id,\n-                    use_tree,\n-                    item.id,\n-                    vis,\n-                    &[],\n-                    false, // uniform_paths_canary_emitted\n-                    false,\n-                    item,\n-                    expansion,\n+                    // This particular use tree\n+                    use_tree, item.id, &[], false, false,\n+                    // The whole `use` item\n+                    parent_scope, item, vis, use_tree.span,\n                 );\n             }\n \n@@ -448,7 +456,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.injected_crate = Some(module);\n                 }\n \n-                let used = self.process_legacy_macro_imports(item, module, expansion);\n+                let used = self.process_legacy_macro_imports(item, module, &parent_scope);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.arenas);\n                 if ptr::eq(self.current_module, self.graph_root) {\n@@ -473,7 +481,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 let directive = self.arenas.alloc_import_directive(ImportDirective {\n                     root_id: item.id,\n                     id: item.id,\n-                    parent,\n+                    parent_scope,\n                     imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n                     subclass: ImportDirectiveSubclass::ExternCrate {\n                         source: orig_name,\n@@ -483,7 +491,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     span: item.span,\n                     module_path: Vec::new(),\n                     vis: Cell::new(vis),\n-                    expansion,\n                     used: Cell::new(used),\n                     is_uniform_paths_canary: false,\n                 });\n@@ -856,43 +863,61 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     }\n \n     // This returns true if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>, expansion: Mark)\n-                                    -> bool {\n-        let allow_shadowing = expansion == Mark::root();\n-        let legacy_imports = self.legacy_macro_imports(&item.attrs);\n-        let used = legacy_imports != LegacyMacroImports::default();\n-\n-        // `#[macro_use]` is only allowed at the crate root.\n-        if self.current_module.parent.is_some() && used {\n-            span_err!(self.session, item.span, E0468,\n-                      \"an `extern crate` loading macros must be at the crate root\");\n+    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>,\n+                                    parent_scope: &ParentScope<'a>) -> bool {\n+        let mut import_all = None;\n+        let mut single_imports = Vec::new();\n+        for attr in &item.attrs {\n+            if attr.check_name(\"macro_use\") {\n+                if self.current_module.parent.is_some() {\n+                    span_err!(self.session, item.span, E0468,\n+                        \"an `extern crate` loading macros must be at the crate root\");\n+                }\n+                let ill_formed = |span| span_err!(self.session, span, E0466, \"bad macro import\");\n+                match attr.meta() {\n+                    Some(meta) => match meta.node {\n+                        MetaItemKind::Word => {\n+                            import_all = Some(meta.span);\n+                            break;\n+                        }\n+                        MetaItemKind::List(nested_metas) => for nested_meta in nested_metas {\n+                            match nested_meta.word() {\n+                                Some(word) => single_imports.push((word.name(), word.span)),\n+                                None => ill_formed(nested_meta.span),\n+                            }\n+                        }\n+                        MetaItemKind::NameValue(..) => ill_formed(meta.span),\n+                    }\n+                    None => ill_formed(attr.span()),\n+                }\n+            }\n         }\n \n-        let (graph_root, arenas) = (self.graph_root, self.arenas);\n+        let arenas = self.arenas;\n         let macro_use_directive = |span| arenas.alloc_import_directive(ImportDirective {\n             root_id: item.id,\n             id: item.id,\n-            parent: graph_root,\n+            parent_scope: parent_scope.clone(),\n             imported_module: Cell::new(Some(ModuleOrUniformRoot::Module(module))),\n             subclass: ImportDirectiveSubclass::MacroUse,\n             root_span: span,\n             span,\n             module_path: Vec::new(),\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n-            expansion,\n             used: Cell::new(false),\n             is_uniform_paths_canary: false,\n         });\n \n-        if let Some(span) = legacy_imports.import_all {\n+        let allow_shadowing = parent_scope.expansion == Mark::root();\n+        if let Some(span) = import_all {\n             let directive = macro_use_directive(span);\n             self.potentially_unused_imports.push(directive);\n             module.for_each_child(|ident, ns, binding| if ns == MacroNS {\n                 let imported_binding = self.import(binding, directive);\n                 self.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n             });\n         } else {\n-            for (name, span) in legacy_imports.imports {\n+            for (name, span) in single_imports.iter().cloned() {\n                 let ident = Ident::with_empty_ctxt(name);\n                 let result = self.resolve_ident_in_module(\n                     ModuleOrUniformRoot::Module(module),\n@@ -911,7 +936,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n             }\n         }\n-        used\n+        import_all.is_some() || !single_imports.is_empty()\n     }\n \n     // does this attribute list contain \"macro_use\"?\n@@ -937,25 +962,6 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n         false\n     }\n-\n-    fn legacy_macro_imports(&mut self, attrs: &[ast::Attribute]) -> LegacyMacroImports {\n-        let mut imports = LegacyMacroImports::default();\n-        for attr in attrs {\n-            if attr.check_name(\"macro_use\") {\n-                match attr.meta_item_list() {\n-                    Some(names) => for attr in names {\n-                        if let Some(word) = attr.word() {\n-                            imports.imports.push((word.name(), attr.span()));\n-                        } else {\n-                            span_err!(self.session, attr.span(), E0466, \"bad macro import\");\n-                        }\n-                    },\n-                    None => imports.import_all = Some(attr.span),\n-                }\n-            }\n-        }\n-        imports\n-    }\n }\n \n pub struct BuildReducedGraphVisitor<'a, 'b: 'a, 'c: 'b> {\n@@ -1010,7 +1016,13 @@ impl<'a, 'b, 'cl> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b, 'cl> {\n \n         let orig_current_module = self.resolver.current_module;\n         let orig_current_legacy_scope = self.current_legacy_scope;\n-        self.resolver.build_reduced_graph_for_item(item, self.expansion);\n+        let parent_scope = ParentScope {\n+            module: self.resolver.current_module,\n+            expansion: self.expansion,\n+            legacy: self.current_legacy_scope,\n+            derives: Vec::new(),\n+        };\n+        self.resolver.build_reduced_graph_for_item(item, parent_scope);\n         visit::walk_item(self, item);\n         self.resolver.current_module = orig_current_module;\n         if !macro_use {"}, {"sha": "def67923322aaabdd06f5809c8394d63627276f6", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use {CrateLint, PathResult, Segment};\n+use macros::ParentScope;\n \n use std::collections::BTreeSet;\n \n@@ -23,7 +24,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     pub(crate) fn make_path_suggestion(\n         &mut self,\n         span: Span,\n-        path: Vec<Segment>\n+        path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         debug!(\"make_path_suggestion: span={:?} path={:?}\", span, path);\n         // If we don't have a path to suggest changes to, then return.\n@@ -40,10 +42,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             (Some(fst), Some(snd)) if !is_special(fst.ident) && !is_special(snd.ident) => {\n                 debug!(\"make_path_suggestion: fst={:?} snd={:?}\", fst, snd);\n \n-                self.make_missing_self_suggestion(span, path.clone())\n-                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_missing_super_suggestion(span, path.clone()))\n-                    .or_else(|| self.make_external_crate_suggestion(span, path))\n+                self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n+                    .or_else(|| self.make_missing_crate_suggestion(span, path.clone(),\n+                                                                   parent_scope))\n+                    .or_else(|| self.make_missing_super_suggestion(span, path.clone(),\n+                                                                   parent_scope))\n+                    .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n             },\n             _ => None,\n         }\n@@ -59,11 +63,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_self_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = keywords::SelfValue.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -82,11 +87,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Crate.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -105,11 +111,12 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_missing_super_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = keywords::Super.name();\n-        let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+        let result = self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some(path)\n@@ -131,7 +138,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     fn make_external_crate_suggestion(\n         &mut self,\n         span: Span,\n-        mut path: Vec<Segment>\n+        mut path: Vec<Segment>,\n+        parent_scope: &ParentScope<'b>,\n     ) -> Option<Vec<Segment>> {\n         // Need to clone else we can't call `resolve_path` without a borrow error. We also store\n         // into a `BTreeMap` so we can get consistent ordering (and therefore the same diagnostic)\n@@ -149,7 +157,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // Replace the first after root (a placeholder we inserted) with a crate name\n             // and check if that is valid.\n             path[1].ident.name = *name;\n-            let result = self.resolve_path(None, &path, None, false, span, CrateLint::No);\n+            let result =\n+                self.resolve_path(None, &path, None, parent_scope, false, span, CrateLint::No);\n             debug!(\"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                     name, path, result);\n             if let PathResult::Module(..) = result {"}, {"sha": "ebd87e87ff60a4c2a72adefc9073d73ac31b5580", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 35, "deletions": 94, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -482,23 +482,21 @@ enum PathSource<'a> {\n     TraitItem(Namespace),\n     // Path in `pub(path)`\n     Visibility,\n-    // Path in `use a::b::{...};`\n-    ImportPrefix,\n }\n \n impl<'a> PathSource<'a> {\n     fn namespace(self) -> Namespace {\n         match self {\n             PathSource::Type | PathSource::Trait(_) | PathSource::Struct |\n-            PathSource::Visibility | PathSource::ImportPrefix => TypeNS,\n+            PathSource::Visibility => TypeNS,\n             PathSource::Expr(..) | PathSource::Pat | PathSource::TupleStruct => ValueNS,\n             PathSource::TraitItem(ns) => ns,\n         }\n     }\n \n     fn global_by_default(self) -> bool {\n         match self {\n-            PathSource::Visibility | PathSource::ImportPrefix => true,\n+            PathSource::Visibility => true,\n             PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n             PathSource::Struct | PathSource::TupleStruct |\n             PathSource::Trait(_) | PathSource::TraitItem(..) => false,\n@@ -510,7 +508,7 @@ impl<'a> PathSource<'a> {\n             PathSource::Type | PathSource::Expr(..) | PathSource::Pat |\n             PathSource::Struct | PathSource::TupleStruct => true,\n             PathSource::Trait(_) | PathSource::TraitItem(..) |\n-            PathSource::Visibility | PathSource::ImportPrefix => false,\n+            PathSource::Visibility => false,\n         }\n     }\n \n@@ -522,7 +520,6 @@ impl<'a> PathSource<'a> {\n             PathSource::Struct => \"struct, variant or union type\",\n             PathSource::TupleStruct => \"tuple struct/variant\",\n             PathSource::Visibility => \"module\",\n-            PathSource::ImportPrefix => \"module or enum\",\n             PathSource::TraitItem(ns) => match ns {\n                 TypeNS => \"associated type\",\n                 ValueNS => \"method or associated constant\",\n@@ -587,10 +584,6 @@ impl<'a> PathSource<'a> {\n                 Def::AssociatedTy(..) if ns == TypeNS => true,\n                 _ => false,\n             },\n-            PathSource::ImportPrefix => match def {\n-                Def::Mod(..) | Def::Enum(..) => true,\n-                _ => false,\n-            },\n             PathSource::Visibility => match def {\n                 Def::Mod(..) => true,\n                 _ => false,\n@@ -626,8 +619,8 @@ impl<'a> PathSource<'a> {\n             (PathSource::Pat, false) | (PathSource::TupleStruct, false) => \"E0531\",\n             (PathSource::TraitItem(..), true) => \"E0575\",\n             (PathSource::TraitItem(..), false) => \"E0576\",\n-            (PathSource::Visibility, true) | (PathSource::ImportPrefix, true) => \"E0577\",\n-            (PathSource::Visibility, false) | (PathSource::ImportPrefix, false) => \"E0578\",\n+            (PathSource::Visibility, true) => \"E0577\",\n+            (PathSource::Visibility, false) => \"E0578\",\n         }\n     }\n }\n@@ -1054,7 +1047,7 @@ pub struct ModuleData<'a> {\n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n     legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n                                            Option<&'a NameBinding<'a>>)>>,\n-    macro_resolutions: RefCell<Vec<(Box<[Ident]>, Span)>>,\n+    macro_resolutions: RefCell<Vec<(Vec<Segment>, ParentScope<'a>, Span)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1207,7 +1200,7 @@ enum NameBindingKind<'a> {\n     }\n }\n \n-struct PrivacyError<'a>(Span, Name, &'a NameBinding<'a>);\n+struct PrivacyError<'a>(Span, Ident, &'a NameBinding<'a>);\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n@@ -1668,22 +1661,15 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         let segments = &path.segments;\n         let path = Segment::from_path(&path);\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n-        let def = match self.resolve_path(None, &path, Some(namespace), true, span, CrateLint::No) {\n+        let def = match self.resolve_path_without_parent_scope(None, &path, Some(namespace),\n+                                                               true, span, CrateLint::No) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                 module.def().unwrap(),\n             PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n                 path_res.base_def(),\n             PathResult::NonModule(..) => {\n-                if let PathResult::Failed(span, msg, _) = self.resolve_path(\n-                    None,\n-                    &path,\n-                    None,\n-                    true,\n-                    span,\n-                    CrateLint::No,\n-                ) {\n-                    error_callback(self, span, ResolutionError::FailedToResolve(&msg));\n-                }\n+                let msg = \"type-relative paths are not supported in this context\";\n+                error_callback(self, span, ResolutionError::FailedToResolve(msg));\n                 Def::Err\n             }\n             PathResult::Module(ModuleOrUniformRoot::UniformRoot(_)) |\n@@ -2357,66 +2343,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 });\n             }\n \n-            ItemKind::Use(ref use_tree) => {\n-                // Imports are resolved as global by default, add starting root segment.\n-                let path = Path {\n-                    segments: use_tree.prefix.make_root().into_iter().collect(),\n-                    span: use_tree.span,\n-                };\n-                self.resolve_use_tree(item.id, use_tree.span, item.id, use_tree, &path);\n-            }\n-\n-            ItemKind::ExternCrate(_) | ItemKind::MacroDef(..) | ItemKind::GlobalAsm(_) => {\n+            ItemKind::Use(..) | ItemKind::ExternCrate(..) |\n+            ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n                 // do nothing, these are just around to be encoded\n             }\n \n             ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n         }\n     }\n \n-    /// For the most part, use trees are desugared into `ImportDirective` instances\n-    /// when building the reduced graph (see `build_reduced_graph_for_use_tree`). But\n-    /// there is one special case we handle here: an empty nested import like\n-    /// `a::{b::{}}`, which desugares into...no import directives.\n-    fn resolve_use_tree(\n-        &mut self,\n-        root_id: NodeId,\n-        root_span: Span,\n-        id: NodeId,\n-        use_tree: &ast::UseTree,\n-        prefix: &Path,\n-    ) {\n-        match use_tree.kind {\n-            ast::UseTreeKind::Nested(ref items) => {\n-                let path = Path {\n-                    segments: prefix.segments\n-                        .iter()\n-                        .chain(use_tree.prefix.segments.iter())\n-                        .cloned()\n-                        .collect(),\n-                    span: prefix.span.to(use_tree.prefix.span),\n-                };\n-\n-                if items.is_empty() {\n-                    // Resolve prefix of an import with empty braces (issue #28388).\n-                    self.smart_resolve_path_with_crate_lint(\n-                        id,\n-                        None,\n-                        &path,\n-                        PathSource::ImportPrefix,\n-                        CrateLint::UsePath { root_id, root_span },\n-                    );\n-                } else {\n-                    for &(ref tree, nested_id) in items {\n-                        self.resolve_use_tree(root_id, root_span, nested_id, tree, &path);\n-                    }\n-                }\n-            }\n-            ast::UseTreeKind::Simple(..) => {},\n-            ast::UseTreeKind::Glob => {},\n-        }\n-    }\n-\n     fn with_type_parameter_rib<'b, F>(&'b mut self, type_parameters: TypeParameters<'a, 'b>, f: F)\n         where F: FnOnce(&mut Resolver)\n     {\n@@ -2530,10 +2465,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 new_id = Some(def.def_id());\n                 let span = trait_ref.path.span;\n                 if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                    self.resolve_path(\n+                    self.resolve_path_without_parent_scope(\n                         None,\n                         &path,\n-                        None,\n+                        Some(TypeNS),\n                         false,\n                         span,\n                         CrateLint::SimplePath(trait_ref.ref_id),\n@@ -3055,8 +2990,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                     (String::new(), \"the crate root\".to_string())\n                 } else {\n                     let mod_path = &path[..path.len() - 1];\n-                    let mod_prefix = match this.resolve_path(None, mod_path, Some(TypeNS),\n-                                                             false, span, CrateLint::No) {\n+                    let mod_prefix = match this.resolve_path_without_parent_scope(\n+                        None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+                    ) {\n                         PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n                             module.def(),\n                         _ => None,\n@@ -3540,7 +3476,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             ));\n         }\n \n-        let result = match self.resolve_path(\n+        let result = match self.resolve_path_without_parent_scope(\n             None,\n             &path,\n             Some(ns),\n@@ -3587,7 +3523,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n            path[0].ident.name != keywords::CrateRoot.name() &&\n            path[0].ident.name != keywords::DollarCrate.name() {\n             let unqualified_result = {\n-                match self.resolve_path(\n+                match self.resolve_path_without_parent_scope(\n                     None,\n                     &[*path.last().unwrap()],\n                     Some(ns),\n@@ -3610,7 +3546,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         Some(result)\n     }\n \n-    fn resolve_path(\n+    fn resolve_path_without_parent_scope(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n@@ -3619,12 +3555,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n+        // Macro and import paths must have full parent scope available during resolution,\n+        // other paths will do okay with parent module alone.\n+        assert!(opt_ns != None && opt_ns != Some(MacroNS));\n         let parent_scope = ParentScope { module: self.current_module, ..self.dummy_parent_scope() };\n-        self.resolve_path_with_parent_scope(base_module, path, opt_ns, &parent_scope,\n-                                            record_used, path_span, crate_lint)\n+        self.resolve_path(base_module, path, opt_ns, &parent_scope,\n+                          record_used, path_span, crate_lint)\n     }\n \n-    fn resolve_path_with_parent_scope(\n+    fn resolve_path(\n         &mut self,\n         base_module: Option<ModuleOrUniformRoot<'a>>,\n         path: &[Segment],\n@@ -3820,7 +3759,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         PathResult::Module(module.unwrap_or_else(|| {\n             span_bug!(path_span, \"resolve_path: empty(?) path {:?} has no module\", path);\n         }))\n-\n     }\n \n     fn lint_if_path_starts_with_module(\n@@ -4104,8 +4042,9 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         } else {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(None, mod_path, Some(TypeNS),\n-                                                                  false, span, CrateLint::No) {\n+            if let PathResult::Module(module) = self.resolve_path_without_parent_scope(\n+                None, mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n                 if let ModuleOrUniformRoot::Module(module) = module {\n                     add_module_candidates(module, &mut names);\n                 }\n@@ -4743,9 +4682,11 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        for &PrivacyError(span, name, binding) in &self.privacy_errors {\n-            if !reported_spans.insert(span) { continue }\n-            span_err!(self.session, span, E0603, \"{} `{}` is private\", binding.descr(), name);\n+        for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n+            if reported_spans.insert(dedup_span) {\n+                span_err!(self.session, ident.span, E0603, \"{} `{}` is private\",\n+                          binding.descr(), ident.name);\n+            }\n         }\n     }\n "}, {"sha": "d5f344346c2d17238fe4bd89eec7322b4bb72d5a", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -43,7 +43,7 @@ use std::cell::Cell;\n use std::mem;\n use rustc_data_structures::sync::Lrc;\n \n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct InvocationData<'a> {\n     def_index: DefIndex,\n     /// Module in which the macro was invoked.\n@@ -70,6 +70,7 @@ impl<'a> InvocationData<'a> {\n \n /// Binding produced by a `macro_rules` item.\n /// Not modularized, can shadow previous legacy bindings, etc.\n+#[derive(Debug)]\n pub struct LegacyBinding<'a> {\n     binding: &'a NameBinding<'a>,\n     /// Legacy scope into which the `macro_rules` item was planted.\n@@ -82,7 +83,7 @@ pub struct LegacyBinding<'a> {\n /// (named or unnamed), or even further if it escapes with `#[macro_use]`.\n /// Some macro invocations need to introduce legacy scopes too because they\n /// potentially can expand into macro definitions.\n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n pub enum LegacyScope<'a> {\n     /// Created when invocation data is allocated in the arena,\n     /// must be replaced with a proper scope later.\n@@ -96,8 +97,8 @@ pub enum LegacyScope<'a> {\n     Invocation(&'a InvocationData<'a>),\n }\n \n-/// Everything you need to resolve a macro path.\n-#[derive(Clone)]\n+/// Everything you need to resolve a macro or import path.\n+#[derive(Clone, Debug)]\n pub struct ParentScope<'a> {\n     crate module: Module<'a>,\n     crate expansion: Mark,\n@@ -461,7 +462,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         parent_scope: &ParentScope<'a>,\n         force: bool,\n     ) -> Result<Def, Determinacy> {\n-        let span = path.span;\n+        let path_span = path.span;\n         let mut path = Segment::from_path(path);\n \n         // Possibly apply the macro helper hack\n@@ -473,15 +474,15 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n \n         if path.len() > 1 {\n-            let def = match self.resolve_path_with_parent_scope(None, &path, Some(MacroNS),\n-                                                                parent_scope, false, span,\n-                                                                CrateLint::No) {\n+            let def = match self.resolve_path(None, &path, Some(MacroNS), parent_scope,\n+                                              false, path_span, CrateLint::No) {\n                 PathResult::NonModule(path_res) => match path_res.base_def() {\n                     Def::Err => Err(Determinacy::Determined),\n                     def @ _ => {\n                         if path_res.unresolved_segments() > 0 {\n                             self.found_unresolved_macro = true;\n-                            self.session.span_err(span, \"fail to resolve non-ident macro path\");\n+                            self.session.span_err(path_span,\n+                                                  \"fail to resolve non-ident macro path\");\n                             Err(Determinacy::Determined)\n                         } else {\n                             Ok(def)\n@@ -497,16 +498,12 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             };\n \n             parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path\n-                    .iter()\n-                    .map(|seg| seg.ident)\n-                    .collect::<Vec<Ident>>()\n-                    .into_boxed_slice(), span));\n+                .push((path, parent_scope.clone(), path_span));\n \n             def\n         } else {\n             let binding = self.early_resolve_ident_in_lexical_scope(\n-                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, span\n+                path[0].ident, MacroNS, Some(kind), parent_scope, false, force, path_span\n             );\n             match binding {\n                 Ok(..) => {}\n@@ -850,9 +847,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n-        for &(ref path, span) in module.macro_resolutions.borrow().iter() {\n-            let path: Vec<_> = path.iter().map(|&ident| Segment::from_ident(ident)).collect();\n-            match self.resolve_path(None, &path, Some(MacroNS), true, span, CrateLint::No) {\n+\n+        let macro_resolutions =\n+            mem::replace(&mut *module.macro_resolutions.borrow_mut(), Vec::new());\n+        for (mut path, parent_scope, path_span) in macro_resolutions {\n+            // FIXME: Path resolution will ICE if segment IDs present.\n+            for seg in &mut path { seg.id = None; }\n+            match self.resolve_path(None, &path, Some(MacroNS), &parent_scope,\n+                                    true, path_span, CrateLint::No) {\n                 PathResult::NonModule(_) => {},\n                 PathResult::Failed(span, msg, _) => {\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));"}, {"sha": "3ca0a9f7f1b973bd16bdcbdeeb440b9b790845ea", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -16,6 +16,7 @@ use {NameBinding, NameBindingKind, ToNameBinding, PathResult, PrivacyError};\n use {Resolver, Segment};\n use {names_to_string, module_to_string};\n use {resolve_error, ResolutionError};\n+use macros::ParentScope;\n \n use rustc_data_structures::ptr_key::PtrKey;\n use rustc::ty;\n@@ -88,13 +89,12 @@ pub struct ImportDirective<'a> {\n     /// Span of the *root* use tree (see `root_id`).\n     pub root_span: Span,\n \n-    pub parent: Module<'a>,\n+    pub parent_scope: ParentScope<'a>,\n     pub module_path: Vec<Segment>,\n     /// The resolution of `module_path`.\n     pub imported_module: Cell<Option<ModuleOrUniformRoot<'a>>>,\n     pub subclass: ImportDirectiveSubclass<'a>,\n     pub vis: Cell<ty::Visibility>,\n-    pub expansion: Mark,\n     pub used: Cell<bool>,\n \n     /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n@@ -226,6 +226,9 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                         let module = self.get_module(binding.def().def_id());\n                         self.populate_module_if_necessary(module);\n                         return Ok(binding);\n+                    } else if !self.graph_root.unresolved_invocations.borrow().is_empty() {\n+                        // Macro-expanded `extern crate`items still can add names to extern prelude.\n+                        return Err(Undetermined);\n                     } else {\n                         return Err(Determined);\n                     }\n@@ -272,7 +275,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     return Ok(self.dummy_binding);\n                 }\n                 if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(path_span, ident.name, binding));\n+                    self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n                 }\n             }\n \n@@ -307,8 +310,9 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             };\n             match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n                 Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, single_import.parent) => continue,\n+                Ok(binding) if !self.is_accessible_from(\n+                    binding.vis, single_import.parent_scope.module\n+                ) => continue,\n                 Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n@@ -381,8 +385,9 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n \n             match result {\n                 Err(Determined) => continue,\n-                Ok(binding)\n-                    if !self.is_accessible_from(binding.vis, glob_import.parent) => continue,\n+                Ok(binding) if !self.is_accessible_from(\n+                    binding.vis, glob_import.parent_scope.module\n+                ) => continue,\n                 Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n         }\n@@ -400,11 +405,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                expansion: Mark,\n+                                parent_scope: ParentScope<'a>,\n                                 is_uniform_paths_canary: bool) {\n-        let current_module = self.current_module;\n+        let current_module = parent_scope.module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n-            parent: current_module,\n+            parent_scope,\n             module_path,\n             imported_module: Cell::new(None),\n             subclass,\n@@ -413,7 +418,6 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             root_span,\n             root_id,\n             vis: Cell::new(vis),\n-            expansion,\n             used: Cell::new(false),\n             is_uniform_paths_canary,\n         });\n@@ -431,7 +435,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n             // which are not relevant to import resolution.\n             GlobImport { is_prelude: true, .. } => {}\n-            GlobImport { .. } => self.current_module.globs.borrow_mut().push(directive),\n+            GlobImport { .. } => current_module.globs.borrow_mut().push(directive),\n             _ => unreachable!(),\n         }\n     }\n@@ -462,7 +466,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             },\n             span: directive.span,\n             vis,\n-            expansion: directive.expansion,\n+            expansion: directive.parent_scope.expansion,\n         })\n     }\n \n@@ -568,12 +572,12 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let scope = match ident.span.reverse_glob_adjust(module.expansion,\n                                                              directive.span.ctxt().modern()) {\n                 Some(Some(def)) => self.macro_def_scope(def),\n-                Some(None) => directive.parent,\n+                Some(None) => directive.parent_scope.module,\n                 None => continue,\n             };\n             if self.is_accessible_from(binding.vis, scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n+                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n \n@@ -587,7 +591,7 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             let dummy_binding = self.dummy_binding;\n             let dummy_binding = self.import(dummy_binding, directive);\n             self.per_ns(|this, ns| {\n-                let _ = this.try_define(directive.parent, target, ns, dummy_binding);\n+                let _ = this.try_define(directive.parent_scope.module, target, ns, dummy_binding);\n             });\n         }\n     }\n@@ -856,8 +860,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                Segment::names_to_string(&directive.module_path[..]),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n-\n-        self.current_module = directive.parent;\n+        self.current_module = directive.parent_scope.module;\n \n         let module = if let Some(module) = directive.imported_module.get() {\n             module\n@@ -868,12 +871,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             directive.vis.set(ty::Visibility::Invisible);\n             let result = self.resolve_path(\n                 Some(if directive.is_uniform_paths_canary {\n-                    ModuleOrUniformRoot::Module(directive.parent)\n+                    ModuleOrUniformRoot::Module(directive.parent_scope.module)\n                 } else {\n                     ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n                 }),\n                 &directive.module_path[..],\n                 None,\n+                &directive.parent_scope,\n                 false,\n                 directive.span,\n                 directive.crate_lint(),\n@@ -910,7 +914,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 return\n             };\n \n-            let parent = directive.parent;\n+            let parent = directive.parent_scope.module;\n             match result[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n@@ -942,17 +946,18 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n     // If appropriate, returns an error to report.\n     fn finalize_import(&mut self, directive: &'b ImportDirective<'b>) -> Option<(Span, String)> {\n-        self.current_module = directive.parent;\n+        self.current_module = directive.parent_scope.module;\n         let ImportDirective { ref module_path, span, .. } = *directive;\n \n         let module_result = self.resolve_path(\n             Some(if directive.is_uniform_paths_canary {\n-                ModuleOrUniformRoot::Module(directive.parent)\n+                ModuleOrUniformRoot::Module(directive.parent_scope.module)\n             } else {\n                 ModuleOrUniformRoot::UniformRoot(keywords::Invalid.name())\n             }),\n             &module_path,\n             None,\n+            &directive.parent_scope,\n             true,\n             span,\n             directive.crate_lint(),\n@@ -965,7 +970,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n             PathResult::Failed(span, msg, true) => {\n                 return if let Some(suggested_path) = self.make_path_suggestion(\n-                    span, module_path.clone()\n+                    span, module_path.clone(), &directive.parent_scope\n                 ) {\n                     Some((\n                         span,\n@@ -995,7 +1000,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n-                    if module.def_id() == directive.parent.def_id() {\n+                    if module.def_id() == directive.parent_scope.module.def_id() {\n                         // Importing a module into itself is not allowed.\n                         return Some((directive.span,\n                             \"Cannot glob-import a module into itself.\".to_string()));\n@@ -1189,7 +1194,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         if let Some(Def::Trait(_)) = module.def() {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n             return;\n-        } else if module.def_id() == directive.parent.def_id()  {\n+        } else if module.def_id() == directive.parent_scope.module.def_id()  {\n             return;\n         } else if let GlobImport { is_prelude: true, .. } = directive.subclass {\n             self.prelude = Some(module);\n@@ -1213,7 +1218,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             };\n             if self.is_accessible_from(binding.pseudo_vis(), scope) {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(directive.parent, ident, ns, imported_binding);\n+                let _ = self.try_define(directive.parent_scope.module, ident, ns, imported_binding);\n             }\n         }\n "}, {"sha": "fc4b33bafa40ace8a14c70966d5f3eaff94bf943", "filename": "src/test/run-pass/macros/macro-use-all-and-none.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-use-all-and-none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-use-all-and-none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-use-all-and-none.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -0,0 +1,8 @@\n+warning: unused attribute\n+  --> $DIR/macro-use-all-and-none.rs:15:1\n+   |\n+LL | #[macro_use()]\n+   | ^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(unused_attributes)] on by default\n+"}, {"sha": "1159348d3db35a66338d30b5f1e27c6343cff9ab", "filename": "src/test/ui/error-codes/E0603.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0603.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: constant `PRIVATE` is private\n-  --> $DIR/E0603.rs:16:5\n+  --> $DIR/E0603.rs:16:17\n    |\n LL |     SomeModule::PRIVATE; //~ ERROR E0603\n-   |     ^^^^^^^^^^^^^^^^^^^\n+   |                 ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "5f1e677ca670848819421f746a4033b60c51cb19", "filename": "src/test/ui/error-festival.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Ferror-festival.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Ferror-festival.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-festival.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -5,10 +5,10 @@ LL |     y = 2;\n    |     ^ did you mean `x`?\n \n error[E0603]: constant `FOO` is private\n-  --> $DIR/error-festival.rs:32:5\n+  --> $DIR/error-festival.rs:32:10\n    |\n LL |     foo::FOO;\n-   |     ^^^^^^^^\n+   |          ^^^\n \n error[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n   --> $DIR/error-festival.rs:22:5"}, {"sha": "dcadad82f29bae4a113ca24d0cdb514c8a1077e4", "filename": "src/test/ui/export-import.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport-import.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport-import.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-import.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: function `unexported` is private\n-  --> $DIR/export-import.rs:11:5\n+  --> $DIR/export-import.rs:11:8\n    |\n LL | use m::unexported;\n-   |     ^^^^^^^^^^^^^\n+   |        ^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "e835c29fda34afc19729b2bc0f70af1b10979626", "filename": "src/test/ui/export-tag-variant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport-tag-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport-tag-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport-tag-variant.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: enum `y` is private\n-  --> $DIR/export-tag-variant.rs:17:21\n+  --> $DIR/export-tag-variant.rs:17:26\n    |\n LL | fn main() { let z = foo::y::y1; } //~ ERROR: enum `y` is private\n-   |                     ^^^^^^^^^^\n+   |                          ^\n \n error: aborting due to previous error\n "}, {"sha": "bed650b8c511e1e98bf40b215381390315d1fd46", "filename": "src/test/ui/export.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fexport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexport.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -23,10 +23,10 @@ LL |     fn z(y: isize) { log(debug, y); }\n    |                          ^^^^^ not found in this scope\n \n error[E0603]: function `z` is private\n-  --> $DIR/export.rs:20:13\n+  --> $DIR/export.rs:20:18\n    |\n LL | fn main() { foo::z(10); } //~ ERROR function `z` is private\n-   |             ^^^^^^\n+   |                  ^\n \n error: aborting due to 5 previous errors\n "}, {"sha": "02ecf0ce6f27cec4bf1d1bf107c49e724bcd2d3d", "filename": "src/test/ui/extern/extern-crate-visibility.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-crate-visibility.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: extern crate `core` is private\n-  --> $DIR/extern-crate-visibility.rs:16:5\n+  --> $DIR/extern-crate-visibility.rs:16:10\n    |\n LL | use foo::core::cell; //~ ERROR extern crate `core` is private\n-   |     ^^^^^^^^^^^^^^^\n+   |          ^^^^\n \n error[E0603]: extern crate `core` is private\n-  --> $DIR/extern-crate-visibility.rs:19:5\n+  --> $DIR/extern-crate-visibility.rs:19:10\n    |\n LL |     foo::core::cell::Cell::new(0); //~ ERROR extern crate `core` is private\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |          ^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b93d4da3a867bfe88de747a62e9da67ed967ffa1", "filename": "src/test/ui/hygiene/privacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprivacy.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: function `f` is private\n-  --> $DIR/privacy.rs:26:9\n+  --> $DIR/privacy.rs:26:14\n    |\n LL |         foo::f() //~ ERROR `f` is private\n-   |         ^^^^^^\n+   |              ^\n \n error: aborting due to previous error\n "}, {"sha": "4cd559f5f4a46854ffb6f142a82533da2319b512", "filename": "src/test/ui/import.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimport.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimport.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimport.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -11,10 +11,10 @@ LL |     use foo; //~ ERROR unresolved import `foo` [E0432]\n    |         ^^^ no `foo` in the root\n \n error[E0603]: unresolved item `foo` is private\n-  --> $DIR/import.rs:23:5\n+  --> $DIR/import.rs:23:10\n    |\n LL |     zed::foo(); //~ ERROR `foo` is private\n-   |     ^^^^^^^^\n+   |          ^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "b1154f2076b802adc1e304566fca88f857331a46", "filename": "src/test/ui/imports/extern-prelude-extern-crate-absolute-expanded.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fextern-prelude-extern-crate-absolute-expanded.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -0,0 +1,18 @@\n+// compile-pass\n+// edition:2018\n+\n+#![feature(extern_crate_item_prelude)]\n+\n+macro_rules! define_iso { () => {\n+    extern crate std as iso;\n+}}\n+\n+::iso::thread_local! {\n+    static S: u8 = 0;\n+}\n+\n+define_iso!();\n+\n+fn main() {\n+    let s = S;\n+}"}, {"sha": "9ed3b02591c2d848ebd7e1ed9966243d1ea9b12d", "filename": "src/test/ui/imports/reexports.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fimports%2Freexports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Freexports.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -17,16 +17,16 @@ LL |         pub use super::*; //~ ERROR must import something with the glob's v\n    |                 ^^^^^^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/reexports.rs:38:9\n+  --> $DIR/reexports.rs:38:15\n    |\n LL |     use b::a::foo::S; //~ ERROR `foo`\n-   |         ^^^^^^^^^^^^\n+   |               ^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/reexports.rs:39:9\n+  --> $DIR/reexports.rs:39:15\n    |\n LL |     use b::b::foo::S as T; //~ ERROR `foo`\n-   |         ^^^^^^^^^^^^^^^^^\n+   |               ^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "93a098432534b542eb8056f21e6c7a5f92fa710f", "filename": "src/test/ui/issues/issue-10545.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-10545.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: struct `S` is private\n-  --> $DIR/issue-10545.rs:17:11\n+  --> $DIR/issue-10545.rs:17:14\n    |\n LL | fn foo(_: a::S) { //~ ERROR: struct `S` is private\n-   |           ^^^^\n+   |              ^\n \n error: aborting due to previous error\n "}, {"sha": "bb5303cb581a1196f3e9486d269f02a0b1c7895c", "filename": "src/test/ui/issues/issue-11593.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11593.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: trait `Foo` is private\n-  --> $DIR/issue-11593.rs:17:6\n+  --> $DIR/issue-11593.rs:17:24\n    |\n LL | impl private_trait_xc::Foo for Bar {}\n-   |      ^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^\n \n error: aborting due to previous error\n "}, {"sha": "4dfd0bf15b92aa5a6b8049c0d5b831583c29c0aa", "filename": "src/test/ui/issues/issue-11680.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11680.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: enum `Foo` is private\n-  --> $DIR/issue-11680.rs:16:14\n+  --> $DIR/issue-11680.rs:16:21\n    |\n LL |     let _b = other::Foo::Bar(1);\n-   |              ^^^^^^^^^^^^^^^\n+   |                     ^^^\n \n error[E0603]: enum `Foo` is private\n-  --> $DIR/issue-11680.rs:19:14\n+  --> $DIR/issue-11680.rs:19:27\n    |\n LL |     let _b = other::test::Foo::Bar(1);\n-   |              ^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "90d5ca59e1e25bd11b87deecb6d723cfaa45f1e7", "filename": "src/test/ui/issues/issue-13407.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13407.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: unit struct `C` is private\n-  --> $DIR/issue-13407.rs:16:5\n+  --> $DIR/issue-13407.rs:16:8\n    |\n LL |     A::C = 1;\n-   |     ^^^^\n+   |        ^\n \n error[E0308]: mismatched types\n   --> $DIR/issue-13407.rs:16:12"}, {"sha": "cbbceb72af39232f3306bd3b91bdbbd8172c08c1", "filename": "src/test/ui/issues/issue-13641.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13641.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: struct `Foo` is private\n-  --> $DIR/issue-13641.rs:19:5\n+  --> $DIR/issue-13641.rs:19:8\n    |\n LL |     a::Foo::new();\n-   |     ^^^^^^^^^^^\n+   |        ^^^\n \n error[E0603]: enum `Bar` is private\n-  --> $DIR/issue-13641.rs:21:5\n+  --> $DIR/issue-13641.rs:21:8\n    |\n LL |     a::Bar::new();\n-   |     ^^^^^^^^^^^\n+   |        ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ba36f9b5582e5ec9ad0d3dc9ec29eae385d24e2c", "filename": "src/test/ui/issues/issue-16725.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16725.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: function `bar` is private\n-  --> $DIR/issue-16725.rs:16:14\n+  --> $DIR/issue-16725.rs:16:19\n    |\n LL |     unsafe { foo::bar(); }\n-   |              ^^^^^^^^\n+   |                   ^^^\n \n error: aborting due to previous error\n "}, {"sha": "7d65a97ec1d5a048f95627775038993038db3ad2", "filename": "src/test/ui/issues/issue-17718-const-privacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17718-const-privacy.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: constant `B` is private\n-  --> $DIR/issue-17718-const-privacy.rs:15:5\n+  --> $DIR/issue-17718-const-privacy.rs:15:8\n    |\n LL | use a::B; //~ ERROR: constant `B` is private\n-   |     ^^^^\n+   |        ^\n \n error[E0603]: constant `BAR` is private\n   --> $DIR/issue-17718-const-privacy.rs:18:5"}, {"sha": "b0418a513e31c67680ff82db7b1970eefcab690e", "filename": "src/test/ui/issues/issue-28388-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -10,6 +10,6 @@\n \n // Prefix in imports with empty braces should be resolved and checked privacy, stability, etc.\n \n-use foo::{}; //~ ERROR cannot find module or enum `foo` in the crate root\n+use foo::{}; //~ ERROR unresolved import `foo`\n \n fn main() {}"}, {"sha": "f93252f1d7dec03292f98e20e61cd45677cc9dd2", "filename": "src/test/ui/issues/issue-28388-1.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28388-1.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,9 +1,9 @@\n-error[E0578]: cannot find module or enum `foo` in the crate root\n+error[E0432]: unresolved import `foo`\n   --> $DIR/issue-28388-1.rs:13:5\n    |\n-LL | use foo::{}; //~ ERROR cannot find module or enum `foo` in the crate root\n-   |     ^^^ not found in the crate root\n+LL | use foo::{}; //~ ERROR unresolved import `foo`\n+   |     ^^^^^^^ no `foo` in the root\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0578`.\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "02ffc4b1758f6d6ec3c11eb9e5ca4e59fd2f419d", "filename": "src/test/ui/issues/issue-28388-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28388-2.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: module `n` is private\n-  --> $DIR/issue-28388-2.rs:17:5\n+  --> $DIR/issue-28388-2.rs:17:8\n    |\n LL | use m::n::{};\n-   |     ^^^^^^^^\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "7d3bd03ba230be1115d72d3d3793775aa396d02a", "filename": "src/test/ui/issues/issue-29161.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29161.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -5,10 +5,10 @@ LL |         pub fn default() -> A { //~ ERROR unnecessary visibility qualifier\n    |         ^^^ `pub` not permitted here because it's implied\n \n error[E0603]: struct `A` is private\n-  --> $DIR/issue-29161.rs:23:5\n+  --> $DIR/issue-29161.rs:23:8\n    |\n LL |     a::A::default();\n-   |     ^^^^^^^^^^^^^\n+   |        ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f6ed3202671796faf9ae80a364ea81a5a406f9c7", "filename": "src/test/ui/issues/issue-38857.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-38857.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -5,10 +5,10 @@ LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!()\n    |                       ^^^ Could not find `imp` in `sys`\n \n error[E0603]: module `sys` is private\n-  --> $DIR/issue-38857.rs:12:13\n+  --> $DIR/issue-38857.rs:12:18\n    |\n LL |     let a = std::sys::imp::process::process_common::StdioPipes { ..panic!() };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                  ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "52f1985c4fbf41c5e56fc4093bd68e3c90035d56", "filename": "src/test/ui/issues/issue-3993.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3993.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: function `fly` is private\n-  --> $DIR/issue-3993.rs:11:5\n+  --> $DIR/issue-3993.rs:11:10\n    |\n LL | use zoo::fly; //~ ERROR: function `fly` is private\n-   |     ^^^^^^^^\n+   |          ^^^\n \n error: aborting due to previous error\n "}, {"sha": "b5ad50fbebab2bada8d253d381620dd638f24125", "filename": "src/test/ui/macros/macro-local-data-key-priv.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-local-data-key-priv.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: constant `baz` is private\n-  --> $DIR/macro-local-data-key-priv.rs:18:5\n+  --> $DIR/macro-local-data-key-priv.rs:18:10\n    |\n LL |     bar::baz.with(|_| ());\n-   |     ^^^^^^^^\n+   |          ^^^\n \n error: aborting due to previous error\n "}, {"sha": "7b72c634ebf9b84ed7f46418f410b9debc587bd3", "filename": "src/test/ui/privacy/privacy-in-paths.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-in-paths.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,20 +1,20 @@\n error[E0603]: module `bar` is private\n-  --> $DIR/privacy-in-paths.rs:34:9\n+  --> $DIR/privacy-in-paths.rs:34:16\n    |\n LL |         ::foo::bar::baz::f(); //~ERROR module `bar` is private\n-   |         ^^^^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: module `bar` is private\n-  --> $DIR/privacy-in-paths.rs:35:9\n+  --> $DIR/privacy-in-paths.rs:35:16\n    |\n LL |         ::foo::bar::S::f(); //~ERROR module `bar` is private\n-   |         ^^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: trait `T` is private\n-  --> $DIR/privacy-in-paths.rs:36:9\n+  --> $DIR/privacy-in-paths.rs:36:23\n    |\n LL |         <() as ::foo::T>::Assoc::f(); //~ERROR trait `T` is private\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                       ^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9243bc2459f91732b74409f760623cbe9bab1fad", "filename": "src/test/ui/privacy/privacy-ns2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ns2.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -55,16 +55,16 @@ LL | use foo3::Bar;\n    |\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:70:9\n+  --> $DIR/privacy-ns2.rs:70:15\n    |\n LL |     use foo3::Bar;  //~ ERROR `Bar` is private\n-   |         ^^^^^^^^^\n+   |               ^^^\n \n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ns2.rs:74:9\n+  --> $DIR/privacy-ns2.rs:74:15\n    |\n LL |     use foo3::Bar;  //~ ERROR `Bar` is private\n-   |         ^^^^^^^^^\n+   |               ^^^\n \n error[E0603]: trait `Bar` is private\n   --> $DIR/privacy-ns2.rs:81:16"}, {"sha": "5989c79bc85d3f5cccf7ba1c484372fc64735e6a", "filename": "src/test/ui/privacy/privacy-ufcs.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy-ufcs.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: trait `Bar` is private\n-  --> $DIR/privacy-ufcs.rs:22:5\n+  --> $DIR/privacy-ufcs.rs:22:20\n    |\n LL |     <i32 as ::foo::Bar>::baz(); //~ERROR trait `Bar` is private\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                    ^^^\n \n error: aborting due to previous error\n "}, {"sha": "9aff4bbc41c9c8b5378a1c9d1e2446bcc2a256ef", "filename": "src/test/ui/privacy/privacy1.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -127,7 +127,6 @@ mod foo {\n     fn test2() {\n         use bar::baz::{foo, bar};\n         //~^ ERROR: module `baz` is private\n-        //~| ERROR: module `baz` is private\n \n         foo();\n         bar();"}, {"sha": "d6197575447e61dbd8a4aee4695f5e2688ebbad9", "filename": "src/test/ui/privacy/privacy1.stderr", "status": "modified", "additions": 25, "deletions": 31, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy1.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,80 +1,74 @@\n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:128:24\n+  --> $DIR/privacy1.rs:128:18\n    |\n LL |         use bar::baz::{foo, bar};\n-   |                        ^^^\n+   |                  ^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:128:29\n-   |\n-LL |         use bar::baz::{foo, bar};\n-   |                             ^^^\n-\n-error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:137:13\n+  --> $DIR/privacy1.rs:136:18\n    |\n LL |         use bar::baz;\n-   |             ^^^^^^^^\n+   |                  ^^^\n \n error[E0603]: module `i` is private\n-  --> $DIR/privacy1.rs:161:9\n+  --> $DIR/privacy1.rs:160:20\n    |\n LL |     use self::foo::i::A; //~ ERROR: module `i` is private\n-   |         ^^^^^^^^^^^^^^^\n+   |                    ^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:100:9\n+  --> $DIR/privacy1.rs:100:16\n    |\n LL |         ::bar::baz::A::foo();   //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:101:9\n+  --> $DIR/privacy1.rs:101:16\n    |\n LL |         ::bar::baz::A::bar();   //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:103:9\n+  --> $DIR/privacy1.rs:103:16\n    |\n LL |         ::bar::baz::A.foo2();   //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:104:9\n+  --> $DIR/privacy1.rs:104:16\n    |\n LL |         ::bar::baz::A.bar2();   //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: trait `B` is private\n-  --> $DIR/privacy1.rs:108:9\n+  --> $DIR/privacy1.rs:108:16\n    |\n LL |         ::bar::B::foo();        //~ ERROR: trait `B` is private\n-   |         ^^^^^^^^^^^^^\n+   |                ^\n \n error[E0603]: function `epriv` is private\n-  --> $DIR/privacy1.rs:114:13\n+  --> $DIR/privacy1.rs:114:20\n    |\n LL |             ::bar::epriv(); //~ ERROR: function `epriv` is private\n-   |             ^^^^^^^^^^^^\n+   |                    ^^^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:123:9\n+  --> $DIR/privacy1.rs:123:16\n    |\n LL |         ::bar::baz::foo(); //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: module `baz` is private\n-  --> $DIR/privacy1.rs:124:9\n+  --> $DIR/privacy1.rs:124:16\n    |\n LL |         ::bar::baz::bar(); //~ ERROR: module `baz` is private\n-   |         ^^^^^^^^^^^^^^^\n+   |                ^^^\n \n error[E0603]: trait `B` is private\n-  --> $DIR/privacy1.rs:153:10\n+  --> $DIR/privacy1.rs:152:17\n    |\n LL |     impl ::bar::B for f32 { fn foo() -> f32 { 1.0 } }\n-   |          ^^^^^^^^\n+   |                 ^\n \n error[E0624]: method `bar` is private\n   --> $DIR/privacy1.rs:73:9\n@@ -106,7 +100,7 @@ error[E0624]: method `bar2` is private\n LL |         ::bar::baz::A.bar2();   //~ ERROR: module `baz` is private\n    |                       ^^^^\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 17 previous errors\n \n Some errors occurred: E0603, E0624.\n For more information about an error, try `rustc --explain E0603`."}, {"sha": "fa4da7f5181b01c565cf3fd292f6db9394da89cf", "filename": "src/test/ui/privacy/privacy2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy2.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -5,10 +5,10 @@ LL |     use bar::foo;\n    |         ^^^^^^^^ no `foo` in `bar`\n \n error[E0603]: function `foo` is private\n-  --> $DIR/privacy2.rs:33:9\n+  --> $DIR/privacy2.rs:33:20\n    |\n LL |     use bar::glob::foo;\n-   |         ^^^^^^^^^^^^^^\n+   |                    ^^^\n \n error: requires `sized` lang_item\n "}, {"sha": "8a4b7401de01a8567fa30812abadf0c9bb9e985f", "filename": "src/test/ui/privacy/privacy4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy4.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: module `glob` is private\n-  --> $DIR/privacy4.rs:31:9\n+  --> $DIR/privacy4.rs:31:14\n    |\n LL |     use bar::glob::gpriv; //~ ERROR: module `glob` is private\n-   |         ^^^^^^^^^^^^^^^^\n+   |              ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "23682575cf1832e1631daf0b34c2dbd5764a39ef", "filename": "src/test/ui/privacy/privacy5.stderr", "status": "modified", "additions": 96, "deletions": 96, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivacy5.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,290 +1,290 @@\n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:61:13\n+  --> $DIR/privacy5.rs:61:16\n    |\n LL |     let a = a::A(()); //~ ERROR tuple struct `A` is private\n-   |             ^^^^\n+   |                ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:62:13\n+  --> $DIR/privacy5.rs:62:16\n    |\n LL |     let b = a::B(2); //~ ERROR tuple struct `B` is private\n-   |             ^^^^\n+   |                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:63:13\n+  --> $DIR/privacy5.rs:63:16\n    |\n LL |     let c = a::C(2, 3); //~ ERROR tuple struct `C` is private\n-   |             ^^^^\n+   |                ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:66:9\n+  --> $DIR/privacy5.rs:66:12\n    |\n LL |     let a::A(()) = a; //~ ERROR tuple struct `A` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:67:9\n+  --> $DIR/privacy5.rs:67:12\n    |\n LL |     let a::A(_) = a; //~ ERROR tuple struct `A` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:68:15\n+  --> $DIR/privacy5.rs:68:18\n    |\n LL |     match a { a::A(()) => {} } //~ ERROR tuple struct `A` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:69:15\n+  --> $DIR/privacy5.rs:69:18\n    |\n LL |     match a { a::A(_) => {} } //~ ERROR tuple struct `A` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:71:9\n+  --> $DIR/privacy5.rs:71:12\n    |\n LL |     let a::B(_) = b; //~ ERROR tuple struct `B` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:72:9\n+  --> $DIR/privacy5.rs:72:12\n    |\n LL |     let a::B(_b) = b; //~ ERROR tuple struct `B` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:73:15\n+  --> $DIR/privacy5.rs:73:18\n    |\n LL |     match b { a::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:74:15\n+  --> $DIR/privacy5.rs:74:18\n    |\n LL |     match b { a::B(_b) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:75:15\n+  --> $DIR/privacy5.rs:75:18\n    |\n LL |     match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:75:29\n+  --> $DIR/privacy5.rs:75:32\n    |\n LL |     match b { a::B(1) => {} a::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |                             ^^^^\n+   |                                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:78:9\n+  --> $DIR/privacy5.rs:78:12\n    |\n LL |     let a::C(_, _) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:79:9\n+  --> $DIR/privacy5.rs:79:12\n    |\n LL |     let a::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:80:9\n+  --> $DIR/privacy5.rs:80:12\n    |\n LL |     let a::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:81:9\n+  --> $DIR/privacy5.rs:81:12\n    |\n LL |     let a::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:82:15\n+  --> $DIR/privacy5.rs:82:18\n    |\n LL |     match c { a::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:83:15\n+  --> $DIR/privacy5.rs:83:18\n    |\n LL |     match c { a::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:84:15\n+  --> $DIR/privacy5.rs:84:18\n    |\n LL |     match c { a::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:85:15\n+  --> $DIR/privacy5.rs:85:18\n    |\n LL |     match c { a::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^\n+   |                  ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:93:14\n+  --> $DIR/privacy5.rs:93:17\n    |\n LL |     let a2 = a::A; //~ ERROR tuple struct `A` is private\n-   |              ^^^^\n+   |                 ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:94:14\n+  --> $DIR/privacy5.rs:94:17\n    |\n LL |     let b2 = a::B; //~ ERROR tuple struct `B` is private\n-   |              ^^^^\n+   |                 ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:95:14\n+  --> $DIR/privacy5.rs:95:17\n    |\n LL |     let c2 = a::C; //~ ERROR tuple struct `C` is private\n-   |              ^^^^\n+   |                 ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:100:13\n+  --> $DIR/privacy5.rs:100:20\n    |\n LL |     let a = other::A(()); //~ ERROR tuple struct `A` is private\n-   |             ^^^^^^^^\n+   |                    ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:101:13\n+  --> $DIR/privacy5.rs:101:20\n    |\n LL |     let b = other::B(2); //~ ERROR tuple struct `B` is private\n-   |             ^^^^^^^^\n+   |                    ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:102:13\n+  --> $DIR/privacy5.rs:102:20\n    |\n LL |     let c = other::C(2, 3); //~ ERROR tuple struct `C` is private\n-   |             ^^^^^^^^\n+   |                    ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:105:9\n+  --> $DIR/privacy5.rs:105:16\n    |\n LL |     let other::A(()) = a; //~ ERROR tuple struct `A` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:106:9\n+  --> $DIR/privacy5.rs:106:16\n    |\n LL |     let other::A(_) = a; //~ ERROR tuple struct `A` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:107:15\n+  --> $DIR/privacy5.rs:107:22\n    |\n LL |     match a { other::A(()) => {} } //~ ERROR tuple struct `A` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:108:15\n+  --> $DIR/privacy5.rs:108:22\n    |\n LL |     match a { other::A(_) => {} } //~ ERROR tuple struct `A` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:110:9\n+  --> $DIR/privacy5.rs:110:16\n    |\n LL |     let other::B(_) = b; //~ ERROR tuple struct `B` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:111:9\n+  --> $DIR/privacy5.rs:111:16\n    |\n LL |     let other::B(_b) = b; //~ ERROR tuple struct `B` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:112:15\n+  --> $DIR/privacy5.rs:112:22\n    |\n LL |     match b { other::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:113:15\n+  --> $DIR/privacy5.rs:113:22\n    |\n LL |     match b { other::B(_b) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:114:15\n+  --> $DIR/privacy5.rs:114:22\n    |\n LL |     match b { other::B(1) => {} other::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:114:33\n+  --> $DIR/privacy5.rs:114:40\n    |\n LL |     match b { other::B(1) => {} other::B(_) => {} } //~ ERROR tuple struct `B` is private\n-   |                                 ^^^^^^^^\n+   |                                        ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:117:9\n+  --> $DIR/privacy5.rs:117:16\n    |\n LL |     let other::C(_, _) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:118:9\n+  --> $DIR/privacy5.rs:118:16\n    |\n LL |     let other::C(_a, _) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:119:9\n+  --> $DIR/privacy5.rs:119:16\n    |\n LL |     let other::C(_, _b) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:120:9\n+  --> $DIR/privacy5.rs:120:16\n    |\n LL |     let other::C(_a, _b) = c; //~ ERROR tuple struct `C` is private\n-   |         ^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:121:15\n+  --> $DIR/privacy5.rs:121:22\n    |\n LL |     match c { other::C(_, _) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:122:15\n+  --> $DIR/privacy5.rs:122:22\n    |\n LL |     match c { other::C(_a, _) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:123:15\n+  --> $DIR/privacy5.rs:123:22\n    |\n LL |     match c { other::C(_, _b) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:124:15\n+  --> $DIR/privacy5.rs:124:22\n    |\n LL |     match c { other::C(_a, _b) => {} } //~ ERROR tuple struct `C` is private\n-   |               ^^^^^^^^\n+   |                      ^\n \n error[E0603]: tuple struct `A` is private\n-  --> $DIR/privacy5.rs:132:14\n+  --> $DIR/privacy5.rs:132:21\n    |\n LL |     let a2 = other::A; //~ ERROR tuple struct `A` is private\n-   |              ^^^^^^^^\n+   |                     ^\n \n error[E0603]: tuple struct `B` is private\n-  --> $DIR/privacy5.rs:133:14\n+  --> $DIR/privacy5.rs:133:21\n    |\n LL |     let b2 = other::B; //~ ERROR tuple struct `B` is private\n-   |              ^^^^^^^^\n+   |                     ^\n \n error[E0603]: tuple struct `C` is private\n-  --> $DIR/privacy5.rs:134:14\n+  --> $DIR/privacy5.rs:134:21\n    |\n LL |     let c2 = other::C; //~ ERROR tuple struct `C` is private\n-   |              ^^^^^^^^\n+   |                     ^\n \n error: aborting due to 48 previous errors\n "}, {"sha": "468bfeaf32e9d5c07d0609e523f2c26a6da0a63a", "filename": "src/test/ui/privacy/private-item-simple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-item-simple.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: function `f` is private\n-  --> $DIR/private-item-simple.rs:16:5\n+  --> $DIR/private-item-simple.rs:16:8\n    |\n LL |     a::f(); //~ ERROR function `f` is private\n-   |     ^^^^\n+   |        ^\n \n error: aborting due to previous error\n "}, {"sha": "afc3ee2db4b8f1cb7b34a7175ce919b72a284927", "filename": "src/test/ui/privacy/restricted/test.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Ftest.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -23,16 +23,16 @@ LL |         pub(super) use foo::bar::f as g; //~ ERROR cannot be re-exported\n    |                        ^^^^^^^^^^^^^^^^\n \n error[E0603]: struct `Crate` is private\n-  --> $DIR/test.rs:48:9\n+  --> $DIR/test.rs:48:25\n    |\n LL |     use pub_restricted::Crate; //~ ERROR private\n-   |         ^^^^^^^^^^^^^^^^^^^^^\n+   |                         ^^^^^\n \n error[E0603]: function `f` is private\n-  --> $DIR/test.rs:40:9\n+  --> $DIR/test.rs:40:19\n    |\n LL |     use foo::bar::f; //~ ERROR private\n-   |         ^^^^^^^^^^^\n+   |                   ^\n \n error[E0616]: field `x` of struct `foo::bar::S` is private\n   --> $DIR/test.rs:41:5"}, {"sha": "8e08f124d6807f8fdfc9bf253cf346a128aac508", "filename": "src/test/ui/resolve/privacy-enum-ctor.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-enum-ctor.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -132,28 +132,28 @@ LL | use m::n::Z;\n    |\n \n error[E0603]: enum `Z` is private\n-  --> $DIR/privacy-enum-ctor.rs:67:16\n+  --> $DIR/privacy-enum-ctor.rs:67:22\n    |\n LL |     let _: Z = m::n::Z;\n-   |                ^^^^^^^\n+   |                      ^\n \n error[E0603]: enum `Z` is private\n-  --> $DIR/privacy-enum-ctor.rs:71:16\n+  --> $DIR/privacy-enum-ctor.rs:71:22\n    |\n LL |     let _: Z = m::n::Z::Fn;\n-   |                ^^^^^^^^^^^\n+   |                      ^\n \n error[E0603]: enum `Z` is private\n-  --> $DIR/privacy-enum-ctor.rs:74:16\n+  --> $DIR/privacy-enum-ctor.rs:74:22\n    |\n LL |     let _: Z = m::n::Z::Struct;\n-   |                ^^^^^^^^^^^^^^^\n+   |                      ^\n \n error[E0603]: enum `Z` is private\n-  --> $DIR/privacy-enum-ctor.rs:78:16\n+  --> $DIR/privacy-enum-ctor.rs:78:22\n    |\n LL |     let _: Z = m::n::Z::Unit {};\n-   |                ^^^^^^^^^^^^^\n+   |                      ^\n \n error[E0308]: mismatched types\n   --> $DIR/privacy-enum-ctor.rs:37:20"}, {"sha": "c4713bd77a87a70715a846d548a34e6aac372c50", "filename": "src/test/ui/resolve/privacy-struct-ctor.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fprivacy-struct-ctor.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -38,40 +38,40 @@ LL | use m::S;\n    |\n \n error[E0603]: tuple struct `Z` is private\n-  --> $DIR/privacy-struct-ctor.rs:28:9\n+  --> $DIR/privacy-struct-ctor.rs:28:12\n    |\n LL |         n::Z;\n-   |         ^^^^\n+   |            ^\n \n error[E0603]: tuple struct `S` is private\n-  --> $DIR/privacy-struct-ctor.rs:39:5\n+  --> $DIR/privacy-struct-ctor.rs:39:8\n    |\n LL |     m::S;\n-   |     ^^^^\n+   |        ^\n \n error[E0603]: tuple struct `S` is private\n-  --> $DIR/privacy-struct-ctor.rs:41:16\n+  --> $DIR/privacy-struct-ctor.rs:41:19\n    |\n LL |     let _: S = m::S(2);\n-   |                ^^^^\n+   |                   ^\n \n error[E0603]: tuple struct `Z` is private\n-  --> $DIR/privacy-struct-ctor.rs:45:5\n+  --> $DIR/privacy-struct-ctor.rs:45:11\n    |\n LL |     m::n::Z;\n-   |     ^^^^^^^\n+   |           ^\n \n error[E0603]: tuple struct `S` is private\n-  --> $DIR/privacy-struct-ctor.rs:51:5\n+  --> $DIR/privacy-struct-ctor.rs:51:16\n    |\n LL |     xcrate::m::S;\n-   |     ^^^^^^^^^^^^\n+   |                ^\n \n error[E0603]: tuple struct `Z` is private\n-  --> $DIR/privacy-struct-ctor.rs:55:5\n+  --> $DIR/privacy-struct-ctor.rs:55:19\n    |\n LL |     xcrate::m::n::Z;\n-   |     ^^^^^^^^^^^^^^^\n+   |                   ^\n \n error: aborting due to 10 previous errors\n "}, {"sha": "5da5a8c3fef62c668378ccc8b430d1ca6b01c3fc", "filename": "src/test/ui/resolve/resolve-bad-import-prefix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -17,8 +17,8 @@ use {}; // OK\n use ::{}; // OK\n use m::{}; // OK\n use E::{}; // OK\n-use S::{}; //~ ERROR expected module or enum, found struct `S`\n-use Tr::{}; //~ ERROR expected module or enum, found trait `Tr`\n-use Nonexistent::{}; //~ ERROR cannot find module or enum `Nonexistent` in the crate root\n+use S::{}; // FIXME, this and `use S::{self};` should be an error\n+use Tr::{}; // FIXME, this and `use Tr::{self};` should be an error\n+use Nonexistent::{}; //~ ERROR unresolved import `Nonexistent`\n \n fn main () {}"}, {"sha": "c4d9b1d0075d55e43258dce8346627c3ae4bd77b", "filename": "src/test/ui/resolve/resolve-bad-import-prefix.stderr", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-bad-import-prefix.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,24 +1,9 @@\n-error[E0577]: expected module or enum, found struct `S`\n-  --> $DIR/resolve-bad-import-prefix.rs:20:5\n-   |\n-LL | use S::{}; //~ ERROR expected module or enum, found struct `S`\n-   |     -^^^^\n-   |     |\n-   |     did you mean `E`?\n-\n-error[E0577]: expected module or enum, found trait `Tr`\n-  --> $DIR/resolve-bad-import-prefix.rs:21:5\n-   |\n-LL | use Tr::{}; //~ ERROR expected module or enum, found trait `Tr`\n-   |     ^^^^^^ not a module or enum\n-\n-error[E0578]: cannot find module or enum `Nonexistent` in the crate root\n+error[E0432]: unresolved import `Nonexistent`\n   --> $DIR/resolve-bad-import-prefix.rs:22:5\n    |\n-LL | use Nonexistent::{}; //~ ERROR cannot find module or enum `Nonexistent` in the crate root\n-   |     ^^^^^^^^^^^ not found in the crate root\n+LL | use Nonexistent::{}; //~ ERROR unresolved import `Nonexistent`\n+   |     ^^^^^^^^^^^^^^^ no `Nonexistent` in the root\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0577, E0578.\n-For more information about an error, try `rustc --explain E0577`.\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "141e4b73b58afb8ec7cf986fcd8f7e40cebecac2", "filename": "src/test/ui/rfc-2008-non-exhaustive/structs.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstructs.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -11,16 +11,16 @@ LL |     let us = UnitStruct;\n    |              ^^^^^^^^^^ constructor is not visible here due to private fields\n \n error[E0603]: tuple struct `TupleStruct` is private\n-  --> $DIR/structs.rs:33:23\n+  --> $DIR/structs.rs:33:32\n    |\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n-   |                       ^^^^^^^^^^^^^^^^^^^^\n+   |                                ^^^^^^^^^^^\n \n error[E0603]: unit struct `UnitStruct` is private\n-  --> $DIR/structs.rs:42:23\n+  --> $DIR/structs.rs:42:32\n    |\n LL |     let us_explicit = structs::UnitStruct;\n-   |                       ^^^^^^^^^^^^^^^^^^^\n+   |                                ^^^^^^^^^^\n \n error[E0639]: cannot create non-exhaustive struct using struct expression\n   --> $DIR/structs.rs:17:14"}, {"sha": "4faaf6cce2435de6790d5a43d57d919148ef135b", "filename": "src/test/ui/shadowed/shadowed-use-visibility.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fshadowed%2Fshadowed-use-visibility.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: module `bar` is private\n-  --> $DIR/shadowed-use-visibility.rs:19:9\n+  --> $DIR/shadowed-use-visibility.rs:19:14\n    |\n LL |     use foo::bar::f as g; //~ ERROR module `bar` is private\n-   |         ^^^^^^^^^^^^^^^^\n+   |              ^^^\n \n error[E0603]: module `f` is private\n-  --> $DIR/shadowed-use-visibility.rs:25:5\n+  --> $DIR/shadowed-use-visibility.rs:25:10\n    |\n LL | use bar::f::f; //~ ERROR module `f` is private\n-   |     ^^^^^^^^^\n+   |          ^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2631e99a9b77d70de0645c9707dd90db9bf13171", "filename": "src/test/ui/static/static-priv-by-default2.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-priv-by-default2.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: static `private` is private\n-  --> $DIR/static-priv-by-default2.rs:25:9\n+  --> $DIR/static-priv-by-default2.rs:25:30\n    |\n LL |     use child::childs_child::private;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                              ^^^^^^^\n \n error[E0603]: static `private` is private\n-  --> $DIR/static-priv-by-default2.rs:33:9\n+  --> $DIR/static-priv-by-default2.rs:33:33\n    |\n LL |     use static_priv_by_default::private;\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                 ^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7c214f9dcea0d0b0ad66719bb4dec7d5b517997e", "filename": "src/test/ui/structs/struct-variant-privacy-xc.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy-xc.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: enum `Bar` is private\n-  --> $DIR/struct-variant-privacy-xc.rs:14:9\n+  --> $DIR/struct-variant-privacy-xc.rs:14:33\n    |\n LL | fn f(b: struct_variant_privacy::Bar) { //~ ERROR enum `Bar` is private\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                 ^^^\n \n error[E0603]: enum `Bar` is private\n-  --> $DIR/struct-variant-privacy-xc.rs:16:9\n+  --> $DIR/struct-variant-privacy-xc.rs:16:33\n    |\n LL |         struct_variant_privacy::Bar::Baz { a: _a } => {} //~ ERROR enum `Bar` is private\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                 ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ffecd880069497fe66b81391d36e885115f6e946", "filename": "src/test/ui/structs/struct-variant-privacy.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-variant-privacy.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: enum `Bar` is private\n-  --> $DIR/struct-variant-privacy.rs:16:9\n+  --> $DIR/struct-variant-privacy.rs:16:14\n    |\n LL | fn f(b: foo::Bar) { //~ ERROR enum `Bar` is private\n-   |         ^^^^^^^^\n+   |              ^^^\n \n error[E0603]: enum `Bar` is private\n-  --> $DIR/struct-variant-privacy.rs:18:9\n+  --> $DIR/struct-variant-privacy.rs:18:14\n    |\n LL |         foo::Bar::Baz { a: _a } => {} //~ ERROR enum `Bar` is private\n-   |         ^^^^^^^^^^^^^\n+   |              ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a998f6b0b8f22b28614a84b9623e96a8a9b8d2ee", "filename": "src/test/ui/unreachable/unreachable-variant.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Funreachable%2Funreachable-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Funreachable%2Funreachable-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funreachable%2Funreachable-variant.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,8 +1,8 @@\n error[E0603]: module `super_sekrit` is private\n-  --> $DIR/unreachable-variant.rs:16:14\n+  --> $DIR/unreachable-variant.rs:16:21\n    |\n LL |     let _x = other::super_sekrit::sooper_sekrit::baz; //~ ERROR is private\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                     ^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "f8e5e18097ba4ca5828eaee4fa877ba57de27243", "filename": "src/test/ui/use/use-from-trait-xc.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-from-trait-xc.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -41,16 +41,16 @@ LL | use use_from_trait_xc::Baz::new as baznew;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `new` in `Baz`\n \n error[E0603]: struct `Foo` is private\n-  --> $DIR/use-from-trait-xc.rs:24:5\n+  --> $DIR/use-from-trait-xc.rs:24:24\n    |\n LL | use use_from_trait_xc::Foo::new; //~ ERROR struct `Foo` is private\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^\n \n error[E0603]: struct `Foo` is private\n-  --> $DIR/use-from-trait-xc.rs:27:5\n+  --> $DIR/use-from-trait-xc.rs:27:24\n    |\n LL | use use_from_trait_xc::Foo::C; //~ ERROR struct `Foo` is private\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                        ^^^\n \n error: aborting due to 9 previous errors\n "}, {"sha": "2ef5fe7947e77b51edc9d6eb9c5dbf2e27e0e76d", "filename": "src/test/ui/use/use-mod/use-mod-3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.rs?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use foo::bar::{\n-    self //~ ERROR module `bar` is private\n+use foo::bar::{ //~ ERROR module `bar` is private\n+    self\n };\n-use foo::bar::{\n-    Bar //~ ERROR module `bar` is private\n+use foo::bar::{ //~ ERROR module `bar` is private\n+    Bar\n };\n \n mod foo {"}, {"sha": "9284091dfa878f10d0bad3810a670b25d7a93a0f", "filename": "src/test/ui/use/use-mod/use-mod-3.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fuse%2Fuse-mod%2Fuse-mod-3.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,14 +1,14 @@\n error[E0603]: module `bar` is private\n-  --> $DIR/use-mod-3.rs:12:5\n+  --> $DIR/use-mod-3.rs:11:10\n    |\n-LL |     self //~ ERROR module `bar` is private\n-   |     ^^^^\n+LL | use foo::bar::{ //~ ERROR module `bar` is private\n+   |          ^^^\n \n error[E0603]: module `bar` is private\n-  --> $DIR/use-mod-3.rs:15:5\n+  --> $DIR/use-mod-3.rs:14:10\n    |\n-LL |     Bar //~ ERROR module `bar` is private\n-   |     ^^^\n+LL | use foo::bar::{ //~ ERROR module `bar` is private\n+   |          ^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ea1f6aaa7d2fcb604327e6a364f7c523e5684a50", "filename": "src/test/ui/xcrate/xcrate-private-by-default.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1982f1887ad524951f24c12a6cc7bf05148aec14/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fxcrate%2Fxcrate-private-by-default.stderr?ref=1982f1887ad524951f24c12a6cc7bf05148aec14", "patch": "@@ -1,62 +1,62 @@\n error[E0603]: static `j` is private\n-  --> $DIR/xcrate-private-by-default.rs:33:5\n+  --> $DIR/xcrate-private-by-default.rs:33:29\n    |\n LL |     static_priv_by_default::j;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^\n \n error[E0603]: function `k` is private\n-  --> $DIR/xcrate-private-by-default.rs:35:5\n+  --> $DIR/xcrate-private-by-default.rs:35:29\n    |\n LL |     static_priv_by_default::k;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^\n \n error[E0603]: unit struct `l` is private\n-  --> $DIR/xcrate-private-by-default.rs:37:5\n+  --> $DIR/xcrate-private-by-default.rs:37:29\n    |\n LL |     static_priv_by_default::l;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^\n \n error[E0603]: enum `m` is private\n-  --> $DIR/xcrate-private-by-default.rs:39:11\n+  --> $DIR/xcrate-private-by-default.rs:39:35\n    |\n LL |     foo::<static_priv_by_default::m>();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^\n \n error[E0603]: type alias `n` is private\n-  --> $DIR/xcrate-private-by-default.rs:41:11\n+  --> $DIR/xcrate-private-by-default.rs:41:35\n    |\n LL |     foo::<static_priv_by_default::n>();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/xcrate-private-by-default.rs:45:5\n+  --> $DIR/xcrate-private-by-default.rs:45:29\n    |\n LL |     static_priv_by_default::foo::a;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/xcrate-private-by-default.rs:47:5\n+  --> $DIR/xcrate-private-by-default.rs:47:29\n    |\n LL |     static_priv_by_default::foo::b;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/xcrate-private-by-default.rs:49:5\n+  --> $DIR/xcrate-private-by-default.rs:49:29\n    |\n LL |     static_priv_by_default::foo::c;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                             ^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/xcrate-private-by-default.rs:51:11\n+  --> $DIR/xcrate-private-by-default.rs:51:35\n    |\n LL |     foo::<static_priv_by_default::foo::d>();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^\n \n error[E0603]: module `foo` is private\n-  --> $DIR/xcrate-private-by-default.rs:53:11\n+  --> $DIR/xcrate-private-by-default.rs:53:35\n    |\n LL |     foo::<static_priv_by_default::foo::e>();\n-   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                                   ^^^\n \n error: aborting due to 10 previous errors\n "}]}