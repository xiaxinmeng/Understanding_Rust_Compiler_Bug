{"sha": "c59f62b75f6bbf79df2283d250a568193927a4c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1OWY2MmI3NWY2YmJmNzlkZjIyODNkMjUwYTU2ODE5MzkyN2E0YzM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T13:02:58Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-02-15T13:12:46Z"}, "message": "Rollup merge of #22350 - brson:usize, r=Gankro\n\n cc https://github.com/rust-lang/rust/issues/22240", "tree": {"sha": "4962f4671a5f4977ab4e0a4ba2956cef36efcc2d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4962f4671a5f4977ab4e0a4ba2956cef36efcc2d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c59f62b75f6bbf79df2283d250a568193927a4c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c59f62b75f6bbf79df2283d250a568193927a4c3", "html_url": "https://github.com/rust-lang/rust/commit/c59f62b75f6bbf79df2283d250a568193927a4c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c59f62b75f6bbf79df2283d250a568193927a4c3/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5659eaa0606162c1f08ba2d8a9e86e20c3a3d1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5659eaa0606162c1f08ba2d8a9e86e20c3a3d1c", "html_url": "https://github.com/rust-lang/rust/commit/e5659eaa0606162c1f08ba2d8a9e86e20c3a3d1c"}, {"sha": "e72fb354dcec11e20278c66d5a886409b1c3846f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e72fb354dcec11e20278c66d5a886409b1c3846f", "html_url": "https://github.com/rust-lang/rust/commit/e72fb354dcec11e20278c66d5a886409b1c3846f"}], "stats": {"total": 240, "additions": 120, "deletions": 120}, "files": [{"sha": "058eff121e63300daef084435917f9b6131fb130", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=c59f62b75f6bbf79df2283d250a568193927a4c3", "patch": "@@ -61,13 +61,13 @@ macro_rules! clone_impl {\n     }\n }\n \n-clone_impl! { int }\n+clone_impl! { isize }\n clone_impl! { i8 }\n clone_impl! { i16 }\n clone_impl! { i32 }\n clone_impl! { i64 }\n \n-clone_impl! { uint }\n+clone_impl! { usize }\n clone_impl! { u8 }\n clone_impl! { u16 }\n clone_impl! { u32 }"}, {"sha": "5cc210df5b464e5d6581614df4d17a2012a6f323", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=c59f62b75f6bbf79df2283d250a568193927a4c3", "patch": "@@ -58,7 +58,7 @@ use mem;\n #[repr(C)]\n pub struct Slice<T> {\n     pub data: *const T,\n-    pub len: uint,\n+    pub len: usize,\n }\n \n impl<T> Copy for Slice<T> {}"}, {"sha": "097633b706312a1762cef1394e8f4233e333a994", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 117, "deletions": 117, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c59f62b75f6bbf79df2283d250a568193927a4c3/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=c59f62b75f6bbf79df2283d250a568193927a4c3", "patch": "@@ -66,28 +66,28 @@ use raw::Slice as RawSlice;\n pub trait SliceExt {\n     type Item;\n \n-    fn split_at<'a>(&'a self, mid: uint) -> (&'a [Self::Item], &'a [Self::Item]);\n+    fn split_at<'a>(&'a self, mid: usize) -> (&'a [Self::Item], &'a [Self::Item]);\n     fn iter<'a>(&'a self) -> Iter<'a, Self::Item>;\n     fn split<'a, P>(&'a self, pred: P) -> Split<'a, Self::Item, P>\n                     where P: FnMut(&Self::Item) -> bool;\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, Self::Item, P>\n+    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n-    fn rsplitn<'a, P>(&'a self,  n: uint, pred: P) -> RSplitN<'a, Self::Item, P>\n+    fn rsplitn<'a, P>(&'a self,  n: usize, pred: P) -> RSplitN<'a, Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn windows<'a>(&'a self, size: uint) -> Windows<'a, Self::Item>;\n-    fn chunks<'a>(&'a self, size: uint) -> Chunks<'a, Self::Item>;\n-    fn get<'a>(&'a self, index: uint) -> Option<&'a Self::Item>;\n+    fn windows<'a>(&'a self, size: usize) -> Windows<'a, Self::Item>;\n+    fn chunks<'a>(&'a self, size: usize) -> Chunks<'a, Self::Item>;\n+    fn get<'a>(&'a self, index: usize) -> Option<&'a Self::Item>;\n     fn first<'a>(&'a self) -> Option<&'a Self::Item>;\n     fn tail<'a>(&'a self) -> &'a [Self::Item];\n     fn init<'a>(&'a self) -> &'a [Self::Item];\n     fn last<'a>(&'a self) -> Option<&'a Self::Item>;\n-    unsafe fn get_unchecked<'a>(&'a self, index: uint) -> &'a Self::Item;\n+    unsafe fn get_unchecked<'a>(&'a self, index: usize) -> &'a Self::Item;\n     fn as_ptr(&self) -> *const Self::Item;\n-    fn binary_search_by<F>(&self, f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, f: F) -> Result<usize, usize> where\n         F: FnMut(&Self::Item) -> Ordering;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool { self.len() == 0 }\n-    fn get_mut<'a>(&'a mut self, index: uint) -> Option<&'a mut Self::Item>;\n+    fn get_mut<'a>(&'a mut self, index: usize) -> Option<&'a mut Self::Item>;\n     fn as_mut_slice<'a>(&'a mut self) -> &'a mut [Self::Item];\n     fn iter_mut<'a>(&'a mut self) -> IterMut<'a, Self::Item>;\n     fn first_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n@@ -96,40 +96,40 @@ pub trait SliceExt {\n     fn last_mut<'a>(&'a mut self) -> Option<&'a mut Self::Item>;\n     fn split_mut<'a, P>(&'a mut self, pred: P) -> SplitMut<'a, Self::Item, P>\n                         where P: FnMut(&Self::Item) -> bool;\n-    fn splitn_mut<P>(&mut self, n: uint, pred: P) -> SplitNMut<Self::Item, P>\n+    fn splitn_mut<P>(&mut self, n: usize, pred: P) -> SplitNMut<Self::Item, P>\n                      where P: FnMut(&Self::Item) -> bool;\n-    fn rsplitn_mut<P>(&mut self,  n: uint, pred: P) -> RSplitNMut<Self::Item, P>\n+    fn rsplitn_mut<P>(&mut self,  n: usize, pred: P) -> RSplitNMut<Self::Item, P>\n                       where P: FnMut(&Self::Item) -> bool;\n-    fn chunks_mut<'a>(&'a mut self, chunk_size: uint) -> ChunksMut<'a, Self::Item>;\n-    fn swap(&mut self, a: uint, b: uint);\n-    fn split_at_mut<'a>(&'a mut self, mid: uint) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n+    fn chunks_mut<'a>(&'a mut self, chunk_size: usize) -> ChunksMut<'a, Self::Item>;\n+    fn swap(&mut self, a: usize, b: usize);\n+    fn split_at_mut<'a>(&'a mut self, mid: usize) -> (&'a mut [Self::Item], &'a mut [Self::Item]);\n     fn reverse(&mut self);\n-    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: uint) -> &'a mut Self::Item;\n+    unsafe fn get_unchecked_mut<'a>(&'a mut self, index: usize) -> &'a mut Self::Item;\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n-    fn position_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn position_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n-    fn rposition_elem(&self, t: &Self::Item) -> Option<uint> where Self::Item: PartialEq;\n+    fn rposition_elem(&self, t: &Self::Item) -> Option<usize> where Self::Item: PartialEq;\n \n     fn contains(&self, x: &Self::Item) -> bool where Self::Item: PartialEq;\n \n     fn starts_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n     fn ends_with(&self, needle: &[Self::Item]) -> bool where Self::Item: PartialEq;\n \n-    fn binary_search(&self, x: &Self::Item) -> Result<uint, uint> where Self::Item: Ord;\n+    fn binary_search(&self, x: &Self::Item) -> Result<usize, usize> where Self::Item: Ord;\n     fn next_permutation(&mut self) -> bool where Self::Item: Ord;\n     fn prev_permutation(&mut self) -> bool where Self::Item: Ord;\n \n-    fn clone_from_slice(&mut self, &[Self::Item]) -> uint where Self::Item: Clone;\n+    fn clone_from_slice(&mut self, &[Self::Item]) -> usize where Self::Item: Clone;\n }\n \n #[unstable(feature = \"core\")]\n impl<T> SliceExt for [T] {\n     type Item = T;\n \n     #[inline]\n-    fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n+    fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n         (&self[..mid], &self[mid..])\n     }\n \n@@ -139,11 +139,11 @@ impl<T> SliceExt for [T] {\n             let p = self.as_ptr();\n             if mem::size_of::<T>() == 0 {\n                 Iter {ptr: p,\n-                      end: (p as uint + self.len()) as *const T,\n+                      end: (p as usize + self.len()) as *const T,\n                       marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 Iter {ptr: p,\n-                      end: p.offset(self.len() as int),\n+                      end: p.offset(self.len() as isize),\n                       marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn<'a, P>(&'a self, n: uint, pred: P) -> SplitN<'a, T, P> where\n+    fn splitn<'a, P>(&'a self, n: usize, pred: P) -> SplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         SplitN {\n@@ -172,7 +172,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P>(&'a self, n: uint, pred: P) -> RSplitN<'a, T, P> where\n+    fn rsplitn<'a, P>(&'a self, n: usize, pred: P) -> RSplitN<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitN {\n@@ -185,19 +185,19 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn windows(&self, size: uint) -> Windows<T> {\n+    fn windows(&self, size: usize) -> Windows<T> {\n         assert!(size != 0);\n         Windows { v: self, size: size }\n     }\n \n     #[inline]\n-    fn chunks(&self, size: uint) -> Chunks<T> {\n+    fn chunks(&self, size: usize) -> Chunks<T> {\n         assert!(size != 0);\n         Chunks { v: self, size: size }\n     }\n \n     #[inline]\n-    fn get(&self, index: uint) -> Option<&T> {\n+    fn get(&self, index: usize) -> Option<&T> {\n         if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n@@ -220,8 +220,8 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(&self, index: uint) -> &T {\n-        transmute(self.repr().data.offset(index as int))\n+    unsafe fn get_unchecked(&self, index: usize) -> &T {\n+        transmute(self.repr().data.offset(index as isize))\n     }\n \n     #[inline]\n@@ -230,11 +230,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[unstable(feature = \"core\")]\n-    fn binary_search_by<F>(&self, mut f: F) -> Result<uint, uint> where\n+    fn binary_search_by<F>(&self, mut f: F) -> Result<usize, usize> where\n         F: FnMut(&T) -> Ordering\n     {\n-        let mut base : uint = 0;\n-        let mut lim : uint = self.len();\n+        let mut base : usize = 0;\n+        let mut lim : usize = self.len();\n \n         while lim != 0 {\n             let ix = base + (lim >> 1);\n@@ -252,18 +252,18 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n-    fn get_mut(&mut self, index: uint) -> Option<&mut T> {\n+    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n         if index < self.len() { Some(&mut self[index]) } else { None }\n     }\n \n     #[inline]\n     fn as_mut_slice(&mut self) -> &mut [T] { self }\n \n     #[inline]\n-    fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {\n+    fn split_at_mut(&mut self, mid: usize) -> (&mut [T], &mut [T]) {\n         unsafe {\n             let self2: &mut [T] = mem::transmute_copy(&self);\n \n@@ -278,11 +278,11 @@ impl<T> SliceExt for [T] {\n             let p = self.as_mut_ptr();\n             if mem::size_of::<T>() == 0 {\n                 IterMut {ptr: p,\n-                         end: (p as uint + self.len()) as *mut T,\n+                         end: (p as usize + self.len()) as *mut T,\n                          marker: marker::ContravariantLifetime::<'a>}\n             } else {\n                 IterMut {ptr: p,\n-                         end: p.offset(self.len() as int),\n+                         end: p.offset(self.len() as isize),\n                          marker: marker::ContravariantLifetime::<'a>}\n             }\n         }\n@@ -317,7 +317,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn splitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> SplitNMut<'a, T, P> where\n+    fn splitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> SplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool\n     {\n         SplitNMut {\n@@ -330,7 +330,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn rsplitn_mut<'a, P>(&'a mut self, n: uint, pred: P) -> RSplitNMut<'a, T, P> where\n+    fn rsplitn_mut<'a, P>(&'a mut self, n: usize, pred: P) -> RSplitNMut<'a, T, P> where\n         P: FnMut(&T) -> bool,\n     {\n         RSplitNMut {\n@@ -343,12 +343,12 @@ impl<T> SliceExt for [T] {\n    }\n \n     #[inline]\n-    fn chunks_mut(&mut self, chunk_size: uint) -> ChunksMut<T> {\n+    fn chunks_mut(&mut self, chunk_size: usize) -> ChunksMut<T> {\n         assert!(chunk_size > 0);\n         ChunksMut { v: self, chunk_size: chunk_size }\n     }\n \n-    fn swap(&mut self, a: uint, b: uint) {\n+    fn swap(&mut self, a: usize, b: usize) {\n         unsafe {\n             // Can't take two mutable loans from one vector, so instead just cast\n             // them to their raw pointers to do the swap\n@@ -359,7 +359,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     fn reverse(&mut self) {\n-        let mut i: uint = 0;\n+        let mut i: usize = 0;\n         let ln = self.len();\n         while i < ln / 2 {\n             // Unsafe swap to avoid the bounds check in safe swap.\n@@ -373,8 +373,8 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(&mut self, index: uint) -> &mut T {\n-        transmute((self.repr().data as *mut T).offset(index as int))\n+    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+        transmute((self.repr().data as *mut T).offset(index as isize))\n     }\n \n     #[inline]\n@@ -383,12 +383,12 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn position_elem(&self, x: &T) -> Option<uint> where T: PartialEq {\n+    fn position_elem(&self, x: &T) -> Option<usize> where T: PartialEq {\n         self.iter().position(|y| *x == *y)\n     }\n \n     #[inline]\n-    fn rposition_elem(&self, t: &T) -> Option<uint> where T: PartialEq {\n+    fn rposition_elem(&self, t: &T) -> Option<usize> where T: PartialEq {\n         self.iter().rposition(|x| *x == *t)\n     }\n \n@@ -410,7 +410,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[unstable(feature = \"core\")]\n-    fn binary_search(&self, x: &T) -> Result<uint, uint> where T: Ord {\n+    fn binary_search(&self, x: &T) -> Result<usize, usize> where T: Ord {\n         self.binary_search_by(|p| p.cmp(x))\n     }\n \n@@ -477,7 +477,7 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn clone_from_slice(&mut self, src: &[T]) -> uint where T: Clone {\n+    fn clone_from_slice(&mut self, src: &[T]) -> usize where T: Clone {\n         let min = cmp::min(self.len(), src.len());\n         let dst = &mut self[.. min];\n         let src = &src[.. min];\n@@ -489,53 +489,53 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<uint> for [T] {\n+impl<T> ops::Index<usize> for [T] {\n     type Output = T;\n \n-    fn index(&self, &index: &uint) -> &T {\n+    fn index(&self, &index: &usize) -> &T {\n         assert!(index < self.len());\n \n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<uint> for [T] {\n-    fn index_mut(&mut self, &index: &uint) -> &mut T {\n+impl<T> ops::IndexMut<usize> for [T] {\n+    fn index_mut(&mut self, &index: &usize) -> &mut T {\n         assert!(index < self.len());\n \n-        unsafe { mem::transmute(self.repr().data.offset(index as int)) }\n+        unsafe { mem::transmute(self.repr().data.offset(index as isize)) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::Range<uint>> for [T] {\n+impl<T> ops::Index<ops::Range<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(index.start as int),\n+                    data: self.as_ptr().offset(index.start as isize),\n                     len: index.end - index.start\n                 })\n         }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeTo<uint>> for [T] {\n+impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<ops::RangeFrom<uint>> for [T] {\n+impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&ops::Range{ start: index.start, end: self.len() })\n     }\n }\n@@ -549,30 +549,30 @@ impl<T> ops::Index<RangeFull> for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::Range<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         assert!(index.start <= index.end);\n         assert!(index.end <= self.len());\n         unsafe {\n             transmute(RawSlice {\n-                    data: self.as_ptr().offset(index.start as int),\n+                    data: self.as_ptr().offset(index.start as isize),\n                     len: index.end - index.start\n                 })\n         }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeTo<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&ops::Range{ start: 0, end: index.end })\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<ops::RangeFrom<uint>> for [T] {\n+impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n         self.index_mut(&ops::Range{ start: index.start, end: len })\n     }\n@@ -660,7 +660,7 @@ macro_rules! iterator {\n                             // purposefully don't use 'ptr.offset' because for\n                             // vectors with 0-size elements this would return the\n                             // same pointer.\n-                            self.ptr = transmute(self.ptr as uint + 1);\n+                            self.ptr = transmute(self.ptr as usize + 1);\n \n                             // Use a non-null pointer value\n                             Some(&mut *(1 as *mut _))\n@@ -675,8 +675,8 @@ macro_rules! iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n-                let diff = (self.end as uint) - (self.ptr as uint);\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n+                let diff = (self.end as usize) - (self.ptr as usize);\n                 let size = mem::size_of::<T>();\n                 let exact = diff / (if size == 0 {1} else {size});\n                 (exact, Some(exact))\n@@ -694,7 +694,7 @@ macro_rules! iterator {\n                     } else {\n                         if mem::size_of::<T>() == 0 {\n                             // See above for why 'ptr.offset' isn't used\n-                            self.end = transmute(self.end as uint - 1);\n+                            self.end = transmute(self.end as usize - 1);\n \n                             // Use a non-null pointer value\n                             Some(&mut *(1 as *mut _))\n@@ -712,7 +712,7 @@ macro_rules! iterator {\n \n macro_rules! make_slice {\n     ($t: ty => $result: ty: $start: expr, $end: expr) => {{\n-        let diff = $end as uint - $start as uint;\n+        let diff = $end as usize - $start as usize;\n         let len = if mem::size_of::<T>() == 0 {\n             diff\n         } else {\n@@ -733,28 +733,28 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>> for Iter<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<usize>> for Iter<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.as_slice().index(index)\n     }\n }\n@@ -792,20 +792,20 @@ impl<'a, T> Clone for Iter<'a, T> {\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Iter<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         let (exact, _) = self.size_hint();\n         exact\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a T> {\n+    fn idx(&mut self, index: usize) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n                 if mem::size_of::<T>() == 0 {\n                     // Use a non-null pointer value\n                     Some(&mut *(1 as *mut _))\n                 } else {\n-                    Some(transmute(self.ptr.offset(index as int)))\n+                    Some(transmute(self.ptr.offset(index as isize)))\n                 }\n             } else {\n                 None\n@@ -824,26 +824,26 @@ pub struct IterMut<'a, T: 'a> {\n \n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::Range<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::Range<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::Range<uint>) -> &[T] {\n+    fn index(&self, index: &ops::Range<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeTo<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeTo<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeTo<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeTo<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::Index<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::Index<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     type Output = [T];\n     #[inline]\n-    fn index(&self, index: &ops::RangeFrom<uint>) -> &[T] {\n+    fn index(&self, index: &ops::RangeFrom<usize>) -> &[T] {\n         self.index(&RangeFull).index(index)\n     }\n }\n@@ -857,23 +857,23 @@ impl<'a, T> ops::Index<RangeFull> for IterMut<'a, T> {\n }\n \n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::Range<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::Range<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::Range<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::Range<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeTo<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeTo<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeTo<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeTo<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n #[unstable(feature = \"core\")]\n-impl<'a, T> ops::IndexMut<ops::RangeFrom<uint>> for IterMut<'a, T> {\n+impl<'a, T> ops::IndexMut<ops::RangeFrom<usize>> for IterMut<'a, T> {\n     #[inline]\n-    fn index_mut(&mut self, index: &ops::RangeFrom<uint>) -> &mut [T] {\n+    fn index_mut(&mut self, index: &ops::RangeFrom<usize>) -> &mut [T] {\n         self.index_mut(&RangeFull).index_mut(index)\n     }\n }\n@@ -952,7 +952,7 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.finished {\n             (0, Some(0))\n         } else {\n@@ -1030,7 +1030,7 @@ impl<'a, T, P> Iterator for SplitMut<'a, T, P> where P: FnMut(&T) -> bool {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.finished {\n             (0, Some(0))\n         } else {\n@@ -1070,7 +1070,7 @@ impl<'a, T, P> DoubleEndedIterator for SplitMut<'a, T, P> where\n /// times.\n struct GenericSplitN<I> {\n     iter: I,\n-    count: uint,\n+    count: usize,\n     invert: bool\n }\n \n@@ -1088,7 +1088,7 @@ impl<T, I: SplitIter<Item=T>> Iterator for GenericSplitN<I> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (lower, upper_opt) = self.iter.size_hint();\n         (lower, upper_opt.map(|upper| cmp::min(self.count + 1, upper)))\n     }\n@@ -1138,7 +1138,7 @@ macro_rules! forward_iterator {\n             }\n \n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.inner.size_hint()\n             }\n         }\n@@ -1155,7 +1155,7 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T:'a> {\n     v: &'a [T],\n-    size: uint\n+    size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1174,7 +1174,7 @@ impl<'a, T> Iterator for Windows<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.size > self.v.len() {\n             (0, Some(0))\n         } else {\n@@ -1204,12 +1204,12 @@ impl<'a, T> ExactSizeIterator for Windows<'a, T> {}\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.size_hint().0\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n         if index + self.size > self.v.len() {\n             None\n         } else {\n@@ -1227,7 +1227,7 @@ impl<'a, T> RandomAccessIterator for Windows<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chunks<'a, T:'a> {\n     v: &'a [T],\n-    size: uint\n+    size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1247,7 +1247,7 @@ impl<'a, T> Iterator for Chunks<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n@@ -1281,12 +1281,12 @@ impl<'a, T> ExactSizeIterator for Chunks<'a, T> {}\n #[unstable(feature = \"core\", reason = \"trait is experimental\")]\n impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n     #[inline]\n-    fn indexable(&self) -> uint {\n+    fn indexable(&self) -> usize {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n     }\n \n     #[inline]\n-    fn idx(&mut self, index: uint) -> Option<&'a [T]> {\n+    fn idx(&mut self, index: usize) -> Option<&'a [T]> {\n         if index < self.indexable() {\n             let lo = index * self.size;\n             let mut hi = lo + self.size;\n@@ -1305,7 +1305,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ChunksMut<'a, T:'a> {\n     v: &'a mut [T],\n-    chunk_size: uint\n+    chunk_size: usize\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1326,7 +1326,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         if self.v.len() == 0 {\n             (0, Some(0))\n         } else {\n@@ -1402,15 +1402,15 @@ pub fn mut_ref_slice<'a, A>(s: &'a mut A) -> &'a mut [A] {\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const uint;\n+/// let ptr = 0x1234 as *const usize;\n /// let amt = 10;\n /// unsafe {\n ///     let slice = slice::from_raw_parts(ptr, amt);\n /// }\n /// ```\n #[inline]\n #[unstable(feature = \"core\")]\n-pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: uint) -> &'a [T] {\n+pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: usize) -> &'a [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n@@ -1422,7 +1422,7 @@ pub unsafe fn from_raw_parts<'a, T>(p: *const T, len: uint) -> &'a [T] {\n /// mutable slice.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n+pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: p, len: len })\n }\n \n@@ -1445,7 +1445,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n /// use std::slice;\n ///\n /// // manifest a slice out of thin air!\n-/// let ptr = 0x1234 as *const uint;\n+/// let ptr = 0x1234 as *const usize;\n /// let amt = 10;\n /// unsafe {\n ///     let slice = slice::from_raw_buf(&ptr, amt);\n@@ -1455,7 +1455,7 @@ pub unsafe fn from_raw_parts_mut<'a, T>(p: *mut T, len: uint) -> &'a mut [T] {\n #[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\",\n              reason = \"use from_raw_parts\")]\n-pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n+pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: usize) -> &'a [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n \n@@ -1469,7 +1469,7 @@ pub unsafe fn from_raw_buf<'a, T>(p: &'a *const T, len: uint) -> &'a [T] {\n #[unstable(feature = \"core\")]\n #[deprecated(since = \"1.0.0\",\n              reason = \"use from_raw_parts_mut\")]\n-pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: uint) -> &'a mut [T] {\n+pub unsafe fn from_raw_mut_buf<'a, T>(p: &'a *mut T, len: usize) -> &'a mut [T] {\n     transmute(RawSlice { data: *p, len: len })\n }\n \n@@ -1606,4 +1606,4 @@ impl_int_slices! { u8,   i8  }\n impl_int_slices! { u16,  i16 }\n impl_int_slices! { u32,  i32 }\n impl_int_slices! { u64,  i64 }\n-impl_int_slices! { uint, int }\n+impl_int_slices! { usize, isize }"}]}