{"sha": "a1b4afe0670fb1603b056f317a301ed527064ef5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYjRhZmUwNjcwZmIxNjAzYjA1NmYzMTdhMzAxZWQ1MjcwNjRlZjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-21T20:44:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-23T13:49:47Z"}, "message": "Update coherence rules to be more flexible for `impl Trait for Type`", "tree": {"sha": "00fb72228420f38bff6d74a044544560a65e92b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00fb72228420f38bff6d74a044544560a65e92b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1b4afe0670fb1603b056f317a301ed527064ef5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b4afe0670fb1603b056f317a301ed527064ef5", "html_url": "https://github.com/rust-lang/rust/commit/a1b4afe0670fb1603b056f317a301ed527064ef5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1b4afe0670fb1603b056f317a301ed527064ef5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b43810841a7825d37ecc6564b246a1a5f109667", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b43810841a7825d37ecc6564b246a1a5f109667", "html_url": "https://github.com/rust-lang/rust/commit/5b43810841a7825d37ecc6564b246a1a5f109667"}], "stats": {"total": 95, "additions": 49, "deletions": 46}, "files": [{"sha": "0b3eca7c07df02735a54e03502002198e9159864", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 49, "deletions": 46, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/a1b4afe0670fb1603b056f317a301ed527064ef5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1b4afe0670fb1603b056f317a301ed527064ef5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a1b4afe0670fb1603b056f317a301ed527064ef5", "patch": "@@ -104,6 +104,32 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n     }\n }\n \n+pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n+    /*!\n+     *\n+     * For coherence, when we have `impl Trait for Type`, we need to\n+     * guarantee that `Type` is \"local\" to the\n+     * crate.  For our purposes, this means that it must contain\n+     * some nominal type defined in this crate.\n+     */\n+\n+    let mut found_nominal = false;\n+    do ty::walk_ty(original_type) |t| {\n+        match get(t).sty {\n+            ty_enum(def_id, _) |\n+            ty_trait(def_id, _, _) |\n+            ty_struct(def_id, _) => {\n+                if def_id.crate == ast::local_crate {\n+                    found_nominal = true;\n+                }\n+            }\n+\n+            _ => { }\n+        }\n+    }\n+    return found_nominal;\n+}\n+\n // Returns the def ID of the base type, if there is one.\n pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n                             span: span,\n@@ -161,8 +187,7 @@ pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n \n-        base_type_def_ids: HashMap(),\n-        privileged_implementations: HashMap()\n+        base_type_def_ids: HashMap()\n     }\n }\n \n@@ -174,11 +199,6 @@ pub struct CoherenceChecker {\n     // definition ID.\n \n     base_type_def_ids: HashMap<def_id,def_id>,\n-\n-    // A set of implementations in privileged scopes; i.e. those\n-    // implementations that are defined in the same scope as their base types.\n-\n-    privileged_implementations: HashMap<node_id,()>,\n }\n \n pub impl CoherenceChecker {\n@@ -615,27 +635,11 @@ pub impl CoherenceChecker {\n                         visit_mod(module_, item.span, item.id, (), visitor);\n                     }\n                     item_impl(_, opt_trait, _, _) => {\n-                        let mut ok = false;\n-                        match self.base_type_def_ids.find(\n-                            &local_def(item.id)) {\n-\n-                            None => {\n-                                // Nothing to do.\n-                            }\n-                            Some(base_type_def_id) => {\n-                                // Check to see whether the implementation is\n-                                // in the same crate as its base type.\n-\n-                                if base_type_def_id.crate == local_crate {\n-                                    // Record that this implementation is OK.\n-                                    self.privileged_implementations.insert\n-                                        (item.id, ());\n-                                    ok = true;\n-                                }\n-                            }\n-                        }\n-\n-                        if !ok {\n+                        // `for_ty` is `Type` in `impl Trait for Type`\n+                        let for_ty =\n+                            ty::node_id_to_type(self.crate_context.tcx,\n+                                                item.id);\n+                        if !type_is_defined_in_local_crate(for_ty) {\n                             // This implementation is not in scope of its base\n                             // type. This still might be OK if the trait is\n                             // defined in the same crate.\n@@ -655,25 +659,24 @@ pub impl CoherenceChecker {\n                                                       implement a trait or \\\n                                                       new type instead\");\n                                 }\n-                                _ => ()\n-                          }\n \n-                          for opt_trait.each |trait_ref| {\n-                                // This is OK if and only if the trait was\n-                                // defined in this crate.\n-\n-                                let trait_def_id =\n-                                    self.trait_ref_to_trait_def_id(\n-                                        *trait_ref);\n-\n-                                if trait_def_id.crate != local_crate {\n-                                    let session = self.crate_context.tcx.sess;\n-                                    session.span_err(item.span,\n-                                                     ~\"cannot provide an \\\n-                                                       extension \\\n-                                                       implementation for a \\\n-                                                       trait not defined in \\\n-                                                       this crate\");\n+                                Some(trait_ref) => {\n+                                    // This is OK if and only if the trait was\n+                                    // defined in this crate.\n+\n+                                    let trait_def_id =\n+                                        self.trait_ref_to_trait_def_id(\n+                                            trait_ref);\n+\n+                                    if trait_def_id.crate != local_crate {\n+                                        let session = self.crate_context.tcx.sess;\n+                                        session.span_err(item.span,\n+                                                         ~\"cannot provide an \\\n+                                                           extension \\\n+                                                           implementation for a \\\n+                                                           trait not defined in \\\n+                                                           this crate\");\n+                                    }\n                                 }\n                             }\n                         }"}]}