{"sha": "37b5e91544210e0520edb6056a37c18037c88537", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3YjVlOTE1NDQyMTBlMDUyMGVkYjYwNTZhMzdjMTgwMzdjODg1Mzc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-19T17:23:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-19T17:40:38Z"}, "message": "rustc: Assert that each basic block isn't terminated before adding instructions to it", "tree": {"sha": "2eca4eae6f320d16eee34dfde4e66171b71b30bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eca4eae6f320d16eee34dfde4e66171b71b30bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37b5e91544210e0520edb6056a37c18037c88537", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37b5e91544210e0520edb6056a37c18037c88537", "html_url": "https://github.com/rust-lang/rust/commit/37b5e91544210e0520edb6056a37c18037c88537", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37b5e91544210e0520edb6056a37c18037c88537/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9287641c863df40561e0cca188fee1842cbe13e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9287641c863df40561e0cca188fee1842cbe13e2", "html_url": "https://github.com/rust-lang/rust/commit/9287641c863df40561e0cca188fee1842cbe13e2"}], "stats": {"total": 103, "additions": 101, "deletions": 2}, "files": [{"sha": "93284e5ad49d553d0f1abe439df4b6b36a75595e", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 100, "deletions": 1, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/37b5e91544210e0520edb6056a37c18037c88537/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b5e91544210e0520edb6056a37c18037c88537/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=37b5e91544210e0520edb6056a37c18037c88537", "patch": "@@ -832,44 +832,61 @@ native mod rustllvm = llvm_lib {\n \n /* Slightly more terse object-interface to LLVM's 'builder' functions. */\n \n-obj builder(BuilderRef B) {\n+// FIXME: Do we want to support mutable object fields?\n+obj builder(BuilderRef B, @mutable bool terminated) {\n \n     /* Terminators */\n     fn RetVoid()  -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildRetVoid(B);\n     }\n \n     fn Ret(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildRet(B, V);\n     }\n \n     fn AggregateRet(vec[ValueRef] RetVals) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildAggregateRet(B,\n                                        _vec.buf[ValueRef](RetVals),\n                                        _vec.len[ValueRef](RetVals));\n     }\n \n     fn Br(BasicBlockRef Dest) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildBr(B, Dest);\n     }\n \n     fn CondBr(ValueRef If, BasicBlockRef Then,\n               BasicBlockRef Else) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildCondBr(B, If, Then, Else);\n     }\n \n     fn Switch(ValueRef V, BasicBlockRef Else, uint NumCases) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildSwitch(B, V, Else, NumCases);\n     }\n \n     fn IndirectBr(ValueRef Addr, uint NumDests) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildIndirectBr(B, Addr, NumDests);\n     }\n \n     fn Invoke(ValueRef Fn,\n               vec[ValueRef] Args,\n               BasicBlockRef Then,\n               BasicBlockRef Catch) -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildInvoke(B, Fn,\n                                  _vec.buf[ValueRef](Args),\n                                  _vec.len[ValueRef](Args),\n@@ -878,282 +895,351 @@ obj builder(BuilderRef B) {\n     }\n \n     fn Unwind() -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildUnwind(B);\n     }\n \n     fn Unreachable() -> ValueRef {\n+        check (!*terminated);\n+        *terminated = true;\n         ret llvm.LLVMBuildUnreachable(B);\n     }\n \n     /* Arithmetic */\n     fn Add(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FAdd(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFAdd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Sub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FSub(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFSub(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Mul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NSWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn NUWMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FMul(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFMul(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn UDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildUDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn ExactSDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildExactSDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FDiv(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFDiv(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn URem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildURem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn SRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FRem(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFRem(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Shl(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildShl(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn LShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildLShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn AShr(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildAShr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn And(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildAnd(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Or(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildOr(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Xor(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildXor(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn BinOp(Opcode Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildBinOp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Neg(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NSWNeg(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNSWNeg(B, V, _str.buf(\"\"));\n     }\n \n     fn NUWNeg(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNUWNeg(B, V, _str.buf(\"\"));\n     }\n     fn FNeg(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFNeg(B, V, _str.buf(\"\"));\n     }\n     fn Not(ValueRef V) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildNot(B, V, _str.buf(\"\"));\n     }\n \n     /* Memory */\n     fn Malloc(TypeRef Ty) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildMalloc(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayMalloc(TypeRef Ty, ValueRef Val) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildArrayMalloc(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Alloca(TypeRef Ty) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildAlloca(B, Ty, _str.buf(\"\"));\n     }\n \n     fn ArrayAlloca(TypeRef Ty, ValueRef Val) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildArrayAlloca(B, Ty, Val, _str.buf(\"\"));\n     }\n \n     fn Free(ValueRef PointerVal) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFree(B, PointerVal);\n     }\n \n     fn Load(ValueRef PointerVal) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildLoad(B, PointerVal, _str.buf(\"\"));\n     }\n \n     fn Store(ValueRef Val, ValueRef Ptr) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildStore(B, Val, Ptr);\n     }\n \n     fn GEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildGEP(B, Pointer,\n                               _vec.buf[ValueRef](Indices),\n                               _vec.len[ValueRef](Indices),\n                               _str.buf(\"\"));\n     }\n \n     fn InBoundsGEP(ValueRef Pointer, vec[ValueRef] Indices) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildInBoundsGEP(B, Pointer,\n                                       _vec.buf[ValueRef](Indices),\n                                       _vec.len[ValueRef](Indices),\n                                       _str.buf(\"\"));\n     }\n \n     fn StructGEP(ValueRef Pointer, uint Idx) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildStructGEP(B, Pointer, Idx, _str.buf(\"\"));\n     }\n \n     fn GlobalString(sbuf Str) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildGlobalString(B, Str, _str.buf(\"\"));\n     }\n \n     fn GlobalStringPtr(sbuf Str) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildGlobalStringPtr(B, Str, _str.buf(\"\"));\n     }\n \n     /* Casts */\n     fn Trunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildZExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToUI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPToUI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPToSI(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPToSI(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn UIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildUIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SIToFP(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSIToFP(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPTrunc(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPTrunc(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPExt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPExt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PtrToInt(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildPtrToInt(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntToPtr(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildIntToPtr(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn BitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn ZExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildZExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn SExtOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSExtOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn TruncOrBitCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildTruncOrBitCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn Cast(Opcode Op, ValueRef Val, TypeRef DestTy, sbuf Name) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildCast(B, Op, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn PointerCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildPointerCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn IntCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildIntCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n     fn FPCast(ValueRef Val, TypeRef DestTy) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFPCast(B, Val, DestTy, _str.buf(\"\"));\n     }\n \n \n     /* Comparisons */\n     fn ICmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n \n     /* Miscellaneous instructions */\n     fn Phi(TypeRef Ty, vec[ValueRef] vals,\n            vec[BasicBlockRef] bbs) -> ValueRef {\n+        check (!*terminated);\n         auto phi = llvm.LLVMBuildPhi(B, Ty, _str.buf(\"\"));\n         check (_vec.len[ValueRef](vals) == _vec.len[BasicBlockRef](bbs));\n         llvm.LLVMAddIncoming(phi,\n@@ -1174,13 +1260,15 @@ obj builder(BuilderRef B) {\n     }\n \n     fn Call(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildCall(B, Fn,\n                                _vec.buf[ValueRef](Args),\n                                _vec.len[ValueRef](Args),\n                                _str.buf(\"\"));\n     }\n \n     fn FastCall(ValueRef Fn, vec[ValueRef] Args) -> ValueRef {\n+        check (!*terminated);\n         auto v = llvm.LLVMBuildCall(B, Fn,\n                                     _vec.buf[ValueRef](Args),\n                                     _vec.len[ValueRef](Args),\n@@ -1190,49 +1278,60 @@ obj builder(BuilderRef B) {\n     }\n \n     fn Select(ValueRef If, ValueRef Then, ValueRef Else) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildSelect(B, If, Then, Else, _str.buf(\"\"));\n     }\n \n     fn VAArg(ValueRef List, TypeRef Ty) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildVAArg(B, List, Ty, _str.buf(\"\"));\n     }\n \n     fn ExtractElement(ValueRef VecVal, ValueRef Index) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildExtractElement(B, VecVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertElement(ValueRef VecVal, ValueRef EltVal,\n                      ValueRef Index) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildInsertElement(B, VecVal, EltVal, Index,\n                                         _str.buf(\"\"));\n     }\n \n     fn ShuffleVector(ValueRef V1, ValueRef V2, ValueRef Mask) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildShuffleVector(B, V1, V2, Mask, _str.buf(\"\"));\n     }\n \n     fn ExtractValue(ValueRef AggVal, uint Index) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildExtractValue(B, AggVal, Index, _str.buf(\"\"));\n     }\n \n     fn InsertValue(ValueRef AggVal, ValueRef EltVal,\n                    uint Index) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildInsertValue(B, AggVal, EltVal, Index, _str.buf(\"\"));\n     }\n \n     fn IsNull(ValueRef Val) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildIsNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn IsNotNull(ValueRef Val) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildIsNotNull(B, Val, _str.buf(\"\"));\n     }\n \n     fn PtrDiff(ValueRef LHS, ValueRef RHS) -> ValueRef {\n+        check (!*terminated);\n         ret llvm.LLVMBuildPtrDiff(B, LHS, RHS, _str.buf(\"\"));\n     }\n \n     fn Trap() -> ValueRef {\n+        check (!*terminated);\n         let BasicBlockRef BB = llvm.LLVMGetInsertBlock(B);\n         let ValueRef FN = llvm.LLVMGetBasicBlockParent(BB);\n         let ModuleRef M = llvm.LLVMGetGlobalParent(FN);"}, {"sha": "e83945d0ff3e8ab316511b0359340afed6781e84", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/37b5e91544210e0520edb6056a37c18037c88537/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b5e91544210e0520edb6056a37c18037c88537/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=37b5e91544210e0520edb6056a37c18037c88537", "patch": "@@ -5401,7 +5401,7 @@ fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n fn new_builder(BasicBlockRef llbb) -> builder {\n     let BuilderRef llbuild = llvm.LLVMCreateBuilder();\n     llvm.LLVMPositionBuilderAtEnd(llbuild, llbb);\n-    ret builder(llbuild);\n+    ret builder(llbuild, @mutable false);\n }\n \n // You probably don't want to use this one. See the"}]}