{"sha": "afa1dddcf97cf6008cfb447739b4b61e04f86660", "node_id": "C_kwDOAAsO6NoAKGFmYTFkZGRjZjk3Y2Y2MDA4Y2ZiNDQ3NzM5YjRiNjFlMDRmODY2NjA", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-02T18:38:23Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-13T01:01:33Z"}, "message": "Store protectors outside Item, pack Tag and Perm\n\nPreviously, Item was a struct of a NonZeroU64, an Option which was\nusually unset or irrelevant, and a 4-variant enum. So collectively, the\nsize of an Item was 24 bytes, but only 8 bytes were used for the most\npart.\n\nSo this takes advantage of the fact that it is probably impossible to\nexhaust the total space of SbTags, and steals 3 bits from it to pack the\nwhole struct into a single u64. This bit-packing means that we reduce\npeak memory usage when Miri goes memory-bound by ~3x. We also get CPU\nperformance improvements of varying size, because not only are we simply\naccessing less memory, we can now compare a Vec<Item> using a memcmp\nbecause it does not have any padding.", "tree": {"sha": "43ec8b926f1cf0078e3a9e40030c6d556febb5ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ec8b926f1cf0078e3a9e40030c6d556febb5ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afa1dddcf97cf6008cfb447739b4b61e04f86660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afa1dddcf97cf6008cfb447739b4b61e04f86660", "html_url": "https://github.com/rust-lang/rust/commit/afa1dddcf97cf6008cfb447739b4b61e04f86660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afa1dddcf97cf6008cfb447739b4b61e04f86660/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e106617f10b2431aeb0fdb84d50cbdcb0d4dad8", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e106617f10b2431aeb0fdb84d50cbdcb0d4dad8", "html_url": "https://github.com/rust-lang/rust/commit/6e106617f10b2431aeb0fdb84d50cbdcb0d4dad8"}], "stats": {"total": 347, "additions": 233, "deletions": 114}, "files": [{"sha": "122bee2970e24e8cfa1920620ce0c69e99a60917", "filename": "src/machine.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -54,15 +54,18 @@ pub struct FrameData<'tcx> {\n     /// for the start of this frame. When we finish executing this frame,\n     /// we use this to register a completed event with `measureme`.\n     pub timing: Option<measureme::DetachedTiming>,\n+\n+    pub protected_tags: Vec<SbTag>,\n }\n \n impl<'tcx> std::fmt::Debug for FrameData<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         // Omitting `timing`, it does not support `Debug`.\n-        let FrameData { call_id, catch_unwind, timing: _ } = self;\n+        let FrameData { call_id, catch_unwind, timing: _, protected_tags } = self;\n         f.debug_struct(\"FrameData\")\n             .field(\"call_id\", call_id)\n             .field(\"catch_unwind\", catch_unwind)\n+            .field(\"protected_tags\", protected_tags)\n             .finish()\n     }\n }\n@@ -788,6 +791,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n+                &machine.threads,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -819,6 +823,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n+                &machine.threads,\n             )?;\n         }\n         if let Some(weak_memory) = &alloc_extra.weak_memory {\n@@ -852,6 +857,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n                 tag,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n+                &machine.threads,\n             )\n         } else {\n             Ok(())\n@@ -892,7 +898,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             stacked_borrows.borrow_mut().new_call()\n         });\n \n-        let extra = FrameData { call_id, catch_unwind: None, timing };\n+        let extra = FrameData { call_id, catch_unwind: None, timing, protected_tags: Vec::new() };\n         Ok(frame.with_extra(extra))\n     }\n \n@@ -936,7 +942,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let timing = frame.extra.timing.take();\n         if let Some(stacked_borrows) = &ecx.machine.stacked_borrows {\n-            stacked_borrows.borrow_mut().end_call(frame.extra.call_id);\n+            stacked_borrows.borrow_mut().end_call(&frame.extra);\n         }\n         let res = ecx.handle_stack_pop_unwind(frame.extra, unwinding);\n         if let Some(profiler) = ecx.machine.profiler.as_ref() {"}, {"sha": "8996754be367273f30df1ffd765028218ea741dc", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 164, "deletions": 62, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -92,27 +92,99 @@ pub enum Permission {\n     Disabled,\n }\n \n-/// An item in the per-location borrow stack.\n-#[derive(Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Item {\n-    /// The permission this item grants.\n-    perm: Permission,\n-    /// The pointers the permission is granted to.\n-    tag: SbTag,\n-    /// An optional protector, ensuring the item cannot get popped until `CallId` is over.\n-    protector: Option<CallId>,\n+impl Permission {\n+    const UNIQUE: u64 = 0;\n+    const SHARED_READ_WRITE: u64 = 1;\n+    const SHARED_READ_ONLY: u64 = 2;\n+    const DISABLED: u64 = 3;\n+\n+    fn to_bits(self) -> u64 {\n+        match self {\n+            Permission::Unique => Self::UNIQUE,\n+            Permission::SharedReadWrite => Self::SHARED_READ_WRITE,\n+            Permission::SharedReadOnly => Self::SHARED_READ_ONLY,\n+            Permission::Disabled => Self::DISABLED,\n+        }\n+    }\n+\n+    fn from_bits(perm: u64) -> Self {\n+        match perm {\n+            Self::UNIQUE => Permission::Unique,\n+            Self::SHARED_READ_WRITE => Permission::SharedReadWrite,\n+            Self::SHARED_READ_ONLY => Permission::SharedReadOnly,\n+            Self::DISABLED => Permission::Disabled,\n+            _ => unreachable!(),\n+        }\n+    }\n }\n \n-impl fmt::Debug for Item {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"[{:?} for {:?}\", self.perm, self.tag)?;\n-        if let Some(call) = self.protector {\n-            write!(f, \" (call {})\", call)?;\n+mod item {\n+    use super::{Permission, SbTag};\n+    use std::fmt;\n+    use std::num::NonZeroU64;\n+\n+    /// An item in the per-location borrow stack.\n+    #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n+    pub struct Item(u64);\n+\n+    // An Item contains 3 bitfields:\n+    // * Bits 0-61 store an SbTag\n+    // * Bits 61-63 store a Permission\n+    // * Bit 64 stores a flag which indicates if we have a protector\n+    const TAG_MASK: u64 = u64::MAX >> 3;\n+    const PERM_MASK: u64 = 0x3 << 61;\n+    const PROTECTED_MASK: u64 = 0x1 << 63;\n+\n+    const PERM_SHIFT: u64 = 61;\n+    const PROTECTED_SHIFT: u64 = 63;\n+\n+    impl Item {\n+        pub fn new(tag: SbTag, perm: Permission, protected: bool) -> Self {\n+            assert!(tag.0.get() <= TAG_MASK);\n+            let packed_tag = tag.0.get();\n+            let packed_perm = perm.to_bits() << PERM_SHIFT;\n+            let packed_protected = (protected as u64) << PROTECTED_SHIFT;\n+\n+            let new = Self(packed_tag | packed_perm | packed_protected);\n+\n+            debug_assert!(new.tag() == tag);\n+            debug_assert!(new.perm() == perm);\n+            debug_assert!(new.protected() == protected);\n+\n+            new\n+        }\n+\n+        /// The pointers the permission is granted to.\n+        pub fn tag(self) -> SbTag {\n+            SbTag(NonZeroU64::new(self.0 & TAG_MASK).unwrap())\n+        }\n+\n+        /// The permission this item grants.\n+        pub fn perm(self) -> Permission {\n+            Permission::from_bits((self.0 & PERM_MASK) >> PERM_SHIFT)\n+        }\n+\n+        /// Whether or not there is a protector for this tag\n+        pub fn protected(self) -> bool {\n+            self.0 & PROTECTED_MASK > 0\n+        }\n+\n+        /// Set the Permission stored in this Item to Permission::Disabled\n+        pub fn set_disabled(&mut self) {\n+            // Clear the current set permission\n+            self.0 &= !PERM_MASK;\n+            // Write Permission::Disabled to the Permission bits\n+            self.0 |= Permission::Disabled.to_bits() << PERM_SHIFT;\n+        }\n+    }\n+\n+    impl fmt::Debug for Item {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            write!(f, \"[{:?} for {:?}]\", self.perm(), self.tag())\n         }\n-        write!(f, \"]\")?;\n-        Ok(())\n     }\n }\n+pub use item::Item;\n \n /// Extra per-allocation state.\n #[derive(Clone, Debug)]\n@@ -136,8 +208,8 @@ pub struct GlobalStateInner {\n     base_ptr_tags: FxHashMap<AllocId, SbTag>,\n     /// Next unused call ID (for protectors).\n     next_call_id: CallId,\n-    /// Those call IDs corresponding to functions that are still running.\n-    active_calls: FxHashSet<CallId>,\n+    /// All tags currently protected\n+    protected_tags: FxHashSet<SbTag>,\n     /// The pointer ids to trace\n     tracked_pointer_tags: HashSet<SbTag>,\n     /// The call ids to trace\n@@ -201,7 +273,7 @@ impl GlobalStateInner {\n             next_ptr_tag: SbTag(NonZeroU64::new(1).unwrap()),\n             base_ptr_tags: FxHashMap::default(),\n             next_call_id: NonZeroU64::new(1).unwrap(),\n-            active_calls: FxHashSet::default(),\n+            protected_tags: FxHashSet::default(),\n             tracked_pointer_tags,\n             tracked_call_ids,\n             retag_fields,\n@@ -221,17 +293,14 @@ impl GlobalStateInner {\n         if self.tracked_call_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedCallId(id));\n         }\n-        assert!(self.active_calls.insert(id));\n         self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n     }\n \n-    pub fn end_call(&mut self, id: CallId) {\n-        assert!(self.active_calls.remove(&id));\n-    }\n-\n-    fn is_active(&self, id: CallId) -> bool {\n-        self.active_calls.contains(&id)\n+    pub fn end_call(&mut self, frame: &machine::FrameData<'_>) {\n+        for tag in &frame.protected_tags {\n+            self.protected_tags.remove(tag);\n+        }\n     }\n \n     pub fn base_ptr_tag(&mut self, id: AllocId) -> SbTag {\n@@ -287,7 +356,7 @@ impl<'tcx> Stack {\n     /// Find the first write-incompatible item above the given one --\n     /// i.e, find the height to which the stack will be truncated when writing to `granting`.\n     fn find_first_write_incompatible(&self, granting: usize) -> usize {\n-        let perm = self.get(granting).unwrap().perm;\n+        let perm = self.get(granting).unwrap().perm();\n         match perm {\n             Permission::SharedReadOnly => bug!(\"Cannot use SharedReadOnly for writing\"),\n             Permission::Disabled => bug!(\"Cannot use Disabled for anything\"),\n@@ -299,7 +368,7 @@ impl<'tcx> Stack {\n                 // The SharedReadWrite *just* above us are compatible, to skip those.\n                 let mut idx = granting + 1;\n                 while let Some(item) = self.get(idx) {\n-                    if item.perm == Permission::SharedReadWrite {\n+                    if item.perm() == Permission::SharedReadWrite {\n                         // Go on.\n                         idx += 1;\n                     } else {\n@@ -325,32 +394,44 @@ impl<'tcx> Stack {\n         provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n-        if global.tracked_pointer_tags.contains(&item.tag) {\n+        if global.tracked_pointer_tags.contains(&item.tag()) {\n             register_diagnostic(NonHaltingDiagnostic::PoppedPointerTag(\n                 *item,\n                 provoking_access.map(|(tag, _alloc_range, _size, access)| (tag, access)),\n             ));\n         }\n \n-        if let Some(call) = item.protector {\n-            if global.is_active(call) {\n-                if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n-                    Err(err_sb_ub(\n-                        format!(\n-                            \"not granting access to tag {:?} because incompatible item is protected: {:?}\",\n-                            tag, item\n-                        ),\n-                        None,\n-                        tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag))),\n-                    ))?\n-                } else {\n-                    Err(err_sb_ub(\n-                        format!(\"deallocating while item is protected: {:?}\", item),\n-                        None,\n-                        None,\n-                    ))?\n-                }\n+        if !item.protected() {\n+            return Ok(());\n+        }\n+\n+        if global.protected_tags.contains(&item.tag()) {\n+            let call_id = threads\n+                .all_stacks()\n+                .flatten()\n+                .find(|t| t.extra.protected_tags.contains(&item.tag()))\n+                .map(|frame| frame.extra.call_id)\n+                .unwrap(); // FIXME: Surely we should find something, but a panic seems wrong here?\n+            if let Some((tag, _alloc_range, _offset, _access)) = provoking_access {\n+                Err(err_sb_ub(\n+                    format!(\n+                        \"not granting access to tag {:?} because incompatible item is protected: {:?} (call {:?})\",\n+                        tag, item, call_id\n+                    ),\n+                    None,\n+                    tag.and_then(|tag| alloc_history.get_logs_relevant_to(tag, Some(item.tag()))),\n+                ))?\n+            } else {\n+                Err(err_sb_ub(\n+                    format!(\n+                        \"deallocating while item is protected: {:?} (call {:?})\",\n+                        item, call_id\n+                    ),\n+                    None,\n+                    None,\n+                ))?\n             }\n         }\n         Ok(())\n@@ -369,6 +450,7 @@ impl<'tcx> Stack {\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n \n@@ -399,8 +481,9 @@ impl<'tcx> Stack {\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n                     alloc_history,\n+                    threads,\n                 )?;\n-                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n                 Ok(())\n             })?;\n         } else {\n@@ -425,8 +508,9 @@ impl<'tcx> Stack {\n                     Some((tag, alloc_range, offset, access)),\n                     global,\n                     alloc_history,\n+                    threads,\n                 )?;\n-                alloc_history.log_invalidation(item.tag, alloc_range, current_span);\n+                alloc_history.log_invalidation(item.tag(), alloc_range, current_span);\n                 Ok(())\n             })?;\n         }\n@@ -439,9 +523,9 @@ impl<'tcx> Stack {\n             for i in 0..self.len() {\n                 let item = self.get(i).unwrap();\n                 // Skip disabled items, they cannot be matched anyway.\n-                if !matches!(item.perm, Permission::Disabled) {\n+                if !matches!(item.perm(), Permission::Disabled) {\n                     // We are looking for a strict upper bound, so add 1 to this tag.\n-                    max = cmp::max(item.tag.0.checked_add(1).unwrap(), max);\n+                    max = cmp::max(item.tag().0.checked_add(1).unwrap(), max);\n                 }\n             }\n             if let Some(unk) = self.unknown_bottom() {\n@@ -467,6 +551,7 @@ impl<'tcx> Stack {\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make sure there is a granting item.\n         self.find_granting(AccessKind::Write, tag, exposed_tags).map_err(|_| {\n@@ -482,7 +567,7 @@ impl<'tcx> Stack {\n         // Step 2: Consider all items removed. This checks for protectors.\n         for idx in (0..self.len()).rev() {\n             let item = self.get(idx).unwrap();\n-            Stack::item_popped(&item, None, global, alloc_history)?;\n+            Stack::item_popped(&item, None, global, alloc_history, threads)?;\n         }\n         Ok(())\n     }\n@@ -502,10 +587,11 @@ impl<'tcx> Stack {\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n         alloc_history: &mut AllocHistory,\n         exposed_tags: &FxHashSet<SbTag>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n         let access =\n-            if new.perm.grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n+            if new.perm().grants(AccessKind::Write) { AccessKind::Write } else { AccessKind::Read };\n \n         // Now we figure out which item grants our parent (`derived_from`) this kind of access.\n         // We use that to determine where to put the new item.\n@@ -517,7 +603,7 @@ impl<'tcx> Stack {\n         // Compute where to put the new item.\n         // Either way, we ensure that we insert the new item in a way such that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        let new_idx = if new.perm == Permission::SharedReadWrite {\n+        let new_idx = if new.perm() == Permission::SharedReadWrite {\n             assert!(\n                 access == AccessKind::Write,\n                 \"this case only makes sense for stack-like accesses\"\n@@ -550,6 +636,7 @@ impl<'tcx> Stack {\n                 current_span,\n                 alloc_history,\n                 exposed_tags,\n+                threads,\n             )?;\n \n             // We insert \"as far up as possible\": We know only compatible items are remaining\n@@ -571,7 +658,7 @@ impl<'tcx> Stack {\n impl<'tcx> Stacks {\n     /// Creates new stack with initial tag.\n     fn new(size: Size, perm: Permission, tag: SbTag) -> Self {\n-        let item = Item { perm, tag, protector: None };\n+        let item = Item::new(tag, perm, false);\n         let stack = Stack::new(item);\n \n         Stacks {\n@@ -637,6 +724,7 @@ impl Stacks {\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n@@ -654,6 +742,7 @@ impl Stacks {\n                 &mut current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })\n     }\n@@ -666,6 +755,7 @@ impl Stacks {\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n@@ -683,6 +773,7 @@ impl Stacks {\n                 &mut current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })\n     }\n@@ -694,11 +785,12 @@ impl Stacks {\n         tag: SbTagExtra,\n         range: AllocRange,\n         state: &GlobalState,\n+        threads: &ThreadManager<'_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n         let state = state.borrow();\n         self.for_each(range, |offset, stack, history, exposed_tags| {\n-            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags)\n+            stack.dealloc(tag, (alloc_id, range, offset), &state, history, exposed_tags, threads)\n         })?;\n         Ok(())\n     }\n@@ -801,7 +893,6 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             });\n         }\n \n-        let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         trace!(\n             \"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind,\n@@ -812,6 +903,13 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             size.bytes()\n         );\n \n+        if protect {\n+            this.frame_mut().extra.protected_tags.push(new_tag);\n+            this.machine.stacked_borrows.as_mut().unwrap().get_mut().protected_tags.insert(new_tag);\n+        }\n+        // FIXME: can't hold the current span handle across the borrows of self above\n+        let current_span = &mut this.machine.current_span();\n+\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -848,15 +946,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     } else {\n                         Permission::SharedReadWrite\n                     };\n-                    let protector = if frozen {\n-                        protector\n+                    let protected = if frozen {\n+                        protect\n                     } else {\n                         // We do not protect inside UnsafeCell.\n                         // This fixes https://github.com/rust-lang/rust/issues/55005.\n-                        None\n+                        false\n                     };\n-                    let item = Item { perm, tag: new_tag, protector };\n+                    let item = Item::new(new_tag, perm, protected);\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+                    let threads = &this.machine.threads;\n                     stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n                         stack.grant(\n                             orig_tag,\n@@ -866,6 +965,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                             current_span,\n                             history,\n                             exposed_tags,\n+                            threads,\n                         )\n                     })\n                 })?;\n@@ -881,9 +981,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .as_mut()\n             .expect(\"we should have Stacked Borrows data\")\n             .borrow_mut();\n-        let item = Item { perm, tag: new_tag, protector };\n+        let item = Item::new(new_tag, perm, protect);\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+        let threads = &machine.threads;\n         let current_span = &mut machine.current_span(); // `get_alloc_extra_mut` invalidated our old `current_span`\n         stacked_borrows.for_each(range, |offset, stack, history, exposed_tags| {\n             stack.grant(\n@@ -894,6 +995,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 current_span,\n                 history,\n                 exposed_tags,\n+                threads,\n             )\n         })?;\n "}, {"sha": "1fa619a3ae4d48f819dcfa0eeacb5be0fce3a33a", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -141,7 +141,7 @@ impl AllocHistory {\n     ) -> InterpError<'tcx> {\n         let action = format!(\n             \"trying to reborrow {derived_from:?} for {new_perm:?} permission at {alloc_id:?}[{offset:#x}]\",\n-            new_perm = new.perm,\n+            new_perm = new.perm(),\n             offset = error_offset.bytes(),\n         );\n         err_sb_ub(\n@@ -185,7 +185,7 @@ fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n     if let SbTagExtra::Concrete(tag) = tag {\n         if (0..stack.len())\n             .map(|i| stack.get(i).unwrap())\n-            .any(|item| item.tag == tag && item.perm != Permission::Disabled)\n+            .any(|item| item.tag() == tag && item.perm() != Permission::Disabled)\n         {\n             \", but that tag only grants SharedReadOnly permission for this location\"\n         } else {"}, {"sha": "0863f8023277580357406da3f378f8c6c5e0d93a", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -37,7 +37,7 @@ pub struct Stack {\n }\n \n /// A very small cache of searches of the borrow stack\n-/// This maps tags to locations in the borrow stack. Any use of this still needs to do a\n+/// This maps items to locations in the borrow stack. Any use of this still needs to do a\n /// probably-cold random access into the borrow stack to figure out what `Permission` an\n /// `SbTag` grants. We could avoid this by also storing the `Permission` in the cache, but\n /// most lookups into the cache are immediately followed by access of the full borrow stack anyway.\n@@ -48,7 +48,7 @@ pub struct Stack {\n #[cfg(feature = \"stack-cache\")]\n #[derive(Clone, Debug)]\n struct StackCache {\n-    tags: [SbTag; CACHE_LEN], // Hot in find_granting\n+    items: [Item; CACHE_LEN], // Hot in find_granting\n     idx: [usize; CACHE_LEN],  // Hot in grant\n }\n \n@@ -59,11 +59,11 @@ impl StackCache {\n     /// We use the position in the cache to represent how recently a tag was used; the first position\n     /// is the most recently used tag. So an add shifts every element towards the end, and inserts\n     /// the new element at the start. We lose the last element.\n-    /// This strategy is effective at keeping the most-accessed tags in the cache, but it costs a\n+    /// This strategy is effective at keeping the most-accessed items in the cache, but it costs a\n     /// linear shift across the entire cache when we add a new tag.\n-    fn add(&mut self, idx: usize, tag: SbTag) {\n-        self.tags.copy_within(0..CACHE_LEN - 1, 1);\n-        self.tags[0] = tag;\n+    fn add(&mut self, idx: usize, item: Item) {\n+        self.items.copy_within(0..CACHE_LEN - 1, 1);\n+        self.items[0] = item;\n         self.idx.copy_within(0..CACHE_LEN - 1, 1);\n         self.idx[0] = idx;\n     }\n@@ -80,20 +80,20 @@ impl Eq for Stack {}\n \n impl<'tcx> Stack {\n     /// Panics if any of the caching mechanisms have broken,\n-    /// - The StackCache indices don't refer to the parallel tags,\n-    /// - There are no Unique tags outside of first_unique..last_unique\n+    /// - The StackCache indices don't refer to the parallel items,\n+    /// - There are no Unique items outside of first_unique..last_unique\n     #[cfg(feature = \"expensive-debug-assertions\")]\n     fn verify_cache_consistency(&self) {\n         // Only a full cache needs to be valid. Also see the comments in find_granting_cache\n         // and set_unknown_bottom.\n         if self.borrows.len() >= CACHE_LEN {\n-            for (tag, stack_idx) in self.cache.tags.iter().zip(self.cache.idx.iter()) {\n-                assert_eq!(self.borrows[*stack_idx].tag, *tag);\n+            for (tag, stack_idx) in self.cache.items.iter().zip(self.cache.idx.iter()) {\n+                assert_eq!(self.borrows[*stack_idx], *tag);\n             }\n         }\n \n         for (idx, item) in self.borrows.iter().enumerate() {\n-            if item.perm == Permission::Unique {\n+            if item.perm() == Permission::Unique {\n                 assert!(\n                     self.unique_range.contains(&idx),\n                     \"{:?} {:?}\",\n@@ -128,7 +128,7 @@ impl<'tcx> Stack {\n                     .rev() // search top-to-bottom\n                     .find_map(|(idx, item)| {\n                         // If the item fits and *might* be this wildcard, use it.\n-                        if item.perm.grants(access) && exposed_tags.contains(&item.tag) {\n+                        if item.perm().grants(access) && exposed_tags.contains(&item.tag()) {\n                             Some(idx)\n                         } else {\n                             None\n@@ -161,9 +161,9 @@ impl<'tcx> Stack {\n         // If we didn't find the tag in the cache, fall back to a linear search of the\n         // whole stack, and add the tag to the cache.\n         for (stack_idx, item) in self.borrows.iter().enumerate().rev() {\n-            if tag == item.tag && item.perm.grants(access) {\n+            if tag == item.tag() && item.perm().grants(access) {\n                 #[cfg(feature = \"stack-cache\")]\n-                self.cache.add(stack_idx, tag);\n+                self.cache.add(stack_idx, *item);\n                 return Some(stack_idx);\n             }\n         }\n@@ -175,7 +175,7 @@ impl<'tcx> Stack {\n         // This looks like a common-sense optimization; we're going to do a linear search of the\n         // cache or the borrow stack to scan the shorter of the two. This optimization is miniscule\n         // and this check actually ensures we do not access an invalid cache.\n-        // When a stack is created and when tags are removed from the top of the borrow stack, we\n+        // When a stack is created and when items are removed from the top of the borrow stack, we\n         // need some valid value to populate the cache. In both cases, we try to use the bottom\n         // item. But when the stack is cleared in `set_unknown_bottom` there is nothing we could\n         // place in the cache that is correct. But due to the way we populate the cache in\n@@ -185,21 +185,23 @@ impl<'tcx> Stack {\n             return None;\n         }\n         // Search the cache for the tag we're looking up\n-        let cache_idx = self.cache.tags.iter().position(|t| *t == tag)?;\n+        let cache_idx = self.cache.items.iter().position(|t| t.tag() == tag)?;\n         let stack_idx = self.cache.idx[cache_idx];\n         // If we found the tag, look up its position in the stack to see if it grants\n         // the required permission\n-        if self.borrows[stack_idx].perm.grants(access) {\n+        if self.cache.items[cache_idx].perm().grants(access) {\n             // If it does, and it's not already in the most-recently-used position, re-insert it at\n             // the most-recently-used position. This technically reduces the efficiency of the\n             // cache by duplicating elements, but current benchmarks do not seem to benefit from\n             // avoiding this duplication.\n             // But if the tag is in position 1, avoiding the duplicating add is trivial.\n+            // If it does, and it's not already in the most-recently-used position, move it there.\n+            // Except if the tag is in position 1, this is equivalent to just a swap, so do that.\n             if cache_idx == 1 {\n-                self.cache.tags.swap(0, 1);\n+                self.cache.items.swap(0, 1);\n                 self.cache.idx.swap(0, 1);\n             } else if cache_idx > 1 {\n-                self.cache.add(stack_idx, tag);\n+                self.cache.add(stack_idx, self.cache.items[cache_idx]);\n             }\n             Some(stack_idx)\n         } else {\n@@ -224,7 +226,7 @@ impl<'tcx> Stack {\n         if self.unique_range.end >= new_idx {\n             self.unique_range.end += 1;\n         }\n-        if new.perm == Permission::Unique {\n+        if new.perm() == Permission::Unique {\n             // Make sure the possibly-unique range contains the new borrow\n             self.unique_range.start = self.unique_range.start.min(new_idx);\n             self.unique_range.end = self.unique_range.end.max(new_idx + 1);\n@@ -233,7 +235,7 @@ impl<'tcx> Stack {\n         // The above insert changes the meaning of every index in the cache >= new_idx, so now\n         // we need to find every one of those indexes and increment it.\n         // But if the insert is at the end (equivalent to a push), we can skip this step because\n-        // it didn't change the position of any other tags.\n+        // it didn't change the position of any other items.\n         if new_idx != self.borrows.len() - 1 {\n             for idx in &mut self.cache.idx {\n                 if *idx >= new_idx {\n@@ -243,7 +245,7 @@ impl<'tcx> Stack {\n         }\n \n         // This primes the cache for the next access, which is almost always the just-added tag.\n-        self.cache.add(new_idx, new.tag);\n+        self.cache.add(new_idx, new);\n \n         #[cfg(feature = \"expensive-debug-assertions\")]\n         self.verify_cache_consistency();\n@@ -255,9 +257,9 @@ impl<'tcx> Stack {\n             borrows: vec![item],\n             unknown_bottom: None,\n             #[cfg(feature = \"stack-cache\")]\n-            cache: StackCache { idx: [0; CACHE_LEN], tags: [item.tag; CACHE_LEN] },\n+            cache: StackCache { idx: [0; CACHE_LEN], items: [item; CACHE_LEN] },\n             #[cfg(feature = \"stack-cache\")]\n-            unique_range: if item.perm == Permission::Unique { 0..1 } else { 0..0 },\n+            unique_range: if item.perm() == Permission::Unique { 0..1 } else { 0..0 },\n         }\n     }\n \n@@ -298,10 +300,15 @@ impl<'tcx> Stack {\n             let lower = unique_range.start.max(disable_start);\n             let upper = (unique_range.end + 1).min(self.borrows.len());\n             for item in &mut self.borrows[lower..upper] {\n-                if item.perm == Permission::Unique {\n+                if item.perm() == Permission::Unique {\n                     log::trace!(\"access: disabling item {:?}\", item);\n                     visitor(*item)?;\n-                    item.perm = Permission::Disabled;\n+                    item.set_disabled();\n+                    for t in &mut self.cache.items {\n+                        if t.tag() == item.tag() {\n+                            t.set_disabled();\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -341,7 +348,7 @@ impl<'tcx> Stack {\n             // also possible that the whole cache is still valid. So we call this method to repair what\n             // aspects of the cache are now invalid, instead of resetting the whole thing to a trivially\n             // valid default state.\n-            let base_tag = self.borrows[0].tag;\n+            let base_tag = self.borrows[0];\n             let mut removed = 0;\n             let mut cursor = 0;\n             // Remove invalid entries from the cache by rotating them to the end of the cache, then\n@@ -350,15 +357,15 @@ impl<'tcx> Stack {\n             for _ in 0..CACHE_LEN - 1 {\n                 if self.cache.idx[cursor] >= start {\n                     self.cache.idx[cursor..CACHE_LEN - removed].rotate_left(1);\n-                    self.cache.tags[cursor..CACHE_LEN - removed].rotate_left(1);\n+                    self.cache.items[cursor..CACHE_LEN - removed].rotate_left(1);\n                     removed += 1;\n                 } else {\n                     cursor += 1;\n                 }\n             }\n             for i in CACHE_LEN - removed - 1..CACHE_LEN {\n                 self.cache.idx[i] = 0;\n-                self.cache.tags[i] = base_tag;\n+                self.cache.items[i] = base_tag;\n             }\n \n             if start < self.unique_range.start.saturating_sub(1) {"}, {"sha": "96135d093d96792d700c7cd7c9078e04d4654d22", "filename": "src/thread.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -281,6 +281,10 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n+    pub fn all_stacks(&self) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>]> {\n+        self.threads.iter().map(|t| &t.stack[..])\n+    }\n+\n     /// Create a new thread and returns its id.\n     fn create_thread(&mut self) -> ThreadId {\n         let new_thread_id = ThreadId::new(self.threads.len());"}, {"sha": "82c504cd836f9034b9161ac1d32624916a2e2c6b", "filename": "tests/fail/stacked_borrows/aliasing_mut1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut1.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n   --> $DIR/aliasing_mut1.rs:LL:CC\n    |\n LL | pub fn safe(_x: &mut i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "2973e22b2b793babf8e27dc7c48d0c8eb3f10686", "filename": "tests/fail/stacked_borrows/aliasing_mut2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut2.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n   --> $DIR/aliasing_mut2.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut i32) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "b9a7b810dbd8504ee9072780a79afc95b4217c42", "filename": "tests/fail/stacked_borrows/aliasing_mut4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Faliasing_mut4.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n   --> $DIR/aliasing_mut4.rs:LL:CC\n    |\n LL | pub fn safe(_x: &i32, _y: &mut Cell<i32>) {}\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "124731e85bd59ccf017e845b0ebed7a9db222982", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier1.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: deallocating while item is protected: [Unique for <TAG>] (call ID)\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [Unique for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "e09158dfb40836aac3890669ce130b6b56aa742e", "filename": "tests/fail/stacked_borrows/deallocate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_barrier2.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n+error: Undefined Behavior: deallocating while item is protected: [SharedReadWrite for <TAG>] (call ID)\n   --> RUSTLIB/alloc/src/alloc.rs:LL:CC\n    |\n LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [SharedReadWrite for <TAG> (call ID)]\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ deallocating while item is protected: [SharedReadWrite for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "cab6f392d1b116684a28217dbdfa5d2c449da38f", "filename": "tests/fail/stacked_borrows/illegal_write6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fillegal_write6.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n   --> $DIR/illegal_write6.rs:LL:CC\n    |\n LL |     unsafe { *y = 2 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "40d5147cadff53a3802a7559a037401e80705c51", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier1.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n   --> $DIR/invalidate_against_barrier1.rs:LL:CC\n    |\n LL |     let _val = unsafe { *x };\n-   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |                         ^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "30148396cc5d15b8ce981ecce646e80d143903b3", "filename": "tests/fail/stacked_borrows/invalidate_against_barrier2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Finvalidate_against_barrier2.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n   --> $DIR/invalidate_against_barrier2.rs:LL:CC\n    |\n LL |     unsafe { *x = 0 };\n-   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG> (call ID)]\n+   |              ^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [SharedReadOnly for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}, {"sha": "337a22967c7dd16a8e782a591da364fa768fe07a", "filename": "tests/fail/stacked_borrows/newtype_retagging.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/afa1dddcf97cf6008cfb447739b4b61e04f86660/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ffail%2Fstacked_borrows%2Fnewtype_retagging.stderr?ref=afa1dddcf97cf6008cfb447739b4b61e04f86660", "patch": "@@ -1,8 +1,8 @@\n-error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+error: Undefined Behavior: not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n   --> RUSTLIB/alloc/src/boxed.rs:LL:CC\n    |\n LL |         Box(unsafe { Unique::new_unchecked(raw) }, alloc)\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG> (call ID)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not granting access to tag <TAG> because incompatible item is protected: [Unique for <TAG>] (call ID)\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information"}]}