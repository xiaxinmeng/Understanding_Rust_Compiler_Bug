{"sha": "54f0bead8158eaf948c93d1cae93b60978937417", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ZjBiZWFkODE1OGVhZjk0OGM5M2QxY2FlOTNiNjA5Nzg5Mzc0MTc=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2014-12-30T20:54:17Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2015-02-19T23:32:59Z"}, "message": "Added string pattern traits and basic implementantions", "tree": {"sha": "f00cfcfa18db7183e05d3d441d0bcaf1489b79c0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f00cfcfa18db7183e05d3d441d0bcaf1489b79c0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54f0bead8158eaf948c93d1cae93b60978937417", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54f0bead8158eaf948c93d1cae93b60978937417", "html_url": "https://github.com/rust-lang/rust/commit/54f0bead8158eaf948c93d1cae93b60978937417", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54f0bead8158eaf948c93d1cae93b60978937417/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d68eb3d24843d2e269989563d45ceda920391fe0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d68eb3d24843d2e269989563d45ceda920391fe0", "html_url": "https://github.com/rust-lang/rust/commit/d68eb3d24843d2e269989563d45ceda920391fe0"}], "stats": {"total": 415, "additions": 289, "deletions": 126}, "files": [{"sha": "fb0c4c4f34f8a5043ad626d7cb9848680f291047", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 169, "deletions": 126, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=54f0bead8158eaf948c93d1cae93b60978937417", "patch": "@@ -36,12 +36,16 @@ use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n use usize;\n \n+pub use self::pattern::{Pattern, Matcher, ReverseMatcher, DoubleEndedMatcher};\n+\n+mod pattern;\n+\n macro_rules! delegate_iter {\n     (exact $te:ty : $ti:ty) => {\n         delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n-            fn len(&self) -> usize {\n+            fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n@@ -56,7 +60,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -78,7 +82,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -100,7 +104,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n+            fn size_hint(&self) -> (uint, Option<uint>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -149,6 +153,7 @@ impl FromStr for bool {\n \n /// An error returned when parsing a `bool` from a string fails.\n #[derive(Debug, Clone, PartialEq)]\n+#[allow(missing_copy_implementations)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ParseBoolError { _priv: () }\n \n@@ -178,7 +183,7 @@ pub enum Utf8Error {\n     /// The offset is guaranteed to be in bounds of the slice in question, and\n     /// the byte at the specified offset was the first invalid byte in the\n     /// sequence detected.\n-    InvalidByte(usize),\n+    InvalidByte(uint),\n \n     /// The byte slice was invalid because more bytes were needed but no more\n     /// bytes were available.\n@@ -227,7 +232,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n-    while *s.offset(len as isize) != 0 {\n+    while *s.offset(len as int) != 0 {\n         len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n@@ -250,7 +255,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -383,7 +388,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         let (len, _) = self.iter.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -428,16 +433,16 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n-    front_offset: usize,\n+    front_offset: uint,\n     iter: Chars<'a>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (usize, char);\n+    type Item = (uint, char);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(usize, char)> {\n+    fn next(&mut self) -> Option<(uint, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n         match self.iter.next() {\n             None => None,\n@@ -451,15 +456,15 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n         self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(usize, char)> {\n+    fn next_back(&mut self) -> Option<(uint, char)> {\n         match self.iter.next_back() {\n             None => None,\n             Some(ch) => {\n@@ -512,7 +517,7 @@ struct CharSplits<'a, Sep> {\n struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n-    count: usize,\n+    count: uint,\n     invert: bool,\n }\n \n@@ -636,15 +641,15 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n /// within a larger string using naive search\n #[derive(Clone)]\n struct NaiveSearcher {\n-    position: usize\n+    position: uint\n }\n \n impl NaiveSearcher {\n     fn new() -> NaiveSearcher {\n         NaiveSearcher { position: 0 }\n     }\n \n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n             if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n@@ -663,13 +668,13 @@ impl NaiveSearcher {\n #[derive(Clone)]\n struct TwoWaySearcher {\n     // constants\n-    crit_pos: usize,\n-    period: usize,\n+    crit_pos: uint,\n+    period: uint,\n     byteset: u64,\n \n     // variables\n-    position: usize,\n-    memory: usize\n+    position: uint,\n+    memory: uint\n }\n \n /*\n@@ -756,7 +761,7 @@ impl TwoWaySearcher {\n \n         // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n \n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n@@ -794,8 +799,7 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n-            -> Option<(usize, usize)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -805,7 +809,7 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if (self.byteset >>\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as usize)) & 1 == 0 {\n+                     as uint)) & 1 == 0 {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -852,7 +856,7 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -897,18 +901,24 @@ impl TwoWaySearcher {\n /// within a larger string using a dynamically chosen search algorithm\n #[derive(Clone)]\n enum Searcher {\n+    EmptyNeedle { pos: usize, done: bool },\n     Naive(NaiveSearcher),\n     TwoWay(TwoWaySearcher),\n     TwoWayLong(TwoWaySearcher)\n }\n \n impl Searcher {\n     fn new(haystack: &[u8], needle: &[u8]) -> Searcher {\n+        if needle.len() == 0 {\n+            Searcher::EmptyNeedle {\n+                pos: 0,\n+                done: false\n+            }\n         // FIXME: Tune this.\n         // FIXME(#16715): This unsigned integer addition will probably not\n         // overflow because that would mean that the memory almost solely\n         // consists of the needle. Needs #16715 to be formally fixed.\n-        if needle.len() + 20 > haystack.len() {\n+        } else if needle.len() + 20 > haystack.len() {\n             Naive(NaiveSearcher::new())\n         } else {\n             let searcher = TwoWaySearcher::new(needle);\n@@ -938,23 +948,37 @@ pub struct MatchIndices<'a> {\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n-    last_end: usize,\n+    last_end: uint,\n     finished: bool\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n-    type Item = (usize, usize);\n+    type Item = (uint, uint);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(usize, usize)> {\n+    fn next(&mut self) -> Option<(uint, uint)> {\n         match self.searcher {\n             Naive(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n             TwoWay(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n             TwoWayLong(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true),\n+            Searcher::EmptyNeedle { ref mut pos, ref mut done } => {\n+                if !*done {\n+                    let r = Some((*pos, *pos));\n+                    if *pos == self.haystack.len() {\n+                        *done = true;\n+                    } else {\n+                        use char::CharExt;\n+                        *pos += self.haystack.char_at(*pos).len_utf8();\n+                    }\n+                    r\n+                } else {\n+                    None\n+                }\n+            }\n         }\n     }\n }\n@@ -994,7 +1018,7 @@ Section: Comparing strings\n fn eq_slice_(a: &str, b: &str) -> bool {\n     // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n                b.as_ptr() as *const i8,\n@@ -1051,7 +1075,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n+            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1126,7 +1150,7 @@ pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n-    pub next: usize,\n+    pub next: uint,\n }\n \n /// Mask of the value bits of a continuation byte\n@@ -1211,10 +1235,10 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<usize>> for str {\n+    impl ops::Index<ops::Range<uint>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::Range<usize>) -> &str {\n+        fn index(&self, index: &ops::Range<uint>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if index.start <= index.end &&\n                self.is_char_boundary(index.start) &&\n@@ -1234,10 +1258,10 @@ mod traits {\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<usize>> for str {\n+    impl ops::Index<ops::RangeTo<uint>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.end) {\n                 unsafe { self.slice_unchecked(0, index.end) }\n@@ -1254,10 +1278,10 @@ mod traits {\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<usize>> for str {\n+    impl ops::Index<ops::RangeFrom<uint>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.start) {\n                 unsafe { self.slice_unchecked(index.start, self.len()) }\n@@ -1328,60 +1352,63 @@ pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n \n-    fn contains(&self, pat: &str) -> bool;\n-    fn contains_char<P: CharEq>(&self, pat: P) -> bool;\n+    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n+    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn chars<'a>(&'a self) -> Chars<'a>;\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n+    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n+    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n-    fn char_len(&self) -> usize;\n-    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    fn char_len(&self) -> uint;\n+    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n     fn ends_with(&self, pat: &str) -> bool;\n-    fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn is_char_boundary(&self, index: usize) -> bool;\n-    fn char_range_at(&self, start: usize) -> CharRange;\n-    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n-    fn char_at(&self, i: usize) -> char;\n-    fn char_at_reverse(&self, i: usize) -> char;\n+    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Matcher: DoubleEndedMatcher<'a>;\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Matcher: ReverseMatcher<'a>;\n+    fn is_char_boundary(&self, index: uint) -> bool;\n+    fn char_range_at(&self, start: uint) -> CharRange;\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n+    fn char_at(&self, i: uint) -> char;\n+    fn char_at_reverse(&self, i: uint) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<P: CharEq>(&self, pat: P) -> Option<usize>;\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize>;\n-    fn find_str(&self, pat: &str) -> Option<usize>;\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>;\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>\n+        where P::Matcher: ReverseMatcher<'a>;\n+    fn find_str(&self, pat: &str) -> Option<uint>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-    fn subslice_offset(&self, inner: &str) -> usize;\n+    fn subslice_offset(&self, inner: &str) -> uint;\n     fn as_ptr(&self) -> *const u8;\n-    fn len(&self) -> usize;\n+    fn len(&self) -> uint;\n     fn is_empty(&self) -> bool;\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n-fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n+fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n }\n \n impl StrExt for str {\n     #[inline]\n-    fn contains(&self, needle: &str) -> bool {\n-        self.find_str(needle).is_some()\n+    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.is_contained_in(self)\n     }\n \n     #[inline]\n-    fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        self.find(pat).is_some()\n+    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.is_contained_in(self)\n     }\n \n     #[inline]\n@@ -1411,7 +1438,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1428,7 +1455,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1438,7 +1465,6 @@ impl StrExt for str {\n \n     #[inline]\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n-        assert!(!sep.is_empty());\n         MatchIndices {\n             haystack: self,\n             needle: sep,\n@@ -1472,9 +1498,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_len(&self) -> usize { self.chars().count() }\n+    fn char_len(&self) -> uint { self.chars().count() }\n \n-    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n+    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1498,9 +1524,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as isize),\n+            data: self.as_ptr().offset(begin as int),\n             len: end - begin,\n         })\n     }\n@@ -1518,41 +1544,71 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn trim_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        let cur = match self.find(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(i) => unsafe { self.slice_unchecked(i, self.len()) }\n-        };\n-        match cur.rfind(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(i) => {\n-                let right = cur.char_range_at(i).next;\n-                unsafe { cur.slice_unchecked(0, right) }\n+    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+    where P::Matcher: DoubleEndedMatcher<'a> {\n+        let mut i = 0;\n+        let mut matcher = pat.into_matcher(self);\n+        let mut possible_end_match = None;\n+        while let Some((a, b)) = Matcher::next(&mut matcher) {\n+            if a == i {\n+                i = b;\n+            } else {\n+                possible_end_match = Some((a, b));\n+                break;\n+            }\n+        }\n+        let mut j = self.len();\n+        while let Some((a, b)) = ReverseMatcher::next_back(&mut matcher)\n+                .or_else(|| possible_end_match.take()) {\n+            if b == j {\n+                j = a;\n+            } else {\n+                break;\n             }\n         }\n+        unsafe {\n+            // Matcher is known to return valid indices\n+            self.slice_unchecked(i, j)\n+        }\n     }\n \n     #[inline]\n-    fn trim_left_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        match self.find(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { self.slice_unchecked(first, self.len()) }\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &str {\n+        let mut i = 0;\n+        let mut matcher = pat.into_matcher(self);\n+        while let Some((a, b)) = Matcher::next(&mut matcher) {\n+            if a == i {\n+                i = b;\n+            } else {\n+                break;\n+            }\n+        }\n+        unsafe {\n+            // Matcher is known to return valid indices\n+            self.slice_unchecked(i, self.len())\n         }\n     }\n \n     #[inline]\n-    fn trim_right_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        match self.rfind(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { self.slice_unchecked(0, next) }\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &str\n+    where P::Matcher: ReverseMatcher<'a> {\n+        let mut i = self.len();\n+        let mut matcher = pat.into_matcher(self);\n+        while let Some((a, b)) = ReverseMatcher::next_back(&mut matcher) {\n+            if b == i {\n+                i = a;\n+            } else {\n+                break;\n             }\n         }\n+        unsafe {\n+            // Matcher is known to return valid indices\n+            self.slice_unchecked(0, i)\n+        }\n     }\n \n     #[inline]\n-    fn is_char_boundary(&self, index: usize) -> bool {\n+    fn is_char_boundary(&self, index: uint) -> bool {\n         if index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n@@ -1561,13 +1617,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_range_at(&self, i: usize) -> CharRange {\n+    fn char_range_at(&self, i: uint) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n         CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n-    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n+    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n@@ -1576,14 +1632,14 @@ impl StrExt for str {\n         }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n+            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -1598,12 +1654,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_at(&self, i: usize) -> char {\n+    fn char_at(&self, i: uint) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n-    fn char_at_reverse(&self, i: usize) -> char {\n+    fn char_at_reverse(&self, i: uint) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n@@ -1612,29 +1668,16 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n-        if pat.only_ascii() {\n-            self.bytes().position(|b| pat.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices() {\n-                if pat.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint> {\n+        Matcher::next(&mut pat.into_matcher(self)).map(|(i, _)| i)\n     }\n \n-    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n-        if pat.only_ascii() {\n-            self.bytes().rposition(|b| pat.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices().rev() {\n-                if pat.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<uint>\n+    where P::Matcher: ReverseMatcher<'a> {\n+        ReverseMatcher::next_back(&mut pat.into_matcher(self)).map(|(i, _)| i)\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<usize> {\n+    fn find_str(&self, needle: &str) -> Option<uint> {\n         if needle.is_empty() {\n             Some(0)\n         } else {\n@@ -1655,10 +1698,10 @@ impl StrExt for str {\n         }\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> usize {\n-        let a_start = self.as_ptr() as usize;\n+    fn subslice_offset(&self, inner: &str) -> uint {\n+        let a_start = self.as_ptr() as uint;\n         let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as usize;\n+        let b_start = inner.as_ptr() as uint;\n         let b_end = b_start + inner.len();\n \n         assert!(a_start <= b_start);\n@@ -1672,7 +1715,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> usize { self.repr().len }\n+    fn len(&self) -> uint { self.repr().len }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1685,15 +1728,15 @@ impl StrExt for str {\n /// index of the next code point.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n+pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n     }\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n+    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n         let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n+        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n         assert!((w != 0));\n \n         val = utf8_first_byte!(val, w);\n@@ -1720,7 +1763,7 @@ impl<'a> Iterator for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1736,7 +1779,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "13b0d1df45ec78af179061326cbb3378cc62b3e8", "filename": "src/libcore/str/pattern.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=54f0bead8158eaf948c93d1cae93b60978937417", "patch": "@@ -0,0 +1,113 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(missing_docs)]\n+\n+use prelude::*;\n+use super::CharEq;\n+\n+// Pattern\n+\n+pub trait Pattern<'a>: Sized {\n+    type Matcher: Matcher<'a>;\n+    fn into_matcher(self, haystack: &'a str) -> Self::Matcher;\n+\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        Matcher::next(&mut self.into_matcher(haystack)).is_some()\n+    }\n+}\n+\n+// Matcher\n+\n+pub unsafe trait Matcher<'a> {\n+    fn haystack(&self) -> &'a str;\n+    fn next(&mut self) -> Option<(usize, usize)>;\n+}\n+\n+pub unsafe trait ReverseMatcher<'a>: Matcher<'a> {\n+    fn next_back(&mut self) -> Option<(usize, usize)>;\n+}\n+\n+pub trait DoubleEndedMatcher<'a>: ReverseMatcher<'a> {}\n+\n+// Impl for CharEq\n+\n+struct CharEqMatcher<'a, C>(C, &'a str, super::CharIndices<'a>);\n+\n+impl<'a, C: CharEq> Pattern<'a> for C {\n+    type Matcher = CharEqMatcher<'a, C>;\n+\n+    #[inline]\n+    fn into_matcher(self, haystack: &'a str) -> CharEqMatcher<'a, C> {\n+        CharEqMatcher(self, haystack, haystack.char_indices())\n+    }\n+}\n+\n+unsafe impl<'a, C: CharEq> Matcher<'a> for CharEqMatcher<'a, C> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.1\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        while let Some((i, c)) = self.2.next() {\n+            if self.0.matches(c) {\n+                return Some((i, i + c.len_utf8()));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+unsafe impl<'a, C: CharEq> ReverseMatcher<'a> for CharEqMatcher<'a, C> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<(usize, usize)> {\n+        while let Some((i, c)) = self.2.next_back() {\n+            if self.0.matches(c) {\n+                return Some((i, i + c.len_utf8()));\n+            }\n+        }\n+        None\n+    }\n+}\n+\n+impl<'a, C: CharEq> DoubleEndedMatcher<'a> for CharEqMatcher<'a, C> {}\n+\n+// Impl for &str\n+\n+struct StrMatcher<'a>(super::MatchIndices<'a>);\n+\n+impl<'a> Pattern<'a> for &'a str {\n+    type Matcher = StrMatcher<'a>;\n+\n+    #[inline]\n+    fn into_matcher(self, haystack: &'a str) -> StrMatcher<'a> {\n+        let mi = super::MatchIndices {\n+            haystack: haystack,\n+            needle: self,\n+            searcher: super::Searcher::new(haystack.as_bytes(), self.as_bytes())\n+        };\n+        StrMatcher(mi)\n+    }\n+}\n+\n+unsafe impl<'a> Matcher<'a> for StrMatcher<'a>  {\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.0.haystack\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        self.0.next()\n+    }\n+}"}, {"sha": "ddbec47eeff4939ca181d610d2a8bc9c7f5dc319", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54f0bead8158eaf948c93d1cae93b60978937417/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=54f0bead8158eaf948c93d1cae93b60978937417", "patch": "@@ -8,6 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[test]\n+fn test_empty_match_indices() {\n+    let data = \"a\u00e4\u4e2d!\";\n+    let vec: Vec<_> = data.match_indices(\"\").collect();\n+    assert_eq!(vec, vec![(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+}\n+\n #[test]\n fn test_bool_from_str() {\n     assert_eq!(\"true\".parse().ok(), Some(true));"}]}