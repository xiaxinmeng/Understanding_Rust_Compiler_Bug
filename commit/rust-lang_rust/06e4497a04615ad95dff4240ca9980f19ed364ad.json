{"sha": "06e4497a04615ad95dff4240ca9980f19ed364ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2ZTQ0OTdhMDQ2MTVhZDk1ZGZmNDI0MGNhOTk4MGYxOWVkMzY0YWQ=", "commit": {"author": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-10-25T15:32:28Z"}, "committer": {"name": "Tim Diekmann", "email": "tim.diekmann@3dvision.de", "date": "2020-10-25T15:32:28Z"}, "message": "Merge remote-tracking branch 'upstream/master' into box-alloc", "tree": {"sha": "123a17d04628e05bb2448d1d3e3f11e60f240304", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/123a17d04628e05bb2448d1d3e3f11e60f240304"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06e4497a04615ad95dff4240ca9980f19ed364ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06e4497a04615ad95dff4240ca9980f19ed364ad", "html_url": "https://github.com/rust-lang/rust/commit/06e4497a04615ad95dff4240ca9980f19ed364ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06e4497a04615ad95dff4240ca9980f19ed364ad/comments", "author": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TimDiekmann", "id": 21277928, "node_id": "MDQ6VXNlcjIxMjc3OTI4", "avatar_url": "https://avatars.githubusercontent.com/u/21277928?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TimDiekmann", "html_url": "https://github.com/TimDiekmann", "followers_url": "https://api.github.com/users/TimDiekmann/followers", "following_url": "https://api.github.com/users/TimDiekmann/following{/other_user}", "gists_url": "https://api.github.com/users/TimDiekmann/gists{/gist_id}", "starred_url": "https://api.github.com/users/TimDiekmann/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TimDiekmann/subscriptions", "organizations_url": "https://api.github.com/users/TimDiekmann/orgs", "repos_url": "https://api.github.com/users/TimDiekmann/repos", "events_url": "https://api.github.com/users/TimDiekmann/events{/privacy}", "received_events_url": "https://api.github.com/users/TimDiekmann/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "693a2bf18b7090202784f561de3dfca45c4f79be", "url": "https://api.github.com/repos/rust-lang/rust/commits/693a2bf18b7090202784f561de3dfca45c4f79be", "html_url": "https://github.com/rust-lang/rust/commit/693a2bf18b7090202784f561de3dfca45c4f79be"}, {"sha": "f392479de6b003e72f93cb8f9955b3cf4135c2cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/f392479de6b003e72f93cb8f9955b3cf4135c2cd", "html_url": "https://github.com/rust-lang/rust/commit/f392479de6b003e72f93cb8f9955b3cf4135c2cd"}], "stats": {"total": 25312, "additions": 13308, "deletions": 12004}, "files": [{"sha": "f476926832158d715f4e474f581655b8ff99f740", "filename": ".mailmap", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -29,7 +29,6 @@ Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n Barosl Lee <vcs@barosl.com> Barosl LEE <github@barosl.com>\n-Bastian Kauschke <bastian_kauschke@hotmail.de>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@bsago.me>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@users.noreply.github.com>\n@@ -161,6 +160,7 @@ Kyle J Strand <batmanaod@gmail.com> <kyle.j.strand@gmail.com>\n Kyle J Strand <batmanaod@gmail.com> <kyle.strand@pieinsurance.com>\n Kyle J Strand <batmanaod@gmail.com> <kyle.strand@rms.com>\n Lauren\u021biu Nicola <lnicola@dend.ro>\n+lcnr <bastian_kauschke@hotmail.de>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>"}, {"sha": "b600074c1977066cb50339fcccd7eb85cd08cb58", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -2,14 +2,14 @@\n \n Thank you for your interest in contributing to Rust!\n \n-To get started, read the [Getting Started] guide in the [rustc-dev-guide].\n+To get started, read the [Contributing to Rust] chapter of the [rustc-dev-guide].\n \n ## Bug reports\n \n Did a compiler error message tell you to come here? If you want to create an ICE report,\n refer to [this section][contributing-bug-reports] and [open an issue][issue template].\n \n-[Getting Started]: https://rustc-dev-guide.rust-lang.org/getting-started.html\n+[Contributing to Rust]: https://rustc-dev-guide.rust-lang.org/contributing.html#contributing-to-rust\n [rustc-dev-guide]: https://rustc-dev-guide.rust-lang.org/\n [contributing-bug-reports]: https://rustc-dev-guide.rust-lang.org/contributing.html#bug-reports\n [issue template]: https://github.com/rust-lang/rust/issues/new/choose"}, {"sha": "98e7e34faf76fdede7bfeec8dab67c1bba093ea5", "filename": "Cargo.lock", "status": "modified", "additions": 77, "deletions": 20, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -310,7 +310,7 @@ dependencies = [\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.7.1\",\n+ \"env_logger 0.8.1\",\n  \"filetime\",\n  \"flate2\",\n  \"fwdansi\",\n@@ -418,6 +418,17 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"cargo_metadata\"\n+version = \"0.12.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d5a5f7b42f606b7f23674f6f4d877628350682bc40687d3fae65679a58d55345\"\n+dependencies = [\n+ \"semver 0.11.0\",\n+ \"serde\",\n+ \"serde_json\",\n+]\n+\n [[package]]\n name = \"cargotest2\"\n version = \"0.1.0\"\n@@ -530,15 +541,14 @@ dependencies = [\n name = \"clippy\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata 0.11.1\",\n+ \"cargo_metadata 0.12.0\",\n  \"clippy-mini-macro-test\",\n  \"clippy_lints\",\n  \"compiletest_rs\",\n  \"derive-new\",\n- \"lazy_static\",\n  \"rustc-workspace-hack\",\n  \"rustc_tools_util 0.2.0\",\n- \"semver 0.10.0\",\n+ \"semver 0.11.0\",\n  \"serde\",\n  \"tempfile\",\n  \"tester\",\n@@ -552,14 +562,14 @@ version = \"0.2.0\"\n name = \"clippy_lints\"\n version = \"0.0.212\"\n dependencies = [\n- \"cargo_metadata 0.11.1\",\n+ \"cargo_metadata 0.12.0\",\n  \"if_chain\",\n  \"itertools 0.9.0\",\n  \"pulldown-cmark 0.8.0\",\n  \"quine-mc_cluskey\",\n  \"quote\",\n  \"regex-syntax\",\n- \"semver 0.10.0\",\n+ \"semver 0.11.0\",\n  \"serde\",\n  \"smallvec 1.4.2\",\n  \"syn\",\n@@ -626,9 +636,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.35\"\n+version = \"0.1.36\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e3fcd8aba10d17504c87ef12d4f62ef404c6a4703d16682a9eb5543e6cf24455\"\n+checksum = \"7cd0782e0a7da7598164153173e5a5d4d9b1da094473c98dce0ff91406112369\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\",\n@@ -1035,6 +1045,19 @@ dependencies = [\n  \"termcolor\",\n ]\n \n+[[package]]\n+name = \"env_logger\"\n+version = \"0.8.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"54532e3223c5af90a6a757c90b5c5521564b07e5e7a958681bcd2afad421cdcd\"\n+dependencies = [\n+ \"atty\",\n+ \"humantime 2.0.1\",\n+ \"log\",\n+ \"regex\",\n+ \"termcolor\",\n+]\n+\n [[package]]\n name = \"error_index_generator\"\n version = \"0.0.0\"\n@@ -1353,9 +1376,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.15\"\n+version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n+checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\",\n@@ -1744,6 +1767,10 @@ dependencies = [\n [[package]]\n name = \"linkchecker\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"once_cell\",\n+ \"regex\",\n+]\n \n [[package]]\n name = \"linked-hash-map\"\n@@ -1940,6 +1967,17 @@ dependencies = [\n  \"rustc-hash\",\n ]\n \n+[[package]]\n+name = \"measureme\"\n+version = \"9.0.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"22bf8d885d073610aee20e7fa205c4341ed32a761dbde96da5fd96301a8d3e82\"\n+dependencies = [\n+ \"parking_lot 0.11.0\",\n+ \"rustc-hash\",\n+ \"smallvec 1.4.2\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.3.3\"\n@@ -3072,7 +3110,7 @@ dependencies = [\n  \"indexmap\",\n  \"jobserver\",\n  \"libc\",\n- \"measureme\",\n+ \"measureme 0.7.1\",\n  \"parking_lot 0.11.0\",\n  \"rustc-ap-rustc_graphviz\",\n  \"rustc-ap-rustc_index\",\n@@ -3272,9 +3310,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-demangle\"\n-version = \"0.1.16\"\n+version = \"0.1.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c691c0e608126e00913e33f0ccf3727d5fc84573623b8d65b2df340b5201783\"\n+checksum = \"6e3bad0ee36814ca07d7968269dd4b7ec89ec2da10c4bb613928d3077083c232\"\n dependencies = [\n  \"compiler_builtins\",\n  \"rustc-std-workspace-core\",\n@@ -3474,7 +3512,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n- \"measureme\",\n+ \"measureme 9.0.0\",\n  \"rustc-demangle\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3540,7 +3578,7 @@ dependencies = [\n  \"indexmap\",\n  \"jobserver\",\n  \"libc\",\n- \"measureme\",\n+ \"measureme 9.0.0\",\n  \"parking_lot 0.11.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n@@ -3845,7 +3883,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"bitflags\",\n  \"chalk-ir\",\n- \"measureme\",\n+ \"measureme 9.0.0\",\n  \"polonius-engine\",\n  \"rustc-rayon-core\",\n  \"rustc_apfloat\",\n@@ -4356,7 +4394,7 @@ version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n dependencies = [\n- \"semver-parser\",\n+ \"semver-parser 0.7.0\",\n  \"serde\",\n ]\n \n@@ -4366,7 +4404,17 @@ version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"394cec28fa623e00903caf7ba4fa6fb9a0e260280bb8cdbbba029611108a0190\"\n dependencies = [\n- \"semver-parser\",\n+ \"semver-parser 0.7.0\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"semver\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f301af10236f6df4160f7c3f04eec6dbc70ace82d23326abad5edee88801c6b6\"\n+dependencies = [\n+ \"semver-parser 0.10.1\",\n  \"serde\",\n ]\n \n@@ -4376,6 +4424,15 @@ version = \"0.7.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n \n+[[package]]\n+name = \"semver-parser\"\n+version = \"0.10.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"42ef146c2ad5e5f4b037cd6ce2ebb775401729b19a82040c1beac9d36c7d1428\"\n+dependencies = [\n+ \"pest\",\n+]\n+\n [[package]]\n name = \"serde\"\n version = \"1.0.115\"\n@@ -4407,9 +4464,9 @@ dependencies = [\n \n [[package]]\n name = \"serde_json\"\n-version = \"1.0.57\"\n+version = \"1.0.59\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"164eacbdb13512ec2745fb09d51fd5b22b0d65ed294a1dcf7285a360c80a675c\"\n+checksum = \"dcac07dbffa1c65e7f816ab9eba78eb142c6d44410f4eeba1e26e4f5dfa56b95\"\n dependencies = [\n  \"itoa\",\n  \"ryu\","}, {"sha": "07c096046640091a533f0a78c3f3281f37bc394a", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -9,8 +9,7 @@ standard library, and documentation.\n \n **Note: this README is for _users_ rather than _contributors_.\n If you wish to _contribute_ to the compiler, you should read the\n-[Getting Started][gettingstarted] of the rustc-dev-guide instead of this\n-section.**\n+[Getting Started][gettingstarted] section of the rustc-dev-guide instead.**\n \n ## Quick Start\n "}, {"sha": "1a85a46ed74f0a8c607f8a09ae5bec561a01d6cc", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -217,16 +217,18 @@ impl<T> TypedArena<T> {\n             let mut chunks = self.chunks.borrow_mut();\n             let mut new_cap;\n             if let Some(last_chunk) = chunks.last_mut() {\n-                let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n-                last_chunk.entries = used_bytes / mem::size_of::<T>();\n+                // If a type is `!needs_drop`, we don't need to keep track of how many elements\n+                // the chunk stores - the field will be ignored anyway.\n+                if mem::needs_drop::<T>() {\n+                    let used_bytes = self.ptr.get() as usize - last_chunk.start() as usize;\n+                    last_chunk.entries = used_bytes / mem::size_of::<T>();\n+                }\n \n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len();\n-                if new_cap < HUGE_PAGE / elem_size {\n-                    new_cap = new_cap.checked_mul(2).unwrap();\n-                }\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / elem_size / 2);\n+                new_cap = new_cap * 2;\n             } else {\n                 new_cap = PAGE / elem_size;\n             }\n@@ -343,10 +345,8 @@ impl DroplessArena {\n                 // If the previous chunk's len is less than HUGE_PAGE\n                 // bytes, then this chunk will be least double the previous\n                 // chunk's size.\n-                new_cap = last_chunk.storage.len();\n-                if new_cap < HUGE_PAGE {\n-                    new_cap = new_cap.checked_mul(2).unwrap();\n-                }\n+                new_cap = last_chunk.storage.len().min(HUGE_PAGE / 2);\n+                new_cap = new_cap * 2;\n             } else {\n                 new_cap = PAGE;\n             }"}, {"sha": "7224b482ed780fc1348c5f031879bbe577038d96", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -24,7 +24,7 @@ pub use UnsafeSource::*;\n \n use crate::ptr::P;\n use crate::token::{self, CommentKind, DelimToken};\n-use crate::tokenstream::{DelimSpan, TokenStream, TokenTree};\n+use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n@@ -97,7 +97,7 @@ pub struct Path {\n     /// The segments in the path: the things separated by `::`.\n     /// Global paths begin with `kw::PathRoot`.\n     pub segments: Vec<PathSegment>,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n impl PartialEq<Symbol> for Path {\n@@ -535,7 +535,7 @@ pub struct Block {\n     /// Distinguishes between `unsafe { ... }` and `{ ... }`.\n     pub rules: BlockCheckMode,\n     pub span: Span,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n /// A match pattern.\n@@ -546,7 +546,7 @@ pub struct Pat {\n     pub id: NodeId,\n     pub kind: PatKind,\n     pub span: Span,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n impl Pat {\n@@ -892,7 +892,7 @@ pub struct Stmt {\n     pub id: NodeId,\n     pub kind: StmtKind,\n     pub span: Span,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n impl Stmt {\n@@ -1040,7 +1040,7 @@ pub struct Expr {\n     pub kind: ExprKind,\n     pub span: Span,\n     pub attrs: AttrVec,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1152,6 +1152,7 @@ impl Expr {\n         match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n+            ExprKind::ConstBlock(_) => ExprPrecedence::ConstBlock,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n             ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n             ExprKind::Tup(_) => ExprPrecedence::Tup,\n@@ -1207,6 +1208,8 @@ pub enum ExprKind {\n     Box(P<Expr>),\n     /// An array (`[a, b, c, d]`)\n     Array(Vec<P<Expr>>),\n+    /// Allow anonymous constants from an inline `const` block\n+    ConstBlock(AnonConst),\n     /// A function call\n     ///\n     /// The first field resolves to the function itself,\n@@ -1832,7 +1835,7 @@ pub struct Ty {\n     pub id: NodeId,\n     pub kind: TyKind,\n     pub span: Span,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n impl Clone for Ty {\n@@ -2405,7 +2408,7 @@ impl<D: Decoder> rustc_serialize::Decodable<D> for AttrId {\n pub struct AttrItem {\n     pub path: Path,\n     pub args: MacArgs,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n /// A list of attributes.\n@@ -2420,6 +2423,7 @@ pub struct Attribute {\n     /// or the construct this attribute is contained within (inner).\n     pub style: AttrStyle,\n     pub span: Span,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2479,7 +2483,7 @@ pub enum CrateSugar {\n pub struct Visibility {\n     pub kind: VisibilityKind,\n     pub span: Span,\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n #[derive(Clone, Encodable, Decodable, Debug)]\n@@ -2566,7 +2570,7 @@ pub struct Item<K = ItemKind> {\n     ///\n     /// Note that the tokens here do not include the outer attributes, but will\n     /// include inner attributes.\n-    pub tokens: Option<TokenStream>,\n+    pub tokens: Option<LazyTokenStream>,\n }\n \n impl Item {"}, {"sha": "70ad43ecad219a32d4ba6dae82805dee51006ed5", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -325,7 +325,7 @@ pub fn mk_attr(style: AttrStyle, path: Path, args: MacArgs, span: Span) -> Attri\n }\n \n pub fn mk_attr_from_item(style: AttrStyle, item: AttrItem, span: Span) -> Attribute {\n-    Attribute { kind: AttrKind::Normal(item), id: mk_attr_id(), style, span }\n+    Attribute { kind: AttrKind::Normal(item), id: mk_attr_id(), style, span, tokens: None }\n }\n \n /// Returns an inner attribute with the given value and span.\n@@ -344,7 +344,13 @@ pub fn mk_doc_comment(\n     data: Symbol,\n     span: Span,\n ) -> Attribute {\n-    Attribute { kind: AttrKind::DocComment(comment_kind, data), id: mk_attr_id(), style, span }\n+    Attribute {\n+        kind: AttrKind::DocComment(comment_kind, data),\n+        id: mk_attr_id(),\n+        style,\n+        span,\n+        tokens: None,\n+    }\n }\n \n pub fn list_contains_name(items: &[NestedMetaItem], name: Symbol) -> bool {\n@@ -623,7 +629,8 @@ impl HasAttrs for StmtKind {\n         match *self {\n             StmtKind::Local(ref local) => local.attrs(),\n             StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Empty | StmtKind::Item(..) => &[],\n+            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Empty => &[],\n             StmtKind::MacCall(ref mac) => mac.attrs.attrs(),\n         }\n     }\n@@ -632,7 +639,8 @@ impl HasAttrs for StmtKind {\n         match self {\n             StmtKind::Local(local) => local.visit_attrs(f),\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n-            StmtKind::Empty | StmtKind::Item(..) => {}\n+            StmtKind::Item(item) => item.visit_attrs(f),\n+            StmtKind::Empty => {}\n             StmtKind::MacCall(mac) => {\n                 mac.attrs.visit_attrs(f);\n             }"}, {"sha": "166d36ce4243305aa5f414c7843e9395e7ffc2d7", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -577,7 +577,7 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { kind, id: _, style: _, span } = attr;\n+    let Attribute { kind, id: _, style: _, span, tokens: _ } = attr;\n     match kind {\n         AttrKind::Normal(AttrItem { path, args, tokens: _ }) => {\n             vis.visit_path(path);\n@@ -1106,6 +1106,9 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     match kind {\n         ExprKind::Box(expr) => vis.visit_expr(expr),\n         ExprKind::Array(exprs) => visit_exprs(exprs, vis),\n+        ExprKind::ConstBlock(anon_const) => {\n+            vis.visit_anon_const(anon_const);\n+        }\n         ExprKind::Repeat(expr, count) => {\n             vis.visit_expr(expr);\n             vis.visit_anon_const(count);"}, {"sha": "d991027cb45733d51cba7fcc6a2e42abc231c98c", "filename": "compiler/rustc_ast/src/token.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftoken.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -153,6 +153,7 @@ pub fn ident_can_begin_expr(name: Symbol, span: Span, is_raw: bool) -> bool {\n             kw::Do,\n             kw::Box,\n             kw::Break,\n+            kw::Const,\n             kw::Continue,\n             kw::False,\n             kw::For,"}, {"sha": "cb419b6362ce7f40e3b5d201c71b12ff9c9f078a", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 78, "deletions": 6, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -16,8 +16,9 @@\n use crate::token::{self, DelimToken, Token, TokenKind};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::sync::{self, Lrc};\n use rustc_macros::HashStable_Generic;\n+use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n@@ -119,13 +120,84 @@ where\n     }\n }\n \n+// A cloneable callback which produces a `TokenStream`. Each clone\n+// of this should produce the same `TokenStream`\n+pub trait CreateTokenStream: sync::Send + sync::Sync + FnOnce() -> TokenStream {\n+    // Workaround for the fact that `Clone` is not object-safe\n+    fn clone_it(&self) -> Box<dyn CreateTokenStream>;\n+}\n+\n+impl<F: 'static + Clone + sync::Send + sync::Sync + FnOnce() -> TokenStream> CreateTokenStream\n+    for F\n+{\n+    fn clone_it(&self) -> Box<dyn CreateTokenStream> {\n+        Box::new(self.clone())\n+    }\n+}\n+\n+impl Clone for Box<dyn CreateTokenStream> {\n+    fn clone(&self) -> Self {\n+        let val: &(dyn CreateTokenStream) = &**self;\n+        val.clone_it()\n+    }\n+}\n+\n+/// A lazy version of `TokenStream`, which may defer creation\n+/// of an actual `TokenStream` until it is needed.\n+pub type LazyTokenStream = Lrc<LazyTokenStreamInner>;\n+\n+#[derive(Clone)]\n+pub enum LazyTokenStreamInner {\n+    Lazy(Box<dyn CreateTokenStream>),\n+    Ready(TokenStream),\n+}\n+\n+impl std::fmt::Debug for LazyTokenStreamInner {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            LazyTokenStreamInner::Lazy(..) => f.debug_struct(\"LazyTokenStream::Lazy\").finish(),\n+            LazyTokenStreamInner::Ready(..) => f.debug_struct(\"LazyTokenStream::Ready\").finish(),\n+        }\n+    }\n+}\n+\n+impl LazyTokenStreamInner {\n+    pub fn into_token_stream(&self) -> TokenStream {\n+        match self {\n+            // Note that we do not cache this. If this ever becomes a performance\n+            // problem, we should investigate wrapping `LazyTokenStreamInner`\n+            // in a lock\n+            LazyTokenStreamInner::Lazy(cb) => (cb.clone())(),\n+            LazyTokenStreamInner::Ready(stream) => stream.clone(),\n+        }\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for LazyTokenStreamInner {\n+    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n+        panic!(\"Attempted to encode LazyTokenStream\");\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for LazyTokenStreamInner {\n+    fn decode(_d: &mut D) -> Result<Self, D::Error> {\n+        panic!(\"Attempted to decode LazyTokenStream\");\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for LazyTokenStreamInner {\n+    fn hash_stable(&self, _hcx: &mut CTX, _hasher: &mut StableHasher) {\n+        panic!(\"Attempted to compute stable hash for LazyTokenStream\");\n+    }\n+}\n+\n /// A `TokenStream` is an abstract sequence of tokens, organized into `TokenTree`s.\n ///\n /// The goal is for procedural macros to work with `TokenStream`s and `TokenTree`s\n /// instead of a representation of the abstract syntax tree.\n /// Today's `TokenTree`s can still contain AST via `token::Interpolated` for back-compat.\n #[derive(Clone, Debug, Default, Encodable, Decodable)]\n-pub struct TokenStream(pub Lrc<Vec<TreeAndSpacing>>);\n+pub struct TokenStream(pub(crate) Lrc<Vec<TreeAndSpacing>>);\n \n pub type TreeAndSpacing = (TokenTree, Spacing);\n \n@@ -286,12 +358,12 @@ impl TokenStream {\n         t1.next().is_none() && t2.next().is_none()\n     }\n \n-    pub fn map_enumerated<F: FnMut(usize, TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n+    pub fn map_enumerated<F: FnMut(usize, &TokenTree) -> TokenTree>(self, mut f: F) -> TokenStream {\n         TokenStream(Lrc::new(\n             self.0\n                 .iter()\n                 .enumerate()\n-                .map(|(i, (tree, is_joint))| (f(i, tree.clone()), *is_joint))\n+                .map(|(i, (tree, is_joint))| (f(i, tree), *is_joint))\n                 .collect(),\n         ))\n     }\n@@ -394,8 +466,8 @@ impl Cursor {\n         self.index = index;\n     }\n \n-    pub fn look_ahead(&self, n: usize) -> Option<TokenTree> {\n-        self.stream.0[self.index..].get(n).map(|(tree, _)| tree.clone())\n+    pub fn look_ahead(&self, n: usize) -> Option<&TokenTree> {\n+        self.stream.0[self.index..].get(n).map(|(tree, _)| tree)\n     }\n }\n "}, {"sha": "21c2c925bc479de340b8081cde5cccdd477643b5", "filename": "compiler/rustc_ast/src/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Flev_distance.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -54,7 +54,7 @@ where\n     T: Iterator<Item = &'a Symbol>,\n {\n     let lookup = &lookup.as_str();\n-    let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n+    let max_dist = dist.unwrap_or_else(|| cmp::max(lookup.len(), 3) / 3);\n     let name_vec: Vec<&Symbol> = iter_names.collect();\n \n     let (case_insensitive_match, levenshtein_match) = name_vec"}, {"sha": "078dd4bd6e60232ed7a118db39e4601d04faa702", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -282,6 +282,7 @@ pub enum ExprPrecedence {\n     ForLoop,\n     Loop,\n     Match,\n+    ConstBlock,\n     Block,\n     TryBlock,\n     Struct,\n@@ -346,6 +347,7 @@ impl ExprPrecedence {\n             ExprPrecedence::ForLoop |\n             ExprPrecedence::Loop |\n             ExprPrecedence::Match |\n+            ExprPrecedence::ConstBlock |\n             ExprPrecedence::Block |\n             ExprPrecedence::TryBlock |\n             ExprPrecedence::Async |"}, {"sha": "507b49616ea0ff5461f237bb646c178f2b440dd2", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -200,11 +200,7 @@ pub trait Visitor<'ast>: Sized {\n         walk_generic_args(self, path_span, generic_args)\n     }\n     fn visit_generic_arg(&mut self, generic_arg: &'ast GenericArg) {\n-        match generic_arg {\n-            GenericArg::Lifetime(lt) => self.visit_lifetime(lt),\n-            GenericArg::Type(ty) => self.visit_ty(ty),\n-            GenericArg::Const(ct) => self.visit_anon_const(ct),\n-        }\n+        walk_generic_arg(self, generic_arg)\n     }\n     fn visit_assoc_ty_constraint(&mut self, constraint: &'ast AssocTyConstraint) {\n         walk_assoc_ty_constraint(self, constraint)\n@@ -486,6 +482,17 @@ where\n     }\n }\n \n+pub fn walk_generic_arg<'a, V>(visitor: &mut V, generic_arg: &'a GenericArg)\n+where\n+    V: Visitor<'a>,\n+{\n+    match generic_arg {\n+        GenericArg::Lifetime(lt) => visitor.visit_lifetime(lt),\n+        GenericArg::Type(ty) => visitor.visit_ty(ty),\n+        GenericArg::Const(ct) => visitor.visit_anon_const(ct),\n+    }\n+}\n+\n pub fn walk_assoc_ty_constraint<'a, V: Visitor<'a>>(\n     visitor: &mut V,\n     constraint: &'a AssocTyConstraint,\n@@ -717,6 +724,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Array(ref subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n         ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)"}, {"sha": "a6ac056b93b5e265c124be759705b9db2e2594ce", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -30,6 +30,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let kind = match e.kind {\n                 ExprKind::Box(ref inner) => hir::ExprKind::Box(self.lower_expr(inner)),\n                 ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+                ExprKind::ConstBlock(ref anon_const) => {\n+                    let anon_const = self.lower_anon_const(anon_const);\n+                    hir::ExprKind::ConstBlock(anon_const)\n+                }\n                 ExprKind::Repeat(ref expr, ref count) => {\n                     let expr = self.lower_expr(expr);\n                     let count = self.lower_anon_const(count);\n@@ -206,9 +210,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         ex.span = e.span;\n                     }\n                     // Merge attributes into the inner expression.\n-                    let mut attrs = e.attrs.clone();\n+                    let mut attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n                     attrs.extend::<Vec<_>>(ex.attrs.into());\n-                    ex.attrs = attrs;\n+                    ex.attrs = attrs.into();\n                     return ex;\n                 }\n \n@@ -1186,52 +1190,47 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                                          input| {\n                             match used_regs.entry(r) {\n                                 Entry::Occupied(o) => {\n-                                    if !skip {\n-                                        skip = true;\n-\n-                                        let idx2 = *o.get();\n-                                        let op2 = &operands[idx2];\n-                                        let op_sp2 = asm.operands[idx2].1;\n-                                        let reg2 = match op2.reg() {\n-                                            Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n-                                            _ => unreachable!(),\n-                                        };\n-\n-                                        let msg = format!(\n-                                            \"register `{}` conflicts with register `{}`\",\n-                                            reg.name(),\n-                                            reg2.name()\n-                                        );\n-                                        let mut err = sess.struct_span_err(op_sp, &msg);\n-                                        err.span_label(\n-                                            op_sp,\n-                                            &format!(\"register `{}`\", reg.name()),\n-                                        );\n-                                        err.span_label(\n-                                            op_sp2,\n-                                            &format!(\"register `{}`\", reg2.name()),\n-                                        );\n-\n-                                        match (op, op2) {\n-                                            (\n-                                                hir::InlineAsmOperand::In { .. },\n-                                                hir::InlineAsmOperand::Out { late, .. },\n-                                            )\n-                                            | (\n-                                                hir::InlineAsmOperand::Out { late, .. },\n-                                                hir::InlineAsmOperand::In { .. },\n-                                            ) => {\n-                                                assert!(!*late);\n-                                                let out_op_sp = if input { op_sp2 } else { op_sp };\n-                                                let msg = \"use `lateout` instead of \\\n-                                                     `out` to avoid conflict\";\n-                                                err.span_help(out_op_sp, msg);\n-                                            }\n-                                            _ => {}\n+                                    if skip {\n+                                        return;\n+                                    }\n+                                    skip = true;\n+\n+                                    let idx2 = *o.get();\n+                                    let op2 = &operands[idx2];\n+                                    let op_sp2 = asm.operands[idx2].1;\n+                                    let reg2 = match op2.reg() {\n+                                        Some(asm::InlineAsmRegOrRegClass::Reg(r)) => r,\n+                                        _ => unreachable!(),\n+                                    };\n+\n+                                    let msg = format!(\n+                                        \"register `{}` conflicts with register `{}`\",\n+                                        reg.name(),\n+                                        reg2.name()\n+                                    );\n+                                    let mut err = sess.struct_span_err(op_sp, &msg);\n+                                    err.span_label(op_sp, &format!(\"register `{}`\", reg.name()));\n+                                    err.span_label(op_sp2, &format!(\"register `{}`\", reg2.name()));\n+\n+                                    match (op, op2) {\n+                                        (\n+                                            hir::InlineAsmOperand::In { .. },\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                        )\n+                                        | (\n+                                            hir::InlineAsmOperand::Out { late, .. },\n+                                            hir::InlineAsmOperand::In { .. },\n+                                        ) => {\n+                                            assert!(!*late);\n+                                            let out_op_sp = if input { op_sp2 } else { op_sp };\n+                                            let msg = \"use `lateout` instead of \\\n+                                                    `out` to avoid conflict\";\n+                                            err.span_help(out_op_sp, msg);\n                                         }\n-\n-                                        err.emit();\n+                                        _ => {}\n                                     }\n+\n+                                    err.emit();\n                                 }\n                                 Entry::Vacant(v) => {\n                                     v.insert(idx);\n@@ -1472,13 +1471,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             hir::MatchSource::ForLoopDesugar,\n         ));\n \n+        let attrs: Vec<_> = e.attrs.iter().map(|a| self.lower_attr(a)).collect();\n+\n         // This is effectively `{ let _result = ...; _result }`.\n         // The construct was introduced in #21984 and is necessary to make sure that\n         // temporaries in the `head` expression are dropped and do not leak to the\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps_mut(desugared_span, match_expr, e.attrs.clone())\n+        self.expr_drop_temps_mut(desugared_span, match_expr, attrs.into())\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:"}, {"sha": "a3f046986c01418f18a1d1671fcf510a5ea5bdfa", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -538,6 +538,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n+                    TyKind::ImplTrait(def_node_id, _) => {\n+                        self.lctx.allocate_hir_id_counter(def_node_id);\n+                        self.with_hir_id_owner(Some(def_node_id), |this| {\n+                            visit::walk_ty(this, t);\n+                        });\n+                    }\n                     _ => visit::walk_ty(self, t),\n                 }\n             }\n@@ -972,7 +978,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             AttrKind::DocComment(comment_kind, data) => AttrKind::DocComment(comment_kind, data),\n         };\n \n-        Attribute { kind, id: attr.id, style: attr.style, span: attr.span }\n+        // Tokens aren't needed after macro expansion and parsing\n+        Attribute { kind, id: attr.id, style: attr.style, span: attr.span, tokens: None }\n     }\n \n     fn lower_mac_args(&mut self, args: &MacArgs) -> MacArgs {\n@@ -1346,10 +1353,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n-                        let hir_bounds = self.lower_param_bounds(\n-                            bounds,\n-                            ImplTraitContext::Universal(in_band_ty_params),\n-                        );\n+                        self.allocate_hir_id_counter(def_node_id);\n+\n+                        let hir_bounds = self.with_hir_id_owner(def_node_id, |this| {\n+                            this.lower_param_bounds(\n+                                bounds,\n+                                ImplTraitContext::Universal(in_band_ty_params),\n+                            )\n+                        });\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n@@ -1713,7 +1724,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 pat: self.lower_pat(&l.pat),\n                 init,\n                 span: l.span,\n-                attrs: l.attrs.clone(),\n+                attrs: l.attrs.iter().map(|a| self.lower_attr(a)).collect::<Vec<_>>().into(),\n                 source: hir::LocalSource::Normal,\n             },\n             ids,\n@@ -2200,7 +2211,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         .attrs\n                         .iter()\n                         .filter(|attr| self.sess.check_name(attr, sym::rustc_synthetic))\n-                        .map(|_| hir::SyntheticTyParamKind::ImplTrait)\n+                        .map(|_| hir::SyntheticTyParamKind::FromAttr)\n                         .next(),\n                 };\n "}, {"sha": "a1cbcde1f4291ca9acc5195668054a90853448af", "filename": "compiler/rustc_ast_lowering/src/pat.rs", "status": "modified", "additions": 79, "deletions": 71, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpat.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,82 +10,90 @@ use rustc_span::symbol::Ident;\n use rustc_span::{source_map::Spanned, Span};\n \n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n-    crate fn lower_pat(&mut self, p: &Pat) -> &'hir hir::Pat<'hir> {\n+    crate fn lower_pat(&mut self, mut pattern: &Pat) -> &'hir hir::Pat<'hir> {\n         ensure_sufficient_stack(|| {\n-            let node = match p.kind {\n-                PatKind::Wild => hir::PatKind::Wild,\n-                PatKind::Ident(ref binding_mode, ident, ref sub) => {\n-                    let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n-                    let node = self.lower_pat_ident(p, binding_mode, ident, lower_sub);\n-                    node\n-                }\n-                PatKind::Lit(ref e) => hir::PatKind::Lit(self.lower_expr(e)),\n-                PatKind::TupleStruct(ref path, ref pats) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n-                    hir::PatKind::TupleStruct(qpath, pats, ddpos)\n-                }\n-                PatKind::Or(ref pats) => hir::PatKind::Or(\n-                    self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n-                ),\n-                PatKind::Path(ref qself, ref path) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        qself,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n-                    hir::PatKind::Path(qpath)\n-                }\n-                PatKind::Struct(ref path, ref fields, etc) => {\n-                    let qpath = self.lower_qpath(\n-                        p.id,\n-                        &None,\n-                        path,\n-                        ParamMode::Optional,\n-                        ImplTraitContext::disallowed(),\n-                    );\n+            // loop here to avoid recursion\n+            let node = loop {\n+                match pattern.kind {\n+                    PatKind::Wild => break hir::PatKind::Wild,\n+                    PatKind::Ident(ref binding_mode, ident, ref sub) => {\n+                        let lower_sub = |this: &mut Self| sub.as_ref().map(|s| this.lower_pat(&*s));\n+                        break self.lower_pat_ident(pattern, binding_mode, ident, lower_sub);\n+                    }\n+                    PatKind::Lit(ref e) => break hir::PatKind::Lit(self.lower_expr(e)),\n+                    PatKind::TupleStruct(ref path, ref pats) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple struct\");\n+                        break hir::PatKind::TupleStruct(qpath, pats, ddpos);\n+                    }\n+                    PatKind::Or(ref pats) => {\n+                        break hir::PatKind::Or(\n+                            self.arena.alloc_from_iter(pats.iter().map(|x| self.lower_pat(x))),\n+                        );\n+                    }\n+                    PatKind::Path(ref qself, ref path) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            qself,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n+                        break hir::PatKind::Path(qpath);\n+                    }\n+                    PatKind::Struct(ref path, ref fields, etc) => {\n+                        let qpath = self.lower_qpath(\n+                            pattern.id,\n+                            &None,\n+                            path,\n+                            ParamMode::Optional,\n+                            ImplTraitContext::disallowed(),\n+                        );\n \n-                    let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n-                        hir_id: self.next_id(),\n-                        ident: f.ident,\n-                        pat: self.lower_pat(&f.pat),\n-                        is_shorthand: f.is_shorthand,\n-                        span: f.span,\n-                    }));\n-                    hir::PatKind::Struct(qpath, fs, etc)\n-                }\n-                PatKind::Tuple(ref pats) => {\n-                    let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n-                    hir::PatKind::Tuple(pats, ddpos)\n-                }\n-                PatKind::Box(ref inner) => hir::PatKind::Box(self.lower_pat(inner)),\n-                PatKind::Ref(ref inner, mutbl) => hir::PatKind::Ref(self.lower_pat(inner), mutbl),\n-                PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n-                    hir::PatKind::Range(\n-                        e1.as_deref().map(|e| self.lower_expr(e)),\n-                        e2.as_deref().map(|e| self.lower_expr(e)),\n-                        self.lower_range_end(end, e2.is_some()),\n-                    )\n-                }\n-                PatKind::Slice(ref pats) => self.lower_pat_slice(pats),\n-                PatKind::Rest => {\n-                    // If we reach here the `..` pattern is not semantically allowed.\n-                    self.ban_illegal_rest_pat(p.span)\n+                        let fs = self.arena.alloc_from_iter(fields.iter().map(|f| hir::FieldPat {\n+                            hir_id: self.next_id(),\n+                            ident: f.ident,\n+                            pat: self.lower_pat(&f.pat),\n+                            is_shorthand: f.is_shorthand,\n+                            span: f.span,\n+                        }));\n+                        break hir::PatKind::Struct(qpath, fs, etc);\n+                    }\n+                    PatKind::Tuple(ref pats) => {\n+                        let (pats, ddpos) = self.lower_pat_tuple(pats, \"tuple\");\n+                        break hir::PatKind::Tuple(pats, ddpos);\n+                    }\n+                    PatKind::Box(ref inner) => {\n+                        break hir::PatKind::Box(self.lower_pat(inner));\n+                    }\n+                    PatKind::Ref(ref inner, mutbl) => {\n+                        break hir::PatKind::Ref(self.lower_pat(inner), mutbl);\n+                    }\n+                    PatKind::Range(ref e1, ref e2, Spanned { node: ref end, .. }) => {\n+                        break hir::PatKind::Range(\n+                            e1.as_deref().map(|e| self.lower_expr(e)),\n+                            e2.as_deref().map(|e| self.lower_expr(e)),\n+                            self.lower_range_end(end, e2.is_some()),\n+                        );\n+                    }\n+                    PatKind::Slice(ref pats) => break self.lower_pat_slice(pats),\n+                    PatKind::Rest => {\n+                        // If we reach here the `..` pattern is not semantically allowed.\n+                        break self.ban_illegal_rest_pat(pattern.span);\n+                    }\n+                    // return inner to be processed in next loop\n+                    PatKind::Paren(ref inner) => pattern = inner,\n+                    PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", pattern.span),\n                 }\n-                // FIXME: consider not using recursion to lower this.\n-                PatKind::Paren(ref inner) => return self.lower_pat(inner),\n-                PatKind::MacCall(_) => panic!(\"{:?} shouldn't exist here\", p.span),\n             };\n \n-            self.pat_with_node_id_of(p, node)\n+            self.pat_with_node_id_of(pattern, node)\n         })\n     }\n "}, {"sha": "b1c8e0ee727303106296980b918ab8131e42f815", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -287,7 +287,7 @@ impl<'a> AstValidator<'a> {\n     // ```\n     fn check_expr_within_pat(&self, expr: &Expr, allow_paths: bool) {\n         match expr.kind {\n-            ExprKind::Lit(..) | ExprKind::Err => {}\n+            ExprKind::Lit(..) | ExprKind::ConstBlock(..) | ExprKind::Err => {}\n             ExprKind::Path(..) if allow_paths => {}\n             ExprKind::Unary(UnOp::Neg, ref inner) if matches!(inner.kind, ExprKind::Lit(_)) => {}\n             _ => self.err_handler().span_err("}, {"sha": "f20084497671f3941da94154c440aed824daa665", "filename": "compiler/rustc_ast_passes/src/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Ffeature_gate.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -629,6 +629,7 @@ pub fn check_crate(krate: &ast::Crate, sess: &Session) {\n     gate_all!(const_trait_bound_opt_out, \"`?const` on trait bounds is experimental\");\n     gate_all!(const_trait_impl, \"const trait impls are experimental\");\n     gate_all!(half_open_range_patterns, \"half-open range patterns are unstable\");\n+    gate_all!(inline_const, \"inline-const is experimental\");\n \n     // All uses of `gate_all!` below this point were added in #65742,\n     // and subsequently disabled (with the non-early gating readded)."}, {"sha": "56e769ba6b71014c5c8f21241ba8dc35d860e074", "filename": "compiler/rustc_ast_pretty/src/pp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpp.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -390,7 +390,7 @@ impl Printer {\n         self.scan_stack.pop_front().unwrap()\n     }\n \n-    fn scan_top(&mut self) -> usize {\n+    fn scan_top(&self) -> usize {\n         *self.scan_stack.front().unwrap()\n     }\n \n@@ -484,7 +484,7 @@ impl Printer {\n         self.pending_indentation += amount;\n     }\n \n-    fn get_top(&mut self) -> PrintStackElem {\n+    fn get_top(&self) -> PrintStackElem {\n         *self.print_stack.last().unwrap_or({\n             &PrintStackElem { offset: 0, pbreak: PrintStackBreak::Broken(Breaks::Inconsistent) }\n         })"}, {"sha": "029a6cb664dc359fae56d47385bfbd4b81e89e1b", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -63,7 +63,7 @@ impl<'a> Comments<'a> {\n     }\n \n     pub fn trailing_comment(\n-        &mut self,\n+        &self,\n         span: rustc_span::Span,\n         next_pos: Option<BytePos>,\n     ) -> Option<Comment> {\n@@ -1714,6 +1714,14 @@ impl<'a> State<'a> {\n         self.end();\n     }\n \n+    fn print_expr_anon_const(&mut self, expr: &ast::AnonConst, attrs: &[ast::Attribute]) {\n+        self.ibox(INDENT_UNIT);\n+        self.s.word(\"const\");\n+        self.print_inner_attributes_inline(attrs);\n+        self.print_expr(&expr.value);\n+        self.end();\n+    }\n+\n     fn print_expr_repeat(\n         &mut self,\n         element: &ast::Expr,\n@@ -1890,6 +1898,9 @@ impl<'a> State<'a> {\n             ast::ExprKind::Array(ref exprs) => {\n                 self.print_expr_vec(&exprs[..], attrs);\n             }\n+            ast::ExprKind::ConstBlock(ref anon_const) => {\n+                self.print_expr_anon_const(anon_const, attrs);\n+            }\n             ast::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(element, count, attrs);\n             }"}, {"sha": "218a9b229e0df0fb2605606c0d609b9edd4d6e60", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1013,13 +1013,28 @@ pub fn allow_internal_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n ) -> Option<impl Iterator<Item = Symbol> + 'a> {\n-    let attrs = sess.filter_by_name(attrs, sym::allow_internal_unstable);\n+    allow_unstable(sess, attrs, sym::allow_internal_unstable)\n+}\n+\n+pub fn rustc_allow_const_fn_unstable<'a>(\n+    sess: &'a Session,\n+    attrs: &'a [Attribute],\n+) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+    allow_unstable(sess, attrs, sym::rustc_allow_const_fn_unstable)\n+}\n+\n+fn allow_unstable<'a>(\n+    sess: &'a Session,\n+    attrs: &'a [Attribute],\n+    symbol: Symbol,\n+) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+    let attrs = sess.filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n             attr.meta_item_list().or_else(|| {\n                 sess.diagnostic().span_err(\n                     attr.span,\n-                    \"`allow_internal_unstable` expects a list of feature names\",\n+                    &format!(\"`{}` expects a list of feature names\", symbol.to_ident_string()),\n                 );\n                 None\n             })\n@@ -1029,8 +1044,10 @@ pub fn allow_internal_unstable<'a>(\n     Some(list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n-            sess.diagnostic()\n-                .span_err(it.span(), \"`allow_internal_unstable` expects feature names\");\n+            sess.diagnostic().span_err(\n+                it.span(),\n+                &format!(\"`{}` expects feature names\", symbol.to_ident_string()),\n+            );\n         }\n         name\n     }))"}, {"sha": "747e48ece704cbb11b06ec19635968fb3625f312", "filename": "compiler/rustc_builtin_macros/src/cmdline_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcmdline_attrs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -15,7 +15,7 @@ pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -\n         );\n \n         let start_span = parser.token.span;\n-        let AttrItem { path, args, tokens: _ } = match parser.parse_attr_item() {\n+        let AttrItem { path, args, tokens: _ } = match parser.parse_attr_item(false) {\n             Ok(ai) => ai,\n             Err(mut err) => {\n                 err.emit();"}, {"sha": "f9373640dce5ea3c1f5f560a7f0cda0f7a998a07", "filename": "compiler/rustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2FCargo.toml?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -11,11 +11,11 @@ doctest = false\n [dependencies]\n bitflags = \"1.0\"\n libc = \"0.2\"\n-measureme = \"0.7.1\"\n+measureme = \"9.0.0\"\n snap = \"1\"\n tracing = \"0.1\"\n rustc_middle = { path = \"../rustc_middle\" }\n-rustc-demangle = \"0.1\"\n+rustc-demangle = \"0.1.18\"\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_codegen_ssa = { path = \"../rustc_codegen_ssa\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "491191d058cf0bd2ba871dc27256edd8042ccd26", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -139,7 +139,7 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         unsafe { llvm::LLVMGetInsertBlock(self.llbuilder) }\n     }\n \n-    fn set_span(&self, _span: Span) {}\n+    fn set_span(&mut self, _span: Span) {}\n \n     fn position_at_end(&mut self, llbb: &'ll BasicBlock) {\n         unsafe {"}, {"sha": "56ff580b43b5989ba293e3ab31381dd17d22a194", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -324,8 +324,8 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n-        self.coverage_cx.as_ref().unwrap()\n+    pub fn coverage_context(&'a self) -> Option<&'a coverageinfo::CrateCoverageContext<'tcx>> {\n+        self.coverage_cx.as_ref()\n     }\n }\n "}, {"sha": "c1163a871cf1f311047ad6ad61daf274592cf0c9", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -26,7 +26,10 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n-    let function_coverage_map = cx.coverage_context().take_function_coverage_map();\n+    let function_coverage_map = match cx.coverage_context() {\n+        Some(ctx) => ctx.take_function_coverage_map(),\n+        None => return,\n+    };\n     if function_coverage_map.is_empty() {\n         // This module has no functions with coverage instrumentation\n         return;"}, {"sha": "7fdbe1a55128ae2f438b5afc5a1c03baa12ab559", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 47, "deletions": 32, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -64,17 +64,22 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n-             at {:?}\",\n-            instance, function_source_hash, id, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter(function_source_hash, id, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter to coverage_regions: instance={:?}, function_source_hash={}, id={:?}, \\\n+                at {:?}\",\n+                instance, function_source_hash, id, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter(function_source_hash, id, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n     fn add_counter_expression_region(\n@@ -85,29 +90,39 @@ impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    ) {\n-        debug!(\n-            \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n-             at {:?}\",\n-            instance, id, lhs, op, rhs, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_counter_expression(id, lhs, op, rhs, region);\n+    ) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding counter expression to coverage_regions: instance={:?}, id={:?}, {:?} {:?} {:?}, \\\n+                at {:?}\",\n+                instance, id, lhs, op, rhs, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_counter_expression(id, lhs, op, rhs, region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) {\n-        debug!(\n-            \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n-            instance, region,\n-        );\n-        let mut coverage_regions = self.coverage_context().function_coverage_map.borrow_mut();\n-        coverage_regions\n-            .entry(instance)\n-            .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n-            .add_unreachable_region(region);\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool {\n+        if let Some(coverage_context) = self.coverage_context() {\n+            debug!(\n+                \"adding unreachable code to coverage_regions: instance={:?}, at {:?}\",\n+                instance, region,\n+            );\n+            let mut coverage_regions = coverage_context.function_coverage_map.borrow_mut();\n+            coverage_regions\n+                .entry(instance)\n+                .or_insert_with(|| FunctionCoverage::new(self.tcx, instance))\n+                .add_unreachable_region(region);\n+            true\n+        } else {\n+            false\n+        }\n     }\n }\n "}, {"sha": "e9900e8bc108ac9f26b72653b1d5541476e2d6ba", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -334,8 +334,8 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n         self.call(expect, &[cond, self.const_bool(expected)], None)\n     }\n \n-    fn sideeffect(&mut self) {\n-        if self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n+    fn sideeffect(&mut self, unconditional: bool) {\n+        if unconditional || self.tcx.sess.opts.debugging_opts.insert_sideeffect {\n             let fnname = self.get_intrinsic(&(\"llvm.sideeffect\"));\n             self.call(fnname, &[], None);\n         }\n@@ -390,7 +390,7 @@ fn codegen_msvc_try(\n ) {\n     let llfn = get_rust_try_fn(bx, &mut |mut bx| {\n         bx.set_personality_fn(bx.eh_personality());\n-        bx.sideeffect();\n+        bx.sideeffect(false);\n \n         let mut normal = bx.build_sibling_block(\"normal\");\n         let mut catchswitch = bx.build_sibling_block(\"catchswitch\");\n@@ -553,7 +553,7 @@ fn codegen_gnu_try(\n         //      call %catch_func(%data, %ptr)\n         //      ret 1\n \n-        bx.sideeffect();\n+        bx.sideeffect(false);\n \n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n@@ -615,7 +615,7 @@ fn codegen_emcc_try(\n         //      call %catch_func(%data, %catch_data)\n         //      ret 1\n \n-        bx.sideeffect();\n+        bx.sideeffect(false);\n \n         let mut then = bx.build_sibling_block(\"then\");\n         let mut catch = bx.build_sibling_block(\"catch\");\n@@ -673,17 +673,9 @@ fn codegen_emcc_try(\n fn gen_fn<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     name: &str,\n-    inputs: Vec<Ty<'tcx>>,\n-    output: Ty<'tcx>,\n+    rust_fn_sig: ty::PolyFnSig<'tcx>,\n     codegen: &mut dyn FnMut(Builder<'_, 'll, 'tcx>),\n ) -> &'ll Value {\n-    let rust_fn_sig = ty::Binder::bind(cx.tcx.mk_fn_sig(\n-        inputs.into_iter(),\n-        output,\n-        false,\n-        hir::Unsafety::Unsafe,\n-        Abi::Rust,\n-    ));\n     let fn_abi = FnAbi::of_fn_ptr(cx, rust_fn_sig, &[]);\n     let llfn = cx.declare_fn(name, &fn_abi);\n     cx.set_frame_pointer_elimination(llfn);\n@@ -710,22 +702,31 @@ fn get_rust_try_fn<'ll, 'tcx>(\n     // Define the type up front for the signature of the rust_try function.\n     let tcx = cx.tcx;\n     let i8p = tcx.mk_mut_ptr(tcx.types.i8);\n-    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8) -> ()`\n+    let try_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         iter::once(i8p),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n-    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+    // `unsafe fn(*mut i8, *mut i8) -> ()`\n+    let catch_fn_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n         [i8p, i8p].iter().cloned(),\n         tcx.mk_unit(),\n         false,\n         hir::Unsafety::Unsafe,\n         Abi::Rust,\n     )));\n-    let output = tcx.types.i32;\n-    let rust_try = gen_fn(cx, \"__rust_try\", vec![try_fn_ty, i8p, catch_fn_ty], output, codegen);\n+    // `unsafe fn(unsafe fn(*mut i8) -> (), *mut i8, unsafe fn(*mut i8, *mut i8) -> ()) -> i32`\n+    let rust_fn_sig = ty::Binder::dummy(cx.tcx.mk_fn_sig(\n+        vec![try_fn_ty, i8p, catch_fn_ty].into_iter(),\n+        tcx.types.i32,\n+        false,\n+        hir::Unsafety::Unsafe,\n+        Abi::Rust,\n+    ));\n+    let rust_try = gen_fn(cx, \"__rust_try\", rust_fn_sig, codegen);\n     cx.rust_try_fn.set(Some(rust_try));\n     rust_try\n }"}, {"sha": "bec0a84cac0a1e2824dc4783b9f6fecd013f2902", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n                 target <= self.bb\n                     && target.start_location().is_predecessor_of(self.bb.start_location(), mir)\n             }) {\n-                bx.sideeffect();\n+                bx.sideeffect(false);\n             }\n         }\n     }\n@@ -964,7 +964,23 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                if bb == target {\n+                    // This is an unconditional branch back to this same basic\n+                    // block. That means we have something like a `loop {}`\n+                    // statement. Currently LLVM miscompiles this because it\n+                    // assumes forward progress. We want to prevent this in all\n+                    // cases, but that has a fairly high cost to compile times\n+                    // currently. Instead, try to handle this specific case\n+                    // which comes up commonly in practice (e.g., in embedded\n+                    // code).\n+                    //\n+                    // The `true` here means we insert side effects regardless\n+                    // of -Zinsert-sideeffect being passed on unconditional\n+                    // branching to the same basic block.\n+                    bx.sideeffect(true);\n+                } else {\n+                    helper.maybe_sideeffect(self.mir, &mut bx, &[target]);\n+                }\n                 helper.funclet_br(self, &mut bx, target);\n             }\n "}, {"sha": "4811adea9ec060851466bddf3a9256c9d2958f42", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,19 +10,19 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let Coverage { kind, code_region } = coverage;\n         match kind {\n             CoverageKind::Counter { function_source_hash, id } => {\n-                bx.add_counter_region(self.instance, function_source_hash, id, code_region);\n+                if bx.add_counter_region(self.instance, function_source_hash, id, code_region) {\n+                    let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n \n-                let coverageinfo = bx.tcx().coverageinfo(self.instance.def_id());\n-\n-                let fn_name = bx.create_pgo_func_name_var(self.instance);\n-                let hash = bx.const_u64(function_source_hash);\n-                let num_counters = bx.const_u32(coverageinfo.num_counters);\n-                let id = bx.const_u32(u32::from(id));\n-                debug!(\n-                    \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    fn_name, hash, num_counters, id,\n-                );\n-                bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                    let fn_name = bx.create_pgo_func_name_var(self.instance);\n+                    let hash = bx.const_u64(function_source_hash);\n+                    let num_counters = bx.const_u32(coverageinfo.num_counters);\n+                    let id = bx.const_u32(u32::from(id));\n+                    debug!(\n+                        \"codegen intrinsic instrprof.increment(fn_name={:?}, hash={:?}, num_counters={:?}, index={:?})\",\n+                        fn_name, hash, num_counters, id,\n+                    );\n+                    bx.instrprof_increment(fn_name, hash, num_counters, id);\n+                }\n             }\n             CoverageKind::Expression { id, lhs, op, rhs } => {\n                 bx.add_counter_expression_region(self.instance, id, lhs, op, rhs, code_region);"}, {"sha": "bff263567bf6b1d8212a434dcffcd87b43097493", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -153,7 +153,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         bx.set_personality_fn(cx.eh_personality());\n     }\n \n-    bx.sideeffect();\n+    bx.sideeffect(false);\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n     // Allocate a `Block` for every basic block, except"}, {"sha": "d5bd2780388e63cd2160f28269fe68b86ad63147", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -45,7 +45,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn build_sibling_block(&self, name: &str) -> Self;\n     fn cx(&self) -> &Self::CodegenCx;\n     fn llbb(&self) -> Self::BasicBlock;\n-    fn set_span(&self, span: Span);\n+    fn set_span(&mut self, span: Span);\n \n     fn position_at_end(&mut self, llbb: Self::BasicBlock);\n     fn ret_void(&mut self);"}, {"sha": "3b1654f3ad4fc94681bc0eff9f5821538afc2d47", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -9,14 +9,18 @@ pub trait CoverageInfoMethods: BackendTypes {\n pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n     fn create_pgo_func_name_var(&self, instance: Instance<'tcx>) -> Self::Value;\n \n+    /// Returns true if the counter was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n     fn add_counter_region(\n         &mut self,\n         instance: Instance<'tcx>,\n         function_source_hash: u64,\n         id: CounterValueReference,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n+    /// Returns true if the expression was added to the coverage map; false if\n+    /// `-Z instrument-coverage` is not enabled (a coverage map is not being generated).\n     fn add_counter_expression_region(\n         &mut self,\n         instance: Instance<'tcx>,\n@@ -25,7 +29,9 @@ pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n         op: Op,\n         rhs: ExpressionOperandId,\n         region: CodeRegion,\n-    );\n+    ) -> bool;\n \n-    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion);\n+    /// Returns true if the region was added to the coverage map; false if `-Z instrument-coverage`\n+    /// is not enabled (a coverage map is not being generated).\n+    fn add_unreachable_region(&mut self, instance: Instance<'tcx>, region: CodeRegion) -> bool;\n }"}, {"sha": "ac3c99f9c908db253b3dcd71bc462321848c93fb", "filename": "compiler/rustc_codegen_ssa/src/traits/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fintrinsic.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -20,7 +20,9 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;\n-    fn sideeffect(&mut self);\n+    /// Normally, sideeffect is only emitted if -Zinsert-sideeffect is passed;\n+    /// in some cases though we want to emit it regardless.\n+    fn sideeffect(&mut self, unconditional: bool);\n     /// Trait method used to inject `va_start` on the \"spoofed\" `VaListImpl` in\n     /// Rust defined C-variadic functions.\n     fn va_start(&mut self, val: Self::Value) -> Self::Value;"}, {"sha": "23e689fcae7963f0c00c21ef362be7003d92243b", "filename": "compiler/rustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2FCargo.toml?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -25,7 +25,7 @@ rustc-hash = \"1.1.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_index = { path = \"../rustc_index\", package = \"rustc_index\" }\n bitflags = \"1.2.1\"\n-measureme = \"0.7.1\"\n+measureme = \"9.0.0\"\n libc = \"0.2\"\n stacker = \"0.1.12\"\n tempfile = \"3.0.5\""}, {"sha": "5f42d46e28575453abc62e2694d3549befbf3679", "filename": "compiler/rustc_data_structures/src/graph/iterate/mod.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fiterate%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,7 @@\n use super::{DirectedGraph, WithNumNodes, WithStartNode, WithSuccessors};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n+use std::ops::ControlFlow;\n \n #[cfg(test)]\n mod tests;\n@@ -86,10 +87,6 @@ where\n     }\n }\n \n-/// Allows searches to terminate early with a value.\n-// FIXME (#75744): remove the alias once the generics are in a better order and `C=()`.\n-pub type ControlFlow<T> = std::ops::ControlFlow<(), T>;\n-\n /// The status of a node in the depth-first search.\n ///\n /// See the documentation of `TriColorDepthFirstSearch` to see how a node's status is updated"}, {"sha": "7669b78834c3f90e9713accb7e04aa0eef4cdb94", "filename": "compiler/rustc_data_structures/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -28,6 +28,7 @@\n #![feature(const_panic)]\n #![feature(min_const_generics)]\n #![feature(once_cell)]\n+#![feature(maybe_uninit_uninit_array)]\n #![allow(rustc::default_hash_types)]\n \n #[macro_use]"}, {"sha": "a5b2df1da5d6d8c6d83fab062cdaecbb7506caa1", "filename": "compiler/rustc_data_structures/src/obligation_forest/mod.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -149,8 +149,8 @@ pub struct ObligationForest<O: ForestObligation> {\n     /// comments in `process_obligation` for details.\n     active_cache: FxHashMap<O::CacheKey, usize>,\n \n-    /// A vector reused in compress(), to avoid allocating new vectors.\n-    node_rewrites: Vec<usize>,\n+    /// A vector reused in compress() and find_cycles_from_node(), to avoid allocating new vectors.\n+    reused_node_vec: Vec<usize>,\n \n     obligation_tree_id_generator: ObligationTreeIdGenerator,\n \n@@ -251,12 +251,22 @@ enum NodeState {\n     Error,\n }\n \n+/// This trait allows us to have two different Outcome types:\n+///  - the normal one that does as little as possible\n+///  - one for tests that does some additional work and checking\n+pub trait OutcomeTrait {\n+    type Error;\n+    type Obligation;\n+\n+    fn new() -> Self;\n+    fn mark_not_stalled(&mut self);\n+    fn is_stalled(&self) -> bool;\n+    fn record_completed(&mut self, outcome: &Self::Obligation);\n+    fn record_error(&mut self, error: Self::Error);\n+}\n+\n #[derive(Debug)]\n pub struct Outcome<O, E> {\n-    /// Obligations that were completely evaluated, including all\n-    /// (transitive) subobligations. Only computed if requested.\n-    pub completed: Option<Vec<O>>,\n-\n     /// Backtrace of obligations that were found to be in error.\n     pub errors: Vec<Error<O, E>>,\n \n@@ -269,12 +279,29 @@ pub struct Outcome<O, E> {\n     pub stalled: bool,\n }\n \n-/// Should `process_obligations` compute the `Outcome::completed` field of its\n-/// result?\n-#[derive(PartialEq)]\n-pub enum DoCompleted {\n-    No,\n-    Yes,\n+impl<O, E> OutcomeTrait for Outcome<O, E> {\n+    type Error = Error<O, E>;\n+    type Obligation = O;\n+\n+    fn new() -> Self {\n+        Self { stalled: true, errors: vec![] }\n+    }\n+\n+    fn mark_not_stalled(&mut self) {\n+        self.stalled = false;\n+    }\n+\n+    fn is_stalled(&self) -> bool {\n+        self.stalled\n+    }\n+\n+    fn record_completed(&mut self, _outcome: &Self::Obligation) {\n+        // do nothing\n+    }\n+\n+    fn record_error(&mut self, error: Self::Error) {\n+        self.errors.push(error)\n+    }\n }\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -289,7 +316,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             nodes: vec![],\n             done_cache: Default::default(),\n             active_cache: Default::default(),\n-            node_rewrites: vec![],\n+            reused_node_vec: vec![],\n             obligation_tree_id_generator: (0..).map(ObligationTreeId),\n             error_cache: Default::default(),\n         }\n@@ -363,8 +390,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n             .map(|(index, _node)| Error { error: error.clone(), backtrace: self.error_at(index) })\n             .collect();\n \n-        let successful_obligations = self.compress(DoCompleted::Yes);\n-        assert!(successful_obligations.unwrap().is_empty());\n+        self.compress(|_| assert!(false));\n         errors\n     }\n \n@@ -392,16 +418,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This _cannot_ be unrolled (presently, at least).\n-    pub fn process_obligations<P>(\n-        &mut self,\n-        processor: &mut P,\n-        do_completed: DoCompleted,\n-    ) -> Outcome<O, P::Error>\n+    pub fn process_obligations<P, OUT>(&mut self, processor: &mut P) -> OUT\n     where\n         P: ObligationProcessor<Obligation = O>,\n+        OUT: OutcomeTrait<Obligation = O, Error = Error<O, P::Error>>,\n     {\n-        let mut errors = vec![];\n-        let mut stalled = true;\n+        let mut outcome = OUT::new();\n \n         // Note that the loop body can append new nodes, and those new nodes\n         // will then be processed by subsequent iterations of the loop.\n@@ -429,7 +451,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 }\n                 ProcessResult::Changed(children) => {\n                     // We are not (yet) stalled.\n-                    stalled = false;\n+                    outcome.mark_not_stalled();\n                     node.state.set(NodeState::Success);\n \n                     for child in children {\n@@ -442,28 +464,22 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n-                    stalled = false;\n-                    errors.push(Error { error: err, backtrace: self.error_at(index) });\n+                    outcome.mark_not_stalled();\n+                    outcome.record_error(Error { error: err, backtrace: self.error_at(index) });\n                 }\n             }\n             index += 1;\n         }\n \n-        if stalled {\n-            // There's no need to perform marking, cycle processing and compression when nothing\n-            // changed.\n-            return Outcome {\n-                completed: if do_completed == DoCompleted::Yes { Some(vec![]) } else { None },\n-                errors,\n-                stalled,\n-            };\n+        // There's no need to perform marking, cycle processing and compression when nothing\n+        // changed.\n+        if !outcome.is_stalled() {\n+            self.mark_successes();\n+            self.process_cycles(processor);\n+            self.compress(|obl| outcome.record_completed(obl));\n         }\n \n-        self.mark_successes();\n-        self.process_cycles(processor);\n-        let completed = self.compress(do_completed);\n-\n-        Outcome { completed, errors, stalled }\n+        outcome\n     }\n \n     /// Returns a vector of obligations for `p` and all of its\n@@ -526,7 +542,6 @@ impl<O: ForestObligation> ObligationForest<O> {\n             let node = &self.nodes[index];\n             let state = node.state.get();\n             if state == NodeState::Success {\n-                node.state.set(NodeState::Waiting);\n                 // This call site is cold.\n                 self.uninlined_mark_dependents_as_waiting(node);\n             } else {\n@@ -538,17 +553,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This never-inlined function is for the cold call site.\n     #[inline(never)]\n     fn uninlined_mark_dependents_as_waiting(&self, node: &Node<O>) {\n+        // Mark node Waiting in the cold uninlined code instead of the hot inlined\n+        node.state.set(NodeState::Waiting);\n         self.inlined_mark_dependents_as_waiting(node)\n     }\n \n     /// Report cycles between all `Success` nodes, and convert all `Success`\n     /// nodes to `Done`. This must be called after `mark_successes`.\n-    fn process_cycles<P>(&self, processor: &mut P)\n+    fn process_cycles<P>(&mut self, processor: &mut P)\n     where\n         P: ObligationProcessor<Obligation = O>,\n     {\n-        let mut stack = vec![];\n-\n+        let mut stack = std::mem::take(&mut self.reused_node_vec);\n         for (index, node) in self.nodes.iter().enumerate() {\n             // For some benchmarks this state test is extremely hot. It's a win\n             // to handle the no-op cases immediately to avoid the cost of the\n@@ -559,6 +575,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         debug_assert!(stack.is_empty());\n+        self.reused_node_vec = stack;\n     }\n \n     fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n@@ -591,13 +608,12 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// indices and hence invalidates any outstanding indices. `process_cycles`\n     /// must be run beforehand to remove any cycles on `Success` nodes.\n     #[inline(never)]\n-    fn compress(&mut self, do_completed: DoCompleted) -> Option<Vec<O>> {\n+    fn compress(&mut self, mut outcome_cb: impl FnMut(&O)) {\n         let orig_nodes_len = self.nodes.len();\n-        let mut node_rewrites: Vec<_> = std::mem::take(&mut self.node_rewrites);\n+        let mut node_rewrites: Vec<_> = std::mem::take(&mut self.reused_node_vec);\n         debug_assert!(node_rewrites.is_empty());\n         node_rewrites.extend(0..orig_nodes_len);\n         let mut dead_nodes = 0;\n-        let mut removed_done_obligations: Vec<O> = vec![];\n \n         // Move removable nodes to the end, preserving the order of the\n         // remaining nodes.\n@@ -627,10 +643,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_cache_key().clone());\n                     }\n-                    if do_completed == DoCompleted::Yes {\n-                        // Extract the success stories.\n-                        removed_done_obligations.push(node.obligation.clone());\n-                    }\n+                    // Extract the success stories.\n+                    outcome_cb(&node.obligation);\n                     node_rewrites[index] = orig_nodes_len;\n                     dead_nodes += 1;\n                 }\n@@ -654,9 +668,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n         }\n \n         node_rewrites.truncate(0);\n-        self.node_rewrites = node_rewrites;\n-\n-        if do_completed == DoCompleted::Yes { Some(removed_done_obligations) } else { None }\n+        self.reused_node_vec = node_rewrites;\n     }\n \n     fn apply_rewrites(&mut self, node_rewrites: &[usize]) {"}, {"sha": "371c62c063fa79a90feec7e708a1cdce32473d6e", "filename": "compiler/rustc_data_structures/src/obligation_forest/tests.rs", "status": "modified", "additions": 261, "deletions": 298, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fobligation_forest%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -17,6 +17,40 @@ struct ClosureObligationProcessor<OF, BF, O, E> {\n     marker: PhantomData<(O, E)>,\n }\n \n+struct TestOutcome<O, E> {\n+    pub completed: Vec<O>,\n+    pub errors: Vec<Error<O, E>>,\n+    pub stalled: bool,\n+}\n+\n+impl<O, E> OutcomeTrait for TestOutcome<O, E>\n+where\n+    O: Clone,\n+{\n+    type Error = Error<O, E>;\n+    type Obligation = O;\n+\n+    fn new() -> Self {\n+        Self { errors: vec![], stalled: false, completed: vec![] }\n+    }\n+\n+    fn mark_not_stalled(&mut self) {\n+        self.stalled = false;\n+    }\n+\n+    fn is_stalled(&self) -> bool {\n+        self.stalled\n+    }\n+\n+    fn record_completed(&mut self, outcome: &Self::Obligation) {\n+        self.completed.push(outcome.clone())\n+    }\n+\n+    fn record_error(&mut self, error: Self::Error) {\n+        self.errors.push(error)\n+    }\n+}\n+\n #[allow(non_snake_case)]\n fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n where\n@@ -65,20 +99,17 @@ fn push_pop() {\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"B\" => ProcessResult::Error(\"B is for broken\"),\n-                \"C\" => ProcessResult::Changed(vec![]),\n-                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"C\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"B\" => ProcessResult::Error(\"B is for broken\"),\n+            \"C\" => ProcessResult::Changed(vec![]),\n+            \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err, vec![Error { error: \"B is for broken\", backtrace: vec![\"B\"] }]);\n \n     // second round: two delays, one success, creating an uneven set of subtasks:\n@@ -88,60 +119,51 @@ fn push_pop() {\n     //      D |-> D.1\n     //        |-> D.2\n     forest.register_obligation(\"D\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Unchanged,\n-                \"A.2\" => ProcessResult::Unchanged,\n-                \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n-                \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n-                \"A.3.i\" | \"D.1\" | \"D.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), Vec::<&'static str>::new());\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Unchanged,\n+            \"A.2\" => ProcessResult::Unchanged,\n+            \"A.3\" => ProcessResult::Changed(vec![\"A.3.i\"]),\n+            \"D\" => ProcessResult::Changed(vec![\"D.1\", \"D.2\"]),\n+            \"A.3.i\" | \"D.1\" | \"D.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, Vec::new());\n \n     // third round: ok in A.1 but trigger an error in A.2. Check that it\n     // propagates to A, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Changed(vec![]),\n-                \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n-                \"A.3.i\" => ProcessResult::Changed(vec![]),\n-                \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n-                \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n-                \"D.1.i\" | \"D.2.i\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Changed(vec![]),\n+            \"A.2\" => ProcessResult::Error(\"A is for apple\"),\n+            \"A.3.i\" => ProcessResult::Changed(vec![]),\n+            \"D.1\" => ProcessResult::Changed(vec![\"D.1.i\"]),\n+            \"D.2\" => ProcessResult::Changed(vec![\"D.2.i\"]),\n+            \"D.1.i\" | \"D.2.i\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A.1\", \"A.3\", \"A.3.i\"]);\n     assert_eq!(err, vec![Error { error: \"A is for apple\", backtrace: vec![\"A.2\", \"A\"] }]);\n \n     // fourth round: error in D.1.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n-                \"D.2.i\" => ProcessResult::Changed(vec![]),\n-                _ => panic!(\"unexpected obligation {:?}\", obligation),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D.1.i\" => ProcessResult::Error(\"D is for dumb\"),\n+            \"D.2.i\" => ProcessResult::Changed(vec![]),\n+            _ => panic!(\"unexpected obligation {:?}\", obligation),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"D.2\", \"D.2.i\"]);\n     assert_eq!(err, vec![Error { error: \"D is for dumb\", backtrace: vec![\"D.1.i\", \"D.1\", \"D\"] }]);\n@@ -160,72 +182,60 @@ fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"A.1\" => ProcessResult::Changed(vec![]),\n-                \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n-                \"A.3\" => ProcessResult::Changed(vec![]),\n-                \"A.2.i\" | \"A.2.ii\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"A.1\" => ProcessResult::Changed(vec![]),\n+            \"A.2\" => ProcessResult::Changed(vec![\"A.2.i\", \"A.2.ii\"]),\n+            \"A.3\" => ProcessResult::Changed(vec![]),\n+            \"A.2.i\" | \"A.2.ii\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A.1\", \"A.3\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i\" => ProcessResult::Unchanged,\n-                \"A.2.ii\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"A.2.ii\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i\" => ProcessResult::Unchanged,\n+            \"A.2.ii\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n-                \"A.2.i.a\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert!(ok.unwrap().is_empty());\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i\" => ProcessResult::Changed(vec![\"A.2.i.a\"]),\n+            \"A.2.i.a\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert!(ok.is_empty());\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.2.i.a\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A\", \"A.2\", \"A.2.i\", \"A.2.i.a\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}), DoCompleted::Yes);\n+    let TestOutcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}));\n \n-    assert!(ok.unwrap().is_empty());\n+    assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n \n@@ -235,18 +245,15 @@ fn to_errors_no_throw() {\n     // yields to correct errors (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n-                \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\", \"A.3\"]),\n+            \"A.1\" | \"A.2\" | \"A.3\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n     let errors = forest.to_errors(());\n     assert_eq!(errors[0].backtrace, vec![\"A.1\", \"A\"]);\n@@ -260,51 +267,42 @@ fn diamond() {\n     // check that diamond dependencies are handled correctly\n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"A\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n-                \"A.1\" | \"A.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"A.1\", \"A.2\"]),\n+            \"A.1\" | \"A.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n-                \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n-                \"D\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A.1\" => ProcessResult::Changed(vec![\"D\"]),\n+            \"A.2\" => ProcessResult::Changed(vec![\"D\"]),\n+            \"D\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => {\n-                    d_count += 1;\n-                    ProcessResult::Changed(vec![])\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => {\n+                d_count += 1;\n+                ProcessResult::Changed(vec![])\n+            }\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n     assert_eq!(d_count, 1);\n-    let mut ok = ok.unwrap();\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A\", \"A.1\", \"A.2\", \"D\"]);\n     assert_eq!(err.len(), 0);\n@@ -313,51 +311,42 @@ fn diamond() {\n     assert_eq!(errors.len(), 0);\n \n     forest.register_obligation(\"A'\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n-                \"A'.1\" | \"A'.2\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A'\" => ProcessResult::Changed(vec![\"A'.1\", \"A'.2\"]),\n+            \"A'.1\" | \"A'.2\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n-                \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n-                \"D'\" | \"A'\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A'.1\" => ProcessResult::Changed(vec![\"D'\", \"A'\"]),\n+            \"A'.2\" => ProcessResult::Changed(vec![\"D'\"]),\n+            \"D'\" | \"A'\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n     let mut d_count = 0;\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D'\" => {\n-                    d_count += 1;\n-                    ProcessResult::Error(\"operation failed\")\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D'\" => {\n+                d_count += 1;\n+                ProcessResult::Error(\"operation failed\")\n+            }\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n     assert_eq!(d_count, 1);\n-    assert_eq!(ok.unwrap().len(), 0);\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(\n         err,\n         vec![super::Error { error: \"operation failed\", backtrace: vec![\"D'\", \"A'.1\", \"A'\"] }]\n@@ -375,35 +364,27 @@ fn done_dependency() {\n     forest.register_obligation(\"B: Sized\");\n     forest.register_obligation(\"C: Sized\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => ProcessResult::Changed(vec![]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]);\n     assert_eq!(err.len(), 0);\n \n     forest.register_obligation(\"(A,B,C): Sized\");\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"(A,B,C): Sized\" => {\n-                    ProcessResult::Changed(vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"])\n-                }\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap(), vec![\"(A,B,C): Sized\"]);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"(A,B,C): Sized\" => ProcessResult::Changed(vec![\"A: Sized\", \"B: Sized\", \"C: Sized\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n     assert_eq!(err.len(), 0);\n }\n \n@@ -416,64 +397,52 @@ fn orphan() {\n     forest.register_obligation(\"C1\");\n     forest.register_obligation(\"C2\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n-                \"B\" => ProcessResult::Unchanged,\n-                \"C1\" => ProcessResult::Changed(vec![]),\n-                \"C2\" => ProcessResult::Changed(vec![]),\n-                \"D\" | \"E\" => ProcessResult::Unchanged,\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    let mut ok = ok.unwrap();\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Changed(vec![\"D\", \"E\"]),\n+            \"B\" => ProcessResult::Unchanged,\n+            \"C1\" => ProcessResult::Changed(vec![]),\n+            \"C2\" => ProcessResult::Changed(vec![]),\n+            \"D\" | \"E\" => ProcessResult::Unchanged,\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    let mut ok = ok;\n     ok.sort();\n     assert_eq!(ok, vec![\"C1\", \"C2\"]);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" | \"E\" => ProcessResult::Unchanged,\n-                \"B\" => ProcessResult::Changed(vec![\"D\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" | \"E\" => ProcessResult::Unchanged,\n+            \"B\" => ProcessResult::Changed(vec![\"D\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => ProcessResult::Unchanged,\n-                \"E\" => ProcessResult::Error(\"E is for error\"),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => ProcessResult::Unchanged,\n+            \"E\" => ProcessResult::Error(\"E is for error\"),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"E is for error\", backtrace: vec![\"E\", \"A\"] }]);\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"D\" => ProcessResult::Error(\"D is dead\"),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"D\" => ProcessResult::Error(\"D is dead\"),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"D is dead\", backtrace: vec![\"D\"] }]);\n \n     let errors = forest.to_errors(());\n@@ -487,35 +456,29 @@ fn simultaneous_register_and_error() {\n     forest.register_obligation(\"A\");\n     forest.register_obligation(\"B\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Error(\"An error\"),\n-                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Error(\"An error\"),\n+            \"B\" => ProcessResult::Changed(vec![\"A\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"An error\", backtrace: vec![\"A\"] }]);\n \n     let mut forest = ObligationForest::new();\n     forest.register_obligation(\"B\");\n     forest.register_obligation(\"A\");\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(\n-        &mut C(\n-            |obligation| match *obligation {\n-                \"A\" => ProcessResult::Error(\"An error\"),\n-                \"B\" => ProcessResult::Changed(vec![\"A\"]),\n-                _ => unreachable!(),\n-            },\n-            |_| {},\n-        ),\n-        DoCompleted::Yes,\n-    );\n-    assert_eq!(ok.unwrap().len(), 0);\n+    let TestOutcome { completed: ok, errors: err, .. } = forest.process_obligations(&mut C(\n+        |obligation| match *obligation {\n+            \"A\" => ProcessResult::Error(\"An error\"),\n+            \"B\" => ProcessResult::Changed(vec![\"A\"]),\n+            _ => unreachable!(),\n+        },\n+        |_| {},\n+    ));\n+    assert_eq!(ok.len(), 0);\n     assert_eq!(err, vec![super::Error { error: \"An error\", backtrace: vec![\"A\"] }]);\n }"}, {"sha": "e598d7a683d5aefeb8d22904edaff92dd7448a1c", "filename": "compiler/rustc_data_structures/src/profiling.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fprofiling.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -94,34 +94,9 @@ use std::process;\n use std::sync::Arc;\n use std::time::{Duration, Instant};\n \n-use measureme::{EventId, EventIdBuilder, SerializableString, StringId};\n+use measureme::{EventId, EventIdBuilder, Profiler, SerializableString, StringId};\n use parking_lot::RwLock;\n \n-cfg_if! {\n-    if #[cfg(any(windows, target_os = \"wasi\"))] {\n-        /// FileSerializationSink is faster on Windows\n-        type SerializationSink = measureme::FileSerializationSink;\n-    } else if #[cfg(target_arch = \"wasm32\")] {\n-        type SerializationSink = measureme::ByteVecSink;\n-    } else {\n-        /// MmapSerializatioSink is faster on macOS and Linux\n-        type SerializationSink = measureme::MmapSerializationSink;\n-    }\n-}\n-\n-type Profiler = measureme::Profiler<SerializationSink>;\n-\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd)]\n-pub enum ProfileCategory {\n-    Parsing,\n-    Expansion,\n-    TypeChecking,\n-    BorrowChecking,\n-    Codegen,\n-    Linking,\n-    Other,\n-}\n-\n bitflags::bitflags! {\n     struct EventFilter: u32 {\n         const GENERIC_ACTIVITIES = 1 << 0;\n@@ -400,7 +375,7 @@ impl SelfProfiler {\n         output_directory: &Path,\n         crate_name: Option<&str>,\n         event_filters: &Option<Vec<String>>,\n-    ) -> Result<SelfProfiler, Box<dyn Error>> {\n+    ) -> Result<SelfProfiler, Box<dyn Error + Send + Sync>> {\n         fs::create_dir_all(output_directory)?;\n \n         let crate_name = crate_name.unwrap_or(\"unknown-crate\");\n@@ -511,13 +486,13 @@ impl SelfProfiler {\n         self.event_filter_mask.contains(EventFilter::QUERY_KEYS)\n     }\n \n-    pub fn event_id_builder(&self) -> EventIdBuilder<'_, SerializationSink> {\n+    pub fn event_id_builder(&self) -> EventIdBuilder<'_> {\n         EventIdBuilder::new(&self.profiler)\n     }\n }\n \n #[must_use]\n-pub struct TimingGuard<'a>(Option<measureme::TimingGuard<'a, SerializationSink>>);\n+pub struct TimingGuard<'a>(Option<measureme::TimingGuard<'a>>);\n \n impl<'a> TimingGuard<'a> {\n     #[inline]"}, {"sha": "53062b9c20da8b8e6e6118730a518ff98c3bbf3f", "filename": "compiler/rustc_data_structures/src/sip128.rs", "status": "modified", "additions": 343, "deletions": 196, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,21 +1,53 @@\n //! This is a copy of `core::hash::sip` adapted to providing 128 bit hashes.\n \n-use std::cmp;\n use std::hash::Hasher;\n-use std::mem;\n+use std::mem::{self, MaybeUninit};\n use std::ptr;\n \n #[cfg(test)]\n mod tests;\n \n+// The SipHash algorithm operates on 8-byte chunks.\n+const ELEM_SIZE: usize = mem::size_of::<u64>();\n+\n+// Size of the buffer in number of elements, not including the spill.\n+//\n+// The selection of this size was guided by rustc-perf benchmark comparisons of\n+// different buffer sizes. It should be periodically reevaluated as the compiler\n+// implementation and input characteristics change.\n+//\n+// Using the same-sized buffer for everything we hash is a performance versus\n+// complexity tradeoff. The ideal buffer size, and whether buffering should even\n+// be used, depends on what is being hashed. It may be worth it to size the\n+// buffer appropriately (perhaps by making SipHasher128 generic over the buffer\n+// size) or disable buffering depending on what is being hashed. But at this\n+// time, we use the same buffer size for everything.\n+const BUFFER_CAPACITY: usize = 8;\n+\n+// Size of the buffer in bytes, not including the spill.\n+const BUFFER_SIZE: usize = BUFFER_CAPACITY * ELEM_SIZE;\n+\n+// Size of the buffer in number of elements, including the spill.\n+const BUFFER_WITH_SPILL_CAPACITY: usize = BUFFER_CAPACITY + 1;\n+\n+// Size of the buffer in bytes, including the spill.\n+const BUFFER_WITH_SPILL_SIZE: usize = BUFFER_WITH_SPILL_CAPACITY * ELEM_SIZE;\n+\n+// Index of the spill element in the buffer.\n+const BUFFER_SPILL_INDEX: usize = BUFFER_WITH_SPILL_CAPACITY - 1;\n+\n #[derive(Debug, Clone)]\n+#[repr(C)]\n pub struct SipHasher128 {\n-    k0: u64,\n-    k1: u64,\n-    length: usize, // how many bytes we've processed\n-    state: State,  // hash State\n-    tail: u64,     // unprocessed bytes le\n-    ntail: usize,  // how many bytes in tail are valid\n+    // The access pattern during hashing consists of accesses to `nbuf` and\n+    // `buf` until the buffer is full, followed by accesses to `state` and\n+    // `processed`, and then repetition of that pattern until hashing is done.\n+    // This is the basis for the ordering of fields below. However, in practice\n+    // the cache miss-rate for data access is extremely low regardless of order.\n+    nbuf: usize, // how many bytes in buf are valid\n+    buf: [MaybeUninit<u64>; BUFFER_WITH_SPILL_CAPACITY], // unprocessed bytes le\n+    state: State, // hash State\n+    processed: usize, // how many bytes we've processed\n }\n \n #[derive(Debug, Clone, Copy)]\n@@ -51,271 +83,386 @@ macro_rules! compress {\n     }};\n }\n \n-/// Loads an integer of the desired type from a byte stream, in LE order. Uses\n-/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n-/// to load it from a possibly unaligned address.\n-///\n-/// Unsafe because: unchecked indexing at i..i+size_of(int_ty)\n-macro_rules! load_int_le {\n-    ($buf:expr, $i:expr, $int_ty:ident) => {{\n-        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n-        let mut data = 0 as $int_ty;\n-        ptr::copy_nonoverlapping(\n-            $buf.get_unchecked($i),\n-            &mut data as *mut _ as *mut u8,\n-            mem::size_of::<$int_ty>(),\n-        );\n-        data.to_le()\n-    }};\n-}\n-\n-/// Loads a u64 using up to 7 bytes of a byte slice. It looks clumsy but the\n-/// `copy_nonoverlapping` calls that occur (via `load_int_le!`) all have fixed\n-/// sizes and avoid calling `memcpy`, which is good for speed.\n-///\n-/// Unsafe because: unchecked indexing at start..start+len\n+// Copies up to 8 bytes from source to destination. This performs better than\n+// `ptr::copy_nonoverlapping` on microbenchmarks and may perform better on real\n+// workloads since all of the copies have fixed sizes and avoid calling memcpy.\n+//\n+// This is specifically designed for copies of up to 8 bytes, because that's the\n+// maximum of number bytes needed to fill an 8-byte-sized element on which\n+// SipHash operates. Note that for variable-sized copies which are known to be\n+// less than 8 bytes, this function will perform more work than necessary unless\n+// the compiler is able to optimize the extra work away.\n #[inline]\n-unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n-    debug_assert!(len < 8);\n-    let mut i = 0; // current byte index (from LSB) in the output u64\n-    let mut out = 0;\n-    if i + 3 < len {\n-        out = load_int_le!(buf, start + i, u32) as u64;\n+unsafe fn copy_nonoverlapping_small(src: *const u8, dst: *mut u8, count: usize) {\n+    debug_assert!(count <= 8);\n+\n+    if count == 8 {\n+        ptr::copy_nonoverlapping(src, dst, 8);\n+        return;\n+    }\n+\n+    let mut i = 0;\n+    if i + 3 < count {\n+        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 4);\n         i += 4;\n     }\n-    if i + 1 < len {\n-        out |= (load_int_le!(buf, start + i, u16) as u64) << (i * 8);\n+\n+    if i + 1 < count {\n+        ptr::copy_nonoverlapping(src.add(i), dst.add(i), 2);\n         i += 2\n     }\n-    if i < len {\n-        out |= (*buf.get_unchecked(start + i) as u64) << (i * 8);\n+\n+    if i < count {\n+        *dst.add(i) = *src.add(i);\n         i += 1;\n     }\n-    debug_assert_eq!(i, len);\n-    out\n+\n+    debug_assert_eq!(i, count);\n }\n \n+// # Implementation\n+//\n+// This implementation uses buffering to reduce the hashing cost for inputs\n+// consisting of many small integers. Buffering simplifies the integration of\n+// integer input--the integer write function typically just appends to the\n+// buffer with a statically sized write, updates metadata, and returns.\n+//\n+// Buffering also prevents alternating between writes that do and do not trigger\n+// the hashing process. Only when the entire buffer is full do we transition\n+// into hashing. This allows us to keep the hash state in registers for longer,\n+// instead of loading and storing it before and after processing each element.\n+//\n+// When a write fills the buffer, a buffer processing function is invoked to\n+// hash all of the buffered input. The buffer processing functions are marked\n+// `#[inline(never)]` so that they aren't inlined into the append functions,\n+// which ensures the more frequently called append functions remain inlineable\n+// and don't include register pushing/popping that would only be made necessary\n+// by inclusion of the complex buffer processing path which uses those\n+// registers.\n+//\n+// The buffer includes a \"spill\"--an extra element at the end--which simplifies\n+// the integer write buffer processing path. The value that fills the buffer can\n+// be written with a statically sized write that may spill over into the spill.\n+// After the buffer is processed, the part of the value that spilled over can be\n+// written from the spill to the beginning of the buffer with another statically\n+// sized write. This write may copy more bytes than actually spilled over, but\n+// we maintain the metadata such that any extra copied bytes will be ignored by\n+// subsequent processing. Due to the static sizes, this scheme performs better\n+// than copying the exact number of bytes needed into the end and beginning of\n+// the buffer.\n+//\n+// The buffer is uninitialized, which improves performance, but may preclude\n+// efficient implementation of alternative approaches. The improvement is not so\n+// large that an alternative approach should be disregarded because it cannot be\n+// efficiently implemented with an uninitialized buffer. On the other hand, an\n+// uninitialized buffer may become more important should a larger one be used.\n+//\n+// # Platform Dependence\n+//\n+// The SipHash algorithm operates on byte sequences. It parses the input stream\n+// as 8-byte little-endian integers. Therefore, given the same byte sequence, it\n+// produces the same result on big- and little-endian hardware.\n+//\n+// However, the Hasher trait has methods which operate on multi-byte integers.\n+// How they are converted into byte sequences can be endian-dependent (by using\n+// native byte order) or independent (by consistently using either LE or BE byte\n+// order). It can also be `isize` and `usize` size dependent (by using the\n+// native size), or independent (by converting to a common size), supposing the\n+// values can be represented in 32 bits.\n+//\n+// In order to make `SipHasher128` consistent with `SipHasher` in libstd, we\n+// choose to do the integer to byte sequence conversion in the platform-\n+// dependent way. Clients can achieve platform-independent hashing by widening\n+// `isize` and `usize` integers to 64 bits on 32-bit systems and byte-swapping\n+// integers on big-endian systems before passing them to the writing functions.\n+// This causes the input byte sequence to look identical on big- and little-\n+// endian systems (supposing `isize` and `usize` values can be represented in 32\n+// bits), which ensures platform-independent results.\n impl SipHasher128 {\n     #[inline]\n     pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher128 {\n-        let mut state = SipHasher128 {\n-            k0: key0,\n-            k1: key1,\n-            length: 0,\n-            state: State { v0: 0, v1: 0, v2: 0, v3: 0 },\n-            tail: 0,\n-            ntail: 0,\n+        let mut hasher = SipHasher128 {\n+            nbuf: 0,\n+            buf: MaybeUninit::uninit_array(),\n+            state: State {\n+                v0: key0 ^ 0x736f6d6570736575,\n+                // The XOR with 0xee is only done on 128-bit algorithm version.\n+                v1: key1 ^ (0x646f72616e646f6d ^ 0xee),\n+                v2: key0 ^ 0x6c7967656e657261,\n+                v3: key1 ^ 0x7465646279746573,\n+            },\n+            processed: 0,\n         };\n-        state.reset();\n-        state\n+\n+        unsafe {\n+            // Initialize spill because we read from it in `short_write_process_buffer`.\n+            *hasher.buf.get_unchecked_mut(BUFFER_SPILL_INDEX) = MaybeUninit::zeroed();\n+        }\n+\n+        hasher\n     }\n \n+    // A specialized write function for values with size <= 8.\n     #[inline]\n-    fn reset(&mut self) {\n-        self.length = 0;\n-        self.state.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.state.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.state.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.state.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n-\n-        // This is only done in the 128 bit version:\n-        self.state.v1 ^= 0xee;\n+    fn short_write<T>(&mut self, x: T) {\n+        let size = mem::size_of::<T>();\n+        let nbuf = self.nbuf;\n+        debug_assert!(size <= 8);\n+        debug_assert!(nbuf < BUFFER_SIZE);\n+        debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);\n+\n+        if nbuf + size < BUFFER_SIZE {\n+            unsafe {\n+                // The memcpy call is optimized away because the size is known.\n+                let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+                ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);\n+            }\n+\n+            self.nbuf = nbuf + size;\n+\n+            return;\n+        }\n+\n+        unsafe { self.short_write_process_buffer(x) }\n     }\n \n-    // A specialized write function for values with size <= 8.\n-    //\n-    // The input must be zero-extended to 64-bits by the caller. This extension\n-    // isn't hashed, but the implementation requires it for correctness.\n+    // A specialized write function for values with size <= 8 that should only\n+    // be called when the write would cause the buffer to fill.\n     //\n-    // This function, given the same integer size and value, has the same effect\n-    // on both little- and big-endian hardware. It operates on values without\n-    // depending on their sequence in memory, so is independent of endianness.\n-    //\n-    // However, we want SipHasher128 to be platform-dependent, in order to be\n-    // consistent with the platform-dependent SipHasher in libstd. In other\n-    // words, we want:\n-    //\n-    // - little-endian: `write_u32(0xDDCCBBAA)` == `write([0xAA, 0xBB, 0xCC, 0xDD])`\n-    // - big-endian:    `write_u32(0xDDCCBBAA)` == `write([0xDD, 0xCC, 0xBB, 0xAA])`\n-    //\n-    // Therefore, in order to produce endian-dependent results, SipHasher128's\n-    // `write_xxx` Hasher trait methods byte-swap `x` prior to zero-extending.\n-    //\n-    // If clients of SipHasher128 itself want platform-independent results, they\n-    // *also* must byte-swap integer inputs before invoking the `write_xxx`\n-    // methods on big-endian hardware (that is, two byte-swaps must occur--one\n-    // in the client, and one in SipHasher128). Additionally, they must extend\n-    // `usize` and `isize` types to 64 bits on 32-bit systems.\n-    #[inline]\n-    fn short_write<T>(&mut self, _x: T, x: u64) {\n+    // SAFETY: the write of `x` into `self.buf` starting at byte offset\n+    // `self.nbuf` must cause `self.buf` to become fully initialized (and not\n+    // overflow) if it wasn't already.\n+    #[inline(never)]\n+    unsafe fn short_write_process_buffer<T>(&mut self, x: T) {\n         let size = mem::size_of::<T>();\n-        self.length += size;\n-\n-        // The original number must be zero-extended, not sign-extended.\n-        debug_assert!(if size < 8 { x >> (8 * size) == 0 } else { true });\n-\n-        // The number of bytes needed to fill `self.tail`.\n-        let needed = 8 - self.ntail;\n-\n-        // SipHash parses the input stream as 8-byte little-endian integers.\n-        // Inputs are put into `self.tail` until 8 bytes of data have been\n-        // collected, and then that word is processed.\n-        //\n-        // For example, imagine that `self.tail` is 0x0000_00EE_DDCC_BBAA,\n-        // `self.ntail` is 5 (because 5 bytes have been put into `self.tail`),\n-        // and `needed` is therefore 3.\n-        //\n-        // - Scenario 1, `self.write_u8(0xFF)`: we have already zero-extended\n-        //   the input to 0x0000_0000_0000_00FF. We now left-shift it five\n-        //   bytes, giving 0x0000_FF00_0000_0000. We then bitwise-OR that value\n-        //   into `self.tail`, resulting in 0x0000_FFEE_DDCC_BBAA.\n-        //   (Zero-extension of the original input is critical in this scenario\n-        //   because we don't want the high two bytes of `self.tail` to be\n-        //   touched by the bitwise-OR.) `self.tail` is not yet full, so we\n-        //   return early, after updating `self.ntail` to 6.\n-        //\n-        // - Scenario 2, `self.write_u32(0xIIHH_GGFF)`: we have already\n-        //   zero-extended the input to 0x0000_0000_IIHH_GGFF. We now\n-        //   left-shift it five bytes, giving 0xHHGG_FF00_0000_0000. We then\n-        //   bitwise-OR that value into `self.tail`, resulting in\n-        //   0xHHGG_FFEE_DDCC_BBAA. `self.tail` is now full, and we can use it\n-        //   to update `self.state`. (As mentioned above, this assumes a\n-        //   little-endian machine; on a big-endian machine we would have\n-        //   byte-swapped 0xIIHH_GGFF in the caller, giving 0xFFGG_HHII, and we\n-        //   would then end up bitwise-ORing 0xGGHH_II00_0000_0000 into\n-        //   `self.tail`).\n-        //\n-        self.tail |= x << (8 * self.ntail);\n-        if size < needed {\n-            self.ntail += size;\n+        let nbuf = self.nbuf;\n+        debug_assert!(size <= 8);\n+        debug_assert!(nbuf < BUFFER_SIZE);\n+        debug_assert!(nbuf + size >= BUFFER_SIZE);\n+        debug_assert!(nbuf + size < BUFFER_WITH_SPILL_SIZE);\n+\n+        // Copy first part of input into end of buffer, possibly into spill\n+        // element. The memcpy call is optimized away because the size is known.\n+        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+        ptr::copy_nonoverlapping(&x as *const _ as *const u8, dst, size);\n+\n+        // Process buffer.\n+        for i in 0..BUFFER_CAPACITY {\n+            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+            self.state.v3 ^= elem;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= elem;\n+        }\n+\n+        // Copy remaining input into start of buffer by copying size - 1\n+        // elements from spill (at most size - 1 bytes could have overflowed\n+        // into the spill). The memcpy call is optimized away because the size\n+        // is known. And the whole copy is optimized away for size == 1.\n+        let src = self.buf.get_unchecked(BUFFER_SPILL_INDEX) as *const _ as *const u8;\n+        ptr::copy_nonoverlapping(src, self.buf.as_mut_ptr() as *mut u8, size - 1);\n+\n+        // This function should only be called when the write fills the buffer.\n+        // Therefore, when size == 1, the new `self.nbuf` must be zero. The size\n+        // is statically known, so the branch is optimized away.\n+        self.nbuf = if size == 1 { 0 } else { nbuf + size - BUFFER_SIZE };\n+        self.processed += BUFFER_SIZE;\n+    }\n+\n+    // A write function for byte slices.\n+    #[inline]\n+    fn slice_write(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        let nbuf = self.nbuf;\n+        debug_assert!(nbuf < BUFFER_SIZE);\n+\n+        if nbuf + length < BUFFER_SIZE {\n+            unsafe {\n+                let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+\n+                if length <= 8 {\n+                    copy_nonoverlapping_small(msg.as_ptr(), dst, length);\n+                } else {\n+                    // This memcpy is *not* optimized away.\n+                    ptr::copy_nonoverlapping(msg.as_ptr(), dst, length);\n+                }\n+            }\n+\n+            self.nbuf = nbuf + length;\n+\n             return;\n         }\n \n-        // `self.tail` is full, process it.\n-        self.state.v3 ^= self.tail;\n-        Sip24Rounds::c_rounds(&mut self.state);\n-        self.state.v0 ^= self.tail;\n-\n-        // Continuing scenario 2: we have one byte left over from the input. We\n-        // set `self.ntail` to 1 and `self.tail` to `0x0000_0000_IIHH_GGFF >>\n-        // 8*3`, which is 0x0000_0000_0000_00II. (Or on a big-endian machine\n-        // the prior byte-swapping would leave us with 0x0000_0000_0000_00FF.)\n-        //\n-        // The `if` is needed to avoid shifting by 64 bits, which Rust\n-        // complains about.\n-        self.ntail = size - needed;\n-        self.tail = if needed < 8 { x >> (8 * needed) } else { 0 };\n+        unsafe { self.slice_write_process_buffer(msg) }\n+    }\n+\n+    // A write function for byte slices that should only be called when the\n+    // write would cause the buffer to fill.\n+    //\n+    // SAFETY: `self.buf` must be initialized up to the byte offset `self.nbuf`,\n+    // and `msg` must contain enough bytes to initialize the rest of the element\n+    // containing the byte offset `self.nbuf`.\n+    #[inline(never)]\n+    unsafe fn slice_write_process_buffer(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        let nbuf = self.nbuf;\n+        debug_assert!(nbuf < BUFFER_SIZE);\n+        debug_assert!(nbuf + length >= BUFFER_SIZE);\n+\n+        // Always copy first part of input into current element of buffer.\n+        // This function should only be called when the write fills the buffer,\n+        // so we know that there is enough input to fill the current element.\n+        let valid_in_elem = nbuf % ELEM_SIZE;\n+        let needed_in_elem = ELEM_SIZE - valid_in_elem;\n+\n+        let src = msg.as_ptr();\n+        let dst = (self.buf.as_mut_ptr() as *mut u8).add(nbuf);\n+        copy_nonoverlapping_small(src, dst, needed_in_elem);\n+\n+        // Process buffer.\n+\n+        // Using `nbuf / ELEM_SIZE + 1` rather than `(nbuf + needed_in_elem) /\n+        // ELEM_SIZE` to show the compiler that this loop's upper bound is > 0.\n+        // We know that is true, because last step ensured we have a full\n+        // element in the buffer.\n+        let last = nbuf / ELEM_SIZE + 1;\n+\n+        for i in 0..last {\n+            let elem = self.buf.get_unchecked(i).assume_init().to_le();\n+            self.state.v3 ^= elem;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= elem;\n+        }\n+\n+        // Process the remaining element-sized chunks of input.\n+        let mut processed = needed_in_elem;\n+        let input_left = length - processed;\n+        let elems_left = input_left / ELEM_SIZE;\n+        let extra_bytes_left = input_left % ELEM_SIZE;\n+\n+        for _ in 0..elems_left {\n+            let elem = (msg.as_ptr().add(processed) as *const u64).read_unaligned().to_le();\n+            self.state.v3 ^= elem;\n+            Sip24Rounds::c_rounds(&mut self.state);\n+            self.state.v0 ^= elem;\n+            processed += ELEM_SIZE;\n+        }\n+\n+        // Copy remaining input into start of buffer.\n+        let src = msg.as_ptr().add(processed);\n+        let dst = self.buf.as_mut_ptr() as *mut u8;\n+        copy_nonoverlapping_small(src, dst, extra_bytes_left);\n+\n+        self.nbuf = extra_bytes_left;\n+        self.processed += nbuf + processed;\n     }\n \n     #[inline]\n     pub fn finish128(mut self) -> (u64, u64) {\n-        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n+        debug_assert!(self.nbuf < BUFFER_SIZE);\n \n-        self.state.v3 ^= b;\n-        Sip24Rounds::c_rounds(&mut self.state);\n-        self.state.v0 ^= b;\n+        // Process full elements in buffer.\n+        let last = self.nbuf / ELEM_SIZE;\n \n-        self.state.v2 ^= 0xee;\n-        Sip24Rounds::d_rounds(&mut self.state);\n-        let _0 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n+        // Since we're consuming self, avoid updating members for a potential\n+        // performance gain.\n+        let mut state = self.state;\n+\n+        for i in 0..last {\n+            let elem = unsafe { self.buf.get_unchecked(i).assume_init().to_le() };\n+            state.v3 ^= elem;\n+            Sip24Rounds::c_rounds(&mut state);\n+            state.v0 ^= elem;\n+        }\n+\n+        // Get remaining partial element.\n+        let elem = if self.nbuf % ELEM_SIZE != 0 {\n+            unsafe {\n+                // Ensure element is initialized by writing zero bytes. At most\n+                // `ELEM_SIZE - 1` are required given the above check. It's safe\n+                // to write this many because we have the spill and we maintain\n+                // `self.nbuf` such that this write will start before the spill.\n+                let dst = (self.buf.as_mut_ptr() as *mut u8).add(self.nbuf);\n+                ptr::write_bytes(dst, 0, ELEM_SIZE - 1);\n+                self.buf.get_unchecked(last).assume_init().to_le()\n+            }\n+        } else {\n+            0\n+        };\n+\n+        // Finalize the hash.\n+        let length = self.processed + self.nbuf;\n+        let b: u64 = ((length as u64 & 0xff) << 56) | elem;\n+\n+        state.v3 ^= b;\n+        Sip24Rounds::c_rounds(&mut state);\n+        state.v0 ^= b;\n+\n+        state.v2 ^= 0xee;\n+        Sip24Rounds::d_rounds(&mut state);\n+        let _0 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;\n+\n+        state.v1 ^= 0xdd;\n+        Sip24Rounds::d_rounds(&mut state);\n+        let _1 = state.v0 ^ state.v1 ^ state.v2 ^ state.v3;\n \n-        self.state.v1 ^= 0xdd;\n-        Sip24Rounds::d_rounds(&mut self.state);\n-        let _1 = self.state.v0 ^ self.state.v1 ^ self.state.v2 ^ self.state.v3;\n         (_0, _1)\n     }\n }\n \n impl Hasher for SipHasher128 {\n     #[inline]\n     fn write_u8(&mut self, i: u8) {\n-        self.short_write(i, i as u64);\n+        self.short_write(i);\n     }\n \n     #[inline]\n     fn write_u16(&mut self, i: u16) {\n-        self.short_write(i, i.to_le() as u64);\n+        self.short_write(i);\n     }\n \n     #[inline]\n     fn write_u32(&mut self, i: u32) {\n-        self.short_write(i, i.to_le() as u64);\n+        self.short_write(i);\n     }\n \n     #[inline]\n     fn write_u64(&mut self, i: u64) {\n-        self.short_write(i, i.to_le() as u64);\n+        self.short_write(i);\n     }\n \n     #[inline]\n     fn write_usize(&mut self, i: usize) {\n-        self.short_write(i, i.to_le() as u64);\n+        self.short_write(i);\n     }\n \n     #[inline]\n     fn write_i8(&mut self, i: i8) {\n-        self.short_write(i, i as u8 as u64);\n+        self.short_write(i as u8);\n     }\n \n     #[inline]\n     fn write_i16(&mut self, i: i16) {\n-        self.short_write(i, (i as u16).to_le() as u64);\n+        self.short_write(i as u16);\n     }\n \n     #[inline]\n     fn write_i32(&mut self, i: i32) {\n-        self.short_write(i, (i as u32).to_le() as u64);\n+        self.short_write(i as u32);\n     }\n \n     #[inline]\n     fn write_i64(&mut self, i: i64) {\n-        self.short_write(i, (i as u64).to_le() as u64);\n+        self.short_write(i as u64);\n     }\n \n     #[inline]\n     fn write_isize(&mut self, i: isize) {\n-        self.short_write(i, (i as usize).to_le() as u64);\n+        self.short_write(i as usize);\n     }\n \n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n-        let length = msg.len();\n-        self.length += length;\n-\n-        let mut needed = 0;\n-\n-        if self.ntail != 0 {\n-            needed = 8 - self.ntail;\n-            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n-            if length < needed {\n-                self.ntail += length;\n-                return;\n-            } else {\n-                self.state.v3 ^= self.tail;\n-                Sip24Rounds::c_rounds(&mut self.state);\n-                self.state.v0 ^= self.tail;\n-                self.ntail = 0;\n-            }\n-        }\n-\n-        // Buffered tail is now flushed, process new input.\n-        let len = length - needed;\n-        let left = len & 0x7;\n-\n-        let mut i = needed;\n-        while i < len - left {\n-            let mi = unsafe { load_int_le!(msg, i, u64) };\n-\n-            self.state.v3 ^= mi;\n-            Sip24Rounds::c_rounds(&mut self.state);\n-            self.state.v0 ^= mi;\n-\n-            i += 8;\n-        }\n-\n-        self.tail = unsafe { u8to64_le(msg, i, left) };\n-        self.ntail = left;\n+        self.slice_write(msg);\n     }\n \n     fn finish(&self) -> u64 {"}, {"sha": "5fe967c4158fe3141ea6a23ec6f4c3b61765d697", "filename": "compiler/rustc_data_structures/src/sip128/tests.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsip128%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -450,3 +450,48 @@ fn test_short_write_works() {\n \n     assert_eq!(h1_hash, h2_hash);\n }\n+\n+macro_rules! test_fill_buffer {\n+    ($type:ty, $write_method:ident) => {{\n+        // Test filling and overfilling the buffer from all possible offsets\n+        // for a given integer type and its corresponding write method.\n+        const SIZE: usize = std::mem::size_of::<$type>();\n+        let input = [42; BUFFER_SIZE];\n+        let x = 0x01234567_89ABCDEF_76543210_FEDCBA98_u128 as $type;\n+        let x_bytes = &x.to_ne_bytes();\n+\n+        for i in 1..=SIZE {\n+            let s = &input[..BUFFER_SIZE - i];\n+\n+            let mut h1 = SipHasher128::new_with_keys(7, 13);\n+            h1.write(s);\n+            h1.$write_method(x);\n+\n+            let mut h2 = SipHasher128::new_with_keys(7, 13);\n+            h2.write(s);\n+            h2.write(x_bytes);\n+\n+            let h1_hash = h1.finish128();\n+            let h2_hash = h2.finish128();\n+\n+            assert_eq!(h1_hash, h2_hash);\n+        }\n+    }};\n+}\n+\n+#[test]\n+fn test_fill_buffer() {\n+    test_fill_buffer!(u8, write_u8);\n+    test_fill_buffer!(u16, write_u16);\n+    test_fill_buffer!(u32, write_u32);\n+    test_fill_buffer!(u64, write_u64);\n+    test_fill_buffer!(u128, write_u128);\n+    test_fill_buffer!(usize, write_usize);\n+\n+    test_fill_buffer!(i8, write_i8);\n+    test_fill_buffer!(i16, write_i16);\n+    test_fill_buffer!(i32, write_i32);\n+    test_fill_buffer!(i64, write_i64);\n+    test_fill_buffer!(i128, write_i128);\n+    test_fill_buffer!(isize, write_isize);\n+}"}, {"sha": "26d35f2620cb26ca249182672c6d0442bfe280ab", "filename": "compiler/rustc_error_codes/src/error_codes/E0660.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0660.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0660.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0660.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -9,4 +9,4 @@ llvm_asm!(\"nop\" \"nop\");\n Considering that this would be a long explanation, we instead recommend you\n take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\n+[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "0b8ba7fbbedac76d1caf2fa17347e1eae0c07800", "filename": "compiler/rustc_error_codes/src/error_codes/E0661.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0661.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0661.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0661.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,4 +10,4 @@ llvm_asm!(\"nop\" : \"r\"(a));\n Considering that this would be a long explanation, we instead recommend you\n take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\n+[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "8c1bab8d0410da5e0fcaef32ac3161488879cd65", "filename": "compiler/rustc_error_codes/src/error_codes/E0662.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0662.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0662.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0662.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,4 +13,4 @@ llvm_asm!(\"xor %eax, %eax\"\n Considering that this would be a long explanation, we instead recommend you\n take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\n+[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "53ffd3373a51c30cd43988ac59c2ae232523f637", "filename": "compiler/rustc_error_codes/src/error_codes/E0663.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0663.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0663.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0663.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,4 +13,4 @@ llvm_asm!(\"xor %eax, %eax\"\n Considering that this would be a long explanation, we instead recommend you\n take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\n+[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "f8e72cd330a31d91b2fcfc6816d304a02f2b159c", "filename": "compiler/rustc_error_codes/src/error_codes/E0664.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0664.md", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0664.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0664.md?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,4 +13,4 @@ llvm_asm!(\"mov $$0x200, %eax\"\n Considering that this would be a long explanation, we instead recommend you\n take a look at the [`llvm_asm`] chapter of the Unstable book:\n \n-[llvm_asm]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html\n+[`llvm_asm`]: https://doc.rust-lang.org/stable/unstable-book/library-features/llvm-asm.html"}, {"sha": "3551b92967c4716520c7beaf0f3819e0b21df8d2", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -3,10 +3,13 @@\n use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n+use rustc_ast::token::{DelimToken, Token, TokenKind};\n+use rustc_ast::tokenstream::{DelimSpan, LazyTokenStreamInner, Spacing, TokenStream, TokenTree};\n use rustc_ast::{self as ast, AttrItem, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n@@ -289,7 +292,37 @@ impl<'a> StripUnconfigured<'a> {\n         expanded_attrs\n             .into_iter()\n             .flat_map(|(item, span)| {\n-                let attr = attr::mk_attr_from_item(attr.style, item, span);\n+                let orig_tokens =\n+                    attr.tokens.as_ref().unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", attr));\n+\n+                // We are taking an attribute of the form `#[cfg_attr(pred, attr)]`\n+                // and producing an attribute of the form `#[attr]`. We\n+                // have captured tokens for `attr` itself, but we need to\n+                // synthesize tokens for the wrapper `#` and `[]`, which\n+                // we do below.\n+\n+                // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n+                // for `attr` when we expand it to `#[attr]`\n+                let pound_token = orig_tokens.into_token_stream().trees().next().unwrap();\n+                if !matches!(pound_token, TokenTree::Token(Token { kind: TokenKind::Pound, .. })) {\n+                    panic!(\"Bad tokens for attribute {:?}\", attr);\n+                }\n+                // We don't really have a good span to use for the syntheized `[]`\n+                // in `#[attr]`, so just use the span of the `#` token.\n+                let bracket_group = TokenTree::Delimited(\n+                    DelimSpan::from_single(pound_token.span()),\n+                    DelimToken::Bracket,\n+                    item.tokens\n+                        .clone()\n+                        .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n+                        .into_token_stream(),\n+                );\n+\n+                let mut attr = attr::mk_attr_from_item(attr.style, item, span);\n+                attr.tokens = Some(Lrc::new(LazyTokenStreamInner::Ready(TokenStream::new(vec![\n+                    (pound_token, Spacing::Alone),\n+                    (bracket_group, Spacing::Alone),\n+                ]))));\n                 self.process_cfg_attr(attr)\n             })\n             .collect()"}, {"sha": "3e5762ab992f48a470c89d0abe6b272986beacf9", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1357,7 +1357,8 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         // we'll expand attributes on expressions separately\n         if !stmt.is_expr() {\n             let (attr, derives, after_derive) = if stmt.is_item() {\n-                self.classify_item(&mut stmt)\n+                // FIXME: Handle custom attributes on statements (#15701)\n+                (None, vec![], false)\n             } else {\n                 // ignore derives on non-item statements so it falls through\n                 // to the unused-attributes lint\n@@ -1785,6 +1786,7 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                 span: at.span,\n                 id: at.id,\n                 style: at.style,\n+                tokens: None,\n             };\n         } else {\n             noop_visit_attribute(at, self)"}, {"sha": "791d2686cb5eb198cc845604b668fc626ecd2ca5", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -288,7 +288,8 @@ fn generic_extension<'cx>(\n                 // Replace all the tokens for the corresponding positions in the macro, to maintain\n                 // proper positions in error reporting, while maintaining the macro_backtrace.\n                 if rhs_spans.len() == tts.len() {\n-                    tts = tts.map_enumerated(|i, mut tt| {\n+                    tts = tts.map_enumerated(|i, tt| {\n+                        let mut tt = tt.clone();\n                         let mut sp = rhs_spans[i];\n                         sp = sp.with_ctxt(tt.span().ctxt());\n                         tt.set_span(sp);"}, {"sha": "d111ce7abb4c0f00dfcf32ad7aaff03ef0d520ae", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -210,6 +210,11 @@ declare_features! (\n     /// it is not on path for eventual stabilization).\n     (active, no_niche, \"1.42.0\", None, None),\n \n+    /// Allows using `#[rustc_allow_const_fn_unstable]`.\n+    /// This is an attribute on `const fn` for the same\n+    /// purpose as `#[allow_internal_unstable]`.\n+    (active, rustc_allow_const_fn_unstable, \"1.49.0\", Some(69399), None),\n+\n     // no-tracking-issue-end\n \n     // -------------------------------------------------------------------------\n@@ -598,6 +603,9 @@ declare_features! (\n     /// Allows `#[instruction_set(_)]` attribute\n     (active, isa_attribute, \"1.48.0\", Some(74727), None),\n \n+    /// Allow anonymous constants from an inline `const` block\n+    (active, inline_const, \"1.49.0\", Some(76001), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------\n@@ -618,6 +626,8 @@ pub const INCOMPLETE_FEATURES: &[Symbol] = &[\n     sym::const_trait_bound_opt_out,\n     sym::lazy_normalization_consts,\n     sym::specialization,\n+    sym::inline_const,\n+    sym::repr128,\n ];\n \n /// Some features are not allowed to be used together at the same time, if"}, {"sha": "f73363cbccc25808e91f19c42c76118002277ae5", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -379,6 +379,10 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n         allow_internal_unstable, AssumedUsed, template!(Word, List: \"feat1, feat2, ...\"),\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n     ),\n+    gated!(\n+        rustc_allow_const_fn_unstable, AssumedUsed, template!(Word, List: \"feat1, feat2, ...\"),\n+        \"rustc_allow_const_fn_unstable side-steps feature gating and stability checks\"\n+    ),\n     gated!(\n         allow_internal_unsafe, Normal, template!(Word),\n         \"allow_internal_unsafe side-steps the unsafe_code lint\",\n@@ -598,7 +602,7 @@ pub fn is_builtin_attr_name(name: Symbol) -> bool {\n     BUILTIN_ATTRIBUTE_MAP.get(&name).is_some()\n }\n \n-pub static BUILTIN_ATTRIBUTE_MAP: SyncLazy<FxHashMap<Symbol, &'static BuiltinAttribute>> =\n+pub static BUILTIN_ATTRIBUTE_MAP: SyncLazy<FxHashMap<Symbol, &BuiltinAttribute>> =\n     SyncLazy::new(|| {\n         let mut map = FxHashMap::default();\n         for attr in BUILTIN_ATTRIBUTES.iter() {"}, {"sha": "fc15bb324c1d881fa77c7b074932c82eb8109531", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -486,6 +486,8 @@ impl Generics<'hir> {\n #[derive(HashStable_Generic)]\n pub enum SyntheticTyParamKind {\n     ImplTrait,\n+    // Created by the `#[rustc_synthetic]` attribute.\n+    FromAttr,\n }\n \n /// A where-clause in a definition.\n@@ -1099,11 +1101,11 @@ pub enum StmtKind<'hir> {\n     Semi(&'hir Expr<'hir>),\n }\n \n-impl StmtKind<'hir> {\n-    pub fn attrs(&self) -> &'hir [Attribute] {\n+impl<'hir> StmtKind<'hir> {\n+    pub fn attrs(&self, get_item: impl FnOnce(ItemId) -> &'hir Item<'hir>) -> &'hir [Attribute] {\n         match *self {\n             StmtKind::Local(ref l) => &l.attrs,\n-            StmtKind::Item(_) => &[],\n+            StmtKind::Item(ref item_id) => &get_item(*item_id).attrs,\n             StmtKind::Expr(ref e) | StmtKind::Semi(ref e) => &e.attrs,\n         }\n     }\n@@ -1361,6 +1363,7 @@ impl Expr<'_> {\n     pub fn precedence(&self) -> ExprPrecedence {\n         match self.kind {\n             ExprKind::Box(_) => ExprPrecedence::Box,\n+            ExprKind::ConstBlock(_) => ExprPrecedence::ConstBlock,\n             ExprKind::Array(_) => ExprPrecedence::Array,\n             ExprKind::Call(..) => ExprPrecedence::Call,\n             ExprKind::MethodCall(..) => ExprPrecedence::MethodCall,\n@@ -1446,6 +1449,7 @@ impl Expr<'_> {\n             | ExprKind::LlvmInlineAsm(..)\n             | ExprKind::AssignOp(..)\n             | ExprKind::Lit(_)\n+            | ExprKind::ConstBlock(..)\n             | ExprKind::Unary(..)\n             | ExprKind::Box(..)\n             | ExprKind::AddrOf(..)\n@@ -1501,6 +1505,8 @@ pub fn is_range_literal(expr: &Expr<'_>) -> bool {\n pub enum ExprKind<'hir> {\n     /// A `box x` expression.\n     Box(&'hir Expr<'hir>),\n+    /// Allow anonymous constants from an inline `const` block\n+    ConstBlock(AnonConst),\n     /// An array (e.g., `[a, b, c, d]`).\n     Array(&'hir [Expr<'hir>]),\n     /// A function call.\n@@ -2377,15 +2383,6 @@ impl VisibilityKind<'_> {\n             VisibilityKind::Crate(..) | VisibilityKind::Restricted { .. } => true,\n         }\n     }\n-\n-    pub fn descr(&self) -> &'static str {\n-        match *self {\n-            VisibilityKind::Public => \"public\",\n-            VisibilityKind::Inherited => \"private\",\n-            VisibilityKind::Crate(..) => \"crate-visible\",\n-            VisibilityKind::Restricted { .. } => \"restricted\",\n-        }\n-    }\n }\n \n #[derive(Debug, HashStable_Generic)]"}, {"sha": "35615af0fc7dfeb3153b532cfa097c1747738360", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1068,6 +1068,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr<'v>)\n         ExprKind::Array(subexpressions) => {\n             walk_list!(visitor, visit_expr, subexpressions);\n         }\n+        ExprKind::ConstBlock(ref anon_const) => visitor.visit_anon_const(anon_const),\n         ExprKind::Repeat(ref element, ref count) => {\n             visitor.visit_expr(element);\n             visitor.visit_anon_const(count)"}, {"sha": "3e4eb9eafd7f99a0a9124e8d43d65d8b740b27a0", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -263,6 +263,7 @@ language_item_table! {\n     // is required to define it somewhere. Additionally, there are restrictions on crates that use\n     // a weak lang item, but do not have it defined.\n     Panic,                   sym::panic,               panic_fn,                   Target::Fn;\n+    PanicStr,                sym::panic_str,           panic_str,                  Target::Fn;\n     PanicBoundsCheck,        sym::panic_bounds_check,  panic_bounds_check_fn,      Target::Fn;\n     PanicInfo,               sym::panic_info,          panic_info,                 Target::Struct;\n     PanicLocation,           sym::panic_location,      panic_location,             Target::Struct;"}, {"sha": "1cd4ddad5783a528e5d9e18bff2de66ef7f79588", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1135,6 +1135,13 @@ impl<'a> State<'a> {\n         self.end()\n     }\n \n+    fn print_expr_anon_const(&mut self, anon_const: &hir::AnonConst) {\n+        self.ibox(INDENT_UNIT);\n+        self.s.word_space(\"const\");\n+        self.print_anon_const(anon_const);\n+        self.end()\n+    }\n+\n     fn print_expr_repeat(&mut self, element: &hir::Expr<'_>, count: &hir::AnonConst) {\n         self.ibox(INDENT_UNIT);\n         self.s.word(\"[\");\n@@ -1287,6 +1294,9 @@ impl<'a> State<'a> {\n             hir::ExprKind::Array(ref exprs) => {\n                 self.print_expr_vec(exprs);\n             }\n+            hir::ExprKind::ConstBlock(ref anon_const) => {\n+                self.print_expr_anon_const(anon_const);\n+            }\n             hir::ExprKind::Repeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, count);\n             }"}, {"sha": "3a0ec6327c18643297e2e4978e6e0ea513f397d3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -619,6 +619,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 scrut_hir_id,\n                 opt_suggest_box_span,\n                 arm_span,\n+                scrut_span,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n@@ -664,18 +665,29 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n                         _ => last_ty,\n                     });\n-                    let msg = \"`match` arms have incompatible types\";\n-                    err.span_label(cause.span, msg);\n+                    let source_map = self.tcx.sess.source_map();\n+                    let mut any_multiline_arm = source_map.is_multiline(arm_span);\n                     if prior_arms.len() <= 4 {\n                         for sp in prior_arms {\n+                            any_multiline_arm |= source_map.is_multiline(*sp);\n                             err.span_label(*sp, format!(\"this is found to be of type `{}`\", t));\n                         }\n                     } else if let Some(sp) = prior_arms.last() {\n+                        any_multiline_arm |= source_map.is_multiline(*sp);\n                         err.span_label(\n                             *sp,\n                             format!(\"this and all prior arms are found to be of type `{}`\", t),\n                         );\n                     }\n+                    let outer_error_span = if any_multiline_arm {\n+                        // Cover just `match` and the scrutinee expression, not\n+                        // the entire match body, to reduce diagram noise.\n+                        cause.span.shrink_to_lo().to(scrut_span)\n+                    } else {\n+                        cause.span\n+                    };\n+                    let msg = \"`match` arms have incompatible types\";\n+                    err.span_label(outer_error_span, msg);\n                     if let Some(sp) = semi_span {\n                         err.span_suggestion_short(\n                             sp,"}, {"sha": "21023a06bb2d90a7e3932d1a24738d215db63d42", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -91,17 +91,6 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n         if let (None, Some(ty)) =\n             (self.found_local_pattern, self.node_ty_contains_target(local.hir_id))\n         {\n-            // FIXME: There's a trade-off here - we can either check that our target span\n-            // is contained in `local.span` or not. If we choose to check containment\n-            // we can avoid some spurious suggestions (see #72690), but we lose\n-            // the ability to report on things like:\n-            //\n-            // ```\n-            // let x = vec![];\n-            // ```\n-            //\n-            // because the target span will be in the macro expansion of `vec![]`.\n-            // At present we choose not to check containment.\n             self.found_local_pattern = Some(&*local.pat);\n             self.found_node_ty = Some(ty);\n         }\n@@ -113,10 +102,8 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n             if let (None, Some(ty)) =\n                 (self.found_arg_pattern, self.node_ty_contains_target(param.hir_id))\n             {\n-                if self.target_span.contains(param.pat.span) {\n-                    self.found_arg_pattern = Some(&*param.pat);\n-                    self.found_node_ty = Some(ty);\n-                }\n+                self.found_arg_pattern = Some(&*param.pat);\n+                self.found_node_ty = Some(ty);\n             }\n         }\n         intravisit::walk_body(self, body);"}, {"sha": "32f73237dd410411d3b51dd8c437928af1cfdfe2", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -157,7 +157,7 @@ impl<'tcx> FreeRegionRelations<'tcx> for FreeRegionMap<'tcx> {\n \n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| tcx.lift(&fr)).map(|relation| FreeRegionMap { relation })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+        self.relation.maybe_map(|&fr| tcx.lift(fr)).map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "abdd6edea90249454287e11193774404a3967fc3", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -636,7 +636,7 @@ where\n         if let (Some(a), Some(b)) = (a.no_bound_vars(), b.no_bound_vars()) {\n             // Fast path for the common case.\n             self.relate(a, b)?;\n-            return Ok(ty::Binder::bind(a));\n+            return Ok(ty::Binder::dummy(a));\n         }\n \n         if self.ambient_covariance() {"}, {"sha": "835f75ec8ef06e3e68caad708ba542863783678b", "filename": "compiler/rustc_infer/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -2,12 +2,12 @@ use super::ObjectSafetyViolation;\n \n use crate::infer::InferCtxt;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n+use rustc_errors::{struct_span_err, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n-use rustc_span::Span;\n+use rustc_span::{MultiSpan, Span};\n use std::fmt;\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -54,10 +54,11 @@ pub fn report_object_safety_error(\n         \"the trait `{}` cannot be made into an object\",\n         trait_str\n     );\n-    err.span_label(span, format!(\"the trait `{}` cannot be made into an object\", trait_str));\n+    err.span_label(span, format!(\"`{}` cannot be made into an object\", trait_str));\n \n     let mut reported_violations = FxHashSet::default();\n-    let mut had_span_label = false;\n+    let mut multi_span = vec![];\n+    let mut messages = vec![];\n     for violation in violations {\n         if let ObjectSafetyViolation::SizedSelf(sp) = &violation {\n             if !sp.is_empty() {\n@@ -71,31 +72,37 @@ pub fn report_object_safety_error(\n             let msg = if trait_span.is_none() || spans.is_empty() {\n                 format!(\"the trait cannot be made into an object because {}\", violation.error_msg())\n             } else {\n-                had_span_label = true;\n                 format!(\"...because {}\", violation.error_msg())\n             };\n             if spans.is_empty() {\n                 err.note(&msg);\n             } else {\n                 for span in spans {\n-                    err.span_label(span, &msg);\n+                    multi_span.push(span);\n+                    messages.push(msg.clone());\n                 }\n             }\n-            match (trait_span, violation.solution()) {\n-                (Some(_), Some((note, None))) => {\n-                    err.help(&note);\n-                }\n-                (Some(_), Some((note, Some((sugg, span))))) => {\n-                    err.span_suggestion(span, &note, sugg, Applicability::MachineApplicable);\n-                }\n+            if trait_span.is_some() {\n                 // Only provide the help if its a local trait, otherwise it's not actionable.\n-                _ => {}\n+                violation.solution(&mut err);\n             }\n         }\n     }\n-    if let (Some(trait_span), true) = (trait_span, had_span_label) {\n-        err.span_label(trait_span, \"this trait cannot be made into an object...\");\n+    let has_multi_span = !multi_span.is_empty();\n+    let mut note_span = MultiSpan::from_spans(multi_span.clone());\n+    if let (Some(trait_span), true) = (trait_span, has_multi_span) {\n+        note_span\n+            .push_span_label(trait_span, \"this trait cannot be made into an object...\".to_string());\n     }\n+    for (span, msg) in multi_span.into_iter().zip(messages.into_iter()) {\n+        note_span.push_span_label(span, msg);\n+    }\n+    err.span_note(\n+        note_span,\n+        \"for a trait to be \\\"object safe\\\" it needs to allow building a vtable to allow the call \\\n+         to be resolvable dynamically; for more information visit \\\n+         <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\",\n+    );\n \n     if tcx.sess.trait_methods_not_found.borrow().contains(&span) {\n         // Avoid emitting error caused by non-existing method (#58734)"}, {"sha": "f6ef98407887eb42150360f9cc419a72ae22df45", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -126,14 +126,15 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        match obligation.predicate.skip_binders() {\n+        let bound_predicate = obligation.predicate.bound_atom();\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n                 let obligations = predicates.predicates.iter().map(|&(pred, _)| {\n                     predicate_obligation(\n-                        pred.subst_supertrait(tcx, &ty::Binder::bind(data.trait_ref)),\n+                        pred.subst_supertrait(tcx, &bound_predicate.rebind(data.trait_ref)),\n                         obligation.param_env,\n                         obligation.cause.clone(),\n                     )"}, {"sha": "bbb47a6e8071e70e15714151c9437b9b1cb889cd", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 70, "deletions": 2, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -2,8 +2,9 @@ use crate::interface::{Compiler, Result};\n use crate::proc_macro_decls;\n use crate::util;\n \n-use rustc_ast::mut_visit::MutVisitor;\n-use rustc_ast::{self as ast, visit};\n+use rustc_ast::mut_visit::{self, MutVisitor};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{self as ast, token, visit};\n use rustc_codegen_ssa::back::link::emit_metadata;\n use rustc_codegen_ssa::traits::CodegenBackend;\n use rustc_data_structures::sync::{par_iter, Lrc, OnceCell, ParallelIterator, WorkerLocal};\n@@ -36,6 +37,7 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{FileName, RealFileName};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n+use smallvec::SmallVec;\n use tracing::{info, warn};\n \n use rustc_serialize::json;\n@@ -50,6 +52,64 @@ use std::path::PathBuf;\n use std::rc::Rc;\n use std::{env, fs, iter, mem};\n \n+/// Remove alls `LazyTokenStreams` from an AST struct\n+/// Normally, this is done during AST lowering. However,\n+/// printing the AST JSON requires us to serialize\n+/// the entire AST, and we don't want to serialize\n+/// a `LazyTokenStream`.\n+struct TokenStripper;\n+impl mut_visit::MutVisitor for TokenStripper {\n+    fn flat_map_item(&mut self, mut i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n+        i.tokens = None;\n+        mut_visit::noop_flat_map_item(i, self)\n+    }\n+    fn visit_block(&mut self, b: &mut P<ast::Block>) {\n+        b.tokens = None;\n+        mut_visit::noop_visit_block(b, self);\n+    }\n+    fn flat_map_stmt(&mut self, mut stmt: ast::Stmt) -> SmallVec<[ast::Stmt; 1]> {\n+        stmt.tokens = None;\n+        mut_visit::noop_flat_map_stmt(stmt, self)\n+    }\n+    fn visit_pat(&mut self, p: &mut P<ast::Pat>) {\n+        p.tokens = None;\n+        mut_visit::noop_visit_pat(p, self);\n+    }\n+    fn visit_ty(&mut self, ty: &mut P<ast::Ty>) {\n+        ty.tokens = None;\n+        mut_visit::noop_visit_ty(ty, self);\n+    }\n+    fn visit_attribute(&mut self, attr: &mut ast::Attribute) {\n+        attr.tokens = None;\n+        if let ast::AttrKind::Normal(ast::AttrItem { tokens, .. }) = &mut attr.kind {\n+            *tokens = None;\n+        }\n+        mut_visit::noop_visit_attribute(attr, self);\n+    }\n+\n+    fn visit_interpolated(&mut self, nt: &mut token::Nonterminal) {\n+        if let token::Nonterminal::NtMeta(meta) = nt {\n+            meta.tokens = None;\n+        }\n+        // Handles all of the other cases\n+        mut_visit::noop_visit_interpolated(nt, self);\n+    }\n+\n+    fn visit_path(&mut self, p: &mut ast::Path) {\n+        p.tokens = None;\n+        mut_visit::noop_visit_path(p, self);\n+    }\n+    fn visit_vis(&mut self, vis: &mut ast::Visibility) {\n+        vis.tokens = None;\n+        mut_visit::noop_visit_vis(vis, self);\n+    }\n+    fn visit_expr(&mut self, e: &mut P<ast::Expr>) {\n+        e.tokens = None;\n+        mut_visit::noop_visit_expr(e, self);\n+    }\n+    fn visit_mac(&mut self, _mac: &mut ast::MacCall) {}\n+}\n+\n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     let krate = sess.time(\"parse_crate\", || match input {\n         Input::File(file) => parse_crate_from_file(file, &sess.parse_sess),\n@@ -59,6 +119,10 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     })?;\n \n     if sess.opts.debugging_opts.ast_json_noexpand {\n+        // Set any `token` fields to `None` before\n+        // we display the AST.\n+        let mut krate = krate.clone();\n+        TokenStripper.visit_crate(&mut krate);\n         println!(\"{}\", json::as_json(&krate));\n     }\n \n@@ -379,6 +443,10 @@ fn configure_and_expand_inner<'a>(\n     }\n \n     if sess.opts.debugging_opts.ast_json {\n+        // Set any `token` fields to `None` before\n+        // we display the AST.\n+        let mut krate = krate.clone();\n+        TokenStripper.visit_crate(&mut krate);\n         println!(\"{}\", json::as_json(&krate));\n     }\n "}, {"sha": "e5f66611d0f9b382471319ce3776c6d8b90e5b47", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -968,7 +968,7 @@ fn warn_if_doc(cx: &EarlyContext<'_>, node_span: Span, node_kind: &str, attrs: &\n     while let Some(attr) = attrs.next() {\n         if attr.is_doc_comment() {\n             sugared_span =\n-                Some(sugared_span.map_or_else(|| attr.span, |span| span.with_hi(attr.span.hi())));\n+                Some(sugared_span.map_or(attr.span, |span| span.with_hi(attr.span.hi())));\n         }\n \n         if attrs.peek().map(|next_attr| next_attr.is_doc_comment()).unwrap_or_default() {\n@@ -994,7 +994,8 @@ impl EarlyLintPass for UnusedDocComment {\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &ast::Stmt) {\n         let kind = match stmt.kind {\n             ast::StmtKind::Local(..) => \"statements\",\n-            ast::StmtKind::Item(..) => \"inner items\",\n+            // Disabled pending discussion in #78306\n+            ast::StmtKind::Item(..) => return,\n             // expressions will be reported by `check_expr`.\n             ast::StmtKind::Empty\n             | ast::StmtKind::Semi(_)\n@@ -2288,12 +2289,20 @@ impl EarlyLintPass for IncompleteFeatures {\n                             n, n,\n                         ));\n                     }\n+                    if HAS_MIN_FEATURES.contains(&name) {\n+                        builder.help(&format!(\n+                            \"consider using `min_{}` instead, which is more stable and complete\",\n+                            name,\n+                        ));\n+                    }\n                     builder.emit();\n                 })\n             });\n     }\n }\n \n+const HAS_MIN_FEATURES: &[Symbol] = &[sym::const_generics, sym::specialization];\n+\n declare_lint! {\n     /// The `invalid_value` lint detects creating a value that is not valid,\n     /// such as a NULL reference."}, {"sha": "9aeeb6277924ec12ce2b3c68a5737233093accfc", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -18,6 +18,7 @@ use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast as ast;\n use rustc_ast::visit as ast_visit;\n+use rustc_attr::HasAttrs;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;\n@@ -119,8 +120,22 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n-        run_early_pass!(self, check_stmt, s);\n-        self.check_id(s.id);\n+        // Add the statement's lint attributes to our\n+        // current state when checking the statement itself.\n+        // This allows us to handle attributes like\n+        // `#[allow(unused_doc_comments)]`, which apply to\n+        // sibling attributes on the same target\n+        //\n+        // Note that statements get their attributes from\n+        // the AST struct that they wrap (e.g. an item)\n+        self.with_lint_attrs(s.id, s.attrs(), |cx| {\n+            run_early_pass!(cx, check_stmt, s);\n+            cx.check_id(s.id);\n+        });\n+        // The visitor for the AST struct wrapped\n+        // by the statement (e.g. `Item`) will call\n+        // `with_lint_attrs`, so do this walk\n+        // outside of the above `with_lint_attrs` call\n         ast_visit::walk_stmt(self, s);\n     }\n \n@@ -195,6 +210,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_expr_post, e);\n     }\n \n+    fn visit_generic_arg(&mut self, arg: &'a ast::GenericArg) {\n+        run_early_pass!(self, check_generic_arg, arg);\n+        ast_visit::walk_generic_arg(self, arg);\n+    }\n+\n     fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n         run_early_pass!(self, check_generic_param, param);\n         ast_visit::walk_generic_param(self, param);"}, {"sha": "015e10987118296d7094272459059efe9eb1b3bb", "filename": "compiler/rustc_lint/src/late.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flate.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -174,12 +174,13 @@ impl<'tcx, T: LateLintPass<'tcx>> hir_visit::Visitor<'tcx> for LateContextAndPas\n     }\n \n     fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        // statement attributes are actually just attributes on one of\n-        // - item\n-        // - local\n-        // - expression\n-        // so we keep track of lint levels there\n-        lint_callback!(self, check_stmt, s);\n+        let get_item = |id: hir::ItemId| self.context.tcx.hir().item(id.id);\n+        let attrs = &s.kind.attrs(get_item);\n+        // See `EarlyContextAndPass::visit_stmt` for an explanation\n+        // of why we call `walk_stmt` outside of `with_lint_attrs`\n+        self.with_lint_attrs(s.hir_id, attrs, |cx| {\n+            lint_callback!(cx, check_stmt, s);\n+        });\n         hir_visit::walk_stmt(self, s);\n     }\n "}, {"sha": "f36f598ade2def1c0e1d557cbf52853616c22d06", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -562,6 +562,13 @@ impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n         })\n     }\n \n+    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n+        // We will call `with_lint_attrs` when we walk\n+        // the `StmtKind`. The outer statement itself doesn't\n+        // define the lint levels.\n+        intravisit::walk_stmt(self, e);\n+    }\n+\n     fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n         self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n             intravisit::walk_expr(builder, e);"}, {"sha": "828f283d2a95a71f7f5d7686d95a5072410c075e", "filename": "compiler/rustc_lint/src/passes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpasses.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -33,6 +33,7 @@ macro_rules! late_lint_methods {\n             fn check_expr(a: &$hir hir::Expr<$hir>);\n             fn check_expr_post(a: &$hir hir::Expr<$hir>);\n             fn check_ty(a: &$hir hir::Ty<$hir>);\n+            fn check_generic_arg(a: &$hir hir::GenericArg<$hir>);\n             fn check_generic_param(a: &$hir hir::GenericParam<$hir>);\n             fn check_generics(a: &$hir hir::Generics<$hir>);\n             fn check_where_predicate(a: &$hir hir::WherePredicate<$hir>);\n@@ -176,6 +177,7 @@ macro_rules! early_lint_methods {\n             fn check_expr(a: &ast::Expr);\n             fn check_expr_post(a: &ast::Expr);\n             fn check_ty(a: &ast::Ty);\n+            fn check_generic_arg(a: &ast::GenericArg);\n             fn check_generic_param(a: &ast::GenericParam);\n             fn check_generics(a: &ast::Generics);\n             fn check_where_predicate(a: &ast::WherePredicate);"}, {"sha": "b502bd7f7a1bd07248f77fecb05b3786aede8ce3", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -145,9 +145,9 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     // We need to preserve the literal's suffix,\n                     // as it may determine typing information.\n                     let suffix = match lit.node {\n-                        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str().to_string(),\n-                        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str().to_string(),\n-                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\".to_string(),\n+                        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n                         _ => bug!(),\n                     };\n                     let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n@@ -170,24 +170,25 @@ fn lint_overflowing_range_endpoint<'tcx>(\n // warnings are consistent between 32- and 64-bit platforms.\n fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n     match int_ty {\n-        ast::IntTy::Isize => (i64::MIN as i128, i64::MAX as i128),\n-        ast::IntTy::I8 => (i8::MIN as i64 as i128, i8::MAX as i128),\n-        ast::IntTy::I16 => (i16::MIN as i64 as i128, i16::MAX as i128),\n-        ast::IntTy::I32 => (i32::MIN as i64 as i128, i32::MAX as i128),\n-        ast::IntTy::I64 => (i64::MIN as i128, i64::MAX as i128),\n-        ast::IntTy::I128 => (i128::MIN as i128, i128::MAX),\n+        ast::IntTy::Isize => (i64::MIN.into(), i64::MAX.into()),\n+        ast::IntTy::I8 => (i8::MIN.into(), i8::MAX.into()),\n+        ast::IntTy::I16 => (i16::MIN.into(), i16::MAX.into()),\n+        ast::IntTy::I32 => (i32::MIN.into(), i32::MAX.into()),\n+        ast::IntTy::I64 => (i64::MIN.into(), i64::MAX.into()),\n+        ast::IntTy::I128 => (i128::MIN, i128::MAX),\n     }\n }\n \n fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n-    match uint_ty {\n-        ast::UintTy::Usize => (u64::MIN as u128, u64::MAX as u128),\n-        ast::UintTy::U8 => (u8::MIN as u128, u8::MAX as u128),\n-        ast::UintTy::U16 => (u16::MIN as u128, u16::MAX as u128),\n-        ast::UintTy::U32 => (u32::MIN as u128, u32::MAX as u128),\n-        ast::UintTy::U64 => (u64::MIN as u128, u64::MAX as u128),\n-        ast::UintTy::U128 => (u128::MIN, u128::MAX),\n-    }\n+    let max = match uint_ty {\n+        ast::UintTy::Usize => u64::MAX.into(),\n+        ast::UintTy::U8 => u8::MAX.into(),\n+        ast::UintTy::U16 => u16::MAX.into(),\n+        ast::UintTy::U32 => u32::MAX.into(),\n+        ast::UintTy::U64 => u64::MAX.into(),\n+        ast::UintTy::U128 => u128::MAX,\n+    };\n+    (0, max)\n }\n \n fn get_bin_hex_repr(cx: &LateContext<'_>, lit: &hir::Lit) -> Option<String> {"}, {"sha": "2409069031d9347fcdef4fe4768af20c64659be4", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -751,13 +751,20 @@ impl UnusedDelimLint for UnusedParens {\n                 if !Self::is_expr_delims_necessary(inner, followed_by_block)\n                     && value.attrs.is_empty()\n                     && !value.span.from_expansion()\n+                    && (ctx != UnusedDelimsCtx::LetScrutineeExpr\n+                        || match inner.kind {\n+                            ast::ExprKind::Binary(\n+                                rustc_span::source_map::Spanned { node, .. },\n+                                _,\n+                                _,\n+                            ) if node.lazy() => false,\n+                            _ => true,\n+                        })\n                 {\n                     self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n                 }\n             }\n             ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n                 self.check_unused_delims_expr(\n                     cx,\n                     expr,\n@@ -839,10 +846,6 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n-        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n-    }\n-\n     fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let StmtKind::Local(ref local) = s.kind {\n             self.check_unused_parens_pat(cx, &local.pat, false, false);\n@@ -965,13 +968,6 @@ impl UnusedDelimLint for UnusedBraces {\n                         if !Self::is_expr_delims_necessary(expr, followed_by_block)\n                             && (ctx != UnusedDelimsCtx::AnonConst\n                                 || matches!(expr.kind, ast::ExprKind::Lit(_)))\n-                            // array length expressions are checked during `check_anon_const` and `check_ty`,\n-                            // once as `ArrayLenExpr` and once as `AnonConst`.\n-                            //\n-                            // As we do not want to lint this twice, we do not emit an error for\n-                            // `ArrayLenExpr` if `AnonConst` would do the same.\n-                            && (ctx != UnusedDelimsCtx::ArrayLenExpr\n-                                || !matches!(expr.kind, ast::ExprKind::Lit(_)))\n                             && !cx.sess().source_map().is_multiline(value.span)\n                             && value.attrs.is_empty()\n                             && !value.span.from_expansion()\n@@ -999,21 +995,54 @@ impl UnusedDelimLint for UnusedBraces {\n }\n \n impl EarlyLintPass for UnusedBraces {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    }\n+\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n-        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e);\n+\n+        if let ExprKind::Repeat(_, ref anon_const) = e.kind {\n+            self.check_unused_delims_expr(\n+                cx,\n+                &anon_const.value,\n+                UnusedDelimsCtx::AnonConst,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n     }\n \n-    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n-        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    fn check_generic_arg(&mut self, cx: &EarlyContext<'_>, arg: &ast::GenericArg) {\n+        if let ast::GenericArg::Const(ct) = arg {\n+            self.check_unused_delims_expr(\n+                cx,\n+                &ct.value,\n+                UnusedDelimsCtx::AnonConst,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant) {\n+        if let Some(anon_const) = &v.disr_expr {\n+            self.check_unused_delims_expr(\n+                cx,\n+                &anon_const.value,\n+                UnusedDelimsCtx::AnonConst,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n     }\n \n     fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n-        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n-            if let ast::TyKind::Array(_, ref len) = r.kind {\n+        match ty.kind {\n+            ast::TyKind::Array(_, ref len) => {\n                 self.check_unused_delims_expr(\n                     cx,\n                     &len.value,\n@@ -1023,6 +1052,19 @@ impl EarlyLintPass for UnusedBraces {\n                     None,\n                 );\n             }\n+\n+            ast::TyKind::Typeof(ref anon_const) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &anon_const.value,\n+                    UnusedDelimsCtx::AnonConst,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+\n+            _ => {}\n         }\n     }\n "}, {"sha": "ad7ac74041749075dcf8b118dc2715a936dd82e4", "filename": "compiler/rustc_macros/src/lift.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_macros%2Fsrc%2Flift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_macros%2Fsrc%2Flift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flift.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -3,6 +3,7 @@ use syn::{self, parse_quote};\n \n pub fn lift_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStream {\n     s.add_bounds(synstructure::AddBounds::Generics);\n+    s.bind_with(|_| synstructure::BindStyle::Move);\n \n     let tcx: syn::Lifetime = parse_quote!('tcx);\n     let newtcx: syn::GenericParam = parse_quote!('__lifted);\n@@ -43,8 +44,8 @@ pub fn lift_derive(mut s: synstructure::Structure<'_>) -> proc_macro2::TokenStre\n         quote! {\n             type Lifted = #lifted;\n \n-            fn lift_to_tcx(&self, __tcx: ::rustc_middle::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n-                Some(match *self { #body })\n+            fn lift_to_tcx(self, __tcx: ::rustc_middle::ty::TyCtxt<'__lifted>) -> Option<#lifted> {\n+                Some(match self { #body })\n             }\n         },\n     )"}, {"sha": "fd85919636949ac89760c4b4270b6b94449e613a", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 6, "deletions": 66, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -190,7 +190,11 @@ impl<T: Parse> Parse for List<T> {\n }\n \n /// A named group containing queries.\n+///\n+/// For now, the name is not used any more, but the capability remains interesting for future\n+/// developments of the query system.\n struct Group {\n+    #[allow(unused)]\n     name: Ident,\n     queries: List<Query>,\n }\n@@ -417,12 +421,9 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n-    let mut dep_node_force_stream = quote! {};\n-    let mut try_load_from_on_disk_cache_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n     for group in groups.0 {\n-        let mut group_stream = quote! {};\n         for mut query in group.queries.0 {\n             let modifiers = process_modifiers(&mut query);\n             let name = &query.name;\n@@ -437,22 +438,6 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 cached_queries.extend(quote! {\n                     #name,\n                 });\n-\n-                try_load_from_on_disk_cache_stream.extend(quote! {\n-                    ::rustc_middle::dep_graph::DepKind::#name => {\n-                        if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n-                            debug_assert!($tcx.dep_graph\n-                                            .node_color($dep_node)\n-                                            .map(|c| c.is_green())\n-                                            .unwrap_or(false));\n-\n-                            let key = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node).unwrap();\n-                            if queries::#name::cache_on_disk($tcx, &key, None) {\n-                                let _ = $tcx.#name(key);\n-                            }\n-                        }\n-                    }\n-                });\n             }\n \n             let mut attributes = Vec::new();\n@@ -485,47 +470,20 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n             let attribute_stream = quote! {#(#attributes),*};\n             let doc_comments = query.doc_comments.iter();\n             // Add the query to the group\n-            group_stream.extend(quote! {\n+            query_stream.extend(quote! {\n                 #(#doc_comments)*\n-                [#attribute_stream] fn #name: #name(#arg) #result,\n+                [#attribute_stream] fn #name(#arg) #result,\n             });\n \n             // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {\n                 [#attribute_stream] #name(#arg),\n             });\n \n-            // Add a match arm to force the query given the dep node\n-            dep_node_force_stream.extend(quote! {\n-                ::rustc_middle::dep_graph::DepKind::#name => {\n-                    if <#arg as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n-                        if let Some(key) = <#arg as DepNodeParams<TyCtxt<'_>>>::recover($tcx, $dep_node) {\n-                            force_query::<crate::ty::query::queries::#name<'_>, _>(\n-                                $tcx,\n-                                key,\n-                                DUMMY_SP,\n-                                *$dep_node\n-                            );\n-                            return true;\n-                        }\n-                    }\n-                }\n-            });\n-\n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n-        let name = &group.name;\n-        query_stream.extend(quote! {\n-            #name { #group_stream },\n-        });\n     }\n \n-    dep_node_force_stream.extend(quote! {\n-        ::rustc_middle::dep_graph::DepKind::Null => {\n-            bug!(\"Cannot force dep node: {:?}\", $dep_node)\n-        }\n-    });\n-\n     TokenStream::from(quote! {\n         macro_rules! rustc_query_append {\n             ([$($macro:tt)*][$($other:tt)*]) => {\n@@ -546,30 +504,12 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 );\n             }\n         }\n-        macro_rules! rustc_dep_node_force {\n-            ([$dep_node:expr, $tcx:expr] $($other:tt)*) => {\n-                match $dep_node.kind {\n-                    $($other)*\n-\n-                    #dep_node_force_stream\n-                }\n-            }\n-        }\n         macro_rules! rustc_cached_queries {\n             ($($macro:tt)*) => {\n                 $($macro)*(#cached_queries);\n             }\n         }\n \n         #query_description_stream\n-\n-        macro_rules! rustc_dep_node_try_load_from_on_disk_cache {\n-            ($dep_node:expr, $tcx:expr) => {\n-                match $dep_node.kind {\n-                    #try_load_from_on_disk_cache_stream\n-                    _ => (),\n-                }\n-            }\n-        }\n     })\n }"}, {"sha": "68faf9c7a629d98b9f5a6907c11b994513ac0616", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -8,6 +8,7 @@ use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_hir as hir;\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::hir::exports::Export;\n@@ -487,6 +488,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(def.krate).def_key(def.index)\n     }\n \n+    fn def_kind(&self, def: DefId) -> DefKind {\n+        self.get_crate_data(def.krate).def_kind(def.index)\n+    }\n+\n     fn def_path(&self, def: DefId) -> DefPath {\n         self.get_crate_data(def.krate).def_path(def.index)\n     }"}, {"sha": "7e33a479228bac820441c093e9a70b480a8906fc", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -28,7 +28,6 @@ use rustc_middle::ty::{self, SymbolName, Ty, TyCtxt};\n use rustc_serialize::{opaque, Encodable, Encoder};\n use rustc_session::config::CrateType;\n use rustc_span::hygiene::{ExpnDataEncodeMode, HygieneEncodeContext};\n-use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::{self, ExternalSource, FileName, SourceFile, Span, SyntaxContext};\n use rustc_target::abi::VariantIdx;\n@@ -436,8 +435,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_items(&mut self) {\n         let krate = self.tcx.hir().krate();\n-        let vis = Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Public };\n-        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs, &vis);\n+        self.encode_info_for_mod(hir::CRATE_HIR_ID, &krate.item.module, &krate.item.attrs);\n \n         // Proc-macro crates only export proc-macro items, which are looked\n         // up using `proc_macro_data`\n@@ -739,12 +737,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n-        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(enum_vis, enum_id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- &self.tcx.get_attrs(def_id)[..]);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -785,17 +779,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        // Variant constructors have the same visibility as the parent enums, unless marked as\n-        // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n-        let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n-        let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n-        if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         self.encode_stability(def_id);\n         self.encode_deprecation(def_id);\n@@ -811,13 +796,7 @@ impl EncodeContext<'a, 'tcx> {\n         self.encode_promoted_mir(def_id.expect_local());\n     }\n \n-    fn encode_info_for_mod(\n-        &mut self,\n-        id: hir::HirId,\n-        md: &hir::Mod<'_>,\n-        attrs: &[ast::Attribute],\n-        vis: &hir::Visibility<'_>,\n-    ) {\n+    fn encode_info_for_mod(&mut self, id: hir::HirId, md: &hir::Mod<'_>, attrs: &[ast::Attribute]) {\n         let tcx = self.tcx;\n         let local_def_id = tcx.hir().local_def_id(id);\n         let def_id = local_def_id.to_def_id();\n@@ -850,7 +829,7 @@ impl EncodeContext<'a, 'tcx> {\n         };\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(self.lazy(data)));\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::from_hir(vis, id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- attrs);\n         if self.is_proc_macro {\n@@ -881,7 +860,7 @@ impl EncodeContext<'a, 'tcx> {\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n-        record!(self.tables.visibility[def_id] <- field.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- variant_data.fields()[field_index].attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -906,25 +885,8 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let struct_id = tcx.hir().local_def_id_to_hir_id(adt_def.did.expect_local());\n-        let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n-        let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n-        for field in &variant.fields {\n-            if ctor_vis.is_at_least(field.vis, tcx) {\n-                ctor_vis = field.vis;\n-            }\n-        }\n-\n-        // If the structure is marked as non_exhaustive then lower the visibility\n-        // to within the crate.\n-        if adt_def.non_enum_variant().is_field_list_non_exhaustive()\n-            && ctor_vis == ty::Visibility::Public\n-        {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n-\n         record!(self.tables.kind[def_id] <- EntryKind::Struct(self.lazy(data), adt_def.repr));\n-        record!(self.tables.visibility[def_id] <- ctor_vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n         self.encode_stability(def_id);\n@@ -1030,7 +992,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::AssocType(container)\n             }\n         });\n-        record!(self.tables.visibility[def_id] <- trait_item.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, ast_item.ident);\n@@ -1112,7 +1074,7 @@ impl EncodeContext<'a, 'tcx> {\n             }\n             ty::AssocKind::Type => EntryKind::AssocType(container)\n         });\n-        record!(self.tables.visibility[def_id] <- impl_item.vis);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- ast_item.span);\n         record!(self.tables.attributes[def_id] <- ast_item.attrs);\n         self.encode_ident_span(def_id, impl_item.ident);\n@@ -1261,7 +1223,7 @@ impl EncodeContext<'a, 'tcx> {\n                 EntryKind::Fn(self.lazy(data))\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.hir_id, m, &item.attrs, &item.vis);\n+                return self.encode_info_for_mod(item.hir_id, m, &item.attrs);\n             }\n             hir::ItemKind::ForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemKind::GlobalAsm(..) => EntryKind::GlobalAsm,\n@@ -1352,8 +1314,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ItemKind::ExternCrate(_) |\n             hir::ItemKind::Use(..) => bug!(\"cannot encode info for item {:?}\", item),\n         });\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(&item.vis, item.hir_id, tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id] <- item.attrs);\n         record!(self.tables.expn_that_defined[def_id] <- self.tcx.expansion_that_defined(def_id));\n@@ -1470,7 +1431,7 @@ impl EncodeContext<'a, 'tcx> {\n     fn encode_info_for_macro_def(&mut self, macro_def: &hir::MacroDef<'_>) {\n         let def_id = self.tcx.hir().local_def_id(macro_def.hir_id).to_def_id();\n         record!(self.tables.kind[def_id] <- EntryKind::MacroDef(self.lazy(macro_def.ast.clone())));\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- macro_def.span);\n         record!(self.tables.attributes[def_id] <- macro_def.attrs);\n         self.encode_ident_span(def_id, macro_def.ident);\n@@ -1480,7 +1441,6 @@ impl EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_generic_param(&mut self, def_id: DefId, kind: EntryKind, encode_type: bool) {\n         record!(self.tables.kind[def_id] <- kind);\n-        record!(self.tables.visibility[def_id] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id] <- self.tcx.def_span(def_id));\n         if encode_type {\n             self.encode_item_type(def_id);\n@@ -1505,7 +1465,6 @@ impl EncodeContext<'a, 'tcx> {\n \n             _ => bug!(\"closure that is neither generator nor closure\"),\n         });\n-        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         record!(self.tables.attributes[def_id.to_def_id()] <- &self.tcx.get_attrs(def_id.to_def_id())[..]);\n         self.encode_item_type(def_id.to_def_id());\n@@ -1525,7 +1484,6 @@ impl EncodeContext<'a, 'tcx> {\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n \n         record!(self.tables.kind[def_id.to_def_id()] <- EntryKind::AnonConst(qualifs, const_data));\n-        record!(self.tables.visibility[def_id.to_def_id()] <- ty::Visibility::Public);\n         record!(self.tables.span[def_id.to_def_id()] <- self.tcx.def_span(def_id));\n         self.encode_item_type(def_id.to_def_id());\n         self.encode_generics(def_id.to_def_id());\n@@ -1762,8 +1720,7 @@ impl EncodeContext<'a, 'tcx> {\n             hir::ForeignItemKind::Static(_, hir::Mutability::Not) => EntryKind::ForeignImmStatic,\n             hir::ForeignItemKind::Type => EntryKind::ForeignType,\n         });\n-        record!(self.tables.visibility[def_id] <-\n-            ty::Visibility::from_hir(&nitem.vis, nitem.hir_id, self.tcx));\n+        record!(self.tables.visibility[def_id] <- self.tcx.visibility(def_id));\n         record!(self.tables.span[def_id] <- nitem.span);\n         record!(self.tables.attributes[def_id] <- nitem.attrs);\n         self.encode_ident_span(def_id, nitem.ident);"}, {"sha": "66532ea02f3681fa08db3fe6276b954b7866fa54", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -28,5 +28,5 @@ rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n chalk-ir = \"0.32.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n-measureme = \"0.7.1\"\n+measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "516c9b6752b97afa46636b3fffe66a6896880c56", "filename": "compiler/rustc_middle/src/hir/map/collector.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fcollector.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -360,8 +360,26 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'hir GenericParam<'hir>) {\n-        self.insert(param.span, param.hir_id, Node::GenericParam(param));\n-        intravisit::walk_generic_param(self, param);\n+        if let hir::GenericParamKind::Type {\n+            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+            ..\n+        } = param.kind\n+        {\n+            debug_assert_eq!(\n+                param.hir_id.owner,\n+                self.definitions.opt_hir_id_to_local_def_id(param.hir_id).unwrap()\n+            );\n+            self.with_dep_node_owner(param.hir_id.owner, param, |this, hash| {\n+                this.insert_with_hash(param.span, param.hir_id, Node::GenericParam(param), hash);\n+\n+                this.with_parent(param.hir_id, |this| {\n+                    intravisit::walk_generic_param(this, param);\n+                });\n+            });\n+        } else {\n+            self.insert(param.span, param.hir_id, Node::GenericParam(param));\n+            intravisit::walk_generic_param(self, param);\n+        }\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {"}, {"sha": "106fa8c78fa286a158ea1a3d11e845a731ca2258", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -816,7 +816,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n-            Some(Node::Stmt(ref s)) => Some(s.kind.attrs()),\n+            Some(Node::Stmt(ref s)) => Some(s.kind.attrs(|id| self.item(id.id))),\n             Some(Node::Arm(ref a)) => Some(&*a.attrs),\n             Some(Node::GenericParam(param)) => Some(&param.attrs[..]),\n             // Unit/tuple structs/variants take the attributes straight from"}, {"sha": "5da4be4e98279ce7ba7598edfed25037883ba837", "filename": "compiler/rustc_middle/src/hir/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fplace.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> Place<'tcx> {\n \n     /// Returns the type of this `Place` after all projections have been applied.\n     pub fn ty(&self) -> Ty<'tcx> {\n-        self.projections.last().map_or_else(|| self.base_ty, |proj| proj.ty)\n+        self.projections.last().map_or(self.base_ty, |proj| proj.ty)\n     }\n \n     /// Returns the type of this `Place` immediately before `projection_index`th projection"}, {"sha": "cab2ca2919f9fab321d316da4be97036acd27ed9", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -40,11 +40,12 @@ impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n         debug_assert!(!attr.ident().map_or(false, |ident| self.is_ignored_attr(ident.name)));\n         debug_assert!(!attr.is_doc_comment());\n \n-        let ast::Attribute { kind, id: _, style, span } = attr;\n+        let ast::Attribute { kind, id: _, style, span, tokens } = attr;\n         if let ast::AttrKind::Normal(item) = kind {\n             item.hash_stable(self, hasher);\n             style.hash_stable(self, hasher);\n             span.hash_stable(self, hasher);\n+            tokens.as_ref().expect_none(\"Tokens should have been removed during lowering!\");\n         } else {\n             unreachable!();\n         }"}, {"sha": "16e9aafb25a54e6987ab1534ab6a024e3e037f7f", "filename": "compiler/rustc_middle/src/infer/unify_key.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Funify_key.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -175,19 +175,15 @@ impl<'tcx> UnifyKey for ty::ConstVid<'tcx> {\n impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n     type Error = (&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>);\n \n-    fn unify_values(value1: &Self, value2: &Self) -> Result<Self, Self::Error> {\n-        let (val, span) = match (value1.val, value2.val) {\n+    fn unify_values(&value1: &Self, &value2: &Self) -> Result<Self, Self::Error> {\n+        Ok(match (value1.val, value2.val) {\n             (ConstVariableValue::Known { .. }, ConstVariableValue::Known { .. }) => {\n                 bug!(\"equating two const variables, both of which have known values\")\n             }\n \n             // If one side is known, prefer that one.\n-            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => {\n-                (value1.val, value1.origin.span)\n-            }\n-            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => {\n-                (value2.val, value2.origin.span)\n-            }\n+            (ConstVariableValue::Known { .. }, ConstVariableValue::Unknown { .. }) => value1,\n+            (ConstVariableValue::Unknown { .. }, ConstVariableValue::Known { .. }) => value2,\n \n             // If both sides are *unknown*, it hardly matters, does it?\n             (\n@@ -200,16 +196,11 @@ impl<'tcx> UnifyValue for ConstVarValue<'tcx> {\n                 // universe is the minimum of the two universes, because that is\n                 // the one which contains the fewest names in scope.\n                 let universe = cmp::min(universe1, universe2);\n-                (ConstVariableValue::Unknown { universe }, value1.origin.span)\n+                ConstVarValue {\n+                    val: ConstVariableValue::Unknown { universe },\n+                    origin: value1.origin,\n+                }\n             }\n-        };\n-\n-        Ok(ConstVarValue {\n-            origin: ConstVariableOrigin {\n-                kind: ConstVariableOriginKind::ConstInference,\n-                span: span,\n-            },\n-            val,\n         })\n     }\n }"}, {"sha": "6ff0a94ebf3ce1f8b8ee149eb8c59ff32b48074c", "filename": "compiler/rustc_middle/src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmacros.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -29,8 +29,8 @@ macro_rules! CloneLiftImpls {\n         $(\n             impl<$tcx> $crate::ty::Lift<$tcx> for $ty {\n                 type Lifted = Self;\n-                fn lift_to_tcx(&self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n-                    Some(Clone::clone(self))\n+                fn lift_to_tcx(self, _: $crate::ty::TyCtxt<$tcx>) -> Option<Self> {\n+                    Some(self)\n                 }\n             }\n         )+"}, {"sha": "ae9e4d364d3cb749e88c7224e7e40f8398652816", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -8,6 +8,7 @@ use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::{self, MetadataRef};\n+use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_macros::HashStable;\n@@ -185,6 +186,7 @@ pub trait CrateStore {\n \n     // resolve\n     fn def_key(&self, def: DefId) -> DefKey;\n+    fn def_kind(&self, def: DefId) -> DefKind;\n     fn def_path(&self, def: DefId) -> DefPath;\n     fn def_path_hash(&self, def: DefId) -> DefPathHash;\n     fn all_def_path_hashes_and_def_ids(&self, cnum: CrateNum) -> Vec<(DefPathHash, DefId)>;"}, {"sha": "d060549ca8137191c73eae593251900541d7ae23", "filename": "compiler/rustc_middle/src/middle/region.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fregion.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -292,20 +292,20 @@ pub struct ScopeTree {\n     ///\n     /// Then:\n     ///\n-    ///     1. From the ordering guarantee of HIR visitors (see\n-    ///     `rustc_hir::intravisit`), `D` does not dominate `U`.\n+    ///   1. From the ordering guarantee of HIR visitors (see\n+    ///   `rustc_hir::intravisit`), `D` does not dominate `U`.\n     ///\n-    ///     2. Therefore, `D` is *potentially* storage-dead at `U` (because\n-    ///     we might visit `U` without ever getting to `D`).\n+    ///   2. Therefore, `D` is *potentially* storage-dead at `U` (because\n+    ///   we might visit `U` without ever getting to `D`).\n     ///\n-    ///     3. However, we guarantee that at each HIR point, each\n-    ///     binding/temporary is always either always storage-live\n-    ///     or always storage-dead. This is what is being guaranteed\n-    ///     by `terminating_scopes` including all blocks where the\n-    ///     count of executions is not guaranteed.\n+    ///   3. However, we guarantee that at each HIR point, each\n+    ///   binding/temporary is always either always storage-live\n+    ///   or always storage-dead. This is what is being guaranteed\n+    ///   by `terminating_scopes` including all blocks where the\n+    ///   count of executions is not guaranteed.\n     ///\n-    ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n-    ///     QED.\n+    ///   4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n+    ///   QED.\n     ///\n     /// This property ought to not on (3) in an essential way -- it\n     /// is probably still correct even if we have \"unrestricted\" terminating"}, {"sha": "1a206b245d37b26fab5de503b501b56c51bebea6", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -256,24 +256,12 @@ pub enum EvalResult {\n }\n \n // See issue #38412.\n-fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, mut def_id: DefId) -> bool {\n-    // Check if `def_id` is a trait method.\n-    match tcx.def_kind(def_id) {\n-        DefKind::AssocFn | DefKind::AssocTy | DefKind::AssocConst => {\n-            if let ty::TraitContainer(trait_def_id) = tcx.associated_item(def_id).container {\n-                // Trait methods do not declare visibility (even\n-                // for visibility info in cstore). Use containing\n-                // trait instead, so methods of `pub` traits are\n-                // themselves considered `pub`.\n-                def_id = trait_def_id;\n-            }\n-        }\n-        _ => {}\n+fn skip_stability_check_due_to_privacy(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    if tcx.def_kind(def_id) == DefKind::TyParam {\n+        // Have no visibility, considered public for the purpose of this check.\n+        return false;\n     }\n-\n-    let visibility = tcx.visibility(def_id);\n-\n-    match visibility {\n+    match tcx.visibility(def_id) {\n         // Must check stability for `pub` items.\n         ty::Visibility::Public => false,\n "}, {"sha": "0421eabc2dc0522e2aedb223b30a57b138da4e0c", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "previous_filename": "compiler/rustc_middle/src/mir/coverage/mod.rs"}, {"sha": "05bcf2ba0ce49079fd031b323713a94a1faf087c", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -146,7 +146,7 @@ impl<'tcx> MirSource<'tcx> {\n /// The lowered representation of a single function.\n #[derive(Clone, TyEncodable, TyDecodable, Debug, HashStable, TypeFoldable)]\n pub struct Body<'tcx> {\n-    /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n+    /// A list of basic blocks. References to basic block use a newtyped index type [`BasicBlock`]\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n@@ -821,9 +821,6 @@ pub struct LocalDecl<'tcx> {\n     /// flag drop flags to avoid triggering this check as they are introduced\n     /// after typeck.\n     ///\n-    /// Unsafety checking will also ignore dereferences of these locals,\n-    /// so they can be used for raw pointers only used in a desugaring.\n-    ///\n     /// This should be sound because the drop flags are fully algebraic, and\n     /// therefore don't affect the OIBIT or outlives properties of the\n     /// generator.\n@@ -1010,13 +1007,13 @@ impl<'tcx> LocalDecl<'tcx> {\n     }\n \n     /// Returns `Some` if this is a reference to a static item that is used to\n-    /// access that static\n+    /// access that static.\n     pub fn is_ref_to_static(&self) -> bool {\n         matches!(self.local_info, Some(box LocalInfo::StaticRef { .. }))\n     }\n \n-    /// Returns `Some` if this is a reference to a static item that is used to\n-    /// access that static\n+    /// Returns `Some` if this is a reference to a thread-local static item that is used to\n+    /// access that static.\n     pub fn is_ref_to_thread_local(&self) -> bool {\n         match self.local_info {\n             Some(box LocalInfo::StaticRef { is_thread_local, .. }) => is_thread_local,\n@@ -1106,6 +1103,9 @@ rustc_index::newtype_index! {\n     /// are edges that go from a multi-successor node to a multi-predecessor node. This pass is\n     /// needed because some analyses require that there are no critical edges in the CFG.\n     ///\n+    /// Note that this type is just an index into [`Body.basic_blocks`](Body::basic_blocks);\n+    /// the actual data that a basic block holds is in [`BasicBlockData`].\n+    ///\n     /// Read more about basic blocks in the [rustc-dev-guide][guide-mir].\n     ///\n     /// [CFG]: https://rustc-dev-guide.rust-lang.org/appendix/background.html#cfg\n@@ -2210,7 +2210,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                         let name = ty::tls::with(|tcx| {\n                             let mut name = String::new();\n-                            let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n+                            let substs = tcx.lift(substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, &mut name, Namespace::ValueNS)\n                                 .print_def_path(variant_def.def_id, substs)?;\n                             Ok(name)\n@@ -2233,7 +2233,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                         if let Some(def_id) = def_id.as_local() {\n                             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n-                                let substs = tcx.lift(&substs).unwrap();\n+                                let substs = tcx.lift(substs).unwrap();\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n@@ -2527,7 +2527,7 @@ fn pretty_print_const(\n ) -> fmt::Result {\n     use crate::ty::print::PrettyPrinter;\n     ty::tls::with(|tcx| {\n-        let literal = tcx.lift(&c).unwrap();\n+        let literal = tcx.lift(c).unwrap();\n         let mut cx = FmtPrinter::new(tcx, fmt, Namespace::ValueNS);\n         cx.print_alloc_ids = true;\n         cx.pretty_print_const(literal, print_types)?;"}, {"sha": "f0bfdae261c643bdf2b6801ea8728aeba82a77e1", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -152,10 +152,14 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.mk_ty(ty::Array(operand.ty(local_decls, tcx), count))\n             }\n             Rvalue::ThreadLocalRef(did) => {\n+                let static_ty = tcx.type_of(did);\n                 if tcx.is_mutable_static(did) {\n-                    tcx.mk_mut_ptr(tcx.type_of(did))\n+                    tcx.mk_mut_ptr(static_ty)\n+                } else if tcx.is_foreign_item(did) {\n+                    tcx.mk_imm_ptr(static_ty)\n                 } else {\n-                    tcx.mk_imm_ref(tcx.lifetimes.re_static, tcx.type_of(did))\n+                    // FIXME: These things don't *really* have 'static lifetime.\n+                    tcx.mk_imm_ref(tcx.lifetimes.re_static, static_ty)\n                 }\n             }\n             Rvalue::Ref(reg, bk, ref place) => {"}, {"sha": "c9493c679879eebf1d74d5f9f025d38314f0aefa", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -535,7 +535,7 @@ impl<'tcx> TerminatorKind<'tcx> {\n             Goto { .. } => vec![\"\".into()],\n             SwitchInt { ref targets, switch_ty, .. } => ty::tls::with(|tcx| {\n                 let param_env = ty::ParamEnv::empty();\n-                let switch_ty = tcx.lift(&switch_ty).unwrap();\n+                let switch_ty = tcx.lift(switch_ty).unwrap();\n                 let size = tcx.layout_of(param_env.and(switch_ty)).unwrap().size;\n                 targets\n                     .values", "previous_filename": "compiler/rustc_middle/src/mir/terminator/mod.rs"}, {"sha": "89faa97d50fca9be3d48cd8b7b3e67cb0d5b2c74", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1267,6 +1267,7 @@ rustc_queries! {\n \n     TypeChecking {\n         query visibility(def_id: DefId) -> ty::Visibility {\n+            eval_always\n             desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n         }\n     }"}, {"sha": "bbc46b8d6083562ae070a76b14133a1490ffbe7c", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 56, "deletions": 21, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,6 +13,7 @@ use crate::mir::interpret::ErrorHandled;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, AdtKind, Ty, TyCtxt};\n \n+use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_span::symbol::Symbol;\n@@ -342,6 +343,7 @@ static_assert_size!(ObligationCauseCode<'_>, 32);\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n     pub arm_span: Span,\n+    pub scrut_span: Span,\n     pub semi_span: Option<Span>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n@@ -646,13 +648,13 @@ impl ObjectSafetyViolation {\n             ObjectSafetyViolation::SizedSelf(_) => \"it requires `Self: Sized`\".into(),\n             ObjectSafetyViolation::SupertraitSelf(ref spans) => {\n                 if spans.iter().any(|sp| *sp != DUMMY_SP) {\n-                    \"it uses `Self` as a type parameter in this\".into()\n+                    \"it uses `Self` as a type parameter\".into()\n                 } else {\n                     \"it cannot use `Self` as a type parameter in a supertrait or `where`-clause\"\n                         .into()\n                 }\n             }\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_), _) => {\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(_, _, _), _) => {\n                 format!(\"associated function `{}` has no `self` parameter\", name).into()\n             }\n             ObjectSafetyViolation::Method(\n@@ -686,32 +688,65 @@ impl ObjectSafetyViolation {\n         }\n     }\n \n-    pub fn solution(&self) -> Option<(String, Option<(String, Span)>)> {\n-        Some(match *self {\n-            ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {\n-                return None;\n+    pub fn solution(&self, err: &mut DiagnosticBuilder<'_>) {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf(_) | ObjectSafetyViolation::SupertraitSelf(_) => {}\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::StaticMethod(sugg, self_span, has_args),\n+                _,\n+            ) => {\n+                err.span_suggestion(\n+                    self_span,\n+                    &format!(\n+                        \"consider turning `{}` into a method by giving it a `&self` argument\",\n+                        name\n+                    ),\n+                    format!(\"&self{}\", if has_args { \", \" } else { \"\" }),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                match sugg {\n+                    Some((sugg, span)) => {\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\n+                                \"alternatively, consider constraining `{}` so it does not apply to \\\n+                                 trait objects\",\n+                                name\n+                            ),\n+                            sugg.to_string(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                    None => {\n+                        err.help(&format!(\n+                            \"consider turning `{}` into a method by giving it a `&self` \\\n+                             argument or constraining it so it does not apply to trait objects\",\n+                            name\n+                        ));\n+                    }\n+                }\n             }\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod(sugg), _) => (\n-                format!(\n-                    \"consider turning `{}` into a method by giving it a `&self` argument or \\\n-                     constraining it so it does not apply to trait objects\",\n-                    name\n-                ),\n-                sugg.map(|(sugg, sp)| (sugg.to_string(), sp)),\n-            ),\n             ObjectSafetyViolation::Method(\n                 name,\n                 MethodViolationCode::UndispatchableReceiver,\n                 span,\n-            ) => (\n-                format!(\"consider changing method `{}`'s `self` parameter to be `&self`\", name),\n-                Some((\"&Self\".to_string(), span)),\n-            ),\n+            ) => {\n+                err.span_suggestion(\n+                    span,\n+                    &format!(\n+                        \"consider changing method `{}`'s `self` parameter to be `&self`\",\n+                        name\n+                    ),\n+                    \"&Self\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n             ObjectSafetyViolation::AssocConst(name, _)\n             | ObjectSafetyViolation::Method(name, ..) => {\n-                (format!(\"consider moving `{}` to another trait\", name), None)\n+                err.help(&format!(\"consider moving `{}` to another trait\", name));\n             }\n-        })\n+        }\n     }\n \n     pub fn spans(&self) -> SmallVec<[Span; 1]> {\n@@ -735,7 +770,7 @@ impl ObjectSafetyViolation {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n pub enum MethodViolationCode {\n     /// e.g., `fn foo()`\n-    StaticMethod(Option<(&'static str, Span)>),\n+    StaticMethod(Option<(&'static str, Span)>, Span, bool /* has args */),\n \n     /// e.g., `fn foo(&self, x: Self)`\n     ReferencesSelfInput(usize),"}, {"sha": "c570ad3273d4e3dcbd81c12911dd908c53b93ed6", "filename": "compiler/rustc_middle/src/traits/select.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fselect.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -127,7 +127,10 @@ pub enum SelectionCandidate<'tcx> {\n \n     TraitAliasCandidate(DefId),\n \n-    ObjectCandidate,\n+    /// Matching `dyn Trait` with a supertrait of `Trait`. The index is the\n+    /// position in the iterator returned by\n+    /// `rustc_infer::traits::util::supertraits`.\n+    ObjectCandidate(usize),\n \n     BuiltinObjectCandidate,\n "}, {"sha": "f6ea6743a0e0476a6dec16e2a0184d3ad5f3d7be", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -22,7 +22,7 @@ use crate::ty::{\n     ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntVar,\n     IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n     ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n-    TyVid, TypeAndMut,\n+    TyVid, TypeAndMut, Visibility,\n };\n use rustc_ast as ast;\n use rustc_ast::expand::allocator::AllocatorKind;\n@@ -134,7 +134,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     fn intern_predicate(&self, kind: PredicateKind<'tcx>) -> &'tcx PredicateInner<'tcx> {\n         self.predicate\n             .intern(kind, |kind| {\n-                let flags = super::flags::FlagComputation::for_predicate(&kind);\n+                let flags = super::flags::FlagComputation::for_predicate(kind);\n \n                 let predicate_struct = PredicateInner {\n                     kind,\n@@ -911,6 +911,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    /// Visibilities produced by resolver.\n+    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n+\n     /// Resolutions of `extern crate` items produced by resolver.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n \n@@ -1057,7 +1060,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n+    pub fn lift<T: Lift<'tcx>>(self, value: T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }\n \n@@ -1124,6 +1127,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             types: common_types,\n             lifetimes: common_lifetimes,\n             consts: common_consts,\n+            visibilities: resolutions.visibilities,\n             extern_crate_map: resolutions.extern_crate_map,\n             trait_map,\n             export_map: resolutions.export_map,\n@@ -1565,16 +1569,16 @@ impl<'tcx> TyCtxt<'tcx> {\n /// e.g., `()` or `u8`, was interned in a different context.\n pub trait Lift<'tcx>: fmt::Debug {\n     type Lifted: fmt::Debug + 'tcx;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n macro_rules! nop_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n             type Lifted = $lifted;\n-            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n-                    Some(unsafe { mem::transmute(*self) })\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                    Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n                 }\n@@ -1587,12 +1591,12 @@ macro_rules! nop_list_lift {\n     ($set:ident; $ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for &'a List<$ty> {\n             type Lifted = &'tcx List<$lifted>;\n-            fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+            fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n                 if self.is_empty() {\n                     return Some(List::empty());\n                 }\n-                if tcx.interners.$set.contains_pointer_to(&Interned(*self)) {\n-                    Some(unsafe { mem::transmute(*self) })\n+                if tcx.interners.$set.contains_pointer_to(&Interned(self)) {\n+                    Some(unsafe { mem::transmute(self) })\n                 } else {\n                     None\n                 }\n@@ -2032,13 +2036,13 @@ direct_interners! {\n \n macro_rules! slice_interners {\n     ($($field:ident: $method:ident($ty:ty)),+ $(,)?) => (\n-        $(impl<'tcx> TyCtxt<'tcx> {\n-            pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n+        impl<'tcx> TyCtxt<'tcx> {\n+            $(pub fn $method(self, v: &[$ty]) -> &'tcx List<$ty> {\n                 self.interners.$field.intern_ref(v, || {\n                     Interned(List::from_arena(&*self.arena, v))\n                 }).0\n-            }\n-        })+\n+            })+\n+        }\n     );\n }\n "}, {"sha": "235f8749cf917766e92e6073eeaca71a0bbfb44d", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -229,7 +229,7 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n             ty::Array(t, n) => {\n-                let n = tcx.lift(&n).unwrap();\n+                let n = tcx.lift(n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n                     _ if t.is_simple_ty() => format!(\"array `{}`\", self).into(),\n                     Some(n) => format!(\"array of {} element{}\", n, pluralize!(n)).into(),"}, {"sha": "8b97a87f214b83955fffc55fd2348464fd6ddc46", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 32, "deletions": 36, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -22,7 +22,7 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_predicate(kind: &ty::PredicateKind<'_>) -> FlagComputation {\n+    pub fn for_predicate(kind: ty::PredicateKind<'_>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n         result.add_predicate_kind(kind);\n         result\n@@ -53,7 +53,14 @@ impl FlagComputation {\n \n     /// Adds the flags/depth from a set of types that appear within the current type, but within a\n     /// region binder.\n-    fn add_bound_computation(&mut self, computation: FlagComputation) {\n+    fn bound_computation<T, F>(&mut self, value: ty::Binder<T>, f: F)\n+    where\n+        F: FnOnce(&mut Self, T),\n+    {\n+        let mut computation = FlagComputation::new();\n+\n+        f(&mut computation, value.skip_binder());\n+\n         self.add_flags(computation.flags);\n \n         // The types that contributed to `computation` occurred within\n@@ -101,9 +108,7 @@ impl FlagComputation {\n             }\n \n             &ty::GeneratorWitness(ts) => {\n-                let mut computation = FlagComputation::new();\n-                computation.add_tys(ts.skip_binder());\n-                self.add_bound_computation(computation);\n+                self.bound_computation(ts, |flags, ts| flags.add_tys(ts));\n             }\n \n             &ty::Closure(_, substs) => {\n@@ -154,20 +159,21 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::Dynamic(ref obj, r) => {\n-                let mut computation = FlagComputation::new();\n-                for predicate in obj.skip_binder().iter() {\n-                    match predicate {\n-                        ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n-                        ty::ExistentialPredicate::Projection(p) => {\n-                            let mut proj_computation = FlagComputation::new();\n-                            proj_computation.add_existential_projection(&p);\n-                            self.add_bound_computation(proj_computation);\n+            &ty::Dynamic(obj, r) => {\n+                self.bound_computation(obj, |computation, obj| {\n+                    for predicate in obj.iter() {\n+                        match predicate {\n+                            ty::ExistentialPredicate::Trait(tr) => {\n+                                computation.add_substs(tr.substs)\n+                            }\n+                            ty::ExistentialPredicate::Projection(p) => {\n+                                computation.add_existential_projection(&p);\n+                            }\n+                            ty::ExistentialPredicate::AutoTrait(_) => {}\n                         }\n-                        ty::ExistentialPredicate::AutoTrait(_) => {}\n                     }\n-                }\n-                self.add_bound_computation(computation);\n+                });\n+\n                 self.add_region(r);\n             }\n \n@@ -195,22 +201,21 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::FnPtr(f) => {\n-                self.add_fn_sig(f);\n-            }\n+            &ty::FnPtr(fn_sig) => self.bound_computation(fn_sig, |computation, fn_sig| {\n+                computation.add_tys(fn_sig.inputs());\n+                computation.add_ty(fn_sig.output());\n+            }),\n         }\n     }\n \n-    fn add_predicate_kind(&mut self, kind: &ty::PredicateKind<'_>) {\n+    fn add_predicate_kind(&mut self, kind: ty::PredicateKind<'_>) {\n         match kind {\n             ty::PredicateKind::ForAll(binder) => {\n-                let mut computation = FlagComputation::new();\n-\n-                computation.add_predicate_atom(binder.skip_binder());\n-\n-                self.add_bound_computation(computation);\n+                self.bound_computation(binder, |computation, atom| {\n+                    computation.add_predicate_atom(atom)\n+                });\n             }\n-            &ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n+            ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n         }\n     }\n \n@@ -266,15 +271,6 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_fn_sig(&mut self, fn_sig: ty::PolyFnSig<'_>) {\n-        let mut computation = FlagComputation::new();\n-\n-        computation.add_tys(fn_sig.skip_binder().inputs());\n-        computation.add_ty(fn_sig.skip_binder().output());\n-\n-        self.add_bound_computation(computation);\n-    }\n-\n     fn add_region(&mut self, r: ty::Region<'_>) {\n         self.add_flags(r.type_flags());\n         if let ty::ReLateBound(debruijn, _) = *r {"}, {"sha": "0e5e22dcaae9f34134dfaf4250e51189a81e3534", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -30,8 +30,6 @@\n //!\n //! These methods return true to indicate that the visitor has found what it is\n //! looking for, and does not need to visit anything else.\n-\n-use crate::ty::structural_impls::PredicateVisitor;\n use crate::ty::{self, flags::FlagComputation, Binder, Ty, TyCtxt, TypeFlags};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n@@ -211,6 +209,10 @@ pub trait TypeVisitor<'tcx>: Sized {\n     fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> bool {\n         c.super_visit_with(self)\n     }\n+\n+    fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> bool {\n+        p.super_visit_with(self)\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -868,9 +870,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n             _ => ct.super_visit_with(self),\n         }\n     }\n-}\n \n-impl<'tcx> PredicateVisitor<'tcx> for HasEscapingVarsVisitor {\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n         predicate.inner.outer_exclusive_binder > self.outer_index\n     }\n@@ -903,9 +903,7 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         debug!(\"HasTypeFlagsVisitor: c={:?} c.flags={:?} self.flags={:?}\", c, flags, self.flags);\n         flags.intersects(self.flags)\n     }\n-}\n \n-impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n         debug!(\n             \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n@@ -914,6 +912,7 @@ impl<'tcx> PredicateVisitor<'tcx> for HasTypeFlagsVisitor {\n         predicate.inner.flags.intersects(self.flags)\n     }\n }\n+\n /// Collects all the late-bound regions at the innermost binding level\n /// into a hash set.\n struct LateBoundRegionsCollector {"}, {"sha": "8b3fb8750706122bd28e3a992335963f5df05e5a", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -258,7 +258,7 @@ impl<'tcx> InstanceDef<'tcx> {\n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         ty::tls::with(|tcx| {\n-            let substs = tcx.lift(&self.substs).expect(\"could not lift for printing\");\n+            let substs = tcx.lift(self.substs).expect(\"could not lift for printing\");\n             FmtPrinter::new(tcx, &mut *f, Namespace::ValueNS)\n                 .print_def_path(self.def_id(), substs)?;\n             Ok(())"}, {"sha": "845fa8a47ae2caee3c05d322ca4bc31b772fc35e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -125,6 +125,7 @@ mod sty;\n pub struct ResolverOutputs {\n     pub definitions: rustc_hir::definitions::Definitions,\n     pub cstore: Box<CrateStoreDyn>,\n+    pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     pub extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n     pub maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     pub maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -1056,9 +1057,21 @@ impl<'tcx> Predicate<'tcx> {\n         }\n     }\n \n+    /// Converts this to a `Binder<PredicateAtom<'tcx>>`. If the value was an\n+    /// `Atom`, then it is not allowed to contain escaping bound vars.\n+    pub fn bound_atom(self) -> Binder<PredicateAtom<'tcx>> {\n+        match self.kind() {\n+            &PredicateKind::ForAll(binder) => binder,\n+            &PredicateKind::Atom(atom) => {\n+                debug_assert!(!atom.has_escaping_bound_vars());\n+                Binder::dummy(atom)\n+            }\n+        }\n+    }\n+\n     /// Allows using a `Binder<PredicateAtom<'tcx>>` even if the given predicate previously\n     /// contained unbound variables by shifting these variables outwards.\n-    pub fn bound_atom(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n+    pub fn bound_atom_with_opt_escaping(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n         match self.kind() {\n             &PredicateKind::ForAll(binder) => binder,\n             &PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n@@ -2436,8 +2449,10 @@ impl<'tcx> AdtDef {\n         self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n+    /// Whether the ADT lacks fields. Note that this includes uninhabited enums,\n+    /// e.g., `enum Void {}` is considered payload free as well.\n     pub fn is_payloadfree(&self) -> bool {\n-        !self.variants.is_empty() && self.variants.iter().all(|v| v.fields.is_empty())\n+        self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n     /// Return a `VariantDef` given a variant id."}, {"sha": "de24322e07de226b9d06c5bf2244e02e623d90ab", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -618,10 +618,9 @@ pub trait PrettyPrinter<'tcx>:\n                         // may contain unbound variables. We therefore do this manually.\n                         //\n                         // FIXME(lcnr): Find out why exactly this is the case :)\n-                        if let ty::PredicateAtom::Trait(pred, _) =\n-                            predicate.bound_atom(self.tcx()).skip_binder()\n-                        {\n-                            let trait_ref = ty::Binder::bind(pred.trait_ref);\n+                        let bound_predicate = predicate.bound_atom_with_opt_escaping(self.tcx());\n+                        if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                            let trait_ref = bound_predicate.rebind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n                                 is_sized = true;\n@@ -1849,7 +1848,7 @@ macro_rules! forward_display_to_print {\n         $(impl fmt::Display for $ty {\n             fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n                 ty::tls::with(|tcx| {\n-                    tcx.lift(self)\n+                    tcx.lift(*self)\n                         .expect(\"could not lift for printing\")\n                         .print(FmtPrinter::new(tcx, f, Namespace::TypeNS))?;\n                     Ok(())"}, {"sha": "7ba4d5a14dffb49e474bcbe37a6607ff8b84cd96", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 57, "deletions": 13, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -34,7 +34,6 @@ use crate::ty::util::AlwaysRequiresDrop;\n use crate::ty::{self, AdtSizedConstraint, CrateInherentImpls, ParamEnvAnd, Ty, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_data_structures::profiling::ProfileCategory::*;\n use rustc_data_structures::stable_hasher::StableVec;\n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::sync::Lrc;\n@@ -169,26 +168,71 @@ pub fn force_from_dep_node<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> bool\n         return false;\n     }\n \n-    rustc_dep_node_force!([dep_node, tcx]\n-        // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already.\n-        DepKind::CrateMetadata |\n+    macro_rules! force_from_dep_node {\n+        ($($(#[$attr:meta])* [$($modifiers:tt)*] $name:ident($K:ty),)*) => {\n+            match dep_node.kind {\n+                // These are inputs that are expected to be pre-allocated and that\n+                // should therefore always be red or green already.\n+                DepKind::CrateMetadata |\n \n-        // These are anonymous nodes.\n-        DepKind::TraitSelect |\n+                // These are anonymous nodes.\n+                DepKind::TraitSelect |\n \n-        // We don't have enough information to reconstruct the query key of\n-        // these.\n-        DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+                // We don't have enough information to reconstruct the query key of\n+                // these.\n+                DepKind::CompileCodegenUnit |\n+\n+                // Forcing this makes no sense.\n+                DepKind::Null => {\n+                    bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n+                }\n+\n+                $(DepKind::$name => {\n+                    debug_assert!(<$K as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key());\n+\n+                    if let Some(key) = <$K as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node) {\n+                        force_query::<queries::$name<'_>, _>(\n+                            tcx,\n+                            key,\n+                            DUMMY_SP,\n+                            *dep_node\n+                        );\n+                        return true;\n+                    }\n+                })*\n+            }\n         }\n-    );\n+    }\n+\n+    rustc_dep_node_append! { [force_from_dep_node!][] }\n \n     false\n }\n \n pub(crate) fn try_load_from_on_disk_cache<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) {\n-    rustc_dep_node_try_load_from_on_disk_cache!(dep_node, tcx)\n+    macro_rules! try_load_from_on_disk_cache {\n+        ($($name:ident,)*) => {\n+            match dep_node.kind {\n+                $(DepKind::$name => {\n+                    if <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::can_reconstruct_query_key() {\n+                        debug_assert!(tcx.dep_graph\n+                                         .node_color(dep_node)\n+                                         .map(|c| c.is_green())\n+                                         .unwrap_or(false));\n+\n+                        let key = <query_keys::$name<'tcx> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node).unwrap();\n+                        if queries::$name::cache_on_disk(tcx, &key, None) {\n+                            let _ = tcx.$name(key);\n+                        }\n+                    }\n+                })*\n+\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    rustc_cached_queries!(try_load_from_on_disk_cache!);\n }\n \n mod sealed {"}, {"sha": "d038695283c107588aa8a252da3d4061f561aeb7", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -40,7 +40,8 @@ impl QueryContext for TyCtxt<'tcx> {\n \n     fn try_collect_active_jobs(\n         &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>> {\n+    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n+    {\n         self.queries.try_collect_active_jobs()\n     }\n \n@@ -241,33 +242,22 @@ macro_rules! hash_result {\n     };\n }\n \n-macro_rules! define_queries {\n-    (<$tcx:tt> $($category:tt {\n-        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($($K:tt)*) -> $V:ty,)*\n-    },)*) => {\n-        define_queries_inner! { <$tcx>\n-            $($( $(#[$attr])* category<$category> [$($modifiers)*] fn $name: $node($($K)*) -> $V,)*)*\n-        }\n-    }\n-}\n-\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     ($K:ty) => { $K };\n }\n \n-macro_rules! define_queries_inner {\n+macro_rules! define_queries {\n     (<$tcx:tt>\n-     $($(#[$attr:meta])* category<$category:tt>\n-        [$($modifiers:tt)*] fn $name:ident: $node:ident($($K:tt)*) -> $V:ty,)*) => {\n+     $($(#[$attr:meta])*\n+        [$($modifiers:tt)*] fn $name:ident($($K:tt)*) -> $V:ty,)*) => {\n \n         use std::mem;\n         use crate::{\n             rustc_data_structures::stable_hasher::HashStable,\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n-        use rustc_data_structures::profiling::ProfileCategory;\n \n         define_queries_struct! {\n             tcx: $tcx,\n@@ -353,26 +343,25 @@ macro_rules! define_queries_inner {\n             $(pub type $name<$tcx> = $V;)*\n         }\n \n-        $(impl<$tcx> QueryConfig<TyCtxt<$tcx>> for queries::$name<$tcx> {\n+        $(impl<$tcx> QueryConfig for queries::$name<$tcx> {\n             type Key = $($K)*;\n             type Value = $V;\n             type Stored = <\n                 query_storage!([$($modifiers)*][$($K)*, $V])\n                 as QueryStorage\n             >::Stored;\n             const NAME: &'static str = stringify!($name);\n-            const CATEGORY: ProfileCategory = $category;\n         }\n \n         impl<$tcx> QueryAccessors<TyCtxt<$tcx>> for queries::$name<$tcx> {\n             const ANON: bool = is_anon!([$($modifiers)*]);\n             const EVAL_ALWAYS: bool = is_eval_always!([$($modifiers)*]);\n-            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$node;\n+            const DEP_KIND: dep_graph::DepKind = dep_graph::DepKind::$name;\n \n             type Cache = query_storage!([$($modifiers)*][$($K)*, $V]);\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<TyCtxt<$tcx>, Self::Cache> {\n+            fn query_state<'a>(tcx: TyCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query, Self::Cache> {\n                 &tcx.queries.$name\n             }\n \n@@ -454,7 +443,7 @@ macro_rules! define_queries_inner {\n             #[inline(always)]\n             #[must_use]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*))\n-                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+                -> <queries::$name<$tcx> as QueryConfig>::Stored\n             {\n                 self.at(DUMMY_SP).$name(key.into_query_param())\n             })*\n@@ -493,7 +482,7 @@ macro_rules! define_queries_inner {\n             $($(#[$attr])*\n             #[inline(always)]\n             pub fn $name(self, key: query_helper_param_ty!($($K)*))\n-                -> <queries::$name<$tcx> as QueryConfig<TyCtxt<$tcx>>>::Stored\n+                -> <queries::$name<$tcx> as QueryConfig>::Stored\n             {\n                 get_query::<queries::$name<'_>, _>(self.tcx, self.span, key.into_query_param())\n             })*\n@@ -527,7 +516,8 @@ macro_rules! define_queries_struct {\n             fallback_extern_providers: Box<Providers>,\n \n             $($(#[$attr])*  $name: QueryState<\n-                TyCtxt<$tcx>,\n+                crate::dep_graph::DepKind,\n+                <TyCtxt<$tcx> as QueryContext>::Query,\n                 <queries::$name<$tcx> as QueryAccessors<TyCtxt<'tcx>>>::Cache,\n             >,)*\n         }\n@@ -548,7 +538,7 @@ macro_rules! define_queries_struct {\n \n             pub(crate) fn try_collect_active_jobs(\n                 &self\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<TyCtxt<'tcx>>>> {\n+            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, <TyCtxt<$tcx> as QueryContext>::Query>>> {\n                 let mut jobs = FxHashMap::default();\n \n                 $("}, {"sha": "cbcecb88491888ee786862bf085cf0f7fb206fd0", "filename": "compiler/rustc_middle/src/ty/query/profiling_support.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fprofiling_support.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -5,8 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::SelfProfiler;\n use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::DefPathData;\n-use rustc_query_system::query::QueryCache;\n-use rustc_query_system::query::QueryState;\n+use rustc_query_system::query::{QueryCache, QueryContext, QueryState};\n use std::fmt::Debug;\n use std::io::Write;\n \n@@ -231,7 +230,7 @@ where\n pub(super) fn alloc_self_profile_query_strings_for_query_cache<'tcx, C>(\n     tcx: TyCtxt<'tcx>,\n     query_name: &'static str,\n-    query_state: &QueryState<TyCtxt<'tcx>, C>,\n+    query_state: &QueryState<crate::dep_graph::DepKind, <TyCtxt<'tcx> as QueryContext>::Query, C>,\n     string_cache: &mut QueryKeyStringCache,\n ) where\n     C: QueryCache,"}, {"sha": "e0b44ce23c912c0fba3c5e0f48dc6d28b4bd9787", "filename": "compiler/rustc_middle/src/ty/query/stats.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fstats.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,11 +1,10 @@\n use crate::ty::query::queries;\n use crate::ty::TyCtxt;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc_query_system::query::QueryCache;\n-use rustc_query_system::query::QueryState;\n-use rustc_query_system::query::{QueryAccessors, QueryContext};\n+use rustc_query_system::query::{QueryAccessors, QueryCache, QueryContext, QueryState};\n \n use std::any::type_name;\n+use std::hash::Hash;\n use std::mem;\n #[cfg(debug_assertions)]\n use std::sync::atomic::Ordering;\n@@ -38,10 +37,12 @@ struct QueryStats {\n     local_def_id_keys: Option<usize>,\n }\n \n-fn stats<CTX: QueryContext, C: QueryCache>(\n-    name: &'static str,\n-    map: &QueryState<CTX, C>,\n-) -> QueryStats {\n+fn stats<D, Q, C>(name: &'static str, map: &QueryState<D, Q, C>) -> QueryStats\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n+{\n     let mut stats = QueryStats {\n         name,\n         #[cfg(debug_assertions)]\n@@ -119,21 +120,22 @@ pub fn print_stats(tcx: TyCtxt<'_>) {\n }\n \n macro_rules! print_stats {\n-    (<$tcx:tt> $($category:tt {\n-        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident: $node:ident($K:ty) -> $V:ty,)*\n-    },)*) => {\n+    (<$tcx:tt>\n+        $($(#[$attr:meta])* [$($modifiers:tt)*] fn $name:ident($K:ty) -> $V:ty,)*\n+    ) => {\n         fn query_stats(tcx: TyCtxt<'_>) -> Vec<QueryStats> {\n             let mut queries = Vec::new();\n \n-            $($(\n+            $(\n                 queries.push(stats::<\n-                    TyCtxt<'_>,\n+                    crate::dep_graph::DepKind,\n+                    <TyCtxt<'_> as QueryContext>::Query,\n                     <queries::$name<'_> as QueryAccessors<TyCtxt<'_>>>::Cache,\n                 >(\n                     stringify!($name),\n                     &tcx.queries.$name,\n                 ));\n-            )*)*\n+            )*\n \n             queries\n         }"}, {"sha": "53521d0e9f332021dc0df1933e8ee0a229a2b1b1", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 104, "deletions": 130, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -332,130 +332,112 @@ CloneTypeFoldableAndLiftImpls! {\n // FIXME(eddyb) replace all the uses of `Option::map` with `?`.\n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>> Lift<'tcx> for (A, B) {\n     type Lifted = (A::Lifted, B::Lifted);\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.0).and_then(|a| tcx.lift(&self.1).map(|b| (a, b)))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some((tcx.lift(self.0)?, tcx.lift(self.1)?))\n     }\n }\n \n impl<'tcx, A: Lift<'tcx>, B: Lift<'tcx>, C: Lift<'tcx>> Lift<'tcx> for (A, B, C) {\n     type Lifted = (A::Lifted, B::Lifted, C::Lifted);\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.0)\n-            .and_then(|a| tcx.lift(&self.1).and_then(|b| tcx.lift(&self.2).map(|c| (a, b, c))))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        Some((tcx.lift(self.0)?, tcx.lift(self.1)?, tcx.lift(self.2)?))\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Option<T> {\n     type Lifted = Option<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            Some(ref x) => tcx.lift(x).map(Some),\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            Some(x) => tcx.lift(x).map(Some),\n             None => Some(None),\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>, E: Lift<'tcx>> Lift<'tcx> for Result<T, E> {\n     type Lifted = Result<T::Lifted, E::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            Ok(ref x) => tcx.lift(x).map(Ok),\n-            Err(ref e) => tcx.lift(e).map(Err),\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            Ok(x) => tcx.lift(x).map(Ok),\n+            Err(e) => tcx.lift(e).map(Err),\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Box<T> {\n     type Lifted = Box<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Box::new)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(*self).map(Box::new)\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Rc<T> {\n+impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Rc<T> {\n     type Lifted = Rc<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Rc::new)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.as_ref().clone()).map(Rc::new)\n     }\n }\n \n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Arc<T> {\n+impl<'tcx, T: Lift<'tcx> + Clone> Lift<'tcx> for Arc<T> {\n     type Lifted = Arc<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&**self).map(Arc::new)\n-    }\n-}\n-\n-impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for [T] {\n-    type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        // type annotation needed to inform `projection_must_outlive`\n-        let mut result: Vec<<T as Lift<'tcx>>::Lifted> = Vec::with_capacity(self.len());\n-        for x in self {\n-            if let Some(value) = tcx.lift(x) {\n-                result.push(value);\n-            } else {\n-                return None;\n-            }\n-        }\n-        Some(result)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.as_ref().clone()).map(Arc::new)\n     }\n }\n-\n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for Vec<T> {\n     type Lifted = Vec<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self[..])\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.into_iter().map(|v| tcx.lift(v)).collect()\n     }\n }\n \n impl<'tcx, I: Idx, T: Lift<'tcx>> Lift<'tcx> for IndexVec<I, T> {\n     type Lifted = IndexVec<I, T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        self.iter().map(|e| tcx.lift(e)).collect()\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.into_iter().map(|e| tcx.lift(e)).collect()\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitRef<'a> {\n     type Lifted = ty::TraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::TraitRef { def_id: self.def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialTraitRef<'a> {\n     type Lifted = ty::ExistentialTraitRef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ExistentialTraitRef { def_id: self.def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialPredicate<'a> {\n     type Lifted = ty::ExistentialPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::ExistentialPredicate::Trait(x) => tcx.lift(x).map(ty::ExistentialPredicate::Trait),\n             ty::ExistentialPredicate::Projection(x) => {\n                 tcx.lift(x).map(ty::ExistentialPredicate::Projection)\n             }\n             ty::ExistentialPredicate::AutoTrait(def_id) => {\n-                Some(ty::ExistentialPredicate::AutoTrait(*def_id))\n+                Some(ty::ExistentialPredicate::AutoTrait(def_id))\n             }\n         }\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::TraitPredicate<'a> {\n     type Lifted = ty::TraitPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n-        tcx.lift(&self.trait_ref).map(|trait_ref| ty::TraitPredicate { trait_ref })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::TraitPredicate<'tcx>> {\n+        tcx.lift(self.trait_ref).map(|trait_ref| ty::TraitPredicate { trait_ref })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n     type Lifted = ty::SubtypePredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n-        tcx.lift(&(self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::SubtypePredicate<'tcx>> {\n+        tcx.lift((self.a, self.b)).map(|(a, b)| ty::SubtypePredicate {\n             a_is_expected: self.a_is_expected,\n             a,\n             b,\n@@ -465,41 +447,41 @@ impl<'a, 'tcx> Lift<'tcx> for ty::SubtypePredicate<'a> {\n \n impl<'tcx, A: Copy + Lift<'tcx>, B: Copy + Lift<'tcx>> Lift<'tcx> for ty::OutlivesPredicate<A, B> {\n     type Lifted = ty::OutlivesPredicate<A::Lifted, B::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift((self.0, self.1)).map(|(a, b)| ty::OutlivesPredicate(a, b))\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n     type Lifted = ty::ProjectionTy<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n-        tcx.lift(&self.substs)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionTy<'tcx>> {\n+        tcx.lift(self.substs)\n             .map(|substs| ty::ProjectionTy { item_def_id: self.item_def_id, substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift(&(self.projection_ty, self.ty))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<ty::ProjectionPredicate<'tcx>> {\n+        tcx.lift((self.projection_ty, self.ty))\n             .map(|(projection_ty, ty)| ty::ProjectionPredicate { projection_ty, ty })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ExistentialProjection<'a> {\n     type Lifted = ty::ExistentialProjection<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ExistentialProjection {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ExistentialProjection {\n             substs,\n-            ty: tcx.lift(&self.ty).expect(\"type must lift when substs do\"),\n+            ty: tcx.lift(self.ty).expect(\"type must lift when substs do\"),\n             item_def_id: self.item_def_id,\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n             ty::PredicateKind::ForAll(binder) => tcx.lift(binder).map(ty::PredicateKind::ForAll),\n             ty::PredicateKind::Atom(atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n@@ -509,100 +491,101 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n     type Lifted = ty::PredicateAtom<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            ty::PredicateAtom::Trait(ref data, constness) => {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::PredicateAtom::Trait(data, constness) => {\n                 tcx.lift(data).map(|data| ty::PredicateAtom::Trait(data, constness))\n             }\n-            ty::PredicateAtom::Subtype(ref data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n-            ty::PredicateAtom::RegionOutlives(ref data) => {\n+            ty::PredicateAtom::Subtype(data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n+            ty::PredicateAtom::RegionOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::RegionOutlives)\n             }\n-            ty::PredicateAtom::TypeOutlives(ref data) => {\n+            ty::PredicateAtom::TypeOutlives(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::TypeOutlives)\n             }\n-            ty::PredicateAtom::Projection(ref data) => {\n+            ty::PredicateAtom::Projection(data) => {\n                 tcx.lift(data).map(ty::PredicateAtom::Projection)\n             }\n-            ty::PredicateAtom::WellFormed(ty) => tcx.lift(&ty).map(ty::PredicateAtom::WellFormed),\n+            ty::PredicateAtom::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateAtom::WellFormed),\n             ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n-                tcx.lift(&closure_substs).map(|closure_substs| {\n+                tcx.lift(closure_substs).map(|closure_substs| {\n                     ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n             ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n                 Some(ty::PredicateAtom::ObjectSafe(trait_def_id))\n             }\n             ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(&substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n+                tcx.lift(substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                tcx.lift(&(c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n+                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n             }\n             ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n-                tcx.lift(&ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n+                tcx.lift(ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n             }\n         }\n     }\n }\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::Binder<T> {\n     type Lifted = ty::Binder<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(self.as_ref().skip_binder()).map(ty::Binder::bind)\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        self.map_bound(|v| tcx.lift(v)).transpose()\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ParamEnv<'a> {\n     type Lifted = ty::ParamEnv<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.caller_bounds())\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.caller_bounds())\n             .map(|caller_bounds| ty::ParamEnv::new(caller_bounds, self.reveal()))\n     }\n }\n \n impl<'a, 'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::ParamEnvAnd<'a, T> {\n     type Lifted = ty::ParamEnvAnd<'tcx, T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.param_env).and_then(|param_env| {\n-            tcx.lift(&self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.param_env).and_then(|param_env| {\n+            tcx.lift(self.value).map(|value| ty::ParamEnvAnd { param_env, value })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::ClosureSubsts<'a> {\n     type Lifted = ty::ClosureSubsts<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::ClosureSubsts { substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::ClosureSubsts { substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GeneratorSubsts<'a> {\n     type Lifted = ty::GeneratorSubsts<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.substs).map(|substs| ty::GeneratorSubsts { substs })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.substs).map(|substs| ty::GeneratorSubsts { substs })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjustment<'a> {\n     type Lifted = ty::adjustment::Adjustment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.kind).and_then(|kind| {\n-            tcx.lift(&self.target).map(|target| ty::adjustment::Adjustment { kind, target })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let ty::adjustment::Adjustment { kind, target } = self;\n+        tcx.lift(kind).and_then(|kind| {\n+            tcx.lift(target).map(|target| ty::adjustment::Adjustment { kind, target })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n     type Lifted = ty::adjustment::Adjust<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::adjustment::Adjust::NeverToAny => Some(ty::adjustment::Adjust::NeverToAny),\n             ty::adjustment::Adjust::Pointer(ptr) => Some(ty::adjustment::Adjust::Pointer(ptr)),\n-            ty::adjustment::Adjust::Deref(ref overloaded) => {\n+            ty::adjustment::Adjust::Deref(overloaded) => {\n                 tcx.lift(overloaded).map(ty::adjustment::Adjust::Deref)\n             }\n-            ty::adjustment::Adjust::Borrow(ref autoref) => {\n+            ty::adjustment::Adjust::Borrow(autoref) => {\n                 tcx.lift(autoref).map(ty::adjustment::Adjust::Borrow)\n             }\n         }\n@@ -611,8 +594,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::Adjust<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n     type Lifted = ty::adjustment::OverloadedDeref<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.region).map(|region| ty::adjustment::OverloadedDeref {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.region).map(|region| ty::adjustment::OverloadedDeref {\n             region,\n             mutbl: self.mutbl,\n             span: self.span,\n@@ -622,10 +605,10 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::OverloadedDeref<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n     type Lifted = ty::adjustment::AutoBorrow<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::adjustment::AutoBorrow::Ref(r, m) => {\n-                tcx.lift(&r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n+                tcx.lift(r).map(|r| ty::adjustment::AutoBorrow::Ref(r, m))\n             }\n             ty::adjustment::AutoBorrow::RawPtr(m) => Some(ty::adjustment::AutoBorrow::RawPtr(m)),\n         }\n@@ -634,16 +617,16 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n \n impl<'a, 'tcx> Lift<'tcx> for ty::GenSig<'a> {\n     type Lifted = ty::GenSig<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&(self.resume_ty, self.yield_ty, self.return_ty))\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift((self.resume_ty, self.yield_ty, self.return_ty))\n             .map(|(resume_ty, yield_ty, return_ty)| ty::GenSig { resume_ty, yield_ty, return_ty })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.inputs_and_output).map(|x| ty::FnSig {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(self.inputs_and_output).map(|x| ty::FnSig {\n             inputs_and_output: x,\n             c_variadic: self.c_variadic,\n             unsafety: self.unsafety,\n@@ -654,19 +637,20 @@ impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n \n impl<'tcx, T: Lift<'tcx>> Lift<'tcx> for ty::error::ExpectedFound<T> {\n     type Lifted = ty::error::ExpectedFound<T::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.expected).and_then(|expected| {\n-            tcx.lift(&self.found).map(|found| ty::error::ExpectedFound { expected, found })\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        let ty::error::ExpectedFound { expected, found } = self;\n+        tcx.lift(expected).and_then(|expected| {\n+            tcx.lift(found).map(|found| ty::error::ExpectedFound { expected, found })\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n     type Lifted = ty::error::TypeError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         use crate::ty::error::TypeError::*;\n \n-        Some(match *self {\n+        Some(match self {\n             Mismatch => Mismatch,\n             UnsafetyMismatch(x) => UnsafetyMismatch(x),\n             AbiMismatch(x) => AbiMismatch(x),\n@@ -675,51 +659,51 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             FixedArraySize(x) => FixedArraySize(x),\n             ArgCount => ArgCount,\n             RegionsDoesNotOutlive(a, b) => {\n-                return tcx.lift(&(a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n+                return tcx.lift((a, b)).map(|(a, b)| RegionsDoesNotOutlive(a, b));\n             }\n             RegionsInsufficientlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n+                return tcx.lift(b).map(|b| RegionsInsufficientlyPolymorphic(a, b));\n             }\n             RegionsOverlyPolymorphic(a, b) => {\n-                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b));\n+                return tcx.lift(b).map(|b| RegionsOverlyPolymorphic(a, b));\n             }\n             RegionsPlaceholderMismatch => RegionsPlaceholderMismatch,\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n-            CyclicTy(t) => return tcx.lift(&t).map(|t| CyclicTy(t)),\n-            CyclicConst(ct) => return tcx.lift(&ct).map(|ct| CyclicConst(ct)),\n+            CyclicTy(t) => return tcx.lift(t).map(|t| CyclicTy(t)),\n+            CyclicConst(ct) => return tcx.lift(ct).map(|ct| CyclicConst(ct)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n-            Sorts(ref x) => return tcx.lift(x).map(Sorts),\n-            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n-            ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            Sorts(x) => return tcx.lift(x).map(Sorts),\n+            ExistentialMismatch(x) => return tcx.lift(x).map(ExistentialMismatch),\n+            ConstMismatch(x) => return tcx.lift(x).map(ConstMismatch),\n             IntrinsicCast => IntrinsicCast,\n-            TargetFeatureCast(ref x) => TargetFeatureCast(*x),\n-            ObjectUnsafeCoercion(ref x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n+            TargetFeatureCast(x) => TargetFeatureCast(x),\n+            ObjectUnsafeCoercion(x) => return tcx.lift(x).map(ObjectUnsafeCoercion),\n         })\n     }\n }\n \n impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     type Lifted = ty::InstanceDef<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self {\n             ty::InstanceDef::Item(def_id) => Some(ty::InstanceDef::Item(def_id)),\n             ty::InstanceDef::VtableShim(def_id) => Some(ty::InstanceDef::VtableShim(def_id)),\n             ty::InstanceDef::ReifyShim(def_id) => Some(ty::InstanceDef::ReifyShim(def_id)),\n             ty::InstanceDef::Intrinsic(def_id) => Some(ty::InstanceDef::Intrinsic(def_id)),\n-            ty::InstanceDef::FnPtrShim(def_id, ref ty) => {\n+            ty::InstanceDef::FnPtrShim(def_id, ty) => {\n                 Some(ty::InstanceDef::FnPtrShim(def_id, tcx.lift(ty)?))\n             }\n             ty::InstanceDef::Virtual(def_id, n) => Some(ty::InstanceDef::Virtual(def_id, n)),\n             ty::InstanceDef::ClosureOnceShim { call_once } => {\n                 Some(ty::InstanceDef::ClosureOnceShim { call_once })\n             }\n-            ty::InstanceDef::DropGlue(def_id, ref ty) => {\n+            ty::InstanceDef::DropGlue(def_id, ty) => {\n                 Some(ty::InstanceDef::DropGlue(def_id, tcx.lift(ty)?))\n             }\n-            ty::InstanceDef::CloneShim(def_id, ref ty) => {\n+            ty::InstanceDef::CloneShim(def_id, ty) => {\n                 Some(ty::InstanceDef::CloneShim(def_id, tcx.lift(ty)?))\n             }\n         }\n@@ -1056,16 +1040,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     }\n }\n \n-pub(super) trait PredicateVisitor<'tcx>: TypeVisitor<'tcx> {\n-    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool;\n-}\n-\n-impl<T: TypeVisitor<'tcx>> PredicateVisitor<'tcx> for T {\n-    default fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> bool {\n-        predicate.super_visit_with(self)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         fold_list(*self, folder, |tcx, v| tcx.intern_predicates(v))"}, {"sha": "0fd48d0928257990d4fffe2c655380de5ea2de28", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -210,6 +210,18 @@ impl TyKind<'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Get the article (\"a\" or \"an\") to use with this type.\n+    pub fn article(&self) -> &'static str {\n+        match self {\n+            Int(_) | Float(_) | Array(_, _) => \"an\",\n+            Adt(def, _) if def.is_enum() => \"an\",\n+            // This should never happen, but ICEing and causing the user's code\n+            // to not compile felt too harsh.\n+            Error(_) => \"a\",\n+            _ => \"a\",\n+        }\n+    }\n }\n \n // `TyKind` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -703,14 +715,16 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n         use crate::ty::ToPredicate;\n         match self.skip_binder() {\n             ExistentialPredicate::Trait(tr) => {\n-                Binder(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n+                self.rebind(tr).with_self_ty(tcx, self_ty).without_const().to_predicate(tcx)\n             }\n             ExistentialPredicate::Projection(p) => {\n-                Binder(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n+                self.rebind(p.with_self_ty(tcx, self_ty)).to_predicate(tcx)\n             }\n             ExistentialPredicate::AutoTrait(did) => {\n-                let trait_ref =\n-                    Binder(ty::TraitRef { def_id: did, substs: tcx.mk_substs_trait(self_ty, &[]) });\n+                let trait_ref = self.rebind(ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n                 trait_ref.without_const().to_predicate(tcx)\n             }\n         }\n@@ -775,7 +789,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n impl<'tcx> Binder<&'tcx List<ExistentialPredicate<'tcx>>> {\n     pub fn principal(&self) -> Option<ty::Binder<ExistentialTraitRef<'tcx>>> {\n-        self.skip_binder().principal().map(Binder::bind)\n+        self.map_bound(|b| b.principal()).transpose()\n     }\n \n     pub fn principal_def_id(&self) -> Option<DefId> {\n@@ -858,8 +872,7 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn to_poly_trait_predicate(&self) -> ty::PolyTraitPredicate<'tcx> {\n-        // Note that we preserve binding levels\n-        Binder(ty::TraitPredicate { trait_ref: self.skip_binder() })\n+        self.map_bound(|trait_ref| ty::TraitPredicate { trait_ref })\n     }\n }\n \n@@ -1001,6 +1014,19 @@ impl<T> Binder<T> {\n         Binder(f(self.0))\n     }\n \n+    /// Wraps a `value` in a binder, using the same bound variables as the\n+    /// current `Binder`. This should not be used if the new value *changes*\n+    /// the bound variables. Note: the (old or new) value itself does not\n+    /// necessarily need to *name* all the bound variables.\n+    ///\n+    /// This currently doesn't do anything different than `bind`, because we\n+    /// don't actually track bound vars. However, semantically, it is different\n+    /// because bound vars aren't allowed to change here, whereas they are\n+    /// in `bind`. This may be (debug) asserted in the future.\n+    pub fn rebind<U>(&self, value: U) -> Binder<U> {\n+        Binder(value)\n+    }\n+\n     /// Unwraps and returns the value within, but only if it contains\n     /// no bound vars at all. (In other words, if this binder --\n     /// and indeed any enclosing binder -- doesn't bind anything at"}, {"sha": "f04144c218e76721872a7ec3b222830d75698782", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -141,11 +141,11 @@ impl<'tcx> GenericArg<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for GenericArg<'a> {\n     type Lifted = GenericArg<'tcx>;\n \n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            GenericArgKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n-            GenericArgKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n-            GenericArgKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n+            GenericArgKind::Lifetime(lt) => tcx.lift(lt).map(|lt| lt.into()),\n+            GenericArgKind::Type(ty) => tcx.lift(ty).map(|ty| ty.into()),\n+            GenericArgKind::Const(ct) => tcx.lift(ct).map(|ct| ct.into()),\n         }\n     }\n }"}, {"sha": "4a20e1c32f99e4c0bb4c0455e928187dbe911b8c", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -529,8 +529,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Make sure that any constants in the static's type are evaluated.\n         let static_ty = self.normalize_erasing_regions(ty::ParamEnv::empty(), self.type_of(def_id));\n \n+        // Make sure that accesses to unsafe statics end up using raw pointers.\n+        // For thread-locals, this needs to be kept in sync with `Rvalue::ty`.\n         if self.is_mutable_static(def_id) {\n             self.mk_mut_ptr(static_ty)\n+        } else if self.is_foreign_item(def_id) {\n+            self.mk_imm_ptr(static_ty)\n         } else {\n             self.mk_imm_ref(self.lifetimes.re_erased, static_ty)\n         }"}, {"sha": "de54c5582e0491a70211e1c9aedbb0167dccf555", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 4, "deletions": 17, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -674,29 +674,16 @@ impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tc\n             TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n-            TerminatorKind::Drop { place: ref drop_place, target: _, unwind: _ } => {\n-                let tcx = self.infcx.tcx;\n-\n-                // Compute the type with accurate region information.\n-                let drop_place_ty = drop_place.ty(self.body, self.infcx.tcx);\n-\n-                // Erase the regions.\n-                let drop_place_ty = self.infcx.tcx.erase_regions(&drop_place_ty).ty;\n-\n-                // \"Lift\" into the tcx -- once regions are erased, this type should be in the\n-                // global arenas; this \"lift\" operation basically just asserts that is true, but\n-                // that is useful later.\n-                tcx.lift(&drop_place_ty).unwrap();\n-\n+            TerminatorKind::Drop { place, target: _, unwind: _ } => {\n                 debug!(\n                     \"visit_terminator_drop \\\n-                     loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\",\n-                    loc, term, drop_place, drop_place_ty, span\n+                     loc: {:?} term: {:?} place: {:?} span: {:?}\",\n+                    loc, term, place, span\n                 );\n \n                 self.access_place(\n                     loc,\n-                    (*drop_place, span),\n+                    (place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,"}, {"sha": "444f9fe8d0a680ae968bd59408983e5f7cca6940", "filename": "compiler/rustc_mir/src/borrow_check/type_check/input_output.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Finput_output.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         // Equate expected input tys with those in the MIR.\n-        for (&normalized_input_ty, argument_index) in normalized_input_tys.iter().zip(0..) {\n+        for (argument_index, &normalized_input_ty) in normalized_input_tys.iter().enumerate() {\n             // In MIR, argument N is stored in local N+1.\n             let local = Local::new(argument_index + 1);\n \n@@ -87,8 +87,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         }\n \n         if let Some(user_provided_sig) = user_provided_sig {\n-            for (&user_provided_input_ty, argument_index) in\n-                user_provided_sig.inputs().iter().zip(0..)\n+            for (argument_index, &user_provided_input_ty) in\n+                user_provided_sig.inputs().iter().enumerate()\n             {\n                 // In MIR, closures begin an implicit `self`, so\n                 // argument N is stored in local N+2."}, {"sha": "7e2cae094811a07ccc69b533b764917ce63891ae", "filename": "compiler/rustc_mir/src/const_eval/machine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -70,9 +70,10 @@ impl<'mir, 'tcx> InterpCx<'mir, 'tcx, CompileTimeInterpreter<'mir, 'tcx>> {\n     ) -> InterpResult<'tcx> {\n         let def_id = instance.def_id();\n         if Some(def_id) == self.tcx.lang_items().panic_fn()\n+            || Some(def_id) == self.tcx.lang_items().panic_str()\n             || Some(def_id) == self.tcx.lang_items().begin_panic_fn()\n         {\n-            // &'static str\n+            // &str\n             assert!(args.len() == 1);\n \n             let msg_place = self.deref_operand(args[0])?;"}, {"sha": "affeae546b2aafce2fe45d4d558194f428a2d32b", "filename": "compiler/rustc_mir/src/interpret/cast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fcast.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -139,9 +139,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         // # First handle non-scalar source values.\n \n-        // Handle cast from a univariant (ZST) enum.\n+        // Handle cast from a ZST enum (0 or 1 variants).\n         match src.layout.variants {\n             Variants::Single { index } => {\n+                if src.layout.abi.is_uninhabited() {\n+                    // This is dead code, because an uninhabited enum is UB to\n+                    // instantiate.\n+                    throw_ub!(Unreachable);\n+                }\n                 if let Some(discr) = src.layout.ty.discriminant_for_variant(*self.tcx, index) {\n                     assert!(src.layout.is_zst());\n                     let discr_layout = self.layout_of(discr.ty)?;"}, {"sha": "945791eddc8f14cca15694780a76e61f3a2f74e4", "filename": "compiler/rustc_mir/src/interpret/intern.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintern.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -187,6 +187,12 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir\n                 return walked;\n             }\n         }\n+\n+        // ZSTs do not need validation unless they're uninhabited\n+        if mplace.layout.is_zst() && !mplace.layout.abi.is_uninhabited() {\n+            return Ok(());\n+        }\n+\n         self.walk_aggregate(mplace, fields)\n     }\n "}, {"sha": "3c68b1c8355d5f57ada6c68853dc7aff82fabe10", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -117,7 +117,7 @@ impl<Tag: Copy> std::fmt::Display for ImmTy<'tcx, Tag> {\n         ty::tls::with(|tcx| {\n             match self.imm {\n                 Immediate::Scalar(s) => {\n-                    if let Some(ty) = tcx.lift(&self.layout.ty) {\n+                    if let Some(ty) = tcx.lift(self.layout.ty) {\n                         let cx = FmtPrinter::new(tcx, f, Namespace::ValueNS);\n                         p(cx, s, ty)?;\n                         return Ok(());"}, {"sha": "ba7bea4ac54e15b1a206055a7ae9d1c26c43f462", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -74,12 +74,18 @@ impl ConstCx<'mir, 'tcx> {\n \n /// Returns `true` if this `DefId` points to one of the official `panic` lang items.\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n-    Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()\n+    Some(def_id) == tcx.lang_items().panic_fn()\n+        || Some(def_id) == tcx.lang_items().panic_str()\n+        || Some(def_id) == tcx.lang_items().begin_panic_fn()\n }\n \n-pub fn allow_internal_unstable(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+pub fn rustc_allow_const_fn_unstable(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    feature_gate: Symbol,\n+) -> bool {\n     let attrs = tcx.get_attrs(def_id);\n-    attr::allow_internal_unstable(&tcx.sess, attrs)\n+    attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs)\n         .map_or(false, |mut features| features.any(|name| name == feature_gate))\n }\n "}, {"sha": "bd51136b8db586e240d788ae571159fe8017291e", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -224,7 +224,8 @@ impl NonConstOp for CellBorrow {\n }\n \n #[derive(Debug)]\n-pub struct MutBorrow;\n+pub struct MutBorrow(pub hir::BorrowKind);\n+\n impl NonConstOp for MutBorrow {\n     fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n         // Forbid everywhere except in const fn with a feature gate\n@@ -236,22 +237,28 @@ impl NonConstOp for MutBorrow {\n     }\n \n     fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        let raw = match self.0 {\n+            hir::BorrowKind::Raw => \"raw \",\n+            hir::BorrowKind::Ref => \"\",\n+        };\n+\n         let mut err = if ccx.const_kind() == hir::ConstContext::ConstFn {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n                 span,\n-                &format!(\"mutable references are not allowed in {}s\", ccx.const_kind()),\n+                &format!(\"{}mutable references are not allowed in {}s\", raw, ccx.const_kind()),\n             )\n         } else {\n             let mut err = struct_span_err!(\n                 ccx.tcx.sess,\n                 span,\n                 E0764,\n-                \"mutable references are not allowed in {}s\",\n+                \"{}mutable references are not allowed in {}s\",\n+                raw,\n                 ccx.const_kind(),\n             );\n-            err.span_label(span, format!(\"`&mut` is only allowed in `const fn`\"));\n+            err.span_label(span, format!(\"`&{}mut` is only allowed in `const fn`\", raw));\n             err\n         };\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n@@ -270,29 +277,6 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n-// FIXME(ecstaticmorse): Unify this with `MutBorrow`. It has basically the same issues.\n-#[derive(Debug)]\n-pub struct MutAddressOf;\n-impl NonConstOp for MutAddressOf {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n-        // Forbid everywhere except in const fn with a feature gate\n-        if ccx.const_kind() == hir::ConstContext::ConstFn {\n-            Status::Unstable(sym::const_mut_refs)\n-        } else {\n-            Status::Forbidden\n-        }\n-    }\n-\n-    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-        feature_err(\n-            &ccx.tcx.sess.parse_sess,\n-            sym::const_mut_refs,\n-            span,\n-            &format!(\"`&raw mut` is not allowed in {}s\", ccx.const_kind()),\n-        )\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {"}, {"sha": "4139b544998faeb724ce2ff79596e7ea5495aeb8", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -292,7 +292,11 @@ impl Validator<'mir, 'tcx> {\n \n             Status::Unstable(gate) if self.tcx.features().enabled(gate) => {\n                 let unstable_in_stable = self.ccx.is_const_stable_const_fn()\n-                    && !super::allow_internal_unstable(self.tcx, self.def_id().to_def_id(), gate);\n+                    && !super::rustc_allow_const_fn_unstable(\n+                        self.tcx,\n+                        self.def_id().to_def_id(),\n+                        gate,\n+                    );\n                 if unstable_in_stable {\n                     emit_unstable_in_stable_error(self.ccx, span, gate);\n                 }\n@@ -525,14 +529,16 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                 if !is_allowed {\n                     if let BorrowKind::Mut { .. } = kind {\n-                        self.check_op(ops::MutBorrow);\n+                        self.check_op(ops::MutBorrow(hir::BorrowKind::Ref));\n                     } else {\n                         self.check_op(ops::CellBorrow);\n                     }\n                 }\n             }\n \n-            Rvalue::AddressOf(Mutability::Mut, _) => self.check_op(ops::MutAddressOf),\n+            Rvalue::AddressOf(Mutability::Mut, _) => {\n+                self.check_op(ops::MutBorrow(hir::BorrowKind::Raw))\n+            }\n \n             Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n@@ -805,7 +811,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     }\n \n                     // Calling an unstable function *always* requires that the corresponding gate\n-                    // be enabled, even if the function has `#[allow_internal_unstable(the_gate)]`.\n+                    // be enabled, even if the function has `#[rustc_allow_const_fn_unstable(the_gate)]`.\n                     if !tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == gate) {\n                         self.check_op(ops::FnCallUnstable(callee, Some(gate)));\n                         return;\n@@ -819,7 +825,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                     // Otherwise, we are something const-stable calling a const-unstable fn.\n \n-                    if super::allow_internal_unstable(tcx, caller, gate) {\n+                    if super::rustc_allow_const_fn_unstable(tcx, caller, gate) {\n                         return;\n                     }\n \n@@ -965,8 +971,8 @@ fn emit_unstable_in_stable_error(ccx: &ConstCx<'_, '_>, span: Span, gate: Symbol\n         )\n         .span_suggestion(\n             attr_span,\n-            \"otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\",\n-            format!(\"#[allow_internal_unstable({})]\\n\", gate),\n+            \"otherwise `#[rustc_allow_const_fn_unstable]` can be used to bypass stability checks\",\n+            format!(\"#[rustc_allow_const_fn_unstable({})]\\n\", gate),\n             Applicability::MaybeIncorrect,\n         )\n         .emit();"}, {"sha": "3d68b862df2d096138b5e9d30ac6c6c275869824", "filename": "compiler/rustc_mir/src/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_unsafety.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -204,6 +204,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             if let [] = proj_base {\n                 let decl = &self.body.local_decls[place.local];\n                 if decl.internal {\n+                    // If the projection root is an artifical local that we introduced when\n+                    // desugaring `static`, give a more specific error message\n+                    // (avoid the general \"raw pointer\" clause below, that would only be confusing).\n                     if let Some(box LocalInfo::StaticRef { def_id, .. }) = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n                             self.require_unsafe("}, {"sha": "4f44bb7b20476f9a49e947da21e69f6371e08eb8", "filename": "compiler/rustc_mir/src/transform/copy_prop.rs", "status": "removed", "additions": 0, "deletions": 384, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcopy_prop.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,384 +0,0 @@\n-//! Trivial copy propagation pass.\n-//!\n-//! This uses def-use analysis to remove values that have exactly one def and one use, which must\n-//! be an assignment.\n-//!\n-//! To give an example, we look for patterns that look like:\n-//!\n-//!     DEST = SRC\n-//!     ...\n-//!     USE(DEST)\n-//!\n-//! where `DEST` and `SRC` are both locals of some form. We replace that with:\n-//!\n-//!     NOP\n-//!     ...\n-//!     USE(SRC)\n-//!\n-//! The assignment `DEST = SRC` must be (a) the only mutation of `DEST` and (b) the only\n-//! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n-//! future.\n-\n-use crate::transform::MirPass;\n-use crate::util::def_use::DefUseAnalysis;\n-use rustc_middle::mir::visit::MutVisitor;\n-use rustc_middle::mir::{\n-    Body, Constant, Local, LocalKind, Location, Operand, Place, Rvalue, StatementKind,\n-};\n-use rustc_middle::ty::TyCtxt;\n-\n-pub struct CopyPropagation;\n-\n-impl<'tcx> MirPass<'tcx> for CopyPropagation {\n-    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n-        let opts = &tcx.sess.opts.debugging_opts;\n-        // We only run when the MIR optimization level is > 1.\n-        // This avoids a slow pass, and messing up debug info.\n-        // FIXME(76740): This optimization is buggy and can cause unsoundness.\n-        if opts.mir_opt_level <= 1 || !opts.unsound_mir_opts {\n-            return;\n-        }\n-\n-        let mut def_use_analysis = DefUseAnalysis::new(body);\n-        loop {\n-            def_use_analysis.analyze(body);\n-\n-            if eliminate_self_assignments(body, &def_use_analysis) {\n-                def_use_analysis.analyze(body);\n-            }\n-\n-            let mut changed = false;\n-            for dest_local in body.local_decls.indices() {\n-                debug!(\"considering destination local: {:?}\", dest_local);\n-\n-                let action;\n-                let location;\n-                {\n-                    // The destination must have exactly one def.\n-                    let dest_use_info = def_use_analysis.local_info(dest_local);\n-                    let dest_def_count = dest_use_info.def_count_not_including_drop();\n-                    if dest_def_count == 0 {\n-                        debug!(\"  Can't copy-propagate local: dest {:?} undefined\", dest_local);\n-                        continue;\n-                    }\n-                    if dest_def_count > 1 {\n-                        debug!(\n-                            \"  Can't copy-propagate local: dest {:?} defined {} times\",\n-                            dest_local,\n-                            dest_use_info.def_count()\n-                        );\n-                        continue;\n-                    }\n-                    if dest_use_info.use_count() == 0 {\n-                        debug!(\"  Can't copy-propagate local: dest {:?} unused\", dest_local);\n-                        continue;\n-                    }\n-                    // Conservatively gives up if the dest is an argument,\n-                    // because there may be uses of the original argument value.\n-                    // Also gives up on the return place, as we cannot propagate into its implicit\n-                    // use by `return`.\n-                    if matches!(\n-                        body.local_kind(dest_local),\n-                        LocalKind::Arg | LocalKind::ReturnPointer\n-                    ) {\n-                        debug!(\"  Can't copy-propagate local: dest {:?} (argument)\", dest_local);\n-                        continue;\n-                    }\n-                    let dest_place_def = dest_use_info.defs_not_including_drop().next().unwrap();\n-                    location = dest_place_def.location;\n-\n-                    let basic_block = &body[location.block];\n-                    let statement_index = location.statement_index;\n-                    let statement = match basic_block.statements.get(statement_index) {\n-                        Some(statement) => statement,\n-                        None => {\n-                            debug!(\"  Can't copy-propagate local: used in terminator\");\n-                            continue;\n-                        }\n-                    };\n-\n-                    // That use of the source must be an assignment.\n-                    match &statement.kind {\n-                        StatementKind::Assign(box (place, Rvalue::Use(operand))) => {\n-                            if let Some(local) = place.as_local() {\n-                                if local == dest_local {\n-                                    let maybe_action = match operand {\n-                                        Operand::Copy(src_place) | Operand::Move(src_place) => {\n-                                            Action::local_copy(&body, &def_use_analysis, *src_place)\n-                                        }\n-                                        Operand::Constant(ref src_constant) => {\n-                                            Action::constant(src_constant)\n-                                        }\n-                                    };\n-                                    match maybe_action {\n-                                        Some(this_action) => action = this_action,\n-                                        None => continue,\n-                                    }\n-                                } else {\n-                                    debug!(\n-                                        \"  Can't copy-propagate local: source use is not an \\\n-                                    assignment\"\n-                                    );\n-                                    continue;\n-                                }\n-                            } else {\n-                                debug!(\n-                                    \"  Can't copy-propagate local: source use is not an \\\n-                                    assignment\"\n-                                );\n-                                continue;\n-                            }\n-                        }\n-                        _ => {\n-                            debug!(\n-                                \"  Can't copy-propagate local: source use is not an \\\n-                                    assignment\"\n-                            );\n-                            continue;\n-                        }\n-                    }\n-                }\n-\n-                changed =\n-                    action.perform(body, &def_use_analysis, dest_local, location, tcx) || changed;\n-                // FIXME(pcwalton): Update the use-def chains to delete the instructions instead of\n-                // regenerating the chains.\n-                break;\n-            }\n-            if !changed {\n-                break;\n-            }\n-        }\n-    }\n-}\n-\n-fn eliminate_self_assignments(body: &mut Body<'_>, def_use_analysis: &DefUseAnalysis) -> bool {\n-    let mut changed = false;\n-\n-    for dest_local in body.local_decls.indices() {\n-        let dest_use_info = def_use_analysis.local_info(dest_local);\n-\n-        for def in dest_use_info.defs_not_including_drop() {\n-            let location = def.location;\n-            if let Some(stmt) = body[location.block].statements.get(location.statement_index) {\n-                match &stmt.kind {\n-                    StatementKind::Assign(box (\n-                        place,\n-                        Rvalue::Use(Operand::Copy(src_place) | Operand::Move(src_place)),\n-                    )) => {\n-                        if let (Some(local), Some(src_local)) =\n-                            (place.as_local(), src_place.as_local())\n-                        {\n-                            if local == dest_local && dest_local == src_local {\n-                            } else {\n-                                continue;\n-                            }\n-                        } else {\n-                            continue;\n-                        }\n-                    }\n-                    _ => {\n-                        continue;\n-                    }\n-                }\n-            } else {\n-                continue;\n-            }\n-            debug!(\"deleting a self-assignment for {:?}\", dest_local);\n-            body.make_statement_nop(location);\n-            changed = true;\n-        }\n-    }\n-\n-    changed\n-}\n-\n-enum Action<'tcx> {\n-    PropagateLocalCopy(Local),\n-    PropagateConstant(Constant<'tcx>),\n-}\n-\n-impl<'tcx> Action<'tcx> {\n-    fn local_copy(\n-        body: &Body<'tcx>,\n-        def_use_analysis: &DefUseAnalysis,\n-        src_place: Place<'tcx>,\n-    ) -> Option<Action<'tcx>> {\n-        // The source must be a local.\n-        let src_local = if let Some(local) = src_place.as_local() {\n-            local\n-        } else {\n-            debug!(\"  Can't copy-propagate local: source is not a local\");\n-            return None;\n-        };\n-\n-        // We're trying to copy propagate a local.\n-        // There must be exactly one use of the source used in a statement (not in a terminator).\n-        let src_use_info = def_use_analysis.local_info(src_local);\n-        let src_use_count = src_use_info.use_count();\n-        if src_use_count == 0 {\n-            debug!(\"  Can't copy-propagate local: no uses\");\n-            return None;\n-        }\n-        if src_use_count != 1 {\n-            debug!(\"  Can't copy-propagate local: {} uses\", src_use_info.use_count());\n-            return None;\n-        }\n-\n-        // Verify that the source doesn't change in between. This is done conservatively for now,\n-        // by ensuring that the source has exactly one mutation. The goal is to prevent things\n-        // like:\n-        //\n-        //     DEST = SRC;\n-        //     SRC = X;\n-        //     USE(DEST);\n-        //\n-        // From being misoptimized into:\n-        //\n-        //     SRC = X;\n-        //     USE(SRC);\n-        let src_def_count = src_use_info.def_count_not_including_drop();\n-        // allow function arguments to be propagated\n-        let is_arg = body.local_kind(src_local) == LocalKind::Arg;\n-        if (is_arg && src_def_count != 0) || (!is_arg && src_def_count != 1) {\n-            debug!(\n-                \"  Can't copy-propagate local: {} defs of src{}\",\n-                src_def_count,\n-                if is_arg { \" (argument)\" } else { \"\" },\n-            );\n-            return None;\n-        }\n-\n-        Some(Action::PropagateLocalCopy(src_local))\n-    }\n-\n-    fn constant(src_constant: &Constant<'tcx>) -> Option<Action<'tcx>> {\n-        Some(Action::PropagateConstant(*src_constant))\n-    }\n-\n-    fn perform(\n-        self,\n-        body: &mut Body<'tcx>,\n-        def_use_analysis: &DefUseAnalysis,\n-        dest_local: Local,\n-        location: Location,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> bool {\n-        match self {\n-            Action::PropagateLocalCopy(src_local) => {\n-                // Eliminate the destination and the assignment.\n-                //\n-                // First, remove all markers.\n-                //\n-                // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n-                debug!(\"  Replacing all uses of {:?} with {:?} (local)\", dest_local, src_local);\n-                for place_use in &def_use_analysis.local_info(dest_local).defs_and_uses {\n-                    if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n-                    }\n-                }\n-                for place_use in &def_use_analysis.local_info(src_local).defs_and_uses {\n-                    if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n-                    }\n-                }\n-\n-                // Replace all uses of the destination local with the source local.\n-                def_use_analysis.replace_all_defs_and_uses_with(dest_local, body, src_local, tcx);\n-\n-                // Finally, zap the now-useless assignment instruction.\n-                debug!(\"  Deleting assignment\");\n-                body.make_statement_nop(location);\n-\n-                true\n-            }\n-            Action::PropagateConstant(src_constant) => {\n-                // First, remove all markers.\n-                //\n-                // FIXME(pcwalton): Don't do this. Merge live ranges instead.\n-                debug!(\n-                    \"  Replacing all uses of {:?} with {:?} (constant)\",\n-                    dest_local, src_constant\n-                );\n-                let dest_local_info = def_use_analysis.local_info(dest_local);\n-                for place_use in &dest_local_info.defs_and_uses {\n-                    if place_use.context.is_storage_marker() {\n-                        body.make_statement_nop(place_use.location)\n-                    }\n-                }\n-\n-                // Replace all uses of the destination local with the constant.\n-                let mut visitor = ConstantPropagationVisitor::new(dest_local, src_constant, tcx);\n-                for dest_place_use in &dest_local_info.defs_and_uses {\n-                    visitor.visit_location(body, dest_place_use.location)\n-                }\n-\n-                // Zap the assignment instruction if we eliminated all the uses. We won't have been\n-                // able to do that if the destination was used in a projection, because projections\n-                // must have places on their LHS.\n-                let use_count = dest_local_info.use_count();\n-                if visitor.uses_replaced == use_count {\n-                    debug!(\n-                        \"  {} of {} use(s) replaced; deleting assignment\",\n-                        visitor.uses_replaced, use_count\n-                    );\n-                    body.make_statement_nop(location);\n-                    true\n-                } else if visitor.uses_replaced == 0 {\n-                    debug!(\"  No uses replaced; not deleting assignment\");\n-                    false\n-                } else {\n-                    debug!(\n-                        \"  {} of {} use(s) replaced; not deleting assignment\",\n-                        visitor.uses_replaced, use_count\n-                    );\n-                    true\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-struct ConstantPropagationVisitor<'tcx> {\n-    dest_local: Local,\n-    constant: Constant<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    uses_replaced: usize,\n-}\n-\n-impl<'tcx> ConstantPropagationVisitor<'tcx> {\n-    fn new(\n-        dest_local: Local,\n-        constant: Constant<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> ConstantPropagationVisitor<'tcx> {\n-        ConstantPropagationVisitor { dest_local, constant, tcx, uses_replaced: 0 }\n-    }\n-}\n-\n-impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn visit_operand(&mut self, operand: &mut Operand<'tcx>, location: Location) {\n-        self.super_operand(operand, location);\n-\n-        match operand {\n-            Operand::Copy(place) | Operand::Move(place) => {\n-                if let Some(local) = place.as_local() {\n-                    if local == self.dest_local {\n-                    } else {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            }\n-            _ => return,\n-        }\n-\n-        *operand = Operand::Constant(box self.constant);\n-        self.uses_replaced += 1\n-    }\n-}"}, {"sha": "796ad6c9c2978d9487deab33e95bb1ca8d31779d", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -201,9 +201,13 @@ impl Inliner<'tcx> {\n         let terminator = bb_data.terminator();\n         if let TerminatorKind::Call { func: ref op, .. } = terminator.kind {\n             if let ty::FnDef(callee_def_id, substs) = *op.ty(caller_body, self.tcx).kind() {\n-                let instance = Instance::resolve(self.tcx, self.param_env, callee_def_id, substs)\n-                    .ok()\n-                    .flatten()?;\n+                // To resolve an instance its substs have to be fully normalized, so\n+                // we do this here.\n+                let normalized_substs = self.tcx.normalize_erasing_regions(self.param_env, substs);\n+                let instance =\n+                    Instance::resolve(self.tcx, self.param_env, callee_def_id, normalized_substs)\n+                        .ok()\n+                        .flatten()?;\n \n                 if let InstanceDef::Virtual(..) = instance.def {\n                     return None;"}, {"sha": "c0b3d5ff18b5c99e9f8fd10ba882e36b21e8843e", "filename": "compiler/rustc_mir/src/transform/instcombine.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstcombine.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -119,6 +119,11 @@ impl OptimizationFinder<'b, 'tcx> {\n     }\n \n     fn find_deref_of_address(&mut self, rvalue: &Rvalue<'tcx>, location: Location) -> Option<()> {\n+        // FIXME(#78192): This optimization can result in unsoundness.\n+        if !self.tcx.sess.opts.debugging_opts.unsound_mir_opts {\n+            return None;\n+        }\n+\n         // Look for the sequence\n         //\n         // _2 = &_1;"}, {"sha": "6824c73ab60a05f69ffa00f1813b6c709469890c", "filename": "compiler/rustc_mir/src/transform/instrument_coverage.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finstrument_coverage.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -22,9 +22,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::def_id::DefId;\n use rustc_span::source_map::original_sp;\n-use rustc_span::{\n-    BytePos, CharPos, FileName, Pos, RealFileName, SourceFile, Span, Symbol, SyntaxContext,\n-};\n+use rustc_span::{BytePos, CharPos, Pos, SourceFile, Span, Symbol, SyntaxContext};\n \n use std::cmp::Ordering;\n \n@@ -549,13 +547,7 @@ impl<'a, 'tcx> Instrumentor<'a, 'tcx> {\n         let mir_body = &self.mir_body;\n         let body_span = self.body_span();\n         let source_file = source_map.lookup_source_file(body_span.lo());\n-        let file_name = match &source_file.name {\n-            FileName::Real(RealFileName::Named(path)) => Symbol::intern(&path.to_string_lossy()),\n-            _ => bug!(\n-                \"source_file.name should be a RealFileName, but it was: {:?}\",\n-                source_file.name\n-            ),\n-        };\n+        let file_name = Symbol::intern(&source_file.name.to_string());\n \n         debug!(\"instrumenting {:?}, span: {}\", def_id, source_map.span_to_string(body_span));\n "}, {"sha": "06690dcbf6eb7aae23c859b953f3272c6b98b4ce", "filename": "compiler/rustc_mir/src/transform/match_branches.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmatch_branches.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -38,12 +38,16 @@ pub struct MatchBranchSimplification;\n \n impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        if tcx.sess.opts.debugging_opts.mir_opt_level <= 1 {\n+            return;\n+        }\n+\n         let param_env = tcx.param_env(body.source.def_id());\n-        let bbs = body.basic_blocks_mut();\n+        let (bbs, local_decls) = body.basic_blocks_and_local_decls_mut();\n         'outer: for bb_idx in bbs.indices() {\n             let (discr, val, switch_ty, first, second) = match bbs[bb_idx].terminator().kind {\n                 TerminatorKind::SwitchInt {\n-                    discr: Operand::Copy(ref place) | Operand::Move(ref place),\n+                    discr: ref discr @ (Operand::Copy(_) | Operand::Move(_)),\n                     switch_ty,\n                     ref targets,\n                     ..\n@@ -52,7 +56,7 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     if target == targets.otherwise() {\n                         continue;\n                     }\n-                    (place, value, switch_ty, target, targets.otherwise())\n+                    (discr, value, switch_ty, target, targets.otherwise())\n                 }\n                 // Only optimize switch int statements\n                 _ => continue,\n@@ -92,6 +96,10 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n             // Take ownership of items now that we know we can optimize.\n             let discr = discr.clone();\n \n+            // Introduce a temporary for the discriminant value.\n+            let source_info = bbs[bb_idx].terminator().source_info;\n+            let discr_local = local_decls.push(LocalDecl::new(switch_ty, source_info.span));\n+\n             // We already checked that first and second are different blocks,\n             // and bb_idx has a different terminator from both of them.\n             let (from, first, second) = bbs.pick3_mut(bb_idx, first, second);\n@@ -120,7 +128,11 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                                 rustc_span::DUMMY_SP,\n                             );\n                             let op = if f_b { BinOp::Eq } else { BinOp::Ne };\n-                            let rhs = Rvalue::BinaryOp(op, Operand::Copy(discr.clone()), const_cmp);\n+                            let rhs = Rvalue::BinaryOp(\n+                                op,\n+                                Operand::Copy(Place::from(discr_local)),\n+                                const_cmp,\n+                            );\n                             Statement {\n                                 source_info: f.source_info,\n                                 kind: StatementKind::Assign(box (*lhs, rhs)),\n@@ -131,7 +143,16 @@ impl<'tcx> MirPass<'tcx> for MatchBranchSimplification {\n                     _ => unreachable!(),\n                 }\n             });\n+\n+            from.statements\n+                .push(Statement { source_info, kind: StatementKind::StorageLive(discr_local) });\n+            from.statements.push(Statement {\n+                source_info,\n+                kind: StatementKind::Assign(box (Place::from(discr_local), Rvalue::Use(discr))),\n+            });\n             from.statements.extend(new_stmts);\n+            from.statements\n+                .push(Statement { source_info, kind: StatementKind::StorageDead(discr_local) });\n             from.terminator_mut().kind = first.terminator().kind.clone();\n         }\n     }"}, {"sha": "20b8c90a9dcad2bc8b669364162a69650d9188e7", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -22,7 +22,6 @@ pub mod check_packed_ref;\n pub mod check_unsafety;\n pub mod cleanup_post_borrowck;\n pub mod const_prop;\n-pub mod copy_prop;\n pub mod deaggregator;\n pub mod dest_prop;\n pub mod dump_mir;\n@@ -401,8 +400,7 @@ fn run_optimization_passes<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         &simplify_try::SimplifyArmIdentity,\n         &simplify_try::SimplifyBranchSame,\n         &dest_prop::DestinationPropagation,\n-        &copy_prop::CopyPropagation,\n-        &simplify_branches::SimplifyBranches::new(\"after-copy-prop\"),\n+        &simplify_branches::SimplifyBranches::new(\"final\"),\n         &remove_noop_landing_pads::RemoveNoopLandingPads,\n         &simplify::SimplifyCfg::new(\"final\"),\n         &nrvo::RenameReturnPlace,"}, {"sha": "292380d7fec2d638d7ffc9010ef77a81ae51926e", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -301,17 +301,6 @@ impl std::ops::Deref for Validator<'a, 'tcx> {\n struct Unpromotable;\n \n impl<'tcx> Validator<'_, 'tcx> {\n-    /// Determines if this code could be executed at runtime and thus is subject to codegen.\n-    /// That means even unused constants need to be evaluated.\n-    ///\n-    /// `const_kind` should not be used in this file other than through this method!\n-    fn maybe_runtime(&self) -> bool {\n-        match self.const_kind {\n-            None | Some(hir::ConstContext::ConstFn) => true,\n-            Some(hir::ConstContext::Static(_) | hir::ConstContext::Const) => false,\n-        }\n-    }\n-\n     fn validate_candidate(&self, candidate: Candidate) -> Result<(), Unpromotable> {\n         match candidate {\n             Candidate::Ref(loc) => {\n@@ -562,14 +551,12 @@ impl<'tcx> Validator<'_, 'tcx> {\n                     }\n \n                     ProjectionElem::Field(..) => {\n-                        if self.maybe_runtime() {\n-                            let base_ty =\n-                                Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n-                            if let Some(def) = base_ty.ty_adt_def() {\n-                                // No promotion of union field accesses.\n-                                if def.is_union() {\n-                                    return Err(Unpromotable);\n-                                }\n+                        let base_ty =\n+                            Place::ty_from(place.local, proj_base, self.body, self.tcx).ty;\n+                        if let Some(def) = base_ty.ty_adt_def() {\n+                            // No promotion of union field accesses.\n+                            if def.is_union() {\n+                                return Err(Unpromotable);\n                             }\n                         }\n                     }\n@@ -751,7 +738,14 @@ impl<'tcx> Validator<'_, 'tcx> {\n     ) -> Result<(), Unpromotable> {\n         let fn_ty = callee.ty(self.body, self.tcx);\n \n-        if !self.explicit && self.maybe_runtime() {\n+        // When doing explicit promotion and inside const/static items, we promote all (eligible) function calls.\n+        // Everywhere else, we require `#[rustc_promotable]` on the callee.\n+        let promote_all_const_fn = self.explicit\n+            || matches!(\n+                self.const_kind,\n+                Some(hir::ConstContext::Static(_) | hir::ConstContext::Const)\n+            );\n+        if !promote_all_const_fn {\n             if let ty::FnDef(def_id, _) = *fn_ty.kind() {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`."}, {"sha": "a9a45e61a38cbf85c1189dd480bdcadfd43e7ddd", "filename": "compiler/rustc_mir/src/transform/simplify_branches.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fsimplify_branches.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -49,9 +49,10 @@ impl<'tcx> MirPass<'tcx> for SimplifyBranches {\n                 }\n                 TerminatorKind::Assert {\n                     target, cond: Operand::Constant(ref c), expected, ..\n-                } if (c.literal.try_eval_bool(tcx, param_env) == Some(true)) == expected => {\n-                    TerminatorKind::Goto { target }\n-                }\n+                } => match c.literal.try_eval_bool(tcx, param_env) {\n+                    Some(v) if v == expected => TerminatorKind::Goto { target },\n+                    _ => continue,\n+                },\n                 TerminatorKind::FalseEdge { real_target, .. } => {\n                     TerminatorKind::Goto { target: real_target }\n                 }"}, {"sha": "7b22d643ab646c9e193d28ca2824a748d49b22fd", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -5,13 +5,17 @@ use crate::dataflow::{Analysis, ResultsCursor};\n use crate::util::storage::AlwaysLiveLocals;\n \n use super::MirPass;\n-use rustc_middle::mir::visit::{PlaceContext, Visitor};\n+use rustc_middle::mir::{\n+    interpret::Scalar,\n+    visit::{PlaceContext, Visitor},\n+};\n use rustc_middle::mir::{\n     AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, Rvalue,\n     SourceScope, Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n };\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n+use rustc_target::abi::Size;\n \n #[derive(Copy, Clone, Debug)]\n enum EdgeKind {\n@@ -346,7 +350,25 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                         ),\n                     );\n                 }\n-                for (_, target) in targets.iter() {\n+\n+                let target_width = self.tcx.sess.target.pointer_width;\n+\n+                let size = Size::from_bits(match switch_ty.kind() {\n+                    ty::Uint(uint) => uint.normalize(target_width).bit_width().unwrap(),\n+                    ty::Int(int) => int.normalize(target_width).bit_width().unwrap(),\n+                    ty::Char => 32,\n+                    ty::Bool => 1,\n+                    other => bug!(\"unhandled type: {:?}\", other),\n+                });\n+\n+                for (value, target) in targets.iter() {\n+                    if Scalar::<()>::try_from_uint(value, size).is_none() {\n+                        self.fail(\n+                            location,\n+                            format!(\"the value {:#x} is not a proper {:?}\", value, switch_ty),\n+                        )\n+                    }\n+\n                     self.check_edge(location, target, EdgeKind::Normal);\n                 }\n                 self.check_edge(location, targets.otherwise(), EdgeKind::Normal);"}, {"sha": "b4448ead8eb8124f4d304f1653e76514fe1ecb7a", "filename": "compiler/rustc_mir/src/util/def_use.rs", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/compiler%2Frustc_mir%2Fsrc%2Futil%2Fdef_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/compiler%2Frustc_mir%2Fsrc%2Futil%2Fdef_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fdef_use.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,158 +0,0 @@\n-//! Def-use analysis.\n-\n-use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::visit::{MutVisitor, PlaceContext, Visitor};\n-use rustc_middle::mir::{Body, Local, Location, VarDebugInfo};\n-use rustc_middle::ty::TyCtxt;\n-use std::mem;\n-\n-pub struct DefUseAnalysis {\n-    info: IndexVec<Local, Info>,\n-}\n-\n-#[derive(Clone)]\n-pub struct Info {\n-    // FIXME(eddyb) use smallvec where possible.\n-    pub defs_and_uses: Vec<Use>,\n-    var_debug_info_indices: Vec<usize>,\n-}\n-\n-#[derive(Clone)]\n-pub struct Use {\n-    pub context: PlaceContext,\n-    pub location: Location,\n-}\n-\n-impl DefUseAnalysis {\n-    pub fn new(body: &Body<'_>) -> DefUseAnalysis {\n-        DefUseAnalysis { info: IndexVec::from_elem_n(Info::new(), body.local_decls.len()) }\n-    }\n-\n-    pub fn analyze(&mut self, body: &Body<'_>) {\n-        self.clear();\n-\n-        let mut finder = DefUseFinder {\n-            info: mem::take(&mut self.info),\n-            var_debug_info_index: 0,\n-            in_var_debug_info: false,\n-        };\n-        finder.visit_body(&body);\n-        self.info = finder.info\n-    }\n-\n-    fn clear(&mut self) {\n-        for info in &mut self.info {\n-            info.clear();\n-        }\n-    }\n-\n-    pub fn local_info(&self, local: Local) -> &Info {\n-        &self.info[local]\n-    }\n-\n-    fn mutate_defs_and_uses(\n-        &self,\n-        local: Local,\n-        body: &mut Body<'tcx>,\n-        new_local: Local,\n-        tcx: TyCtxt<'tcx>,\n-    ) {\n-        let mut visitor = MutateUseVisitor::new(local, new_local, tcx);\n-        let info = &self.info[local];\n-        for place_use in &info.defs_and_uses {\n-            visitor.visit_location(body, place_use.location)\n-        }\n-        // Update debuginfo as well, alongside defs/uses.\n-        for &i in &info.var_debug_info_indices {\n-            visitor.visit_var_debug_info(&mut body.var_debug_info[i]);\n-        }\n-    }\n-\n-    // FIXME(pcwalton): this should update the def-use chains.\n-    pub fn replace_all_defs_and_uses_with(\n-        &self,\n-        local: Local,\n-        body: &mut Body<'tcx>,\n-        new_local: Local,\n-        tcx: TyCtxt<'tcx>,\n-    ) {\n-        self.mutate_defs_and_uses(local, body, new_local, tcx)\n-    }\n-}\n-\n-struct DefUseFinder {\n-    info: IndexVec<Local, Info>,\n-    var_debug_info_index: usize,\n-    in_var_debug_info: bool,\n-}\n-\n-impl Visitor<'_> for DefUseFinder {\n-    fn visit_local(&mut self, &local: &Local, context: PlaceContext, location: Location) {\n-        let info = &mut self.info[local];\n-        if self.in_var_debug_info {\n-            info.var_debug_info_indices.push(self.var_debug_info_index);\n-        } else {\n-            info.defs_and_uses.push(Use { context, location });\n-        }\n-    }\n-    fn visit_var_debug_info(&mut self, var_debug_info: &VarDebugInfo<'tcx>) {\n-        assert!(!self.in_var_debug_info);\n-        self.in_var_debug_info = true;\n-        self.super_var_debug_info(var_debug_info);\n-        self.in_var_debug_info = false;\n-        self.var_debug_info_index += 1;\n-    }\n-}\n-\n-impl Info {\n-    fn new() -> Info {\n-        Info { defs_and_uses: vec![], var_debug_info_indices: vec![] }\n-    }\n-\n-    fn clear(&mut self) {\n-        self.defs_and_uses.clear();\n-        self.var_debug_info_indices.clear();\n-    }\n-\n-    pub fn def_count(&self) -> usize {\n-        self.defs_and_uses.iter().filter(|place_use| place_use.context.is_mutating_use()).count()\n-    }\n-\n-    pub fn def_count_not_including_drop(&self) -> usize {\n-        self.defs_not_including_drop().count()\n-    }\n-\n-    pub fn defs_not_including_drop(&self) -> impl Iterator<Item = &Use> {\n-        self.defs_and_uses\n-            .iter()\n-            .filter(|place_use| place_use.context.is_mutating_use() && !place_use.context.is_drop())\n-    }\n-\n-    pub fn use_count(&self) -> usize {\n-        self.defs_and_uses.iter().filter(|place_use| place_use.context.is_nonmutating_use()).count()\n-    }\n-}\n-\n-struct MutateUseVisitor<'tcx> {\n-    query: Local,\n-    new_local: Local,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl MutateUseVisitor<'tcx> {\n-    fn new(query: Local, new_local: Local, tcx: TyCtxt<'tcx>) -> MutateUseVisitor<'tcx> {\n-        MutateUseVisitor { query, new_local, tcx }\n-    }\n-}\n-\n-impl MutVisitor<'tcx> for MutateUseVisitor<'tcx> {\n-    fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn visit_local(&mut self, local: &mut Local, _context: PlaceContext, _location: Location) {\n-        if *local == self.query {\n-            *local = self.new_local;\n-        }\n-    }\n-}"}, {"sha": "7da2f4ffe0889891a4bc59b04f87eaf7461148e2", "filename": "compiler/rustc_mir/src/util/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,5 @@\n pub mod aggregate;\n pub mod borrowck_errors;\n-pub mod def_use;\n pub mod elaborate_drops;\n pub mod patch;\n pub mod storage;"}, {"sha": "3a36ad590c506faa0842a51e55a2b2d3ced1645d", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -33,6 +33,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Constant { span, user_ty, literal }\n             }\n             ExprKind::StaticRef { literal, .. } => Constant { span, user_ty: None, literal },\n+            ExprKind::ConstBlock { value } => Constant { span, user_ty: None, literal: value },\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }\n     }"}, {"sha": "443025c4f84581dbd2becaad2a4d962faf084ffd", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -254,6 +254,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Continue { .. }\n             | ExprKind::Return { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::ConstBlock { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::InlineAsm { .. }\n             | ExprKind::LlvmInlineAsm { .. }"}, {"sha": "4033cc6cf46c4ed673f1d5ddfee1508d378d3dfa", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -234,6 +234,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             }\n             ExprKind::Yield { .. }\n             | ExprKind::Literal { .. }\n+            | ExprKind::ConstBlock { .. }\n             | ExprKind::StaticRef { .. }\n             | ExprKind::Block { .. }\n             | ExprKind::Match { .. }"}, {"sha": "ac5cf187aa01bced7ceaf74bc114a1f4d72798bd", "filename": "compiler/rustc_mir_build/src/build/expr/category.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fcategory.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -68,7 +68,9 @@ impl Category {\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::LlvmInlineAsm { .. } => Some(Category::Rvalue(RvalueFunc::AsRvalue)),\n \n-            ExprKind::Literal { .. } | ExprKind::StaticRef { .. } => Some(Category::Constant),\n+            ExprKind::ConstBlock { .. } | ExprKind::Literal { .. } | ExprKind::StaticRef { .. } => {\n+                Some(Category::Constant)\n+            }\n \n             ExprKind::Loop { .. }\n             | ExprKind::Block { .. }"}, {"sha": "a268b0b46ff51980017c5798c7004d78912cd98c", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -454,6 +454,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             | ExprKind::Array { .. }\n             | ExprKind::Tuple { .. }\n             | ExprKind::Closure { .. }\n+            | ExprKind::ConstBlock { .. }\n             | ExprKind::Literal { .. }\n             | ExprKind::ThreadLocalRef(_)\n             | ExprKind::StaticRef { .. } => {"}, {"sha": "899fc647493a0c9f5ef6885967287cb003b1bad5", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -351,9 +351,6 @@ struct Builder<'a, 'tcx> {\n     unit_temp: Option<Place<'tcx>>,\n \n     var_debug_info: Vec<VarDebugInfo<'tcx>>,\n-\n-    /// Cached block with the `UNREACHABLE` terminator.\n-    cached_unreachable_block: Option<BasicBlock>,\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -634,10 +631,6 @@ where\n         builder.cfg.terminate(return_block, source_info, TerminatorKind::Return);\n         let should_abort = should_abort_on_panic(tcx, fn_def_id, abi);\n         builder.build_drop_trees(should_abort);\n-        // Attribute any unreachable codepaths to the function's closing brace\n-        if let Some(unreachable_block) = builder.cached_unreachable_block {\n-            builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n-        }\n         return_block.unit()\n     }));\n \n@@ -676,12 +669,6 @@ fn construct_const<'a, 'tcx>(\n \n     builder.build_drop_trees(false);\n \n-    // Constants may be match expressions in which case an unreachable block may\n-    // be created, so terminate it properly.\n-    if let Some(unreachable_block) = builder.cached_unreachable_block {\n-        builder.cfg.terminate(unreachable_block, source_info, TerminatorKind::Unreachable);\n-    }\n-\n     builder.finish()\n }\n \n@@ -757,7 +744,6 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             var_indices: Default::default(),\n             unit_temp: None,\n             var_debug_info: vec![],\n-            cached_unreachable_block: None,\n         };\n \n         assert_eq!(builder.cfg.start_new_block(), START_BLOCK);"}, {"sha": "576b537c017669140c562cb46a4c6ec6af94703c", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,5 +1,5 @@\n use rustc_data_structures::graph::iterate::{\n-    ControlFlow, NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n+    NodeStatus, TriColorDepthFirstSearch, TriColorVisitor,\n };\n use rustc_hir::intravisit::FnKind;\n use rustc_middle::hir::map::blocks::FnLikeNode;\n@@ -8,6 +8,7 @@ use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n use rustc_middle::ty::{self, AssocItem, AssocItemContainer, Instance, TyCtxt};\n use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n+use std::ops::ControlFlow;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n@@ -71,12 +72,14 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n \n         let func_ty = func.ty(body, tcx);\n         if let ty::FnDef(callee, substs) = *func_ty.kind() {\n-            let (callee, call_substs) =\n-                if let Ok(Some(instance)) = Instance::resolve(tcx, param_env, callee, substs) {\n-                    (instance.def_id(), instance.substs)\n-                } else {\n-                    (callee, substs)\n-                };\n+            let normalized_substs = tcx.normalize_erasing_regions(param_env, substs);\n+            let (callee, call_substs) = if let Ok(Some(instance)) =\n+                Instance::resolve(tcx, param_env, callee, normalized_substs)\n+            {\n+                (instance.def_id(), instance.substs)\n+            } else {\n+                (callee, normalized_substs)\n+            };\n \n             // FIXME(#57965): Make this work across function boundaries\n "}, {"sha": "731bd954246cecf8cdc3cbb54bb244d546d432e8", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -511,6 +511,12 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n             inputs: asm.inputs_exprs.to_ref(),\n         },\n \n+        hir::ExprKind::ConstBlock(ref anon_const) => {\n+            let anon_const_def_id = cx.tcx.hir().local_def_id(anon_const.hir_id);\n+            let value = ty::Const::from_anon_const(cx.tcx, anon_const_def_id);\n+\n+            ExprKind::ConstBlock { value }\n+        }\n         // Now comes the rote stuff:\n         hir::ExprKind::Repeat(ref v, ref count) => {\n             let count_def_id = cx.tcx.hir().local_def_id(count.hir_id);"}, {"sha": "f2a2ef0d8f2bcf5ae8d44ea4eabc05f13c53fdf8", "filename": "compiler/rustc_mir_build/src/thir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -232,6 +232,9 @@ crate enum ExprKind<'tcx> {\n     Return {\n         value: Option<ExprRef<'tcx>>,\n     },\n+    ConstBlock {\n+        value: &'tcx Const<'tcx>,\n+    },\n     Repeat {\n         value: ExprRef<'tcx>,\n         count: &'tcx Const<'tcx>,"}, {"sha": "0449e14983150da08372f98a4c916d97e7777d44", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 143, "deletions": 347, "changes": 490, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -78,20 +78,26 @@\n //! new pattern `p`.\n //!\n //! For example, say we have the following:\n+//!\n //! ```\n-//!     // x: (Option<bool>, Result<()>)\n-//!     match x {\n-//!         (Some(true), _) => {}\n-//!         (None, Err(())) => {}\n-//!         (None, Err(_)) => {}\n-//!     }\n+//! // x: (Option<bool>, Result<()>)\n+//! match x {\n+//!     (Some(true), _) => {}\n+//!     (None, Err(())) => {}\n+//!     (None, Err(_)) => {}\n+//! }\n //! ```\n+//!\n //! Here, the matrix `P` starts as:\n+//!\n+//! ```\n //! [\n //!     [(Some(true), _)],\n //!     [(None, Err(()))],\n //!     [(None, Err(_))],\n //! ]\n+//! ```\n+//!\n //! We can tell it's not exhaustive, because `U(P, _)` is true (we're not covering\n //! `[(Some(false), _)]`, for instance). In addition, row 3 is not useful, because\n //! all the values it covers are already covered by row 2.\n@@ -178,10 +184,14 @@\n //! This special case is handled in `is_useful_specialized`.\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n-//! [Some(true), _],\n-//! [None, 0],\n+//!     [Some(true), _],\n+//!     [None, 0],\n //! ]\n+//! ```\n+//!\n //! and `p` is [Some(false), 0], then we don't care about row 2 since we know `p` only\n //! matches values that row 2 doesn't. For row 1 however, we need to dig into the\n //! arguments of `Some` to know whether some new value is covered. So we compute\n@@ -198,10 +208,14 @@\n //! `U(P, p) := U(D(P), D(p))`\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n //!     [_, true, _],\n //!     [None, false, 1],\n //! ]\n+//! ```\n+//!\n //! and `p` is [_, false, _], the `Some` constructor doesn't appear in `P`. So if we\n //! only had row 2, we'd know that `p` is useful. However row 1 starts with a\n //! wildcard, so we need to check whether `U([[true, _]], [false, 1])`.\n@@ -215,10 +229,14 @@\n //! `U(P, p) := \u2203(k \u03f5 constructors) U(S(k, P), S(k, p))`\n //!\n //! For example, if `P` is:\n+//!\n+//! ```\n //! [\n //!     [Some(true), _],\n //!     [None, false],\n //! ]\n+//! ```\n+//!\n //! and `p` is [_, false], both `None` and `Some` constructors appear in the first\n //! components of `P`. We will therefore try popping both constructors in turn: we\n //! compute `U([[true, _]], [_, false])` for the `Some` constructor, and `U([[false]],\n@@ -284,10 +302,9 @@ use super::{FieldPat, Pat, PatKind, PatRange};\n \n use rustc_arena::TypedArena;\n use rustc_attr::{SignedInt, UnsignedInt};\n-use rustc_errors::ErrorReported;\n use rustc_hir::def_id::DefId;\n use rustc_hir::{HirId, RangeEnd};\n-use rustc_middle::mir::interpret::{truncate, AllocId, ConstValue, Pointer, Scalar};\n+use rustc_middle::mir::interpret::{truncate, ConstValue};\n use rustc_middle::mir::Field;\n use rustc_middle::ty::layout::IntegerExt;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n@@ -296,108 +313,21 @@ use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n use smallvec::{smallvec, SmallVec};\n-use std::borrow::Cow;\n use std::cmp::{self, max, min, Ordering};\n-use std::convert::TryInto;\n use std::fmt;\n use std::iter::{FromIterator, IntoIterator};\n use std::ops::RangeInclusive;\n \n-crate fn expand_pattern<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>, pat: Pat<'tcx>) -> Pat<'tcx> {\n-    LiteralExpander { tcx: cx.tcx, param_env: cx.param_env }.fold_pattern(&pat)\n-}\n-\n-struct LiteralExpander<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n+crate fn expand_pattern<'tcx>(pat: Pat<'tcx>) -> Pat<'tcx> {\n+    LiteralExpander.fold_pattern(&pat)\n }\n \n-impl<'tcx> LiteralExpander<'tcx> {\n-    /// Derefs `val` and potentially unsizes the value if `crty` is an array and `rty` a slice.\n-    ///\n-    /// `crty` and `rty` can differ because you can use array constants in the presence of slice\n-    /// patterns. So the pattern may end up being a slice, but the constant is an array. We convert\n-    /// the array to a slice in that case.\n-    fn fold_const_value_deref(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-        // the pattern's pointee type\n-        rty: Ty<'tcx>,\n-        // the constant's pointee type\n-        crty: Ty<'tcx>,\n-    ) -> ConstValue<'tcx> {\n-        debug!(\"fold_const_value_deref {:?} {:?} {:?}\", val, rty, crty);\n-        match (val, &crty.kind(), &rty.kind()) {\n-            // the easy case, deref a reference\n-            (ConstValue::Scalar(p), x, y) if x == y => {\n-                match p {\n-                    Scalar::Ptr(p) => {\n-                        let alloc = self.tcx.global_alloc(p.alloc_id).unwrap_memory();\n-                        ConstValue::ByRef { alloc, offset: p.offset }\n-                    }\n-                    Scalar::Raw { .. } => {\n-                        let layout = self.tcx.layout_of(self.param_env.and(rty)).unwrap();\n-                        if layout.is_zst() {\n-                            // Deref of a reference to a ZST is a nop.\n-                            ConstValue::Scalar(Scalar::zst())\n-                        } else {\n-                            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;`\n-                            bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty);\n-                        }\n-                    }\n-                }\n-            }\n-            // unsize array to slice if pattern is array but match value or other patterns are slice\n-            (ConstValue::Scalar(Scalar::Ptr(p)), ty::Array(t, n), ty::Slice(u)) => {\n-                assert_eq!(t, u);\n-                ConstValue::Slice {\n-                    data: self.tcx.global_alloc(p.alloc_id).unwrap_memory(),\n-                    start: p.offset.bytes().try_into().unwrap(),\n-                    end: n.eval_usize(self.tcx, ty::ParamEnv::empty()).try_into().unwrap(),\n-                }\n-            }\n-            // fat pointers stay the same\n-            (ConstValue::Slice { .. }, _, _)\n-            | (_, ty::Slice(_), ty::Slice(_))\n-            | (_, ty::Str, ty::Str) => val,\n-            // FIXME(oli-obk): this is reachable for `const FOO: &&&u32 = &&&42;` being used\n-            _ => bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty),\n-        }\n-    }\n-}\n+struct LiteralExpander;\n \n-impl<'tcx> PatternFolder<'tcx> for LiteralExpander<'tcx> {\n+impl<'tcx> PatternFolder<'tcx> for LiteralExpander {\n     fn fold_pattern(&mut self, pat: &Pat<'tcx>) -> Pat<'tcx> {\n         debug!(\"fold_pattern {:?} {:?} {:?}\", pat, pat.ty.kind(), pat.kind);\n         match (pat.ty.kind(), &*pat.kind) {\n-            (&ty::Ref(_, rty, _), &PatKind::Constant { value: Const { val, ty: const_ty } })\n-                if const_ty.is_ref() =>\n-            {\n-                let crty =\n-                    if let ty::Ref(_, crty, _) = const_ty.kind() { crty } else { unreachable!() };\n-                if let ty::ConstKind::Value(val) = val {\n-                    Pat {\n-                        ty: pat.ty,\n-                        span: pat.span,\n-                        kind: box PatKind::Deref {\n-                            subpattern: Pat {\n-                                ty: rty,\n-                                span: pat.span,\n-                                kind: box PatKind::Constant {\n-                                    value: Const::from_value(\n-                                        self.tcx,\n-                                        self.fold_const_value_deref(*val, rty, crty),\n-                                        rty,\n-                                    ),\n-                                },\n-                            },\n-                        },\n-                    }\n-                } else {\n-                    bug!(\"cannot deref {:#?}, {} -> {}\", val, crty, rty)\n-                }\n-            }\n-\n             (_, &PatKind::Binding { subpattern: Some(ref s), .. }) => s.fold_with(self),\n             (_, &PatKind::AscribeUserType { subpattern: ref s, .. }) => s.fold_with(self),\n             _ => pat.super_fold_with(self),\n@@ -482,9 +412,15 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         cx: &mut MatchCheckCtxt<'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+        is_my_head_ctor: bool,\n     ) -> Option<PatStack<'p, 'tcx>> {\n-        let new_fields =\n-            specialize_one_pattern(cx, self.head(), constructor, ctor_wild_subpatterns)?;\n+        let new_fields = specialize_one_pattern(\n+            cx,\n+            self.head(),\n+            constructor,\n+            ctor_wild_subpatterns,\n+            is_my_head_ctor,\n+        )?;\n         Some(new_fields.push_on_patstack(&self.0[1..]))\n     }\n }\n@@ -662,6 +598,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                                 cx,\n                                 constructor,\n                                 ctor_wild_subpatterns,\n+                                false,\n                             )\n                         })\n                         .collect()\n@@ -687,7 +624,9 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n             SpecializationCache::Incompatible => self\n                 .patterns\n                 .iter()\n-                .filter_map(|r| r.specialize_constructor(cx, constructor, ctor_wild_subpatterns))\n+                .filter_map(|r| {\n+                    r.specialize_constructor(cx, constructor, ctor_wild_subpatterns, false)\n+                })\n                 .collect(),\n         }\n     }\n@@ -707,6 +646,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n /// +++++++++++++++++++++++++++++\n /// + _     + [_, _, tail @ ..] +\n /// +++++++++++++++++++++++++++++\n+/// ```\n impl<'p, 'tcx> fmt::Debug for Matrix<'p, 'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"\\n\")?;\n@@ -908,42 +848,30 @@ enum Constructor<'tcx> {\n     Single,\n     /// Enum variants.\n     Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(&'tcx ty::Const<'tcx>),\n     /// Ranges of integer literal values (`2`, `2..=5` or `2..5`).\n     IntRange(IntRange<'tcx>),\n     /// Ranges of floating-point literal values (`2.0..=5.2`).\n     FloatRange(&'tcx ty::Const<'tcx>, &'tcx ty::Const<'tcx>, RangeEnd),\n+    /// String literals. Strings are not quite the same as `&[u8]` so we treat them separately.\n+    Str(&'tcx ty::Const<'tcx>),\n     /// Array and slice patterns.\n     Slice(Slice),\n+    /// Constants that must not be matched structurally. They are treated as black\n+    /// boxes for the purposes of exhaustiveness: we must not inspect them, and they\n+    /// don't count towards making a match exhaustive.\n+    Opaque,\n     /// Fake extra constructor for enums that aren't allowed to be matched exhaustively.\n     NonExhaustive,\n }\n \n impl<'tcx> Constructor<'tcx> {\n-    fn is_slice(&self) -> bool {\n-        match self {\n-            Slice(_) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    fn variant_index_for_adt<'a>(\n-        &self,\n-        cx: &MatchCheckCtxt<'a, 'tcx>,\n-        adt: &'tcx ty::AdtDef,\n-    ) -> VariantIdx {\n+    fn variant_index_for_adt(&self, adt: &'tcx ty::AdtDef) -> VariantIdx {\n         match *self {\n             Variant(id) => adt.variant_index_with_id(id),\n             Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n             }\n-            ConstantValue(c) => cx\n-                .tcx\n-                .destructure_const(cx.param_env.and(c))\n-                .variant\n-                .expect(\"destructed const of adt without variant id\"),\n             _ => bug!(\"bad constructor {:?} for adt {:?}\", self, adt),\n         }\n     }\n@@ -957,16 +885,14 @@ impl<'tcx> Constructor<'tcx> {\n \n         match self {\n             // Those constructors can only match themselves.\n-            Single | Variant(_) | ConstantValue(..) | FloatRange(..) => {\n+            Single | Variant(_) | Str(..) | FloatRange(..) => {\n                 if other_ctors.iter().any(|c| c == self) { vec![] } else { vec![self.clone()] }\n             }\n             &Slice(slice) => {\n                 let mut other_slices = other_ctors\n                     .iter()\n                     .filter_map(|c: &Constructor<'_>| match c {\n                         Slice(slice) => Some(*slice),\n-                        // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                        ConstantValue(..) => None,\n                         _ => bug!(\"bad slice pattern constructor {:?}\", c),\n                     })\n                     .map(Slice::value_kind);\n@@ -1030,6 +956,7 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             // This constructor is never covered by anything else\n             NonExhaustive => vec![NonExhaustive],\n+            Opaque => bug!(\"unexpected opaque ctor {:?} found in all_ctors\", self),\n         }\n     }\n \n@@ -1069,7 +996,7 @@ impl<'tcx> Constructor<'tcx> {\n                             PatKind::Variant {\n                                 adt_def: adt,\n                                 substs,\n-                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                variant_index: self.variant_index_for_adt(adt),\n                                 subpatterns,\n                             }\n                         } else {\n@@ -1108,10 +1035,11 @@ impl<'tcx> Constructor<'tcx> {\n                     PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n             },\n-            &ConstantValue(value) => PatKind::Constant { value },\n+            &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n             IntRange(range) => return range.to_pat(cx.tcx),\n             NonExhaustive => PatKind::Wild,\n+            Opaque => bug!(\"we should not try to apply an opaque constructor {:?}\", self),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n@@ -1186,12 +1114,6 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n         Fields::Slice(std::slice::from_ref(pat))\n     }\n \n-    /// Construct a new `Fields` from the given patterns. You must be sure those patterns can't\n-    /// contain fields that need to be filtered out. When in doubt, prefer `replace_fields`.\n-    fn from_slice_unfiltered(pats: &'p [Pat<'tcx>]) -> Self {\n-        Fields::Slice(pats)\n-    }\n-\n     /// Convenience; internal use.\n     fn wildcards_from_tys(\n         cx: &MatchCheckCtxt<'p, 'tcx>,\n@@ -1221,7 +1143,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                         // Use T as the sub pattern type of Box<T>.\n                         Fields::from_single_pattern(wildcard_from_ty(substs.type_at(0)))\n                     } else {\n-                        let variant = &adt.variants[constructor.variant_index_for_adt(cx, adt)];\n+                        let variant = &adt.variants[constructor.variant_index_for_adt(adt)];\n                         // Whether we must not match the fields of this variant exhaustively.\n                         let is_non_exhaustive =\n                             variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n@@ -1269,7 +1191,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            ConstantValue(..) | FloatRange(..) | IntRange(..) | NonExhaustive => Fields::empty(),\n+            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque => Fields::empty(),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n         ret\n@@ -1496,6 +1418,7 @@ struct PatCtxt<'tcx> {\n /// multiple patterns.\n ///\n /// For example, if we are constructing a witness for the match against\n+///\n /// ```\n /// struct Pair(Option<(u32, u32)>, bool);\n ///\n@@ -1581,9 +1504,7 @@ fn all_constructors<'a, 'tcx>(\n         )\n     };\n     match *pcx.ty.kind() {\n-        ty::Bool => {\n-            [true, false].iter().map(|&b| ConstantValue(ty::Const::from_bool(cx.tcx, b))).collect()\n-        }\n+        ty::Bool => vec![make_range(0, 1)],\n         ty::Array(ref sub_ty, len) if len.try_eval_usize(cx.tcx, cx.param_env).is_some() => {\n             let len = len.eval_usize(cx.tcx, cx.param_env);\n             if len != 0 && cx.is_uninhabited(sub_ty) {\n@@ -1619,12 +1540,14 @@ fn all_constructors<'a, 'tcx>(\n             // actually match against them all themselves. So we always return only the fictitious\n             // constructor.\n             // E.g., in an example like:\n+            //\n             // ```\n             //     let err: io::ErrorKind = ...;\n             //     match err {\n             //         io::ErrorKind::NotFound => {},\n             //     }\n             // ```\n+            //\n             // we don't want to show every possible IO error, but instead have only `_` as the\n             // witness.\n             let is_declared_nonexhaustive = cx.is_foreign_non_exhaustive_enum(pcx.ty);\n@@ -1696,7 +1619,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn is_integral(ty: Ty<'_>) -> bool {\n         match ty.kind() {\n-            ty::Char | ty::Int(_) | ty::Uint(_) => true,\n+            ty::Char | ty::Int(_) | ty::Uint(_) | ty::Bool => true,\n             _ => false,\n         }\n     }\n@@ -1718,6 +1641,7 @@ impl<'tcx> IntRange<'tcx> {\n     #[inline]\n     fn integral_size_and_signed_bias(tcx: TyCtxt<'tcx>, ty: Ty<'_>) -> Option<(Size, u128)> {\n         match *ty.kind() {\n+            ty::Bool => Some((Size::from_bytes(1), 0)),\n             ty::Char => Some((Size::from_bytes(4), 0)),\n             ty::Int(ity) => {\n                 let size = Integer::from_attr(&tcx, SignedInt(ity)).size();\n@@ -2017,6 +1941,7 @@ crate fn is_useful<'p, 'tcx>(\n         let mut unreachable_branches = Vec::new();\n         // Subpatterns that are unreachable from all branches. E.g. in the following case, the last\n         // `true` is unreachable only from one branch, so it is overall reachable.\n+        //\n         // ```\n         // match (true, true) {\n         //     (true, true) => {}\n@@ -2161,10 +2086,12 @@ crate fn is_useful<'p, 'tcx>(\n             // to do this and instead report a single `_` witness:\n             // if the user didn't actually specify a constructor\n             // in this arm, e.g., in\n+            //\n             // ```\n             //     let x: (Direction, Direction, bool) = ...;\n             //     let (_, _, false) = x;\n             // ```\n+            //\n             // we don't want to show all 16 possible witnesses\n             // `(<direction-1>, <direction-2>, true)` - we are\n             // satisfied with `(_, _, true)`. In this case,\n@@ -2206,7 +2133,7 @@ fn is_useful_specialized<'p, 'tcx>(\n     // We cache the result of `Fields::wildcards` because it is used a lot.\n     let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n     let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns)\n+    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns, true)\n         .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n         .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n@@ -2231,18 +2158,13 @@ fn pat_constructor<'tcx>(\n             if let Some(int_range) = IntRange::from_const(tcx, param_env, value, pat.span) {\n                 Some(IntRange(int_range))\n             } else {\n-                match (value.val, &value.ty.kind()) {\n-                    (_, ty::Array(_, n)) => {\n-                        let len = n.eval_usize(tcx, param_env);\n-                        Some(Slice(Slice { array_len: Some(len), kind: FixedLen(len) }))\n-                    }\n-                    (ty::ConstKind::Value(ConstValue::Slice { start, end, .. }), ty::Slice(_)) => {\n-                        let len = (end - start) as u64;\n-                        Some(Slice(Slice { array_len: None, kind: FixedLen(len) }))\n-                    }\n-                    // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                    // (ty::ConstKind::Value(ConstValue::ByRef { .. }), ty::Slice(_)) => { ... }\n-                    _ => Some(ConstantValue(value)),\n+                match value.ty.kind() {\n+                    ty::Float(_) => Some(FloatRange(value, value, RangeEnd::Included)),\n+                    ty::Ref(_, t, _) if t.is_str() => Some(Str(value)),\n+                    // All constants that can be structurally matched have already been expanded\n+                    // into the corresponding `Pat`s by `const_to_pat`. Constants that remain are\n+                    // opaque.\n+                    _ => Some(Opaque),\n                 }\n             }\n         }\n@@ -2278,75 +2200,6 @@ fn pat_constructor<'tcx>(\n     }\n }\n \n-// checks whether a constant is equal to a user-written slice pattern. Only supports byte slices,\n-// meaning all other types will compare unequal and thus equal patterns often do not cause the\n-// second pattern to lint about unreachable match arms.\n-fn slice_pat_covered_by_const<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    _span: Span,\n-    const_val: &'tcx ty::Const<'tcx>,\n-    prefix: &[Pat<'tcx>],\n-    slice: &Option<Pat<'tcx>>,\n-    suffix: &[Pat<'tcx>],\n-    param_env: ty::ParamEnv<'tcx>,\n-) -> Result<bool, ErrorReported> {\n-    let const_val_val = if let ty::ConstKind::Value(val) = const_val.val {\n-        val\n-    } else {\n-        bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        )\n-    };\n-\n-    let data: &[u8] = match (const_val_val, &const_val.ty.kind()) {\n-        (ConstValue::ByRef { offset, alloc, .. }, ty::Array(t, n)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let n = n.eval_usize(tcx, param_env);\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            alloc.get_bytes(&tcx, ptr, Size::from_bytes(n)).unwrap()\n-        }\n-        (ConstValue::Slice { data, start, end }, ty::Slice(t)) => {\n-            assert_eq!(*t, tcx.types.u8);\n-            let ptr = Pointer::new(AllocId(0), Size::from_bytes(start));\n-            data.get_bytes(&tcx, ptr, Size::from_bytes(end - start)).unwrap()\n-        }\n-        // FIXME(oli-obk): create a way to extract fat pointers from ByRef\n-        (_, ty::Slice(_)) => return Ok(false),\n-        _ => bug!(\n-            \"slice_pat_covered_by_const: {:#?}, {:#?}, {:#?}, {:#?}\",\n-            const_val,\n-            prefix,\n-            slice,\n-            suffix,\n-        ),\n-    };\n-\n-    let pat_len = prefix.len() + suffix.len();\n-    if data.len() < pat_len || (slice.is_none() && data.len() > pat_len) {\n-        return Ok(false);\n-    }\n-\n-    for (ch, pat) in data[..prefix.len()]\n-        .iter()\n-        .zip(prefix)\n-        .chain(data[data.len() - suffix.len()..].iter().zip(suffix))\n-    {\n-        if let box PatKind::Constant { value } = pat.kind {\n-            let b = value.eval_bits(tcx, param_env, pat.ty);\n-            assert_eq!(b as u8 as u128, b);\n-            if b as u8 != *ch {\n-                return Ok(false);\n-            }\n-        }\n-    }\n-\n-    Ok(true)\n-}\n-\n /// For exhaustive integer matching, some constructors are grouped within other constructors\n /// (namely integer typed values are grouped within ranges). However, when specialising these\n /// constructors, we want to be specialising for the underlying constructors (the integers), not\n@@ -2644,35 +2497,6 @@ fn lint_overlapping_patterns<'tcx>(\n     }\n }\n \n-fn constructor_covered_by_range<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    ctor: &Constructor<'tcx>,\n-    pat: &Pat<'tcx>,\n-) -> Option<()> {\n-    if let Single = ctor {\n-        return Some(());\n-    }\n-\n-    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n-        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n-        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", pat),\n-    };\n-    let (ctor_from, ctor_to, ctor_end) = match *ctor {\n-        ConstantValue(value) => (value, value, RangeEnd::Included),\n-        FloatRange(from, to, ctor_end) => (from, to, ctor_end),\n-        _ => bug!(\"`constructor_covered_by_range` called with {:?}\", ctor),\n-    };\n-    trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, pat_from, pat_to, ty);\n-\n-    let to = compare_const_vals(tcx, ctor_to, pat_to, param_env, ty)?;\n-    let from = compare_const_vals(tcx, ctor_from, pat_from, param_env, ty)?;\n-    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n-        && (to == Ordering::Less || (pat_end == ctor_end && to == Ordering::Equal));\n-    if intersects { Some(()) } else { None }\n-}\n-\n /// This is the main specialization step. It expands the pattern\n /// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n /// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n@@ -2689,15 +2513,43 @@ fn specialize_one_pattern<'p, 'tcx>(\n     pat: &'p Pat<'tcx>,\n     constructor: &Constructor<'tcx>,\n     ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n+    is_its_own_ctor: bool, // Whether `ctor` is known to be derived from `pat`\n ) -> Option<Fields<'p, 'tcx>> {\n     if let NonExhaustive = constructor {\n-        // Only a wildcard pattern can match the special extra constructor\n+        // Only a wildcard pattern can match the special extra constructor.\n         if !pat.is_wildcard() {\n             return None;\n         }\n         return Some(Fields::empty());\n     }\n \n+    if let Opaque = constructor {\n+        // Only a wildcard pattern can match an opaque constant, unless we're specializing the\n+        // value against its own constructor. That happens when we call\n+        // `v.specialize_constructor(ctor)` with `ctor` obtained from `pat_constructor(v.head())`.\n+        // For example, in the following match, when we are dealing with the third branch, we will\n+        // specialize with an `Opaque` ctor. We want to ignore the second branch because opaque\n+        // constants should not be inspected, but we don't want to ignore the current (third)\n+        // branch, as that would cause us to always conclude that such a branch is unreachable.\n+        // ```rust\n+        // #[derive(PartialEq)]\n+        // struct Foo(i32);\n+        // impl Eq for Foo {}\n+        // const FOO: Foo = Foo(42);\n+        //\n+        // match (Foo(0), true) {\n+        //     (_, true) => {}\n+        //     (FOO, true) => {}\n+        //     (FOO, false) => {}\n+        // }\n+        // ```\n+        if is_its_own_ctor || pat.is_wildcard() {\n+            return Some(Fields::empty());\n+        } else {\n+            return None;\n+        }\n+    }\n+\n     let result = match *pat.kind {\n         PatKind::AscribeUserType { .. } => bug!(), // Handled by `expand_pattern`\n \n@@ -2717,93 +2569,52 @@ fn specialize_one_pattern<'p, 'tcx>(\n \n         PatKind::Deref { ref subpattern } => Some(Fields::from_single_pattern(subpattern)),\n \n-        PatKind::Constant { value } if constructor.is_slice() => {\n-            // We extract an `Option` for the pointer because slices of zero\n-            // elements don't necessarily point to memory, they are usually\n-            // just integers. The only time they should be pointing to memory\n-            // is when they are subslices of nonzero slices.\n-            let (alloc, offset, n, ty) = match value.ty.kind() {\n-                ty::Array(t, n) => {\n-                    let n = n.eval_usize(cx.tcx, cx.param_env);\n-                    // Shortcut for `n == 0` where no matter what `alloc` and `offset` we produce,\n-                    // the result would be exactly what we early return here.\n-                    if n == 0 {\n-                        if ctor_wild_subpatterns.len() as u64 != n {\n-                            return None;\n-                        }\n-                        return Some(Fields::empty());\n-                    }\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::ByRef { offset, alloc, .. }) => {\n-                            (Cow::Borrowed(alloc), offset, n, t)\n-                        }\n-                        _ => span_bug!(pat.span, \"array pattern is {:?}\", value,),\n+        PatKind::Constant { .. } | PatKind::Range { .. } => {\n+            match constructor {\n+                IntRange(ctor) => {\n+                    let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n+                    ctor.intersection(cx.tcx, &pat)?;\n+                    // Constructor splitting should ensure that all intersections we encounter\n+                    // are actually inclusions.\n+                    assert!(ctor.is_subrange(&pat));\n+                }\n+                FloatRange(ctor_from, ctor_to, ctor_end) => {\n+                    let (pat_from, pat_to, pat_end, ty) = match *pat.kind {\n+                        PatKind::Constant { value } => (value, value, RangeEnd::Included, value.ty),\n+                        PatKind::Range(PatRange { lo, hi, end }) => (lo, hi, end, lo.ty),\n+                        _ => unreachable!(), // This is ensured by the branch we're in\n+                    };\n+                    let to = compare_const_vals(cx.tcx, ctor_to, pat_to, cx.param_env, ty)?;\n+                    let from = compare_const_vals(cx.tcx, ctor_from, pat_from, cx.param_env, ty)?;\n+                    let intersects = (from == Ordering::Greater || from == Ordering::Equal)\n+                        && (to == Ordering::Less\n+                            || (pat_end == *ctor_end && to == Ordering::Equal));\n+                    if !intersects {\n+                        return None;\n                     }\n                 }\n-                ty::Slice(t) => {\n-                    match value.val {\n-                        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => {\n-                            let offset = Size::from_bytes(start);\n-                            let n = (end - start) as u64;\n-                            (Cow::Borrowed(data), offset, n, t)\n-                        }\n-                        ty::ConstKind::Value(ConstValue::ByRef { .. }) => {\n-                            // FIXME(oli-obk): implement `deref` for `ConstValue`\n-                            return None;\n-                        }\n+                Str(ctor_value) => {\n+                    let pat_value = match *pat.kind {\n+                        PatKind::Constant { value } => value,\n                         _ => span_bug!(\n                             pat.span,\n-                            \"slice pattern constant must be scalar pair but is {:?}\",\n-                            value,\n+                            \"unexpected range pattern {:?} for constant value ctor\",\n+                            pat\n                         ),\n+                    };\n+\n+                    // FIXME: there's probably a more direct way of comparing for equality\n+                    if compare_const_vals(cx.tcx, ctor_value, pat_value, cx.param_env, pat.ty)?\n+                        != Ordering::Equal\n+                    {\n+                        return None;\n                     }\n                 }\n-                _ => span_bug!(\n-                    pat.span,\n-                    \"unexpected const-val {:?} with ctor {:?}\",\n-                    value,\n-                    constructor,\n-                ),\n-            };\n-            if ctor_wild_subpatterns.len() as u64 != n {\n-                return None;\n-            }\n-\n-            // Convert a constant slice/array pattern to a list of patterns.\n-            let layout = cx.tcx.layout_of(cx.param_env.and(ty)).ok()?;\n-            let ptr = Pointer::new(AllocId(0), offset);\n-            let pats = cx.pattern_arena.alloc_from_iter((0..n).filter_map(|i| {\n-                let ptr = ptr.offset(layout.size * i, &cx.tcx).ok()?;\n-                let scalar = alloc.read_scalar(&cx.tcx, ptr, layout.size).ok()?;\n-                let scalar = scalar.check_init().ok()?;\n-                let value = ty::Const::from_scalar(cx.tcx, scalar, ty);\n-                let pattern = Pat { ty, span: pat.span, kind: box PatKind::Constant { value } };\n-                Some(pattern)\n-            }));\n-            // Ensure none of the dereferences failed.\n-            if pats.len() as u64 != n {\n-                return None;\n-            }\n-            Some(Fields::from_slice_unfiltered(pats))\n-        }\n-\n-        PatKind::Constant { .. } | PatKind::Range { .. } => {\n-            // If the constructor is a:\n-            // - Single value: add a row if the pattern contains the constructor.\n-            // - Range: add a row if the constructor intersects the pattern.\n-            if let IntRange(ctor) = constructor {\n-                let pat = IntRange::from_pat(cx.tcx, cx.param_env, pat)?;\n-                ctor.intersection(cx.tcx, &pat)?;\n-                // Constructor splitting should ensure that all intersections we encounter\n-                // are actually inclusions.\n-                assert!(ctor.is_subrange(&pat));\n-            } else {\n-                // Fallback for non-ranges and ranges that involve\n-                // floating-point numbers, which are not conveniently handled\n-                // by `IntRange`. For these cases, the constructor may not be a\n-                // range so intersection actually devolves into being covered\n-                // by the pattern.\n-                constructor_covered_by_range(cx.tcx, cx.param_env, constructor, pat)?;\n+                _ => {\n+                    // If we reach here, we must be trying to inspect an opaque constant. Thus we skip\n+                    // the row.\n+                    return None;\n+                }\n             }\n             Some(Fields::empty())\n         }\n@@ -2826,21 +2637,6 @@ fn specialize_one_pattern<'p, 'tcx>(\n                 let suffix = suffix.iter().enumerate().map(|(i, p)| (arity - suffix.len() + i, p));\n                 Some(ctor_wild_subpatterns.replace_fields_indexed(prefix.chain(suffix)))\n             }\n-            ConstantValue(cv) => {\n-                match slice_pat_covered_by_const(\n-                    cx.tcx,\n-                    pat.span,\n-                    cv,\n-                    prefix,\n-                    slice,\n-                    suffix,\n-                    cx.param_env,\n-                ) {\n-                    Ok(true) => Some(Fields::empty()),\n-                    Ok(false) => None,\n-                    Err(ErrorReported) => None,\n-                }\n-            }\n             _ => span_bug!(pat.span, \"unexpected ctor {:?} for slice pat\", constructor),\n         },\n "}, {"sha": "30b700a1d4f63e6c0fb6e9dda087d4002b8597c9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -137,7 +137,7 @@ impl<'tcx> MatchVisitor<'_, 'tcx> {\n         patcx.include_lint_checks();\n         let pattern = patcx.lower_pattern(pat);\n         let pattern_ty = pattern.ty;\n-        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(cx, pattern));\n+        let pattern: &_ = cx.pattern_arena.alloc(expand_pattern(pattern));\n         if !patcx.errors.is_empty() {\n             *have_errors = true;\n             patcx.report_inlining_errors(pat.span);"}, {"sha": "6370f8c375b2a91cf5d4cef7018d52f96b6e6aec", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -387,14 +387,16 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n                 // `&str` and `&[u8]` are represented as `ConstValue::Slice`, let's keep using this\n                 // optimization for now.\n                 ty::Str => PatKind::Constant { value: cv },\n-                ty::Slice(elem_ty) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n                 // `b\"foo\"` produces a `&[u8; 3]`, but you can't use constants of array type when\n                 // matching against references, you can only use byte string literals.\n-                // FIXME: clean this up, likely by permitting array patterns when matching on slices\n-                ty::Array(elem_ty, _) if elem_ty == tcx.types.u8 => PatKind::Constant { value: cv },\n+                // The typechecker has a special case for byte string literals, by treating them\n+                // as slices. This means we turn `&[T; N]` constants into slice patterns, which\n+                // has no negative effects on pattern matching, even if we're actually matching on\n+                // arrays.\n+                ty::Array(..) |\n                 // Cannot merge this with the catch all branch below, because the `const_deref`\n-                // changes the type from slice to array, and slice patterns behave differently from\n-                // array patterns.\n+                // changes the type from slice to array, we need to keep the original type in the\n+                // pattern.\n                 ty::Slice(..) => {\n                     let old = self.behind_reference.replace(true);\n                     let array = tcx.deref_const(self.param_env.and(cv));"}, {"sha": "25e187243416d5e412c9b552f3fbc54873739816", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -158,6 +158,13 @@ crate enum PatKind<'tcx> {\n         subpattern: Pat<'tcx>,\n     },\n \n+    /// One of the following:\n+    /// * `&str`, which will be handled as a string pattern and thus exhaustiveness\n+    ///   checking will detect if you use the same string twice in different patterns.\n+    /// * integer, bool, char or float, which will be handled by exhaustivenes to cover exactly\n+    ///   its own value, similar to `&str`, but these values are much simpler.\n+    /// * Opaque constants, that must not be matched structurally. So anything that does not derive\n+    ///   `PartialEq` and `Eq`.\n     Constant {\n         value: &'tcx ty::Const<'tcx>,\n     },\n@@ -856,6 +863,11 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n             *self.lower_path(qpath, expr.hir_id, expr.span).kind\n         } else {\n             let (lit, neg) = match expr.kind {\n+                hir::ExprKind::ConstBlock(ref anon_const) => {\n+                    let anon_const_def_id = self.tcx.hir().local_def_id(anon_const.hir_id);\n+                    let value = ty::Const::from_anon_const(self.tcx, anon_const_def_id);\n+                    return *self.const_to_pat(value, expr.hir_id, expr.span, false).kind;\n+                }\n                 hir::ExprKind::Lit(ref lit) => (lit, false),\n                 hir::ExprKind::Unary(hir::UnOp::UnNeg, ref expr) => {\n                     let lit = match expr.kind {"}, {"sha": "ba416be6b38d3e8589cc0698229f54135bba5004", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 22, "deletions": 58, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast as ast;\n use rustc_ast::token::{self, DelimToken, Nonterminal, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{self, LazyTokenStream, TokenStream, TokenTree};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};\n@@ -22,7 +22,7 @@ use std::str;\n \n use tracing::{debug, info};\n \n-pub const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n+pub const MACRO_ARGUMENTS: Option<&str> = Some(\"macro arguments\");\n \n #[macro_use]\n pub mod parser;\n@@ -248,35 +248,36 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // As a result, some AST nodes are annotated with the token stream they\n     // came from. Here we attempt to extract these lossless token streams\n     // before we fall back to the stringification.\n+\n+    let convert_tokens = |tokens: Option<LazyTokenStream>| tokens.map(|t| t.into_token_stream());\n+\n     let tokens = match *nt {\n-        Nonterminal::NtItem(ref item) => {\n-            prepend_attrs(sess, &item.attrs, item.tokens.as_ref(), span)\n-        }\n-        Nonterminal::NtBlock(ref block) => block.tokens.clone(),\n+        Nonterminal::NtItem(ref item) => prepend_attrs(&item.attrs, item.tokens.as_ref()),\n+        Nonterminal::NtBlock(ref block) => convert_tokens(block.tokens.clone()),\n         Nonterminal::NtStmt(ref stmt) => {\n             // FIXME: We currently only collect tokens for `:stmt`\n             // matchers in `macro_rules!` macros. When we start collecting\n             // tokens for attributes on statements, we will need to prepend\n             // attributes here\n-            stmt.tokens.clone()\n+            convert_tokens(stmt.tokens.clone())\n         }\n-        Nonterminal::NtPat(ref pat) => pat.tokens.clone(),\n-        Nonterminal::NtTy(ref ty) => ty.tokens.clone(),\n+        Nonterminal::NtPat(ref pat) => convert_tokens(pat.tokens.clone()),\n+        Nonterminal::NtTy(ref ty) => convert_tokens(ty.tokens.clone()),\n         Nonterminal::NtIdent(ident, is_raw) => {\n             Some(tokenstream::TokenTree::token(token::Ident(ident.name, is_raw), ident.span).into())\n         }\n         Nonterminal::NtLifetime(ident) => {\n             Some(tokenstream::TokenTree::token(token::Lifetime(ident.name), ident.span).into())\n         }\n-        Nonterminal::NtMeta(ref attr) => attr.tokens.clone(),\n-        Nonterminal::NtPath(ref path) => path.tokens.clone(),\n-        Nonterminal::NtVis(ref vis) => vis.tokens.clone(),\n+        Nonterminal::NtMeta(ref attr) => convert_tokens(attr.tokens.clone()),\n+        Nonterminal::NtPath(ref path) => convert_tokens(path.tokens.clone()),\n+        Nonterminal::NtVis(ref vis) => convert_tokens(vis.tokens.clone()),\n         Nonterminal::NtTT(ref tt) => Some(tt.clone().into()),\n         Nonterminal::NtExpr(ref expr) | Nonterminal::NtLiteral(ref expr) => {\n             if expr.tokens.is_none() {\n                 debug!(\"missing tokens for expr {:?}\", expr);\n             }\n-            prepend_attrs(sess, &expr.attrs, expr.tokens.as_ref(), span)\n+            prepend_attrs(&expr.attrs, expr.tokens.as_ref())\n         }\n     };\n \n@@ -600,12 +601,10 @@ fn token_probably_equal_for_proc_macro(first: &Token, other: &Token) -> bool {\n }\n \n fn prepend_attrs(\n-    sess: &ParseSess,\n     attrs: &[ast::Attribute],\n-    tokens: Option<&tokenstream::TokenStream>,\n-    span: rustc_span::Span,\n+    tokens: Option<&tokenstream::LazyTokenStream>,\n ) -> Option<tokenstream::TokenStream> {\n-    let tokens = tokens?;\n+    let tokens = tokens?.clone().into_token_stream();\n     if attrs.is_empty() {\n         return Some(tokens.clone());\n     }\n@@ -616,47 +615,12 @@ fn prepend_attrs(\n             ast::AttrStyle::Outer,\n             \"inner attributes should prevent cached tokens from existing\"\n         );\n-\n-        let source = pprust::attribute_to_string(attr);\n-        let macro_filename = FileName::macro_expansion_source_code(&source);\n-\n-        let item = match attr.kind {\n-            ast::AttrKind::Normal(ref item) => item,\n-            ast::AttrKind::DocComment(..) => {\n-                let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-                builder.push(stream);\n-                continue;\n-            }\n-        };\n-\n-        // synthesize # [ $path $tokens ] manually here\n-        let mut brackets = tokenstream::TokenStreamBuilder::new();\n-\n-        // For simple paths, push the identifier directly\n-        if item.path.segments.len() == 1 && item.path.segments[0].args.is_none() {\n-            let ident = item.path.segments[0].ident;\n-            let token = token::Ident(ident.name, ident.as_str().starts_with(\"r#\"));\n-            brackets.push(tokenstream::TokenTree::token(token, ident.span));\n-\n-        // ... and for more complicated paths, fall back to a reparse hack that\n-        // should eventually be removed.\n-        } else {\n-            let stream = parse_stream_from_source_str(macro_filename, source, sess, Some(span));\n-            brackets.push(stream);\n-        }\n-\n-        brackets.push(item.args.outer_tokens());\n-\n-        // The span we list here for `#` and for `[ ... ]` are both wrong in\n-        // that it encompasses more than each token, but it hopefully is \"good\n-        // enough\" for now at least.\n-        builder.push(tokenstream::TokenTree::token(token::Pound, attr.span));\n-        let delim_span = tokenstream::DelimSpan::from_single(attr.span);\n-        builder.push(tokenstream::TokenTree::Delimited(\n-            delim_span,\n-            token::DelimToken::Bracket,\n-            brackets.build(),\n-        ));\n+        builder.push(\n+            attr.tokens\n+                .clone()\n+                .unwrap_or_else(|| panic!(\"Attribute {:?} is missing tokens!\", attr))\n+                .into_token_stream(),\n+        );\n     }\n     builder.push(tokens.clone());\n     Some(builder.build())"}, {"sha": "053b7e0b75fe4cf731f4d6c59c80bc92f6c03f89", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 98, "deletions": 52, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -4,7 +4,7 @@ use rustc_ast::attr;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast_pretty::pprust;\n use rustc_errors::{error_code, PResult};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use tracing::debug;\n \n@@ -30,41 +30,53 @@ impl<'a> Parser<'a> {\n         let mut just_parsed_doc_comment = false;\n         loop {\n             debug!(\"parse_outer_attributes: self.token={:?}\", self.token);\n-            if self.check(&token::Pound) {\n-                let inner_error_reason = if just_parsed_doc_comment {\n-                    \"an inner attribute is not permitted following an outer doc comment\"\n-                } else if !attrs.is_empty() {\n-                    \"an inner attribute is not permitted following an outer attribute\"\n-                } else {\n-                    DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n-                };\n-                let inner_parse_policy = InnerAttrPolicy::Forbidden {\n-                    reason: inner_error_reason,\n-                    saw_doc_comment: just_parsed_doc_comment,\n-                    prev_attr_sp: attrs.last().map(|a| a.span),\n-                };\n-                let attr = self.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n-                attrs.push(attr);\n-                just_parsed_doc_comment = false;\n+            let (attr, tokens) = if self.check(&token::Pound) {\n+                self.collect_tokens(|this| {\n+                    let inner_error_reason = if just_parsed_doc_comment {\n+                        \"an inner attribute is not permitted following an outer doc comment\"\n+                    } else if !attrs.is_empty() {\n+                        \"an inner attribute is not permitted following an outer attribute\"\n+                    } else {\n+                        DEFAULT_UNEXPECTED_INNER_ATTR_ERR_MSG\n+                    };\n+                    let inner_parse_policy = InnerAttrPolicy::Forbidden {\n+                        reason: inner_error_reason,\n+                        saw_doc_comment: just_parsed_doc_comment,\n+                        prev_attr_sp: attrs.last().map(|a| a.span),\n+                    };\n+                    let attr = this.parse_attribute_with_inner_parse_policy(inner_parse_policy)?;\n+                    just_parsed_doc_comment = false;\n+                    Ok(Some(attr))\n+                })?\n             } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n-                let attr = attr::mk_doc_comment(comment_kind, attr_style, data, self.token.span);\n-                if attr.style != ast::AttrStyle::Outer {\n-                    self.sess\n-                        .span_diagnostic\n-                        .struct_span_err_with_code(\n-                            self.token.span,\n-                            \"expected outer doc comment\",\n-                            error_code!(E0753),\n-                        )\n-                        .note(\n-                            \"inner doc comments like this (starting with \\\n-                             `//!` or `/*!`) can only appear before items\",\n-                        )\n-                        .emit();\n-                }\n+                self.collect_tokens(|this| {\n+                    let attr =\n+                        attr::mk_doc_comment(comment_kind, attr_style, data, this.token.span);\n+                    if attr.style != ast::AttrStyle::Outer {\n+                        this.sess\n+                            .span_diagnostic\n+                            .struct_span_err_with_code(\n+                                this.token.span,\n+                                \"expected outer doc comment\",\n+                                error_code!(E0753),\n+                            )\n+                            .note(\n+                                \"inner doc comments like this (starting with \\\n+                                 `//!` or `/*!`) can only appear before items\",\n+                            )\n+                            .emit();\n+                    }\n+                    this.bump();\n+                    just_parsed_doc_comment = true;\n+                    Ok(Some(attr))\n+                })?\n+            } else {\n+                (None, None)\n+            };\n+\n+            if let Some(mut attr) = attr {\n+                attr.tokens = tokens;\n                 attrs.push(attr);\n-                self.bump();\n-                just_parsed_doc_comment = true;\n             } else {\n                 break;\n             }\n@@ -99,7 +111,7 @@ impl<'a> Parser<'a> {\n                 if self.eat(&token::Not) { ast::AttrStyle::Inner } else { ast::AttrStyle::Outer };\n \n             self.expect(&token::OpenDelim(token::Bracket))?;\n-            let item = self.parse_attr_item()?;\n+            let item = self.parse_attr_item(false)?;\n             self.expect(&token::CloseDelim(token::Bracket))?;\n             let attr_sp = lo.to(self.prev_token.span);\n \n@@ -148,7 +160,7 @@ impl<'a> Parser<'a> {\n     ///     PATH\n     ///     PATH `=` UNSUFFIXED_LIT\n     /// The delimiters or `=` are still put into the resulting token stream.\n-    pub fn parse_attr_item(&mut self) -> PResult<'a, ast::AttrItem> {\n+    pub fn parse_attr_item(&mut self, capture_tokens: bool) -> PResult<'a, ast::AttrItem> {\n         let item = match self.token.kind {\n             token::Interpolated(ref nt) => match **nt {\n                 Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n@@ -160,9 +172,18 @@ impl<'a> Parser<'a> {\n             self.bump();\n             item\n         } else {\n-            let path = self.parse_path(PathStyle::Mod)?;\n-            let args = self.parse_attr_args()?;\n-            ast::AttrItem { path, args, tokens: None }\n+            let do_parse = |this: &mut Self| {\n+                let path = this.parse_path(PathStyle::Mod)?;\n+                let args = this.parse_attr_args()?;\n+                Ok(ast::AttrItem { path, args, tokens: None })\n+            };\n+            if capture_tokens {\n+                let (mut item, tokens) = self.collect_tokens(do_parse)?;\n+                item.tokens = tokens;\n+                item\n+            } else {\n+                do_parse(self)?\n+            }\n         })\n     }\n \n@@ -175,19 +196,31 @@ impl<'a> Parser<'a> {\n         let mut attrs: Vec<ast::Attribute> = vec![];\n         loop {\n             // Only try to parse if it is an inner attribute (has `!`).\n-            if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n-                let attr = self.parse_attribute(true)?;\n-                assert_eq!(attr.style, ast::AttrStyle::Inner);\n-                attrs.push(attr);\n-            } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n-                // We need to get the position of this token before we bump.\n-                let attr = attr::mk_doc_comment(comment_kind, attr_style, data, self.token.span);\n-                if attr.style == ast::AttrStyle::Inner {\n-                    attrs.push(attr);\n-                    self.bump();\n+            let (attr, tokens) =\n+                if self.check(&token::Pound) && self.look_ahead(1, |t| t == &token::Not) {\n+                    self.collect_tokens(|this| {\n+                        let attr = this.parse_attribute(true)?;\n+                        assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                        Ok(Some(attr))\n+                    })?\n+                } else if let token::DocComment(comment_kind, attr_style, data) = self.token.kind {\n+                    self.collect_tokens(|this| {\n+                        // We need to get the position of this token before we bump.\n+                        let attr =\n+                            attr::mk_doc_comment(comment_kind, attr_style, data, this.token.span);\n+                        if attr.style == ast::AttrStyle::Inner {\n+                            this.bump();\n+                            Ok(Some(attr))\n+                        } else {\n+                            Ok(None)\n+                        }\n+                    })?\n                 } else {\n-                    break;\n-                }\n+                    (None, None)\n+                };\n+            if let Some(mut attr) = attr {\n+                attr.tokens = tokens;\n+                attrs.push(attr);\n             } else {\n                 break;\n             }\n@@ -220,7 +253,7 @@ impl<'a> Parser<'a> {\n         let mut expanded_attrs = Vec::with_capacity(1);\n         while self.token.kind != token::Eof {\n             let lo = self.token.span;\n-            let item = self.parse_attr_item()?;\n+            let item = self.parse_attr_item(true)?;\n             expanded_attrs.push((item, lo.to(self.prev_token.span)));\n             if !self.eat(&token::Comma) {\n                 break;\n@@ -302,3 +335,16 @@ impl<'a> Parser<'a> {\n         Err(self.struct_span_err(self.token.span, &msg))\n     }\n }\n+\n+pub fn maybe_needs_tokens(attrs: &[ast::Attribute]) -> bool {\n+    attrs.iter().any(|attr| {\n+        if let Some(ident) = attr.ident() {\n+            ident.name == sym::derive\n+            // This might apply a custom attribute/derive\n+            || ident.name == sym::cfg_attr\n+            || !rustc_feature::is_builtin_attr_name(ident.name)\n+        } else {\n+            true\n+        }\n+    })\n+}"}, {"sha": "c44e00f861de6c17ad5953663924abeaac75eddc", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -6,6 +6,7 @@ use crate::maybe_recover_from_interpolated_ty_qpath;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Token, TokenKind};\n+use rustc_ast::tokenstream::Spacing;\n use rustc_ast::util::classify;\n use rustc_ast::util::literal::LitError;\n use rustc_ast::util::parser::{prec_let_scrutinee_needs_par, AssocOp, Fixity};\n@@ -18,7 +19,6 @@ use rustc_span::source_map::{self, Span, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{BytePos, Pos};\n use std::mem;\n-use tracing::debug;\n \n /// Possibly accepts an `token::Interpolated` expression (a pre-parsed expression\n /// dropped into the token stream, which happens while parsing the result of\n@@ -459,7 +459,7 @@ impl<'a> Parser<'a> {\n     /// Parses a prefix-unary-operator expr.\n     fn parse_prefix_expr(&mut self, attrs: Option<AttrVec>) -> PResult<'a, P<Expr>> {\n         let attrs = self.parse_or_use_outer_attributes(attrs)?;\n-        self.maybe_collect_tokens(!attrs.is_empty(), |this| {\n+        self.maybe_collect_tokens(super::attr::maybe_needs_tokens(&attrs), |this| {\n             let lo = this.token.span;\n             // Note: when adding new unary operators, don't forget to adjust TokenKind::can_begin_expr()\n             let (hi, ex) = match this.token.uninterpolate().kind {\n@@ -884,7 +884,7 @@ impl<'a> Parser<'a> {\n                 assert!(suffix.is_none());\n                 let symbol = Symbol::intern(&i);\n                 self.token = Token::new(token::Ident(symbol, false), ident_span);\n-                let next_token = Token::new(token::Dot, dot_span);\n+                let next_token = (Token::new(token::Dot, dot_span), self.token_spacing);\n                 self.parse_tuple_field_access_expr(lo, base, symbol, None, Some(next_token))\n             }\n             // 1.2 | 1.2e3\n@@ -902,12 +902,14 @@ impl<'a> Parser<'a> {\n                 };\n                 let symbol1 = Symbol::intern(&i1);\n                 self.token = Token::new(token::Ident(symbol1, false), ident1_span);\n-                let next_token1 = Token::new(token::Dot, dot_span);\n+                // This needs to be `Spacing::Alone` to prevent regressions.\n+                // See issue #76399 and PR #76285 for more details\n+                let next_token1 = (Token::new(token::Dot, dot_span), Spacing::Alone);\n                 let base1 =\n                     self.parse_tuple_field_access_expr(lo, base, symbol1, None, Some(next_token1));\n                 let symbol2 = Symbol::intern(&i2);\n                 let next_token2 = Token::new(token::Ident(symbol2, false), ident2_span);\n-                self.bump_with(next_token2); // `.`\n+                self.bump_with((next_token2, self.token_spacing)); // `.`\n                 self.parse_tuple_field_access_expr(lo, base1, symbol2, suffix, None)\n             }\n             // 1e+ | 1e- (recovered)\n@@ -930,7 +932,7 @@ impl<'a> Parser<'a> {\n         base: P<Expr>,\n         field: Symbol,\n         suffix: Option<Symbol>,\n-        next_token: Option<Token>,\n+        next_token: Option<(Token, Spacing)>,\n     ) -> P<Expr> {\n         match next_token {\n             Some(next_token) => self.bump_with(next_token),\n@@ -1060,6 +1062,8 @@ impl<'a> Parser<'a> {\n             })\n         } else if self.eat_keyword(kw::Unsafe) {\n             self.parse_block_expr(None, lo, BlockCheckMode::Unsafe(ast::UserProvided), attrs)\n+        } else if self.check_inline_const(0) {\n+            self.parse_const_block(lo.to(self.token.span))\n         } else if self.is_do_catch_block() {\n             self.recover_do_catch(attrs)\n         } else if self.is_try_block() {\n@@ -1107,13 +1111,12 @@ impl<'a> Parser<'a> {\n \n     fn maybe_collect_tokens(\n         &mut self,\n-        has_outer_attrs: bool,\n+        needs_tokens: bool,\n         f: impl FnOnce(&mut Self) -> PResult<'a, P<Expr>>,\n     ) -> PResult<'a, P<Expr>> {\n-        if has_outer_attrs {\n+        if needs_tokens {\n             let (mut expr, tokens) = self.collect_tokens(f)?;\n-            debug!(\"maybe_collect_tokens: Collected tokens for {:?} (tokens {:?}\", expr, tokens);\n-            expr.tokens = Some(tokens);\n+            expr.tokens = tokens;\n             Ok(expr)\n         } else {\n             f(self)"}, {"sha": "e57a2e42b5dded7270008fc427083d428f6ce01f", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -116,15 +116,16 @@ impl<'a> Parser<'a> {\n             Some(item.into_inner())\n         });\n \n+        let needs_tokens = super::attr::maybe_needs_tokens(&attrs);\n+\n         let mut unclosed_delims = vec![];\n-        let has_attrs = !attrs.is_empty();\n         let parse_item = |this: &mut Self| {\n             let item = this.parse_item_common_(attrs, mac_allowed, attrs_allowed, req_name);\n             unclosed_delims.append(&mut this.unclosed_delims);\n             item\n         };\n \n-        let (mut item, tokens) = if has_attrs {\n+        let (mut item, tokens) = if needs_tokens {\n             let (item, tokens) = self.collect_tokens(parse_item)?;\n             (item, Some(tokens))\n         } else {\n@@ -150,7 +151,7 @@ impl<'a> Parser<'a> {\n         if let Some(tokens) = tokens {\n             if let Some(item) = &mut item {\n                 if !item.attrs.iter().any(|attr| attr.style == AttrStyle::Inner) {\n-                    item.tokens = Some(tokens);\n+                    item.tokens = tokens;\n                 }\n             }\n         }"}, {"sha": "175dd3fa53a6eb727c317dbb5f7190761ab25e38", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 170, "deletions": 142, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -16,12 +16,15 @@ pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, DelimSpan, TokenStream, TokenTree, TreeAndSpacing};\n+use rustc_ast::tokenstream::{self, DelimSpan, LazyTokenStream, LazyTokenStreamInner, Spacing};\n+use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n-use rustc_ast::{Async, MacArgs, MacDelimiter, Mutability, StrLit, Visibility, VisibilityKind};\n+use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n+use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacDelimiter, Mutability, StrLit};\n+use rustc_ast::{Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n-use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError, PResult};\n+use rustc_errors::PResult;\n+use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, FatalError};\n use rustc_session::parse::ParseSess;\n use rustc_span::source_map::{Span, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n@@ -84,10 +87,14 @@ pub struct Parser<'a> {\n     pub sess: &'a ParseSess,\n     /// The current token.\n     pub token: Token,\n+    /// The spacing for the current token\n+    pub token_spacing: Spacing,\n     /// The previous token.\n     pub prev_token: Token,\n     restrictions: Restrictions,\n     expected_tokens: Vec<TokenType>,\n+    // Important: This must only be advanced from `next_tok`\n+    // to ensure that `token_cursor.num_next_calls` is updated properly\n     token_cursor: TokenCursor,\n     desugar_doc_comments: bool,\n     /// This field is used to keep track of how many left angle brackets we have seen. This is\n@@ -119,8 +126,10 @@ impl<'a> Drop for Parser<'a> {\n struct TokenCursor {\n     frame: TokenCursorFrame,\n     stack: Vec<TokenCursorFrame>,\n-    cur_token: Option<TreeAndSpacing>,\n-    collecting: Option<Collecting>,\n+    desugar_doc_comments: bool,\n+    // Counts the number of calls to `next` or `next_desugared`,\n+    // depending on whether `desugar_doc_comments` is set.\n+    num_next_calls: usize,\n }\n \n #[derive(Clone)]\n@@ -132,40 +141,22 @@ struct TokenCursorFrame {\n     close_delim: bool,\n }\n \n-/// Used to track additional state needed by `collect_tokens`\n-#[derive(Clone, Debug)]\n-struct Collecting {\n-    /// Holds the current tokens captured during the most\n-    /// recent call to `collect_tokens`\n-    buf: Vec<TreeAndSpacing>,\n-    /// The depth of the `TokenCursor` stack at the time\n-    /// collection was started. When we encounter a `TokenTree::Delimited`,\n-    /// we want to record the `TokenTree::Delimited` itself,\n-    /// but *not* any of the inner tokens while we are inside\n-    /// the new frame (this would cause us to record duplicate tokens).\n-    ///\n-    /// This `depth` fields tracks stack depth we are recording tokens.\n-    /// Only tokens encountered at this depth will be recorded. See\n-    /// `TokenCursor::next` for more details.\n-    depth: usize,\n-}\n-\n impl TokenCursorFrame {\n-    fn new(span: DelimSpan, delim: DelimToken, tts: &TokenStream) -> Self {\n+    fn new(span: DelimSpan, delim: DelimToken, tts: TokenStream) -> Self {\n         TokenCursorFrame {\n             delim,\n             span,\n             open_delim: delim == token::NoDelim,\n-            tree_cursor: tts.clone().into_trees(),\n+            tree_cursor: tts.into_trees(),\n             close_delim: delim == token::NoDelim,\n         }\n     }\n }\n \n impl TokenCursor {\n-    fn next(&mut self) -> Token {\n+    fn next(&mut self) -> (Token, Spacing) {\n         loop {\n-            let tree = if !self.frame.open_delim {\n+            let (tree, spacing) = if !self.frame.open_delim {\n                 self.frame.open_delim = true;\n                 TokenTree::open_tt(self.frame.span, self.frame.delim).into()\n             } else if let Some(tree) = self.frame.tree_cursor.next_with_spacing() {\n@@ -177,40 +168,24 @@ impl TokenCursor {\n                 self.frame = frame;\n                 continue;\n             } else {\n-                return Token::new(token::Eof, DUMMY_SP);\n+                (TokenTree::Token(Token::new(token::Eof, DUMMY_SP)), Spacing::Alone)\n             };\n \n-            // Don't set an open delimiter as our current token - we want\n-            // to leave it as the full `TokenTree::Delimited` from the previous\n-            // iteration of this loop\n-            if !matches!(tree.0, TokenTree::Token(Token { kind: TokenKind::OpenDelim(_), .. })) {\n-                self.cur_token = Some(tree.clone());\n-            }\n-\n-            if let Some(collecting) = &mut self.collecting {\n-                if collecting.depth == self.stack.len() {\n-                    debug!(\n-                        \"TokenCursor::next():  collected {:?} at depth {:?}\",\n-                        tree,\n-                        self.stack.len()\n-                    );\n-                    collecting.buf.push(tree.clone())\n+            match tree {\n+                TokenTree::Token(token) => {\n+                    return (token, spacing);\n                 }\n-            }\n-\n-            match tree.0 {\n-                TokenTree::Token(token) => return token,\n                 TokenTree::Delimited(sp, delim, tts) => {\n-                    let frame = TokenCursorFrame::new(sp, delim, &tts);\n+                    let frame = TokenCursorFrame::new(sp, delim, tts);\n                     self.stack.push(mem::replace(&mut self.frame, frame));\n                 }\n             }\n         }\n     }\n \n-    fn next_desugared(&mut self) -> Token {\n+    fn next_desugared(&mut self) -> (Token, Spacing) {\n         let (data, attr_style, sp) = match self.next() {\n-            Token { kind: token::DocComment(_, attr_style, data), span } => {\n+            (Token { kind: token::DocComment(_, attr_style, data), span }, _) => {\n                 (data, attr_style, span)\n             }\n             tok => return tok,\n@@ -248,7 +223,7 @@ impl TokenCursor {\n             TokenCursorFrame::new(\n                 delim_span,\n                 token::NoDelim,\n-                &if attr_style == AttrStyle::Inner {\n+                if attr_style == AttrStyle::Inner {\n                     [TokenTree::token(token::Pound, sp), TokenTree::token(token::Not, sp), body]\n                         .iter()\n                         .cloned()\n@@ -350,14 +325,15 @@ impl<'a> Parser<'a> {\n         let mut parser = Parser {\n             sess,\n             token: Token::dummy(),\n+            token_spacing: Spacing::Alone,\n             prev_token: Token::dummy(),\n             restrictions: Restrictions::empty(),\n             expected_tokens: Vec::new(),\n             token_cursor: TokenCursor {\n-                frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, &tokens),\n+                frame: TokenCursorFrame::new(DelimSpan::dummy(), token::NoDelim, tokens),\n                 stack: Vec::new(),\n-                cur_token: None,\n-                collecting: None,\n+                num_next_calls: 0,\n+                desugar_doc_comments,\n             },\n             desugar_doc_comments,\n             unmatched_angle_bracket_count: 0,\n@@ -374,17 +350,18 @@ impl<'a> Parser<'a> {\n         parser\n     }\n \n-    fn next_tok(&mut self, fallback_span: Span) -> Token {\n-        let mut next = if self.desugar_doc_comments {\n+    fn next_tok(&mut self, fallback_span: Span) -> (Token, Spacing) {\n+        let (mut next, spacing) = if self.desugar_doc_comments {\n             self.token_cursor.next_desugared()\n         } else {\n             self.token_cursor.next()\n         };\n+        self.token_cursor.num_next_calls += 1;\n         if next.span.is_dummy() {\n             // Tweak the location for better diagnostics, but keep syntactic context intact.\n             next.span = fallback_span.with_ctxt(next.span.ctxt());\n         }\n-        next\n+        (next, spacing)\n     }\n \n     pub fn unexpected<T>(&mut self) -> PResult<'a, T> {\n@@ -545,6 +522,15 @@ impl<'a> Parser<'a> {\n         self.check_or_expected(self.token.can_begin_const_arg(), TokenType::Const)\n     }\n \n+    fn check_inline_const(&self, dist: usize) -> bool {\n+        self.is_keyword_ahead(dist, &[kw::Const])\n+            && self.look_ahead(dist + 1, |t| match t.kind {\n+                token::Interpolated(ref nt) => matches!(**nt, token::NtBlock(..)),\n+                token::OpenDelim(DelimToken::Brace) => true,\n+                _ => false,\n+            })\n+    }\n+\n     /// Checks to see if the next token is either `+` or `+=`.\n     /// Otherwise returns `false`.\n     fn check_plus(&mut self) -> bool {\n@@ -567,7 +553,9 @@ impl<'a> Parser<'a> {\n                 let first_span = self.sess.source_map().start_point(self.token.span);\n                 let second_span = self.token.span.with_lo(first_span.hi());\n                 self.token = Token::new(first, first_span);\n-                self.bump_with(Token::new(second, second_span));\n+                // Use the spacing of the glued token as the spacing\n+                // of the unglued second token.\n+                self.bump_with((Token::new(second, second_span), self.token_spacing));\n                 true\n             }\n             _ => {\n@@ -799,7 +787,7 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Advance the parser by one token using provided token as the next one.\n-    fn bump_with(&mut self, next_token: Token) {\n+    fn bump_with(&mut self, (next_token, next_spacing): (Token, Spacing)) {\n         // Bumping after EOF is a bad sign, usually an infinite loop.\n         if self.prev_token.kind == TokenKind::Eof {\n             let msg = \"attempted to bump the parser past EOF (may be stuck in a loop)\";\n@@ -808,6 +796,7 @@ impl<'a> Parser<'a> {\n \n         // Update the current and previous tokens.\n         self.prev_token = mem::replace(&mut self.token, next_token);\n+        self.token_spacing = next_spacing;\n \n         // Diagnostics.\n         self.expected_tokens.clear();\n@@ -827,15 +816,15 @@ impl<'a> Parser<'a> {\n         }\n \n         let frame = &self.token_cursor.frame;\n-        looker(&match frame.tree_cursor.look_ahead(dist - 1) {\n+        match frame.tree_cursor.look_ahead(dist - 1) {\n             Some(tree) => match tree {\n-                TokenTree::Token(token) => token,\n+                TokenTree::Token(token) => looker(token),\n                 TokenTree::Delimited(dspan, delim, _) => {\n-                    Token::new(token::OpenDelim(delim), dspan.open)\n+                    looker(&Token::new(token::OpenDelim(*delim), dspan.open))\n                 }\n             },\n-            None => Token::new(token::CloseDelim(frame.delim), frame.span.close),\n-        })\n+            None => looker(&Token::new(token::CloseDelim(frame.delim), frame.span.close)),\n+        }\n     }\n \n     /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n@@ -864,13 +853,28 @@ impl<'a> Parser<'a> {\n \n     /// Parses constness: `const` or nothing.\n     fn parse_constness(&mut self) -> Const {\n-        if self.eat_keyword(kw::Const) {\n+        // Avoid const blocks to be parsed as const items\n+        if self.look_ahead(1, |t| t != &token::OpenDelim(DelimToken::Brace))\n+            && self.eat_keyword(kw::Const)\n+        {\n             Const::Yes(self.prev_token.uninterpolated_span())\n         } else {\n             Const::No\n         }\n     }\n \n+    /// Parses inline const expressions.\n+    fn parse_const_block(&mut self, span: Span) -> PResult<'a, P<Expr>> {\n+        self.sess.gated_spans.gate(sym::inline_const, span);\n+        self.eat_keyword(kw::Const);\n+        let blk = self.parse_block()?;\n+        let anon_const = AnonConst {\n+            id: DUMMY_NODE_ID,\n+            value: self.mk_expr(blk.span, ExprKind::Block(blk, None), AttrVec::new()),\n+        };\n+        Ok(self.mk_expr(span, ExprKind::ConstBlock(anon_const), AttrVec::new()))\n+    }\n+\n     /// Parses mutability (`mut` or nothing).\n     fn parse_mutability(&mut self) -> Mutability {\n         if self.eat_keyword(kw::Mut) { Mutability::Mut } else { Mutability::Not }\n@@ -963,13 +967,27 @@ impl<'a> Parser<'a> {\n     pub(crate) fn parse_token_tree(&mut self) -> TokenTree {\n         match self.token.kind {\n             token::OpenDelim(..) => {\n-                let frame = mem::replace(\n-                    &mut self.token_cursor.frame,\n-                    self.token_cursor.stack.pop().unwrap(),\n-                );\n-                self.token = Token::new(TokenKind::CloseDelim(frame.delim), frame.span.close);\n+                let depth = self.token_cursor.stack.len();\n+\n+                // We keep advancing the token cursor until we hit\n+                // the matching `CloseDelim` token.\n+                while !(depth == self.token_cursor.stack.len()\n+                    && matches!(self.token.kind, token::CloseDelim(_)))\n+                {\n+                    // Advance one token at a time, so `TokenCursor::next()`\n+                    // can capture these tokens if necessary.\n+                    self.bump();\n+                }\n+                // We are still inside the frame corresponding\n+                // to the delimited stream we captured, so grab\n+                // the tokens from this frame.\n+                let frame = &self.token_cursor.frame;\n+                let stream = frame.tree_cursor.stream.clone();\n+                let span = frame.span;\n+                let delim = frame.delim;\n+                // Consume close delimiter\n                 self.bump();\n-                TokenTree::Delimited(frame.span, frame.delim, frame.tree_cursor.stream)\n+                TokenTree::Delimited(span, delim, stream)\n             }\n             token::CloseDelim(_) | token::Eof => unreachable!(),\n             _ => {\n@@ -1160,8 +1178,9 @@ impl<'a> Parser<'a> {\n \n     /// Records all tokens consumed by the provided callback,\n     /// including the current token. These tokens are collected\n-    /// into a `TokenStream`, and returned along with the result\n-    /// of the callback.\n+    /// into a `LazyTokenStream`, and returned along with the result\n+    /// of the callback. The returned `LazyTokenStream` will be `None`\n+    /// if not tokens were captured.\n     ///\n     /// Note: If your callback consumes an opening delimiter\n     /// (including the case where you call `collect_tokens`\n@@ -1177,79 +1196,50 @@ impl<'a> Parser<'a> {\n     pub fn collect_tokens<R>(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n-    ) -> PResult<'a, (R, TokenStream)> {\n-        // Record all tokens we parse when parsing this item.\n-        let tokens: Vec<TreeAndSpacing> = self.token_cursor.cur_token.clone().into_iter().collect();\n-        debug!(\"collect_tokens: starting with {:?}\", tokens);\n-\n-        // We need special handling for the case where `collect_tokens` is called\n-        // on an opening delimeter (e.g. '('). At this point, we have already pushed\n-        // a new frame - however, we want to record the original `TokenTree::Delimited`,\n-        // for consistency with the case where we start recording one token earlier.\n-        // See `TokenCursor::next` to see how `cur_token` is set up.\n-        let prev_depth =\n-            if matches!(self.token_cursor.cur_token, Some((TokenTree::Delimited(..), _))) {\n-                if self.token_cursor.stack.is_empty() {\n-                    // There is nothing below us in the stack that\n-                    // the function could consume, so the only thing it can legally\n-                    // capture is the entire contents of the current frame.\n-                    return Ok((f(self)?, TokenStream::new(tokens)));\n-                }\n-                // We have already recorded the full `TokenTree::Delimited` when we created\n-                // our `tokens` vector at the start of this function. We are now inside\n-                // a new frame corresponding to the `TokenTree::Delimited` we already recoreded.\n-                // We don't want to record any of the tokens inside this frame, since they\n-                // will be duplicates of the tokens nested inside the `TokenTree::Delimited`.\n-                // Therefore, we set our recording depth to the *previous* frame. This allows\n-                // us to record a sequence like: `(foo).bar()`: the `(foo)` will be recored\n-                // as our initial `cur_token`, while the `.bar()` will be recored after we\n-                // pop the `(foo)` frame.\n-                self.token_cursor.stack.len() - 1\n-            } else {\n-                self.token_cursor.stack.len()\n-            };\n-        let prev_collecting =\n-            self.token_cursor.collecting.replace(Collecting { buf: tokens, depth: prev_depth });\n+    ) -> PResult<'a, (R, Option<LazyTokenStream>)> {\n+        let start_token = (self.token.clone(), self.token_spacing);\n+        let mut cursor_snapshot = self.token_cursor.clone();\n \n-        let ret = f(self);\n+        let ret = f(self)?;\n \n-        let mut collected_tokens = if let Some(collecting) = self.token_cursor.collecting.take() {\n-            collecting.buf\n-        } else {\n-            let msg = \"our vector went away?\";\n-            debug!(\"collect_tokens: {}\", msg);\n-            self.sess.span_diagnostic.delay_span_bug(self.token.span, &msg);\n-            // This can happen due to a bad interaction of two unrelated recovery mechanisms\n-            // with mismatched delimiters *and* recovery lookahead on the likely typo\n-            // `pub ident(` (#62895, different but similar to the case above).\n-            return Ok((ret?, TokenStream::default()));\n-        };\n+        let new_calls = self.token_cursor.num_next_calls;\n+        let num_calls = new_calls - cursor_snapshot.num_next_calls;\n+        let desugar_doc_comments = self.desugar_doc_comments;\n \n-        debug!(\"collect_tokens: got raw tokens {:?}\", collected_tokens);\n-\n-        // If we're not at EOF our current token wasn't actually consumed by\n-        // `f`, but it'll still be in our list that we pulled out. In that case\n-        // put it back.\n-        let extra_token = if self.token != token::Eof { collected_tokens.pop() } else { None };\n-\n-        if let Some(mut collecting) = prev_collecting {\n-            // If we were previously collecting at the same depth,\n-            // then the previous call to `collect_tokens` needs to see\n-            // the tokens we just recorded.\n-            //\n-            // If we were previously recording at an lower `depth`,\n-            // then the previous `collect_tokens` call already recorded\n-            // this entire frame in the form of a `TokenTree::Delimited`,\n-            // so there is nothing else for us to do.\n-            if collecting.depth == prev_depth {\n-                collecting.buf.extend(collected_tokens.iter().cloned());\n-                collecting.buf.extend(extra_token);\n-                debug!(\"collect_tokens: updating previous buf to {:?}\", collecting);\n-            }\n-            self.token_cursor.collecting = Some(collecting)\n+        // We didn't capture any tokens\n+        if num_calls == 0 {\n+            return Ok((ret, None));\n         }\n \n-        Ok((ret?, TokenStream::new(collected_tokens)))\n+        // Produces a `TokenStream` on-demand. Using `cursor_snapshot`\n+        // and `num_calls`, we can reconstruct the `TokenStream` seen\n+        // by the callback. This allows us to avoid producing a `TokenStream`\n+        // if it is never needed - for example, a captured `macro_rules!`\n+        // argument that is never passed to a proc macro.\n+        //\n+        // This also makes `Parser` very cheap to clone, since\n+        // there is no intermediate collection buffer to clone.\n+        let lazy_cb = move || {\n+            // The token produced by the final call to `next` or `next_desugared`\n+            // was not actually consumed by the callback. The combination\n+            // of chaining the initial token and using `take` produces the desired\n+            // result - we produce an empty `TokenStream` if no calls were made,\n+            // and omit the final token otherwise.\n+            let tokens = std::iter::once(start_token)\n+                .chain((0..num_calls).map(|_| {\n+                    if desugar_doc_comments {\n+                        cursor_snapshot.next_desugared()\n+                    } else {\n+                        cursor_snapshot.next()\n+                    }\n+                }))\n+                .take(num_calls);\n+\n+            make_token_stream(tokens)\n+        };\n+        let stream = LazyTokenStream::new(LazyTokenStreamInner::Lazy(Box::new(lazy_cb)));\n+\n+        Ok((ret, Some(stream)))\n     }\n \n     /// `::{` or `::*`\n@@ -1298,3 +1288,41 @@ pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, sess: &Pa\n         }\n     }\n }\n+\n+/// Converts a flattened iterator of tokens (including open and close delimiter tokens)\n+/// into a `TokenStream`, creating a `TokenTree::Delimited` for each matching pair\n+/// of open and close delims.\n+fn make_token_stream(tokens: impl Iterator<Item = (Token, Spacing)>) -> TokenStream {\n+    #[derive(Debug)]\n+    struct FrameData {\n+        open: Span,\n+        inner: Vec<(TokenTree, Spacing)>,\n+    }\n+    let mut stack = vec![FrameData { open: DUMMY_SP, inner: vec![] }];\n+    for (token, spacing) in tokens {\n+        match token {\n+            Token { kind: TokenKind::OpenDelim(_), span } => {\n+                stack.push(FrameData { open: span, inner: vec![] });\n+            }\n+            Token { kind: TokenKind::CloseDelim(delim), span } => {\n+                let frame_data = stack.pop().expect(\"Token stack was empty!\");\n+                let dspan = DelimSpan::from_pair(frame_data.open, span);\n+                let stream = TokenStream::new(frame_data.inner);\n+                let delimited = TokenTree::Delimited(dspan, delim, stream);\n+                stack\n+                    .last_mut()\n+                    .unwrap_or_else(|| panic!(\"Bottom token frame is missing for tokens!\"))\n+                    .inner\n+                    .push((delimited, Spacing::Alone));\n+            }\n+            token => stack\n+                .last_mut()\n+                .expect(\"Bottom token frame is missing!\")\n+                .inner\n+                .push((TokenTree::Token(token), spacing)),\n+        }\n+    }\n+    let final_buf = stack.pop().expect(\"Missing final buf!\");\n+    assert!(stack.is_empty(), \"Stack should be empty: final_buf={:?} stack={:?}\", final_buf, stack);\n+    TokenStream::new(final_buf.inner)\n+}"}, {"sha": "98fb1c829251072dc012f11f271a62ce9eaf7906", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -103,7 +103,7 @@ impl<'a> Parser<'a> {\n                     // If we captured tokens during parsing (due to outer attributes),\n                     // use those.\n                     if item.tokens.is_none() {\n-                        item.tokens = Some(tokens);\n+                        item.tokens = tokens;\n                     }\n                     token::NtItem(item)\n                 }\n@@ -115,7 +115,7 @@ impl<'a> Parser<'a> {\n                 let (mut block, tokens) = self.collect_tokens(|this| this.parse_block())?;\n                 // We have have eaten an NtBlock, which could already have tokens\n                 if block.tokens.is_none() {\n-                    block.tokens = Some(tokens);\n+                    block.tokens = tokens;\n                 }\n                 token::NtBlock(block)\n             }\n@@ -124,7 +124,7 @@ impl<'a> Parser<'a> {\n                 match stmt {\n                     Some(mut s) => {\n                         if s.tokens.is_none() {\n-                            s.tokens = Some(tokens);\n+                            s.tokens = tokens;\n                         }\n                         token::NtStmt(s)\n                     }\n@@ -137,7 +137,7 @@ impl<'a> Parser<'a> {\n                 let (mut pat, tokens) = self.collect_tokens(|this| this.parse_pat(None))?;\n                 // We have have eaten an NtPat, which could already have tokens\n                 if pat.tokens.is_none() {\n-                    pat.tokens = Some(tokens);\n+                    pat.tokens = tokens;\n                 }\n                 token::NtPat(pat)\n             }\n@@ -146,7 +146,7 @@ impl<'a> Parser<'a> {\n                 // If we captured tokens during parsing (due to outer attributes),\n                 // use those.\n                 if expr.tokens.is_none() {\n-                    expr.tokens = Some(tokens);\n+                    expr.tokens = tokens;\n                 }\n                 token::NtExpr(expr)\n             }\n@@ -155,15 +155,15 @@ impl<'a> Parser<'a> {\n                     self.collect_tokens(|this| this.parse_literal_maybe_minus())?;\n                 // We have have eaten a nonterminal, which  could already have tokens\n                 if lit.tokens.is_none() {\n-                    lit.tokens = Some(tokens);\n+                    lit.tokens = tokens;\n                 }\n                 token::NtLiteral(lit)\n             }\n             NonterminalKind::Ty => {\n                 let (mut ty, tokens) = self.collect_tokens(|this| this.parse_ty())?;\n                 // We have an eaten an NtTy, which could already have tokens\n                 if ty.tokens.is_none() {\n-                    ty.tokens = Some(tokens);\n+                    ty.tokens = tokens;\n                 }\n                 token::NtTy(ty)\n             }\n@@ -183,15 +183,15 @@ impl<'a> Parser<'a> {\n                     self.collect_tokens(|this| this.parse_path(PathStyle::Type))?;\n                 // We have have eaten an NtPath, which could already have tokens\n                 if path.tokens.is_none() {\n-                    path.tokens = Some(tokens);\n+                    path.tokens = tokens;\n                 }\n                 token::NtPath(path)\n             }\n             NonterminalKind::Meta => {\n-                let (mut attr, tokens) = self.collect_tokens(|this| this.parse_attr_item())?;\n+                let (mut attr, tokens) = self.collect_tokens(|this| this.parse_attr_item(false))?;\n                 // We may have eaten a nonterminal, which could already have tokens\n                 if attr.tokens.is_none() {\n-                    attr.tokens = Some(tokens);\n+                    attr.tokens = tokens;\n                 }\n                 token::NtMeta(P(attr))\n             }\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n                     self.collect_tokens(|this| this.parse_visibility(FollowedByType::Yes))?;\n                 // We may have etan an `NtVis`, which could already have tokens\n                 if vis.tokens.is_none() {\n-                    vis.tokens = Some(tokens);\n+                    vis.tokens = tokens;\n                 }\n                 token::NtVis(vis)\n             }"}, {"sha": "27fe75a23b6a844c34b9af2634419c72cbe8edcd", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -313,6 +313,15 @@ impl<'a> Parser<'a> {\n             let pat = self.parse_pat_with_range_pat(false, None)?;\n             self.sess.gated_spans.gate(sym::box_patterns, lo.to(self.prev_token.span));\n             PatKind::Box(pat)\n+        } else if self.check_inline_const(0) {\n+            // Parse `const pat`\n+            let const_expr = self.parse_const_block(lo.to(self.token.span))?;\n+\n+            if let Some(re) = self.parse_range_end() {\n+                self.parse_pat_range_begin_with(const_expr, re)?\n+            } else {\n+                PatKind::Lit(const_expr)\n+            }\n         } else if self.can_be_ident_pat() {\n             // Parse `ident @ pat`\n             // This can give false positives and parse nullary enums,\n@@ -714,16 +723,19 @@ impl<'a> Parser<'a> {\n \n     /// Is the token `dist` away from the current suitable as the start of a range patterns end?\n     fn is_pat_range_end_start(&self, dist: usize) -> bool {\n-        self.look_ahead(dist, |t| {\n-            t.is_path_start() // e.g. `MY_CONST`;\n+        self.check_inline_const(dist)\n+            || self.look_ahead(dist, |t| {\n+                t.is_path_start() // e.g. `MY_CONST`;\n                 || t.kind == token::Dot // e.g. `.5` for recovery;\n                 || t.can_begin_literal_maybe_minus() // e.g. `42`.\n                 || t.is_whole_expr()\n-        })\n+            })\n     }\n \n     fn parse_pat_range_end(&mut self) -> PResult<'a, P<Expr>> {\n-        if self.check_path() {\n+        if self.check_inline_const(0) {\n+            self.parse_const_block(self.token.span)\n+        } else if self.check_path() {\n             let lo = self.token.span;\n             let (qself, path) = if self.eat_lt() {\n                 // Parse a qualified path"}, {"sha": "7679582f8811e39b2534d0f79f4e8ab1d7f46188", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 84, "deletions": 56, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -85,6 +85,10 @@ impl CheckAttrVisitor<'tcx> {\n                 self.check_export_name(&attr, span, target)\n             } else if self.tcx.sess.check_name(attr, sym::rustc_args_required_const) {\n                 self.check_rustc_args_required_const(&attr, span, target, item)\n+            } else if self.tcx.sess.check_name(attr, sym::allow_internal_unstable) {\n+                self.check_allow_internal_unstable(&attr, span, target, &attrs)\n+            } else if self.tcx.sess.check_name(attr, sym::rustc_allow_const_fn_unstable) {\n+                self.check_rustc_allow_const_fn_unstable(hir_id, &attr, span, target)\n             } else {\n                 // lint-only checks\n                 if self.tcx.sess.check_name(attr, sym::cold) {\n@@ -104,7 +108,7 @@ impl CheckAttrVisitor<'tcx> {\n             return;\n         }\n \n-        if matches!(target, Target::Fn | Target::Method(_) | Target::ForeignFn) {\n+        if matches!(target, Target::Closure | Target::Fn | Target::Method(_) | Target::ForeignFn) {\n             self.tcx.ensure().codegen_fn_attrs(self.tcx.hir().local_def_id(hir_id));\n         }\n \n@@ -195,7 +199,7 @@ impl CheckAttrVisitor<'tcx> {\n     /// Checks if the `#[non_exhaustive]` attribute on an `item` is valid. Returns `true` if valid.\n     fn check_non_exhaustive(&self, attr: &Attribute, span: &Span, target: Target) -> bool {\n         match target {\n-            Target::Struct | Target::Enum => true,\n+            Target::Struct | Target::Enum | Target::Variant => true,\n             _ => {\n                 struct_span_err!(\n                     self.tcx.sess,\n@@ -587,6 +591,9 @@ impl CheckAttrVisitor<'tcx> {\n \n         for hint in &hints {\n             let (article, allowed_targets) = match hint.name_or_empty() {\n+                _ if !matches!(target, Target::Struct | Target::Enum | Target::Union) => {\n+                    (\"a\", \"struct, enum, or union\")\n+                }\n                 name @ sym::C | name @ sym::align => {\n                     is_c |= name == sym::C;\n                     match target {\n@@ -652,12 +659,16 @@ impl CheckAttrVisitor<'tcx> {\n                 }\n                 _ => continue,\n             };\n-            self.emit_repr_error(\n+\n+            struct_span_err!(\n+                self.tcx.sess,\n                 hint.span(),\n-                *span,\n-                &format!(\"attribute should be applied to {}\", allowed_targets),\n-                &format!(\"not {} {}\", article, allowed_targets),\n+                E0517,\n+                \"{}\",\n+                &format!(\"attribute should be applied to {} {}\", article, allowed_targets)\n             )\n+            .span_label(*span, &format!(\"not {} {}\", article, allowed_targets))\n+            .emit();\n         }\n \n         // Just point at all repr hints if there are any incompatibilities.\n@@ -703,64 +714,63 @@ impl CheckAttrVisitor<'tcx> {\n         }\n     }\n \n-    fn emit_repr_error(\n-        &self,\n-        hint_span: Span,\n-        label_span: Span,\n-        hint_message: &str,\n-        label_message: &str,\n-    ) {\n-        struct_span_err!(self.tcx.sess, hint_span, E0517, \"{}\", hint_message)\n-            .span_label(label_span, label_message)\n-            .emit();\n-    }\n-\n-    fn check_stmt_attributes(&self, stmt: &hir::Stmt<'_>) {\n-        // When checking statements ignore expressions, they will be checked later\n-        if let hir::StmtKind::Local(ref l) = stmt.kind {\n-            self.check_attributes(l.hir_id, &l.attrs, &stmt.span, Target::Statement, None);\n-            for attr in l.attrs.iter() {\n-                if self.tcx.sess.check_name(attr, sym::repr) {\n-                    self.emit_repr_error(\n-                        attr.span,\n-                        stmt.span,\n-                        \"attribute should not be applied to a statement\",\n-                        \"not a struct, enum, or union\",\n-                    );\n-                }\n+    fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n+        for attr in attrs {\n+            if self.tcx.sess.check_name(attr, sym::used) && target != Target::Static {\n+                self.tcx\n+                    .sess\n+                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n             }\n         }\n     }\n \n-    fn check_expr_attributes(&self, expr: &hir::Expr<'_>) {\n-        let target = match expr.kind {\n-            hir::ExprKind::Closure(..) => Target::Closure,\n-            _ => Target::Expression,\n-        };\n-        self.check_attributes(expr.hir_id, &expr.attrs, &expr.span, target, None);\n-        for attr in expr.attrs.iter() {\n-            if self.tcx.sess.check_name(attr, sym::repr) {\n-                self.emit_repr_error(\n-                    attr.span,\n-                    expr.span,\n-                    \"attribute should not be applied to an expression\",\n-                    \"not defining a struct, enum, or union\",\n-                );\n+    /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros.\n+    /// (Allows proc_macro functions)\n+    fn check_allow_internal_unstable(\n+        &self,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+        attrs: &[Attribute],\n+    ) -> bool {\n+        debug!(\"Checking target: {:?}\", target);\n+        if target == Target::Fn {\n+            for attr in attrs {\n+                if self.tcx.sess.is_proc_macro_attr(attr) {\n+                    debug!(\"Is proc macro attr\");\n+                    return true;\n+                }\n             }\n+            debug!(\"Is not proc macro attr\");\n         }\n-        if target == Target::Closure {\n-            self.tcx.ensure().codegen_fn_attrs(self.tcx.hir().local_def_id(expr.hir_id));\n-        }\n+        self.tcx\n+            .sess\n+            .struct_span_err(attr.span, \"attribute should be applied to a macro\")\n+            .span_label(*span, \"not a macro\")\n+            .emit();\n+        false\n     }\n \n-    fn check_used(&self, attrs: &'hir [Attribute], target: Target) {\n-        for attr in attrs {\n-            if self.tcx.sess.check_name(attr, sym::used) && target != Target::Static {\n-                self.tcx\n-                    .sess\n-                    .span_err(attr.span, \"attribute must be applied to a `static` variable\");\n+    /// Outputs an error for `#[allow_internal_unstable]` which can only be applied to macros.\n+    /// (Allows proc_macro functions)\n+    fn check_rustc_allow_const_fn_unstable(\n+        &self,\n+        hir_id: HirId,\n+        attr: &Attribute,\n+        span: &Span,\n+        target: Target,\n+    ) -> bool {\n+        if let Target::Fn | Target::Method(_) = target {\n+            if self.tcx.is_const_fn_raw(self.tcx.hir().local_def_id(hir_id)) {\n+                return true;\n             }\n         }\n+        self.tcx\n+            .sess\n+            .struct_span_err(attr.span, \"attribute should be applied to `const fn`\")\n+            .span_label(*span, \"not a `const fn`\")\n+            .emit();\n+        false\n     }\n }\n \n@@ -808,14 +818,32 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n     }\n \n     fn visit_stmt(&mut self, stmt: &'tcx hir::Stmt<'tcx>) {\n-        self.check_stmt_attributes(stmt);\n+        // When checking statements ignore expressions, they will be checked later.\n+        if let hir::StmtKind::Local(ref l) = stmt.kind {\n+            self.check_attributes(l.hir_id, &l.attrs, &stmt.span, Target::Statement, None);\n+        }\n         intravisit::walk_stmt(self, stmt)\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx hir::Expr<'tcx>) {\n-        self.check_expr_attributes(expr);\n+        let target = match expr.kind {\n+            hir::ExprKind::Closure(..) => Target::Closure,\n+            _ => Target::Expression,\n+        };\n+\n+        self.check_attributes(expr.hir_id, &expr.attrs, &expr.span, target, None);\n         intravisit::walk_expr(self, expr)\n     }\n+\n+    fn visit_variant(\n+        &mut self,\n+        variant: &'tcx hir::Variant<'tcx>,\n+        generics: &'tcx hir::Generics<'tcx>,\n+        item_id: HirId,\n+    ) {\n+        self.check_attributes(variant.id, variant.attrs, &variant.span, Target::Variant, None);\n+        intravisit::walk_variant(self, variant, generics, item_id)\n+    }\n }\n \n fn is_c_like_enum(item: &Item<'_>) -> bool {"}, {"sha": "b24c62b971a468a31ca5e32b36a8051cb68b1dc1", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -87,7 +87,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n \n         let is_feature_allowed = |feature_gate| {\n             // All features require that the corresponding gate be enabled,\n-            // even if the function has `#[allow_internal_unstable(the_gate)]`.\n+            // even if the function has `#[rustc_allow_const_fn_unstable(the_gate)]`.\n             if !tcx.features().enabled(feature_gate) {\n                 return false;\n             }\n@@ -105,8 +105,8 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             }\n \n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n-            // opt-in via `allow_internal_unstable`.\n-            attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n+            // opt-in via `rustc_allow_const_fn_unstable`.\n+            attr::rustc_allow_const_fn_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n                 .map_or(false, |mut features| features.any(|name| name == feature_gate))\n         };\n "}, {"sha": "f567dd83bc13dc6b4b6ae3aee3fc1d04b3b60b4f", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -458,8 +458,8 @@ fn create_and_seed_worklist<'tcx>(\n         .map\n         .iter()\n         .filter_map(\n-            |(&id, level)| {\n-                if level >= &privacy::AccessLevel::Reachable { Some(id) } else { None }\n+            |(&id, &level)| {\n+                if level >= privacy::AccessLevel::Reachable { Some(id) } else { None }\n             },\n         )\n         .chain(\n@@ -547,7 +547,7 @@ impl DeadVisitor<'tcx> {\n         let def_id = self.tcx.hir().local_def_id(id);\n         let inherent_impls = self.tcx.inherent_impls(def_id);\n         for &impl_did in inherent_impls.iter() {\n-            for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n+            for item_did in self.tcx.associated_item_def_ids(impl_did) {\n                 if let Some(did) = item_did.as_local() {\n                     let item_hir_id = self.tcx.hir().local_def_id_to_hir_id(did);\n                     if self.live_symbols.contains(&item_hir_id) {"}, {"sha": "6d1a5fcc10b0ff14ff9c10e316e0358d3bef0370", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -163,4 +163,17 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n         // we are currently in. So for those it's correct that they have a\n         // different owner.\n     }\n+\n+    fn visit_generic_param(&mut self, param: &'hir hir::GenericParam<'hir>) {\n+        if let hir::GenericParamKind::Type {\n+            synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+            ..\n+        } = param.kind\n+        {\n+            // Synthetic impl trait parameters are owned by the node of the desugared type.\n+            // This means it is correct for them to have a different owner.\n+        } else {\n+            intravisit::walk_generic_param(self, param);\n+        }\n+    }\n }"}, {"sha": "7288015e170293f2170263909f0918088939be60", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -432,6 +432,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n             | hir::ExprKind::Break(..)\n             | hir::ExprKind::Continue(_)\n             | hir::ExprKind::Lit(_)\n+            | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Ret(..)\n             | hir::ExprKind::Block(..)\n             | hir::ExprKind::Assign(..)\n@@ -1173,7 +1174,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                             }\n                         }\n                         hir::InlineAsmOperand::InOut { expr, .. } => {\n-                            succ = self.write_place(expr, succ, ACC_READ | ACC_WRITE);\n+                            succ = self.write_place(expr, succ, ACC_READ | ACC_WRITE | ACC_USE);\n                         }\n                         hir::InlineAsmOperand::SplitInOut { out_expr, .. } => {\n                             if let Some(expr) = out_expr {\n@@ -1232,6 +1233,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             hir::ExprKind::Lit(..)\n+            | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Err\n             | hir::ExprKind::Path(hir::QPath::TypeRelative(..))\n             | hir::ExprKind::Path(hir::QPath::LangItem(..)) => succ,\n@@ -1478,6 +1480,7 @@ fn check_expr<'tcx>(this: &mut Liveness<'_, 'tcx>, expr: &'tcx Expr<'tcx>) {\n         | hir::ExprKind::Break(..)\n         | hir::ExprKind::Continue(..)\n         | hir::ExprKind::Lit(_)\n+        | hir::ExprKind::ConstBlock(..)\n         | hir::ExprKind::Block(..)\n         | hir::ExprKind::AddrOf(..)\n         | hir::ExprKind::Struct(..)"}, {"sha": "c9497f2a5b2b058a3b89150d82e556515a442461", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,15 +13,13 @@ use rustc_hir::{Generics, HirId, Item, StructField, TraitRef, Ty, TyKind, Varian\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::middle::stability::{DeprecationEntry, Index};\n-use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, query::Providers, TyCtxt};\n use rustc_session::lint;\n use rustc_session::lint::builtin::INEFFECTIVE_UNSTABLE_TRAIT_IMPL;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::Span;\n-use rustc_trait_selection::traits::misc::can_type_implement_copy;\n+use rustc_span::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n use std::mem::replace;\n@@ -711,27 +709,35 @@ impl Visitor<'tcx> for Checker<'tcx> {\n             // so semi-randomly perform it here in stability.rs\n             hir::ItemKind::Union(..) if !self.tcx.features().untagged_unions => {\n                 let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                let adt_def = self.tcx.adt_def(def_id);\n                 let ty = self.tcx.type_of(def_id);\n+                let (adt_def, substs) = match ty.kind() {\n+                    ty::Adt(adt_def, substs) => (adt_def, substs),\n+                    _ => bug!(),\n+                };\n \n-                if adt_def.has_dtor(self.tcx) {\n-                    feature_err(\n-                        &self.tcx.sess.parse_sess,\n-                        sym::untagged_unions,\n-                        item.span,\n-                        \"unions with `Drop` implementations are unstable\",\n-                    )\n-                    .emit();\n-                } else {\n-                    let param_env = self.tcx.param_env(def_id);\n-                    if can_type_implement_copy(self.tcx, param_env, ty).is_err() {\n-                        feature_err(\n-                            &self.tcx.sess.parse_sess,\n-                            sym::untagged_unions,\n-                            item.span,\n-                            \"unions with non-`Copy` fields are unstable\",\n-                        )\n-                        .emit();\n+                // Non-`Copy` fields are unstable, except for `ManuallyDrop`.\n+                let param_env = self.tcx.param_env(def_id);\n+                for field in &adt_def.non_enum_variant().fields {\n+                    let field_ty = field.ty(self.tcx, substs);\n+                    if !field_ty.ty_adt_def().map_or(false, |adt_def| adt_def.is_manually_drop())\n+                        && !field_ty.is_copy_modulo_regions(self.tcx.at(DUMMY_SP), param_env)\n+                    {\n+                        if field_ty.needs_drop(self.tcx, param_env) {\n+                            // Avoid duplicate error: This will error later anyway because fields\n+                            // that need drop are not allowed.\n+                            self.tcx.sess.delay_span_bug(\n+                                item.span,\n+                                \"union should have been rejected due to potentially dropping field\",\n+                            );\n+                        } else {\n+                            feature_err(\n+                                &self.tcx.sess.parse_sess,\n+                                sym::untagged_unions,\n+                                self.tcx.def_span(field.did),\n+                                \"unions with non-`Copy` fields other than `ManuallyDrop<T>` are unstable\",\n+                            )\n+                            .emit();\n+                        }\n                     }\n                 }\n             }"}, {"sha": "851e0dfbe0d45dbeb0a1b43931fb7975cc8c769c", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 81, "deletions": 138, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(or_patterns)]\n #![recursion_limit = \"256\"]\n \n use rustc_attr as attr;\n@@ -14,13 +15,14 @@ use rustc_hir::{AssocItemKind, HirIdSet, Node, PatKind};\n use rustc_middle::bug;\n use rustc_middle::hir::map::Map;\n use rustc_middle::middle::privacy::{AccessLevel, AccessLevels};\n+use rustc_middle::span_bug;\n use rustc_middle::ty::fold::TypeVisitor;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::{self, GenericParamDefKind, TraitRef, Ty, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n use rustc_span::hygiene::Transparency;\n-use rustc_span::symbol::{kw, sym, Ident};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n use std::marker::PhantomData;\n@@ -233,125 +235,6 @@ where\n     }\n }\n \n-fn def_id_visibility<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: DefId,\n-) -> (ty::Visibility, Span, &'static str) {\n-    match def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id)) {\n-        Some(hir_id) => {\n-            let vis = match tcx.hir().get(hir_id) {\n-                Node::Item(item) => &item.vis,\n-                Node::ForeignItem(foreign_item) => &foreign_item.vis,\n-                Node::MacroDef(macro_def) => {\n-                    if tcx.sess.contains_name(&macro_def.attrs, sym::macro_export) {\n-                        return (ty::Visibility::Public, macro_def.span, \"public\");\n-                    } else {\n-                        &macro_def.vis\n-                    }\n-                }\n-                Node::TraitItem(..) | Node::Variant(..) => {\n-                    return def_id_visibility(tcx, tcx.hir().get_parent_did(hir_id).to_def_id());\n-                }\n-                Node::ImplItem(impl_item) => {\n-                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n-                        Node::Item(item) => match &item.kind {\n-                            hir::ItemKind::Impl { of_trait: None, .. } => &impl_item.vis,\n-                            hir::ItemKind::Impl { of_trait: Some(trait_ref), .. } => {\n-                                return def_id_visibility(tcx, trait_ref.path.res.def_id());\n-                            }\n-                            kind => bug!(\"unexpected item kind: {:?}\", kind),\n-                        },\n-                        node => bug!(\"unexpected node kind: {:?}\", node),\n-                    }\n-                }\n-                Node::Ctor(vdata) => {\n-                    let parent_hir_id = tcx.hir().get_parent_node(hir_id);\n-                    match tcx.hir().get(parent_hir_id) {\n-                        Node::Variant(..) => {\n-                            let parent_did = tcx.hir().local_def_id(parent_hir_id);\n-                            let (mut ctor_vis, mut span, mut descr) =\n-                                def_id_visibility(tcx, parent_did.to_def_id());\n-\n-                            let adt_def = tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n-                            let ctor_did = tcx.hir().local_def_id(vdata.ctor_hir_id().unwrap());\n-                            let variant = adt_def.variant_with_ctor_id(ctor_did.to_def_id());\n-\n-                            if variant.is_field_list_non_exhaustive()\n-                                && ctor_vis == ty::Visibility::Public\n-                            {\n-                                ctor_vis =\n-                                    ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                let attrs = tcx.get_attrs(variant.def_id);\n-                                span = tcx\n-                                    .sess\n-                                    .find_by_name(&attrs, sym::non_exhaustive)\n-                                    .unwrap()\n-                                    .span;\n-                                descr = \"crate-visible\";\n-                            }\n-\n-                            return (ctor_vis, span, descr);\n-                        }\n-                        Node::Item(..) => {\n-                            let item = match tcx.hir().get(parent_hir_id) {\n-                                Node::Item(item) => item,\n-                                node => bug!(\"unexpected node kind: {:?}\", node),\n-                            };\n-                            let (mut ctor_vis, mut span, mut descr) = (\n-                                ty::Visibility::from_hir(&item.vis, parent_hir_id, tcx),\n-                                item.vis.span,\n-                                item.vis.node.descr(),\n-                            );\n-                            for field in vdata.fields() {\n-                                let field_vis = ty::Visibility::from_hir(&field.vis, hir_id, tcx);\n-                                if ctor_vis.is_at_least(field_vis, tcx) {\n-                                    ctor_vis = field_vis;\n-                                    span = field.vis.span;\n-                                    descr = field.vis.node.descr();\n-                                }\n-                            }\n-\n-                            // If the structure is marked as non_exhaustive then lower the\n-                            // visibility to within the crate.\n-                            if ctor_vis == ty::Visibility::Public {\n-                                let adt_def =\n-                                    tcx.adt_def(tcx.hir().get_parent_did(hir_id).to_def_id());\n-                                if adt_def.non_enum_variant().is_field_list_non_exhaustive() {\n-                                    ctor_vis =\n-                                        ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-                                    span = tcx\n-                                        .sess\n-                                        .find_by_name(&item.attrs, sym::non_exhaustive)\n-                                        .unwrap()\n-                                        .span;\n-                                    descr = \"crate-visible\";\n-                                }\n-                            }\n-\n-                            return (ctor_vis, span, descr);\n-                        }\n-                        node => bug!(\"unexpected node kind: {:?}\", node),\n-                    }\n-                }\n-                Node::Expr(expr) => {\n-                    return (\n-                        ty::Visibility::Restricted(tcx.parent_module(expr.hir_id).to_def_id()),\n-                        expr.span,\n-                        \"private\",\n-                    );\n-                }\n-                node => bug!(\"unexpected node kind: {:?}\", node),\n-            };\n-            (ty::Visibility::from_hir(vis, hir_id, tcx), vis.span, vis.node.descr())\n-        }\n-        None => {\n-            let vis = tcx.visibility(def_id);\n-            let descr = if vis == ty::Visibility::Public { \"public\" } else { \"private\" };\n-            (vis, tcx.def_span(def_id), descr)\n-        }\n-    }\n-}\n-\n fn min(vis1: ty::Visibility, vis2: ty::Visibility, tcx: TyCtxt<'_>) -> ty::Visibility {\n     if vis1.is_at_least(vis2, tcx) { vis2 } else { vis1 }\n }\n@@ -424,7 +307,7 @@ trait VisibilityLike: Sized {\n impl VisibilityLike for ty::Visibility {\n     const MAX: Self = ty::Visibility::Public;\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n-        min(def_id_visibility(find.tcx, def_id).0, find.min, find.tcx)\n+        min(find.tcx.visibility(def_id), find.min, find.tcx)\n     }\n }\n impl VisibilityLike for Option<AccessLevel> {\n@@ -534,17 +417,16 @@ impl EmbargoVisitor<'tcx> {\n             let hir_id = item_id.id;\n             let item_def_id = self.tcx.hir().local_def_id(hir_id);\n             let def_kind = self.tcx.def_kind(item_def_id);\n-            let item = self.tcx.hir().expect_item(hir_id);\n-            let vis = ty::Visibility::from_hir(&item.vis, hir_id, self.tcx);\n+            let vis = self.tcx.visibility(item_def_id);\n             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_exports(module_def_id) {\n             for export in exports {\n                 if export.vis.is_accessible_from(defining_mod, self.tcx) {\n                     if let Res::Def(def_kind, def_id) = export.res {\n-                        let vis = def_id_visibility(self.tcx, def_id).0;\n                         if let Some(def_id) = def_id.as_local() {\n                             let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                            let vis = self.tcx.visibility(def_id.to_def_id());\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -596,7 +478,7 @@ impl EmbargoVisitor<'tcx> {\n                     {\n                         for field in struct_def.fields() {\n                             let field_vis =\n-                                ty::Visibility::from_hir(&field.vis, field.hir_id, self.tcx);\n+                                self.tcx.visibility(self.tcx.hir().local_def_id(field.hir_id));\n                             if field_vis.is_accessible_from(module, self.tcx) {\n                                 self.reach(field.hir_id, level).ty();\n                             }\n@@ -1015,11 +897,10 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n-            if let ((ty::Visibility::Public, ..), _)\n-            | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n-                (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n+            if let (ty::Visibility::Public, _) | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n+                (self.tcx().visibility(def_id.to_def_id()), self.access_level)\n             {\n+                let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n                 self.ev.update(hir_id, self.access_level);\n             }\n         }\n@@ -1184,9 +1065,7 @@ impl<'tcx> TypePrivacyVisitor<'tcx> {\n     }\n \n     fn item_is_accessible(&self, did: DefId) -> bool {\n-        def_id_visibility(self.tcx, did)\n-            .0\n-            .is_accessible_from(self.current_item.to_def_id(), self.tcx)\n+        self.tcx.visibility(did).is_accessible_from(self.current_item.to_def_id(), self.tcx)\n     }\n \n     // Take node-id of an expression or pattern and check its type for privacy.\n@@ -1840,15 +1719,30 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n             None => return false,\n         };\n \n-        let (vis, vis_span, vis_descr) = def_id_visibility(self.tcx, def_id);\n+        let vis = self.tcx.visibility(def_id);\n         if !vis.is_at_least(self.required_visibility, self.tcx) {\n+            let vis_descr = match vis {\n+                ty::Visibility::Public => \"public\",\n+                ty::Visibility::Invisible => \"private\",\n+                ty::Visibility::Restricted(vis_def_id) => {\n+                    if vis_def_id == self.tcx.parent_module(hir_id).to_def_id() {\n+                        \"private\"\n+                    } else if vis_def_id.is_top_level_module() {\n+                        \"crate-private\"\n+                    } else {\n+                        \"restricted\"\n+                    }\n+                }\n+            };\n             let make_msg = || format!(\"{} {} `{}` in public interface\", vis_descr, kind, descr);\n             if self.has_pub_restricted || self.has_old_errors || self.in_assoc_ty {\n                 let mut err = if kind == \"trait\" {\n                     struct_span_err!(self.tcx.sess, self.span, E0445, \"{}\", make_msg())\n                 } else {\n                     struct_span_err!(self.tcx.sess, self.span, E0446, \"{}\", make_msg())\n                 };\n+                let vis_span =\n+                    self.tcx.sess.source_map().guess_head_span(self.tcx.def_span(def_id));\n                 err.span_label(self.span, format!(\"can't leak {} {}\", vis_descr, kind));\n                 err.span_label(vis_span, format!(\"`{}` declared as {}\", descr, vis_descr));\n                 err.emit();\n@@ -1965,7 +1859,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         let tcx = self.tcx;\n-        let item_visibility = ty::Visibility::from_hir(&item.vis, item.hir_id, tcx);\n+        let item_visibility = tcx.visibility(tcx.hir().local_def_id(item.hir_id).to_def_id());\n \n         match item.kind {\n             // Crates are always public.\n@@ -2019,7 +1913,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n             // Subitems of foreign modules have their own publicity.\n             hir::ItemKind::ForeignMod(ref foreign_mod) => {\n                 for foreign_item in foreign_mod.items {\n-                    let vis = ty::Visibility::from_hir(&foreign_item.vis, item.hir_id, tcx);\n+                    let vis = tcx.visibility(tcx.hir().local_def_id(foreign_item.hir_id));\n                     self.check(foreign_item.hir_id, vis).generics().predicates().ty();\n                 }\n             }\n@@ -2028,7 +1922,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for field in struct_def.fields() {\n-                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.hir_id, tcx);\n+                    let field_visibility = tcx.visibility(tcx.hir().local_def_id(field.hir_id));\n                     self.check(field.hir_id, min(item_visibility, field_visibility, tcx)).ty();\n                 }\n             }\n@@ -2040,10 +1934,9 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 let impl_vis = ty::Visibility::of_impl(item.hir_id, tcx, &Default::default());\n                 self.check(item.hir_id, impl_vis).generics().predicates();\n                 for impl_item_ref in items {\n-                    let impl_item = tcx.hir().impl_item(impl_item_ref.id);\n                     let impl_item_vis = if of_trait.is_none() {\n                         min(\n-                            ty::Visibility::from_hir(&impl_item.vis, item.hir_id, tcx),\n+                            tcx.visibility(tcx.hir().local_def_id(impl_item_ref.id.hir_id)),\n                             impl_vis,\n                             tcx,\n                         )\n@@ -2064,13 +1957,63 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n \n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n+        visibility,\n         privacy_access_levels,\n         check_private_in_public,\n         check_mod_privacy,\n         ..*providers\n     };\n }\n \n+fn visibility(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Visibility {\n+    let def_id = def_id.expect_local();\n+    match tcx.visibilities.get(&def_id) {\n+        Some(vis) => *vis,\n+        None => {\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+            match tcx.hir().get(hir_id) {\n+                // Unique types created for closures participate in type privacy checking.\n+                // They have visibilities inherited from the module they are defined in.\n+                Node::Expr(hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n+                    ty::Visibility::Restricted(tcx.parent_module(hir_id).to_def_id())\n+                }\n+                // - AST lowering may clone `use` items and the clones don't\n+                //   get their entries in the resolver's visibility table.\n+                // - AST lowering also creates opaque type items with inherited visibilies.\n+                //   Visibility on them should have no effect, but to avoid the visibility\n+                //   query failing on some items, we provide it for opaque types as well.\n+                Node::Item(hir::Item {\n+                    vis,\n+                    kind: hir::ItemKind::Use(..) | hir::ItemKind::OpaqueTy(..),\n+                    ..\n+                }) => ty::Visibility::from_hir(vis, hir_id, tcx),\n+                // Visibilities of trait impl items are inherited from their traits\n+                // and are not filled in resolve.\n+                Node::ImplItem(impl_item) => {\n+                    match tcx.hir().get(tcx.hir().get_parent_item(hir_id)) {\n+                        Node::Item(hir::Item {\n+                            kind: hir::ItemKind::Impl { of_trait: Some(tr), .. },\n+                            ..\n+                        }) => tr.path.res.opt_def_id().map_or_else(\n+                            || {\n+                                tcx.sess.delay_span_bug(tr.path.span, \"trait without a def-id\");\n+                                ty::Visibility::Public\n+                            },\n+                            |def_id| tcx.visibility(def_id),\n+                        ),\n+                        _ => span_bug!(impl_item.span, \"the parent is not a trait impl\"),\n+                    }\n+                }\n+                _ => span_bug!(\n+                    tcx.def_span(def_id),\n+                    \"visibility table unexpectedly missing a def-id: {:?}\",\n+                    def_id,\n+                ),\n+            }\n+        }\n+    }\n+}\n+\n fn check_mod_privacy(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     // Check privacy of names not checked in previous compilation stages.\n     let mut visitor = NamePrivacyVisitor { tcx, maybe_typeck_results: None, current_item: None };"}, {"sha": "7bc6ae1d1c6c3ecdde83f4b2f57de6879134bac2", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,12 +1,12 @@\n use crate::dep_graph::DepNodeIndex;\n use crate::query::plumbing::{QueryLookup, QueryState};\n-use crate::query::QueryContext;\n \n use rustc_arena::TypedArena;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sharded::Sharded;\n use rustc_data_structures::sync::WorkerLocal;\n use std::default::Default;\n+use std::fmt::Debug;\n use std::hash::Hash;\n use std::marker::PhantomData;\n \n@@ -24,24 +24,24 @@ pub trait QueryStorage: Default {\n }\n \n pub trait QueryCache: QueryStorage {\n-    type Key: Hash;\n+    type Key: Hash + Eq + Clone + Debug;\n     type Sharded: Default;\n \n     /// Checks if the query is already computed and in the cache.\n     /// It returns the shard index and a lock guard to the shard,\n     /// which will be used if the query is not in the cache and we need\n     /// to compute it.\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: Self::Key,\n         // `on_hit` can be called while holding a lock to the query state shard.\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&Self::Stored, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(Self::Key, QueryLookup<'_, CTX, Self::Key, Self::Sharded>) -> R;\n+        OnMiss: FnOnce(Self::Key, QueryLookup<'_, D, Q, Self::Key, Self::Sharded>) -> R;\n \n     fn complete(\n         &self,\n@@ -86,21 +86,25 @@ impl<K: Eq + Hash, V: Clone> QueryStorage for DefaultCache<K, V> {\n     }\n }\n \n-impl<K: Eq + Hash, V: Clone> QueryCache for DefaultCache<K, V> {\n+impl<K, V> QueryCache for DefaultCache<K, V>\n+where\n+    K: Eq + Hash + Clone + Debug,\n+    V: Clone,\n+{\n     type Key = K;\n     type Sharded = FxHashMap<K, (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, CTX, K, Self::Sharded>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;\n@@ -164,21 +168,24 @@ impl<'tcx, K: Eq + Hash, V: 'tcx> QueryStorage for ArenaCache<'tcx, K, V> {\n     }\n }\n \n-impl<'tcx, K: Eq + Hash, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V> {\n+impl<'tcx, K, V: 'tcx> QueryCache for ArenaCache<'tcx, K, V>\n+where\n+    K: Eq + Hash + Clone + Debug,\n+{\n     type Key = K;\n     type Sharded = FxHashMap<K, &'tcx (V, DepNodeIndex)>;\n \n     #[inline(always)]\n-    fn lookup<CTX: QueryContext, R, OnHit, OnMiss>(\n+    fn lookup<D, Q, R, OnHit, OnMiss>(\n         &self,\n-        state: &QueryState<CTX, Self>,\n+        state: &QueryState<D, Q, Self>,\n         key: K,\n         on_hit: OnHit,\n         on_miss: OnMiss,\n     ) -> R\n     where\n         OnHit: FnOnce(&&'tcx V, DepNodeIndex) -> R,\n-        OnMiss: FnOnce(K, QueryLookup<'_, CTX, K, Self::Sharded>) -> R,\n+        OnMiss: FnOnce(K, QueryLookup<'_, D, Q, K, Self::Sharded>) -> R,\n     {\n         let mut lookup = state.get_lookup(&key);\n         let lock = &mut *lookup.lock;"}, {"sha": "0f0684b354791b549120d1e29101ac9a0095955b", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -5,18 +5,14 @@ use crate::dep_graph::SerializedDepNodeIndex;\n use crate::query::caches::QueryCache;\n use crate::query::plumbing::CycleError;\n use crate::query::{QueryContext, QueryState};\n-use rustc_data_structures::profiling::ProfileCategory;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::borrow::Cow;\n use std::fmt::Debug;\n use std::hash::Hash;\n \n-// The parameter `CTX` is required in librustc_middle:\n-// implementations may need to access the `'tcx` lifetime in `CTX = TyCtxt<'tcx>`.\n-pub trait QueryConfig<CTX> {\n+pub trait QueryConfig {\n     const NAME: &'static str;\n-    const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n     type Value;\n@@ -70,15 +66,15 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n     }\n }\n \n-pub trait QueryAccessors<CTX: QueryContext>: QueryConfig<CTX> {\n+pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     const ANON: bool;\n     const EVAL_ALWAYS: bool;\n     const DEP_KIND: CTX::DepKind;\n \n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX, Self::Cache>;\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Cache>;\n \n     fn to_dep_node(tcx: CTX, key: &Self::Key) -> DepNode<CTX::DepKind>\n     where"}, {"sha": "c1d3210b61768308ca310fc8f201a9c8ea23b4f6", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 98, "deletions": 72, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,16 +1,16 @@\n-use crate::dep_graph::{DepContext, DepKind};\n use crate::query::plumbing::CycleError;\n-use crate::query::QueryContext;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::Span;\n \n use std::convert::TryFrom;\n+use std::hash::Hash;\n use std::marker::PhantomData;\n use std::num::NonZeroU32;\n \n #[cfg(parallel_compiler)]\n use {\n+    super::QueryContext,\n     parking_lot::{Condvar, Mutex},\n     rustc_data_structures::fx::FxHashSet,\n     rustc_data_structures::stable_hasher::{HashStable, StableHasher},\n@@ -31,79 +31,83 @@ pub struct QueryInfo<Q> {\n     pub query: Q,\n }\n \n-type QueryMap<CTX> = FxHashMap<QueryJobId<<CTX as DepContext>::DepKind>, QueryJobInfo<CTX>>;\n+pub(crate) type QueryMap<D, Q> = FxHashMap<QueryJobId<D>, QueryJobInfo<D, Q>>;\n \n /// A value uniquely identifiying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub struct QueryShardJobId(pub NonZeroU32);\n \n /// A value uniquely identifiying an active query job.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n-pub struct QueryJobId<K> {\n+pub struct QueryJobId<D> {\n     /// Which job within a shard is this\n     pub job: QueryShardJobId,\n \n     /// In which shard is this job\n     pub shard: u16,\n \n-    /// What kind of query this job is\n-    pub kind: K,\n+    /// What kind of query this job is.\n+    pub kind: D,\n }\n \n-impl<K: DepKind> QueryJobId<K> {\n-    pub fn new(job: QueryShardJobId, shard: usize, kind: K) -> Self {\n+impl<D> QueryJobId<D>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+{\n+    pub fn new(job: QueryShardJobId, shard: usize, kind: D) -> Self {\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n \n-    fn query<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> CTX::Query {\n+    fn query<Q: Clone>(self, map: &QueryMap<D, Q>) -> Q {\n         map.get(&self).unwrap().info.query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Span {\n+    fn span<Q: Clone>(self, map: &QueryMap<D, Q>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent<CTX: QueryContext<DepKind = K>>(self, map: &QueryMap<CTX>) -> Option<QueryJobId<K>> {\n+    fn parent<Q: Clone>(self, map: &QueryMap<D, Q>) -> Option<QueryJobId<D>> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a, CTX: QueryContext<DepKind = K>>(\n-        self,\n-        map: &'a QueryMap<CTX>,\n-    ) -> Option<&'a QueryLatch<CTX>> {\n+    fn latch<'a, Q: Clone>(self, map: &'a QueryMap<D, Q>) -> Option<&'a QueryLatch<D, Q>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n-pub struct QueryJobInfo<CTX: QueryContext> {\n-    pub info: QueryInfo<CTX::Query>,\n-    pub job: QueryJob<CTX>,\n+pub struct QueryJobInfo<D, Q> {\n+    pub info: QueryInfo<Q>,\n+    pub job: QueryJob<D, Q>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob<CTX: QueryContext> {\n+pub struct QueryJob<D, Q> {\n     pub id: QueryShardJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n \n     /// The parent query job which created this job and is implicitly waiting on it.\n-    pub parent: Option<QueryJobId<CTX::DepKind>>,\n+    pub parent: Option<QueryJobId<D>>,\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch<CTX>>,\n+    latch: Option<QueryLatch<D, Q>>,\n \n-    dummy: PhantomData<QueryLatch<CTX>>,\n+    dummy: PhantomData<QueryLatch<D, Q>>,\n }\n \n-impl<CTX: QueryContext> QueryJob<CTX> {\n+impl<D, Q> QueryJob<D, Q>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     /// Creates a new query job.\n-    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<CTX::DepKind>>) -> Self {\n+    pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<D>>) -> Self {\n         QueryJob {\n             id,\n             span,\n@@ -115,15 +119,15 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self, _id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, _id: QueryJobId<D>) -> QueryLatch<D, Q> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n         self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn latch(&mut self, id: QueryJobId<CTX::DepKind>) -> QueryLatch<CTX> {\n+    pub(super) fn latch(&mut self, id: QueryJobId<D>) -> QueryLatch<D, Q> {\n         QueryLatch { id, dummy: PhantomData }\n     }\n \n@@ -143,19 +147,26 @@ impl<CTX: QueryContext> QueryJob<CTX> {\n \n #[cfg(not(parallel_compiler))]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<CTX: QueryContext> {\n-    id: QueryJobId<CTX::DepKind>,\n-    dummy: PhantomData<CTX>,\n+pub(super) struct QueryLatch<D, Q> {\n+    id: QueryJobId<D>,\n+    dummy: PhantomData<Q>,\n }\n \n #[cfg(not(parallel_compiler))]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n-    pub(super) fn find_cycle_in_stack(&self, tcx: CTX, span: Span) -> CycleError<CTX::Query> {\n-        let query_map = tcx.try_collect_active_jobs().unwrap();\n-\n-        // Get the current executing query (waiter) and find the waitee amongst its parents\n-        let mut current_job = tcx.current_query_job();\n+impl<D, Q> QueryLatch<D, Q>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n+    pub(super) fn find_cycle_in_stack(\n+        &self,\n+        query_map: QueryMap<D, Q>,\n+        current_job: &Option<QueryJobId<D>>,\n+        span: Span,\n+    ) -> CycleError<Q> {\n+        // Find the waitee amongst `current_job` parents\n         let mut cycle = Vec::new();\n+        let mut current_job = Option::clone(current_job);\n \n         while let Some(job) = current_job {\n             let info = query_map.get(&job).unwrap();\n@@ -186,35 +197,35 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter<CTX: QueryContext> {\n-    query: Option<QueryJobId<CTX::DepKind>>,\n+struct QueryWaiter<D, Q> {\n+    query: Option<QueryJobId<D>>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError<CTX::Query>>>,\n+    cycle: Lock<Option<CycleError<Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryWaiter<CTX> {\n+impl<D, Q> QueryWaiter<D, Q> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo<CTX: QueryContext> {\n+struct QueryLatchInfo<D, Q> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter<CTX>>>,\n+    waiters: Vec<Lrc<QueryWaiter<D, Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<CTX: QueryContext> {\n-    info: Lrc<Mutex<QueryLatchInfo<CTX>>>,\n+pub(super) struct QueryLatch<D, Q> {\n+    info: Lrc<Mutex<QueryLatchInfo<D, Q>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n+impl<D: Eq + Hash, Q: Clone> QueryLatch<D, Q> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n@@ -223,10 +234,13 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n }\n \n #[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n+impl<D, Q> QueryLatch<D, Q> {\n     /// Awaits for the query job to complete.\n-    pub(super) fn wait_on(&self, tcx: CTX, span: Span) -> Result<(), CycleError<CTX::Query>> {\n-        let query = tcx.current_query_job();\n+    pub(super) fn wait_on(\n+        &self,\n+        query: Option<QueryJobId<D>>,\n+        span: Span,\n+    ) -> Result<(), CycleError<Q>> {\n         let waiter =\n             Lrc::new(QueryWaiter { query, span, cycle: Lock::new(None), condvar: Condvar::new() });\n         self.wait_on_inner(&waiter);\n@@ -239,12 +253,9 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n             Some(cycle) => Err(cycle),\n         }\n     }\n-}\n \n-#[cfg(parallel_compiler)]\n-impl<CTX: QueryContext> QueryLatch<CTX> {\n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<CTX>>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D, Q>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -278,7 +289,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<CTX>> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D, Q>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -288,7 +299,7 @@ impl<CTX: QueryContext> QueryLatch<CTX> {\n \n /// A resumable waiter of a query. The usize is the index into waiters in the query's latch\n #[cfg(parallel_compiler)]\n-type Waiter<K> = (QueryJobId<K>, usize);\n+type Waiter<D> = (QueryJobId<D>, usize);\n \n /// Visits all the non-resumable and resumable waiters of a query.\n /// Only waiters in a query are visited.\n@@ -300,13 +311,15 @@ type Waiter<K> = (QueryJobId<K>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<CTX: QueryContext, F>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n+fn visit_waiters<D, Q, F>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n     mut visit: F,\n-) -> Option<Option<Waiter<CTX::DepKind>>>\n+) -> Option<Option<Waiter<D>>>\n where\n-    F: FnMut(Span, QueryJobId<CTX::DepKind>) -> Option<Option<Waiter<CTX::DepKind>>>,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    F: FnMut(Span, QueryJobId<D>) -> Option<Option<Waiter<D>>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n     if let Some(parent) = query.parent(query_map) {\n@@ -335,13 +348,17 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n+fn cycle_check<D, Q>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n     span: Span,\n-    stack: &mut Vec<(Span, QueryJobId<CTX::DepKind>)>,\n-    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n-) -> Option<Option<Waiter<CTX::DepKind>>> {\n+    stack: &mut Vec<(Span, QueryJobId<D>)>,\n+    visited: &mut FxHashSet<QueryJobId<D>>,\n+) -> Option<Option<Waiter<D>>>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     if !visited.insert(query) {\n         return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n             // We detected a query cycle, fix up the initial span and return Some\n@@ -376,11 +393,15 @@ fn cycle_check<CTX: QueryContext>(\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n-    query: QueryJobId<CTX::DepKind>,\n-    visited: &mut FxHashSet<QueryJobId<CTX::DepKind>>,\n-) -> bool {\n+fn connected_to_root<D, Q>(\n+    query_map: &QueryMap<D, Q>,\n+    query: QueryJobId<D>,\n+    visited: &mut FxHashSet<QueryJobId<D>>,\n+) -> bool\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+{\n     // We already visited this or we're deliberately ignoring it\n     if !visited.insert(query) {\n         return false;\n@@ -399,7 +420,12 @@ fn connected_to_root<CTX: QueryContext>(\n \n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n-fn pick_query<'a, CTX, T, F>(query_map: &QueryMap<CTX>, tcx: CTX, queries: &'a [T], f: F) -> &'a T\n+fn pick_query<'a, CTX, T, F>(\n+    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n+    tcx: CTX,\n+    queries: &'a [T],\n+    f: F,\n+) -> &'a T\n where\n     CTX: QueryContext,\n     F: Fn(&T) -> (Span, QueryJobId<CTX::DepKind>),\n@@ -429,9 +455,9 @@ where\n /// the function returns false.\n #[cfg(parallel_compiler)]\n fn remove_cycle<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX>,\n+    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n     jobs: &mut Vec<QueryJobId<CTX::DepKind>>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter<CTX>>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<CTX::DepKind, CTX::Query>>>,\n     tcx: CTX,\n ) -> bool {\n     let mut visited = FxHashSet::default();"}, {"sha": "da45565dbe6bdad399081c066321490b204896b3", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -15,8 +15,8 @@ mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n use crate::dep_graph::{DepContext, DepGraph};\n+use crate::query::job::QueryMap;\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::HashStable;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n@@ -38,9 +38,7 @@ pub trait QueryContext: DepContext {\n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n \n-    fn try_collect_active_jobs(\n-        &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self>>>;\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind, Self::Query>>;\n \n     /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics"}, {"sha": "50f443716f44baf2c5313ea18bc5eaf55a555423", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 72, "deletions": 62, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -7,7 +7,7 @@ use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n-use crate::query::QueryContext;\n+use crate::query::{QueryContext, QueryMap};\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -20,42 +20,40 @@ use rustc_errors::{Diagnostic, FatalError};\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::Span;\n use std::collections::hash_map::Entry;\n-use std::convert::TryFrom;\n-use std::fmt::Debug;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::num::NonZeroU32;\n use std::ptr;\n #[cfg(debug_assertions)]\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n-pub(super) struct QueryStateShard<CTX: QueryContext, K, C> {\n+pub(super) struct QueryStateShard<D, Q, K, C> {\n     pub(super) cache: C,\n-    active: FxHashMap<K, QueryResult<CTX>>,\n+    active: FxHashMap<K, QueryResult<D, Q>>,\n \n     /// Used to generate unique ids for active jobs.\n     jobs: u32,\n }\n \n-impl<CTX: QueryContext, K, C: Default> Default for QueryStateShard<CTX, K, C> {\n-    fn default() -> QueryStateShard<CTX, K, C> {\n+impl<D, Q, K, C: Default> Default for QueryStateShard<D, Q, K, C> {\n+    fn default() -> QueryStateShard<D, Q, K, C> {\n         QueryStateShard { cache: Default::default(), active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub struct QueryState<CTX: QueryContext, C: QueryCache> {\n+pub struct QueryState<D, Q, C: QueryCache> {\n     cache: C,\n-    shards: Sharded<QueryStateShard<CTX, C::Key, C::Sharded>>,\n+    shards: Sharded<QueryStateShard<D, Q, C::Key, C::Sharded>>,\n     #[cfg(debug_assertions)]\n     pub cache_hits: AtomicUsize,\n }\n \n-impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n+impl<D, Q, C: QueryCache> QueryState<D, Q, C> {\n     #[inline]\n     pub(super) fn get_lookup<'tcx>(\n         &'tcx self,\n         key: &C::Key,\n-    ) -> QueryLookup<'tcx, CTX, C::Key, C::Sharded> {\n+    ) -> QueryLookup<'tcx, D, Q, C::Key, C::Sharded> {\n         // We compute the key's hash once and then use it for both the\n         // shard lookup and the hashmap lookup. This relies on the fact\n         // that both of them use `FxHasher`.\n@@ -70,16 +68,21 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult<CTX: QueryContext> {\n+enum QueryResult<D, Q> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob<CTX>),\n+    Started(QueryJob<D, Q>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n+impl<D, Q, C> QueryState<D, Q, C>\n+where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n+{\n     #[inline(always)]\n     pub fn iter_results<R>(\n         &self,\n@@ -98,22 +101,18 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n \n     pub fn try_collect_active_jobs(\n         &self,\n-        kind: CTX::DepKind,\n-        make_query: fn(C::Key) -> CTX::Query,\n-        jobs: &mut FxHashMap<QueryJobId<CTX::DepKind>, QueryJobInfo<CTX>>,\n-    ) -> Option<()>\n-    where\n-        C::Key: Clone,\n-    {\n+        kind: D,\n+        make_query: fn(C::Key) -> Q,\n+        jobs: &mut QueryMap<D, Q>,\n+    ) -> Option<()> {\n         // We use try_lock_shards here since we are called from the\n         // deadlock handler, and this shouldn't be locked.\n         let shards = self.shards.try_lock_shards()?;\n         let shards = shards.iter().enumerate();\n         jobs.extend(shards.flat_map(|(shard_id, shard)| {\n             shard.active.iter().filter_map(move |(k, v)| {\n                 if let QueryResult::Started(ref job) = *v {\n-                    let id =\n-                        QueryJobId { job: job.id, shard: u16::try_from(shard_id).unwrap(), kind };\n+                    let id = QueryJobId::new(job.id, shard_id, kind);\n                     let info = QueryInfo { span: job.span, query: make_query(k.clone()) };\n                     Some((id, QueryJobInfo { info, job: job.clone() }))\n                 } else {\n@@ -126,8 +125,8 @@ impl<CTX: QueryContext, C: QueryCache> QueryState<CTX, C> {\n     }\n }\n \n-impl<CTX: QueryContext, C: QueryCache> Default for QueryState<CTX, C> {\n-    fn default() -> QueryState<CTX, C> {\n+impl<D, Q, C: QueryCache> Default for QueryState<D, Q, C> {\n+    fn default() -> QueryState<D, Q, C> {\n         QueryState {\n             cache: C::default(),\n             shards: Default::default(),\n@@ -138,28 +137,30 @@ impl<CTX: QueryContext, C: QueryCache> Default for QueryState<CTX, C> {\n }\n \n /// Values used when checking a query cache which can be reused on a cache-miss to execute the query.\n-pub struct QueryLookup<'tcx, CTX: QueryContext, K, C> {\n+pub struct QueryLookup<'tcx, D, Q, K, C> {\n     pub(super) key_hash: u64,\n     shard: usize,\n-    pub(super) lock: LockGuard<'tcx, QueryStateShard<CTX, K, C>>,\n+    pub(super) lock: LockGuard<'tcx, QueryStateShard<D, Q, K, C>>,\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, CTX: QueryContext, C>\n+struct JobOwner<'tcx, D, Q, C>\n where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n     C: QueryCache,\n-    C::Key: Eq + Hash + Clone + Debug,\n {\n-    state: &'tcx QueryState<CTX, C>,\n+    state: &'tcx QueryState<D, Q, C>,\n     key: C::Key,\n-    id: QueryJobId<CTX::DepKind>,\n+    id: QueryJobId<D>,\n }\n \n-impl<'tcx, CTX: QueryContext, C> JobOwner<'tcx, CTX, C>\n+impl<'tcx, D, Q, C> JobOwner<'tcx, D, Q, C>\n where\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n     C: QueryCache,\n-    C::Key: Eq + Hash + Clone + Debug,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n     /// start executing the query, or returns with the result of the query.\n@@ -170,14 +171,14 @@ where\n     /// This function is inlined because that results in a noticeable speed-up\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n-    fn try_start<'a, 'b>(\n+    fn try_start<'a, 'b, CTX>(\n         tcx: CTX,\n-        state: &'b QueryState<CTX, C>,\n+        state: &'b QueryState<CTX::DepKind, CTX::Query, C>,\n         span: Span,\n         key: &C::Key,\n-        mut lookup: QueryLookup<'a, CTX, C::Key, C::Sharded>,\n+        mut lookup: QueryLookup<'a, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n         query: &QueryVtable<CTX, C::Key, C::Value>,\n-    ) -> TryGetJob<'b, CTX, C>\n+    ) -> TryGetJob<'b, CTX::DepKind, CTX::Query, C>\n     where\n         CTX: QueryContext,\n     {\n@@ -229,15 +230,20 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            let value = query.handle_cycle_error(tcx, latch.find_cycle_in_stack(tcx, span));\n+            let error: CycleError<CTX::Query> = latch.find_cycle_in_stack(\n+                tcx.try_collect_active_jobs().unwrap(),\n+                &tcx.current_query_job(),\n+                span,\n+            );\n+            let value = query.handle_cycle_error(tcx, error);\n             state.cache.store_nocache(value)\n         }));\n \n         // With parallel queries we might just have to wait on some other\n         // thread.\n         #[cfg(parallel_compiler)]\n         {\n-            let result = latch.wait_on(tcx, span);\n+            let result = latch.wait_on(tcx.current_query_job(), span);\n \n             if let Err(cycle) = result {\n                 let value = query.handle_cycle_error(tcx, cycle);\n@@ -297,9 +303,11 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, CTX: QueryContext, C: QueryCache> Drop for JobOwner<'tcx, CTX, C>\n+impl<'tcx, D, Q, C> Drop for JobOwner<'tcx, D, Q, C>\n where\n-    C::Key: Eq + Hash + Clone + Debug,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n {\n     #[inline(never)]\n     #[cold]\n@@ -330,12 +338,14 @@ pub struct CycleError<Q> {\n }\n \n /// The result of `try_start`.\n-enum TryGetJob<'tcx, CTX: QueryContext, C: QueryCache>\n+enum TryGetJob<'tcx, D, Q, C>\n where\n-    C::Key: Eq + Hash + Clone + Debug,\n+    D: Copy + Clone + Eq + Hash,\n+    Q: Clone,\n+    C: QueryCache,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, CTX, C>),\n+    NotYetStarted(JobOwner<'tcx, D, Q, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -354,7 +364,7 @@ where\n #[inline(always)]\n fn try_get_cached<CTX, C, R, OnHit, OnMiss>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     // `on_hit` can be called while holding a lock to the query cache\n     on_hit: OnHit,\n@@ -364,7 +374,7 @@ where\n     C: QueryCache,\n     CTX: QueryContext,\n     OnHit: FnOnce(&C::Stored, DepNodeIndex) -> R,\n-    OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX, C::Key, C::Sharded>) -> R,\n+    OnMiss: FnOnce(C::Key, QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>) -> R,\n {\n     state.cache.lookup(\n         state,\n@@ -386,19 +396,20 @@ where\n #[inline(always)]\n fn try_execute_query<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     span: Span,\n     key: C::Key,\n-    lookup: QueryLookup<'_, CTX, C::Key, C::Sharded>,\n+    lookup: QueryLookup<'_, CTX::DepKind, CTX::Query, C::Key, C::Sharded>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where\n     C: QueryCache,\n-    C::Key: Eq + Clone + Debug + crate::dep_graph::DepNodeParams<CTX>,\n-    C::Stored: Clone,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n+    let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+        tcx, state, span, &key, lookup, query,\n+    ) {\n         TryGetJob::NotYetStarted(job) => job,\n         TryGetJob::Cycle(result) => return result,\n         #[cfg(parallel_compiler)]\n@@ -559,14 +570,12 @@ fn incremental_verify_ich<CTX, K, V>(\n fn force_query_with_job<C, CTX>(\n     tcx: CTX,\n     key: C::Key,\n-    job: JobOwner<'_, CTX, C>,\n+    job: JobOwner<'_, CTX::DepKind, CTX::Query, C>,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> (C::Stored, DepNodeIndex)\n where\n     C: QueryCache,\n-    C::Key: Eq + Clone + Debug,\n-    C::Stored: Clone,\n     CTX: QueryContext,\n {\n     // If the following assertion triggers, it can have two reasons:\n@@ -617,16 +626,15 @@ where\n #[inline(never)]\n fn get_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     span: Span,\n     key: C::Key,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> C::Stored\n where\n     CTX: QueryContext,\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n-    C::Stored: Clone,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n {\n     try_get_cached(\n         tcx,\n@@ -650,12 +658,12 @@ where\n #[inline(never)]\n fn ensure_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n     if query.eval_always {\n@@ -687,14 +695,14 @@ fn ensure_query_impl<CTX, C>(\n #[inline(never)]\n fn force_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX, C>,\n+    state: &QueryState<CTX::DepKind, CTX::Query, C>,\n     key: C::Key,\n     span: Span,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) where\n     C: QueryCache,\n-    C::Key: Eq + Clone + crate::dep_graph::DepNodeParams<CTX>,\n+    C::Key: crate::dep_graph::DepNodeParams<CTX>,\n     CTX: QueryContext,\n {\n     // We may be concurrently trying both execute and force a query.\n@@ -708,7 +716,9 @@ fn force_query_impl<CTX, C>(\n             // Cache hit, do nothing\n         },\n         |key, lookup| {\n-            let job = match JobOwner::try_start(tcx, state, span, &key, lookup, query) {\n+            let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+                tcx, state, span, &key, lookup, query,\n+            ) {\n                 TryGetJob::NotYetStarted(job) => job,\n                 TryGetJob::Cycle(_) => return,\n                 #[cfg(parallel_compiler)]"}, {"sha": "feeea726f4c1bde0de1f7c96abc37caa66306a64", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 155, "deletions": 79, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -95,6 +95,27 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    /// Walks up the tree of definitions starting at `def_id`,\n+    /// stopping at the first `DefKind::Mod` encountered\n+    fn nearest_mod_parent(&mut self, def_id: DefId) -> Module<'a> {\n+        let def_key = self.cstore().def_key(def_id);\n+\n+        let mut parent_id = DefId {\n+            krate: def_id.krate,\n+            index: def_key.parent.expect(\"failed to get parent for module\"),\n+        };\n+        // The immediate parent may not be a module\n+        // (e.g. `const _: () =  { #[path = \"foo.rs\"] mod foo; };`)\n+        // Walk up the tree until we hit a module or the crate root.\n+        while parent_id.index != CRATE_DEF_INDEX\n+            && self.cstore().def_kind(parent_id) != DefKind::Mod\n+        {\n+            let parent_def_key = self.cstore().def_key(parent_id);\n+            parent_id.index = parent_def_key.parent.expect(\"failed to get parent for module\");\n+        }\n+        self.get_module(parent_id)\n+    }\n+\n     crate fn get_module(&mut self, def_id: DefId) -> Module<'a> {\n         // If this is a local module, it will be in `module_map`, no need to recalculate it.\n         if let Some(def_id) = def_id.as_local() {\n@@ -116,11 +137,8 @@ impl<'a> Resolver<'a> {\n                 .data\n                 .get_opt_name()\n                 .expect(\"given a DefId that wasn't a module\");\n-            // This unwrap is safe since we know this isn't the root\n-            let parent = Some(self.get_module(DefId {\n-                index: def_key.parent.expect(\"failed to get parent for module\"),\n-                ..def_id\n-            }));\n+\n+            let parent = Some(self.nearest_mod_parent(def_id));\n             (name, parent)\n         };\n \n@@ -145,8 +163,24 @@ impl<'a> Resolver<'a> {\n         if let Some(id) = def_id.as_local() {\n             self.local_macro_def_scopes[&id]\n         } else {\n-            let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();\n-            self.get_module(module_def_id)\n+            // This is not entirely correct - a `macro_rules!` macro may occur\n+            // inside a 'block' module:\n+            //\n+            // ```rust\n+            // const _: () = {\n+            // #[macro_export]\n+            // macro_rules! my_macro {\n+            //     () => {};\n+            // }\n+            // `\n+            // We don't record this information for external crates, so\n+            // the module we compute here will be the closest 'mod' item\n+            // (not necesssarily the actual parent of the `macro_rules!`\n+            // macro). `macro_rules!` macros can't use def-site hygiene,\n+            // so this hopefully won't be a problem.\n+            //\n+            // See https://github.com/rust-lang/rust/pull/77984#issuecomment-712445508\n+            self.nearest_mod_parent(def_id)\n         }\n     }\n \n@@ -613,12 +647,21 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one item.\n     fn build_reduced_graph_for_item(&mut self, item: &'b Item) {\n+        if matches!(item.kind, ItemKind::Mod(..)) && item.ident.name == kw::Invalid {\n+            // Fake crate root item from expand.\n+            return;\n+        }\n+\n         let parent_scope = &self.parent_scope;\n         let parent = parent_scope.module;\n         let expansion = parent_scope.expansion;\n         let ident = item.ident;\n         let sp = item.span;\n         let vis = self.resolve_visibility(&item.vis);\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+\n+        self.r.visibilities.insert(local_def_id, vis);\n \n         match item.kind {\n             ItemKind::Use(ref use_tree) => {\n@@ -651,10 +694,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 } else if orig_name == Some(kw::SelfLower) {\n                     self.r.graph_root\n                 } else {\n-                    let def_id = self.r.local_def_id(item.id);\n-                    let crate_id =\n-                        self.r.crate_loader.process_extern_crate(item, &self.r.definitions, def_id);\n-                    self.r.extern_crate_map.insert(def_id, crate_id);\n+                    let crate_id = self.r.crate_loader.process_extern_crate(\n+                        item,\n+                        &self.r.definitions,\n+                        local_def_id,\n+                    );\n+                    self.r.extern_crate_map.insert(local_def_id, crate_id);\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n@@ -705,41 +750,32 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.define(parent, ident, TypeNS, imported_binding);\n             }\n \n-            ItemKind::Mod(..) if ident.name == kw::Invalid => {} // Crate root\n-\n             ItemKind::Mod(..) => {\n-                let def_id = self.r.local_def_id(item.id);\n-                let module_kind = ModuleKind::Def(DefKind::Mod, def_id.to_def_id(), ident.name);\n+                let module_kind = ModuleKind::Def(DefKind::Mod, def_id, ident.name);\n                 let module = self.r.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         self.r.session.contains_name(&item.attrs, sym::no_implicit_prelude)\n                     },\n-                    ..ModuleData::new(\n-                        Some(parent),\n-                        module_kind,\n-                        def_id.to_def_id(),\n-                        expansion,\n-                        item.span,\n-                    )\n+                    ..ModuleData::new(Some(parent), module_kind, def_id, expansion, item.span)\n                 });\n                 self.r.define(parent, ident, TypeNS, (module, vis, sp, expansion));\n-                self.r.module_map.insert(def_id, module);\n+                self.r.module_map.insert(local_def_id, module);\n \n                 // Descend into the module.\n                 self.parent_scope.module = module;\n             }\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let res = Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Static, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let res = Res::Def(DefKind::Const, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Const, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let res = Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::Fn, def_id);\n                 self.r.define(parent, ident, ValueNS, (res, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n@@ -749,13 +785,11 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n             // These items live in the type namespace.\n             ItemKind::TyAlias(..) => {\n-                let res = Res::Def(DefKind::TyAlias, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::TyAlias, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(_, _) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n-                self.r.variant_vis.insert(def_id, vis);\n                 let module_kind = ModuleKind::Def(DefKind::Enum, def_id, ident.name);\n                 let module = self.r.new_module(\n                     parent,\n@@ -769,14 +803,13 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let res = Res::Def(DefKind::TraitAlias, self.r.local_def_id(item.id).to_def_id());\n+                let res = Res::Def(DefKind::TraitAlias, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref vdata, _) => {\n                 // Define a name in the type namespace.\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Struct, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -810,17 +843,19 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                         ret_fields.push(field_vis);\n                     }\n+                    let ctor_def_id = self.r.local_def_id(ctor_node_id);\n                     let ctor_res = Res::Def(\n                         DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(vdata)),\n-                        self.r.local_def_id(ctor_node_id).to_def_id(),\n+                        ctor_def_id.to_def_id(),\n                     );\n                     self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, sp, expansion));\n+                    self.r.visibilities.insert(ctor_def_id, ctor_vis);\n+\n                     self.r.struct_constructors.insert(def_id, (ctor_res, ctor_vis, ret_fields));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n                 let res = Res::Def(DefKind::Union, def_id);\n                 self.r.define(parent, ident, TypeNS, (res, vis, sp, expansion));\n \n@@ -829,8 +864,6 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             ItemKind::Trait(..) => {\n-                let def_id = self.r.local_def_id(item.id).to_def_id();\n-\n                 // Add all the items within to a new module.\n                 let module_kind = ModuleKind::Def(DefKind::Trait, def_id, ident.name);\n                 let module = self.r.new_module(\n@@ -845,6 +878,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             }\n \n             // These items do not add names to modules.\n+            ItemKind::Impl { of_trait: Some(..), .. } => {\n+                self.r.trait_impl_items.insert(local_def_id);\n+            }\n             ItemKind::Impl { .. } | ItemKind::ForeignMod(..) | ItemKind::GlobalAsm(..) => {}\n \n             ItemKind::MacroDef(..) | ItemKind::MacCall(_) => unreachable!(),\n@@ -853,22 +889,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem) {\n-        let (res, ns) = match item.kind {\n-            ForeignItemKind::Fn(..) => {\n-                (Res::Def(DefKind::Fn, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n-            }\n-            ForeignItemKind::Static(..) => {\n-                (Res::Def(DefKind::Static, self.r.local_def_id(item.id).to_def_id()), ValueNS)\n-            }\n-            ForeignItemKind::TyAlias(..) => {\n-                (Res::Def(DefKind::ForeignTy, self.r.local_def_id(item.id).to_def_id()), TypeNS)\n-            }\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+        let (def_kind, ns) = match item.kind {\n+            ForeignItemKind::Fn(..) => (DefKind::Fn, ValueNS),\n+            ForeignItemKind::Static(..) => (DefKind::Static, ValueNS),\n+            ForeignItemKind::TyAlias(..) => (DefKind::ForeignTy, TypeNS),\n             ForeignItemKind::MacCall(_) => unreachable!(),\n         };\n         let parent = self.parent_scope.module;\n         let expansion = self.parent_scope.expansion;\n         let vis = self.resolve_visibility(&item.vis);\n+        let res = Res::Def(def_kind, def_id);\n         self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        self.r.visibilities.insert(local_def_id, vis);\n     }\n \n     fn build_reduced_graph_for_block(&mut self, block: &Block) {\n@@ -1205,6 +1239,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n+            self.r.visibilities.insert(def_id, vis);\n             MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n                 parent_macro_rules_scope: parent_scope.macro_rules,\n                 binding,\n@@ -1224,6 +1259,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_unused_macro(ident, def_id, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n+            self.r.visibilities.insert(def_id, vis);\n             self.parent_scope.macro_rules\n         }\n     }\n@@ -1297,36 +1333,64 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {\n-        let parent = self.parent_scope.module;\n-\n         if let AssocItemKind::MacCall(_) = item.kind {\n             self.visit_invoc(item.id);\n             return;\n         }\n \n-        if let AssocCtxt::Impl = ctxt {\n-            self.resolve_visibility(&item.vis);\n-            visit::walk_assoc_item(self, item, ctxt);\n-            return;\n-        }\n+        let local_def_id = self.r.local_def_id(item.id);\n+        let def_id = local_def_id.to_def_id();\n+        let vis = match ctxt {\n+            AssocCtxt::Trait => {\n+                let (def_kind, ns) = match item.kind {\n+                    AssocItemKind::Const(..) => (DefKind::AssocConst, ValueNS),\n+                    AssocItemKind::Fn(_, ref sig, _, _) => {\n+                        if sig.decl.has_self() {\n+                            self.r.has_self.insert(def_id);\n+                        }\n+                        (DefKind::AssocFn, ValueNS)\n+                    }\n+                    AssocItemKind::TyAlias(..) => (DefKind::AssocTy, TypeNS),\n+                    AssocItemKind::MacCall(_) => bug!(), // handled above\n+                };\n \n-        // Add the item to the trait info.\n-        let item_def_id = self.r.local_def_id(item.id).to_def_id();\n-        let (res, ns) = match item.kind {\n-            AssocItemKind::Const(..) => (Res::Def(DefKind::AssocConst, item_def_id), ValueNS),\n-            AssocItemKind::Fn(_, ref sig, _, _) => {\n-                if sig.decl.has_self() {\n-                    self.r.has_self.insert(item_def_id);\n+                let parent = self.parent_scope.module;\n+                let expansion = self.parent_scope.expansion;\n+                let res = Res::Def(def_kind, def_id);\n+                // Trait item visibility is inherited from its trait when not specified explicitly.\n+                let vis = match &item.vis.kind {\n+                    ast::VisibilityKind::Inherited => {\n+                        self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n+                    }\n+                    _ => self.resolve_visibility(&item.vis),\n+                };\n+                // FIXME: For historical reasons the binding visibility is set to public,\n+                // use actual visibility here instead, using enum variants as an example.\n+                let vis_hack = ty::Visibility::Public;\n+                self.r.define(parent, item.ident, ns, (res, vis_hack, item.span, expansion));\n+                Some(vis)\n+            }\n+            AssocCtxt::Impl => {\n+                // Trait impl item visibility is inherited from its trait when not specified\n+                // explicitly. In that case we cannot determine it here in early resolve,\n+                // so we leave a hole in the visibility table to be filled later.\n+                // Inherent impl item visibility is never inherited from other items.\n+                if matches!(item.vis.kind, ast::VisibilityKind::Inherited)\n+                    && self\n+                        .r\n+                        .trait_impl_items\n+                        .contains(&ty::DefIdTree::parent(&*self.r, def_id).unwrap().expect_local())\n+                {\n+                    None\n+                } else {\n+                    Some(self.resolve_visibility(&item.vis))\n                 }\n-                (Res::Def(DefKind::AssocFn, item_def_id), ValueNS)\n             }\n-            AssocItemKind::TyAlias(..) => (Res::Def(DefKind::AssocTy, item_def_id), TypeNS),\n-            AssocItemKind::MacCall(_) => bug!(), // handled above\n         };\n \n-        let vis = ty::Visibility::Public;\n-        let expansion = self.parent_scope.expansion;\n-        self.r.define(parent, item.ident, ns, (res, vis, item.span, expansion));\n+        if let Some(vis) = vis {\n+            self.r.visibilities.insert(local_def_id, vis);\n+        }\n \n         visit::walk_assoc_item(self, item, ctxt);\n     }\n@@ -1394,7 +1458,8 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         if sf.is_placeholder {\n             self.visit_invoc(sf.id);\n         } else {\n-            self.resolve_visibility(&sf.vis);\n+            let vis = self.resolve_visibility(&sf.vis);\n+            self.r.visibilities.insert(self.r.local_def_id(sf.id), vis);\n             visit::walk_struct_field(self, sf);\n         }\n     }\n@@ -1408,35 +1473,46 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n         }\n \n         let parent = self.parent_scope.module;\n-        let vis = self.r.variant_vis[&parent.def_id().expect(\"enum without def-id\")];\n+        let vis = match variant.vis.kind {\n+            // Variant visibility is inherited from its enum when not specified explicitly.\n+            ast::VisibilityKind::Inherited => {\n+                self.r.visibilities[&parent.def_id().unwrap().expect_local()]\n+            }\n+            _ => self.resolve_visibility(&variant.vis),\n+        };\n         let expn_id = self.parent_scope.expansion;\n         let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.local_def_id(variant.id).to_def_id();\n-        let res = Res::Def(DefKind::Variant, def_id);\n+        let def_id = self.r.local_def_id(variant.id);\n+        let res = Res::Def(DefKind::Variant, def_id.to_def_id());\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n+        self.r.visibilities.insert(def_id, vis);\n \n-        // If the variant is marked as non_exhaustive then lower the visibility to within the\n-        // crate.\n-        let mut ctor_vis = vis;\n-        let has_non_exhaustive = self.r.session.contains_name(&variant.attrs, sym::non_exhaustive);\n-        if has_non_exhaustive && vis == ty::Visibility::Public {\n-            ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n-        }\n+        // If the variant is marked as non_exhaustive then lower the visibility to within the crate.\n+        let ctor_vis = if vis == ty::Visibility::Public\n+            && self.r.session.contains_name(&variant.attrs, sym::non_exhaustive)\n+        {\n+            ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))\n+        } else {\n+            vis\n+        };\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n         let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n-        let ctor_def_id = self.r.local_def_id(ctor_node_id).to_def_id();\n+        let ctor_def_id = self.r.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.data);\n-        let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n+        let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id.to_def_id());\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n+        if ctor_def_id != def_id {\n+            self.r.visibilities.insert(ctor_def_id, ctor_vis);\n+        }\n         // Record field names for error reporting.\n-        self.insert_field_names_local(ctor_def_id, &variant.data);\n+        self.insert_field_names_local(ctor_def_id.to_def_id(), &variant.data);\n \n         visit::walk_variant(self, variant);\n     }"}, {"sha": "a4de4d500f5e9f0d4865c7e0887e17495d50ac5e", "filename": "compiler/rustc_resolve/src/def_collector.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdef_collector.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -76,6 +76,7 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n         let def_data = match &i.kind {\n             ItemKind::Impl { .. } => DefPathData::Impl,\n             ItemKind::Mod(..) if i.ident.name == kw::Invalid => {\n+                // Fake crate root item from expand.\n                 return visit::walk_item(self, i);\n             }\n             ItemKind::Mod(..)\n@@ -239,13 +240,13 @@ impl<'a, 'b> visit::Visitor<'a> for DefCollector<'a, 'b> {\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.kind {\n-            TyKind::MacCall(..) => return self.visit_macro_invoc(ty.id),\n+            TyKind::MacCall(..) => self.visit_macro_invoc(ty.id),\n             TyKind::ImplTrait(node_id, _) => {\n-                self.create_def(node_id, DefPathData::ImplTrait, ty.span);\n+                let parent_def = self.create_def(node_id, DefPathData::ImplTrait, ty.span);\n+                self.with_parent(parent_def, |this| visit::walk_ty(this, ty));\n             }\n-            _ => {}\n+            _ => visit::walk_ty(self, ty),\n         }\n-        visit::walk_ty(self, ty);\n     }\n \n     fn visit_stmt(&mut self, stmt: &'a Stmt) {"}, {"sha": "33ab09a8f4280ddd5ada23d2b22d8a547275be00", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -922,6 +922,17 @@ impl<'a> Resolver<'a> {\n         );\n         self.add_typo_suggestion(err, suggestion, ident.span);\n \n+        let import_suggestions = self.lookup_import_candidates(\n+            ident,\n+            Namespace::MacroNS,\n+            parent_scope,\n+            |res| match res {\n+                Res::Def(DefKind::Macro(MacroKind::Bang), _) => true,\n+                _ => false,\n+            },\n+        );\n+        show_candidates(err, None, &import_suggestions, false, true);\n+\n         if macro_kind == MacroKind::Derive && (ident.name == sym::Send || ident.name == sym::Sync) {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);"}, {"sha": "7517ab66170a2943943d7fc0aa815f52337efc34", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -369,7 +369,7 @@ struct DiagnosticMetadata<'ast> {\n     /// param.\n     currently_processing_generics: bool,\n \n-    /// The current enclosing function (used for better errors).\n+    /// The current enclosing (non-closure) function (used for better errors).\n     current_function: Option<(FnKind<'ast>, Span)>,\n \n     /// A list of labels as of yet unused. Labels will be removed from this map when\n@@ -515,8 +515,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             FnKind::Fn(FnCtxt::Assoc(_), ..) => NormalRibKind,\n             FnKind::Closure(..) => ClosureOrAsyncRibKind,\n         };\n-        let previous_value =\n-            replace(&mut self.diagnostic_metadata.current_function, Some((fn_kind, sp)));\n+        let previous_value = self.diagnostic_metadata.current_function;\n+        if matches!(fn_kind, FnKind::Fn(..)) {\n+            self.diagnostic_metadata.current_function = Some((fn_kind, sp));\n+        }\n         debug!(\"(resolving function) entering function\");\n         let declaration = fn_kind.decl();\n "}, {"sha": "c24b383f3b81171d39eea893f9137cad1f19d333", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 88, "deletions": 62, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1330,58 +1330,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         let suggest_only_tuple_variants =\n             matches!(source, PathSource::TupleStruct(..)) || source.is_call();\n-        let mut suggestable_variants = if suggest_only_tuple_variants {\n+        if suggest_only_tuple_variants {\n             // Suggest only tuple variants regardless of whether they have fields and do not\n             // suggest path with added parenthesis.\n-            variants\n+            let mut suggestable_variants = variants\n                 .iter()\n                 .filter(|(.., kind)| *kind == CtorKind::Fn)\n                 .map(|(variant, ..)| path_names_to_string(variant))\n-                .collect::<Vec<_>>()\n-        } else {\n-            variants\n-                .iter()\n-                .filter(|(_, def_id, kind)| {\n-                    // Suggest only variants that have no fields (these can definitely\n-                    // be constructed).\n-                    let has_fields =\n-                        self.r.field_names.get(&def_id).map(|f| f.is_empty()).unwrap_or(false);\n-                    match kind {\n-                        CtorKind::Const => true,\n-                        CtorKind::Fn | CtorKind::Fictive if has_fields => true,\n-                        _ => false,\n-                    }\n-                })\n-                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n-                .map(|(variant_str, kind)| {\n-                    // Add constructor syntax where appropriate.\n-                    match kind {\n-                        CtorKind::Const => variant_str,\n-                        CtorKind::Fn => format!(\"({}())\", variant_str),\n-                        CtorKind::Fictive => format!(\"({} {{}})\", variant_str),\n-                    }\n-                })\n-                .collect::<Vec<_>>()\n-        };\n-\n-        let non_suggestable_variant_count = variants.len() - suggestable_variants.len();\n+                .collect::<Vec<_>>();\n \n-        if !suggestable_variants.is_empty() {\n-            let msg = if non_suggestable_variant_count == 0 && suggestable_variants.len() == 1 {\n-                \"try using the enum's variant\"\n-            } else {\n-                \"try using one of the enum's variants\"\n-            };\n+            let non_suggestable_variant_count = variants.len() - suggestable_variants.len();\n \n-            err.span_suggestions(\n-                span,\n-                msg,\n-                suggestable_variants.drain(..),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        if suggest_only_tuple_variants {\n             let source_msg = if source.is_call() {\n                 \"to construct\"\n             } else if matches!(source, PathSource::TupleStruct(..)) {\n@@ -1390,6 +1349,21 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 unreachable!()\n             };\n \n+            if !suggestable_variants.is_empty() {\n+                let msg = if non_suggestable_variant_count == 0 && suggestable_variants.len() == 1 {\n+                    format!(\"try {} the enum's variant\", source_msg)\n+                } else {\n+                    format!(\"try {} one of the enum's variants\", source_msg)\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    suggestable_variants.drain(..),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n             // If the enum has no tuple variants..\n             if non_suggestable_variant_count == variants.len() {\n                 err.help(&format!(\"the enum has no tuple variants {}\", source_msg));\n@@ -1408,24 +1382,76 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 ));\n             }\n         } else {\n-            let made_suggestion = non_suggestable_variant_count != variants.len();\n-            if made_suggestion {\n-                if non_suggestable_variant_count == 1 {\n-                    err.help(\n-                        \"you might have meant to use the enum's other variant that has fields\",\n-                    );\n-                } else if non_suggestable_variant_count >= 1 {\n-                    err.help(\n-                        \"you might have meant to use one of the enum's other variants that \\\n-                         have fields\",\n-                    );\n-                }\n-            } else {\n-                if non_suggestable_variant_count == 1 {\n-                    err.help(\"you might have meant to use the enum's variant\");\n-                } else if non_suggestable_variant_count >= 1 {\n-                    err.help(\"you might have meant to use one of the enum's variants\");\n+            let needs_placeholder = |def_id: DefId, kind: CtorKind| {\n+                let has_no_fields =\n+                    self.r.field_names.get(&def_id).map(|f| f.is_empty()).unwrap_or(false);\n+                match kind {\n+                    CtorKind::Const => false,\n+                    CtorKind::Fn | CtorKind::Fictive if has_no_fields => false,\n+                    _ => true,\n                 }\n+            };\n+\n+            let mut suggestable_variants = variants\n+                .iter()\n+                .filter(|(_, def_id, kind)| !needs_placeholder(*def_id, *kind))\n+                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n+                .map(|(variant, kind)| match kind {\n+                    CtorKind::Const => variant,\n+                    CtorKind::Fn => format!(\"({}())\", variant),\n+                    CtorKind::Fictive => format!(\"({} {{}})\", variant),\n+                })\n+                .collect::<Vec<_>>();\n+\n+            if !suggestable_variants.is_empty() {\n+                let msg = if suggestable_variants.len() == 1 {\n+                    \"you might have meant to use the following enum variant\"\n+                } else {\n+                    \"you might have meant to use one of the following enum variants\"\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    msg,\n+                    suggestable_variants.drain(..),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+\n+            let mut suggestable_variants_with_placeholders = variants\n+                .iter()\n+                .filter(|(_, def_id, kind)| needs_placeholder(*def_id, *kind))\n+                .map(|(variant, _, kind)| (path_names_to_string(variant), kind))\n+                .filter_map(|(variant, kind)| match kind {\n+                    CtorKind::Fn => Some(format!(\"({}(/* fields */))\", variant)),\n+                    CtorKind::Fictive => Some(format!(\"({} {{ /* fields */ }})\", variant)),\n+                    _ => None,\n+                })\n+                .collect::<Vec<_>>();\n+\n+            if !suggestable_variants_with_placeholders.is_empty() {\n+                let msg = match (\n+                    suggestable_variants.is_empty(),\n+                    suggestable_variants_with_placeholders.len(),\n+                ) {\n+                    (true, 1) => \"the following enum variant is available\",\n+                    (true, _) => \"the following enum variants are available\",\n+                    (false, 1) => \"alternatively, the following enum variant is available\",\n+                    (false, _) => \"alternatively, the following enum variants are also available\",\n+                };\n+\n+                err.span_suggestions(\n+                    span,\n+                    msg,\n+                    suggestable_variants_with_placeholders.drain(..),\n+                    Applicability::HasPlaceholders,\n+                );\n+            }\n+        };\n+\n+        if def_id.is_local() {\n+            if let Some(span) = self.def_span(def_id) {\n+                err.span_note(span, \"the enum is defined here\");\n             }\n         }\n     }"}, {"sha": "b12e516fa3ed5371f360c99a5935ed4ad1a913f8", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -19,7 +19,7 @@ pub use rustc_hir::def::{Namespace, PerNS};\n \n use Determinacy::*;\n \n-use rustc_arena::TypedArena;\n+use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n@@ -944,7 +944,8 @@ pub struct Resolver<'a> {\n \n     /// Maps glob imports to the names of items actually imported.\n     glob_map: FxHashMap<LocalDefId, FxHashSet<Symbol>>,\n-\n+    /// Visibilities in \"lowered\" form, for all entities that have them.\n+    visibilities: FxHashMap<LocalDefId, ty::Visibility>,\n     used_imports: FxHashSet<(NodeId, Namespace)>,\n     maybe_unused_trait_imports: FxHashSet<LocalDefId>,\n     maybe_unused_extern_crates: Vec<(LocalDefId, Span)>,\n@@ -1008,10 +1009,6 @@ pub struct Resolver<'a> {\n     /// Features enabled for this crate.\n     active_features: FxHashSet<Symbol>,\n \n-    /// Stores enum visibilities to properly build a reduced graph\n-    /// when visiting the correspondent variants.\n-    variant_vis: DefIdMap<ty::Visibility>,\n-\n     lint_buffer: LintBuffer,\n \n     next_node_id: NodeId,\n@@ -1028,19 +1025,20 @@ pub struct Resolver<'a> {\n     invocation_parents: FxHashMap<ExpnId, LocalDefId>,\n \n     next_disambiguator: FxHashMap<(LocalDefId, DefPathData), u32>,\n+    /// Some way to know that we are in a *trait* impl in `visit_assoc_item`.\n+    /// FIXME: Replace with a more general AST map (together with some other fields).\n+    trait_impl_items: FxHashSet<LocalDefId>,\n }\n \n /// Nothing really interesting here; it just provides memory for the rest of the crate.\n #[derive(Default)]\n pub struct ResolverArenas<'a> {\n     modules: TypedArena<ModuleData<'a>>,\n     local_modules: RefCell<Vec<Module<'a>>>,\n-    name_bindings: TypedArena<NameBinding<'a>>,\n     imports: TypedArena<Import<'a>>,\n     name_resolutions: TypedArena<RefCell<NameResolution<'a>>>,\n-    macro_rules_bindings: TypedArena<MacroRulesBinding<'a>>,\n     ast_paths: TypedArena<ast::Path>,\n-    pattern_spans: TypedArena<Span>,\n+    dropless: DroplessArena,\n }\n \n impl<'a> ResolverArenas<'a> {\n@@ -1055,7 +1053,7 @@ impl<'a> ResolverArenas<'a> {\n         self.local_modules.borrow()\n     }\n     fn alloc_name_binding(&'a self, name_binding: NameBinding<'a>) -> &'a NameBinding<'a> {\n-        self.name_bindings.alloc(name_binding)\n+        self.dropless.alloc(name_binding)\n     }\n     fn alloc_import(&'a self, import: Import<'a>) -> &'a Import<'_> {\n         self.imports.alloc(import)\n@@ -1067,13 +1065,13 @@ impl<'a> ResolverArenas<'a> {\n         &'a self,\n         binding: MacroRulesBinding<'a>,\n     ) -> &'a MacroRulesBinding<'a> {\n-        self.macro_rules_bindings.alloc(binding)\n+        self.dropless.alloc(binding)\n     }\n     fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n         self.ast_paths.alloc_from_iter(paths.iter().cloned())\n     }\n     fn alloc_pattern_spans(&'a self, spans: impl Iterator<Item = Span>) -> &'a [Span] {\n-        self.pattern_spans.alloc_from_iter(spans)\n+        self.dropless.alloc_from_iter(spans)\n     }\n }\n \n@@ -1195,7 +1193,8 @@ impl<'a> Resolver<'a> {\n         metadata_loader: &'a MetadataLoaderDyn,\n         arenas: &'a ResolverArenas<'a>,\n     ) -> Resolver<'a> {\n-        let root_def_id = DefId::local(CRATE_DEF_INDEX);\n+        let root_local_def_id = LocalDefId { local_def_index: CRATE_DEF_INDEX };\n+        let root_def_id = root_local_def_id.to_def_id();\n         let root_module_kind = ModuleKind::Def(DefKind::Mod, root_def_id, kw::Invalid);\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: session.contains_name(&krate.attrs, sym::no_implicit_prelude),\n@@ -1213,11 +1212,14 @@ impl<'a> Resolver<'a> {\n             )\n         });\n         let mut module_map = FxHashMap::default();\n-        module_map.insert(LocalDefId { local_def_index: CRATE_DEF_INDEX }, graph_root);\n+        module_map.insert(root_local_def_id, graph_root);\n \n         let definitions = Definitions::new(crate_name, session.local_crate_disambiguator());\n         let root = definitions.get_root_def();\n \n+        let mut visibilities = FxHashMap::default();\n+        visibilities.insert(root_local_def_id, ty::Visibility::Public);\n+\n         let mut def_id_to_span = IndexVec::default();\n         assert_eq!(def_id_to_span.push(rustc_span::DUMMY_SP), root);\n         let mut def_id_to_node_id = IndexVec::default();\n@@ -1240,9 +1242,6 @@ impl<'a> Resolver<'a> {\n             extern_prelude.insert(Ident::with_dummy_span(sym::core), Default::default());\n             if !session.contains_name(&krate.attrs, sym::no_std) {\n                 extern_prelude.insert(Ident::with_dummy_span(sym::std), Default::default());\n-                if session.rust_2018() {\n-                    extern_prelude.insert(Ident::with_dummy_span(sym::meta), Default::default());\n-                }\n             }\n         }\n \n@@ -1293,7 +1292,7 @@ impl<'a> Resolver<'a> {\n             ast_transform_scopes: FxHashMap::default(),\n \n             glob_map: Default::default(),\n-\n+            visibilities,\n             used_imports: FxHashSet::default(),\n             maybe_unused_trait_imports: Default::default(),\n             maybe_unused_extern_crates: Vec::new(),\n@@ -1342,7 +1341,6 @@ impl<'a> Resolver<'a> {\n                 .map(|(feat, ..)| *feat)\n                 .chain(features.declared_lang_features.iter().map(|(feat, ..)| *feat))\n                 .collect(),\n-            variant_vis: Default::default(),\n             lint_buffer: LintBuffer::default(),\n             next_node_id: NodeId::from_u32(1),\n             def_id_to_span,\n@@ -1351,6 +1349,7 @@ impl<'a> Resolver<'a> {\n             placeholder_field_indices: Default::default(),\n             invocation_parents,\n             next_disambiguator: Default::default(),\n+            trait_impl_items: Default::default(),\n         }\n     }\n \n@@ -1374,6 +1373,7 @@ impl<'a> Resolver<'a> {\n \n     pub fn into_outputs(self) -> ResolverOutputs {\n         let definitions = self.definitions;\n+        let visibilities = self.visibilities;\n         let extern_crate_map = self.extern_crate_map;\n         let export_map = self.export_map;\n         let maybe_unused_trait_imports = self.maybe_unused_trait_imports;\n@@ -1382,6 +1382,7 @@ impl<'a> Resolver<'a> {\n         ResolverOutputs {\n             definitions: definitions,\n             cstore: Box::new(self.crate_loader.into_cstore()),\n+            visibilities,\n             extern_crate_map,\n             export_map,\n             glob_map,\n@@ -1399,6 +1400,7 @@ impl<'a> Resolver<'a> {\n         ResolverOutputs {\n             definitions: self.definitions.clone(),\n             cstore: Box::new(self.cstore().clone()),\n+            visibilities: self.visibilities.clone(),\n             extern_crate_map: self.extern_crate_map.clone(),\n             export_map: self.export_map.clone(),\n             glob_map: self.glob_map.clone(),"}, {"sha": "b5b281b93bcae5376115c7588b4a64d1adf42576", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -19,7 +19,7 @@ use rustc_feature::is_builtin_attr_name;\n use rustc_hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc_hir::def_id;\n use rustc_middle::middle::stability;\n-use rustc_middle::{span_bug, ty};\n+use rustc_middle::ty;\n use rustc_session::lint::builtin::UNUSED_MACROS;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -885,11 +885,11 @@ impl<'a> Resolver<'a> {\n                                  initial_res: Option<Res>,\n                                  res: Res| {\n             if let Some(initial_res) = initial_res {\n-                if res != initial_res && res != Res::Err && this.ambiguity_errors.is_empty() {\n+                if res != initial_res {\n                     // Make sure compilation does not succeed if preferred macro resolution\n                     // has changed after the macro had been expanded. In theory all such\n-                    // situations should be reported as ambiguity errors, so this is a bug.\n-                    span_bug!(span, \"inconsistent resolution for a macro\");\n+                    // situations should be reported as errors, so this is a bug.\n+                    this.session.delay_span_bug(span, \"inconsistent resolution for a macro\");\n                 }\n             } else {\n                 // It's possible that the macro was unresolved (indeterminate) and silently"}, {"sha": "dbb5e3cc9f06620f3a03041096dc62ac75607400", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -320,6 +320,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n         for param in generics.params {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n+                hir::GenericParamKind::Type {\n+                    synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n+                    ..\n+                } => {\n+                    return self\n+                        .nest_typeck_results(self.tcx.hir().local_def_id(param.hir_id), |this| {\n+                            this.visit_generics(generics)\n+                        });\n+                }\n                 hir::GenericParamKind::Type { .. } => {\n                     let param_ss = param.name.ident().span;\n                     let name = escape(self.span.snippet(param_ss));\n@@ -351,7 +360,8 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 hir::GenericParamKind::Const { .. } => {}\n             }\n         }\n-        self.visit_generics(generics);\n+\n+        self.visit_generics(generics)\n     }\n \n     fn process_fn("}, {"sha": "bae1e4f314c01e3360e4c4653e7da12c47063adc", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -593,6 +593,7 @@ symbols! {\n         infer_static_outlives_requirements,\n         inlateout,\n         inline,\n+        inline_const,\n         inout,\n         instruction_set,\n         intel,\n@@ -776,6 +777,7 @@ symbols! {\n         panic_info,\n         panic_location,\n         panic_runtime,\n+        panic_str,\n         panic_unwind,\n         param_attrs,\n         parent_trait,\n@@ -892,6 +894,7 @@ symbols! {\n         rustc,\n         rustc_allocator,\n         rustc_allocator_nounwind,\n+        rustc_allow_const_fn_unstable,\n         rustc_args_required_const,\n         rustc_attrs,\n         rustc_builtin_macro,"}, {"sha": "3df5f16131922cfb3455d99aa19907ae1edd81cc", "filename": "compiler/rustc_symbol_mangling/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_symbol_mangling%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_symbol_mangling%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2FCargo.toml?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,7 +10,7 @@ doctest = false\n [dependencies]\n tracing = \"0.1\"\n punycode = \"0.4.0\"\n-rustc-demangle = \"0.1.16\"\n+rustc-demangle = \"0.1.18\"\n \n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }"}, {"sha": "7833385cbc99698271dc9478404f4ab8cff45a1c", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -4,6 +4,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n+use rustc_middle::mir::interpret::sign_extend;\n use rustc_middle::ty::print::{Print, Printer};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, Subst};\n use rustc_middle::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n@@ -527,17 +528,31 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n         }\n         let start = self.out.len();\n \n-        match ct.ty.kind() {\n-            ty::Uint(_) => {}\n-            ty::Bool => {}\n+        let mut neg = false;\n+        let val = match ct.ty.kind() {\n+            ty::Uint(_) | ty::Bool | ty::Char => {\n+                ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty)\n+            }\n+            ty::Int(_) => {\n+                let param_env = ty::ParamEnv::reveal_all();\n+                ct.try_eval_bits(self.tcx, param_env, ct.ty).and_then(|b| {\n+                    let sz = self.tcx.layout_of(param_env.and(ct.ty)).ok()?.size;\n+                    let val = sign_extend(b, sz) as i128;\n+                    if val < 0 {\n+                        neg = true;\n+                    }\n+                    Some(val.wrapping_abs() as u128)\n+                })\n+            }\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n             }\n-        }\n-        self = ct.ty.print(self)?;\n+        };\n \n-        if let Some(bits) = ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty) {\n-            let _ = write!(self.out, \"{:x}_\", bits);\n+        if let Some(bits) = val {\n+            // We only print the type if the const can be evaluated.\n+            self = ct.ty.print(self)?;\n+            let _ = write!(self.out, \"{}{:x}_\", if neg { \"n\" } else { \"\" }, bits);\n         } else {\n             // NOTE(eddyb) despite having the path, we need to\n             // encode a placeholder, as the path could refer"}, {"sha": "1b17c2c278f9abd9ff374f2daf85e6f0c730b53a", "filename": "compiler/rustc_target/src/spec/apple_sdk_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fapple_sdk_base.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -34,6 +34,7 @@ fn link_env_remove(arch: Arch) -> Vec<String> {\n pub fn opts(arch: Arch) -> TargetOptions {\n     TargetOptions {\n         cpu: target_cpu(arch),\n+        dynamic_linking: false,\n         executables: true,\n         link_env_remove: link_env_remove(arch),\n         has_elf_tls: false,"}, {"sha": "93a0073588ec71663a6e573e379fca5a1c4f1c1d", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -642,18 +642,19 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            match predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(p, _) => {\n                     if self.is_param_no_infer(p.trait_ref.substs)\n                         && !only_projections\n                         && is_new_pred\n                     {\n                         self.add_user_pred(computed_preds, predicate);\n                     }\n-                    predicates.push_back(ty::Binder::bind(p));\n+                    predicates.push_back(bound_predicate.rebind(p));\n                 }\n                 ty::PredicateAtom::Projection(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.rebind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n                         predicate\n@@ -783,13 +784,13 @@ impl AutoTraitFinder<'tcx> {\n                     }\n                 }\n                 ty::PredicateAtom::RegionOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n                 ty::PredicateAtom::TypeOutlives(binder) => {\n-                    let binder = ty::Binder::bind(binder);\n+                    let binder = bound_predicate.rebind(binder);\n                     match (\n                         binder.no_bound_vars(),\n                         binder.map_bound_ref(|pred| pred.0).no_bound_vars(),"}, {"sha": "3cb6ec8626186f511710f5d26f7b9615d256090b", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "renamed", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -17,14 +17,17 @@ use rustc_middle::ty::{self, TyCtxt};\n /// (necessarily) resolve all nested obligations on the impl. Note\n /// that type check should guarantee to us that all nested\n /// obligations *could be* resolved if we wanted to.\n+///\n /// Assumes that this is run after the entire crate has been successfully type-checked.\n+/// This also expects that `trait_ref` is fully normalized.\n pub fn codegen_fulfill_obligation<'tcx>(\n-    ty: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n     // Remove any references to regions; this helps improve caching.\n-    let trait_ref = ty.erase_regions(&trait_ref);\n-\n+    let trait_ref = tcx.erase_regions(&trait_ref);\n+    // We expect the input to be fully normalized.\n+    debug_assert_eq!(trait_ref, tcx.normalize_erasing_regions(param_env, trait_ref));\n     debug!(\n         \"codegen_fulfill_obligation(trait_ref={:?}, def_id={:?})\",\n         (param_env, trait_ref),\n@@ -33,7 +36,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n \n     // Do the initial selection for the obligation. This yields the\n     // shallow result we are looking for -- that is, what specific impl.\n-    ty.infer_ctxt().enter(|infcx| {\n+    tcx.infer_ctxt().enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n \n         let obligation_cause = ObligationCause::dummy();\n@@ -118,7 +121,10 @@ where\n     // contains unbound type parameters. It could be a slight\n     // optimization to stop iterating early.\n     if let Err(errors) = fulfill_cx.select_all_or_error(infcx) {\n-        bug!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors);\n+        infcx.tcx.sess.delay_span_bug(\n+            rustc_span::DUMMY_SP,\n+            &format!(\"Encountered errors `{:?}` resolving bounds after type-checking\", errors),\n+        );\n     }\n \n     let result = infcx.resolve_vars_if_possible(result);", "previous_filename": "compiler/rustc_trait_selection/src/traits/codegen/mod.rs"}, {"sha": "c79b2624f8cb0256d003fd53ae9e4ede270c1c34", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 64, "deletions": 21, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -223,11 +223,23 @@ impl AbstractConst<'tcx> {\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+struct WorkNode<'tcx> {\n+    node: Node<'tcx>,\n+    span: Span,\n+    used: bool,\n+}\n+\n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     body: &'a mir::Body<'tcx>,\n     /// The current WIP node tree.\n-    nodes: IndexVec<NodeId, Node<'tcx>>,\n+    ///\n+    /// We require all nodes to be used in the final abstract const,\n+    /// so we store this here. Note that we also consider nodes as used\n+    /// if they are mentioned in an assert, so some used nodes are never\n+    /// actually reachable by walking the [`AbstractConst`].\n+    nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n     locals: IndexVec<mir::Local, NodeId>,\n     /// We only allow field accesses if they access\n     /// the result of a checked operation.\n@@ -274,6 +286,27 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         Ok(Some(builder))\n     }\n \n+    fn add_node(&mut self, node: Node<'tcx>, span: Span) -> NodeId {\n+        // Mark used nodes.\n+        match node {\n+            Node::Leaf(_) => (),\n+            Node::Binop(_, lhs, rhs) => {\n+                self.nodes[lhs].used = true;\n+                self.nodes[rhs].used = true;\n+            }\n+            Node::UnaryOp(_, input) => {\n+                self.nodes[input].used = true;\n+            }\n+            Node::FunctionCall(func, nodes) => {\n+                self.nodes[func].used = true;\n+                nodes.iter().for_each(|&n| self.nodes[n].used = true);\n+            }\n+        }\n+\n+        // Nodes start as unused.\n+        self.nodes.push(WorkNode { node, span, used: false })\n+    }\n+\n     fn place_to_local(\n         &mut self,\n         span: Span,\n@@ -311,7 +344,7 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 let local = self.place_to_local(span, p)?;\n                 Ok(self.locals[local])\n             }\n-            mir::Operand::Constant(ct) => Ok(self.nodes.push(Node::Leaf(ct.literal))),\n+            mir::Operand::Constant(ct) => Ok(self.add_node(Node::Leaf(ct.literal), span)),\n         }\n     }\n \n@@ -336,38 +369,38 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n         debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n+        let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(stmt.source_info.span, place)?;\n+                let local = self.place_to_local(span, place)?;\n                 match *rvalue {\n                     Rvalue::Use(ref operand) => {\n-                        self.locals[local] =\n-                            self.operand_to_node(stmt.source_info.span, operand)?;\n+                        self.locals[local] = self.operand_to_node(span, operand)?;\n                         Ok(())\n                     }\n                     Rvalue::BinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         if op.is_checkable() {\n                             bug!(\"unexpected unchecked checkable binary operation\");\n                         } else {\n                             Ok(())\n                         }\n                     }\n                     Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(stmt.source_info.span, lhs)?;\n-                        let rhs = self.operand_to_node(stmt.source_info.span, rhs)?;\n-                        self.locals[local] = self.nodes.push(Node::Binop(op, lhs, rhs));\n+                        let lhs = self.operand_to_node(span, lhs)?;\n+                        let rhs = self.operand_to_node(span, rhs)?;\n+                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n                         self.checked_op_locals.insert(local);\n                         Ok(())\n                     }\n                     Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(stmt.source_info.span, operand)?;\n-                        self.locals[local] = self.nodes.push(Node::UnaryOp(op, operand));\n+                        let operand = self.operand_to_node(span, operand)?;\n+                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n                         Ok(())\n                     }\n-                    _ => self.error(Some(stmt.source_info.span), \"unsupported rvalue\")?,\n+                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n                 }\n             }\n             // These are not actually relevant for us here, so we can ignore them.\n@@ -415,13 +448,9 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                         .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n                         .collect::<Result<Vec<NodeId>, _>>()?,\n                 );\n-                self.locals[local] = self.nodes.push(Node::FunctionCall(func, args));\n+                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n                 Ok(Some(target))\n             }\n-            // We only allow asserts for checked operations.\n-            //\n-            // These asserts seem to all have the form `!_local.0` so\n-            // we only allow exactly that.\n             TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n                 let p = match cond {\n                     mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n@@ -430,7 +459,15 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n                 const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n                 debug!(\"proj: {:?}\", p.projection);\n-                if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n+                if let Some(p) = p.as_local() {\n+                    debug_assert!(!self.checked_op_locals.contains(p));\n+                    // Mark locals directly used in asserts as used.\n+                    //\n+                    // This is needed because division does not use `CheckedBinop` but instead\n+                    // adds an explicit assert for `divisor != 0`.\n+                    self.nodes[self.locals[p]].used = true;\n+                    return Ok(Some(target));\n+                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n                     // Only allow asserts checking the result of a checked operation.\n                     if self.checked_op_locals.contains(p.local) {\n                         return Ok(Some(target));\n@@ -457,7 +494,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             if let Some(next) = self.build_terminator(block.terminator())? {\n                 block = &self.body.basic_blocks()[next];\n             } else {\n-                return Ok(self.tcx.arena.alloc_from_iter(self.nodes));\n+                assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n+                self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n+                if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n+                    self.error(Some(unused.span), \"dead code\")?;\n+                }\n+\n+                return Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)));\n             }\n         }\n     }"}, {"sha": "f8bd3ab96e254733666043631f3402f7a7388f7c", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -255,9 +255,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom();\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        let trait_predicate = ty::Binder::bind(trait_predicate);\n+                        let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(&trait_predicate);\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n@@ -531,7 +532,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n \n                     ty::PredicateAtom::RegionOutlives(predicate) => {\n-                        let predicate = ty::Binder::bind(predicate);\n+                        let predicate = bound_predicate.rebind(predicate);\n                         let predicate = self.resolve_vars_if_possible(&predicate);\n                         let err = self\n                             .region_outlives_predicate(&obligation.cause, predicate)\n@@ -1078,9 +1079,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n-        let (cond, error) = match (cond.skip_binders(), error.skip_binders()) {\n+        let bound_error = error.bound_atom();\n+        let (cond, error) = match (cond.skip_binders(), bound_error.skip_binder()) {\n             (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n-                (cond, ty::Binder::bind(error))\n+                (cond, bound_error.rebind(error))\n             }\n             _ => {\n                 // FIXME: make this work in other cases too.\n@@ -1089,9 +1091,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            if let ty::PredicateAtom::Trait(implication, _) = obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            if let ty::PredicateAtom::Trait(implication, _) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n-                let implication = ty::Binder::bind(implication.trait_ref);\n+                let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n                 // Eventually I'll need to implement param-env-aware\n                 // `\u0393\u2081 \u22a6 \u03c6\u2081 => \u0393\u2082 \u22a6 \u03c6\u2082` logic.\n@@ -1169,12 +1172,13 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n+            let bound_predicate = predicate.bound_atom();\n+            if let ty::PredicateAtom::Projection(data) = bound_predicate.skip_binder() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n                     infer::LateBoundRegionConversionTime::HigherRankedType,\n-                    &ty::Binder::bind(data),\n+                    &bound_predicate.rebind(data),\n                 );\n                 let mut obligations = vec![];\n                 let normalized_ty = super::normalize_projection_type(\n@@ -1455,11 +1459,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let mut err = match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom();\n+        let mut err = match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(data, _) => {\n-                let trait_ref = ty::Binder::bind(data.trait_ref);\n-                let self_ty = trait_ref.skip_binder().self_ty();\n-                debug!(\"self_ty {:?} {:?} trait_ref {:?}\", self_ty, self_ty.kind(), trait_ref);\n+                let trait_ref = bound_predicate.rebind(data.trait_ref);\n+                debug!(\"trait_ref {:?}\", trait_ref);\n \n                 if predicate.references_error() {\n                     return;\n@@ -1474,6 +1478,17 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // known, since we don't dispatch based on region\n                 // relationships.\n \n+                // Pick the first substitution that still contains inference variables as the one\n+                // we're going to emit an error for. If there are none (see above), fall back to\n+                // the substitution for `Self`.\n+                let subst = {\n+                    let substs = data.trait_ref.substs;\n+                    substs\n+                        .iter()\n+                        .find(|s| s.has_infer_types_or_consts())\n+                        .unwrap_or_else(|| substs[0])\n+                };\n+\n                 // This is kind of a hack: it frequently happens that some earlier\n                 // error prevents types from being fully inferred, and then we get\n                 // a bunch of uninteresting errors saying something like \"<generic\n@@ -1490,21 +1505,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // check upstream for type errors and don't add the obligations to\n                 // begin with in those cases.\n                 if self.tcx.lang_items().sized_trait() == Some(trait_ref.def_id()) {\n-                    self.emit_inference_failure_err(\n-                        body_id,\n-                        span,\n-                        self_ty.into(),\n-                        ErrorCode::E0282,\n-                    )\n-                    .emit();\n+                    self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0282).emit();\n                     return;\n                 }\n-                let mut err = self.emit_inference_failure_err(\n-                    body_id,\n-                    span,\n-                    self_ty.into(),\n-                    ErrorCode::E0283,\n-                );\n+                let mut err =\n+                    self.emit_inference_failure_err(body_id, span, subst, ErrorCode::E0283);\n                 err.note(&format!(\"cannot satisfy `{}`\", predicate));\n                 if let ObligationCauseCode::ItemObligation(def_id) = obligation.cause.code {\n                     self.suggest_fully_qualified_path(&mut err, def_id, span, trait_ref.def_id());\n@@ -1582,7 +1587,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n             ty::PredicateAtom::Projection(data) => {\n-                let trait_ref = ty::Binder::bind(data).to_poly_trait_ref(self.tcx);\n+                let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n                 if predicate.references_error() {"}, {"sha": "9a8b5534dfe83089ec944691d47420707f13b743", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,6 @@\n use crate::infer::{InferCtxt, TyOrConstInferVar};\n use rustc_data_structures::obligation_forest::ProcessResult;\n-use rustc_data_structures::obligation_forest::{DoCompleted, Error, ForestObligation};\n+use rustc_data_structures::obligation_forest::{Error, ForestObligation, Outcome};\n use rustc_data_structures::obligation_forest::{ObligationForest, ObligationProcessor};\n use rustc_errors::ErrorReported;\n use rustc_infer::traits::{TraitEngine, TraitEngineExt as _, TraitObligation};\n@@ -129,13 +129,11 @@ impl<'a, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = self.predicates.process_obligations(\n-                &mut FulfillProcessor {\n+            let outcome: Outcome<_, _> =\n+                self.predicates.process_obligations(&mut FulfillProcessor {\n                     selcx,\n                     register_region_obligations: self.register_region_obligations,\n-                },\n-                DoCompleted::No,\n-            );\n+                });\n             debug!(\"select: outcome={:#?}\", outcome);\n \n             // FIXME: if we kept the original cache key, we could mark projection\n@@ -353,7 +351,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n                 ty::PredicateAtom::Trait(trait_ref, _constness) => {\n-                    let trait_obligation = obligation.with(Binder::bind(trait_ref));\n+                    let trait_obligation = obligation.with(binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n                         obligation,\n@@ -362,7 +360,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n                 ty::PredicateAtom::Projection(data) => {\n-                    let project_obligation = obligation.with(Binder::bind(data));\n+                    let project_obligation = obligation.with(binder.rebind(data));\n \n                     self.process_projection_obligation(\n                         project_obligation,"}, {"sha": "d1647e686a84f9b225acf62c4104157c96f4a87f", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 63, "deletions": 48, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -13,15 +13,15 @@ use super::elaborate_predicates;\n use crate::infer::TyCtxtInferExt;\n use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n-use rustc_errors::{Applicability, FatalError};\n+use rustc_errors::FatalError;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::subst::{GenericArg, InternalSubsts, Subst};\n use rustc_middle::ty::{self, Ty, TyCtxt, TypeFoldable, TypeVisitor, WithConstness};\n use rustc_middle::ty::{Predicate, ToPredicate};\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n use rustc_span::symbol::Symbol;\n-use rustc_span::Span;\n+use rustc_span::{MultiSpan, Span};\n use smallvec::SmallVec;\n \n use std::array;\n@@ -100,49 +100,7 @@ fn object_safety_violations_for_trait(\n                 span,\n             ) = violation\n             {\n-                // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n-                // It's also hard to get a use site span, so we use the method definition span.\n-                tcx.struct_span_lint_hir(\n-                    WHERE_CLAUSES_OBJECT_SAFETY,\n-                    hir::CRATE_HIR_ID,\n-                    *span,\n-                    |lint| {\n-                        let mut err = lint.build(&format!(\n-                            \"the trait `{}` cannot be made into an object\",\n-                            tcx.def_path_str(trait_def_id)\n-                        ));\n-                        let node = tcx.hir().get_if_local(trait_def_id);\n-                        let msg = if let Some(hir::Node::Item(item)) = node {\n-                            err.span_label(\n-                                item.ident.span,\n-                                \"this trait cannot be made into an object...\",\n-                            );\n-                            format!(\"...because {}\", violation.error_msg())\n-                        } else {\n-                            format!(\n-                                \"the trait cannot be made into an object because {}\",\n-                                violation.error_msg()\n-                            )\n-                        };\n-                        err.span_label(*span, &msg);\n-                        match (node, violation.solution()) {\n-                            (Some(_), Some((note, None))) => {\n-                                err.help(&note);\n-                            }\n-                            (Some(_), Some((note, Some((sugg, span))))) => {\n-                                err.span_suggestion(\n-                                    span,\n-                                    &note,\n-                                    sugg,\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            // Only provide the help if its a local trait, otherwise it's not actionable.\n-                            _ => {}\n-                        }\n-                        err.emit();\n-                    },\n-                );\n+                lint_object_unsafe_trait(tcx, *span, trait_def_id, violation);\n                 false\n             } else {\n                 true\n@@ -180,6 +138,51 @@ fn object_safety_violations_for_trait(\n     violations\n }\n \n+/// Lint object-unsafe trait.\n+fn lint_object_unsafe_trait(\n+    tcx: TyCtxt<'_>,\n+    span: Span,\n+    trait_def_id: DefId,\n+    violation: &ObjectSafetyViolation,\n+) {\n+    // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n+    // It's also hard to get a use site span, so we use the method definition span.\n+    tcx.struct_span_lint_hir(WHERE_CLAUSES_OBJECT_SAFETY, hir::CRATE_HIR_ID, span, |lint| {\n+        let mut err = lint.build(&format!(\n+            \"the trait `{}` cannot be made into an object\",\n+            tcx.def_path_str(trait_def_id)\n+        ));\n+        let node = tcx.hir().get_if_local(trait_def_id);\n+        let mut spans = MultiSpan::from_span(span);\n+        if let Some(hir::Node::Item(item)) = node {\n+            spans.push_span_label(\n+                item.ident.span,\n+                \"this trait cannot be made into an object...\".into(),\n+            );\n+            spans.push_span_label(span, format!(\"...because {}\", violation.error_msg()));\n+        } else {\n+            spans.push_span_label(\n+                span,\n+                format!(\n+                    \"the trait cannot be made into an object because {}\",\n+                    violation.error_msg()\n+                ),\n+            );\n+        };\n+        err.span_note(\n+            spans,\n+            \"for a trait to be \\\"object safe\\\" it needs to allow building a vtable to allow the \\\n+             call to be resolvable dynamically; for more information visit \\\n+             <https://doc.rust-lang.org/reference/items/traits.html#object-safety>\",\n+        );\n+        if node.is_some() {\n+            // Only provide the help if its a local trait, otherwise it's not\n+            violation.solution(&mut err);\n+        }\n+        err.emit();\n+    });\n+}\n+\n fn sized_trait_bound_spans<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     bounds: hir::GenericBounds<'tcx>,\n@@ -385,6 +388,8 @@ fn virtual_call_violation_for_method<'tcx>(\n     trait_def_id: DefId,\n     method: &ty::AssocItem,\n ) -> Option<MethodViolationCode> {\n+    let sig = tcx.fn_sig(method.def_id);\n+\n     // The method's first parameter must be named `self`\n     if !method.fn_has_self_parameter {\n         // We'll attempt to provide a structured suggestion for `Self: Sized`.\n@@ -395,11 +400,21 @@ fn virtual_call_violation_for_method<'tcx>(\n                     [.., pred] => (\", Self: Sized\", pred.span().shrink_to_hi()),\n                 },\n             );\n-        return Some(MethodViolationCode::StaticMethod(sugg));\n+        // Get the span pointing at where the `self` receiver should be.\n+        let sm = tcx.sess.source_map();\n+        let self_span = method.ident.span.to(tcx\n+            .hir()\n+            .span_if_local(method.def_id)\n+            .unwrap_or_else(|| sm.next_point(method.ident.span))\n+            .shrink_to_hi());\n+        let self_span = sm.span_through_char(self_span, '(').shrink_to_hi();\n+        return Some(MethodViolationCode::StaticMethod(\n+            sugg,\n+            self_span,\n+            !sig.inputs().skip_binder().is_empty(),\n+        ));\n     }\n \n-    let sig = tcx.fn_sig(method.def_id);\n-\n     for (i, input_ty) in sig.skip_binder().inputs()[1..].iter().enumerate() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelfInput(i));"}, {"sha": "827b1d35f1c2296ddc69fd31fd26b73ac038aac5", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -623,7 +623,8 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n                 // variables. In principle, we only care if this\n@@ -634,7 +635,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n                 ty::PredicateAtom::Projection(data) => {\n-                    infcx.unresolved_type_vars(&ty::Binder::bind(data.ty)).is_some()\n+                    infcx.unresolved_type_vars(&bound_predicate.rebind(data.ty)).is_some()\n                 }\n \n                 // We are only interested in `T: Foo<X = U>` predicates, whre\n@@ -907,8 +908,9 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(?predicate);\n+        let bound_predicate = predicate.bound_atom();\n         if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n-            let data = ty::Binder::bind(data);\n+            let data = bound_predicate.rebind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n \n             let is_match = same_def_id"}, {"sha": "b0bfb4ad173719c791a3f228f87997aac1c11a50", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -642,24 +642,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             debug!(?poly_trait_ref, \"assemble_candidates_from_object_ty\");\n \n+            let poly_trait_predicate = self.infcx().resolve_vars_if_possible(&obligation.predicate);\n+            let placeholder_trait_predicate =\n+                self.infcx().replace_bound_vars_with_placeholders(&poly_trait_predicate);\n+\n             // Count only those upcast versions that match the trait-ref\n             // we are looking for. Specifically, do not only check for the\n             // correct trait, but also the correct type parameters.\n             // For example, we may be trying to upcast `Foo` to `Bar<i32>`,\n             // but `Foo` is declared as `trait Foo: Bar<u32>`.\n-            let upcast_trait_refs = util::supertraits(self.tcx(), poly_trait_ref)\n-                .filter(|upcast_trait_ref| {\n-                    self.infcx\n-                        .probe(|_| self.match_poly_trait_ref(obligation, *upcast_trait_ref).is_ok())\n+            let candidate_supertraits = util::supertraits(self.tcx(), poly_trait_ref)\n+                .enumerate()\n+                .filter(|&(_, upcast_trait_ref)| {\n+                    self.infcx.probe(|_| {\n+                        self.match_normalize_trait_ref(\n+                            obligation,\n+                            upcast_trait_ref,\n+                            placeholder_trait_predicate.trait_ref,\n+                        )\n+                        .is_ok()\n+                    })\n                 })\n-                .count();\n+                .map(|(idx, _)| ObjectCandidate(idx));\n \n-            if upcast_trait_refs > 1 {\n-                // Can be upcast in many ways; need more type information.\n-                candidates.ambiguous = true;\n-            } else if upcast_trait_refs == 1 {\n-                candidates.vec.push(ObjectCandidate);\n-            }\n+            candidates.vec.extend(candidate_supertraits);\n         })\n     }\n "}, {"sha": "872b8e85f563fa1bbcd191b1628298a91159ef13", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 44, "deletions": 53, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -69,10 +69,15 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ProjectionCandidate(idx) => {\n-                let obligations = self.confirm_projection_candidate(obligation, idx);\n+                let obligations = self.confirm_projection_candidate(obligation, idx)?;\n                 Ok(ImplSource::Param(obligations))\n             }\n \n+            ObjectCandidate(idx) => {\n+                let data = self.confirm_object_candidate(obligation, idx)?;\n+                Ok(ImplSource::Object(data))\n+            }\n+\n             ClosureCandidate => {\n                 let vtable_closure = self.confirm_closure_candidate(obligation)?;\n                 Ok(ImplSource::Closure(vtable_closure))\n@@ -97,11 +102,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(ImplSource::TraitAlias(data))\n             }\n \n-            ObjectCandidate => {\n-                let data = self.confirm_object_candidate(obligation);\n-                Ok(ImplSource::Object(data))\n-            }\n-\n             BuiltinObjectCandidate => {\n                 // This indicates something like `Trait + Send: Send`. In this case, we know that\n                 // this holds because that's what the object type is telling us, and there's really\n@@ -120,7 +120,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         idx: usize,\n-    ) -> Vec<PredicateObligation<'tcx>> {\n+    ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         self.infcx.commit_unconditionally(|_| {\n             let tcx = self.tcx();\n \n@@ -148,19 +148,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 &mut obligations,\n             );\n \n-            obligations.extend(\n+            obligations.extend(self.infcx.commit_if_ok(|_| {\n                 self.infcx\n                     .at(&obligation.cause, obligation.param_env)\n                     .sup(placeholder_trait_predicate.trait_ref.to_poly_trait_ref(), candidate)\n                     .map(|InferOk { obligations, .. }| obligations)\n-                    .unwrap_or_else(|_| {\n-                        bug!(\n-                            \"Projection bound `{:?}` was applicable to `{:?}` but now is not\",\n-                            candidate,\n-                            obligation\n-                        );\n-                    }),\n-            );\n+                    .map_err(|_| Unimplemented)\n+            })?);\n \n             if let ty::Projection(..) = placeholder_self_ty.kind() {\n                 for predicate in tcx.predicates_of(def_id).instantiate_own(tcx, substs).predicates {\n@@ -181,7 +175,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n             }\n \n-            obligations\n+            Ok(obligations)\n         })\n     }\n \n@@ -371,9 +365,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     fn confirm_object_candidate(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n-    ) -> ImplSourceObjectData<'tcx, PredicateObligation<'tcx>> {\n-        debug!(?obligation, \"confirm_object_candidate\");\n+        index: usize,\n+    ) -> Result<ImplSourceObjectData<'tcx, PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n         let tcx = self.tcx();\n+        debug!(?obligation, ?index, \"confirm_object_candidate\");\n \n         let trait_predicate =\n             self.infcx.replace_bound_vars_with_placeholders(&obligation.predicate);\n@@ -399,43 +394,39 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             })\n             .with_self_ty(self.tcx(), self_ty);\n \n-        let mut upcast_trait_ref = None;\n         let mut nested = vec![];\n-        let vtable_base;\n \n-        {\n-            // We want to find the first supertrait in the list of\n-            // supertraits that we can unify with, and do that\n-            // unification. We know that there is exactly one in the list\n-            // where we can unify, because otherwise select would have\n-            // reported an ambiguity. (When we do find a match, also\n-            // record it for later.)\n-            let nonmatching = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref))\n-                .take_while(|&t| {\n-                    match self.infcx.commit_if_ok(|_| {\n-                        self.infcx\n-                            .at(&obligation.cause, obligation.param_env)\n-                            .sup(obligation_trait_ref, t)\n-                            .map(|InferOk { obligations, .. }| obligations)\n-                            .map_err(|_| ())\n-                    }) {\n-                        Ok(obligations) => {\n-                            upcast_trait_ref = Some(t);\n-                            nested.extend(obligations);\n-                            false\n-                        }\n-                        Err(_) => true,\n-                    }\n-                });\n+        let mut supertraits = util::supertraits(tcx, ty::Binder::dummy(object_trait_ref));\n \n-            // Additionally, for each of the non-matching predicates that\n-            // we pass over, we sum up the set of number of vtable\n-            // entries, so that we can compute the offset for the selected\n-            // trait.\n-            vtable_base = nonmatching.map(|t| super::util::count_own_vtable_entries(tcx, t)).sum();\n-        }\n+        // For each of the non-matching predicates that\n+        // we pass over, we sum up the set of number of vtable\n+        // entries, so that we can compute the offset for the selected\n+        // trait.\n+        let vtable_base = supertraits\n+            .by_ref()\n+            .take(index)\n+            .map(|t| super::util::count_own_vtable_entries(tcx, t))\n+            .sum();\n+\n+        let unnormalized_upcast_trait_ref =\n+            supertraits.next().expect(\"supertraits iterator no longer has as many elements\");\n+\n+        let upcast_trait_ref = normalize_with_depth_to(\n+            self,\n+            obligation.param_env,\n+            obligation.cause.clone(),\n+            obligation.recursion_depth + 1,\n+            &unnormalized_upcast_trait_ref,\n+            &mut nested,\n+        );\n \n-        let upcast_trait_ref = upcast_trait_ref.unwrap();\n+        nested.extend(self.infcx.commit_if_ok(|_| {\n+            self.infcx\n+                .at(&obligation.cause, obligation.param_env)\n+                .sup(obligation_trait_ref, upcast_trait_ref)\n+                .map(|InferOk { obligations, .. }| obligations)\n+                .map_err(|_| Unimplemented)\n+        })?);\n \n         // Check supertraits hold. This is so that their associated type bounds\n         // will be checked in the code below.\n@@ -501,7 +492,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         debug!(?nested, \"object nested obligations\");\n-        ImplSourceObjectData { upcast_trait_ref, vtable_base, nested }\n+        Ok(ImplSourceObjectData { upcast_trait_ref, vtable_base, nested })\n     }\n \n     fn confirm_fn_pointer_candidate("}, {"sha": "4cc4bc0acdab68923116058b5c4b1b15ccb9af6c", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -449,16 +449,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let result = ensure_sufficient_stack(|| {\n-            match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(t, _) => {\n-                    let t = ty::Binder::bind(t);\n+                    let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n                     self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n                 }\n \n                 ty::PredicateAtom::Subtype(p) => {\n-                    let p = ty::Binder::bind(p);\n+                    let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n                         Some(Ok(InferOk { mut obligations, .. })) => {\n@@ -502,7 +503,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 ty::PredicateAtom::Projection(data) => {\n-                    let data = ty::Binder::bind(data);\n+                    let data = bound_predicate.rebind(data);\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n                         Ok(Ok(Some(mut subobligations))) => {\n@@ -517,12 +518,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             result\n                         }\n                         Ok(Ok(None)) => Ok(EvaluatedToAmbig),\n-                        // EvaluatedToRecur might also be acceptable here, but use\n-                        // Unknown for now because it means that we won't dismiss a\n-                        // selection candidate solely because it has a projection\n-                        // cycle. This is closest to the previous behavior of\n-                        // immediately erroring.\n-                        Ok(Err(project::InProgress)) => Ok(EvaluatedToUnknown),\n+                        Ok(Err(project::InProgress)) => Ok(EvaluatedToRecur),\n                         Err(_) => Ok(EvaluatedToErr),\n                     }\n                 }\n@@ -1174,10 +1170,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n-                if let ty::PredicateAtom::Trait(pred, _) = bound.skip_binders() {\n-                    let bound = ty::Binder::bind(pred.trait_ref);\n+                let bound_predicate = bound.bound_atom();\n+                if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                    let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n-                        match self.match_projection(\n+                        match self.match_normalize_trait_ref(\n                             obligation,\n                             bound,\n                             placeholder_trait_predicate.trait_ref,\n@@ -1205,7 +1202,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     /// Equates the trait in `obligation` with trait bound. If the two traits\n     /// can be equated and the normalized trait bound doesn't contain inference\n     /// variables or placeholders, the normalized bound is returned.\n-    fn match_projection(\n+    fn match_normalize_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         trait_bound: ty::PolyTraitRef<'tcx>,\n@@ -1355,10 +1352,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..)\n-                | ObjectCandidate\n+                | ObjectCandidate(_)\n                 | ProjectionCandidate(_),\n             ) => !is_global(cand),\n-            (ObjectCandidate | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n+            (ObjectCandidate(_) | ProjectionCandidate(_), ParamCandidate(ref cand)) => {\n                 // Prefer these to a global where-clause bound\n                 // (see issue #50825).\n                 is_global(cand)\n@@ -1379,20 +1376,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 is_global(cand) && other.evaluation.must_apply_modulo_regions()\n             }\n \n-            (ProjectionCandidate(i), ProjectionCandidate(j)) => {\n-                // Arbitrarily pick the first candidate for backwards\n+            (ProjectionCandidate(i), ProjectionCandidate(j))\n+            | (ObjectCandidate(i), ObjectCandidate(j)) => {\n+                // Arbitrarily pick the lower numbered candidate for backwards\n                 // compatibility reasons. Don't let this affect inference.\n-                i > j && !needs_infer\n+                i < j && !needs_infer\n             }\n-            (ObjectCandidate, ObjectCandidate) => bug!(\"Duplicate object candidate\"),\n-            (ObjectCandidate, ProjectionCandidate(_))\n-            | (ProjectionCandidate(_), ObjectCandidate) => {\n+            (ObjectCandidate(_), ProjectionCandidate(_))\n+            | (ProjectionCandidate(_), ObjectCandidate(_)) => {\n                 bug!(\"Have both object and projection candidate\")\n             }\n \n             // Arbitrarily give projection and object candidates priority.\n             (\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n                 ImplCandidate(..)\n                 | ClosureCandidate\n                 | GeneratorCandidate\n@@ -1412,7 +1409,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 | BuiltinUnsizeCandidate\n                 | BuiltinCandidate { .. }\n                 | TraitAliasCandidate(..),\n-                ObjectCandidate | ProjectionCandidate(_),\n+                ObjectCandidate(_) | ProjectionCandidate(_),\n             ) => false,\n \n             (&ImplCandidate(other_def), &ImplCandidate(victim_def)) => {\n@@ -1529,16 +1526,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Str | ty::Slice(_) | ty::Dynamic(..) | ty::Foreign(..) => None,\n \n-            ty::Tuple(tys) => {\n-                Where(ty::Binder::bind(tys.last().into_iter().map(|k| k.expect_ty()).collect()))\n-            }\n+            ty::Tuple(tys) => Where(\n+                obligation\n+                    .predicate\n+                    .rebind(tys.last().into_iter().map(|k| k.expect_ty()).collect()),\n+            ),\n \n             ty::Adt(def, substs) => {\n                 let sized_crit = def.sized_constraint(self.tcx());\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(\n-                    sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect(),\n-                ))\n+                Where(\n+                    obligation.predicate.rebind({\n+                        sized_crit.iter().map(|ty| ty.subst(self.tcx(), substs)).collect()\n+                    }),\n+                )\n             }\n \n             ty::Projection(_) | ty::Param(_) | ty::Opaque(..) => None,\n@@ -1561,7 +1562,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         use self::BuiltinImplConditions::{Ambiguous, None, Where};\n \n-        match self_ty.kind() {\n+        match *self_ty.kind() {\n             ty::Infer(ty::IntVar(_))\n             | ty::Infer(ty::FloatVar(_))\n             | ty::FnDef(..)\n@@ -1590,12 +1591,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::Array(element_ty, _) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(vec![element_ty]))\n+                Where(obligation.predicate.rebind(vec![element_ty]))\n             }\n \n             ty::Tuple(tys) => {\n                 // (*) binder moved here\n-                Where(ty::Binder::bind(tys.iter().map(|k| k.expect_ty()).collect()))\n+                Where(obligation.predicate.rebind(tys.iter().map(|k| k.expect_ty()).collect()))\n             }\n \n             ty::Closure(_, substs) => {\n@@ -1605,7 +1606,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Not yet resolved.\n                     Ambiguous\n                 } else {\n-                    Where(ty::Binder::bind(substs.as_closure().upvar_tys().collect()))\n+                    Where(obligation.predicate.rebind(substs.as_closure().upvar_tys().collect()))\n                 }\n             }\n \n@@ -1884,9 +1885,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n     /// Normalize `where_clause_trait_ref` and try to match it against\n     /// `obligation`. If successful, return any predicates that\n-    /// result from the normalization. Normalization is necessary\n-    /// because where-clauses are stored in the parameter environment\n-    /// unnormalized.\n+    /// result from the normalization.\n     fn match_where_clause_trait_ref(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,"}, {"sha": "5ca0fc0c88b540623fdee82d71afecfd49eb36d2", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 31, "deletions": 27, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -81,8 +81,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().map(|predicate| {\n-            let (predicate, binders, _named_regions) =\n-                collect_bound_vars(interner, interner.tcx, &predicate.bound_atom(interner.tcx));\n+            let (predicate, binders, _named_regions) = collect_bound_vars(\n+                interner,\n+                interner.tcx,\n+                &predicate.bound_atom_with_opt_escaping(interner.tcx),\n+            );\n             let consequence = match predicate {\n                 ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n                     chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner)))\n@@ -133,8 +136,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (predicate, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n \n         let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n@@ -653,8 +659,11 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let (predicate, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self.bound_atom(interner.tcx));\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n         let value = match predicate {\n             ty::PredicateAtom::Trait(predicate, _) => {\n                 Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n@@ -762,27 +771,22 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>> {\n-        match self.bound_atom(interner.tcx).skip_binder() {\n-            ty::PredicateAtom::Trait(predicate, _) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::TraitBound(\n-                        predicate.trait_ref.lower_into(interner),\n-                    ),\n-                ))\n-            }\n-            ty::PredicateAtom::Projection(predicate) => {\n-                let (predicate, binders, _named_regions) =\n-                    collect_bound_vars(interner, interner.tcx, &ty::Binder::bind(predicate));\n-\n-                Some(chalk_ir::Binders::new(\n-                    binders,\n-                    chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n-                ))\n-            }\n+        let (predicate, binders, _named_regions) = collect_bound_vars(\n+            interner,\n+            interner.tcx,\n+            &self.bound_atom_with_opt_escaping(interner.tcx),\n+        );\n+        match predicate {\n+            ty::PredicateAtom::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::TraitBound(\n+                    predicate.trait_ref.lower_into(interner),\n+                ),\n+            )),\n+            ty::PredicateAtom::Projection(predicate) => Some(chalk_ir::Binders::new(\n+                binders,\n+                chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n+            )),\n             ty::PredicateAtom::TypeOutlives(_predicate) => None,\n             ty::PredicateAtom::WellFormed(_ty) => None,\n "}, {"sha": "2562140bb5d7e03187029bb2084fac0da6b9a6fe", "filename": "compiler/rustc_ty/src/ty.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_ty%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty%2Fsrc%2Fty.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -80,7 +80,6 @@ fn sized_constraint_for_ty<'tcx>(\n fn associated_item_from_trait_item_ref(\n     tcx: TyCtxt<'_>,\n     parent_def_id: LocalDefId,\n-    parent_vis: &hir::Visibility<'_>,\n     trait_item_ref: &hir::TraitItemRef,\n ) -> ty::AssocItem {\n     let def_id = tcx.hir().local_def_id(trait_item_ref.id.hir_id);\n@@ -93,8 +92,7 @@ fn associated_item_from_trait_item_ref(\n     ty::AssocItem {\n         ident: trait_item_ref.ident,\n         kind,\n-        // Visibility of trait items is inherited from their traits.\n-        vis: ty::Visibility::from_hir(parent_vis, trait_item_ref.id.hir_id, tcx),\n+        vis: tcx.visibility(def_id),\n         defaultness: trait_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n         container: ty::TraitContainer(parent_def_id.to_def_id()),\n@@ -117,8 +115,7 @@ fn associated_item_from_impl_item_ref(\n     ty::AssocItem {\n         ident: impl_item_ref.ident,\n         kind,\n-        // Visibility of trait impl items doesn't matter.\n-        vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.hir_id, tcx),\n+        vis: tcx.visibility(def_id),\n         defaultness: impl_item_ref.defaultness,\n         def_id: def_id.to_def_id(),\n         container: ty::ImplContainer(parent_def_id.to_def_id()),\n@@ -143,12 +140,8 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) = trait_item_refs.iter().find(|i| i.id.hir_id == id) {\n-                let assoc_item = associated_item_from_trait_item_ref(\n-                    tcx,\n-                    parent_def_id,\n-                    &parent_item.vis,\n-                    trait_item_ref,\n-                );\n+                let assoc_item =\n+                    associated_item_from_trait_item_ref(tcx, parent_def_id, trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n                 return assoc_item;\n             }"}, {"sha": "3bfb2d3f1b0f958173bed32d9d9bd3914d1e48c2", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -548,13 +548,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generics: &ty::Generics,\n     ) -> bool {\n         let explicit = !seg.infer_args;\n-        let impl_trait = generics.params.iter().any(|param| match param.kind {\n-            ty::GenericParamDefKind::Type {\n-                synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n-                ..\n-            } => true,\n-            _ => false,\n-        });\n+        let impl_trait =\n+            generics.params.iter().any(|param| match param.kind {\n+                ty::GenericParamDefKind::Type {\n+                    synthetic:\n+                        Some(\n+                            hir::SyntheticTyParamKind::ImplTrait\n+                            | hir::SyntheticTyParamKind::FromAttr,\n+                        ),\n+                    ..\n+                } => true,\n+                _ => false,\n+            });\n \n         if explicit && impl_trait {\n             let spans = seg"}, {"sha": "07e523af3ebf518b5b0ad9413273725379a54024", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1095,9 +1095,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                match obligation.predicate.skip_binders() {\n+                let bound_predicate = obligation.predicate.bound_atom();\n+                match bound_predicate.skip_binder() {\n                     ty::PredicateAtom::Trait(pred, _) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n                                 .in_definition_order()\n@@ -1106,7 +1107,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         );\n                     }\n                     ty::PredicateAtom::Projection(pred) => {\n-                        let pred = ty::Binder::bind(pred);\n+                        let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self ="}, {"sha": "398e013e62fb561b0f58da9bec9f8bb6c0388f95", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -201,6 +201,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         expr.span,\n                         ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                             arm_span,\n+                            scrut_span: scrut.span,\n                             semi_span,\n                             source: match_src,\n                             prior_arms: other_arms.clone(),"}, {"sha": "3d8653b4a6a470ecd72001ecfc5c477fec151b55", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -348,8 +348,7 @@ pub(super) fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     check_packed(tcx, span, def);\n }\n \n-/// When the `#![feature(untagged_unions)]` gate is active,\n-/// check that the fields of the `union` does not contain fields that need dropping.\n+/// Check that the fields of the `union` do not need dropping.\n pub(super) fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> bool {\n     let item_type = tcx.type_of(item_def_id);\n     if let ty::Adt(def, substs) = item_type.kind() {"}, {"sha": "8cd83c39f9e31a061205264fc8d1fa0a5dfbe693", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -192,14 +192,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n+                let bound_predicate = obligation.predicate.bound_atom();\n                 if let ty::PredicateAtom::Projection(proj_predicate) =\n                     obligation.predicate.skip_binders()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n                     self.deduce_sig_from_projection(\n                         Some(obligation.cause.span),\n-                        ty::Binder::bind(proj_predicate),\n+                        bound_predicate.rebind(proj_predicate),\n                     )\n                 } else {\n                     None"}, {"sha": "6da3ecde329cfc0f72a7e9e62ba1e3ee0b2ae5eb", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -583,7 +583,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let trait_pred = match obligation.predicate.skip_binders() {\n+            let bound_predicate = obligation.predicate.bound_atom();\n+            let trait_pred = match bound_predicate.skip_binder() {\n                 ty::PredicateAtom::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n@@ -594,7 +595,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                             has_unsized_tuple_coercion = true;\n                         }\n                     }\n-                    ty::Binder::bind(trait_pred)\n+                    bound_predicate.rebind(trait_pred)\n                 }\n                 _ => {\n                     coercion.obligations.push(obligation);\n@@ -1474,6 +1475,28 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n         if let (Some(sp), Some(fn_output)) = (fcx.ret_coercion_span.borrow().as_ref(), fn_output) {\n             self.add_impl_trait_explanation(&mut err, cause, fcx, expected, *sp, fn_output);\n         }\n+\n+        if let Some(sp) = fcx.ret_coercion_span.borrow().as_ref() {\n+            // If the closure has an explicit return type annotation,\n+            // then a type error may occur at the first return expression we\n+            // see in the closure (if it conflicts with the declared\n+            // return type). Skip adding a note in this case, since it\n+            // would be incorrect.\n+            if !err.span.primary_spans().iter().any(|span| span == sp) {\n+                let hir = fcx.tcx.hir();\n+                let body_owner = hir.body_owned_by(hir.enclosing_body_owner(fcx.body_id));\n+                if fcx.tcx.is_closure(hir.body_owner_def_id(body_owner).to_def_id()) {\n+                    err.span_note(\n+                        *sp,\n+                        &format!(\n+                            \"return type inferred to be `{}` here\",\n+                            fcx.resolve_vars_if_possible(&expected)\n+                        ),\n+                    );\n+                }\n+            }\n+        }\n+\n         err\n     }\n "}, {"sha": "b8143787a2ddf499d5064a557eebf9844ee1943c", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -751,8 +751,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let msg = format!(\"you can convert an `{}` to `{}`\", checked_ty, expected_ty);\n-        let cast_msg = format!(\"you can cast an `{} to `{}`\", checked_ty, expected_ty);\n+        let msg = format!(\n+            \"you can convert {} `{}` to {} `{}`\",\n+            checked_ty.kind().article(),\n+            checked_ty,\n+            expected_ty.kind().article(),\n+            expected_ty,\n+        );\n+        let cast_msg = format!(\n+            \"you can cast {} `{}` to {} `{}`\",\n+            checked_ty.kind().article(),\n+            checked_ty,\n+            expected_ty.kind().article(),\n+            expected_ty,\n+        );\n         let lit_msg = format!(\n             \"change the type of the numeric literal from `{}` to `{}`\",\n             checked_ty, expected_ty,\n@@ -814,7 +826,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let suggestion = format!(\"{}::from({})\", checked_ty, lhs_src);\n                     (lhs_expr.span, msg, suggestion)\n                 } else {\n-                    let msg = format!(\"{} and panic if the converted value wouldn't fit\", msg);\n+                    let msg = format!(\"{} and panic if the converted value doesn't fit\", msg);\n                     let suggestion =\n                         format!(\"{}{}.try_into().unwrap()\", prefix, with_opt_paren(&src));\n                     (expr.span, msg, suggestion)"}, {"sha": "5650b2cdd3c98d8b2286c68319834586f57ce2bb", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -226,12 +226,14 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            match (predicate.skip_binders(), p.skip_binders()) {\n+            let predicate = predicate.bound_atom();\n+            let p = p.bound_atom();\n+            match (predicate.skip_binder(), p.skip_binder()) {\n                 (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n+                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n-                    relator.relate(ty::Binder::bind(a), ty::Binder::bind(b)).is_ok()\n+                    relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 _ => predicate == p,\n             }"}, {"sha": "9990f86a36b1374e97b1eb046ffd44e18f2bc538", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -286,6 +286,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ExprKind::DropTemps(ref e) => self.check_expr_with_expectation(e, expected),\n             ExprKind::Array(ref args) => self.check_expr_array(args, expected, expr),\n+            ExprKind::ConstBlock(ref anon_const) => self.to_const(anon_const).ty,\n             ExprKind::Repeat(ref element, ref count) => {\n                 self.check_expr_repeat(element, count, expected, expr)\n             }"}, {"sha": "4473aa2081f23192c1d0944950229e8bafef8f01", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -250,10 +250,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InteriorVisitor<'a, 'tcx> {\n             let mut scope_var_ids =\n                 self.guard_bindings.pop().expect(\"should have pushed at least one earlier\");\n             for var_id in scope_var_ids.drain(..) {\n-                assert!(\n-                    self.guard_bindings_set.remove(&var_id),\n-                    \"variable should be placed in scope earlier\"\n-                );\n+                self.guard_bindings_set.remove(&var_id);\n             }\n         }\n         self.visit_expr(body);"}, {"sha": "f40a250200e4a1df9f846ea50e7b217f1b26b64b", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -328,14 +328,14 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n \n             kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let try_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n                     tcx.mk_unit(),\n                     false,\n                     hir::Unsafety::Normal,\n                     Abi::Rust,\n                 ));\n-                let catch_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n+                let catch_fn_ty = ty::Binder::dummy(tcx.mk_fn_sig(\n                     [mut_u8, mut_u8].iter().cloned(),\n                     tcx.mk_unit(),\n                     false,"}, {"sha": "d403e25939893f4d4f46a93fbfb8cc3046b0550f", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -796,29 +796,29 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         // FIXME: do we want to commit to this behavior for param bounds?\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n-        let bounds =\n-            self.param_env.caller_bounds().iter().map(ty::Predicate::skip_binders).filter_map(\n-                |predicate| match predicate {\n-                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n-                        match trait_predicate.trait_ref.self_ty().kind() {\n-                            ty::Param(ref p) if *p == param_ty => {\n-                                Some(ty::Binder::bind(trait_predicate.trait_ref))\n-                            }\n-                            _ => None,\n+        let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n+            let bound_predicate = predicate.bound_atom();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                    match *trait_predicate.trait_ref.self_ty().kind() {\n+                        ty::Param(p) if p == param_ty => {\n+                            Some(bound_predicate.rebind(trait_predicate.trait_ref))\n                         }\n+                        _ => None,\n                     }\n-                    ty::PredicateAtom::Subtype(..)\n-                    | ty::PredicateAtom::Projection(..)\n-                    | ty::PredicateAtom::RegionOutlives(..)\n-                    | ty::PredicateAtom::WellFormed(..)\n-                    | ty::PredicateAtom::ObjectSafe(..)\n-                    | ty::PredicateAtom::ClosureKind(..)\n-                    | ty::PredicateAtom::TypeOutlives(..)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-                },\n-            );\n+                }\n+                ty::PredicateAtom::Subtype(..)\n+                | ty::PredicateAtom::Projection(..)\n+                | ty::PredicateAtom::RegionOutlives(..)\n+                | ty::PredicateAtom::WellFormed(..)\n+                | ty::PredicateAtom::ObjectSafe(..)\n+                | ty::PredicateAtom::ClosureKind(..)\n+                | ty::PredicateAtom::TypeOutlives(..)\n+                | ty::PredicateAtom::ConstEvaluatable(..)\n+                | ty::PredicateAtom::ConstEquate(..)\n+                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+            }\n+        });\n \n         self.elaborate_bounds(bounds, |this, poly_trait_ref, item| {\n             let trait_ref = this.erase_late_bound_regions(&poly_trait_ref);"}, {"sha": "6d2ffadc20c27ad126d016836001771c5fc61121", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -637,9 +637,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        match pred.skip_binders() {\n+                        let bound_predicate = pred.bound_atom();\n+                        match bound_predicate.skip_binder() {\n                             ty::PredicateAtom::Projection(pred) => {\n-                                let pred = ty::Binder::bind(pred);\n+                                let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n                                     pred.skip_binder().projection_ty.trait_ref(self.tcx);\n@@ -658,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n                             ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n-                                let poly_trait_ref = ty::Binder::bind(poly_trait_ref);\n-                                let p = poly_trait_ref.skip_binder().trait_ref;\n+                                let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n                                 let obligation = format!(\"{}: {}\", self_ty, path);"}, {"sha": "169ad0df3a5c963fe572faefddef6ad8704cae0b", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -111,6 +111,7 @@ use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirIdMap, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::Idx;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::GenericArgKind;\n@@ -528,7 +529,20 @@ fn typeck_with_fallback<'tcx>(\n                     hir::TyKind::Infer => Some(AstConv::ast_ty_to_ty(&fcx, ty)),\n                     _ => None,\n                 })\n-                .unwrap_or_else(fallback);\n+                .unwrap_or_else(|| match tcx.hir().get(id) {\n+                    Node::AnonConst(_) => match tcx.hir().get(tcx.hir().get_parent_node(id)) {\n+                        Node::Expr(&hir::Expr {\n+                            kind: hir::ExprKind::ConstBlock(ref anon_const),\n+                            ..\n+                        }) if anon_const.hir_id == id => fcx.next_ty_var(TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span,\n+                        }),\n+                        _ => fallback(),\n+                    },\n+                    _ => fallback(),\n+                });\n+\n             let expected_type = fcx.normalize_associated_types_in(body.value.span, &expected_type);\n             fcx.require_type_is_sized(expected_type, body.value.span, traits::ConstSized);\n \n@@ -850,7 +864,8 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        match predicate.skip_binders() {\n+        let bound_predicate = predicate.bound_atom();\n+        match bound_predicate.skip_binder() {\n             ty::PredicateAtom::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n@@ -861,7 +876,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                 }\n             }\n             ty::PredicateAtom::Projection(projection_pred) => {\n-                projections.push(ty::Binder::bind(projection_pred));\n+                projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}\n         }"}, {"sha": "02268b11a7a8eb21a2428f67577be5041241c916", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -302,7 +302,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 true,\n                             ),\n                             hir::BinOpKind::Mul => (\n-                                format!(\"cannot multiply `{}` to `{}`\", rhs_ty, lhs_ty),\n+                                format!(\"cannot multiply `{}` by `{}`\", lhs_ty, rhs_ty),\n                                 Some(\"std::ops::Mul\"),\n                                 true,\n                             ),"}, {"sha": "b2009962aba2ec9b00d97300f22115b203d6214f", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -110,7 +110,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                             )\n                             .note(\n                                 \"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which is it implemented is local, \\\n+                                    least one of the types for which it is implemented is local, \\\n                                     and no uncovered type parameters appear before that first \\\n                                     local type\",\n                             )\n@@ -135,7 +135,7 @@ impl ItemLikeVisitor<'v> for OrphanChecker<'tcx> {\n                                 local type\",\n                                 param_ty,\n                             )).note(\"implementing a foreign trait is only possible if at \\\n-                                    least one of the types for which is it implemented is local\"\n+                                    least one of the types for which it is implemented is local\"\n                             ).note(\"only traits defined in the current crate can be \\\n                                     implemented for a type parameter\"\n                             ).emit();"}, {"sha": "b30fb7be273f1fa2754db798ebb0d744ecfde337", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -40,7 +40,7 @@ use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::subst::InternalSubsts;\n use rustc_middle::ty::util::Discr;\n use rustc_middle::ty::util::IntTypeExt;\n-use rustc_middle::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc_middle::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_session::config::SanitizerSet;\n use rustc_session::lint;\n@@ -851,7 +851,6 @@ fn convert_variant(\n     parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()\n         .iter()\n@@ -868,11 +867,7 @@ fn convert_variant(\n                 seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }\n \n-            ty::FieldDef {\n-                did: fid.to_def_id(),\n-                ident: f.ident,\n-                vis: ty::Visibility::from_hir(&f.vis, hir_id, tcx),\n-            }\n+            ty::FieldDef { did: fid.to_def_id(), ident: f.ident, vis: tcx.visibility(fid) }\n         })\n         .collect();\n     let recovered = match def {\n@@ -2791,6 +2786,14 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n         }\n     });\n \n+    // #73631: closures inherit `#[target_feature]` annotations\n+    if tcx.features().target_feature_11 && tcx.is_closure(id) {\n+        let owner_id = tcx.parent(id).expect(\"closure should have a parent\");\n+        codegen_fn_attrs\n+            .target_features\n+            .extend(tcx.codegen_fn_attrs(owner_id).target_features.iter().copied())\n+    }\n+\n     // If a function uses #[target_feature] it can't be inlined into general\n     // purpose functions as they wouldn't have the right target features\n     // enabled. For that reason we also forbid #[inline(always)] as it can't be"}, {"sha": "a754d4dbac7134ea4bf0176a1e735b50a664bc85", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -112,12 +112,16 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                         tcx.sess.delay_span_bug(tcx.def_span(def_id), \"anon const with Res::Err\");\n                         return None;\n                     }\n-                    _ => span_bug!(\n-                        DUMMY_SP,\n-                        \"unexpected anon const res {:?} in path: {:?}\",\n-                        res,\n-                        path,\n-                    ),\n+                    _ => {\n+                        // If the user tries to specify generics on a type that does not take them,\n+                        // e.g. `usize<T>`, we may hit this branch, in which case we treat it as if\n+                        // no arguments have been passed. An error should already have been emitted.\n+                        tcx.sess.delay_span_bug(\n+                            tcx.def_span(def_id),\n+                            &format!(\"unexpected anon const res {:?} in path: {:?}\", res, path),\n+                        );\n+                        return None;\n+                    }\n                 };\n \n                 generics\n@@ -309,6 +313,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     tcx.types.usize\n                 }\n \n+                Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+                    if anon_const.hir_id == hir_id =>\n+                {\n+                    tcx.typeck(def_id).node_type(anon_const.hir_id)\n+                }\n+\n                 Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n                     .adt_def(tcx.hir().get_parent_did(hir_id).to_def_id())\n                     .repr"}, {"sha": "471909a092f7b0243709a716f6e373a720255991", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -258,7 +258,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_exprs(&ia.inputs_exprs);\n             }\n \n-            hir::ExprKind::Continue(..) | hir::ExprKind::Lit(..) | hir::ExprKind::Err => {}\n+            hir::ExprKind::Continue(..)\n+            | hir::ExprKind::Lit(..)\n+            | hir::ExprKind::ConstBlock(..)\n+            | hir::ExprKind::Err => {}\n \n             hir::ExprKind::Loop(ref blk, _, _) => {\n                 self.walk_block(blk);"}, {"sha": "c1fa39e96eb95656761c724c11dc641f5a684de0", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -317,7 +317,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n                 }\n             }\n \n-            let se_ty = tcx.mk_fn_ptr(ty::Binder::bind(tcx.mk_fn_sig(\n+            let se_ty = tcx.mk_fn_ptr(ty::Binder::dummy(tcx.mk_fn_sig(\n                 [tcx.types.isize, tcx.mk_imm_ptr(tcx.mk_imm_ptr(tcx.types.u8))].iter().cloned(),\n                 tcx.types.isize,\n                 false,"}, {"sha": "f6ac7aa9155fec3710df3008e2a71736a9ef45ea", "filename": "compiler/rustc_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fmem_categorization.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -370,6 +370,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             | hir::ExprKind::Loop(..)\n             | hir::ExprKind::Match(..)\n             | hir::ExprKind::Lit(..)\n+            | hir::ExprKind::ConstBlock(..)\n             | hir::ExprKind::Break(..)\n             | hir::ExprKind::Continue(..)\n             | hir::ExprKind::Struct(..)"}, {"sha": "1565efbb022f4bc03d3058bf0faa25391903e74b", "filename": "compiler/rustc_typeck/src/variance/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -4,7 +4,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/variance.html\n \n use hir::Node;\n-use rustc_arena::TypedArena;\n+use rustc_arena::DroplessArena;\n use rustc_hir as hir;\n use rustc_hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc_middle::ty::query::Providers;\n@@ -32,8 +32,8 @@ pub fn provide(providers: &mut Providers) {\n \n fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateVariancesMap<'_> {\n     assert_eq!(crate_num, LOCAL_CRATE);\n-    let mut arena = TypedArena::default();\n-    let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &mut arena);\n+    let arena = DroplessArena::default();\n+    let terms_cx = terms::determine_parameters_to_be_inferred(tcx, &arena);\n     let constraints_cx = constraints::add_constraints_from_crate(terms_cx);\n     solve::solve_constraints(constraints_cx)\n }"}, {"sha": "81c858c53cb8e4035a2a8143882fd7e231e91809", "filename": "compiler/rustc_typeck/src/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fvariance%2Fterms.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -9,7 +9,7 @@\n // `InferredIndex` is a newtype'd int representing the index of such\n // a variable.\n \n-use rustc_arena::TypedArena;\n+use rustc_arena::DroplessArena;\n use rustc_hir as hir;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::HirIdMap;\n@@ -47,7 +47,7 @@ impl<'a> fmt::Debug for VarianceTerm<'a> {\n \n pub struct TermsContext<'a, 'tcx> {\n     pub tcx: TyCtxt<'tcx>,\n-    pub arena: &'a TypedArena<VarianceTerm<'a>>,\n+    pub arena: &'a DroplessArena,\n \n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n@@ -64,7 +64,7 @@ pub struct TermsContext<'a, 'tcx> {\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    arena: &'a mut TypedArena<VarianceTerm<'a>>,\n+    arena: &'a DroplessArena,\n ) -> TermsContext<'a, 'tcx> {\n     let mut terms_cx = TermsContext {\n         tcx,"}, {"sha": "0a4f88dedbb07ad4220c6f0620042f7eb5b309a7", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -383,7 +383,7 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     unsafe { oom_impl(layout) }\n }\n \n-#[cfg(not(any(test, bootstrap)))]\n+#[cfg(not(any(target_os = \"hermit\", test, bootstrap)))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]"}, {"sha": "4f9aa44b6b510b78d7dbc9ebaf5f0a998d3f7a1b", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 10, "deletions": 690, "changes": 700, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -9,12 +9,17 @@ use core::ops::{Index, RangeBounds};\n use core::ptr;\n \n use super::borrow::DormantMutRef;\n-use super::node::{self, marker, ForceResult::*, Handle, InsertResult::*, NodeRef};\n+use super::node::{self, marker, ForceResult::*, Handle, NodeRef};\n use super::search::{self, SearchResult::*};\n use super::unwrap_unchecked;\n \n+mod entry;\n+pub use entry::{Entry, OccupiedEntry, VacantEntry};\n use Entry::*;\n-use UnderflowResult::*;\n+\n+/// Minimum number of elements in nodes that are not a root.\n+/// We might temporarily have fewer elements during methods.\n+pub(super) const MIN_LEN: usize = node::MIN_LEN_AFTER_SPLIT;\n \n /// A map based on a B-Tree.\n ///\n@@ -452,69 +457,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n     }\n }\n \n-/// A view into a single entry in a map, which may either be vacant or occupied.\n-///\n-/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n-///\n-/// [`entry`]: BTreeMap::entry\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub enum Entry<'a, K: 'a, V: 'a> {\n-    /// A vacant entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n-\n-    /// An occupied entry.\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n-            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n-        }\n-    }\n-}\n-\n-/// A view into a vacant entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct VacantEntry<'a, K: 'a, V: 'a> {\n-    key: K,\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n-    }\n-}\n-\n-/// A view into an occupied entry in a `BTreeMap`.\n-/// It is part of the [`Entry`] enum.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n-    handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n-    dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n-\n-    // Be invariant in `K` and `V`\n-    _marker: PhantomData<&'a mut (K, V)>,\n-}\n-\n-#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n-impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n-    }\n-}\n-\n // An iterator for merging two sorted sequences into one\n struct MergeIter<K, V, I: Iterator<Item = (K, V)>> {\n     left: Peekable<I>,\n@@ -1156,13 +1098,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             // Check if right-most child is underfull.\n             let mut last_edge = internal.last_edge();\n             let right_child_len = last_edge.reborrow().descend().len();\n-            if right_child_len < node::MIN_LEN {\n+            if right_child_len < MIN_LEN {\n                 // We need to steal.\n                 let mut last_kv = match last_edge.left_kv() {\n                     Ok(left) => left,\n                     Err(_) => unreachable!(),\n                 };\n-                last_kv.bulk_steal_left(node::MIN_LEN - right_child_len);\n+                last_kv.bulk_steal_left(MIN_LEN - right_child_len);\n                 last_edge = last_kv.right_edge();\n             }\n \n@@ -1214,40 +1156,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n \n         let mut right = Self::new();\n         let right_root = Self::ensure_is_owned(&mut right.root);\n-        for _ in 0..left_root.height() {\n-            right_root.push_internal_level();\n-        }\n \n-        {\n-            let mut left_node = left_root.node_as_mut();\n-            let mut right_node = right_root.node_as_mut();\n-\n-            loop {\n-                let mut split_edge = match search::search_node(left_node, key) {\n-                    // key is going to the right tree\n-                    Found(handle) => handle.left_edge(),\n-                    GoDown(handle) => handle,\n-                };\n-\n-                split_edge.move_suffix(&mut right_node);\n-\n-                match (split_edge.force(), right_node.force()) {\n-                    (Internal(edge), Internal(node)) => {\n-                        left_node = edge.descend();\n-                        right_node = node.first_edge().descend();\n-                    }\n-                    (Leaf(_), Leaf(_)) => {\n-                        break;\n-                    }\n-                    _ => {\n-                        unreachable!();\n-                    }\n-                }\n-            }\n-        }\n-\n-        left_root.fix_right_border();\n-        right_root.fix_left_border();\n+        left_root.split_off(right_root, key);\n \n         if left_root.height() < right_root.height() {\n             self.length = left_root.node_as_ref().calc_length();\n@@ -2310,596 +2220,6 @@ impl<K, V> BTreeMap<K, V> {\n     }\n }\n \n-impl<'a, K: Ord, V> Entry<'a, K, V> {\n-    /// Ensures a value is in the entry by inserting the default if empty, and returns\n-    /// a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert(self, default: V) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default),\n-        }\n-    }\n-\n-    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n-    /// let s = \"hoho\".to_string();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with(|| s);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(default()),\n-        }\n-    }\n-\n-    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n-    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n-    /// which takes the key as its argument, and returns a mutable reference to the value in the\n-    /// entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(or_insert_with_key)]\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 9);\n-    /// ```\n-    #[inline]\n-    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => {\n-                let value = default(entry.key());\n-                entry.insert(value)\n-            }\n-        }\n-    }\n-\n-    /// Returns a reference to this entry's key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        match *self {\n-            Occupied(ref entry) => entry.key(),\n-            Vacant(ref entry) => entry.key(),\n-        }\n-    }\n-\n-    /// Provides in-place mutable access to an occupied entry before any\n-    /// potential inserts into the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 42);\n-    ///\n-    /// map.entry(\"poneyland\")\n-    ///    .and_modify(|e| { *e += 1 })\n-    ///    .or_insert(42);\n-    /// assert_eq!(map[\"poneyland\"], 43);\n-    /// ```\n-    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n-    pub fn and_modify<F>(self, f: F) -> Self\n-    where\n-        F: FnOnce(&mut V),\n-    {\n-        match self {\n-            Occupied(mut entry) => {\n-                f(entry.get_mut());\n-                Occupied(entry)\n-            }\n-            Vacant(entry) => Vacant(entry),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n-    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n-    /// Ensures a value is in the entry by inserting the default value if empty,\n-    /// and returns a mutable reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_default();\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], None);\n-    /// ```\n-    pub fn or_default(self) -> &'a mut V {\n-        match self {\n-            Occupied(entry) => entry.into_mut(),\n-            Vacant(entry) => entry.insert(Default::default()),\n-        }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n-    /// Gets a reference to the key that would be used when inserting a value\n-    /// through the VacantEntry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        &self.key\n-    }\n-\n-    /// Take ownership of the key.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n-    ///     v.into_key();\n-    /// }\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn into_key(self) -> K {\n-        self.key\n-    }\n-\n-    /// Sets the value of the entry with the `VacantEntry`'s key,\n-    /// and returns a mutable reference to it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n-    ///\n-    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n-    ///     o.insert(37);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 37);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(self, value: V) -> &'a mut V {\n-        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n-            (Fit(_), val_ptr) => {\n-                // Safety: We have consumed self.handle and the handle returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                map.length += 1;\n-                val_ptr\n-            }\n-            (Split(ins), val_ptr) => {\n-                drop(ins.left);\n-                // Safety: We have consumed self.handle and the reference returned.\n-                let map = unsafe { self.dormant_map.awaken() };\n-                let root = map.root.as_mut().unwrap();\n-                root.push_internal_level().push(ins.k, ins.v, ins.right);\n-                map.length += 1;\n-                val_ptr\n-            }\n-        };\n-        // Now that we have finished growing the tree using borrowed references,\n-        // dereference the pointer to a part of it, that we picked up along the way.\n-        unsafe { &mut *out_ptr }\n-    }\n-}\n-\n-impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n-    /// Gets a reference to the key in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n-    /// ```\n-    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n-    pub fn key(&self) -> &K {\n-        self.handle.reborrow().into_kv().0\n-    }\n-\n-    /// Take ownership of the key and value from the map.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     // We delete the entry from the map.\n-    ///     o.remove_entry();\n-    /// }\n-    ///\n-    /// // If now try to get the value, it will panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n-    pub fn remove_entry(self) -> (K, V) {\n-        self.remove_kv()\n-    }\n-\n-    /// Gets a reference to the value in the entry.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.get(), &12);\n-    /// }\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> &V {\n-        self.handle.reborrow().into_kv().1\n-    }\n-\n-    /// Gets a mutable reference to the value in the entry.\n-    ///\n-    /// If you need a reference to the `OccupiedEntry` that may outlive the\n-    /// destruction of the `Entry` value, see [`into_mut`].\n-    ///\n-    /// [`into_mut`]: OccupiedEntry::into_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     *o.get_mut() += 10;\n-    ///     assert_eq!(*o.get(), 22);\n-    ///\n-    ///     // We can use the same Entry multiple times.\n-    ///     *o.get_mut() += 2;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 24);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get_mut(&mut self) -> &mut V {\n-        self.handle.kv_mut().1\n-    }\n-\n-    /// Converts the entry into a mutable reference to its value.\n-    ///\n-    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n-    ///\n-    /// [`get_mut`]: OccupiedEntry::get_mut\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// assert_eq!(map[\"poneyland\"], 12);\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     *o.into_mut() += 10;\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 22);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn into_mut(self) -> &'a mut V {\n-        self.handle.into_val_mut()\n-    }\n-\n-    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n-    /// and returns the entry's old value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.insert(15), 12);\n-    /// }\n-    /// assert_eq!(map[\"poneyland\"], 15);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: V) -> V {\n-        mem::replace(self.get_mut(), value)\n-    }\n-\n-    /// Takes the value of the entry out of the map, and returns it.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::collections::BTreeMap;\n-    /// use std::collections::btree_map::Entry;\n-    ///\n-    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n-    /// map.entry(\"poneyland\").or_insert(12);\n-    ///\n-    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n-    ///     assert_eq!(o.remove(), 12);\n-    /// }\n-    /// // If we try to get \"poneyland\"'s value, it'll panic:\n-    /// // println!(\"{}\", map[\"poneyland\"]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn remove(self) -> V {\n-        self.remove_kv().1\n-    }\n-\n-    // Body of `remove_entry`, separate to keep the above implementations short.\n-    fn remove_kv(self) -> (K, V) {\n-        let mut emptied_internal_root = false;\n-        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n-        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n-        let map = unsafe { self.dormant_map.awaken() };\n-        map.length -= 1;\n-        if emptied_internal_root {\n-            let root = map.root.as_mut().unwrap();\n-            root.pop_internal_level();\n-        }\n-        old_kv\n-    }\n-}\n-\n-impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the map, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair.\n-    fn remove_kv_tracking<F: FnOnce()>(\n-        self,\n-        handle_emptied_internal_root: F,\n-    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n-        let (old_kv, mut pos, was_internal) = match self.force() {\n-            Leaf(leaf) => {\n-                let (old_kv, pos) = leaf.remove();\n-                (old_kv, pos, false)\n-            }\n-            Internal(mut internal) => {\n-                // Replace the location freed in the internal node with an\n-                // adjacent KV, and remove that adjacent KV from its leaf.\n-                // Always choose the adjacent KV on the left side because\n-                // it is typically faster to pop an element from the end\n-                // of the KV arrays without needing to shift other elements.\n-\n-                let key_loc = internal.kv_mut().0 as *mut K;\n-                let val_loc = internal.kv_mut().1 as *mut V;\n-\n-                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n-                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n-\n-                let (kv, pos) = to_remove.remove();\n-\n-                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n-\n-                ((old_key, old_val), pos, true)\n-            }\n-        };\n-\n-        // Handle underflow\n-        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n-        let mut at_leaf = true;\n-        while cur_node.len() < node::MIN_LEN {\n-            match handle_underfull_node(cur_node) {\n-                AtRoot => break,\n-                Merged(edge, merged_with_left, offset) => {\n-                    // If we merged with our right sibling then our tracked\n-                    // position has not changed. However if we merged with our\n-                    // left sibling then our tracked position is now dangling.\n-                    if at_leaf && merged_with_left {\n-                        let idx = pos.idx() + offset;\n-                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n-                            Leaf(leaf) => leaf,\n-                            Internal(_) => unreachable!(),\n-                        };\n-                        pos = unsafe { Handle::new_edge(node, idx) };\n-                    }\n-\n-                    let parent = edge.into_node();\n-                    if parent.len() == 0 {\n-                        // The parent that was just emptied must be the root,\n-                        // because nodes on a lower level would not have been\n-                        // left with a single child.\n-                        handle_emptied_internal_root();\n-                        break;\n-                    } else {\n-                        cur_node = parent.forget_type();\n-                        at_leaf = false;\n-                    }\n-                }\n-                Stole(stole_from_left) => {\n-                    // Adjust the tracked position if we stole from a left sibling\n-                    if stole_from_left && at_leaf {\n-                        // SAFETY: This is safe since we just added an element to our node.\n-                        unsafe {\n-                            pos.move_next_unchecked();\n-                        }\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-\n-        // If we deleted from an internal node then we need to compensate for\n-        // the earlier swap and adjust the tracked position to point to the\n-        // next element.\n-        if was_internal {\n-            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n-        }\n-\n-        (old_kv, pos)\n-    }\n-}\n-\n-impl<K, V> node::Root<K, V> {\n-    /// Removes empty levels on the top, but keep an empty leaf if the entire tree is empty.\n-    fn fix_top(&mut self) {\n-        while self.height() > 0 && self.node_as_ref().len() == 0 {\n-            self.pop_internal_level();\n-        }\n-    }\n-\n-    fn fix_right_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.node_as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut last_kv = node.last_kv();\n-\n-                if last_kv.can_merge() {\n-                    cur_node = last_kv.merge().descend();\n-                } else {\n-                    let right_len = last_kv.reborrow().right_edge().descend().len();\n-                    // `MINLEN + 1` to avoid readjust if merge happens on the next level.\n-                    if right_len < node::MIN_LEN + 1 {\n-                        last_kv.bulk_steal_left(node::MIN_LEN + 1 - right_len);\n-                    }\n-                    cur_node = last_kv.right_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-\n-    /// The symmetric clone of `fix_right_border`.\n-    fn fix_left_border(&mut self) {\n-        self.fix_top();\n-\n-        {\n-            let mut cur_node = self.node_as_mut();\n-\n-            while let Internal(node) = cur_node.force() {\n-                let mut first_kv = node.first_kv();\n-\n-                if first_kv.can_merge() {\n-                    cur_node = first_kv.merge().descend();\n-                } else {\n-                    let left_len = first_kv.reborrow().left_edge().descend().len();\n-                    if left_len < node::MIN_LEN + 1 {\n-                        first_kv.bulk_steal_right(node::MIN_LEN + 1 - left_len);\n-                    }\n-                    cur_node = first_kv.left_edge().descend();\n-                }\n-            }\n-        }\n-\n-        self.fix_top();\n-    }\n-}\n-\n-enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n-    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n-    Stole(bool),\n-}\n-\n-fn handle_underfull_node<'a, K: 'a, V: 'a>(\n-    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n-) -> UnderflowResult<'_, K, V> {\n-    let parent = match node.ascend() {\n-        Ok(parent) => parent,\n-        Err(_) => return AtRoot,\n-    };\n-\n-    // Prefer the left KV if it exists. Merging with the left side is faster,\n-    // since merging happens towards the left and `node` has fewer elements.\n-    // Stealing from the left side is faster, since we can pop from the end of\n-    // the KV arrays.\n-    let (is_left, mut handle) = match parent.left_kv() {\n-        Ok(left) => (true, left),\n-        Err(parent) => {\n-            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n-            (false, right)\n-        }\n-    };\n-\n-    if handle.can_merge() {\n-        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n-        Merged(handle.merge(), is_left, offset)\n-    } else {\n-        if is_left {\n-            handle.steal_left();\n-        } else {\n-            handle.steal_right();\n-        }\n-        Stole(is_left)\n-    }\n-}\n-\n impl<K: Ord, V, I: Iterator<Item = (K, V)>> Iterator for MergeIter<K, V, I> {\n     type Item = (K, V);\n "}, {"sha": "73a0ca21f6733f919d3ac12beae88d3c82caa19a", "filename": "library/alloc/src/collections/btree/map/entry.rs", "status": "added", "additions": 475, "deletions": 0, "changes": 475, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Fentry.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -0,0 +1,475 @@\n+use core::fmt::{self, Debug};\n+use core::marker::PhantomData;\n+use core::mem;\n+\n+use super::super::borrow::DormantMutRef;\n+use super::super::node::{marker, Handle, InsertResult::*, NodeRef};\n+use super::BTreeMap;\n+\n+use Entry::*;\n+\n+/// A view into a single entry in a map, which may either be vacant or occupied.\n+///\n+/// This `enum` is constructed from the [`entry`] method on [`BTreeMap`].\n+///\n+/// [`entry`]: BTreeMap::entry\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub enum Entry<'a, K: 'a, V: 'a> {\n+    /// A vacant entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Vacant(#[stable(feature = \"rust1\", since = \"1.0.0\")] VacantEntry<'a, K, V>),\n+\n+    /// An occupied entry.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    Occupied(#[stable(feature = \"rust1\", since = \"1.0.0\")] OccupiedEntry<'a, K, V>),\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            Vacant(ref v) => f.debug_tuple(\"Entry\").field(v).finish(),\n+            Occupied(ref o) => f.debug_tuple(\"Entry\").field(o).finish(),\n+        }\n+    }\n+}\n+\n+/// A view into a vacant entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    pub(super) key: K,\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"VacantEntry\").field(self.key()).finish()\n+    }\n+}\n+\n+/// A view into an occupied entry in a `BTreeMap`.\n+/// It is part of the [`Entry`] enum.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n+    pub(super) handle: Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>,\n+    pub(super) dormant_map: DormantMutRef<'a, BTreeMap<K, V>>,\n+\n+    // Be invariant in `K` and `V`\n+    pub(super) _marker: PhantomData<&'a mut (K, V)>,\n+}\n+\n+#[stable(feature = \"debug_btree_map\", since = \"1.12.0\")]\n+impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"OccupiedEntry\").field(\"key\", self.key()).field(\"value\", self.get()).finish()\n+    }\n+}\n+\n+impl<'a, K: Ord, V> Entry<'a, K, V> {\n+    /// Ensures a value is in the entry by inserting the default if empty, and returns\n+    /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert(self, default: V) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default),\n+        }\n+    }\n+\n+    /// Ensures a value is in the entry by inserting the result of the default function if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, String> = BTreeMap::new();\n+    /// let s = \"hoho\".to_string();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_string());\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(default()),\n+        }\n+    }\n+\n+    #[unstable(feature = \"or_insert_with_key\", issue = \"71024\")]\n+    /// Ensures a value is in the entry by inserting, if empty, the result of the default function,\n+    /// which takes the key as its argument, and returns a mutable reference to the value in the\n+    /// entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(or_insert_with_key)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with_key(|key| key.chars().count());\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 9);\n+    /// ```\n+    #[inline]\n+    pub fn or_insert_with_key<F: FnOnce(&K) -> V>(self, default: F) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => {\n+                let value = default(entry.key());\n+                entry.insert(value)\n+            }\n+        }\n+    }\n+\n+    /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        match *self {\n+            Occupied(ref entry) => entry.key(),\n+            Vacant(ref entry) => entry.key(),\n+        }\n+    }\n+\n+    /// Provides in-place mutable access to an occupied entry before any\n+    /// potential inserts into the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 42);\n+    ///\n+    /// map.entry(\"poneyland\")\n+    ///    .and_modify(|e| { *e += 1 })\n+    ///    .or_insert(42);\n+    /// assert_eq!(map[\"poneyland\"], 43);\n+    /// ```\n+    #[stable(feature = \"entry_and_modify\", since = \"1.26.0\")]\n+    pub fn and_modify<F>(self, f: F) -> Self\n+    where\n+        F: FnOnce(&mut V),\n+    {\n+        match self {\n+            Occupied(mut entry) => {\n+                f(entry.get_mut());\n+                Occupied(entry)\n+            }\n+            Vacant(entry) => Vacant(entry),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V: Default> Entry<'a, K, V> {\n+    #[stable(feature = \"entry_or_default\", since = \"1.28.0\")]\n+    /// Ensures a value is in the entry by inserting the default value if empty,\n+    /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, Option<usize>> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_default();\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], None);\n+    /// ```\n+    pub fn or_default(self) -> &'a mut V {\n+        match self {\n+            Occupied(entry) => entry.into_mut(),\n+            Vacant(entry) => entry.insert(Default::default()),\n+        }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> VacantEntry<'a, K, V> {\n+    /// Gets a reference to the key that would be used when inserting a value\n+    /// through the VacantEntry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        &self.key\n+    }\n+\n+    /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn into_key(self) -> K {\n+        self.key\n+    }\n+\n+    /// Sets the value of the entry with the `VacantEntry`'s key,\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, u32> = BTreeMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(self, value: V) -> &'a mut V {\n+        let out_ptr = match self.handle.insert_recursing(self.key, value) {\n+            (Fit(_), val_ptr) => {\n+                // Safety: We have consumed self.handle and the handle returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                map.length += 1;\n+                val_ptr\n+            }\n+            (Split(ins), val_ptr) => {\n+                drop(ins.left);\n+                // Safety: We have consumed self.handle and the reference returned.\n+                let map = unsafe { self.dormant_map.awaken() };\n+                let root = map.root.as_mut().unwrap();\n+                root.push_internal_level().push(ins.k, ins.v, ins.right);\n+                map.length += 1;\n+                val_ptr\n+            }\n+        };\n+        // Now that we have finished growing the tree using borrowed references,\n+        // dereference the pointer to a part of it, that we picked up along the way.\n+        unsafe { &mut *out_ptr }\n+    }\n+}\n+\n+impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n+    /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n+    #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n+    pub fn key(&self) -> &K {\n+        self.handle.reborrow().into_kv().0\n+    }\n+\n+    /// Take ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_entry();\n+    /// }\n+    ///\n+    /// // If now try to get the value, it will panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n+    pub fn remove_entry(self) -> (K, V) {\n+        self.remove_kv()\n+    }\n+\n+    /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get(&self) -> &V {\n+        self.handle.reborrow().into_kv().1\n+    }\n+\n+    /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// If you need a reference to the `OccupiedEntry` that may outlive the\n+    /// destruction of the `Entry` value, see [`into_mut`].\n+    ///\n+    /// [`into_mut`]: OccupiedEntry::into_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     *o.get_mut() += 10;\n+    ///     assert_eq!(*o.get(), 22);\n+    ///\n+    ///     // We can use the same Entry multiple times.\n+    ///     *o.get_mut() += 2;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 24);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn get_mut(&mut self) -> &mut V {\n+        self.handle.kv_mut().1\n+    }\n+\n+    /// Converts the entry into a mutable reference to its value.\n+    ///\n+    /// If you need multiple references to the `OccupiedEntry`, see [`get_mut`].\n+    ///\n+    /// [`get_mut`]: OccupiedEntry::get_mut\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn into_mut(self) -> &'a mut V {\n+        self.handle.into_val_mut()\n+    }\n+\n+    /// Sets the value of the entry with the `OccupiedEntry`'s key,\n+    /// and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn insert(&mut self, value: V) -> V {\n+        mem::replace(self.get_mut(), value)\n+    }\n+\n+    /// Takes the value of the entry out of the map, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::BTreeMap;\n+    /// use std::collections::btree_map::Entry;\n+    ///\n+    /// let mut map: BTreeMap<&str, usize> = BTreeMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    /// // If we try to get \"poneyland\"'s value, it'll panic:\n+    /// // println!(\"{}\", map[\"poneyland\"]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn remove(self) -> V {\n+        self.remove_kv().1\n+    }\n+\n+    // Body of `remove_entry`, separate to keep the above implementations short.\n+    pub(super) fn remove_kv(self) -> (K, V) {\n+        let mut emptied_internal_root = false;\n+        let (old_kv, _) = self.handle.remove_kv_tracking(|| emptied_internal_root = true);\n+        // SAFETY: we consumed the intermediate root borrow, `self.handle`.\n+        let map = unsafe { self.dormant_map.awaken() };\n+        map.length -= 1;\n+        if emptied_internal_root {\n+            let root = map.root.as_mut().unwrap();\n+            root.pop_internal_level();\n+        }\n+        old_kv\n+    }\n+}"}, {"sha": "adb94972f5bb63de616f644fe79aaac7d564d2dd", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 24, "deletions": 76, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,4 +1,4 @@\n-use super::super::{navigate::Position, node, DeterministicRng};\n+use super::super::{node, DeterministicRng};\n use super::Entry::{Occupied, Vacant};\n use super::*;\n use crate::boxed::Box;\n@@ -7,7 +7,7 @@ use crate::rc::Rc;\n use crate::string::{String, ToString};\n use crate::vec::Vec;\n use std::convert::TryFrom;\n-use std::iter::FromIterator;\n+use std::iter::{self, FromIterator};\n use std::mem;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n@@ -42,19 +42,6 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n     }\n }\n \n-struct SeriesChecker<T> {\n-    previous: Option<T>,\n-}\n-\n-impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n-    fn is_ascending(&mut self, next: T) {\n-        if let Some(previous) = self.previous {\n-            assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n-        }\n-        self.previous = Some(next);\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     /// Panics if the map (or the code navigating it) is corrupted.\n     fn check(&self)\n@@ -63,44 +50,15 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n     {\n         if let Some(root) = &self.root {\n             let root_node = root.node_as_ref();\n-            let mut checker = SeriesChecker { previous: None };\n-            let mut internal_length = 0;\n-            let mut internal_kv_count = 0;\n-            let mut leaf_length = 0;\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(node) => {\n-                    let is_root = root_node.height() == 0;\n-                    let min_len = if is_root { 0 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n-\n-                    for idx in 0..node.len() {\n-                        let key = *unsafe { node.key_at(idx) };\n-                        checker.is_ascending(key);\n-                    }\n-                    leaf_length += node.len();\n-                }\n-                Position::Internal(node) => {\n-                    let is_root = root_node.height() == node.height();\n-                    let min_len = if is_root { 1 } else { node::MIN_LEN };\n-                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n \n-                    for idx in 0..=node.len() {\n-                        let edge = unsafe { node::Handle::new_edge(node, idx) };\n-                        assert!(edge.descend().ascend().ok().unwrap() == edge);\n-                    }\n+            assert!(root_node.ascend().is_err());\n+            root_node.assert_back_pointers();\n \n-                    internal_length += node.len();\n-                }\n-                Position::InternalKV(kv) => {\n-                    let key = *kv.into_kv().0;\n-                    checker.is_ascending(key);\n+            let counted = root_node.assert_ascending();\n+            assert_eq!(self.length, counted);\n+            assert_eq!(self.length, root_node.calc_length());\n \n-                    internal_kv_count += 1;\n-                }\n-            });\n-            assert_eq!(internal_length, internal_kv_count);\n-            assert_eq!(root_node.calc_length(), internal_length + leaf_length);\n-            assert_eq!(self.length, internal_length + leaf_length);\n+            root_node.assert_min_len(if root_node.height() > 0 { 1 } else { 0 });\n         } else {\n             assert_eq!(self.length, 0);\n         }\n@@ -116,34 +74,25 @@ impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n         K: Debug,\n     {\n         if let Some(root) = self.root.as_ref() {\n-            let mut result = String::new();\n-            let root_node = root.node_as_ref();\n-            root_node.visit_nodes_in_order(|pos| match pos {\n-                Position::Leaf(leaf) => {\n-                    let depth = root_node.height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}\", indent);\n-                    for idx in 0..leaf.len() {\n-                        if idx > 0 {\n-                            result += \", \";\n-                        }\n-                        result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n-                    }\n-                }\n-                Position::Internal(_) => {}\n-                Position::InternalKV(kv) => {\n-                    let depth = root_node.height() - kv.into_node().height();\n-                    let indent = \"  \".repeat(depth);\n-                    result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n-                }\n-            });\n-            result\n+            root.node_as_ref().dump_keys()\n         } else {\n             String::from(\"not yet allocated\")\n         }\n     }\n }\n \n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    pub fn assert_min_len(self, min_len: usize) {\n+        assert!(self.len() >= min_len, \"{} < {}\", self.len(), min_len);\n+        if let node::ForceResult::Internal(node) = self.force() {\n+            for idx in 0..=node.len() {\n+                let edge = unsafe { Handle::new_edge(node, idx) };\n+                edge.descend().assert_min_len(MIN_LEN);\n+            }\n+        }\n+    }\n+}\n+\n // Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n // implementation of insertion, but it's best to be aware of when it does.\n #[test]\n@@ -170,7 +119,6 @@ fn test_levels() {\n         let last_key = *map.last_key_value().unwrap().0;\n         map.insert(last_key + 1, ());\n     }\n-    println!(\"{}\", map.dump_keys());\n     map.check();\n     // Structure:\n     // - 1 element in internal root node with 2 children\n@@ -372,7 +320,7 @@ fn test_iter_rev() {\n fn do_test_iter_mut_mutation<T>(size: usize)\n where\n     T: Copy + Debug + Ord + TryFrom<usize>,\n-    <T as std::convert::TryFrom<usize>>::Error: std::fmt::Debug,\n+    <T as TryFrom<usize>>::Error: Debug,\n {\n     let zero = T::try_from(0).unwrap();\n     let mut map: BTreeMap<T, T> = (0..size).map(|i| (T::try_from(i).unwrap(), zero)).collect();\n@@ -857,7 +805,7 @@ mod test_drain_filter {\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n-        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+        assert!(map.drain_filter(|_, _| false).eq(iter::empty()));\n         map.check();\n     }\n \n@@ -878,7 +826,7 @@ mod test_drain_filter {\n                 *v += 6;\n                 false\n             })\n-            .eq(std::iter::empty())\n+            .eq(iter::empty())\n         );\n         assert!(map.keys().copied().eq(0..3));\n         assert!(map.values().copied().eq(6..9));"}, {"sha": "bcc50ed56158710cbff6af424d33d0eecef3639f", "filename": "library/alloc/src/collections/btree/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -2,8 +2,10 @@ mod borrow;\n pub mod map;\n mod navigate;\n mod node;\n+mod remove;\n mod search;\n pub mod set;\n+mod split;\n \n #[doc(hidden)]\n trait Recover<Q: ?Sized> {"}, {"sha": "c8d3de9e5cd5c70715965a43545bef53dac1d1e4", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 40, "deletions": 54, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -38,8 +38,8 @@ use crate::alloc::{AllocRef, Global, Layout};\n use crate::boxed::Box;\n \n const B: usize = 6;\n-pub const MIN_LEN: usize = B - 1;\n pub const CAPACITY: usize = 2 * B - 1;\n+pub const MIN_LEN_AFTER_SPLIT: usize = B - 1;\n const KV_IDX_CENTER: usize = B - 1;\n const EDGE_IDX_LEFT_OF_CENTER: usize = B - 1;\n const EDGE_IDX_RIGHT_OF_CENTER: usize = B;\n@@ -87,7 +87,6 @@ impl<K, V> LeafNode<K, V> {\n #[repr(C)]\n // gdb_providers.py uses this type name for introspection.\n struct InternalNode<K, V> {\n-    // gdb_providers.py uses this field name for introspection.\n     data: LeafNode<K, V>,\n \n     /// The pointers to the children of this node. `len + 1` of these are considered\n@@ -128,10 +127,6 @@ impl<K, V> BoxedNode<K, V> {\n         BoxedNode { ptr: Unique::from(&mut Box::leak(node).data) }\n     }\n \n-    unsafe fn from_ptr(ptr: NonNull<LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: unsafe { Unique::new_unchecked(ptr.as_ptr()) } }\n-    }\n-\n     fn as_ptr(&self) -> NonNull<LeafNode<K, V>> {\n         NonNull::from(self.ptr)\n     }\n@@ -199,7 +194,7 @@ impl<K, V> Root<K, V> {\n     /// and is the opposite of `pop_internal_level`.\n     pub fn push_internal_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n+        new_node.edges[0].write(unsafe { ptr::read(&mut self.node) });\n \n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n@@ -225,8 +220,8 @@ impl<K, V> Root<K, V> {\n \n         let top = self.node.ptr;\n \n-        let internal_node = unsafe { self.internal_node_as_mut() };\n-        self.node = unsafe { BoxedNode::from_ptr(internal_node.first_edge().descend().node) };\n+        let mut internal_node = unsafe { self.internal_node_as_mut() };\n+        self.node = unsafe { internal_node.as_internal_mut().edges[0].assume_init_read() };\n         self.height -= 1;\n         self.node_as_mut().as_leaf_mut().parent = None;\n \n@@ -616,7 +611,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n \n     /// Adds a key/value pair to the beginning of the node.\n     fn push_front(&mut self, key: K, val: V) {\n-        debug_assert!(self.len() < CAPACITY);\n+        assert!(self.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -669,14 +664,7 @@ impl<'a, K: 'a, V: 'a> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n             slice_insert(self.vals_mut(), 0, val);\n-            slice_insert(\n-                slice::from_raw_parts_mut(\n-                    MaybeUninit::slice_as_mut_ptr(&mut self.as_internal_mut().edges),\n-                    self.len() + 1,\n-                ),\n-                0,\n-                edge.node,\n-            );\n+            slice_insert(self.edges_mut(), 0, edge.node);\n         }\n \n         self.as_leaf_mut().len += 1;\n@@ -926,33 +914,22 @@ fn splitpoint(edge_idx: usize) -> (usize, InsertionPlace) {\n     }\n }\n \n-impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n-    /// Helps implementations of `insert_fit` for a particular `NodeType`,\n-    /// by taking care of leaf data.\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    fn leafy_insert_fit(&mut self, key: K, val: V) {\n+    ///\n+    /// The returned pointer points to the inserted value.\n+    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         debug_assert!(self.node.len() < CAPACITY);\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n             slice_insert(self.node.vals_mut(), self.idx, val);\n-\n             self.node.as_leaf_mut().len += 1;\n-        }\n-    }\n-}\n \n-impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n-    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n-    /// this edge. This method assumes that there is enough space in the node for the new\n-    /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n-        self.leafy_insert_fit(key, val);\n-        unsafe { self.node.val_mut_at(self.idx) }\n+            self.node.val_mut_at(self.idx)\n+        }\n     }\n }\n \n@@ -1001,11 +978,14 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n     fn insert_fit(&mut self, key: K, val: V, edge: Root<K, V>) {\n+        debug_assert!(self.node.len() < CAPACITY);\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n+            slice_insert(self.node.keys_mut(), self.idx, key);\n+            slice_insert(self.node.vals_mut(), self.idx, val);\n             slice_insert(self.node.edges_mut(), self.idx + 1, edge.node);\n-            self.leafy_insert_fit(key, val);\n+            self.node.as_leaf_mut().len += 1;\n \n             self.node.correct_childrens_parent_links((self.idx + 1)..=self.node.len());\n         }\n@@ -1136,15 +1116,21 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n }\n \n impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    /// Helps implementations of `split` for a particular `NodeType`,\n+    /// by calculating the length of the new node.\n+    fn split_new_node_len(&self) -> usize {\n+        debug_assert!(self.idx < self.node.len());\n+        self.node.len() - self.idx - 1\n+    }\n+\n     /// Helps implementations of `split` for a particular `NodeType`,\n     /// by taking care of leaf data.\n-    fn leafy_split(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V, usize) {\n+    fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n+        let new_len = self.split_new_node_len();\n         unsafe {\n             let k = ptr::read(self.node.key_at(self.idx));\n             let v = ptr::read(self.node.val_at(self.idx));\n \n-            let new_len = self.node.len() - self.idx - 1;\n-\n             ptr::copy_nonoverlapping(\n                 self.node.key_at(self.idx + 1),\n                 MaybeUninit::slice_as_mut_ptr(&mut new_node.keys),\n@@ -1158,15 +1144,15 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n             self.node.as_leaf_mut().len = self.idx as u16;\n             new_node.len = new_len as u16;\n-            (k, v, new_len)\n+            (k, v)\n         }\n     }\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n     /// Splits the underlying node into three parts:\n     ///\n-    /// - The node is truncated to only contain the key/value pairs to the right of\n+    /// - The node is truncated to only contain the key/value pairs to the left of\n     ///   this handle.\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the key/value pairs to the right of this handle are put into a newly\n@@ -1175,9 +1161,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, mark\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n-            let (k, v, _) = self.leafy_split(&mut new_node);\n+            let (k, v) = self.split_leaf_data(&mut new_node);\n \n-            (self.node, k, v, Root { node: BoxedNode::from_leaf(new_node), height: 0 })\n+            let right = Root { node: BoxedNode::from_leaf(new_node), height: 0 };\n+            (self.node, k, v, right)\n         }\n     }\n \n@@ -1211,29 +1198,28 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// Splits the underlying node into three parts:\n     ///\n     /// - The node is truncated to only contain the edges and key/value pairs to the\n-    ///   right of this handle.\n+    ///   left of this handle.\n     /// - The key and value pointed to by this handle are extracted.\n     /// - All the edges and key/value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Internal>, K, V, Root<K, V>) {\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n-\n-            let (k, v, new_len) = self.leafy_split(&mut new_node.data);\n-            let height = self.node.height;\n-            let old_node = &*self.node.as_internal_ptr();\n-\n+            // Move edges out before reducing length:\n+            let new_len = self.split_new_node_len();\n             ptr::copy_nonoverlapping(\n-                old_node.edges.as_ptr().add(self.idx + 1),\n-                new_node.edges.as_mut_ptr(),\n+                self.node.edge_at(self.idx + 1),\n+                MaybeUninit::slice_as_mut_ptr(&mut new_node.edges),\n                 new_len + 1,\n             );\n+            let (k, v) = self.split_leaf_data(&mut new_node.data);\n \n-            let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n+            let height = self.node.height;\n+            let mut right = Root { node: BoxedNode::from_internal(new_node), height };\n \n-            new_root.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n+            right.internal_node_as_mut().correct_childrens_parent_links(0..=new_len);\n \n-            (self.node, k, v, new_root)\n+            (self.node, k, v, right)\n         }\n     }\n "}, {"sha": "d6527057c5d772f9789f20d9fb53474d8cad8f7d", "filename": "library/alloc/src/collections/btree/node/tests.rs", "status": "modified", "additions": 83, "deletions": 2, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,87 @@\n+use super::super::navigate;\n use super::*;\n+use crate::fmt::Debug;\n+use crate::string::String;\n use core::cmp::Ordering::*;\n \n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Asserts that the back pointer in each reachable node points to its parent.\n+    pub fn assert_back_pointers(self) {\n+        if let ForceResult::Internal(node) = self.force() {\n+            for idx in 0..=node.len() {\n+                let edge = unsafe { Handle::new_edge(node, idx) };\n+                let child = edge.descend();\n+                assert!(child.ascend().ok() == Some(edge));\n+                child.assert_back_pointers();\n+            }\n+        }\n+    }\n+\n+    /// Asserts that the keys are in strictly ascending order.\n+    /// Returns how many keys it encountered.\n+    pub fn assert_ascending(self) -> usize\n+    where\n+        K: Copy + Debug + Ord,\n+    {\n+        struct SeriesChecker<T> {\n+            num_seen: usize,\n+            previous: Option<T>,\n+        }\n+        impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n+            fn is_ascending(&mut self, next: T) {\n+                if let Some(previous) = self.previous {\n+                    assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n+                }\n+                self.previous = Some(next);\n+                self.num_seen += 1;\n+            }\n+        }\n+\n+        let mut checker = SeriesChecker { num_seen: 0, previous: None };\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(node) => {\n+                for idx in 0..node.len() {\n+                    let key = *unsafe { node.key_at(idx) };\n+                    checker.is_ascending(key);\n+                }\n+            }\n+            navigate::Position::InternalKV(kv) => {\n+                let key = *kv.into_kv().0;\n+                checker.is_ascending(key);\n+            }\n+            navigate::Position::Internal(_) => {}\n+        });\n+        checker.num_seen\n+    }\n+\n+    pub fn dump_keys(self) -> String\n+    where\n+        K: Debug,\n+    {\n+        let mut result = String::new();\n+        self.visit_nodes_in_order(|pos| match pos {\n+            navigate::Position::Leaf(leaf) => {\n+                let depth = self.height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}\", indent);\n+                for idx in 0..leaf.len() {\n+                    if idx > 0 {\n+                        result += \", \";\n+                    }\n+                    result += &format!(\"{:?}\", unsafe { leaf.key_at(idx) });\n+                }\n+            }\n+            navigate::Position::Internal(_) => {}\n+            navigate::Position::InternalKV(kv) => {\n+                let depth = self.height() - kv.into_node().height();\n+                let indent = \"  \".repeat(depth);\n+                result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n+            }\n+        });\n+        result\n+    }\n+}\n+\n #[test]\n fn test_splitpoint() {\n     for idx in 0..=CAPACITY {\n@@ -19,8 +100,8 @@ fn test_splitpoint() {\n                 right_len += 1;\n             }\n         }\n-        assert!(left_len >= MIN_LEN);\n-        assert!(right_len >= MIN_LEN);\n+        assert!(left_len >= MIN_LEN_AFTER_SPLIT);\n+        assert!(right_len >= MIN_LEN_AFTER_SPLIT);\n         assert!(left_len + right_len == CAPACITY);\n     }\n }"}, {"sha": "99655d3e2bf64f35c2bc0f52b1427f7e81b92fa1", "filename": "library/alloc/src/collections/btree/remove.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fremove.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -0,0 +1,133 @@\n+use super::map::MIN_LEN;\n+use super::node::{marker, ForceResult, Handle, NodeRef};\n+use super::unwrap_unchecked;\n+use core::mem;\n+use core::ptr;\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair.\n+    pub fn remove_kv_tracking<F: FnOnce()>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n+        let (old_kv, mut pos, was_internal) = match self.force() {\n+            ForceResult::Leaf(leaf) => {\n+                let (old_kv, pos) = leaf.remove();\n+                (old_kv, pos, false)\n+            }\n+            ForceResult::Internal(mut internal) => {\n+                // Replace the location freed in the internal node with an\n+                // adjacent KV, and remove that adjacent KV from its leaf.\n+                // Always choose the adjacent KV on the left side because\n+                // it is typically faster to pop an element from the end\n+                // of the KV arrays without needing to shift other elements.\n+\n+                let key_loc = internal.kv_mut().0 as *mut K;\n+                let val_loc = internal.kv_mut().1 as *mut V;\n+\n+                let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n+                let to_remove = unsafe { unwrap_unchecked(to_remove) };\n+\n+                let (kv, pos) = to_remove.remove();\n+\n+                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n+\n+                ((old_key, old_val), pos, true)\n+            }\n+        };\n+\n+        // Handle underflow\n+        let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n+        let mut at_leaf = true;\n+        while cur_node.len() < MIN_LEN {\n+            match handle_underfull_node(cur_node) {\n+                UnderflowResult::AtRoot => break,\n+                UnderflowResult::Merged(edge, merged_with_left, offset) => {\n+                    // If we merged with our right sibling then our tracked\n+                    // position has not changed. However if we merged with our\n+                    // left sibling then our tracked position is now dangling.\n+                    if at_leaf && merged_with_left {\n+                        let idx = pos.idx() + offset;\n+                        let node = match unsafe { ptr::read(&edge).descend().force() } {\n+                            ForceResult::Leaf(leaf) => leaf,\n+                            ForceResult::Internal(_) => unreachable!(),\n+                        };\n+                        pos = unsafe { Handle::new_edge(node, idx) };\n+                    }\n+\n+                    let parent = edge.into_node();\n+                    if parent.len() == 0 {\n+                        // The parent that was just emptied must be the root,\n+                        // because nodes on a lower level would not have been\n+                        // left with a single child.\n+                        handle_emptied_internal_root();\n+                        break;\n+                    } else {\n+                        cur_node = parent.forget_type();\n+                        at_leaf = false;\n+                    }\n+                }\n+                UnderflowResult::Stole(stole_from_left) => {\n+                    // Adjust the tracked position if we stole from a left sibling\n+                    if stole_from_left && at_leaf {\n+                        // SAFETY: This is safe since we just added an element to our node.\n+                        unsafe {\n+                            pos.move_next_unchecked();\n+                        }\n+                    }\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // If we deleted from an internal node then we need to compensate for\n+        // the earlier swap and adjust the tracked position to point to the\n+        // next element.\n+        if was_internal {\n+            pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n+        }\n+\n+        (old_kv, pos)\n+    }\n+}\n+\n+enum UnderflowResult<'a, K, V> {\n+    AtRoot,\n+    Merged(Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::Edge>, bool, usize),\n+    Stole(bool),\n+}\n+\n+fn handle_underfull_node<'a, K: 'a, V: 'a>(\n+    node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>,\n+) -> UnderflowResult<'_, K, V> {\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(_) => return UnderflowResult::AtRoot,\n+    };\n+\n+    // Prefer the left KV if it exists. Merging with the left side is faster,\n+    // since merging happens towards the left and `node` has fewer elements.\n+    // Stealing from the left side is faster, since we can pop from the end of\n+    // the KV arrays.\n+    let (is_left, mut handle) = match parent.left_kv() {\n+        Ok(left) => (true, left),\n+        Err(parent) => {\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n+        }\n+    };\n+\n+    if handle.can_merge() {\n+        let offset = if is_left { handle.reborrow().left_edge().descend().len() + 1 } else { 0 };\n+        UnderflowResult::Merged(handle.merge(), is_left, offset)\n+    } else {\n+        if is_left {\n+            handle.steal_left();\n+        } else {\n+            handle.steal_right();\n+        }\n+        UnderflowResult::Stole(is_left)\n+    }\n+}"}, {"sha": "5f00a5a25abad5bf2a091c8f9ea024b6e304a713", "filename": "library/alloc/src/collections/btree/split.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fsplit.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -0,0 +1,106 @@\n+use super::map::MIN_LEN;\n+use super::node::{ForceResult::*, Root};\n+use super::search::{search_node, SearchResult::*};\n+use core::borrow::Borrow;\n+\n+impl<K, V> Root<K, V> {\n+    pub fn split_off<Q: ?Sized + Ord>(&mut self, right_root: &mut Self, key: &Q)\n+    where\n+        K: Borrow<Q>,\n+    {\n+        debug_assert!(right_root.height() == 0);\n+        debug_assert!(right_root.node_as_ref().len() == 0);\n+\n+        let left_root = self;\n+        for _ in 0..left_root.height() {\n+            right_root.push_internal_level();\n+        }\n+\n+        {\n+            let mut left_node = left_root.node_as_mut();\n+            let mut right_node = right_root.node_as_mut();\n+\n+            loop {\n+                let mut split_edge = match search_node(left_node, key) {\n+                    // key is going to the right tree\n+                    Found(handle) => handle.left_edge(),\n+                    GoDown(handle) => handle,\n+                };\n+\n+                split_edge.move_suffix(&mut right_node);\n+\n+                match (split_edge.force(), right_node.force()) {\n+                    (Internal(edge), Internal(node)) => {\n+                        left_node = edge.descend();\n+                        right_node = node.first_edge().descend();\n+                    }\n+                    (Leaf(_), Leaf(_)) => {\n+                        break;\n+                    }\n+                    _ => unreachable!(),\n+                }\n+            }\n+        }\n+\n+        left_root.fix_right_border();\n+        right_root.fix_left_border();\n+    }\n+\n+    /// Removes empty levels on the top, but keeps an empty leaf if the entire tree is empty.\n+    fn fix_top(&mut self) {\n+        while self.height() > 0 && self.node_as_ref().len() == 0 {\n+            self.pop_internal_level();\n+        }\n+    }\n+\n+    fn fix_right_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.node_as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut last_kv = node.last_kv();\n+\n+                if last_kv.can_merge() {\n+                    cur_node = last_kv.merge().descend();\n+                } else {\n+                    let right_len = last_kv.reborrow().right_edge().descend().len();\n+                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+                    if right_len < MIN_LEN + 1 {\n+                        last_kv.bulk_steal_left(MIN_LEN + 1 - right_len);\n+                    }\n+                    cur_node = last_kv.right_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+\n+    /// The symmetric clone of `fix_right_border`.\n+    fn fix_left_border(&mut self) {\n+        self.fix_top();\n+\n+        {\n+            let mut cur_node = self.node_as_mut();\n+\n+            while let Internal(node) = cur_node.force() {\n+                let mut first_kv = node.first_kv();\n+\n+                if first_kv.can_merge() {\n+                    cur_node = first_kv.merge().descend();\n+                } else {\n+                    let left_len = first_kv.reborrow().left_edge().descend().len();\n+                    // `MIN_LEN + 1` to avoid readjust if merge happens on the next level.\n+                    if left_len < MIN_LEN + 1 {\n+                        first_kv.bulk_steal_right(MIN_LEN + 1 - left_len);\n+                    }\n+                    cur_node = first_kv.left_edge().descend();\n+                }\n+            }\n+        }\n+\n+        self.fix_top();\n+    }\n+}"}, {"sha": "22b02a4f849b6b90bc3bef198644ec769f257285", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 139, "deletions": 2, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1102,7 +1102,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        let Range { start, end } = slice::check_range(self.len(), range);\n+        let Range { start, end } = range.assert_len(self.len());\n         let tail = self.wrap_add(self.tail, start);\n         let head = self.wrap_add(self.tail, end);\n         (tail, head)\n@@ -2181,7 +2181,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// This method does not allocate and does not change the order of the\n     /// inserted elements. As it returns a mutable slice, this can be used to\n-    /// sort or binary search a deque.\n+    /// sort a deque.\n     ///\n     /// Once the internal storage is contiguous, the [`as_slices`] and\n     /// [`as_mut_slices`] methods will return the entire contents of the\n@@ -2430,6 +2430,143 @@ impl<T> VecDeque<T> {\n             self.wrap_copy(self.tail, self.head, k);\n         }\n     }\n+\n+    /// Binary searches this sorted `VecDeque` for a given element.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search(&13),  Ok(9));\n+    /// assert_eq!(deque.binary_search(&4),   Err(7));\n+    /// assert_eq!(deque.binary_search(&100), Err(13));\n+    /// let r = deque.binary_search(&1);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    ///\n+    /// If you want to insert an item to a sorted `VecDeque`, while maintaining\n+    /// sort order:\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    /// let num = 42;\n+    /// let idx = deque.binary_search(&num).unwrap_or_else(|x| x);\n+    /// deque.insert(idx, num);\n+    /// assert_eq!(deque, &[0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 42, 55]);\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search(&self, x: &T) -> Result<usize, usize>\n+    where\n+        T: Ord,\n+    {\n+        self.binary_search_by(|e| e.cmp(x))\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a comparator function.\n+    ///\n+    /// The comparator function should implement an order consistent\n+    /// with the sort order of the underlying `VecDeque`, returning an\n+    /// order code that indicates whether its argument is `Less`,\n+    /// `Equal` or `Greater` than the desired target.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements. The first is found, with a\n+    /// uniquely determined position; the second and third are not\n+    /// found; the fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&13)),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&4)),   Err(7));\n+    /// assert_eq!(deque.binary_search_by(|x| x.cmp(&100)), Err(13));\n+    /// let r = deque.binary_search_by(|x| x.cmp(&1));\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    pub fn binary_search_by<'a, F>(&'a self, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> Ordering,\n+    {\n+        let (front, back) = self.as_slices();\n+\n+        if let Some(Ordering::Less | Ordering::Equal) = back.first().map(|elem| f(elem)) {\n+            back.binary_search_by(f).map(|idx| idx + front.len()).map_err(|idx| idx + front.len())\n+        } else {\n+            front.binary_search_by(f)\n+        }\n+    }\n+\n+    /// Binary searches this sorted `VecDeque` with a key extraction function.\n+    ///\n+    /// Assumes that the `VecDeque` is sorted by the key, for instance with\n+    /// [`make_contiguous().sort_by_key()`](#method.make_contiguous) using the same\n+    /// key extraction function.\n+    ///\n+    /// If the value is found then [`Result::Ok`] is returned, containing the\n+    /// index of the matching element. If there are multiple matches, then any\n+    /// one of the matches could be returned. If the value is not found then\n+    /// [`Result::Err`] is returned, containing the index where a matching\n+    /// element could be inserted while maintaining sorted order.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Looks up a series of four elements in a slice of pairs sorted by\n+    /// their second elements. The first is found, with a uniquely\n+    /// determined position; the second and third are not found; the\n+    /// fourth could match any position in `[1, 4]`.\n+    ///\n+    /// ```\n+    /// #![feature(vecdeque_binary_search)]\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let deque: VecDeque<_> = vec![(0, 0), (2, 1), (4, 1), (5, 1),\n+    ///          (3, 1), (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),\n+    ///          (1, 21), (2, 34), (4, 55)].into();\n+    ///\n+    /// assert_eq!(deque.binary_search_by_key(&13, |&(a,b)| b),  Ok(9));\n+    /// assert_eq!(deque.binary_search_by_key(&4, |&(a,b)| b),   Err(7));\n+    /// assert_eq!(deque.binary_search_by_key(&100, |&(a,b)| b), Err(13));\n+    /// let r = deque.binary_search_by_key(&1, |&(a,b)| b);\n+    /// assert!(matches!(r, Ok(1..=4)));\n+    /// ```\n+    #[unstable(feature = \"vecdeque_binary_search\", issue = \"78021\")]\n+    #[inline]\n+    pub fn binary_search_by_key<'a, B, F>(&'a self, b: &B, mut f: F) -> Result<usize, usize>\n+    where\n+        F: FnMut(&'a T) -> B,\n+        B: Ord,\n+    {\n+        self.binary_search_by(|k| f(k).cmp(b))\n+    }\n }\n \n impl<T: Clone> VecDeque<T> {"}, {"sha": "0fe15958076c53ad1b1054083bcdad4c9ffdaa88", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -72,6 +72,7 @@\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n #![deny(unsafe_op_in_unsafe_fn)]\n+#![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n #![cfg_attr(test, feature(new_uninit))]\n@@ -114,11 +115,12 @@\n #![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n+#![feature(range_bounds_assert_len)]\n #![feature(raw_ref_op)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n+#![feature(renamed_spin_loop)]\n #![feature(min_specialization)]\n-#![feature(slice_check_range)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]\n #![feature(staged_api)]"}, {"sha": "a4240308bb35fec34f630518235b16c337b99c02", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -116,7 +116,8 @@ impl<T> RawVec<T, Global> {\n impl<T, A: AllocRef> RawVec<T, A> {\n     /// Like `new`, but parameterized over the choice of allocator for\n     /// the returned `RawVec`.\n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn new_in(alloc: A) -> Self {\n         // `cap: 0` means \"unallocated\". zero-sized types are ignored.\n         Self { ptr: Unique::dangling(), cap: 0, alloc }\n@@ -259,7 +260,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// Ensures that the buffer contains at least enough space to hold `len +\n     /// additional` elements. If it doesn't already have enough capacity, will\n     /// reallocate enough space plus comfortable slack space to get amortized\n-    /// `O(1)` behavior. Will limit this behavior if it would needlessly cause\n+    /// *O*(1) behavior. Will limit this behavior if it would needlessly cause\n     /// itself to panic.\n     ///\n     /// If `len` exceeds `self.capacity()`, this may fail to actually allocate"}, {"sha": "3db66964941c3dbd679115f5d6d259ee242aa9ec", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -91,8 +91,6 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n-#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n-pub use core::slice::check_range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub use core::slice::ArrayChunks;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n@@ -169,7 +167,7 @@ mod hack {\n impl<T> [T] {\n     /// Sorts the slice.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// When applicable, unstable sorting is preferred because it is generally faster than stable\n     /// sorting and it doesn't allocate auxiliary memory.\n@@ -204,7 +202,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a comparator function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(n * log(n))` worst-case.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*n* \\* log(*n*)) worst-case.\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n@@ -258,8 +256,8 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or\n     /// basic operations), [`sort_by_cached_key`](#method.sort_by_cached_key) is likely to be\n@@ -301,8 +299,8 @@ impl<T> [T] {\n     ///\n     /// During sorting, the key function is called only once per element.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m * n + n * log(n))`\n-    /// worst-case, where the key function is `O(m)`.\n+    /// This sort is stable (i.e., does not reorder equal elements) and *O*(*m* \\* *n* + *n* \\* log(*n*))\n+    /// worst-case, where the key function is *O*(*m*).\n     ///\n     /// For simple key functions (e.g., functions that are property accesses or\n     /// basic operations), [`sort_by_key`](#method.sort_by_key) is likely to be\n@@ -946,7 +944,7 @@ where\n /// 1. for every `i` in `1..runs.len()`: `runs[i - 1].len > runs[i].len`\n /// 2. for every `i` in `2..runs.len()`: `runs[i - 2].len > runs[i - 1].len + runs[i].len`\n ///\n-/// The invariants ensure that the total running time is `O(n * log(n))` worst-case.\n+/// The invariants ensure that the total running time is *O*(*n* \\* log(*n*)) worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n where\n     F: FnMut(&T, &T) -> bool,"}, {"sha": "72ed036637d8b074d512b7ab728671c3489e6ba0", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,8 +1,8 @@\n-//! A UTF-8 encoded, growable string.\n+//! A UTF-8\u2013encoded, growable string.\n //!\n-//! This module contains the [`String`] type, a trait for converting\n-//! [`ToString`]s, and several error types that may result from working with\n-//! [`String`]s.\n+//! This module contains the [`String`] type, the [`ToString`] trait for\n+//! converting to strings, and several error types that may result from\n+//! working with [`String`]s.\n //!\n //! # Examples\n //!\n@@ -49,7 +49,6 @@ use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n-use core::slice;\n use core::str::{lossy, pattern::Pattern};\n \n use crate::borrow::{Cow, ToOwned};\n@@ -58,7 +57,7 @@ use crate::collections::TryReserveError;\n use crate::str::{self, from_boxed_utf8_unchecked, Chars, FromStr, Utf8Error};\n use crate::vec::Vec;\n \n-/// A UTF-8 encoded, growable string.\n+/// A UTF-8\u2013encoded, growable string.\n ///\n /// The `String` type is the most common string type that has ownership over the\n /// contents of the string. It has a close relationship with its borrowed\n@@ -566,7 +565,7 @@ impl String {\n         Cow::Owned(res)\n     }\n \n-    /// Decode a UTF-16 encoded vector `v` into a `String`, returning [`Err`]\n+    /// Decode a UTF-16\u2013encoded vector `v` into a `String`, returning [`Err`]\n     /// if `v` contains any invalid data.\n     ///\n     /// # Examples\n@@ -600,7 +599,7 @@ impl String {\n         Ok(ret)\n     }\n \n-    /// Decode a UTF-16 encoded slice `v` into a `String`, replacing\n+    /// Decode a UTF-16\u2013encoded slice `v` into a `String`, replacing\n     /// invalid data with [the replacement character (`U+FFFD`)][U+FFFD].\n     ///\n     /// Unlike [`from_utf8_lossy`] which returns a [`Cow<'a, str>`],\n@@ -1507,14 +1506,14 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let Range { start, end } = slice::check_range(self.len(), range);\n+        let Range { start, end } = range.assert_len(self.len());\n         assert!(self.is_char_boundary(start));\n         assert!(self.is_char_boundary(end));\n \n         // Take out two simultaneous borrows. The &mut String won't be accessed\n         // until iteration is over, in Drop.\n         let self_ptr = self as *mut _;\n-        // SAFETY: `check_range` and `is_char_boundary` do the appropriate bounds checks.\n+        // SAFETY: `assert_len` and `is_char_boundary` do the appropriate bounds checks.\n         let chars_iter = unsafe { self.get_unchecked(start..end) }.chars();\n \n         Drain { start, end, iter: chars_iter, string: self_ptr }\n@@ -2192,15 +2191,15 @@ pub trait ToString {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> ToString for T {\n     // A common guideline is to not inline generic functions. However,\n-    // remove `#[inline]` from this method causes non-negligible regression.\n-    // See <https://github.com/rust-lang/rust/pull/74852> as last attempt try to remove it.\n+    // removing `#[inline]` from this method causes non-negligible regressions.\n+    // See <https://github.com/rust-lang/rust/pull/74852>, the last attempt\n+    // to try to remove it.\n     #[inline]\n     default fn to_string(&self) -> String {\n         use fmt::Write;\n         let mut buf = String::new();\n         buf.write_fmt(format_args!(\"{}\", self))\n             .expect(\"a Display implementation returned an error unexpectedly\");\n-        buf.shrink_to_fit();\n         buf\n     }\n }"}, {"sha": "73ff795c01aa88d31a97d158e3c5ba59b363a27c", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,6 +10,7 @@ use core::cmp::Ordering;\n use core::convert::{From, TryFrom};\n use core::fmt;\n use core::hash::{Hash, Hasher};\n+use core::hint;\n use core::intrinsics::abort;\n use core::iter;\n use core::marker::{PhantomData, Unpin, Unsize};\n@@ -764,6 +765,7 @@ impl<T: ?Sized> Arc<T> {\n         loop {\n             // check if the weak counter is currently \"locked\"; if so, spin.\n             if cur == usize::MAX {\n+                hint::spin_loop();\n                 cur = this.inner().weak.load(Relaxed);\n                 continue;\n             }"}, {"sha": "5b3604db563c6092549d6f654c73dda99122bda0", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 2, "deletions": 46, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -259,7 +259,7 @@ use crate::raw_vec::RawVec;\n /// `Vec` does not guarantee any particular growth strategy when reallocating\n /// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n+/// strategy is used will of course guarantee *O*(1) amortized [`push`].\n ///\n /// `vec![x; n]`, `vec![a, b, c, d]`, and\n /// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all produce a `Vec`\n@@ -1314,7 +1314,7 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let Range { start, end } = slice::check_range(len, range);\n+        let Range { start, end } = range.assert_len(len);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked\n@@ -1603,50 +1603,6 @@ impl<T: Clone> Vec<T> {\n     }\n }\n \n-impl<T: Default> Vec<T> {\n-    /// Resizes the `Vec` in-place so that `len` is equal to `new_len`.\n-    ///\n-    /// If `new_len` is greater than `len`, the `Vec` is extended by the\n-    /// difference, with each additional slot filled with [`Default::default()`].\n-    /// If `new_len` is less than `len`, the `Vec` is simply truncated.\n-    ///\n-    /// This method uses [`Default`] to create new values on every push. If\n-    /// you'd rather [`Clone`] a given value, use [`resize`].\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// # #![allow(deprecated)]\n-    /// #![feature(vec_resize_default)]\n-    ///\n-    /// let mut vec = vec![1, 2, 3];\n-    /// vec.resize_default(5);\n-    /// assert_eq!(vec, [1, 2, 3, 0, 0]);\n-    ///\n-    /// let mut vec = vec![1, 2, 3, 4];\n-    /// vec.resize_default(2);\n-    /// assert_eq!(vec, [1, 2]);\n-    /// ```\n-    ///\n-    /// [`resize`]: Vec::resize\n-    #[unstable(feature = \"vec_resize_default\", issue = \"41758\")]\n-    #[rustc_deprecated(\n-        reason = \"This is moving towards being removed in favor \\\n-                  of `.resize_with(Default::default)`.  If you disagree, please comment \\\n-                  in the tracking issue.\",\n-        since = \"1.33.0\"\n-    )]\n-    pub fn resize_default(&mut self, new_len: usize) {\n-        let len = self.len();\n-\n-        if new_len > len {\n-            self.extend_with(new_len - len, ExtendDefault);\n-        } else {\n-            self.truncate(new_len);\n-        }\n-    }\n-}\n-\n // This code generalizes `extend_with_{element,default}`.\n trait ExtendWith<T> {\n     fn next(&mut self) -> T;"}, {"sha": "b7cc03f8eb999403f45f2a70939bbf92f960c569", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -20,6 +20,7 @@\n #![feature(inplace_iteration)]\n #![feature(iter_map_while)]\n #![feature(int_bits_const)]\n+#![feature(vecdeque_binary_search)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "834dd4656ff76bdb171ef96c3329af15e6ff1e31", "filename": "library/alloc/tests/str.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstr.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -529,6 +529,13 @@ mod slice_index {\n             message: \"out of bounds\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: \"abcdef\";\n+            good: data[0..=5] == \"abcdef\";\n+            bad: data[0..=6];\n+            message: \"out of bounds\";\n+        }\n+\n         in mod range_len_len {\n             data: \"abcdef\";\n             good: data[6..6] == \"\";\n@@ -544,6 +551,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: \"abcdef\";\n+\n+            good: data[0..=5] == \"abcdef\";\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == \"\";\n+\n+            // 0..=6 is out of bounds before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of bounds\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: \"abcdef\";"}, {"sha": "05cb3a2c03d79a49780436dfe9889e918af955af", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1659,3 +1659,42 @@ fn test_drain_leak() {\n     drop(v);\n     assert_eq!(unsafe { DROPS }, 7);\n }\n+\n+#[test]\n+fn test_binary_search() {\n+    // Contiguous (front only) search:\n+    let deque: VecDeque<_> = vec![1, 2, 3, 5, 6].into();\n+    assert!(deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&3), Ok(2));\n+    assert_eq!(deque.binary_search(&4), Err(3));\n+\n+    // Split search (both front & back non-empty):\n+    let mut deque: VecDeque<_> = vec![5, 6].into();\n+    deque.push_front(3);\n+    deque.push_front(2);\n+    deque.push_front(1);\n+    deque.push_back(10);\n+    assert!(!deque.as_slices().0.is_empty());\n+    assert!(!deque.as_slices().1.is_empty());\n+    assert_eq!(deque.binary_search(&0), Err(0));\n+    assert_eq!(deque.binary_search(&1), Ok(0));\n+    assert_eq!(deque.binary_search(&5), Ok(3));\n+    assert_eq!(deque.binary_search(&7), Err(5));\n+    assert_eq!(deque.binary_search(&20), Err(6));\n+}\n+\n+#[test]\n+fn test_binary_search_by() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&3)), Ok(2));\n+    assert_eq!(deque.binary_search_by(|&(v,)| v.cmp(&4)), Err(3));\n+}\n+\n+#[test]\n+fn test_binary_search_by_key() {\n+    let deque: VecDeque<_> = vec![(1,), (2,), (3,), (5,), (6,)].into();\n+\n+    assert_eq!(deque.binary_search_by_key(&3, |&(v,)| v), Ok(2));\n+    assert_eq!(deque.binary_search_by_key(&4, |&(v,)| v), Err(3));\n+}"}, {"sha": "8b8ea53b56f519dd7780defdd4254daaec892584", "filename": "library/backtrace", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fbacktrace?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1 +1 @@\n-Subproject commit 893fbb23688e98376e54c26b59432a2966a8cc96\n+Subproject commit 8b8ea53b56f519dd7780defdd4254daaec892584"}, {"sha": "bc59c378609f04992d1c1e36e9641c08637d40d4", "filename": "library/core/benches/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fbenches%2Fascii.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -253,9 +253,9 @@ macro_rules! repeat {\n     };\n }\n \n-const SHORT: &'static str = \"Alice's\";\n-const MEDIUM: &'static str = \"Alice's Adventures in Wonderland\";\n-const LONG: &'static str = repeat!(\n+const SHORT: &str = \"Alice's\";\n+const MEDIUM: &str = \"Alice's Adventures in Wonderland\";\n+const LONG: &str = repeat!(\n     r#\"\n     La Guida di Bragia, a Ballad Opera for the Marionette Theatre (around 1850)\n     Alice's Adventures in Wonderland (1865)"}, {"sha": "c61c19cc7d1d1a3c94f080f8d7038273c132dd45", "filename": "library/core/src/alloc/mod.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -89,13 +89,11 @@ impl fmt::Display for AllocError {\n pub unsafe trait AllocRef {\n     /// Attempts to allocate a block of memory.\n     ///\n-    /// On success, returns a [`NonNull<[u8]>`] meeting the size and alignment guarantees of `layout`.\n+    /// On success, returns a [`NonNull<[u8]>`][NonNull] meeting the size and alignment guarantees of `layout`.\n     ///\n     /// The returned block may have a larger size than specified by `layout.size()`, and may or may\n     /// not have its contents initialized.\n     ///\n-    /// [`NonNull<[u8]>`]: NonNull\n-    ///\n     /// # Errors\n     ///\n     /// Returning `Err` indicates that either memory is exhausted or `layout` does not meet\n@@ -146,7 +144,7 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to extend the memory block.\n     ///\n-    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`][NonNull] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n     /// this, the allocator may extend the allocation referenced by `ptr` to fit the new layout.\n     ///\n@@ -158,8 +156,6 @@ pub unsafe trait AllocRef {\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// [`NonNull<[u8]>`]: NonNull\n-    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator.\n@@ -271,7 +267,7 @@ pub unsafe trait AllocRef {\n \n     /// Attempts to shrink the memory block.\n     ///\n-    /// Returns a new [`NonNull<[u8]>`] containing a pointer and the actual size of the allocated\n+    /// Returns a new [`NonNull<[u8]>`][NonNull] containing a pointer and the actual size of the allocated\n     /// memory. The pointer is suitable for holding data described by `new_layout`. To accomplish\n     /// this, the allocator may shrink the allocation referenced by `ptr` to fit the new layout.\n     ///\n@@ -283,8 +279,6 @@ pub unsafe trait AllocRef {\n     /// If this method returns `Err`, then ownership of the memory block has not been transferred to\n     /// this allocator, and the contents of the memory block are unaltered.\n     ///\n-    /// [`NonNull<[u8]>`]: NonNull\n-    ///\n     /// # Safety\n     ///\n     /// * `ptr` must denote a block of memory [*currently allocated*] via this allocator."}, {"sha": "3f7110b34cc67de60eb1bdc0b9ab3cbf00b89e3b", "filename": "library/core/src/convert/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -134,6 +134,7 @@ pub const fn identity<T>(x: T) -> T {\n /// want to accept all references that can be converted to [`&str`] as an argument.\n /// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n+/// [`&str`]: primitive@str\n /// [`Option<T>`]: Option\n /// [`Result<T, E>`]: Result\n /// [`Borrow`]: crate::borrow::Borrow"}, {"sha": "2dd5e813d6fb7bbe2e2d504f06b9992089cb1192", "filename": "library/core/src/convert/num.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fconvert%2Fnum.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -485,3 +485,49 @@ nzint_impl_try_from_int! { i32, NonZeroI32, #[stable(feature = \"nzint_try_from_i\n nzint_impl_try_from_int! { i64, NonZeroI64, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n nzint_impl_try_from_int! { i128, NonZeroI128, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n nzint_impl_try_from_int! { isize, NonZeroIsize, #[stable(feature = \"nzint_try_from_int_conv\", since = \"1.46.0\")] }\n+\n+macro_rules! nzint_impl_try_from_nzint {\n+    ($From:ty => $To:ty, $doc: expr) => {\n+        #[stable(feature = \"nzint_try_from_nzint_conv\", since = \"1.49.0\")]\n+        #[doc = $doc]\n+        impl TryFrom<$From> for $To {\n+            type Error = TryFromIntError;\n+\n+            #[inline]\n+            fn try_from(value: $From) -> Result<Self, Self::Error> {\n+                TryFrom::try_from(value.get()).map(|v| {\n+                    // SAFETY: $From is a NonZero type, so v is not zero.\n+                    unsafe { Self::new_unchecked(v) }\n+                })\n+            }\n+        }\n+    };\n+    ($To:ty: $($From: ty),*) => {$(\n+        nzint_impl_try_from_nzint!(\n+            $From => $To,\n+            concat!(\n+                \"Attempts to convert `\",\n+                stringify!($From),\n+                \"` to `\",\n+                stringify!($To),\n+                \"`.\",\n+            )\n+        );\n+    )*};\n+}\n+\n+// Non-zero int -> non-zero unsigned int\n+nzint_impl_try_from_nzint! { NonZeroU8: NonZeroI8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU16: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU32: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU64: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroU128: NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroUsize: NonZeroI8, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroIsize }\n+\n+// Non-zero int -> non-zero signed int\n+nzint_impl_try_from_nzint! { NonZeroI8: NonZeroU8, NonZeroU16, NonZeroI16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI16: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI32: NonZeroU32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI64: NonZeroU64, NonZeroU128, NonZeroI128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroI128: NonZeroU128, NonZeroUsize, NonZeroIsize }\n+nzint_impl_try_from_nzint! { NonZeroIsize: NonZeroU16, NonZeroU32, NonZeroI32, NonZeroU64, NonZeroI64, NonZeroU128, NonZeroI128, NonZeroUsize }"}, {"sha": "dbc7921a62a674a319abf0811213c72f2e4f6107", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1660,22 +1660,22 @@ extern \"rust-intrinsic\" {\n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `checked_add` method. For example,\n-    /// [`u32::checked_add`]\n+    /// primitives via the `wrapping_add` method. For example,\n+    /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `checked_sub` method. For example,\n-    /// [`u32::checked_sub`]\n+    /// primitives via the `wrapping_sub` method. For example,\n+    /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n     /// The stabilized versions of this intrinsic are available on the integer\n-    /// primitives via the `checked_mul` method. For example,\n-    /// [`u32::checked_mul`]\n+    /// primitives via the `wrapping_mul` method. For example,\n+    /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n "}, {"sha": "2e070d71224422b9bb0e190e802a2d5fd1de0084", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -109,7 +109,7 @@ where\n             acc = b.try_fold(acc, f)?;\n             // we don't fuse the second iterator\n         }\n-        Try::from_ok(acc)\n+        try { acc }\n     }\n \n     fn fold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n@@ -292,7 +292,7 @@ where\n             acc = a.try_rfold(acc, f)?;\n             // we don't fuse the second iterator\n         }\n-        Try::from_ok(acc)\n+        try { acc }\n     }\n \n     fn rfold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc"}, {"sha": "35adb4f69d854eec06cab4edfdf17eb80bcda98d", "filename": "library/core/src/iter/adapters/flatten.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fflatten.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -317,7 +317,7 @@ where\n         }\n         self.backiter = None;\n \n-        Try::from_ok(init)\n+        try { init }\n     }\n \n     #[inline]\n@@ -397,7 +397,7 @@ where\n         }\n         self.frontiter = None;\n \n-        Try::from_ok(init)\n+        try { init }\n     }\n \n     #[inline]"}, {"sha": "60ac3524e66964c65b3c37e1d6c517815c5bc788", "filename": "library/core/src/iter/adapters/fuse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Ffuse.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -303,7 +303,7 @@ where\n             acc = iter.try_fold(acc, fold)?;\n             self.iter = None;\n         }\n-        Try::from_ok(acc)\n+        try { acc }\n     }\n \n     #[inline]\n@@ -353,7 +353,7 @@ where\n             acc = iter.try_rfold(acc, fold)?;\n             self.iter = None;\n         }\n-        Try::from_ok(acc)\n+        try { acc }\n     }\n \n     #[inline]"}, {"sha": "9c8e639c2d802cfcf0350386b69575e874f5345a", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -579,7 +579,7 @@ where\n         })?;\n \n         if is_empty {\n-            return Try::from_ok(acc);\n+            return try { acc };\n         }\n \n         loop {\n@@ -715,7 +715,7 @@ where\n         if self.first_take {\n             self.first_take = false;\n             match self.iter.next() {\n-                None => return Try::from_ok(acc),\n+                None => return try { acc },\n                 Some(x) => acc = f(acc, x)?,\n             }\n         }\n@@ -792,7 +792,7 @@ where\n         }\n \n         match self.next_back() {\n-            None => Try::from_ok(init),\n+            None => try { init },\n             Some(x) => {\n                 let acc = f(init, x)?;\n                 from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n@@ -1075,7 +1075,7 @@ fn filter_try_fold<'a, T, Acc, R: Try<Ok = Acc>>(\n     predicate: &'a mut impl FnMut(&T) -> bool,\n     mut fold: impl FnMut(Acc, T) -> R + 'a,\n ) -> impl FnMut(Acc, T) -> R + 'a {\n-    move |acc, item| if predicate(&item) { fold(acc, item) } else { R::from_ok(acc) }\n+    move |acc, item| if predicate(&item) { fold(acc, item) } else { try { acc } }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1229,7 +1229,7 @@ fn filter_map_try_fold<'a, T, B, Acc, R: Try<Ok = Acc>>(\n ) -> impl FnMut(Acc, T) -> R + 'a {\n     move |acc, item| match f(item) {\n         Some(x) => fold(acc, x),\n-        None => R::from_ok(acc),\n+        None => try { acc },\n     }\n }\n \n@@ -1280,7 +1280,7 @@ where\n         #[inline]\n         fn find<T, B>(\n             f: &mut impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), B> + '_ {\n+        ) -> impl FnMut((), T) -> ControlFlow<B> + '_ {\n             move |(), x| match f(x) {\n                 Some(x) => ControlFlow::Break(x),\n                 None => ControlFlow::CONTINUE,\n@@ -1660,7 +1660,7 @@ impl<I: Iterator> Iterator for Peekable<I> {\n         R: Try<Ok = B>,\n     {\n         let acc = match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n+            Some(None) => return try { init },\n             Some(Some(v)) => f(init, v)?,\n             None => init,\n         };\n@@ -1703,7 +1703,7 @@ where\n         R: Try<Ok = B>,\n     {\n         match self.peeked.take() {\n-            Some(None) => Try::from_ok(init),\n+            Some(None) => try { init },\n             Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n                 Ok(acc) => f(acc, v),\n                 Err(e) => {\n@@ -1938,7 +1938,7 @@ where\n         if !self.flag {\n             match self.next() {\n                 Some(v) => init = fold(init, v)?,\n-                None => return Try::from_ok(init),\n+                None => return try { init },\n             }\n         }\n         self.iter.try_fold(init, fold)\n@@ -2059,19 +2059,19 @@ where\n             flag: &'a mut bool,\n             p: &'a mut impl FnMut(&T) -> bool,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| {\n                 if p(&x) {\n                     ControlFlow::from_try(fold(acc, x))\n                 } else {\n                     *flag = true;\n-                    ControlFlow::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(try { acc })\n                 }\n             }\n         }\n \n         if self.flag {\n-            Try::from_ok(init)\n+            try { init }\n         } else {\n             let flag = &mut self.flag;\n             let p = &mut self.predicate;\n@@ -2180,7 +2180,7 @@ where\n         let Self { iter, predicate } = self;\n         iter.try_fold(init, |acc, x| match predicate(x) {\n             Some(item) => ControlFlow::from_try(fold(acc, item)),\n-            None => ControlFlow::Break(Try::from_ok(acc)),\n+            None => ControlFlow::Break(try { acc }),\n         })\n         .into_try()\n     }\n@@ -2316,7 +2316,7 @@ where\n         if n > 0 {\n             // nth(n) skips n+1\n             if self.iter.nth(n - 1).is_none() {\n-                return Try::from_ok(init);\n+                return try { init };\n             }\n         }\n         self.iter.try_fold(init, fold)\n@@ -2372,7 +2372,7 @@ where\n         fn check<T, Acc, R: Try<Ok = Acc>>(\n             mut n: usize,\n             mut fold: impl FnMut(Acc, T) -> R,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> {\n             move |acc, x| {\n                 n -= 1;\n                 let r = fold(acc, x);\n@@ -2381,11 +2381,7 @@ where\n         }\n \n         let n = self.len();\n-        if n == 0 {\n-            Try::from_ok(init)\n-        } else {\n-            self.iter.try_rfold(init, check(n, fold)).into_try()\n-        }\n+        if n == 0 { try { init } } else { self.iter.try_rfold(init, check(n, fold)).into_try() }\n     }\n \n     fn rfold<Acc, Fold>(mut self, init: Acc, fold: Fold) -> Acc\n@@ -2500,7 +2496,7 @@ where\n         fn check<'a, T, Acc, R: Try<Ok = Acc>>(\n             n: &'a mut usize,\n             mut fold: impl FnMut(Acc, T) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| {\n                 *n -= 1;\n                 let r = fold(acc, x);\n@@ -2509,7 +2505,7 @@ where\n         }\n \n         if self.n == 0 {\n-            Try::from_ok(init)\n+            try { init }\n         } else {\n             let n = &mut self.n;\n             self.iter.try_fold(init, check(n, fold)).into_try()\n@@ -2587,11 +2583,11 @@ where\n         R: Try<Ok = Acc>,\n     {\n         if self.n == 0 {\n-            Try::from_ok(init)\n+            try { init }\n         } else {\n             let len = self.iter.len();\n             if len > self.n && self.iter.nth_back(len - self.n - 1).is_none() {\n-                Try::from_ok(init)\n+                try { init }\n             } else {\n                 self.iter.try_rfold(init, fold)\n             }\n@@ -2685,9 +2681,9 @@ where\n             state: &'a mut St,\n             f: &'a mut impl FnMut(&mut St, T) -> Option<B>,\n             mut fold: impl FnMut(Acc, B) -> R + 'a,\n-        ) -> impl FnMut(Acc, T) -> ControlFlow<Acc, R> + 'a {\n+        ) -> impl FnMut(Acc, T) -> ControlFlow<R, Acc> + 'a {\n             move |acc, x| match f(state, x) {\n-                None => ControlFlow::Break(Try::from_ok(acc)),\n+                None => ControlFlow::Break(try { acc }),\n                 Some(x) => ControlFlow::from_try(fold(acc, x)),\n             }\n         }\n@@ -2951,7 +2947,7 @@ where\n                 Ok(x) => ControlFlow::from_try(f(acc, x)),\n                 Err(e) => {\n                     *error = Err(e);\n-                    ControlFlow::Break(Try::from_ok(acc))\n+                    ControlFlow::Break(try { acc })\n                 }\n             })\n             .into_try()"}, {"sha": "cd8ab11cb842641ede0ed39576e8328ad2ff0fa9", "filename": "library/core/src/iter/range.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Frange.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -713,7 +713,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         R: Try<Ok = B>,\n     {\n         if self.is_empty() {\n-            return Try::from_ok(init);\n+            return try { init };\n         }\n \n         let mut accum = init;\n@@ -731,7 +731,7 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n             accum = f(accum, self.start.clone())?;\n         }\n \n-        Try::from_ok(accum)\n+        try { accum }\n     }\n \n     #[inline]\n@@ -818,7 +818,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n         R: Try<Ok = B>,\n     {\n         if self.is_empty() {\n-            return Try::from_ok(init);\n+            return try { init };\n         }\n \n         let mut accum = init;\n@@ -836,7 +836,7 @@ impl<A: Step> DoubleEndedIterator for ops::RangeInclusive<A> {\n             accum = f(accum, self.start.clone())?;\n         }\n \n-        Try::from_ok(accum)\n+        try { accum }\n     }\n \n     #[inline]"}, {"sha": "6f8cb6b5a65b6fcdef683a4b24b300cbfd1037e0", "filename": "library/core/src/iter/traits/double_ended.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -122,6 +122,9 @@ pub trait DoubleEndedIterator: Iterator {\n     /// assert_eq!(iter.advance_back_by(0), Ok(()));\n     /// assert_eq!(iter.advance_back_by(100), Err(1)); // only `&3` was skipped\n     /// ```\n+    ///\n+    /// [`Ok(())`]: Ok\n+    /// [`Err(k)`]: Err\n     #[inline]\n     #[unstable(feature = \"iter_advance_by\", reason = \"recently added\", issue = \"77404\")]\n     fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n@@ -221,7 +224,7 @@ pub trait DoubleEndedIterator: Iterator {\n         while let Some(x) = self.next_back() {\n             accum = f(accum, x)?;\n         }\n-        Try::from_ok(accum)\n+        try { accum }\n     }\n \n     /// An iterator method that reduces the iterator's elements to a single,\n@@ -336,9 +339,7 @@ pub trait DoubleEndedIterator: Iterator {\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(\n-            mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {\n             move |(), x| {\n                 if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::CONTINUE }\n             }"}, {"sha": "7fc60caec2a736fe5ee56895dc3575188c43bdab", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -289,12 +289,12 @@ pub trait Iterator {\n     /// This method will eagerly skip `n` elements by calling [`next`] up to `n`\n     /// times until [`None`] is encountered.\n     ///\n-    /// `advance_by(n)` will return [`Ok(())`] if the iterator successfully advances by\n-    /// `n` elements, or [`Err(k)`] if [`None`] is encountered, where `k` is the number\n+    /// `advance_by(n)` will return [`Ok(())`][Ok] if the iterator successfully advances by\n+    /// `n` elements, or [`Err(k)`][Err] if [`None`] is encountered, where `k` is the number\n     /// of elements the iterator is advanced by before running out of elements (i.e. the\n     /// length of the iterator). Note that `k` is always less than `n`.\n     ///\n-    /// Calling `advance_by(0)` does not consume any elements and always returns [`Ok(())`].\n+    /// Calling `advance_by(0)` does not consume any elements and always returns [`Ok(())`][Ok].\n     ///\n     /// [`next`]: Iterator::next\n     ///\n@@ -1887,7 +1887,7 @@ pub trait Iterator {\n         while let Some(x) = self.next() {\n             accum = f(accum, x)?;\n         }\n-        Try::from_ok(accum)\n+        try { accum }\n     }\n \n     /// An iterator method that applies a fallible function to each item in the\n@@ -2109,7 +2109,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {\n             move |(), x| {\n                 if f(x) { ControlFlow::CONTINUE } else { ControlFlow::BREAK }\n             }\n@@ -2162,7 +2162,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<(), ()> {\n+        fn check<T>(mut f: impl FnMut(T) -> bool) -> impl FnMut((), T) -> ControlFlow<()> {\n             move |(), x| {\n                 if f(x) { ControlFlow::BREAK } else { ControlFlow::CONTINUE }\n             }\n@@ -2222,9 +2222,7 @@ pub trait Iterator {\n         P: FnMut(&Self::Item) -> bool,\n     {\n         #[inline]\n-        fn check<T>(\n-            mut predicate: impl FnMut(&T) -> bool,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), T> {\n+        fn check<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut((), T) -> ControlFlow<T> {\n             move |(), x| {\n                 if predicate(&x) { ControlFlow::Break(x) } else { ControlFlow::CONTINUE }\n             }\n@@ -2255,9 +2253,7 @@ pub trait Iterator {\n         F: FnMut(Self::Item) -> Option<B>,\n     {\n         #[inline]\n-        fn check<T, B>(\n-            mut f: impl FnMut(T) -> Option<B>,\n-        ) -> impl FnMut((), T) -> ControlFlow<(), B> {\n+        fn check<T, B>(mut f: impl FnMut(T) -> Option<B>) -> impl FnMut((), T) -> ControlFlow<B> {\n             move |(), x| match f(x) {\n                 Some(x) => ControlFlow::Break(x),\n                 None => ControlFlow::CONTINUE,\n@@ -2296,7 +2292,7 @@ pub trait Iterator {\n         R: Try<Ok = bool>,\n     {\n         #[inline]\n-        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<(), Result<T, R::Error>>\n+        fn check<F, T, R>(mut f: F) -> impl FnMut((), T) -> ControlFlow<Result<T, R::Error>>\n         where\n             F: FnMut(&T) -> R,\n             R: Try<Ok = bool>,"}, {"sha": "6cb240d1730edf4a1797fae4d98571c66065bba6", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -63,6 +63,7 @@\n #![warn(missing_debug_implementations)]\n #![allow(explicit_outlives_requirements)]\n #![allow(incomplete_features)]\n+#![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n #![feature(asm)]\n@@ -129,9 +130,10 @@\n #![feature(str_split_as_str)]\n #![feature(str_split_inclusive_as_str)]\n #![feature(transparent_unions)]\n+#![feature(try_blocks)]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]\n-#![feature(untagged_unions)]\n+#![cfg_attr(bootstrap, feature(untagged_unions))]\n #![feature(unwind_attributes)]\n #![feature(variant_count)]\n #![feature(tbm_target_feature)]"}, {"sha": "ac45e819cf67a23a82186b45adb3942606ea6b0f", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -10,7 +10,7 @@ macro_rules! panic {\n         $crate::panicking::panic($msg)\n     );\n     ($msg:expr) => (\n-        $crate::panic!(\"{}\", $crate::convert::identity::<&str>($msg))\n+        $crate::panicking::panic_str($msg)\n     );\n     ($msg:expr,) => (\n         $crate::panic!($msg)"}, {"sha": "295a876773c48779255894975912de187d5b6c16", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -2045,7 +2045,8 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_transmute)]\n+            #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+            #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n@@ -2193,7 +2194,8 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_transmute)]\n+            #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+            #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them"}, {"sha": "bdea0ea3b08c026aaf518462aa941c96987544b9", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1803,7 +1803,8 @@ assert_eq!(\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute them to arrays of bytes\n-            #[allow_internal_unstable(const_fn_transmute)]\n+            #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+            #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n                 // SAFETY: integers are plain old datatypes so we can always transmute them to\n@@ -1951,7 +1952,8 @@ fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT),\n             #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n             // SAFETY: const sound because integers are plain old datatypes so we can always\n             // transmute to them\n-            #[allow_internal_unstable(const_fn_transmute)]\n+            #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+            #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n                 // SAFETY: integers are plain old datatypes so we can always transmute to them"}, {"sha": "92090d8e6fca7fe875ede962cd77d024f911169c", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -302,7 +302,7 @@ sub_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n #[lang = \"mul\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_on_unimplemented(\n-    message = \"cannot multiply `{Rhs}` to `{Self}`\",\n+    message = \"cannot multiply `{Self}` by `{Rhs}`\",\n     label = \"no implementation for `{Self} * {Rhs}`\"\n )]\n #[doc(alias = \"*\")]\n@@ -826,7 +826,7 @@ sub_assign_impl! { usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 f32 f64 }\n #[lang = \"mul_assign\"]\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n #[rustc_on_unimplemented(\n-    message = \"cannot multiply-assign `{Rhs}` to `{Self}`\",\n+    message = \"cannot multiply-assign `{Self}` by `{Rhs}`\",\n     label = \"no implementation for `{Self} *= {Rhs}`\"\n )]\n #[doc(alias = \"*\")]"}, {"sha": "5ede1ba8e2c104076aa205dff4ff2edd5e87a738", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -3,15 +3,15 @@ use crate::ops::Try;\n /// Used to make try_fold closures more like normal loops\n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n #[derive(Debug, Clone, Copy, PartialEq)]\n-pub enum ControlFlow<C, B> {\n+pub enum ControlFlow<B, C = ()> {\n     /// Continue in the loop, using the given value for the next iteration\n     Continue(C),\n     /// Exit the loop, yielding the given value\n     Break(B),\n }\n \n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n-impl<C, B> Try for ControlFlow<C, B> {\n+impl<B, C> Try for ControlFlow<B, C> {\n     type Ok = C;\n     type Error = B;\n     #[inline]\n@@ -31,7 +31,21 @@ impl<C, B> Try for ControlFlow<C, B> {\n     }\n }\n \n-impl<C, B> ControlFlow<C, B> {\n+impl<B, C> ControlFlow<B, C> {\n+    /// Returns `true` if this is a `Break` variant.\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn is_break(&self) -> bool {\n+        matches!(*self, ControlFlow::Break(_))\n+    }\n+\n+    /// Returns `true` if this is a `Continue` variant.\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn is_continue(&self) -> bool {\n+        matches!(*self, ControlFlow::Continue(_))\n+    }\n+\n     /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n     /// `ControlFlow` was `Break` and `None` otherwise.\n     #[inline]\n@@ -44,7 +58,7 @@ impl<C, B> ControlFlow<C, B> {\n     }\n }\n \n-impl<R: Try> ControlFlow<R::Ok, R> {\n+impl<R: Try> ControlFlow<R, R::Ok> {\n     /// Create a `ControlFlow` from any type implementing `Try`.\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n     #[inline]\n@@ -66,7 +80,7 @@ impl<R: Try> ControlFlow<R::Ok, R> {\n     }\n }\n \n-impl<B> ControlFlow<(), B> {\n+impl<B> ControlFlow<B, ()> {\n     /// It's frequently the case that there's no value needed with `Continue`,\n     /// so this provides a way to avoid typing `(())`, if you prefer it.\n     ///\n@@ -88,7 +102,7 @@ impl<B> ControlFlow<(), B> {\n     pub const CONTINUE: Self = ControlFlow::Continue(());\n }\n \n-impl<C> ControlFlow<C, ()> {\n+impl<C> ControlFlow<(), C> {\n     /// APIs like `try_for_each` don't need values with `Break`,\n     /// so this provides a way to avoid typing `(())`, if you prefer it.\n     ///"}, {"sha": "1d67e65e51f5f16effad651f589cd99b13a2163b", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 173, "deletions": 41, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,5 +1,9 @@\n use crate::fmt;\n use crate::hash::Hash;\n+use crate::slice::index::{\n+    slice_end_index_len_fail, slice_end_index_overflow_fail, slice_index_order_fail,\n+    slice_start_index_overflow_fail,\n+};\n \n /// An unbounded range (`..`).\n ///\n@@ -19,20 +23,20 @@ use crate::hash::Hash;\n ///\n /// ```compile_fail,E0277\n /// for i in .. {\n-///    // ...\n+///     // ...\n /// }\n /// ```\n ///\n /// Used as a [slicing index], `RangeFull` produces the full array as a slice.\n ///\n /// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);  // RangeFull\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]); // This is the `RangeFull`\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n /// ```\n ///\n /// [slicing index]: crate::slice::SliceIndex\n@@ -52,22 +56,26 @@ impl fmt::Debug for RangeFull {\n /// A (half-open) range bounded inclusively below and exclusively above\n /// (`start..end`).\n ///\n-/// The `Range` `start..end` contains all values with `x >= start` and\n-/// `x < end`. It is empty unless `start < end`.\n+/// The range `start..end` contains all values with `start <= x < end`.\n+/// It is empty if `start >= end`.\n ///\n /// # Examples\n ///\n+/// The `start..end` syntax is a `Range`:\n+///\n /// ```\n /// assert_eq!((3..5), std::ops::Range { start: 3, end: 5 });\n /// assert_eq!(3 + 4 + 5, (3..6).sum());\n+/// ```\n ///\n+/// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);  // Range\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]); // This is a `Range`\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n /// ```\n #[lang = \"Range\"]\n #[doc(alias = \"..\")]\n@@ -160,17 +168,21 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n ///\n /// # Examples\n ///\n+/// The `start..` syntax is a `RangeFrom`:\n+///\n /// ```\n /// assert_eq!((2..), std::ops::RangeFrom { start: 2 });\n /// assert_eq!(2 + 3 + 4, (2..).take(3).sum());\n+/// ```\n ///\n+/// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);  // RangeFrom\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]); // This is a `RangeFrom`\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n /// ```\n #[lang = \"RangeFrom\"]\n #[doc(alias = \"..\")]\n@@ -244,12 +256,12 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n ///\n /// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);  // RangeTo\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]); // This is a `RangeTo`\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n /// ```\n ///\n /// [slicing index]: crate::slice::SliceIndex\n@@ -310,17 +322,21 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n ///\n /// # Examples\n ///\n+/// The `start..=end` syntax is a `RangeInclusive`:\n+///\n /// ```\n /// assert_eq!((3..=5), std::ops::RangeInclusive::new(3, 5));\n /// assert_eq!(3 + 4 + 5, (3..=5).sum());\n+/// ```\n ///\n+/// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);  // RangeInclusive\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]);\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]); // This is a `RangeInclusive`\n /// ```\n #[lang = \"RangeInclusive\"]\n #[doc(alias = \"..=\")]\n@@ -430,6 +446,20 @@ impl<Idx> RangeInclusive<Idx> {\n     }\n }\n \n+impl RangeInclusive<usize> {\n+    /// Converts to an exclusive `Range` for `SliceIndex` implementations.\n+    /// The caller is responsible for dealing with `end == usize::MAX`.\n+    #[inline]\n+    pub(crate) fn into_slice_range(self) -> Range<usize> {\n+        // If we're not exhausted, we want to simply slice `start..end + 1`.\n+        // If we are exhausted, then slicing with `end + 1..end + 1` gives us an\n+        // empty range that is still subject to bounds-checks for that endpoint.\n+        let exclusive_end = self.end + 1;\n+        let start = if self.exhausted { exclusive_end } else { self.start };\n+        start..exclusive_end\n+    }\n+}\n+\n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n@@ -463,6 +493,16 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(0.0..=f32::NAN).contains(&0.0));\n     /// assert!(!(f32::NAN..=1.0).contains(&1.0));\n     /// ```\n+    ///\n+    /// This method always returns `false` after iteration has finished:\n+    ///\n+    /// ```\n+    /// let mut r = 3..=5;\n+    /// assert!(r.contains(&3) && r.contains(&5));\n+    /// for _ in r.by_ref() {}\n+    /// // Precise field values are unspecified here\n+    /// assert!(!r.contains(&3) && !r.contains(&5));\n+    /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     pub fn contains<U>(&self, item: &U) -> bool\n     where\n@@ -534,12 +574,12 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n ///\n /// ```\n /// let arr = [0, 1, 2, 3, 4];\n-/// assert_eq!(arr[ ..  ], [0,1,2,3,4]);\n-/// assert_eq!(arr[ .. 3], [0,1,2    ]);\n-/// assert_eq!(arr[ ..=3], [0,1,2,3  ]);  // RangeToInclusive\n-/// assert_eq!(arr[1..  ], [  1,2,3,4]);\n-/// assert_eq!(arr[1.. 3], [  1,2    ]);\n-/// assert_eq!(arr[1..=3], [  1,2,3  ]);\n+/// assert_eq!(arr[ ..  ], [0, 1, 2, 3, 4]);\n+/// assert_eq!(arr[ .. 3], [0, 1, 2      ]);\n+/// assert_eq!(arr[ ..=3], [0, 1, 2, 3   ]); // This is a `RangeToInclusive`\n+/// assert_eq!(arr[1..  ], [   1, 2, 3, 4]);\n+/// assert_eq!(arr[1.. 3], [   1, 2      ]);\n+/// assert_eq!(arr[1..=3], [   1, 2, 3   ]);\n /// ```\n ///\n /// [slicing index]: crate::slice::SliceIndex\n@@ -661,9 +701,9 @@ impl<T: Clone> Bound<&T> {\n     }\n }\n \n-#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n+#[stable(feature = \"collections_range\", since = \"1.28.0\")]\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///\n@@ -701,6 +741,92 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n     fn end_bound(&self) -> Bound<&T>;\n \n+    /// Performs bounds-checking of this range.\n+    ///\n+    /// The returned [`Range`] is safe to pass to [`slice::get_unchecked`] and\n+    /// [`slice::get_unchecked_mut`] for slices of the given length.\n+    ///\n+    /// [`slice::get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n+    /// [`slice::get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the range would be out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(range_bounds_assert_len)]\n+    ///\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(1..2, (1..2).assert_len(v.len()));\n+    /// assert_eq!(0..2, (..2).assert_len(v.len()));\n+    /// assert_eq!(1..3, (1..).assert_len(v.len()));\n+    /// ```\n+    ///\n+    /// Panics when [`Index::index`] would panic:\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_bounds_assert_len)]\n+    ///\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// (2..1).assert_len(3);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_bounds_assert_len)]\n+    ///\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// (1..4).assert_len(3);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(range_bounds_assert_len)]\n+    ///\n+    /// use std::ops::RangeBounds;\n+    ///\n+    /// (1..=usize::MAX).assert_len(3);\n+    /// ```\n+    ///\n+    /// [`Index::index`]: crate::ops::Index::index\n+    #[track_caller]\n+    #[unstable(feature = \"range_bounds_assert_len\", issue = \"76393\")]\n+    fn assert_len(self, len: usize) -> Range<usize>\n+    where\n+        Self: RangeBounds<usize>,\n+    {\n+        let start: Bound<&usize> = self.start_bound();\n+        let start = match start {\n+            Bound::Included(&start) => start,\n+            Bound::Excluded(start) => {\n+                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end: Bound<&usize> = self.end_bound();\n+        let end = match end {\n+            Bound::Included(end) => {\n+                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+            }\n+            Bound::Excluded(&end) => end,\n+            Bound::Unbounded => len,\n+        };\n+\n+        if start > end {\n+            slice_index_order_fail(start, end);\n+        }\n+        if end > len {\n+            slice_end_index_len_fail(end, len);\n+        }\n+\n+        Range { start, end }\n+    }\n+\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -779,7 +905,13 @@ impl<T> RangeBounds<T> for RangeInclusive<T> {\n         Included(&self.start)\n     }\n     fn end_bound(&self) -> Bound<&T> {\n-        Included(&self.end)\n+        if self.exhausted {\n+            // When the iterator is exhausted, we usually have start == end,\n+            // but we want the range to appear empty, containing nothing.\n+            Excluded(&self.end)\n+        } else {\n+            Included(&self.end)\n+        }\n     }\n }\n "}, {"sha": "3daf26208b937b3336f3675661ae897e5070bc1b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -562,6 +562,36 @@ impl<T> Option<T> {\n         }\n     }\n \n+    /// Inserts `value` into the option then returns a mutable reference to it.\n+    ///\n+    /// If the option already contains a value, the old value is dropped.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(option_insert)]\n+    ///\n+    /// let mut opt = None;\n+    /// let val = opt.insert(1);\n+    /// assert_eq!(*val, 1);\n+    /// assert_eq!(opt.unwrap(), 1);\n+    /// let val = opt.insert(2);\n+    /// assert_eq!(*val, 2);\n+    /// *val = 3;\n+    /// assert_eq!(opt.unwrap(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"option_insert\", reason = \"newly added\", issue = \"78271\")]\n+    pub fn insert(&mut self, value: T) -> &mut T {\n+        *self = Some(value);\n+\n+        match self {\n+            Some(v) => v,\n+            // SAFETY: the code above just filled the option\n+            None => unsafe { hint::unreachable_unchecked() },\n+        }\n+    }\n+\n     /////////////////////////////////////////////////////////////////////////\n     // Iterator constructors\n     /////////////////////////////////////////////////////////////////////////\n@@ -687,6 +717,7 @@ impl<T> Option<T> {\n     /// assert_eq!(Some(4).filter(is_even), Some(4));\n     /// ```\n     ///\n+    /// [`Some(t)`]: Some\n     #[inline]\n     #[stable(feature = \"option_filter\", since = \"1.27.0\")]\n     pub fn filter<P: FnOnce(&T) -> bool>(self, predicate: P) -> Self {\n@@ -791,7 +822,7 @@ impl<T> Option<T> {\n     // Entry-like operations to insert if None and return a reference\n     /////////////////////////////////////////////////////////////////////////\n \n-    /// Inserts `v` into the option if it is [`None`], then\n+    /// Inserts `value` into the option if it is [`None`], then\n     /// returns a mutable reference to the contained value.\n     ///\n     /// # Examples\n@@ -810,12 +841,12 @@ impl<T> Option<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"option_entry\", since = \"1.20.0\")]\n-    pub fn get_or_insert(&mut self, v: T) -> &mut T {\n-        self.get_or_insert_with(|| v)\n+    pub fn get_or_insert(&mut self, value: T) -> &mut T {\n+        self.get_or_insert_with(|| value)\n     }\n \n-    /// Inserts a value computed from `f` into the option if it is [`None`], then\n-    /// returns a mutable reference to the contained value.\n+    /// Inserts a value computed from `f` into the option if it is [`None`],\n+    /// then returns a mutable reference to the contained value.\n     ///\n     /// # Examples\n     ///\n@@ -838,8 +869,8 @@ impl<T> Option<T> {\n             *self = Some(f());\n         }\n \n-        match *self {\n-            Some(ref mut v) => v,\n+        match self {\n+            Some(v) => v,\n             // SAFETY: a `None` variant for `self` would have been replaced by a `Some`\n             // variant in the code above.\n             None => unsafe { hint::unreachable_unchecked() },"}, {"sha": "09dd19b8f5f9385450fa7dc6ce4e5c85eeacf52f", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -50,6 +50,13 @@ pub fn panic(expr: &'static str) -> ! {\n     panic_fmt(fmt::Arguments::new_v1(&[expr], &[]));\n }\n \n+#[inline]\n+#[track_caller]\n+#[cfg_attr(not(bootstrap), lang = \"panic_str\")] // needed for const-evaluated panics\n+pub fn panic_str(expr: &str) -> ! {\n+    panic_fmt(format_args!(\"{}\", expr));\n+}\n+\n #[cold]\n #[cfg_attr(not(feature = \"panic_immediate_abort\"), inline(never))]\n #[track_caller]"}, {"sha": "0b9c733f7feadfdbcfe4949a4787ea3c134d2698", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -781,6 +781,34 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     }\n }\n \n+impl<T: ?Sized> Pin<&'static T> {\n+    /// Get a pinned reference from a static reference.\n+    ///\n+    /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n+    /// never ends.\n+    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    pub const fn static_ref(r: &'static T) -> Pin<&'static T> {\n+        // SAFETY: The 'static borrow guarantees the data will not be\n+        // moved/invalidated until it gets dropped (which is never).\n+        unsafe { Pin::new_unchecked(r) }\n+    }\n+}\n+\n+impl<T: ?Sized> Pin<&'static mut T> {\n+    /// Get a pinned mutable reference from a static mutable reference.\n+    ///\n+    /// This is safe, because `T` is borrowed for the `'static` lifetime, which\n+    /// never ends.\n+    #[unstable(feature = \"pin_static_ref\", issue = \"78186\")]\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    pub const fn static_mut(r: &'static mut T) -> Pin<&'static mut T> {\n+        // SAFETY: The 'static borrow guarantees the data will not be\n+        // moved/invalidated until it gets dropped (which is never).\n+        unsafe { Pin::new_unchecked(r) }\n+    }\n+}\n+\n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<P: Deref> Deref for Pin<P> {\n     type Target = P::Target;"}, {"sha": "bca3be56ba5f525a7ba6364d53e7a200f02b3eac", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -229,6 +229,16 @@ pub(crate) struct FatPtr<T> {\n     pub(crate) len: usize,\n }\n \n+// Manual impl needed to avoid `T: Clone` bound.\n+impl<T> Clone for FatPtr<T> {\n+    fn clone(&self) -> Self {\n+        *self\n+    }\n+}\n+\n+// Manual impl needed to avoid `T: Copy` bound.\n+impl<T> Copy for FatPtr<T> {}\n+\n /// Forms a raw slice from a pointer and a length.\n ///\n /// The `len` argument is the number of **elements**, not the number of bytes."}, {"sha": "660c8a2da5da04ac3a8006d05ea6bd830e80cd93", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 11, "deletions": 88, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,6 +1,6 @@\n //! Indexing implementations for `[T]`.\n \n-use crate::ops::{self, Bound, Range, RangeBounds};\n+use crate::ops;\n use crate::ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -37,104 +37,31 @@ fn slice_start_index_len_fail(index: usize, len: usize) -> ! {\n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(super) fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n+pub(crate) fn slice_end_index_len_fail(index: usize, len: usize) -> ! {\n     panic!(\"range end index {} out of range for slice of length {}\", index, len);\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(super) fn slice_index_order_fail(index: usize, end: usize) -> ! {\n+pub(crate) fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(super) fn slice_start_index_overflow_fail() -> ! {\n+pub(crate) fn slice_start_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice from after maximum usize\");\n }\n \n #[inline(never)]\n #[cold]\n #[track_caller]\n-pub(super) fn slice_end_index_overflow_fail() -> ! {\n+pub(crate) fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n-/// Performs bounds-checking of the given range.\n-/// The returned [`Range`] is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`]\n-/// for slices of the given length.\n-///\n-/// [`get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n-/// [`get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n-///\n-/// # Panics\n-///\n-/// Panics if the range is out of bounds.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// #![feature(slice_check_range)]\n-/// use std::slice;\n-///\n-/// let v = [10, 40, 30];\n-/// assert_eq!(1..2, slice::check_range(v.len(), 1..2));\n-/// assert_eq!(0..2, slice::check_range(v.len(), ..2));\n-/// assert_eq!(1..3, slice::check_range(v.len(), 1..));\n-/// ```\n-///\n-/// Panics when [`Index::index`] would panic:\n-///\n-/// ```should_panic\n-/// #![feature(slice_check_range)]\n-///\n-/// std::slice::check_range(3, 2..1);\n-/// ```\n-///\n-/// ```should_panic\n-/// #![feature(slice_check_range)]\n-///\n-/// std::slice::check_range(3, 1..4);\n-/// ```\n-///\n-/// ```should_panic\n-/// #![feature(slice_check_range)]\n-///\n-/// std::slice::check_range(3, 1..=usize::MAX);\n-/// ```\n-///\n-/// [`Index::index`]: ops::Index::index\n-#[track_caller]\n-#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n-pub fn check_range<R: RangeBounds<usize>>(len: usize, range: R) -> Range<usize> {\n-    let start = match range.start_bound() {\n-        Bound::Included(&start) => start,\n-        Bound::Excluded(start) => {\n-            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-        }\n-        Bound::Unbounded => 0,\n-    };\n-\n-    let end = match range.end_bound() {\n-        Bound::Included(end) => {\n-            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-        }\n-        Bound::Excluded(&end) => end,\n-        Bound::Unbounded => len,\n-    };\n-\n-    if start > end {\n-        slice_index_order_fail(start, end);\n-    }\n-    if end > len {\n-        slice_end_index_len_fail(end, len);\n-    }\n-\n-    Range { start, end }\n-}\n-\n mod private_slice_index {\n     use super::ops;\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n@@ -449,44 +376,40 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n \n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n \n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n             slice_end_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n "}, {"sha": "b6fd0c4986b64b59ec5b4c73d257fc91c0edccf5", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -29,7 +29,7 @@ pub mod memchr;\n \n mod ascii;\n mod cmp;\n-mod index;\n+pub(crate) mod index;\n mod iter;\n mod raw;\n mod rotate;\n@@ -73,9 +73,6 @@ pub use sort::heapsort;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use index::SliceIndex;\n \n-#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n-pub use index::check_range;\n-\n #[lang = \"slice\"]\n #[cfg(not(test))]\n impl<T> [T] {\n@@ -91,7 +88,8 @@ impl<T> [T] {\n     #[rustc_const_stable(feature = \"const_slice_len\", since = \"1.32.0\")]\n     #[inline]\n     // SAFETY: const sound because we transmute out the length field as a usize (which it must be)\n-    #[allow_internal_unstable(const_fn_union)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_union))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_union))]\n     pub const fn len(&self) -> usize {\n         // SAFETY: this is safe because `&[T]` and `FatPtr<T>` have the same layout.\n         // Only `std` can make this guarantee.\n@@ -1948,10 +1946,10 @@ impl<T> [T] {\n     ///\n     /// The comparator function must define a total ordering for the elements in the slice. If\n     /// the ordering is not total, the order of the elements is unspecified. An order is a\n-    /// total order if it is (for all a, b and c):\n+    /// total order if it is (for all `a`, `b` and `c`):\n     ///\n-    /// * total and antisymmetric: exactly one of a < b, a == b or a > b is true; and\n-    /// * transitive, a < b and b < c implies a < c. The same must hold for both == and >.\n+    /// * total and antisymmetric: exactly one of `a < b`, `a == b` or `a > b` is true, and\n+    /// * transitive, `a < b` and `b < c` implies `a < c`. The same must hold for both `==` and `>`.\n     ///\n     /// For example, while [`f64`] doesn't implement [`Ord`] because `NaN != NaN`, we can use\n     /// `partial_cmp` as our sort function when we know the slice doesn't contain a `NaN`.\n@@ -2714,7 +2712,7 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        let Range { start: src_start, end: src_end } = check_range(self.len(), src);\n+        let Range { start: src_start, end: src_end } = src.assert_len(self.len());\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,"}, {"sha": "952d0598a7c5b961366bb3aceda9a66b1c37edb8", "filename": "library/core/src/str/converts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fconverts.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -157,7 +157,8 @@ pub fn from_utf8_mut(v: &mut [u8]) -> Result<&mut str, Utf8Error> {\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_const_unstable(feature = \"const_str_from_utf8_unchecked\", issue = \"75196\")]\n-#[allow_internal_unstable(const_fn_transmute)]\n+#[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+#[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n     // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n     // Also relies on `&str` and `&[u8]` having the same layout."}, {"sha": "ee9c09fe186c7491e9864bc4f70146c0610222ce", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -219,7 +219,8 @@ impl str {\n     #[rustc_const_stable(feature = \"str_as_bytes\", since = \"1.32.0\")]\n     #[inline(always)]\n     #[allow(unused_attributes)]\n-    #[allow_internal_unstable(const_fn_transmute)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n     pub const fn as_bytes(&self) -> &[u8] {\n         // SAFETY: const sound because we transmute two types with the same layout\n         unsafe { mem::transmute(self) }"}, {"sha": "9cfb5a899877371ce156bb4860324faca2e85eae", "filename": "library/core/src/str/traits.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Ftraits.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -89,7 +89,7 @@ fn str_index_overflow_fail() -> ! {\n /// self`. Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`. Unlike\n /// other indexing operations, this can never panic.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -130,7 +130,7 @@ unsafe impl SliceIndex<str> for ops::RangeFull {\n /// Returns a slice of the given string from the byte range\n /// [`begin`, `end`).\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -237,7 +237,7 @@ unsafe impl SliceIndex<str> for ops::Range<usize> {\n /// Returns a slice of the given string from the byte range [`0`, `end`).\n /// Equivalent to `&self[0 .. end]` or `&mut self[0 .. end]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -308,7 +308,7 @@ unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n /// `len`). Equivalent to `&self[begin .. len]` or `&mut self[begin ..\n /// len]`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// Prior to 1.20.0, these indexing operations were still supported by\n /// direct implementation of `Index` and `IndexMut`.\n@@ -385,7 +385,7 @@ unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n /// self[begin .. end + 1]`, except if `end` has the maximum value for\n /// `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///\n@@ -398,39 +398,35 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n     type Output = str;\n     #[inline]\n     fn get(self, slice: &str) -> Option<&Self::Output> {\n-        if *self.end() == usize::MAX { None } else { (*self.start()..self.end() + 1).get(slice) }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get(slice) }\n     }\n     #[inline]\n     fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n-        if *self.end() == usize::MAX {\n-            None\n-        } else {\n-            (*self.start()..self.end() + 1).get_mut(slice)\n-        }\n+        if *self.end() == usize::MAX { None } else { self.into_slice_range().get_mut(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n+        unsafe { self.into_slice_range().get_unchecked(slice) }\n     }\n     #[inline]\n     unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n         // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n+        unsafe { self.into_slice_range().get_unchecked_mut(slice) }\n     }\n     #[inline]\n     fn index(self, slice: &str) -> &Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index(slice)\n+        self.into_slice_range().index(slice)\n     }\n     #[inline]\n     fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n         if *self.end() == usize::MAX {\n             str_index_overflow_fail();\n         }\n-        (*self.start()..self.end() + 1).index_mut(slice)\n+        self.into_slice_range().index_mut(slice)\n     }\n }\n \n@@ -441,7 +437,7 @@ unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n /// Equivalent to `&self [0 .. end + 1]`, except if `end` has the maximum\n /// value for `usize`.\n ///\n-/// This operation is `O(1)`.\n+/// This operation is *O*(1).\n ///\n /// # Panics\n ///"}, {"sha": "d3c0d9b784139c08974ba0c9e0cce3aa27f7257b", "filename": "library/core/src/task/wake.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftask%2Fwake.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -130,7 +130,8 @@ impl RawWakerVTable {\n     #[rustc_promotable]\n     #[stable(feature = \"futures_api\", since = \"1.36.0\")]\n     #[rustc_const_stable(feature = \"futures_api\", since = \"1.36.0\")]\n-    #[allow_internal_unstable(const_fn_fn_ptr_basics)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_fn_ptr_basics))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_fn_ptr_basics))]\n     pub const fn new(\n         clone: unsafe fn(*const ()) -> RawWaker,\n         wake: unsafe fn(*const ()),"}, {"sha": "9ccc5a08dcbeab1e254f54f9a90fcbadb8bb786d", "filename": "library/core/tests/slice.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fslice.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1341,6 +1341,14 @@ mod slice_index {\n             message: \"out of range\";\n         }\n \n+        in mod rangeinclusive_len {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            bad: data[0..=6];\n+            message: \"out of range\";\n+        }\n+\n         in mod range_len_len {\n             data: [0, 1, 2, 3, 4, 5];\n \n@@ -1358,6 +1366,28 @@ mod slice_index {\n         }\n     }\n \n+    panic_cases! {\n+        in mod rangeinclusive_exhausted {\n+            data: [0, 1, 2, 3, 4, 5];\n+\n+            good: data[0..=5] == [0, 1, 2, 3, 4, 5];\n+            good: data[{\n+                let mut iter = 0..=5;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }] == [];\n+\n+            // 0..=6 is out of range before exhaustion, so it\n+            // stands to reason that it still would be after.\n+            bad: data[{\n+                let mut iter = 0..=6;\n+                iter.by_ref().count(); // exhaust it\n+                iter\n+            }];\n+            message: \"out of range\";\n+        }\n+    }\n+\n     panic_cases! {\n         in mod range_neg_width {\n             data: [0, 1, 2, 3, 4, 5];"}, {"sha": "dfe5df965cfacc043d518f9ddcaa509f7a5cfd5c", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -401,7 +401,8 @@ fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n }\n \n impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn expand1(f: fn(crate::TokenStream) -> crate::TokenStream) -> Self {\n         extern \"C\" fn run(\n             bridge: Bridge<'_>,\n@@ -414,7 +415,8 @@ impl Client<fn(crate::TokenStream) -> crate::TokenStream> {\n }\n \n impl Client<fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream> {\n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn expand2(\n         f: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n@@ -459,7 +461,8 @@ impl ProcMacro {\n         }\n     }\n \n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn custom_derive(\n         trait_name: &'static str,\n         attributes: &'static [&'static str],\n@@ -468,15 +471,17 @@ impl ProcMacro {\n         ProcMacro::CustomDerive { trait_name, attributes, client: Client::expand1(expand) }\n     }\n \n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn attr(\n         name: &'static str,\n         expand: fn(crate::TokenStream, crate::TokenStream) -> crate::TokenStream,\n     ) -> Self {\n         ProcMacro::Attr { name, client: Client::expand2(expand) }\n     }\n \n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn bang(\n         name: &'static str,\n         expand: fn(crate::TokenStream) -> crate::TokenStream,"}, {"sha": "e7c32b10384d4afdcbafad435a220c92f6df50be", "filename": "library/proc_macro/src/bridge/scoped_cell.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fscoped_cell.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -35,7 +35,8 @@ impl<'a, 'b, T: LambdaL> DerefMut for RefMutL<'a, 'b, T> {\n pub struct ScopedCell<T: LambdaL>(Cell<<T as ApplyL<'static>>::Out>);\n \n impl<T: LambdaL> ScopedCell<T> {\n-    #[allow_internal_unstable(const_fn)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn))]\n     pub const fn new(value: <T as ApplyL<'static>>::Out) -> Self {\n         ScopedCell(Cell::new(value))\n     }"}, {"sha": "5a4b69cf6fc1b294b2380ad70f630b813dec1682", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -18,6 +18,7 @@\n     test(no_crate_inject, attr(deny(warnings))),\n     test(attr(allow(dead_code, deprecated, unused_variables, unused_mut)))\n )]\n+#![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n #![feature(nll)]\n #![feature(staged_api)]\n #![feature(const_fn)]"}, {"sha": "5925aa87a3f1398bdd3aabcbca2f8b1789a4f24f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -24,7 +24,7 @@ hashbrown = { version = \"0.9.0\", default-features = false, features = ['rustc-de\n \n # Dependencies of the `backtrace` crate\n addr2line = { version = \"0.13.0\", optional = true, default-features = false }\n-rustc-demangle = { version = \"0.1.4\", features = ['rustc-dep-of-std'] }\n+rustc-demangle = { version = \"0.1.18\", features = ['rustc-dep-of-std'] }\n miniz_oxide = { version = \"0.4.0\", optional = true, default-features = false }\n [dependencies.object]\n version = \"0.20\"\n@@ -42,7 +42,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.15\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.17\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "6df4eb992594fc145595ed074aa7ff8f9f389e7a", "filename": "library/std/src/ffi/c_str.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fffi%2Fc_str.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1383,7 +1383,8 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n-    /// [`str`]: prim@str\n+    /// [`str`]: primitive@str\n+    /// [`&str`]: primitive@str\n     /// [`Borrowed`]: Cow::Borrowed\n     /// [`Owned`]: Cow::Owned\n     /// [U+FFFD]: crate::char::REPLACEMENT_CHARACTER"}, {"sha": "38fd470a1c3227d936500b090e34816b609e8a8e", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -73,10 +73,9 @@ pub fn got_symlink_permission(tmpdir: &TempDir) -> bool {\n     let link = tmpdir.join(\"some_hopefully_unique_link_name\");\n \n     match symlink_file(r\"nonexisting_target\", link) {\n-        Ok(_) => true,\n         // ERROR_PRIVILEGE_NOT_HELD = 1314\n         Err(ref err) if err.raw_os_error() == Some(1314) => false,\n-        Err(_) => true,\n+        Ok(_) | Err(_) => true,\n     }\n }\n "}, {"sha": "9b704ee9ecab2debb5908463fa576ddc0c0c6680", "filename": "library/std/src/keyword_docs.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fkeyword_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fkeyword_docs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -102,7 +102,9 @@ mod break_keyword {}\n \n #[doc(keyword = \"const\")]\n //\n-/// Compile-time constants and deterministic functions.\n+/// Compile-time constants and compile-time evaluable functions.\n+///\n+/// ## Compile-time constants\n ///\n /// Sometimes a certain value is used many times throughout a program, and it can become\n /// inconvenient to copy it over and over. What's more, it's not always possible or desirable to\n@@ -145,15 +147,28 @@ mod break_keyword {}\n ///\n /// Constants, like statics, should always be in `SCREAMING_SNAKE_CASE`.\n ///\n+/// For more detail on `const`, see the [Rust Book] or the [Reference].\n+///\n+/// ## Compile-time evaluable functions\n+///\n+/// The other main use of the `const` keyword is in `const fn`. This marks a function as being\n+/// callable in the body of a `const` or `static` item and in array initializers (commonly called\n+/// \"const contexts\"). `const fn` are restricted in the set of operations they can perform, to\n+/// ensure that they can be evaluated at compile-time. See the [Reference][const-eval] for more\n+/// detail.\n+///\n+/// Turning a `fn` into a `const fn` has no effect on run-time uses of that function.\n+///\n+/// ## Other uses of `const`\n+///\n /// The `const` keyword is also used in raw pointers in combination with `mut`, as seen in `*const\n /// T` and `*mut T`. More about `const` as used in raw pointers can be read at the Rust docs for the [pointer primitive].\n ///\n-/// For more detail on `const`, see the [Rust Book] or the [Reference].\n-///\n /// [pointer primitive]: primitive.pointer.html\n /// [Rust Book]:\n /// ../book/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants\n /// [Reference]: ../reference/items/constant-items.html\n+/// [const-eval]: ../reference/const_eval.html\n mod const_keyword {}\n \n #[doc(keyword = \"continue\")]\n@@ -331,14 +346,15 @@ mod else_keyword {}\n /// When data follows along with a variant, such as with rust's built-in [`Option`] type, the data\n /// is added as the type describes, for example `Option::Some(123)`. The same follows with\n /// struct-like variants, with things looking like `ComplexEnum::LotsOfThings { usual_struct_stuff:\n-/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to () in that they cannot be\n+/// true, blah: \"hello!\".to_string(), }`. Empty Enums are similar to [`!`] in that they cannot be\n /// instantiated at all, and are used mainly to mess with the type system in interesting ways.\n ///\n /// For more information, take a look at the [Rust Book] or the [Reference]\n ///\n /// [ADT]: https://en.wikipedia.org/wiki/Algebraic_data_type\n /// [Rust Book]: ../book/ch06-01-defining-an-enum.html\n /// [Reference]: ../reference/items/enumerations.html\n+/// [`!`]: primitive.never.html\n mod enum_keyword {}\n \n #[doc(keyword = \"extern\")]"}, {"sha": "96a7755c688219d6a1a30c1448e21745e1273cbb", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -206,6 +206,7 @@\n #![needs_panic_runtime]\n // std may use features in a platform-specific way\n #![allow(unused_features)]\n+#![cfg_attr(not(bootstrap), feature(rustc_allow_const_fn_unstable))]\n #![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n@@ -259,6 +260,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![feature(external_doc)]\n+#![feature(fmt_as_str)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]\n@@ -319,7 +321,7 @@\n #![feature(unsafe_block_in_unsafe_fn)]\n #![feature(unsafe_cell_get_mut)]\n #![feature(unsafe_cell_raw_get)]\n-#![feature(untagged_unions)]\n+#![cfg_attr(bootstrap, feature(untagged_unions))]\n #![feature(unwind_attributes)]\n #![feature(vec_into_raw_parts)]\n #![feature(wake_trait)]"}, {"sha": "40f5a84bcd520a3f19e1eaf90a34c39daae45802", "filename": "library/std/src/net/addr/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Faddr%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -68,7 +68,7 @@ fn bind_udp_socket_bad() {\n     // returns its own address, it is still an error to bind a UDP socket to\n     // a non-local address, and so we still get an error here in that case.\n \n-    const INPUT_23076: &'static str = \"1200::AB00:1234::2552:7777:1313:34300\";\n+    const INPUT_23076: &str = \"1200::AB00:1234::2552:7777:1313:34300\";\n \n     assert!(crate::net::UdpSocket::bind(INPUT_23076).is_err())\n }"}, {"sha": "bb3ece4c2739f239883ffe5402fa81d66baf3fe2", "filename": "library/std/src/net/ip.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fip.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -456,10 +456,7 @@ impl Ipv4Addr {\n     #[rustc_const_unstable(feature = \"const_ipv4\", issue = \"76205\")]\n     #[stable(since = \"1.7.0\", feature = \"ip_17\")]\n     pub const fn is_link_local(&self) -> bool {\n-        match self.octets() {\n-            [169, 254, ..] => true,\n-            _ => false,\n-        }\n+        matches!(self.octets(), [169, 254, ..])\n     }\n \n     /// Returns [`true`] if the address appears to be globally routable.\n@@ -1046,7 +1043,8 @@ impl Ipv6Addr {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_const_stable(feature = \"const_ipv6\", since = \"1.32.0\")]\n-    #[allow_internal_unstable(const_fn_transmute)]\n+    #[cfg_attr(not(bootstrap), rustc_allow_const_fn_unstable(const_fn_transmute))]\n+    #[cfg_attr(bootstrap, allow_internal_unstable(const_fn_transmute))]\n     pub const fn new(a: u16, b: u16, c: u16, d: u16, e: u16, f: u16, g: u16, h: u16) -> Ipv6Addr {\n         let addr16 = [\n             a.to_be(),\n@@ -1262,10 +1260,7 @@ impl Ipv6Addr {\n     /// [RFC 4291 errata 4406]: https://www.rfc-editor.org/errata/eid4406\n     #[rustc_const_unstable(feature = \"const_ipv6\", issue = \"76205\")]\n     pub const fn is_unicast_link_local_strict(&self) -> bool {\n-        (self.segments()[0] & 0xffff) == 0xfe80\n-            && (self.segments()[1] & 0xffff) == 0\n-            && (self.segments()[2] & 0xffff) == 0\n-            && (self.segments()[3] & 0xffff) == 0\n+        matches!(self.segments(), [0xfe80, 0, 0, 0, ..])\n     }\n \n     /// Returns [`true`] if the address is a unicast link-local address (`fe80::/10`)."}, {"sha": "fbed3d32d451af446ee6df0ccedb40fd0333b35f", "filename": "library/std/src/net/udp/tests.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Fudp%2Ftests.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -152,19 +152,13 @@ fn udp_clone_two_write() {\n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n         let _t = thread::spawn(move || {\n-            match sock3.send_to(&[1], &addr2) {\n-                Ok(..) => {\n-                    let _ = tx2.send(());\n-                }\n-                Err(..) => {}\n+            if sock3.send_to(&[1], &addr2).is_ok() {\n+                let _ = tx2.send(());\n             }\n             done.send(()).unwrap();\n         });\n-        match sock1.send_to(&[2], &addr2) {\n-            Ok(..) => {\n-                let _ = tx.send(());\n-            }\n-            Err(..) => {}\n+        if sock1.send_to(&[2], &addr2).is_ok() {\n+            let _ = tx.send(());\n         }\n         drop(tx);\n "}, {"sha": "77e6238ca1f528dd11420ae35724608ce9e4cbdf", "filename": "library/std/src/os/vxworks/fs.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Ffs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -26,10 +26,16 @@ pub trait MetadataExt {\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_atime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_mtime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_ctime(&self) -> i64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blksize(&self) -> u64;\n     #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n     fn st_blocks(&self) -> u64;\n@@ -66,12 +72,21 @@ impl MetadataExt for Metadata {\n     fn st_atime(&self) -> i64 {\n         self.as_inner().as_inner().st_atime as i64\n     }\n+    fn st_atime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_mtime(&self) -> i64 {\n         self.as_inner().as_inner().st_mtime as i64\n     }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_ctime(&self) -> i64 {\n         self.as_inner().as_inner().st_ctime as i64\n     }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        0\n+    }\n     fn st_blksize(&self) -> u64 {\n         self.as_inner().as_inner().st_blksize as u64\n     }"}, {"sha": "cb41ddfe2a9bf4d916441ec8632da981d3b933bf", "filename": "library/std/src/os/vxworks/raw.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fvxworks%2Fraw.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -5,3 +5,6 @@ use crate::os::raw::c_ulong;\n \n #[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n pub type pthread_t = c_ulong;\n+\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use libc::{blkcnt_t, blksize_t, dev_t, ino_t, mode_t, nlink_t, off_t, time_t};"}, {"sha": "221ae809e23a2dbbd6beac3a740d99eb86ad3d3b", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -478,10 +478,26 @@ pub fn begin_panic_handler(info: &PanicInfo<'_>) -> ! {\n         }\n     }\n \n+    struct StrPanicPayload(&'static str);\n+\n+    unsafe impl BoxMeUp for StrPanicPayload {\n+        fn take_box(&mut self) -> *mut (dyn Any + Send) {\n+            Box::into_raw(Box::new(self.0))\n+        }\n+\n+        fn get(&mut self) -> &(dyn Any + Send) {\n+            &self.0\n+        }\n+    }\n+\n     let loc = info.location().unwrap(); // The current implementation always returns Some\n     let msg = info.message().unwrap(); // The current implementation always returns Some\n     crate::sys_common::backtrace::__rust_end_short_backtrace(move || {\n-        rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+        if let Some(msg) = msg.as_str() {\n+            rust_panic_with_hook(&mut StrPanicPayload(msg), info.message(), loc);\n+        } else {\n+            rust_panic_with_hook(&mut PanicPayload::new(msg), info.message(), loc);\n+        }\n     })\n }\n "}, {"sha": "a1499467744041b1133a592ed1f8de6593841e87", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1184,7 +1184,7 @@ impl Stdio {\n     }\n \n     /// This stream will be ignored. This is the equivalent of attaching the\n-    /// stream to `/dev/null`\n+    /// stream to `/dev/null`.\n     ///\n     /// # Examples\n     ///"}, {"sha": "5c4e3fd85c41caca2352b02a3060b6dea52f2d99", "filename": "library/std/src/sys/cloudabi/abi/cloudabi.rs", "status": "modified", "additions": 70, "deletions": 63, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fabi%2Fcloudabi.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1910,7 +1910,7 @@ extern \"C\" {\n /// The resolution of the clock.\n #[inline]\n pub unsafe fn clock_res_get(clock_id_: clockid, resolution_: &mut timestamp) -> errno {\n-    cloudabi_sys_clock_res_get(clock_id_, resolution_)\n+    unsafe { cloudabi_sys_clock_res_get(clock_id_, resolution_) }\n }\n \n /// Obtains the time value of a clock.\n@@ -1934,7 +1934,7 @@ pub unsafe fn clock_time_get(\n     precision_: timestamp,\n     time_: *mut timestamp,\n ) -> errno {\n-    cloudabi_sys_clock_time_get(clock_id_, precision_, time_)\n+    unsafe { cloudabi_sys_clock_time_get(clock_id_, precision_, time_) }\n }\n \n /// Wakes up threads waiting on a userspace condition variable.\n@@ -1961,7 +1961,7 @@ pub unsafe fn clock_time_get(\n /// threads, all threads are woken up.\n #[inline]\n pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: nthreads) -> errno {\n-    cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_)\n+    unsafe { cloudabi_sys_condvar_signal(condvar_, scope_, nwaiters_) }\n }\n \n /// Closes a file descriptor.\n@@ -1972,7 +1972,7 @@ pub unsafe fn condvar_signal(condvar_: *mut condvar, scope_: scope, nwaiters_: n\n /// The file descriptor that needs to be closed.\n #[inline]\n pub unsafe fn fd_close(fd_: fd) -> errno {\n-    cloudabi_sys_fd_close(fd_)\n+    unsafe { cloudabi_sys_fd_close(fd_) }\n }\n \n /// Creates a file descriptor.\n@@ -1990,7 +1990,7 @@ pub unsafe fn fd_close(fd_: fd) -> errno {\n /// The file descriptor that has been created.\n #[inline]\n pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n-    cloudabi_sys_fd_create1(type_, fd_)\n+    unsafe { cloudabi_sys_fd_create1(type_, fd_) }\n }\n \n /// Creates a pair of file descriptors.\n@@ -2013,7 +2013,8 @@ pub unsafe fn fd_create1(type_: filetype, fd_: &mut fd) -> errno {\n /// The second file descriptor of the pair.\n #[inline]\n pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno {\n-    cloudabi_sys_fd_create2(type_, fd1_, fd2_)\n+    // SAFETY: the caller must uphold the safety contract for `cloudabi_sys_fd_create2`.\n+    unsafe { cloudabi_sys_fd_create2(type_, fd1_, fd2_) }\n }\n \n /// Synchronizes the data of a file to disk.\n@@ -2025,7 +2026,9 @@ pub unsafe fn fd_create2(type_: filetype, fd1_: &mut fd, fd2_: &mut fd) -> errno\n /// needs to be synchronized to disk.\n #[inline]\n pub unsafe fn fd_datasync(fd_: fd) -> errno {\n-    cloudabi_sys_fd_datasync(fd_)\n+    // SAFETY: the caller must guarantee that `fd` is valid\n+    // for synchronization.\n+    unsafe { cloudabi_sys_fd_datasync(fd_) }\n }\n \n /// Duplicates a file descriptor.\n@@ -2040,7 +2043,7 @@ pub unsafe fn fd_datasync(fd_: fd) -> errno {\n /// The new file descriptor.\n #[inline]\n pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n-    cloudabi_sys_fd_dup(from_, fd_)\n+    unsafe { cloudabi_sys_fd_dup(from_, fd_) }\n }\n \n /// Reads from a file descriptor, without using and updating the\n@@ -2064,7 +2067,7 @@ pub unsafe fn fd_dup(from_: fd, fd_: &mut fd) -> errno {\n /// The number of bytes read.\n #[inline]\n pub unsafe fn fd_pread(fd_: fd, iovs_: &[iovec], offset_: filesize, nread_: &mut usize) -> errno {\n-    cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_)\n+    unsafe { cloudabi_sys_fd_pread(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nread_) }\n }\n \n /// Writes to a file descriptor, without using and updating the\n@@ -2093,7 +2096,7 @@ pub unsafe fn fd_pwrite(\n     offset_: filesize,\n     nwritten_: &mut usize,\n ) -> errno {\n-    cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_)\n+    unsafe { cloudabi_sys_fd_pwrite(fd_, iovs_.as_ptr(), iovs_.len(), offset_, nwritten_) }\n }\n \n /// Reads from a file descriptor.\n@@ -2112,7 +2115,7 @@ pub unsafe fn fd_pwrite(\n /// The number of bytes read.\n #[inline]\n pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n-    cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_)\n+    unsafe { cloudabi_sys_fd_read(fd_, iovs_.as_ptr(), iovs_.len(), nread_) }\n }\n \n /// Atomically replaces a file descriptor by a copy of another\n@@ -2138,7 +2141,7 @@ pub unsafe fn fd_read(fd_: fd, iovs_: &[iovec], nread_: &mut usize) -> errno {\n /// overwritten.\n #[inline]\n pub unsafe fn fd_replace(from_: fd, to_: fd) -> errno {\n-    cloudabi_sys_fd_replace(from_, to_)\n+    unsafe { cloudabi_sys_fd_replace(from_, to_) }\n }\n \n /// Moves the offset of the file descriptor.\n@@ -2166,7 +2169,7 @@ pub unsafe fn fd_seek(\n     whence_: whence,\n     newoffset_: &mut filesize,\n ) -> errno {\n-    cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_)\n+    unsafe { cloudabi_sys_fd_seek(fd_, offset_, whence_, newoffset_) }\n }\n \n /// Gets attributes of a file descriptor.\n@@ -2182,7 +2185,7 @@ pub unsafe fn fd_seek(\n /// attributes are stored.\n #[inline]\n pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n-    cloudabi_sys_fd_stat_get(fd_, buf_)\n+    unsafe { cloudabi_sys_fd_stat_get(fd_, buf_) }\n }\n \n /// Adjusts attributes of a file descriptor.\n@@ -2202,7 +2205,7 @@ pub unsafe fn fd_stat_get(fd_: fd, buf_: *mut fdstat) -> errno {\n /// be adjusted.\n #[inline]\n pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> errno {\n-    cloudabi_sys_fd_stat_put(fd_, buf_, flags_)\n+    unsafe { cloudabi_sys_fd_stat_put(fd_, buf_, flags_) }\n }\n \n /// Synchronizes the data and metadata of a file to disk.\n@@ -2214,7 +2217,7 @@ pub unsafe fn fd_stat_put(fd_: fd, buf_: *const fdstat, flags_: fdsflags) -> err\n /// and metadata needs to be synchronized to disk.\n #[inline]\n pub unsafe fn fd_sync(fd_: fd) -> errno {\n-    cloudabi_sys_fd_sync(fd_)\n+    unsafe { cloudabi_sys_fd_sync(fd_) }\n }\n \n /// Writes to a file descriptor.\n@@ -2233,7 +2236,7 @@ pub unsafe fn fd_sync(fd_: fd) -> errno {\n /// The number of bytes written.\n #[inline]\n pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errno {\n-    cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_)\n+    unsafe { cloudabi_sys_fd_write(fd_, iovs_.as_ptr(), iovs_.len(), nwritten_) }\n }\n \n /// Provides file advisory information on a file descriptor.\n@@ -2256,7 +2259,7 @@ pub unsafe fn fd_write(fd_: fd, iovs_: &[ciovec], nwritten_: &mut usize) -> errn\n /// The advice.\n #[inline]\n pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: advice) -> errno {\n-    cloudabi_sys_file_advise(fd_, offset_, len_, advice_)\n+    unsafe { cloudabi_sys_file_advise(fd_, offset_, len_, advice_) }\n }\n \n /// Forces the allocation of space in a file.\n@@ -2275,7 +2278,7 @@ pub unsafe fn file_advise(fd_: fd, offset_: filesize, len_: filesize, advice_: a\n /// The length of the area that is allocated.\n #[inline]\n pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno {\n-    cloudabi_sys_file_allocate(fd_, offset_, len_)\n+    unsafe { cloudabi_sys_file_allocate(fd_, offset_, len_) }\n }\n \n /// Creates a file of a specified type.\n@@ -2296,7 +2299,7 @@ pub unsafe fn file_allocate(fd_: fd, offset_: filesize, len_: filesize) -> errno\n ///     Creates a directory.\n #[inline]\n pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n-    cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)\n+    unsafe { cloudabi_sys_file_create(fd_, path_.as_ptr(), path_.len(), type_)}\n }\n \n /// Creates a hard link.\n@@ -2320,7 +2323,7 @@ pub unsafe fn file_create(fd_: fd, path_: &[u8], type_: filetype) -> errno {\n /// should be created.\n #[inline]\n pub unsafe fn file_link(fd1_: lookup, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len())\n+    unsafe { cloudabi_sys_file_link(fd1_, path1_.as_ptr(), path1_.len(), fd2_, path2_.as_ptr(), path2_.len()) }\n }\n \n /// Opens a file.\n@@ -2362,7 +2365,7 @@ pub unsafe fn file_open(\n     fds_: *const fdstat,\n     fd_: &mut fd,\n ) -> errno {\n-    cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_)\n+    unsafe { cloudabi_sys_file_open(dirfd_, path_.as_ptr(), path_.len(), oflags_, fds_, fd_) }\n }\n \n /// Reads directory entries from a directory.\n@@ -2402,7 +2405,7 @@ pub unsafe fn file_readdir(\n     cookie_: dircookie,\n     bufused_: &mut usize,\n ) -> errno {\n-    cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_)\n+    unsafe { cloudabi_sys_file_readdir(fd_, buf_.as_mut_ptr() as *mut (), buf_.len(), cookie_, bufused_) }\n }\n \n /// Reads the contents of a symbolic link.\n@@ -2425,14 +2428,16 @@ pub unsafe fn file_readdir(\n /// The number of bytes placed in the buffer.\n #[inline]\n pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &mut usize) -> errno {\n-    cloudabi_sys_file_readlink(\n-        fd_,\n-        path_.as_ptr(),\n-        path_.len(),\n-        buf_.as_mut_ptr(),\n-        buf_.len(),\n-        bufused_,\n-    )\n+    unsafe {\n+        cloudabi_sys_file_readlink(\n+            fd_,\n+            path_.as_ptr(),\n+            path_.len(),\n+            buf_.as_mut_ptr(),\n+            buf_.len(),\n+            bufused_,\n+        )\n+    }\n }\n \n /// Renames a file.\n@@ -2456,14 +2461,16 @@ pub unsafe fn file_readlink(fd_: fd, path_: &[u8], buf_: &mut [u8], bufused_: &m\n /// be renamed.\n #[inline]\n pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_rename(\n-        fd1_,\n-        path1_.as_ptr(),\n-        path1_.len(),\n-        fd2_,\n-        path2_.as_ptr(),\n-        path2_.len(),\n-    )\n+    unsafe {\n+        cloudabi_sys_file_rename(\n+            fd1_,\n+            path1_.as_ptr(),\n+            path1_.len(),\n+            fd2_,\n+            path2_.as_ptr(),\n+            path2_.len(),\n+        )\n+    }\n }\n \n /// Gets attributes of a file by file descriptor.\n@@ -2479,7 +2486,7 @@ pub unsafe fn file_rename(fd1_: fd, path1_: &[u8], fd2_: fd, path2_: &[u8]) -> e\n /// stored.\n #[inline]\n pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n-    cloudabi_sys_file_stat_fget(fd_, buf_)\n+    unsafe { cloudabi_sys_file_stat_fget(fd_, buf_) }\n }\n \n /// Adjusts attributes of a file by file descriptor.\n@@ -2499,7 +2506,7 @@ pub unsafe fn file_stat_fget(fd_: fd, buf_: *mut filestat) -> errno {\n /// be adjusted.\n #[inline]\n pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) -> errno {\n-    cloudabi_sys_file_stat_fput(fd_, buf_, flags_)\n+    unsafe { cloudabi_sys_file_stat_fput(fd_, buf_, flags_) }\n }\n \n /// Gets attributes of a file by path.\n@@ -2520,7 +2527,7 @@ pub unsafe fn file_stat_fput(fd_: fd, buf_: *const filestat, flags_: fsflags) ->\n /// stored.\n #[inline]\n pub unsafe fn file_stat_get(fd_: lookup, path_: &[u8], buf_: *mut filestat) -> errno {\n-    cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_)\n+    unsafe { cloudabi_sys_file_stat_get(fd_, path_.as_ptr(), path_.len(), buf_) }\n }\n \n /// Adjusts attributes of a file by path.\n@@ -2550,7 +2557,7 @@ pub unsafe fn file_stat_put(\n     buf_: *const filestat,\n     flags_: fsflags,\n ) -> errno {\n-    cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_)\n+    unsafe { cloudabi_sys_file_stat_put(fd_, path_.as_ptr(), path_.len(), buf_, flags_) }\n }\n \n /// Creates a symbolic link.\n@@ -2569,7 +2576,7 @@ pub unsafe fn file_stat_put(\n /// link should be created.\n #[inline]\n pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n-    cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len())\n+    unsafe { cloudabi_sys_file_symlink(path1_.as_ptr(), path1_.len(), fd_, path2_.as_ptr(), path2_.len()) }\n }\n \n /// Unlinks a file, or removes a directory.\n@@ -2591,7 +2598,7 @@ pub unsafe fn file_symlink(path1_: &[u8], fd_: fd, path2_: &[u8]) -> errno {\n ///     Otherwise, unlink a file.\n #[inline]\n pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n-    cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_)\n+    unsafe { cloudabi_sys_file_unlink(fd_, path_.as_ptr(), path_.len(), flags_) }\n }\n \n /// Unlocks a write-locked userspace lock.\n@@ -2618,7 +2625,7 @@ pub unsafe fn file_unlink(fd_: fd, path_: &[u8], flags_: ulflags) -> errno {\n /// shared memory.\n #[inline]\n pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n-    cloudabi_sys_lock_unlock(lock_, scope_)\n+    unsafe { cloudabi_sys_lock_unlock(lock_, scope_) }\n }\n \n /// Provides memory advisory information on a region of memory.\n@@ -2633,7 +2640,7 @@ pub unsafe fn lock_unlock(lock_: *mut lock, scope_: scope) -> errno {\n /// The advice.\n #[inline]\n pub unsafe fn mem_advise(mapping_: &mut [u8], advice_: advice) -> errno {\n-    cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_)\n+    unsafe { cloudabi_sys_mem_advise(mapping_.as_mut_ptr() as *mut (), mapping_.len(), advice_) }\n }\n \n /// Creates a memory mapping, making the contents of a file\n@@ -2682,7 +2689,7 @@ pub unsafe fn mem_map(\n     off_: filesize,\n     mem_: &mut *mut (),\n ) -> errno {\n-    cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_)\n+    unsafe { cloudabi_sys_mem_map(addr_, len_, prot_, flags_, fd_, off_, mem_) }\n }\n \n /// Changes the protection of a memory mapping.\n@@ -2696,7 +2703,7 @@ pub unsafe fn mem_map(\n /// New protection options.\n #[inline]\n pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n-    cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_)\n+    unsafe { cloudabi_sys_mem_protect(mapping_.as_mut_ptr() as *mut (), mapping_.len(), prot_) }\n }\n \n /// Synchronizes a region of memory with its physical storage.\n@@ -2710,7 +2717,7 @@ pub unsafe fn mem_protect(mapping_: &mut [u8], prot_: mprot) -> errno {\n /// The method of synchronization.\n #[inline]\n pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n-    cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_)\n+    unsafe { cloudabi_sys_mem_sync(mapping_.as_mut_ptr() as *mut (), mapping_.len(), flags_) }\n }\n \n /// Unmaps a region of memory.\n@@ -2721,7 +2728,7 @@ pub unsafe fn mem_sync(mapping_: &mut [u8], flags_: msflags) -> errno {\n /// The pages that needs to be unmapped.\n #[inline]\n pub unsafe fn mem_unmap(mapping_: &mut [u8]) -> errno {\n-    cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len())\n+    unsafe { cloudabi_sys_mem_unmap(mapping_.as_mut_ptr() as *mut (), mapping_.len()) }\n }\n \n /// Concurrently polls for the occurrence of a set of events.\n@@ -2746,7 +2753,7 @@ pub unsafe fn poll(\n     nsubscriptions_: usize,\n     nevents_: *mut usize,\n ) -> errno {\n-    cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_)\n+    unsafe { cloudabi_sys_poll(in_, out_, nsubscriptions_, nevents_) }\n }\n \n /// Replaces the process by a new executable.\n@@ -2784,7 +2791,7 @@ pub unsafe fn poll(\n /// execution.\n #[inline]\n pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n-    cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len())\n+    unsafe { cloudabi_sys_proc_exec(fd_, data_.as_ptr() as *const (), data_.len(), fds_.as_ptr(), fds_.len()) }\n }\n \n /// Terminates the process normally.\n@@ -2797,7 +2804,7 @@ pub unsafe fn proc_exec(fd_: fd, data_: &[u8], fds_: &[fd]) -> errno {\n /// through [`event.union.proc_terminate.exitcode`](struct.event_proc_terminate.html#structfield.exitcode).\n #[inline]\n pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n-    cloudabi_sys_proc_exit(rval_)\n+    unsafe { cloudabi_sys_proc_exit(rval_) }\n }\n \n /// Forks the process of the calling thread.\n@@ -2822,7 +2829,7 @@ pub unsafe fn proc_exit(rval_: exitcode) -> ! {\n /// initial thread of the child process.\n #[inline]\n pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n-    cloudabi_sys_proc_fork(fd_, tid_)\n+    unsafe { cloudabi_sys_proc_fork(fd_, tid_) }\n }\n \n /// Sends a signal to the process of the calling thread.\n@@ -2837,7 +2844,7 @@ pub unsafe fn proc_fork(fd_: &mut fd, tid_: &mut tid) -> errno {\n /// [`event.union.proc_terminate.signal`](struct.event_proc_terminate.html#structfield.signal).\n #[inline]\n pub unsafe fn proc_raise(sig_: signal) -> errno {\n-    cloudabi_sys_proc_raise(sig_)\n+    unsafe { cloudabi_sys_proc_raise(sig_) }\n }\n \n /// Obtains random data from the kernel random number generator.\n@@ -2853,7 +2860,7 @@ pub unsafe fn proc_raise(sig_: signal) -> errno {\n /// data.\n #[inline]\n pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n-    cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len())\n+    unsafe { cloudabi_sys_random_get(buf_.as_mut_ptr() as *mut (), buf_.len()) }\n }\n \n /// Receives a message on a socket.\n@@ -2871,7 +2878,7 @@ pub unsafe fn random_get(buf_: &mut [u8]) -> errno {\n /// Output parameters.\n #[inline]\n pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) -> errno {\n-    cloudabi_sys_sock_recv(sock_, in_, out_)\n+    unsafe { cloudabi_sys_sock_recv(sock_, in_, out_) }\n }\n \n /// Sends a message on a socket.\n@@ -2888,7 +2895,7 @@ pub unsafe fn sock_recv(sock_: fd, in_: *const recv_in, out_: *mut recv_out) ->\n /// Output parameters.\n #[inline]\n pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) -> errno {\n-    cloudabi_sys_sock_send(sock_, in_, out_)\n+    unsafe { cloudabi_sys_sock_send(sock_, in_, out_) }\n }\n \n /// Shuts down socket send and receive channels.\n@@ -2903,7 +2910,7 @@ pub unsafe fn sock_send(sock_: fd, in_: *const send_in, out_: *mut send_out) ->\n /// down.\n #[inline]\n pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n-    cloudabi_sys_sock_shutdown(sock_, how_)\n+    unsafe { cloudabi_sys_sock_shutdown(sock_, how_) }\n }\n \n /// Creates a new thread within the current process.\n@@ -2917,7 +2924,7 @@ pub unsafe fn sock_shutdown(sock_: fd, how_: sdflags) -> errno {\n /// The thread ID of the new thread.\n #[inline]\n pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n-    cloudabi_sys_thread_create(attr_, tid_)\n+    unsafe { cloudabi_sys_thread_create(attr_, tid_) }\n }\n \n /// Terminates the calling thread.\n@@ -2937,11 +2944,11 @@ pub unsafe fn thread_create(attr_: *mut threadattr, tid_: &mut tid) -> errno {\n /// shared memory.\n #[inline]\n pub unsafe fn thread_exit(lock_: *mut lock, scope_: scope) -> ! {\n-    cloudabi_sys_thread_exit(lock_, scope_)\n+    unsafe { cloudabi_sys_thread_exit(lock_, scope_) }\n }\n \n /// Temporarily yields execution of the calling thread.\n #[inline]\n pub unsafe fn thread_yield() -> errno {\n-    cloudabi_sys_thread_yield()\n+    unsafe { cloudabi_sys_thread_yield() }\n }"}, {"sha": "13f1bc8826e61b92810f957b50483207a4735901", "filename": "library/std/src/sys/cloudabi/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,3 +1,5 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+\n use crate::io::ErrorKind;\n use crate::mem;\n "}, {"sha": "9dafcbc1fba0bb9b5e21964c06e2f94f2a8b8ff6", "filename": "library/std/src/sys/cloudabi/mutex.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -103,7 +103,9 @@ impl ReentrantMutex {\n             };\n             let mut event = MaybeUninit::<abi::event>::uninit();\n             let mut nevents = MaybeUninit::<usize>::uninit();\n-            let ret = abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr());\n+            // SAFE: The caller must to ensure that `event` and `nevents` are initialized.\n+            let ret =\n+                unsafe { abi::poll(&subscription, event.as_mut_ptr(), 1, nevents.as_mut_ptr()) };\n             assert_eq!(ret, abi::errno::SUCCESS, \"Failed to acquire mutex\");\n             let event = event.assume_init();\n             assert_eq!(event.error, abi::errno::SUCCESS, \"Failed to acquire mutex\");"}, {"sha": "829d4c943f11b2b33d743def77331af5136e1270", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -334,10 +334,6 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         Err(Error::from_raw_os_error(22))\n     }\n-\n-    pub fn diverge(&self) -> ! {\n-        loop {}\n-    }\n }\n \n impl DirBuilder {"}, {"sha": "af05310a8d3ab0c8c1118d484de8d817623027bb", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -31,6 +31,7 @@ pub mod net;\n pub mod os;\n pub mod path;\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;"}, {"sha": "f988a019cfedb39f98c22f5fd12543f961d4cacb", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 180, "deletions": 10, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,44 +1,214 @@\n+use crate::cell::UnsafeCell;\n+use crate::collections::VecDeque;\n use crate::ffi::c_void;\n+use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n+use crate::sync::atomic::{spin_loop_hint, AtomicUsize, Ordering};\n use crate::sys::hermit::abi;\n \n+/// This type provides a lock based on busy waiting to realize mutual exclusion\n+///\n+/// # Description\n+///\n+/// This structure behaves a lot like a common mutex. There are some differences:\n+///\n+/// - By using busy waiting, it can be used outside the runtime.\n+/// - It is a so called ticket lock and is completly fair.\n+#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n+#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\n+struct Spinlock<T: ?Sized> {\n+    queue: AtomicUsize,\n+    dequeue: AtomicUsize,\n+    data: UnsafeCell<T>,\n+}\n+\n+unsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\n+unsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n+\n+/// A guard to which the protected data can be accessed\n+///\n+/// When the guard falls out of scope it will release the lock.\n+struct SpinlockGuard<'a, T: ?Sized + 'a> {\n+    dequeue: &'a AtomicUsize,\n+    data: &'a mut T,\n+}\n+\n+impl<T> Spinlock<T> {\n+    pub const fn new(user_data: T) -> Spinlock<T> {\n+        Spinlock {\n+            queue: AtomicUsize::new(0),\n+            dequeue: AtomicUsize::new(1),\n+            data: UnsafeCell::new(user_data),\n+        }\n+    }\n+\n+    #[inline]\n+    fn obtain_lock(&self) {\n+        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n+        while self.dequeue.load(Ordering::SeqCst) != ticket {\n+            spin_loop_hint();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n+        self.obtain_lock();\n+        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for Spinlock<T> {\n+    fn default() -> Spinlock<T> {\n+        Spinlock::new(Default::default())\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        &*self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n+    /// The dropping of the SpinlockGuard will release the lock it was created from.\n+    fn drop(&mut self) {\n+        self.dequeue.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+/// Realize a priority queue for tasks\n+struct PriorityQueue {\n+    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n+    prio_bitmap: u64,\n+}\n+\n+impl PriorityQueue {\n+    pub const fn new() -> PriorityQueue {\n+        PriorityQueue {\n+            queues: [\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None,\n+            ],\n+            prio_bitmap: 0,\n+        }\n+    }\n+\n+    /// Add a task id by its priority to the queue\n+    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n+        let i: usize = prio.into().into();\n+        self.prio_bitmap |= (1 << i) as u64;\n+        if let Some(queue) = &mut self.queues[i] {\n+            queue.push_back(id);\n+        } else {\n+            let mut queue = VecDeque::new();\n+            queue.push_back(id);\n+            self.queues[i] = Some(queue);\n+        }\n+    }\n+\n+    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n+        if let Some(queue) = &mut self.queues[queue_index] {\n+            let id = queue.pop_front();\n+\n+            if queue.is_empty() {\n+                self.prio_bitmap &= !(1 << queue_index as u64);\n+            }\n+\n+            id\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pop the task handle with the highest priority from the queue\n+    pub fn pop(&mut self) -> Option<abi::Tid> {\n+        for i in 0..abi::NO_PRIORITIES {\n+            if self.prio_bitmap & (1 << i) != 0 {\n+                return self.pop_from_queue(i);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+struct MutexInner {\n+    locked: bool,\n+    blocked_task: PriorityQueue,\n+}\n+\n+impl MutexInner {\n+    pub const fn new() -> MutexInner {\n+        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n+    }\n+}\n+\n pub struct Mutex {\n-    inner: *const c_void,\n+    inner: Spinlock<MutexInner>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: ptr::null() }\n+        Mutex { inner: Spinlock::new(MutexInner::new()) }\n     }\n \n     #[inline]\n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        self.inner = Spinlock::new(MutexInner::new());\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::sem_timedwait(self.inner, 0);\n+        loop {\n+            let mut guard = self.inner.lock();\n+            if guard.locked == false {\n+                guard.locked = true;\n+                return;\n+            } else {\n+                let prio = abi::get_priority();\n+                let id = abi::getpid();\n+\n+                guard.blocked_task.push(prio, id);\n+                abi::block_current_task();\n+                drop(guard);\n+                abi::yield_now();\n+            }\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::sem_post(self.inner);\n+        let mut guard = self.inner.lock();\n+        guard.locked = false;\n+        if let Some(tid) = guard.blocked_task.pop() {\n+            abi::wakeup_task(tid);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let result = abi::sem_trywait(self.inner);\n-        result == 0\n+        let mut guard = self.inner.lock();\n+        if guard.locked == false {\n+            guard.locked = true;\n+        }\n+        guard.locked\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.inner);\n-    }\n+    pub unsafe fn destroy(&self) {}\n }\n \n pub struct ReentrantMutex {"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "library/std/src/sys/hermit/process.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,149 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "b4628b649117ed6b353afd45025a9d697e3da818", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -89,6 +89,7 @@ cfg_if::cfg_if! {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as windows_ext;\n     } else if #[cfg(any(target_os = \"cloudabi\",\n+                        target_os = \"hermit\",\n                         target_arch = \"wasm32\",\n                         all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         // On CloudABI and wasm right now the shim below doesn't compile, so"}, {"sha": "8043b7c5213a17306498623c08454a67fe56f820", "filename": "library/std/src/sys/sgx/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fenv.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,9 +1,9 @@\n pub mod os {\n-    pub const FAMILY: &'static str = \"\";\n-    pub const OS: &'static str = \"\";\n-    pub const DLL_PREFIX: &'static str = \"\";\n-    pub const DLL_SUFFIX: &'static str = \".sgxs\";\n-    pub const DLL_EXTENSION: &'static str = \"sgxs\";\n-    pub const EXE_SUFFIX: &'static str = \".sgxs\";\n-    pub const EXE_EXTENSION: &'static str = \"sgxs\";\n+    pub const FAMILY: &str = \"\";\n+    pub const OS: &str = \"\";\n+    pub const DLL_PREFIX: &str = \"\";\n+    pub const DLL_SUFFIX: &str = \".sgxs\";\n+    pub const DLL_EXTENSION: &str = \"sgxs\";\n+    pub const EXE_SUFFIX: &str = \".sgxs\";\n+    pub const EXE_EXTENSION: &str = \"sgxs\";\n }"}, {"sha": "840a7ae04262508abc1bd81fd78a7f8fd4231363", "filename": "library/std/src/sys/sgx/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fpath.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -15,5 +15,5 @@ pub fn parse_prefix(_: &OsStr) -> Option<Prefix<'_>> {\n     None\n }\n \n-pub const MAIN_SEP_STR: &'static str = \"/\";\n+pub const MAIN_SEP_STR: &str = \"/\";\n pub const MAIN_SEP: char = '/';"}, {"sha": "69676472493909b72be73204bc05a7262e595815", "filename": "library/std/src/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fargs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -70,7 +70,8 @@ impl DoubleEndedIterator for Args {\n     target_os = \"haiku\",\n     target_os = \"l4re\",\n     target_os = \"fuchsia\",\n-    target_os = \"redox\"\n+    target_os = \"redox\",\n+    target_os = \"vxworks\"\n ))]\n mod imp {\n     use super::Args;"}, {"sha": "66bbc1c585413906067b8372804ffd948f978829", "filename": "library/std/src/sys/unix/ext/fs.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Ffs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -650,6 +650,9 @@ pub trait MetadataExt {\n     /// ```\n     #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n     fn blocks(&self) -> u64;\n+    #[cfg(target_os = \"vxworks\")]\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    fn attrib(&self) -> u8;\n }\n \n #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n@@ -702,6 +705,10 @@ impl MetadataExt for fs::Metadata {\n     fn blocks(&self) -> u64 {\n         self.st_blocks()\n     }\n+    #[cfg(target_os = \"vxworks\")]\n+    fn attrib(&self) -> u8 {\n+        self.st_attrib()\n+    }\n }\n \n /// Unix-specific extensions for [`fs::FileType`]."}, {"sha": "3615a8a5ee8b0432be4e369993d1cd360cb57a00", "filename": "library/std/src/sys/unix/ext/process.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fprocess.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -16,12 +16,20 @@ pub trait CommandExt {\n     /// `setuid` call in the child process. Failure in the `setuid`\n     /// call will cause the spawn to fail.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn uid(&mut self, id: u32) -> &mut process::Command;\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Similar to `uid`, but sets the group ID of the child process. This has\n     /// the same semantics as the `uid` field.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn gid(&mut self, id: u32) -> &mut process::Command;\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command;\n \n     /// Schedules a closure to be run just before the `exec` function is\n     /// invoked.\n@@ -115,12 +123,20 @@ pub trait CommandExt {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CommandExt for process::Command {\n-    fn uid(&mut self, id: u32) -> &mut process::Command {\n+    fn uid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().uid(id);\n         self\n     }\n \n-    fn gid(&mut self, id: u32) -> &mut process::Command {\n+    fn gid(\n+        &mut self,\n+        #[cfg(not(target_os = \"vxworks\"))] id: u32,\n+        #[cfg(target_os = \"vxworks\")] id: u16,\n+    ) -> &mut process::Command {\n         self.as_inner_mut().gid(id);\n         self\n     }"}, {"sha": "d3a279a23553ee551d7812a86094cad051c441e1", "filename": "library/std/src/sys/unix/fd.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffd.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -200,7 +200,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -217,7 +218,8 @@ impl FileDesc {\n         target_os = \"l4re\",\n         target_os = \"linux\",\n         target_os = \"haiku\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "d27d6e2c5659b65944cfc3de9b2033368bb795e1", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -297,20 +297,38 @@ impl FileAttr {\n \n #[cfg(not(target_os = \"netbsd\"))]\n impl FileAttr {\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn modified(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_mtime as libc::time_t,\n             tv_nsec: self.stat.st_mtime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn modified(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_mtime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn accessed(&self) -> io::Result<SystemTime> {\n         Ok(SystemTime::from(libc::timespec {\n             tv_sec: self.stat.st_atime as libc::time_t,\n             tv_nsec: self.stat.st_atime_nsec as _,\n         }))\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn accessed(&self) -> io::Result<SystemTime> {\n+        Ok(SystemTime::from(libc::timespec {\n+            tv_sec: self.stat.st_atime as libc::time_t,\n+            tv_nsec: 0,\n+        }))\n+    }\n+\n     #[cfg(any(\n         target_os = \"freebsd\",\n         target_os = \"openbsd\",\n@@ -535,12 +553,22 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\"))]\n+    #[cfg(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    ))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\", target_os = \"haiku\")))]\n+    #[cfg(not(any(\n+        target_os = \"solaris\",\n+        target_os = \"illumos\",\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n+    )))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -565,7 +593,8 @@ impl DirEntry {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"fuchsia\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n@@ -603,7 +632,8 @@ impl DirEntry {\n         target_os = \"linux\",\n         target_os = \"emscripten\",\n         target_os = \"l4re\",\n-        target_os = \"haiku\"\n+        target_os = \"haiku\",\n+        target_os = \"vxworks\"\n     ))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes() }\n@@ -757,11 +787,25 @@ impl File {\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fcntl(fd, libc::F_FULLFSYNC)\n         }\n-        #[cfg(target_os = \"linux\")]\n+        #[cfg(any(\n+            target_os = \"freebsd\",\n+            target_os = \"linux\",\n+            target_os = \"android\",\n+            target_os = \"netbsd\",\n+            target_os = \"openbsd\"\n+        ))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fdatasync(fd)\n         }\n-        #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"linux\")))]\n+        #[cfg(not(any(\n+            target_os = \"android\",\n+            target_os = \"freebsd\",\n+            target_os = \"ios\",\n+            target_os = \"linux\",\n+            target_os = \"macos\",\n+            target_os = \"netbsd\",\n+            target_os = \"openbsd\"\n+        )))]\n         unsafe fn os_datasync(fd: c_int) -> c_int {\n             libc::fsync(fd)\n         }\n@@ -901,13 +945,25 @@ impl fmt::Debug for File {\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(target_os = \"vxworks\")]\n+        fn get_path(fd: c_int) -> Option<PathBuf> {\n+            let mut buf = vec![0; libc::PATH_MAX as usize];\n+            let n = unsafe { libc::ioctl(fd, libc::FIOGETNAME, buf.as_ptr()) };\n+            if n == -1 {\n+                return None;\n+            }\n+            let l = buf.iter().position(|&c| c == 0).unwrap();\n+            buf.truncate(l as usize);\n+            Some(PathBuf::from(OsString::from_vec(buf)))\n+        }\n+\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_path(_fd: c_int) -> Option<PathBuf> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None\n         }\n \n-        #[cfg(any(target_os = \"linux\", target_os = \"macos\"))]\n+        #[cfg(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\"))]\n         fn get_mode(fd: c_int) -> Option<(bool, bool)> {\n             let mode = unsafe { libc::fcntl(fd, libc::F_GETFL) };\n             if mode == -1 {\n@@ -921,7 +977,7 @@ impl fmt::Debug for File {\n             }\n         }\n \n-        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\")))]\n+        #[cfg(not(any(target_os = \"linux\", target_os = \"macos\", target_os = \"vxworks\")))]\n         fn get_mode(_fd: c_int) -> Option<(bool, bool)> {\n             // FIXME(#24570): implement this for other Unix platforms\n             None"}, {"sha": "b28c6d85b7c725b7b6667378248d00aa77f426c9", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -220,6 +220,10 @@ where\n     }\n }\n \n+pub fn cvt_nz(error: libc::c_int) -> crate::io::Result<()> {\n+    if error == 0 { Ok(()) } else { Err(crate::io::Error::from_raw_os_error(error)) }\n+}\n+\n // On Unix-like platforms, libc::abort will unregister signal handlers\n // including the SIGABRT handler, preventing the abort from being blocked, and\n // fclose streams, with the side effect of flushing them so libc buffered"}, {"sha": "89c55eb859d0944daec0d28263bc2d72d48f4702", "filename": "library/std/src/sys/unix/mutex.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -1,5 +1,6 @@\n use crate::cell::UnsafeCell;\n use crate::mem::MaybeUninit;\n+use crate::sys::cvt_nz;\n \n pub struct Mutex {\n     inner: UnsafeCell<libc::pthread_mutex_t>,\n@@ -51,14 +52,11 @@ impl Mutex {\n         // PTHREAD_MUTEX_NORMAL which is guaranteed to deadlock if we try to\n         // re-lock it from the same thread, thus avoiding undefined behavior.\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let r = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL);\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(r, 0);\n-        let r = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(r, 0);\n+        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+        let attr = PthreadMutexAttr(&mut attr);\n+        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_NORMAL))\n+            .unwrap();\n+        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n     }\n     #[inline]\n     pub unsafe fn lock(&self) {\n@@ -106,15 +104,11 @@ impl ReentrantMutex {\n \n     pub unsafe fn init(&self) {\n         let mut attr = MaybeUninit::<libc::pthread_mutexattr_t>::uninit();\n-        let result = libc::pthread_mutexattr_init(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result =\n-            libc::pthread_mutexattr_settype(attr.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE);\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutex_init(self.inner.get(), attr.as_ptr());\n-        debug_assert_eq!(result, 0);\n-        let result = libc::pthread_mutexattr_destroy(attr.as_mut_ptr());\n-        debug_assert_eq!(result, 0);\n+        cvt_nz(libc::pthread_mutexattr_init(attr.as_mut_ptr())).unwrap();\n+        let attr = PthreadMutexAttr(&mut attr);\n+        cvt_nz(libc::pthread_mutexattr_settype(attr.0.as_mut_ptr(), libc::PTHREAD_MUTEX_RECURSIVE))\n+            .unwrap();\n+        cvt_nz(libc::pthread_mutex_init(self.inner.get(), attr.0.as_ptr())).unwrap();\n     }\n \n     pub unsafe fn lock(&self) {\n@@ -137,3 +131,14 @@ impl ReentrantMutex {\n         debug_assert_eq!(result, 0);\n     }\n }\n+\n+struct PthreadMutexAttr<'a>(&'a mut MaybeUninit<libc::pthread_mutexattr_t>);\n+\n+impl Drop for PthreadMutexAttr<'_> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let result = libc::pthread_mutexattr_destroy(self.0.as_mut_ptr());\n+            debug_assert_eq!(result, 0);\n+        }\n+    }\n+}"}, {"sha": "74c7db27226ef8a43b6e9f9177daf9914297ba7f", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -77,6 +77,7 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(not(target_os = \"vxworks\"))]\n     pub fn new_pair(fam: c_int, ty: c_int) -> io::Result<(Socket, Socket)> {\n         unsafe {\n             let mut fds = [0, 0];\n@@ -98,6 +99,11 @@ impl Socket {\n         }\n     }\n \n+    #[cfg(target_os = \"vxworks\")]\n+    pub fn new_pair(_fam: c_int, _ty: c_int) -> io::Result<(Socket, Socket)> {\n+        unimplemented!()\n+    }\n+\n     pub fn connect_timeout(&self, addr: &SocketAddr, timeout: Duration) -> io::Result<()> {\n         self.set_nonblocking(true)?;\n         let r = unsafe {\n@@ -366,7 +372,7 @@ impl IntoInner<c_int> for Socket {\n // res_init unconditionally, we call it only when we detect we're linking\n // against glibc version < 2.26. (That is, when we both know its needed and\n // believe it's thread-safe).\n-#[cfg(target_env = \"gnu\")]\n+#[cfg(all(target_env = \"gnu\", not(target_os = \"vxworks\")))]\n fn on_resolver_failure() {\n     use crate::sys;\n \n@@ -378,5 +384,5 @@ fn on_resolver_failure() {\n     }\n }\n \n-#[cfg(not(target_env = \"gnu\"))]\n+#[cfg(any(not(target_env = \"gnu\"), target_os = \"vxworks\"))]\n fn on_resolver_failure() {}"}, {"sha": "d5e14bec7657298e2d4ced4951a300c5fa81ab51", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -37,7 +37,7 @@ cfg_if::cfg_if! {\n }\n \n extern \"C\" {\n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n     #[cfg_attr(\n         any(\n             target_os = \"linux\",\n@@ -67,18 +67,28 @@ extern \"C\" {\n }\n \n /// Returns the platform-specific value of errno\n-#[cfg(not(target_os = \"dragonfly\"))]\n+#[cfg(not(any(target_os = \"dragonfly\", target_os = \"vxworks\")))]\n pub fn errno() -> i32 {\n     unsafe { (*errno_location()) as i32 }\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\")))] // needed for readdir and syscall!\n+#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n #[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn errno() -> i32 {\n+    unsafe { libc::errnoGet() }\n+}\n+\n+#[cfg(target_os = \"vxworks\")]\n+pub fn set_errno(e: i32) {\n+    unsafe { libc::errnoSet(e as c_int) };\n+}\n+\n #[cfg(target_os = \"dragonfly\")]\n pub fn errno() -> i32 {\n     extern \"C\" {\n@@ -439,6 +449,19 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))\n }\n \n+#[cfg(target_os = \"vxworks\")]\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    #[cfg(test)]\n+    use realstd::env;\n+\n+    #[cfg(not(test))]\n+    use crate::env;\n+\n+    let exe_path = env::args().next().unwrap();\n+    let path = path::Path::new(&exe_path);\n+    path.canonicalize()\n+}\n+\n pub struct Env {\n     iter: vec::IntoIter<(OsString, OsString)>,\n     _dont_send_or_sync_me: PhantomData<*mut ()>,\n@@ -568,7 +591,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     unsafe fn fallback() -> Option<OsString> {\n         None\n@@ -577,7 +601,8 @@ pub fn home_dir() -> Option<PathBuf> {\n         target_os = \"android\",\n         target_os = \"ios\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     )))]\n     unsafe fn fallback() -> Option<OsString> {\n         let amt = match libc::sysconf(libc::_SC_GETPW_R_SIZE_MAX) {"}, {"sha": "372e5e6a5b367eaf4e5404b4925305a8ffb033d6", "filename": "library/std/src/sys/unix/process/process_common.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -24,6 +24,8 @@ cfg_if::cfg_if! {\n         // fuchsia doesn't have /dev/null\n     } else if #[cfg(target_os = \"redox\")] {\n         const DEV_NULL: &str = \"null:\\0\";\n+    } else if #[cfg(target_os = \"vxworks\")] {\n+        const DEV_NULL: &str = \"/null\\0\";\n     } else {\n         const DEV_NULL: &str = \"/dev/null\\0\";\n     }\n@@ -48,7 +50,7 @@ cfg_if::cfg_if! {\n             raw[bit / 8] |= 1 << (bit % 8);\n             return 0;\n         }\n-    } else {\n+    } else if #[cfg(not(target_os = \"vxworks\"))] {\n         pub use libc::{sigemptyset, sigaddset};\n     }\n }\n@@ -253,11 +255,17 @@ impl Command {\n         let maybe_env = self.env.capture_if_changed();\n         maybe_env.map(|env| construct_envp(env, &mut self.saw_nul))\n     }\n+\n     #[allow(dead_code)]\n     pub fn env_saw_path(&self) -> bool {\n         self.env.have_changed_path()\n     }\n \n+    #[allow(dead_code)]\n+    pub fn program_is_path(&self) -> bool {\n+        self.program.to_bytes().contains(&b'/')\n+    }\n+\n     pub fn setup_io(\n         &self,\n         default: Stdio,"}, {"sha": "a590c74435639cc87658216711321afba545ee5a", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -6,6 +6,10 @@ use crate::sys;\n use crate::sys::cvt;\n use crate::sys::process::process_common::*;\n \n+#[cfg(target_os = \"vxworks\")]\n+use libc::RTP_ID as pid_t;\n+\n+#[cfg(not(target_os = \"vxworks\"))]\n use libc::{c_int, gid_t, pid_t, uid_t};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -277,11 +281,11 @@ impl Command {\n         envp: Option<&CStringArray>,\n     ) -> io::Result<Option<Process>> {\n         use crate::mem::MaybeUninit;\n-        use crate::sys;\n+        use crate::sys::{self, cvt_nz};\n \n         if self.get_gid().is_some()\n             || self.get_uid().is_some()\n-            || self.env_saw_path()\n+            || (self.env_saw_path() && !self.program_is_path())\n             || !self.get_closures().is_empty()\n         {\n             return Ok(None);\n@@ -339,10 +343,6 @@ impl Command {\n             }\n         }\n \n-        fn cvt_nz(error: libc::c_int) -> io::Result<()> {\n-            if error == 0 { Ok(()) } else { Err(io::Error::from_raw_os_error(error)) }\n-        }\n-\n         unsafe {\n             let mut attrs = MaybeUninit::uninit();\n             cvt_nz(libc::posix_spawnattr_init(attrs.as_mut_ptr()))?;"}, {"sha": "d84742053524eb95950a1727b60dcf94b9c79c23", "filename": "library/std/src/sys/unix/stack_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fstack_overflow.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -219,7 +219,7 @@ mod imp {\n     target_os = \"solaris\",\n     target_os = \"illumos\",\n     all(target_os = \"netbsd\", not(target_vendor = \"rumprun\")),\n-    target_os = \"openbsd\"\n+    target_os = \"openbsd\",\n )))]\n mod imp {\n     pub unsafe fn init() {}"}, {"sha": "fdf114d6df6fec17fd354e14acee433c9b152c77", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06e4497a04615ad95dff4240ca9980f19ed364ad/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=06e4497a04615ad95dff4240ca9980f19ed364ad", "patch": "@@ -6,10 +6,12 @@ use crate::ptr;\n use crate::sys::{os, stack_overflow};\n use crate::time::Duration;\n \n-#[cfg(not(target_os = \"l4re\"))]\n+#[cfg(not(any(target_os = \"l4re\", target_os = \"vxworks\")))]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 2 * 1024 * 1024;\n #[cfg(target_os = \"l4re\")]\n pub const DEFAULT_MIN_STACK_SIZE: usize = 1024 * 1024;\n+#[cfg(target_os = \"vxworks\")]\n+pub const DEFAULT_MIN_STACK_SIZE: usize = 256 * 1024;\n \n pub struct Thread {\n     id: libc::pthread_t,\n@@ -152,10 +154,11 @@ impl Thread {\n         target_os = \"haiku\",\n         target_os = \"l4re\",\n         target_os = \"emscripten\",\n-        target_os = \"redox\"\n+        target_os = \"redox\",\n+        target_os = \"vxworks\"\n     ))]\n     pub fn set_name(_name: &CStr) {\n-        // Newlib, Haiku, and Emscripten have no way to set a thread name.\n+        // Newlib, Haiku, Emscripten, and VxWorks have no way to set a thread name.\n     }\n     #[cfg(target_os = \"fuchsia\")]\n     pub fn set_name(_name: &CStr) {"}, {"sha": "97a191d7232e08837fcbac10e3862232784aa53c", "filename": "library/std/src/sys/vxworks/alloc.rs", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Falloc.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,49 +0,0 @@\n-use crate::alloc::{GlobalAlloc, Layout, System};\n-use crate::ptr;\n-use crate::sys_common::alloc::{realloc_fallback, MIN_ALIGN};\n-\n-#[stable(feature = \"alloc_system_type\", since = \"1.28.0\")]\n-unsafe impl GlobalAlloc for System {\n-    #[inline]\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            libc::malloc(layout.size()) as *mut u8\n-        } else {\n-            aligned_malloc(&layout)\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n-            libc::calloc(layout.size(), 1) as *mut u8\n-        } else {\n-            let ptr = self.alloc(layout.clone());\n-            if !ptr.is_null() {\n-                ptr::write_bytes(ptr, 0, layout.size());\n-            }\n-            ptr\n-        }\n-    }\n-\n-    #[inline]\n-    unsafe fn dealloc(&self, ptr: *mut u8, _layout: Layout) {\n-        libc::free(ptr as *mut libc::c_void)\n-    }\n-\n-    #[inline]\n-    unsafe fn realloc(&self, ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n-        if layout.align() <= MIN_ALIGN && layout.align() <= new_size {\n-            libc::realloc(ptr as *mut libc::c_void, new_size) as *mut u8\n-        } else {\n-            realloc_fallback(self, ptr, layout, new_size)\n-        }\n-    }\n-}\n-\n-#[inline]\n-unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n-    let mut out = ptr::null_mut();\n-    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n-    if ret != 0 { ptr::null_mut() } else { out as *mut u8 }\n-}"}, {"sha": "30cf7a707c7af9e08d53ec1e6719d98f837ab357", "filename": "library/std/src/sys/vxworks/args.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fargs.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,95 +0,0 @@\n-#![allow(dead_code)] // runtime init functions not used during testing\n-use crate::ffi::OsString;\n-use crate::marker::PhantomData;\n-use crate::vec;\n-\n-/// One-time global initialization.\n-pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-    imp::init(argc, argv)\n-}\n-\n-/// One-time global cleanup.\n-pub unsafe fn cleanup() {\n-    imp::cleanup()\n-}\n-\n-/// Returns the command line arguments\n-pub fn args() -> Args {\n-    imp::args()\n-}\n-\n-pub struct Args {\n-    iter: vec::IntoIter<OsString>,\n-    _dont_send_or_sync_me: PhantomData<*mut ()>,\n-}\n-\n-impl Args {\n-    pub fn inner_debug(&self) -> &[OsString] {\n-        self.iter.as_slice()\n-    }\n-}\n-\n-impl Iterator for Args {\n-    type Item = OsString;\n-    fn next(&mut self) -> Option<OsString> {\n-        self.iter.next()\n-    }\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        self.iter.size_hint()\n-    }\n-}\n-\n-impl ExactSizeIterator for Args {\n-    fn len(&self) -> usize {\n-        self.iter.len()\n-    }\n-}\n-\n-impl DoubleEndedIterator for Args {\n-    fn next_back(&mut self) -> Option<OsString> {\n-        self.iter.next_back()\n-    }\n-}\n-\n-mod imp {\n-    use super::Args;\n-    use crate::ffi::{CStr, OsString};\n-    use crate::marker::PhantomData;\n-    use crate::ptr;\n-\n-    use crate::sys_common::mutex::StaticMutex;\n-\n-    static mut ARGC: isize = 0;\n-    static mut ARGV: *const *const u8 = ptr::null();\n-    static LOCK: StaticMutex = StaticMutex::new();\n-\n-    pub unsafe fn init(argc: isize, argv: *const *const u8) {\n-        let _guard = LOCK.lock();\n-        ARGC = argc;\n-        ARGV = argv;\n-    }\n-\n-    pub unsafe fn cleanup() {\n-        let _guard = LOCK.lock();\n-        ARGC = 0;\n-        ARGV = ptr::null();\n-    }\n-\n-    pub fn args() -> Args {\n-        Args { iter: clone().into_iter(), _dont_send_or_sync_me: PhantomData }\n-    }\n-\n-    fn clone() -> Vec<OsString> {\n-        unsafe {\n-            let _guard = LOCK.lock();\n-            let ret = (0..ARGC)\n-                .map(|i| {\n-                    let cstr = CStr::from_ptr(*ARGV.offset(i) as *const libc::c_char);\n-                    use crate::sys::vxworks::ext::ffi::OsStringExt;\n-                    OsStringExt::from_vec(cstr.to_bytes().to_vec())\n-                })\n-                .collect();\n-            return ret;\n-        }\n-    }\n-}"}, {"sha": "f327b69fc754109060b23b56f44d3ffb832b1fb9", "filename": "library/std/src/sys/vxworks/cmath.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcmath.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,32 +0,0 @@\n-#![cfg(not(test))]\n-\n-use libc::{c_double, c_float};\n-\n-extern \"C\" {\n-    pub fn acos(n: c_double) -> c_double;\n-    pub fn acosf(n: c_float) -> c_float;\n-    pub fn asin(n: c_double) -> c_double;\n-    pub fn asinf(n: c_float) -> c_float;\n-    pub fn atan(n: c_double) -> c_double;\n-    pub fn atan2(a: c_double, b: c_double) -> c_double;\n-    pub fn atan2f(a: c_float, b: c_float) -> c_float;\n-    pub fn atanf(n: c_float) -> c_float;\n-    pub fn cbrt(n: c_double) -> c_double;\n-    pub fn cbrtf(n: c_float) -> c_float;\n-    pub fn cosh(n: c_double) -> c_double;\n-    pub fn coshf(n: c_float) -> c_float;\n-    pub fn expm1(n: c_double) -> c_double;\n-    pub fn expm1f(n: c_float) -> c_float;\n-    pub fn fdim(a: c_double, b: c_double) -> c_double;\n-    pub fn fdimf(a: c_float, b: c_float) -> c_float;\n-    pub fn hypot(x: c_double, y: c_double) -> c_double;\n-    pub fn hypotf(x: c_float, y: c_float) -> c_float;\n-    pub fn log1p(n: c_double) -> c_double;\n-    pub fn log1pf(n: c_float) -> c_float;\n-    pub fn sinh(n: c_double) -> c_double;\n-    pub fn sinhf(n: c_float) -> c_float;\n-    pub fn tan(n: c_double) -> c_double;\n-    pub fn tanf(n: c_float) -> c_float;\n-    pub fn tanh(n: c_double) -> c_double;\n-    pub fn tanhf(n: c_float) -> c_float;\n-}"}, {"sha": "b4724be7c7c3b38b31e65fba624978384e98e0d5", "filename": "library/std/src/sys/vxworks/condvar.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,91 +0,0 @@\n-use crate::cell::UnsafeCell;\n-use crate::sys::mutex::{self, Mutex};\n-use crate::time::Duration;\n-\n-pub struct Condvar {\n-    inner: UnsafeCell<libc::pthread_cond_t>,\n-}\n-\n-pub type MovableCondvar = Box<Condvar>;\n-\n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n-const TIMESPEC_MAX: libc::timespec =\n-    libc::timespec { tv_sec: <libc::time_t>::MAX, tv_nsec: 1_000_000_000 - 1 };\n-\n-fn saturating_cast_to_time_t(value: u64) -> libc::time_t {\n-    if value > <libc::time_t>::MAX as u64 { <libc::time_t>::MAX } else { value as libc::time_t }\n-}\n-\n-impl Condvar {\n-    pub const fn new() -> Condvar {\n-        // Might be moved and address is changing it is better to avoid\n-        // initialization of potentially opaque OS data before it landed\n-        Condvar { inner: UnsafeCell::new(libc::PTHREAD_COND_INITIALIZER) }\n-    }\n-\n-    pub unsafe fn init(&mut self) {\n-        use crate::mem::MaybeUninit;\n-        let mut attr = MaybeUninit::<libc::pthread_condattr_t>::uninit();\n-        let r = libc::pthread_condattr_init(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_setclock(attr.as_mut_ptr(), libc::CLOCK_MONOTONIC);\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_cond_init(self.inner.get(), attr.as_ptr());\n-        assert_eq!(r, 0);\n-        let r = libc::pthread_condattr_destroy(attr.as_mut_ptr());\n-        assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        let r = libc::pthread_cond_signal(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        let r = libc::pthread_cond_broadcast(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    #[inline]\n-    pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = libc::pthread_cond_wait(self.inner.get(), mutex::raw(mutex));\n-        debug_assert_eq!(r, 0);\n-    }\n-\n-    // This implementation is used on systems that support pthread_condattr_setclock\n-    // where we configure condition variable to use monotonic clock (instead of\n-    // default system clock). This approach avoids all problems that result\n-    // from changes made to the system time.\n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        use crate::mem;\n-\n-        let mut now: libc::timespec = mem::zeroed();\n-        let r = libc::clock_gettime(libc::CLOCK_MONOTONIC, &mut now);\n-        assert_eq!(r, 0);\n-\n-        // Nanosecond calculations can't overflow because both values are below 1e9.\n-        let nsec = dur.subsec_nanos() + now.tv_nsec as u32;\n-\n-        let sec = saturating_cast_to_time_t(dur.as_secs())\n-            .checked_add((nsec / 1_000_000_000) as libc::time_t)\n-            .and_then(|s| s.checked_add(now.tv_sec));\n-        let nsec = nsec % 1_000_000_000;\n-\n-        let timeout =\n-            sec.map(|s| libc::timespec { tv_sec: s, tv_nsec: nsec as _ }).unwrap_or(TIMESPEC_MAX);\n-\n-        let r = libc::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n-        assert!(r == libc::ETIMEDOUT || r == 0);\n-        r == 0\n-    }\n-\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let r = libc::pthread_cond_destroy(self.inner.get());\n-        debug_assert_eq!(r, 0);\n-    }\n-}"}, {"sha": "76b34a6b5d84aa64a0a9a429e56218fc59931752", "filename": "library/std/src/sys/vxworks/ext/ffi.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Fffi.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be", "patch": "@@ -1,38 +0,0 @@\n-//! Unix-specific extension to the primitives in the `std::ffi` module\n-//!\n-//! # Examples\n-//!\n-//! ```\n-//! use std::ffi::OsString;\n-//! use std::os::unix::ffi::OsStringExt;\n-//!\n-//! let bytes = b\"foo\".to_vec();\n-//!\n-//! // OsStringExt::from_vec\n-//! let os_string = OsString::from_vec(bytes);\n-//! assert_eq!(os_string.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStringExt::into_vec\n-//! let bytes = os_string.into_vec();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-//!\n-//! ```\n-//! use std::ffi::OsStr;\n-//! use std::os::unix::ffi::OsStrExt;\n-//!\n-//! let bytes = b\"foo\";\n-//!\n-//! // OsStrExt::from_bytes\n-//! let os_str = OsStr::from_bytes(bytes);\n-//! assert_eq!(os_str.to_str(), Some(\"foo\"));\n-//!\n-//! // OsStrExt::as_bytes\n-//! let bytes = os_str.as_bytes();\n-//! assert_eq!(bytes, b\"foo\");\n-//! ```\n-\n-#![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use crate::sys_common::os_str_bytes::*;"}, {"sha": "68dc21b806c0fd70cb0be6555939bf9dc8b3a3bb", "filename": "library/std/src/sys/vxworks/ext/fs.rs", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/693a2bf18b7090202784f561de3dfca45c4f79be/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fext%2Ffs.rs?ref=693a2bf18b7090202784f561de3dfca45c4f79be"}]}