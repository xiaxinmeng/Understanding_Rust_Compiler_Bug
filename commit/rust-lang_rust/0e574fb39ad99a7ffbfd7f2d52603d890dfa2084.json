{"sha": "0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNTc0ZmIzOWFkOTlhN2ZmYmZkN2YyZDUyNjAzZDg5MGRmYTIwODQ=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T04:57:18Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-12-12T05:01:25Z"}, "message": "Fix the JSON backend\n\nThis was simpler than expected.", "tree": {"sha": "820a946f9ef690da8c77a0181506482301337a47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/820a946f9ef690da8c77a0181506482301337a47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "html_url": "https://github.com/rust-lang/rust/commit/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fa95b3a078f261267293f3308dd62889167c0bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fa95b3a078f261267293f3308dd62889167c0bd", "html_url": "https://github.com/rust-lang/rust/commit/4fa95b3a078f261267293f3308dd62889167c0bd"}], "stats": {"total": 48, "additions": 25, "deletions": 23}, "files": [{"sha": "c463481db86d2e5ac6c651214ef3c75d3f73fa7a", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "patch": "@@ -6,14 +6,16 @@ use std::convert::From;\n \n use rustc_ast::ast;\n use rustc_span::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc_span::Pos;\n \n use crate::clean;\n use crate::doctree;\n use crate::formats::item_type::ItemType;\n use crate::json::types::*;\n+use crate::json::JsonRenderer;\n \n-impl From<clean::Item> for Option<Item> {\n-    fn from(item: clean::Item) -> Self {\n+impl JsonRenderer {\n+    pub(super) fn convert_item(&self, item: clean::Item) -> Option<Item> {\n         let item_type = ItemType::from(&item);\n         let clean::Item {\n             source,\n@@ -32,7 +34,7 @@ impl From<clean::Item> for Option<Item> {\n                 id: def_id.into(),\n                 crate_id: def_id.krate.as_u32(),\n                 name,\n-                source: source.into(),\n+                source: self.convert_span(source),\n                 visibility: visibility.into(),\n                 docs: attrs.collapsed_doc_value().unwrap_or_default(),\n                 links: attrs\n@@ -53,25 +55,23 @@ impl From<clean::Item> for Option<Item> {\n             }),\n         }\n     }\n-}\n \n-impl From<clean::Span> for Option<Span> {\n-    #[allow(unreachable_code)]\n-    fn from(span: clean::Span) -> Self {\n-        // TODO: this should actually work\n-        // Unfortunately this requires rethinking the whole framework,\n-        // since this now needs a context and not just .into().\n-        match span.filename(todo!()) {\n-            rustc_span::FileName::Real(name) => Some(Span {\n-                filename: match name {\n-                    rustc_span::RealFileName::Named(path) => path,\n-                    rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n-                        local_path\n-                    }\n-                },\n-                begin: todo!(),\n-                end: todo!(),\n-            }),\n+    fn convert_span(&self, span: clean::Span) -> Option<Span> {\n+        match span.filename(&self.sess) {\n+            rustc_span::FileName::Real(name) => {\n+                let hi = span.hi(&self.sess);\n+                let lo = span.lo(&self.sess);\n+                Some(Span {\n+                    filename: match name {\n+                        rustc_span::RealFileName::Named(path) => path,\n+                        rustc_span::RealFileName::Devirtualized { local_path, virtual_name: _ } => {\n+                            local_path\n+                        }\n+                    },\n+                    begin: (lo.line, lo.col.to_usize()),\n+                    end: (hi.line, hi.col.to_usize()),\n+                })\n+            }\n             _ => None,\n         }\n     }"}, {"sha": "5c5239d1b6a26f4d33034e3c3a684625206d5522", "filename": "src/librustdoc/json/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084/src%2Flibrustdoc%2Fjson%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e574fb39ad99a7ffbfd7f2d52603d890dfa2084/src%2Flibrustdoc%2Fjson%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fmod.rs?ref=0e574fb39ad99a7ffbfd7f2d52603d890dfa2084", "patch": "@@ -26,6 +26,7 @@ use crate::html::render::cache::ExternalLocation;\n \n #[derive(Clone)]\n crate struct JsonRenderer {\n+    sess: Lrc<Session>,\n     /// A mapping of IDs that contains all local items for this crate which gets output as a top\n     /// level field of the JSON blob.\n     index: Rc<RefCell<FxHashMap<types::Id, types::Item>>>,\n@@ -126,11 +127,12 @@ impl FormatRenderer for JsonRenderer {\n         _render_info: RenderInfo,\n         _edition: Edition,\n         _cache: &mut Cache,\n-        _sess: Lrc<Session>,\n+        sess: Lrc<Session>,\n     ) -> Result<(Self, clean::Crate), Error> {\n         debug!(\"Initializing json renderer\");\n         Ok((\n             JsonRenderer {\n+                sess,\n                 index: Rc::new(RefCell::new(FxHashMap::default())),\n                 out_path: options.output,\n             },\n@@ -146,7 +148,7 @@ impl FormatRenderer for JsonRenderer {\n         item.kind.inner_items().for_each(|i| self.item(i.clone(), cache).unwrap());\n \n         let id = item.def_id;\n-        if let Some(mut new_item) = item.into(): Option<types::Item> {\n+        if let Some(mut new_item) = self.convert_item(item) {\n             if let types::ItemEnum::TraitItem(ref mut t) = new_item.inner {\n                 t.implementors = self.get_trait_implementors(id, cache)\n             } else if let types::ItemEnum::StructItem(ref mut s) = new_item.inner {"}]}