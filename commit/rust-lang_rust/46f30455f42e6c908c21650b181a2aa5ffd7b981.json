{"sha": "46f30455f42e6c908c21650b181a2aa5ffd7b981", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZjMwNDU1ZjQyZTZjOTA4YzIxNjUwYjE4MWEyYWE1ZmZkN2I5ODE=", "commit": {"author": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-01-17T20:20:21Z"}, "committer": {"name": "D\u00e1niel Buga", "email": "bugadani@gmail.com", "date": "2021-02-07T21:26:21Z"}, "message": "Optimize Borrows\n\nReuse as much memory as possible, reduce number of allocations.\nUse BitSet instead of a HashMap, since only a single bit of\ninformation was used as the map's value.", "tree": {"sha": "7e541512794bd270ee1e26e8c267c2f7c5bd5684", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e541512794bd270ee1e26e8c267c2f7c5bd5684"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46f30455f42e6c908c21650b181a2aa5ffd7b981", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46f30455f42e6c908c21650b181a2aa5ffd7b981", "html_url": "https://github.com/rust-lang/rust/commit/46f30455f42e6c908c21650b181a2aa5ffd7b981", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46f30455f42e6c908c21650b181a2aa5ffd7b981/comments", "author": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bugadani", "id": 977627, "node_id": "MDQ6VXNlcjk3NzYyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/977627?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bugadani", "html_url": "https://github.com/bugadani", "followers_url": "https://api.github.com/users/bugadani/followers", "following_url": "https://api.github.com/users/bugadani/following{/other_user}", "gists_url": "https://api.github.com/users/bugadani/gists{/gist_id}", "starred_url": "https://api.github.com/users/bugadani/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bugadani/subscriptions", "organizations_url": "https://api.github.com/users/bugadani/orgs", "repos_url": "https://api.github.com/users/bugadani/repos", "events_url": "https://api.github.com/users/bugadani/events{/privacy}", "received_events_url": "https://api.github.com/users/bugadani/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7", "html_url": "https://github.com/rust-lang/rust/commit/5e91c4ecc09312d8b63d250a432b0f3ef83f1df7"}], "stats": {"total": 172, "additions": 90, "deletions": 82}, "files": [{"sha": "d115a5fa36d48e058537950d0e771a3a5c91970b", "filename": "compiler/rustc_mir/src/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46f30455f42e6c908c21650b181a2aa5ffd7b981/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f30455f42e6c908c21650b181a2aa5ffd7b981/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fmod.rs?ref=46f30455f42e6c908c21650b181a2aa5ffd7b981", "patch": "@@ -259,7 +259,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let regioncx = Rc::new(regioncx);\n \n-    let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), &borrow_set)\n+    let flow_borrows = Borrows::new(tcx, &body, regioncx.clone(), Rc::clone(borrow_set))\n         .into_engine(tcx, &body)\n         .pass_name(\"borrowck\")\n         .iterate_to_fixpoint();"}, {"sha": "26b090d564ef5cbd76596f82f7e890634db0dd32", "filename": "compiler/rustc_mir/src/dataflow/impls/borrows.rs", "status": "modified", "additions": 89, "deletions": 81, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/46f30455f42e6c908c21650b181a2aa5ffd7b981/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46f30455f42e6c908c21650b181a2aa5ffd7b981/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fdataflow%2Fimpls%2Fborrows.rs?ref=46f30455f42e6c908c21650b181a2aa5ffd7b981", "patch": "@@ -41,90 +41,105 @@ struct StackEntry {\n     bb: mir::BasicBlock,\n     lo: usize,\n     hi: usize,\n-    first_part_only: bool,\n }\n \n-fn precompute_borrows_out_of_scope<'tcx>(\n-    body: &Body<'tcx>,\n-    regioncx: &Rc<RegionInferenceContext<'tcx>>,\n-    borrows_out_of_scope_at_location: &mut FxHashMap<Location, Vec<BorrowIndex>>,\n-    borrow_index: BorrowIndex,\n-    borrow_region: RegionVid,\n-    location: Location,\n-) {\n-    // We visit one BB at a time. The complication is that we may start in the\n-    // middle of the first BB visited (the one containing `location`), in which\n-    // case we may have to later on process the first part of that BB if there\n-    // is a path back to its start.\n-\n-    // For visited BBs, we record the index of the first statement processed.\n-    // (In fully processed BBs this index is 0.) Note also that we add BBs to\n-    // `visited` once they are added to `stack`, before they are actually\n-    // processed, because this avoids the need to look them up again on\n-    // completion.\n-    let mut visited = FxHashMap::default();\n-    visited.insert(location.block, location.statement_index);\n-\n-    let mut stack = vec![];\n-    stack.push(StackEntry {\n-        bb: location.block,\n-        lo: location.statement_index,\n-        hi: body[location.block].statements.len(),\n-        first_part_only: false,\n-    });\n-\n-    while let Some(StackEntry { bb, lo, hi, first_part_only }) = stack.pop() {\n-        let mut finished_early = first_part_only;\n-        for i in lo..=hi {\n-            let location = Location { block: bb, statement_index: i };\n-            // If region does not contain a point at the location, then add to list and skip\n-            // successor locations.\n-            if !regioncx.region_contains(borrow_region, location) {\n-                debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n-                borrows_out_of_scope_at_location.entry(location).or_default().push(borrow_index);\n-                finished_early = true;\n-                break;\n-            }\n+struct OutOfScopePrecomputer<'a, 'tcx> {\n+    visited: BitSet<mir::BasicBlock>,\n+    visit_stack: Vec<StackEntry>,\n+    body: &'a Body<'tcx>,\n+    regioncx: Rc<RegionInferenceContext<'tcx>>,\n+    borrows_out_of_scope_at_location: FxHashMap<Location, Vec<BorrowIndex>>,\n+}\n+\n+impl<'a, 'tcx> OutOfScopePrecomputer<'a, 'tcx> {\n+    fn new(body: &'a Body<'tcx>, regioncx: Rc<RegionInferenceContext<'tcx>>) -> Self {\n+        OutOfScopePrecomputer {\n+            visited: BitSet::new_empty(body.basic_blocks().len()),\n+            visit_stack: vec![],\n+            body,\n+            regioncx,\n+            borrows_out_of_scope_at_location: FxHashMap::default(),\n         }\n+    }\n+}\n+\n+impl<'tcx> OutOfScopePrecomputer<'_, 'tcx> {\n+    fn precompute_borrows_out_of_scope(\n+        &mut self,\n+        borrow_index: BorrowIndex,\n+        borrow_region: RegionVid,\n+        location: Location,\n+    ) {\n+        // We visit one BB at a time. The complication is that we may start in the\n+        // middle of the first BB visited (the one containing `location`), in which\n+        // case we may have to later on process the first part of that BB if there\n+        // is a path back to its start.\n+\n+        // For visited BBs, we record the index of the first statement processed.\n+        // (In fully processed BBs this index is 0.) Note also that we add BBs to\n+        // `visited` once they are added to `stack`, before they are actually\n+        // processed, because this avoids the need to look them up again on\n+        // completion.\n+        self.visited.insert(location.block);\n+\n+        let mut first_lo = location.statement_index;\n+        let first_hi = self.body[location.block].statements.len();\n+\n+        self.visit_stack.push(StackEntry { bb: location.block, lo: first_lo, hi: first_hi });\n+\n+        while let Some(StackEntry { bb, lo, hi }) = self.visit_stack.pop() {\n+            // If we process the first part of the first basic block (i.e. we encounter that block\n+            // for the second time), we no longer have to visit its successors again.\n+            let mut finished_early = bb == location.block && hi != first_hi;\n+            for i in lo..=hi {\n+                let location = Location { block: bb, statement_index: i };\n+                // If region does not contain a point at the location, then add to list and skip\n+                // successor locations.\n+                if !self.regioncx.region_contains(borrow_region, location) {\n+                    debug!(\"borrow {:?} gets killed at {:?}\", borrow_index, location);\n+                    self.borrows_out_of_scope_at_location\n+                        .entry(location)\n+                        .or_default()\n+                        .push(borrow_index);\n+                    finished_early = true;\n+                    break;\n+                }\n+            }\n \n-        if !finished_early {\n-            // Add successor BBs to the work list, if necessary.\n-            let bb_data = &body[bb];\n-            assert!(hi == bb_data.statements.len());\n-            for &succ_bb in bb_data.terminator().successors() {\n-                visited\n-                    .entry(succ_bb)\n-                    .and_modify(|lo| {\n-                        // `succ_bb` has been seen before. If it wasn't\n-                        // fully processed, add its first part to `stack`\n-                        // for processing.\n-                        if *lo > 0 {\n-                            stack.push(StackEntry {\n+            if !finished_early {\n+                // Add successor BBs to the work list, if necessary.\n+                let bb_data = &self.body[bb];\n+                debug_assert!(hi == bb_data.statements.len());\n+                for &succ_bb in bb_data.terminator().successors() {\n+                    if self.visited.insert(succ_bb) == false {\n+                        if succ_bb == location.block && first_lo > 0 {\n+                            // `succ_bb` has been seen before. If it wasn't\n+                            // fully processed, add its first part to `stack`\n+                            // for processing.\n+                            self.visit_stack.push(StackEntry {\n                                 bb: succ_bb,\n                                 lo: 0,\n-                                hi: *lo - 1,\n-                                first_part_only: true,\n+                                hi: first_lo - 1,\n                             });\n+\n+                            // And update this entry with 0, to represent the\n+                            // whole BB being processed.\n+                            first_lo = 0;\n                         }\n-                        // And update this entry with 0, to represent the\n-                        // whole BB being processed.\n-                        *lo = 0;\n-                    })\n-                    .or_insert_with(|| {\n+                    } else {\n                         // succ_bb hasn't been seen before. Add it to\n                         // `stack` for processing.\n-                        stack.push(StackEntry {\n+                        self.visit_stack.push(StackEntry {\n                             bb: succ_bb,\n                             lo: 0,\n-                            hi: body[succ_bb].statements.len(),\n-                            first_part_only: false,\n+                            hi: self.body[succ_bb].statements.len(),\n                         });\n-                        // Insert 0 for this BB, to represent the whole BB\n-                        // being processed.\n-                        0\n-                    });\n+                    }\n+                }\n             }\n         }\n+\n+        self.visited.clear();\n     }\n }\n \n@@ -133,28 +148,21 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         body: &'a Body<'tcx>,\n         nonlexical_regioncx: Rc<RegionInferenceContext<'tcx>>,\n-        borrow_set: &Rc<BorrowSet<'tcx>>,\n+        borrow_set: Rc<BorrowSet<'tcx>>,\n     ) -> Self {\n-        let mut borrows_out_of_scope_at_location = FxHashMap::default();\n+        let mut prec = OutOfScopePrecomputer::new(body, nonlexical_regioncx.clone());\n         for (borrow_index, borrow_data) in borrow_set.iter_enumerated() {\n             let borrow_region = borrow_data.region.to_region_vid();\n             let location = borrow_data.reserve_location;\n \n-            precompute_borrows_out_of_scope(\n-                body,\n-                &nonlexical_regioncx,\n-                &mut borrows_out_of_scope_at_location,\n-                borrow_index,\n-                borrow_region,\n-                location,\n-            );\n+            prec.precompute_borrows_out_of_scope(borrow_index, borrow_region, location);\n         }\n \n         Borrows {\n             tcx,\n             body,\n-            borrow_set: borrow_set.clone(),\n-            borrows_out_of_scope_at_location,\n+            borrow_set,\n+            borrows_out_of_scope_at_location: prec.borrows_out_of_scope_at_location,\n             _nonlexical_regioncx: nonlexical_regioncx,\n         }\n     }"}]}