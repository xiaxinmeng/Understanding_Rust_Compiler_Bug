{"sha": "65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YWFjZDA4M2ExYThhNWUyYWUxZTVmZmFiNGJiMWIwMzI4NTQzMjc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-11-07T23:34:31Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-11-12T23:32:31Z"}, "message": "rustpkg: Eliminate the spurious `os::path_exists(&pkg_src.start_dir.join(p))` assertion failure\n\nThis addresses the problem reported in #10253 and possibly elsewhere.\n\nCloses #10253", "tree": {"sha": "f50c5a478f9994b93019ffb3d243f44bfaf9b04a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f50c5a478f9994b93019ffb3d243f44bfaf9b04a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "html_url": "https://github.com/rust-lang/rust/commit/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b0d48634f546055e17cf23a6bcde1bbfbc16b15", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b0d48634f546055e17cf23a6bcde1bbfbc16b15", "html_url": "https://github.com/rust-lang/rust/commit/3b0d48634f546055e17cf23a6bcde1bbfbc16b15"}], "stats": {"total": 93, "additions": 71, "deletions": 22}, "files": [{"sha": "b6edab3d65ad037fc1200b4f5b93d8056f9c3b89", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "patch": "@@ -118,7 +118,8 @@ impl PkgSrc {\n \n         debug!(\"Checking dirs: {:?}\", to_try.map(|p| p.display().to_str()).connect(\":\"));\n \n-        let path = to_try.iter().find(|&d| d.exists());\n+        let path = to_try.iter().find(|&d| d.is_dir()\n+                                      && dir_has_crate_file(d));\n \n         // See the comments on the definition of PkgSrc\n         let mut build_in_destination = use_rust_path_hack;"}, {"sha": "921005fdaab57014e71f4be37583112c25b1e6a8", "filename": "src/librustpkg/path_util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Fpath_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Fpath_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpath_util.rs?ref=65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "patch": "@@ -461,6 +461,7 @@ pub fn versionize(p: &Path, v: &Version) -> Path {\n }\n \n #[cfg(target_os = \"win32\")]\n+#[fixed_stack_segment]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n         do p.with_c_str |src_buf| {\n@@ -470,6 +471,7 @@ pub fn chmod_read_only(p: &Path) -> bool {\n }\n \n #[cfg(not(target_os = \"win32\"))]\n+#[fixed_stack_segment]\n pub fn chmod_read_only(p: &Path) -> bool {\n     unsafe {\n         do p.with_c_str |src_buf| {"}, {"sha": "bf62e7068f325f7d865398335975045ab46ce544", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "patch": "@@ -239,7 +239,8 @@ fn rustpkg_exec() -> Path {\n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     match command_line_test_with_env(args, cwd, None) {\n         Success(r) => r,\n-        Fail(error) => fail!(\"Command line test failed with error {}\", error)\n+        Fail(error) => fail!(\"Command line test failed with error {}\",\n+                             error.status)\n     }\n }\n \n@@ -253,15 +254,15 @@ fn command_line_test_expect_fail(args: &[~str],\n                                  expected_exitcode: int) {\n     match command_line_test_with_env(args, cwd, env) {\n         Success(_) => fail!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n-        Fail(error) if error.matches_exit_status(expected_exitcode) => (), // ok\n+        Fail(ref error) if error.status.matches_exit_status(expected_exitcode) => (), // ok\n         Fail(other) => fail!(\"Expected to fail with {}, but failed with {} instead\",\n-                              expected_exitcode, other)\n+                              expected_exitcode, other.status)\n     }\n }\n \n enum ProcessResult {\n     Success(ProcessOutput),\n-    Fail(ProcessExit)\n+    Fail(ProcessOutput)\n }\n \n /// Runs `rustpkg` (based on the directory that this executable was\n@@ -295,7 +296,7 @@ fn command_line_test_with_env(args: &[~str], cwd: &Path, env: Option<~[(~str, ~s\n         debug!(\"Command {} {:?} failed with exit code {:?}; its output was --- {} ---\",\n               cmd, args, output.status,\n               str::from_utf8(output.output) + str::from_utf8(output.error));\n-        Fail(output.status)\n+        Fail(output)\n     }\n     else {\n         Success(output)\n@@ -1093,7 +1094,7 @@ fn no_rebuilding() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status.matches_exit_status(65) =>\n+        Fail(ref status) if status.status.matches_exit_status(65) =>\n             fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding failed for some other reason\")\n     }\n@@ -1112,7 +1113,8 @@ fn no_recopying() {\n \n     match command_line_test_partial([~\"install\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(process::ExitStatus(65)) => fail!(\"no_recopying failed: it tried to re-copy foo\"),\n+        Fail(ref status) if status.status.matches_exit_status(65) =>\n+            fail!(\"no_recopying failed: it tried to re-copy foo\"),\n         Fail(_) => fail!(\"no_copying failed for some other reason\")\n     }\n }\n@@ -1130,7 +1132,7 @@ fn no_rebuilding_dep() {\n     assert!(chmod_read_only(&bar_lib));\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status.matches_exit_status(65) =>\n+        Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n     }\n@@ -1151,7 +1153,7 @@ fn do_rebuild_dep_dates_change() {\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n-        Fail(status) if status.matches_exit_status(65) => (), // ok\n+        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_dates_change failed for some other reason\")\n     }\n }\n@@ -1172,7 +1174,7 @@ fn do_rebuild_dep_only_contents_change() {\n     // should adjust the datestamp\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n         Success(*) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n-        Fail(status) if status.matches_exit_status(65) => (), // ok\n+        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n     }\n }\n@@ -2148,7 +2150,7 @@ fn test_rebuild_when_needed() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n-        Fail(status) if status.matches_exit_status(65) => (), // ok\n+        Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n }\n@@ -2168,7 +2170,7 @@ fn test_no_rebuilding() {\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n         Success(*) => (), // ok\n-        Fail(status) if status.matches_exit_status(65) =>\n+        Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n         Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n     }\n@@ -2296,7 +2298,7 @@ fn test_compile_error() {\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n     match result {\n         Success(*) => fail!(\"Failed by succeeding!\"), // should be a compile error\n-        Fail(status) => {\n+        Fail(ref status) => {\n             debug!(\"Failed with status {:?}... that's good, right?\", status);\n         }\n     }\n@@ -2364,7 +2366,7 @@ fn test_c_dependency_no_rebuilding() {\n \n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n         Success(*) => (), // ok\n-        Fail(status) if status.matches_exit_status(65) =>\n+        Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"test_c_dependency_no_rebuilding failed: \\\n                     it tried to rebuild foo.c\"),\n         Fail(_) =>\n@@ -2403,11 +2405,43 @@ fn test_c_dependency_yes_rebuilding() {\n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n         Success(*) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n                             it didn't rebuild and should have\"),\n-        Fail(status) if status.matches_exit_status(65) => (),\n+        Fail(ref r) if r.status.matches_exit_status(65) => (),\n         Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n     }\n }\n \n+// n.b. This might help with #10253, or at least the error will be different.\n+#[test]\n+fn correct_error_dependency() {\n+    // Supposing a package we're trying to install via a dependency doesn't\n+    // exist, we should throw a condition, and not ICE\n+    let dir = create_local_package(&PkgId::new(\"badpkg\"));\n+\n+    let dir = dir.path();\n+    writeFile(&dir.join_many([\"src\", \"badpkg-0.1\", \"main.rs\"]),\n+              \"extern mod p = \\\"some_package_that_doesnt_exist\\\";\n+               fn main() {}\");\n+\n+    match command_line_test_partial([~\"build\", ~\"badpkg\"], dir) {\n+        Fail(ProcessOutput{ error: error, output: output, _ }) => {\n+            assert!(str::is_utf8(error));\n+            assert!(str::is_utf8(output));\n+            let error_str = str::from_utf8(error);\n+            let out_str   = str::from_utf8(output);\n+            debug!(\"ss = {}\", error_str);\n+            debug!(\"out_str = {}\", out_str);\n+            if out_str.contains(\"Package badpkg depends on some_package_that_doesnt_exist\") &&\n+                !error_str.contains(\"nonexistent_package\") {\n+                // Ok\n+                ()\n+            } else {\n+                fail!(\"Wrong error\");\n+            }\n+        }\n+        Success(*)       => fail!(\"Test passed when it should have failed\")\n+    }\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     p.exists() && p.stat().perm & io::UserExecute == io::UserExecute"}, {"sha": "6156cc0838ab7f3407c9bf0d22492940ca60f0a7", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65aacd083a1a8a5e2ae1e5ffab4bb1b032854327/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=65aacd083a1a8a5e2ae1e5ffab4bb1b032854327", "patch": "@@ -36,6 +36,7 @@ pub use target::{Target, Build, Install};\n use extra::treemap::TreeMap;\n pub use target::{lib_name_of, lib_crate_filename, WhatToBuild, MaybeCustom, Inferred};\n use workcache_support::{digest_file_with_date, digest_only_date};\n+use messages::error;\n \n // It would be nice to have the list of commands in just one place -- for example,\n // you could update the match in rustpkg.rc but forget to update this list. I think\n@@ -430,6 +431,8 @@ struct ViewItemVisitor<'self> {\n \n impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n     fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n+        use conditions::nonexistent_package::cond;\n+\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n@@ -490,12 +493,21 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // and the `PkgSrc` constructor will detect that;\n                         // or else it's already in a workspace and we'll build into that\n                         // workspace\n-                        let pkg_src = PkgSrc::new(source_workspace,\n-                                                  dest_workspace,\n-                        // Use the rust_path_hack to search for dependencies iff\n-                        // we were already using it\n-                                                  self.context.context.use_rust_path_hack,\n-                                                  pkg_id.clone());\n+                        let pkg_src = do cond.trap(|_| {\n+                                 // Nonexistent package? Then print a better error\n+                                 error(format!(\"Package {} depends on {}, but I don't know \\\n+                                               how to find it\",\n+                                               self.parent.path.display(),\n+                                               pkg_id.path.display()));\n+                                 fail!()\n+                        }).inside {\n+                            PkgSrc::new(source_workspace.clone(),\n+                                        dest_workspace.clone(),\n+                                        // Use the rust_path_hack to search for dependencies iff\n+                                        // we were already using it\n+                                        self.context.context.use_rust_path_hack,\n+                                        pkg_id.clone())\n+                        };\n                         let (outputs_disc, inputs_disc) =\n                             self.context.install(\n                                 pkg_src,"}]}