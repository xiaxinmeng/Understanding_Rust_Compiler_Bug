{"sha": "629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "node_id": "C_kwDOAAsO6NoAKDYyOWE0MTRkN2JhNGNhYTNjYTI4YjBhNDZjNDc4ZTJlY2I0YzAwNTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T07:58:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-26T07:58:28Z"}, "message": "Auto merge of #103562 - Dylan-DPC:rollup-sheepp5, r=Dylan-DPC\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #102951 (suggest type annotation for local statement initialed by ref expression)\n - #103209 (Diagnostic derives: allow specifying multiple alternative suggestions)\n - #103287 (Use a faster allocation size check in slice::from_raw_parts)\n - #103416 (Name the `impl Trait` in region bound suggestions)\n - #103430 (Workaround unstable stmt_expr_attributes for method receiver expressions)\n - #103444 (Remove extra type error after missing semicolon error)\n - #103520 (rustc_middle: Rearrange resolver outputs structures slightly)\n - #103533 (Use &self instead of &mut self for cast methods)\n - #103536 (Remove `rustc_driver::set_sigpipe_handler()`)\n - #103542 (Pinning tests for some `macro_rules!` errors discussed in the lang meeting)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b1f78f8f0ab6047c65cd12fed875ff6240df9c14", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1f78f8f0ab6047c65cd12fed875ff6240df9c14"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "html_url": "https://github.com/rust-lang/rust/commit/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d49e7e7fa13479c11a3733824c78e280e391288b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d49e7e7fa13479c11a3733824c78e280e391288b", "html_url": "https://github.com/rust-lang/rust/commit/d49e7e7fa13479c11a3733824c78e280e391288b"}, {"sha": "703fb66fa03f1ca4832d02aa274eecefa10ca029", "url": "https://api.github.com/repos/rust-lang/rust/commits/703fb66fa03f1ca4832d02aa274eecefa10ca029", "html_url": "https://github.com/rust-lang/rust/commit/703fb66fa03f1ca4832d02aa274eecefa10ca029"}], "stats": {"total": 933, "additions": 753, "deletions": 180}, "files": [{"sha": "b970e57e0173c444a5dddef1862087d6036c35d9", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -152,6 +152,12 @@ pub trait MutVisitor: Sized {\n         noop_visit_expr(e, self);\n     }\n \n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &mut P<Expr>) {\n+        self.visit_expr(ex)\n+    }\n+\n     fn filter_map_expr(&mut self, e: P<Expr>) -> Option<P<Expr>> {\n         noop_filter_map_expr(e, self)\n     }\n@@ -1301,7 +1307,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n             vis.visit_ident(ident);\n             vis.visit_id(id);\n             visit_opt(args, |args| vis.visit_generic_args(args));\n-            vis.visit_expr(receiver);\n+            vis.visit_method_receiver_expr(receiver);\n             visit_exprs(exprs, vis);\n             vis.visit_span(span);\n         }\n@@ -1589,3 +1595,9 @@ impl DummyAstNode for Crate {\n         }\n     }\n }\n+\n+impl<N: DummyAstNode, T: DummyAstNode> DummyAstNode for crate::ast_traits::AstNodeWrapper<N, T> {\n+    fn dummy() -> Self {\n+        crate::ast_traits::AstNodeWrapper::new(N::dummy(), T::dummy())\n+    }\n+}"}, {"sha": "6f56c1ef0e8daa6ff4e5fad425bd1171a51cc4f6", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -140,6 +140,11 @@ pub trait Visitor<'ast>: Sized {\n     fn visit_expr(&mut self, ex: &'ast Expr) {\n         walk_expr(self, ex)\n     }\n+    /// This method is a hack to workaround unstable of `stmt_expr_attributes`.\n+    /// It can be removed once that feature is stabilized.\n+    fn visit_method_receiver_expr(&mut self, ex: &'ast Expr) {\n+        self.visit_expr(ex)\n+    }\n     fn visit_expr_post(&mut self, _ex: &'ast Expr) {}\n     fn visit_ty(&mut self, t: &'ast Ty) {\n         walk_ty(self, t)"}, {"sha": "750f1fe121f6d90a368ee38a7a4f7b3bc0a1aa66", "filename": "compiler/rustc_builtin_macros/src/cfg_eval.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fcfg_eval.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -210,8 +210,15 @@ impl CfgEval<'_, '_> {\n }\n \n impl MutVisitor for CfgEval<'_, '_> {\n+    #[instrument(level = \"trace\", skip(self))]\n     fn visit_expr(&mut self, expr: &mut P<ast::Expr>) {\n-        self.cfg.configure_expr(expr);\n+        self.cfg.configure_expr(expr, false);\n+        mut_visit::noop_visit_expr(expr, self);\n+    }\n+\n+    #[instrument(level = \"trace\", skip(self))]\n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        self.cfg.configure_expr(expr, true);\n         mut_visit::noop_visit_expr(expr, self);\n     }\n "}, {"sha": "cb33c4d4c465a711e497d7661760838a48f2eb79", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -139,7 +139,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn int_to_int_or_float(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -154,7 +154,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn float_to_float_or_int(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -176,7 +176,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Handles 'FnPtrToPtr' and 'PtrToPtr' casts.\n     pub fn ptr_to_ptr(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {\n@@ -226,7 +226,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     }\n \n     pub fn pointer_from_exposed_address_cast(\n-        &mut self,\n+        &self,\n         src: &ImmTy<'tcx, M::Provenance>,\n         cast_ty: Ty<'tcx>,\n     ) -> InterpResult<'tcx, Immediate<M::Provenance>> {"}, {"sha": "cfa734c7df39c331a9eb39b1a482d003f9f6d62d", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -427,18 +427,6 @@ fn run_compiler(\n     })\n }\n \n-#[cfg(unix)]\n-pub fn set_sigpipe_handler() {\n-    unsafe {\n-        // Set the SIGPIPE signal handler, so that an EPIPE\n-        // will cause rustc to terminate, as expected.\n-        assert_ne!(libc::signal(libc::SIGPIPE, libc::SIG_DFL), libc::SIG_ERR);\n-    }\n-}\n-\n-#[cfg(windows)]\n-pub fn set_sigpipe_handler() {}\n-\n // Extract output directory and file from matches.\n fn make_output(matches: &getopts::Matches) -> (Option<PathBuf>, Option<PathBuf>) {\n     let odir = matches.opt_str(\"out-dir\").map(|o| PathBuf::from(&o));"}, {"sha": "23f29a24fe79feb71a6385d2dde8f4062a71ab12", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -690,6 +690,24 @@ impl Diagnostic {\n         msg: impl Into<SubdiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n+    ) -> &mut Self {\n+        self.span_suggestions_with_style(\n+            sp,\n+            msg,\n+            suggestions,\n+            applicability,\n+            SuggestionStyle::ShowCode,\n+        )\n+    }\n+\n+    /// [`Diagnostic::span_suggestions()`] but you can set the [`SuggestionStyle`].\n+    pub fn span_suggestions_with_style(\n+        &mut self,\n+        sp: Span,\n+        msg: impl Into<SubdiagnosticMessage>,\n+        suggestions: impl Iterator<Item = String>,\n+        applicability: Applicability,\n+        style: SuggestionStyle,\n     ) -> &mut Self {\n         let mut suggestions: Vec<_> = suggestions.collect();\n         suggestions.sort();\n@@ -706,14 +724,15 @@ impl Diagnostic {\n         self.push_suggestion(CodeSuggestion {\n             substitutions,\n             msg: self.subdiagnostic_message_to_diagnostic_message(msg),\n-            style: SuggestionStyle::ShowCode,\n+            style,\n             applicability,\n         });\n         self\n     }\n \n-    /// Prints out a message with multiple suggested edits of the code.\n-    /// See also [`Diagnostic::span_suggestion()`].\n+    /// Prints out a message with multiple suggested edits of the code, where each edit consists of\n+    /// multiple parts.\n+    /// See also [`Diagnostic::multipart_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n         msg: impl Into<SubdiagnosticMessage>,\n@@ -745,6 +764,7 @@ impl Diagnostic {\n         });\n         self\n     }\n+\n     /// Prints out a message with a suggested edit of the code. If the suggestion is presented\n     /// inline, it will only show the message and not the suggestion.\n     ///"}, {"sha": "1d2b1298a68f6372dca41d0bf71b0241636eda44", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -469,6 +469,7 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n+    #[instrument(level = \"trace\", skip(self))]\n     pub(crate) fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map_or(true, |features| features.stmt_expr_attributes) {\n             let mut err = feature_err(\n@@ -486,9 +487,12 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n-    pub fn configure_expr(&self, expr: &mut P<ast::Expr>) {\n-        for attr in expr.attrs.iter() {\n-            self.maybe_emit_expr_attr_err(attr);\n+    #[instrument(level = \"trace\", skip(self))]\n+    pub fn configure_expr(&self, expr: &mut P<ast::Expr>, method_receiver: bool) {\n+        if !method_receiver {\n+            for attr in expr.attrs.iter() {\n+                self.maybe_emit_expr_attr_err(attr);\n+            }\n         }\n \n         // If an expr is valid to cfg away it will have been removed by the"}, {"sha": "57713fb3cd61d59c7a2f33fdc46d8938b7eafb17", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -50,20 +50,23 @@ macro_rules! ast_fragments {\n         /// Can also serve as an input and intermediate result for macro expansion operations.\n         pub enum AstFragment {\n             OptExpr(Option<P<ast::Expr>>),\n+            MethodReceiverExpr(P<ast::Expr>),\n             $($Kind($AstTy),)*\n         }\n \n         /// \"Discriminant\" of an AST fragment.\n         #[derive(Copy, Clone, PartialEq, Eq)]\n         pub enum AstFragmentKind {\n             OptExpr,\n+            MethodReceiverExpr,\n             $($Kind,)*\n         }\n \n         impl AstFragmentKind {\n             pub fn name(self) -> &'static str {\n                 match self {\n                     AstFragmentKind::OptExpr => \"expression\",\n+                    AstFragmentKind::MethodReceiverExpr => \"expression\",\n                     $(AstFragmentKind::$Kind => $kind_name,)*\n                 }\n             }\n@@ -72,6 +75,8 @@ macro_rules! ast_fragments {\n                 match self {\n                     AstFragmentKind::OptExpr =>\n                         result.make_expr().map(Some).map(AstFragment::OptExpr),\n+                    AstFragmentKind::MethodReceiverExpr =>\n+                        result.make_expr().map(AstFragment::MethodReceiverExpr),\n                     $(AstFragmentKind::$Kind => result.$make_ast().map(AstFragment::$Kind),)*\n                 }\n             }\n@@ -98,6 +103,13 @@ macro_rules! ast_fragments {\n                 }\n             }\n \n+            pub fn make_method_receiver_expr(self) -> P<ast::Expr> {\n+                match self {\n+                    AstFragment::MethodReceiverExpr(expr) => expr,\n+                    _ => panic!(\"AstFragment::make_* called on the wrong kind of fragment\"),\n+                }\n+            }\n+\n             $(pub fn $make_ast(self) -> $AstTy {\n                 match self {\n                     AstFragment::$Kind(ast) => ast,\n@@ -120,6 +132,7 @@ macro_rules! ast_fragments {\n                             }\n                         });\n                     }\n+                    AstFragment::MethodReceiverExpr(expr) => vis.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ast) => vis.$mut_visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ast) =>\n                         ast.flat_map_in_place(|ast| vis.$flat_map_ast_elt(ast)),)?)*\n@@ -130,6 +143,7 @@ macro_rules! ast_fragments {\n                 match *self {\n                     AstFragment::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n                     AstFragment::OptExpr(None) => {}\n+                    AstFragment::MethodReceiverExpr(ref expr) => visitor.visit_method_receiver_expr(expr),\n                     $($(AstFragment::$Kind(ref ast) => visitor.$visit_ast(ast),)?)*\n                     $($(AstFragment::$Kind(ref ast) => for ast_elt in &ast[..] {\n                         visitor.$visit_ast_elt(ast_elt, $($args)*);\n@@ -222,6 +236,7 @@ impl AstFragmentKind {\n         match self {\n             AstFragmentKind::OptExpr\n             | AstFragmentKind::Expr\n+            | AstFragmentKind::MethodReceiverExpr\n             | AstFragmentKind::Stmts\n             | AstFragmentKind::Ty\n             | AstFragmentKind::Pat => SupportsMacroExpansion::Yes { supports_inner_attrs: false },\n@@ -285,6 +300,9 @@ impl AstFragmentKind {\n             AstFragmentKind::Expr => AstFragment::Expr(\n                 items.next().expect(\"expected exactly one expression\").expect_expr(),\n             ),\n+            AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(\n+                items.next().expect(\"expected exactly one expression\").expect_expr(),\n+            ),\n             AstFragmentKind::OptExpr => {\n                 AstFragment::OptExpr(items.next().map(Annotatable::expect_expr))\n             }\n@@ -893,6 +911,7 @@ pub fn parse_ast_fragment<'a>(\n             AstFragment::Stmts(stmts)\n         }\n         AstFragmentKind::Expr => AstFragment::Expr(this.parse_expr()?),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(this.parse_expr()?),\n         AstFragmentKind::OptExpr => {\n             if this.token != token::Eof {\n                 AstFragment::OptExpr(Some(this.parse_expr()?))\n@@ -1477,6 +1496,42 @@ impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, OptExprTag> {\n     }\n }\n \n+/// This struct is a hack to workaround unstable of `stmt_expr_attributes`.\n+/// It can be removed once that feature is stabilized.\n+struct MethodReceiverTag;\n+impl DummyAstNode for MethodReceiverTag {\n+    fn dummy() -> MethodReceiverTag {\n+        MethodReceiverTag\n+    }\n+}\n+impl InvocationCollectorNode for AstNodeWrapper<P<ast::Expr>, MethodReceiverTag> {\n+    type OutputTy = Self;\n+    type AttrsTy = ast::AttrVec;\n+    const KIND: AstFragmentKind = AstFragmentKind::MethodReceiverExpr;\n+    fn descr() -> &'static str {\n+        \"an expression\"\n+    }\n+    fn to_annotatable(self) -> Annotatable {\n+        Annotatable::Expr(self.wrapped)\n+    }\n+    fn fragment_to_output(fragment: AstFragment) -> Self::OutputTy {\n+        AstNodeWrapper::new(fragment.make_method_receiver_expr(), MethodReceiverTag)\n+    }\n+    fn noop_visit<V: MutVisitor>(&mut self, visitor: &mut V) {\n+        noop_visit_expr(&mut self.wrapped, visitor)\n+    }\n+    fn is_mac_call(&self) -> bool {\n+        matches!(self.wrapped.kind, ast::ExprKind::MacCall(..))\n+    }\n+    fn take_mac_call(self) -> (P<ast::MacCall>, Self::AttrsTy, AddSemicolon) {\n+        let node = self.wrapped.into_inner();\n+        match node.kind {\n+            ExprKind::MacCall(mac) => (mac, node.attrs, AddSemicolon::No),\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n struct InvocationCollector<'a, 'b> {\n     cx: &'a mut ExtCtxt<'b>,\n     invocations: Vec<(Invocation, Option<Lrc<SyntaxExtension>>)>,\n@@ -1840,6 +1895,14 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n         self.visit_node(node)\n     }\n \n+    fn visit_method_receiver_expr(&mut self, node: &mut P<ast::Expr>) {\n+        visit_clobber(node, |node| {\n+            let mut wrapper = AstNodeWrapper::new(node, MethodReceiverTag);\n+            self.visit_node(&mut wrapper);\n+            wrapper.wrapped\n+        })\n+    }\n+\n     fn filter_map_expr(&mut self, node: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         self.flat_map_node(AstNodeWrapper::new(node, OptExprTag))\n     }"}, {"sha": "faaf3b3fea58916ae2740546351fcfbc1cb0301a", "filename": "compiler/rustc_expand/src/placeholders.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fplaceholders.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -55,6 +55,7 @@ pub fn placeholder(\n         }),\n         AstFragmentKind::Expr => AstFragment::Expr(expr_placeholder()),\n         AstFragmentKind::OptExpr => AstFragment::OptExpr(Some(expr_placeholder())),\n+        AstFragmentKind::MethodReceiverExpr => AstFragment::MethodReceiverExpr(expr_placeholder()),\n         AstFragmentKind::Items => AstFragment::Items(smallvec![P(ast::Item {\n             id,\n             span,\n@@ -296,6 +297,13 @@ impl MutVisitor for PlaceholderExpander {\n         }\n     }\n \n+    fn visit_method_receiver_expr(&mut self, expr: &mut P<ast::Expr>) {\n+        match expr.kind {\n+            ast::ExprKind::MacCall(_) => *expr = self.remove(expr.id).make_method_receiver_expr(),\n+            _ => noop_visit_expr(expr, self),\n+        }\n+    }\n+\n     fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         match expr.kind {\n             ast::ExprKind::MacCall(_) => self.remove(expr.id).make_opt_expr(),"}, {"sha": "be14234afe28d37d0aaa434fe553c6b0617a6937", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -714,7 +714,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &hir::Expr<'tcx>,\n         checked_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n-    ) -> Option<(Span, String, String, Applicability, bool /* verbose */)> {\n+    ) -> Option<(\n+        Span,\n+        String,\n+        String,\n+        Applicability,\n+        bool, /* verbose */\n+        bool, /* suggest `&` or `&mut` type annotation */\n+    )> {\n         let sess = self.sess();\n         let sp = expr.span;\n \n@@ -746,6 +753,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     String::new(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                             }\n                         }\n@@ -760,6 +768,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     \"b\".to_string(),\n                                     Applicability::MachineApplicable,\n                                     true,\n+                                    false,\n                                 ));\n                     }\n                 }\n@@ -817,6 +826,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 sugg.2,\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ));\n                         }\n \n@@ -844,13 +854,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 format!(\"{prefix}&mut {sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                             hir::Mutability::Not => (\n                                 sp,\n                                 \"consider borrowing here\".to_string(),\n                                 format!(\"{prefix}&{sugg_expr}\"),\n                                 Applicability::MachineApplicable,\n                                 false,\n+                                false,\n                             ),\n                         });\n                     }\n@@ -880,6 +892,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             String::new(),\n                             Applicability::MachineApplicable,\n                             true,\n+                            true\n                         ));\n                     }\n                     return None;\n@@ -893,6 +906,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         String::new(),\n                         Applicability::MachineApplicable,\n                         true,\n+                        true,\n                     ));\n                 }\n             }\n@@ -959,6 +973,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             src,\n                             applicability,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }\n@@ -999,6 +1014,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 Applicability::MachineApplicable\n                             },\n                             true,\n+                            false,\n                         ));\n                     }\n \n@@ -1050,6 +1066,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             suggestion,\n                             Applicability::MachineApplicable,\n                             true,\n+                            false,\n                         ));\n                     }\n                 }"}, {"sha": "4db9c56f98fee3440daa27e6aafa5e4002c283bf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 44, "deletions": 3, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -327,17 +327,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n     ) -> bool {\n         let expr = expr.peel_blocks();\n-        if let Some((sp, msg, suggestion, applicability, verbose)) =\n+        if let Some((sp, msg, suggestion, applicability, verbose, annotation)) =\n             self.check_ref(expr, found, expected)\n         {\n             if verbose {\n                 err.span_suggestion_verbose(sp, &msg, suggestion, applicability);\n             } else {\n                 err.span_suggestion(sp, &msg, suggestion, applicability);\n             }\n+            if annotation {\n+                let suggest_annotation = match expr.peel_drop_temps().kind {\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Not, _) => \"&\",\n+                    hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, _) => \"&mut \",\n+                    _ => return true,\n+                };\n+                let mut tuple_indexes = Vec::new();\n+                let mut expr_id = expr.hir_id;\n+                for (parent_id, node) in self.tcx.hir().parent_iter(expr.hir_id) {\n+                    match node {\n+                        Node::Expr(&Expr { kind: ExprKind::Tup(subs), .. }) => {\n+                            tuple_indexes.push(\n+                                subs.iter()\n+                                    .enumerate()\n+                                    .find(|(_, sub_expr)| sub_expr.hir_id == expr_id)\n+                                    .unwrap()\n+                                    .0,\n+                            );\n+                            expr_id = parent_id;\n+                        }\n+                        Node::Local(local) => {\n+                            if let Some(mut ty) = local.ty {\n+                                while let Some(index) = tuple_indexes.pop() {\n+                                    match ty.kind {\n+                                        TyKind::Tup(tys) => ty = &tys[index],\n+                                        _ => return true,\n+                                    }\n+                                }\n+                                let annotation_span = ty.span;\n+                                err.span_suggestion(\n+                                    annotation_span.with_hi(annotation_span.lo()),\n+                                    format!(\"alternatively, consider changing the type annotation\"),\n+                                    suggest_annotation,\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            break;\n+                        }\n+                        _ => break,\n+                    }\n+                }\n+            }\n             return true;\n-        } else if self.suggest_else_fn_with_closure(err, expr, found, expected)\n-        {\n+        } else if self.suggest_else_fn_with_closure(err, expr, found, expected) {\n             return true;\n         } else if self.suggest_fn_call(err, expr, found, |output| self.can_coerce(output, expected))\n             && let ty::FnDef(def_id, ..) = &found.kind()"}, {"sha": "a74c172fa0c131ba646d44c03f896bb9e155a5a6", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -286,8 +286,8 @@ pub fn suggest_new_region_bound(\n ) {\n     debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n     // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-    let consider = \"consider changing the\";\n-    let declare = \"to declare that the\";\n+    let consider = \"consider changing\";\n+    let declare = \"to declare that\";\n     let explicit = format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n     let explicit_static =\n         arg.map(|arg| format!(\"explicit `'static` bound to the lifetime of {}\", arg));\n@@ -305,6 +305,10 @@ pub fn suggest_new_region_bound(\n                     return;\n                 };\n \n+                // Get the identity type for this RPIT\n+                let did = item_id.def_id.to_def_id();\n+                let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n+\n                 if let Some(span) = opaque\n                     .bounds\n                     .iter()\n@@ -321,7 +325,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             span,\n-                            &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n+                            &format!(\"{consider} `{ty}`'s {explicit_static}\"),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );\n@@ -351,12 +355,7 @@ pub fn suggest_new_region_bound(\n                 } else {\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n-                        &format!(\n-                            \"{declare} `impl Trait` {captures}, {explicit}\",\n-                            declare = declare,\n-                            captures = captures,\n-                            explicit = explicit,\n-                        ),\n+                        &format!(\"{declare} `{ty}` {captures}, {explicit}\",),\n                         &plus_lt,\n                         Applicability::MaybeIncorrect,\n                     );\n@@ -367,7 +366,7 @@ pub fn suggest_new_region_bound(\n                     err.span_suggestion_verbose(\n                         fn_return.span.shrink_to_hi(),\n                         &format!(\n-                            \"{declare} trait object {captures}, {explicit}\",\n+                            \"{declare} the trait object {captures}, {explicit}\",\n                             declare = declare,\n                             captures = captures,\n                             explicit = explicit,\n@@ -384,7 +383,7 @@ pub fn suggest_new_region_bound(\n                     if let Some(explicit_static) = &explicit_static {\n                         err.span_suggestion_verbose(\n                             lt.span,\n-                            &format!(\"{} trait object's {}\", consider, explicit_static),\n+                            &format!(\"{} the trait object's {}\", consider, explicit_static),\n                             &lifetime_name,\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "9d2325e8265e7b2a71d01228f9f872e6892c58e5", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -16,7 +16,6 @@ use rustc_data_structures::sync::{Lrc, OnceCell, WorkerLocal};\n use rustc_errors::{ErrorGuaranteed, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::StableCrateId;\n-use rustc_hir::definitions::Definitions;\n use rustc_lint::{BufferedEarlyLint, EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n use rustc_middle::arena::Arena;\n@@ -30,7 +29,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n+use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n use rustc_session::output::filename_for_input;\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -135,10 +134,7 @@ mod boxed_resolver {\n             f((&mut *resolver).as_mut().unwrap())\n         }\n \n-        pub fn to_resolver_outputs(\n-            resolver: Rc<RefCell<BoxedResolver>>,\n-        ) -> (Definitions, Box<CrateStoreDyn>, ty::ResolverOutputs, ty::ResolverAstLowering)\n-        {\n+        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ty::ResolverOutputs {\n             match Rc::try_unwrap(resolver) {\n                 Ok(resolver) => {\n                     let mut resolver = resolver.into_inner();\n@@ -788,8 +784,7 @@ pub fn create_global_ctxt<'tcx>(\n     // incr. comp. yet.\n     dep_graph.assert_ignored();\n \n-    let (definitions, cstore, resolver_outputs, resolver_for_lowering) =\n-        BoxedResolver::to_resolver_outputs(resolver);\n+    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n \n     let sess = &compiler.session();\n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n@@ -816,10 +811,7 @@ pub fn create_global_ctxt<'tcx>(\n                 lint_store,\n                 arena,\n                 hir_arena,\n-                definitions,\n-                cstore,\n                 resolver_outputs,\n-                resolver_for_lowering,\n                 krate,\n                 dep_graph,\n                 queries.on_disk_cache.as_ref().map(OnDiskCache::as_dyn),"}, {"sha": "3ea83fd09c794d5092586afe89cdc70a76be9fe5", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic_builder.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -454,7 +454,7 @@ impl<'a> DiagnosticDeriveVariantBuilder<'a> {\n \n                 self.formatting_init.extend(code_init);\n                 Ok(quote! {\n-                    #diag.span_suggestion_with_style(\n+                    #diag.span_suggestions_with_style(\n                         #span_field,\n                         rustc_errors::fluent::#slug,\n                         #code_field,"}, {"sha": "fa0ca5a52423af786b2c53bce1e4d6cf6a60874b", "filename": "compiler/rustc_macros/src/diagnostics/subdiagnostic.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fsubdiagnostic.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -11,9 +11,11 @@ use crate::diagnostics::utils::{\n };\n use proc_macro2::TokenStream;\n use quote::{format_ident, quote};\n-use syn::{spanned::Spanned, Attribute, Meta, MetaList, MetaNameValue, NestedMeta, Path};\n+use syn::{spanned::Spanned, Attribute, Meta, MetaList, NestedMeta, Path};\n use synstructure::{BindingInfo, Structure, VariantInfo};\n \n+use super::utils::{build_suggestion_code, AllowMultipleAlternatives};\n+\n /// The central struct for constructing the `add_to_diagnostic` method from an annotated struct.\n pub(crate) struct SubdiagnosticDeriveBuilder {\n     diag: syn::Ident,\n@@ -414,30 +416,31 @@ impl<'parent, 'a> SubdiagnosticDeriveVariantBuilder<'parent, 'a> {\n                     let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n                     let nested_name = nested_name.as_str();\n \n-                    let Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) = meta else {\n-                        throw_invalid_nested_attr!(attr, &nested_attr);\n-                    };\n-\n                     match nested_name {\n                         \"code\" => {\n-                            let formatted_str = self.build_format(&value.value(), value.span());\n                             let code_field = new_code_ident();\n-                            code.set_once((code_field, formatted_str), span);\n+                            let formatting_init = build_suggestion_code(\n+                                &code_field,\n+                                meta,\n+                                self,\n+                                AllowMultipleAlternatives::No,\n+                            );\n+                            code.set_once((code_field, formatting_init), span);\n                         }\n                         _ => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                             diag.help(\"`code` is the only valid nested attribute\")\n                         }),\n                     }\n                 }\n \n-                let Some((code_field, formatted_str)) = code.value() else {\n+                let Some((code_field, formatting_init)) = code.value() else {\n                     span_err(span, \"`#[suggestion_part(...)]` attribute without `code = \\\"...\\\"`\")\n                         .emit();\n                     return Ok(quote! {});\n                 };\n                 let binding = info.binding;\n \n-                self.formatting_init.extend(quote! { let #code_field = #formatted_str; });\n+                self.formatting_init.extend(formatting_init);\n                 let code_field = if clone_suggestion_code {\n                     quote! { #code_field.clone() }\n                 } else {"}, {"sha": "374c795d0a6385c81802224989716ab9227b9efa", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 94, "deletions": 11, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -2,7 +2,7 @@ use crate::diagnostics::error::{\n     span_err, throw_invalid_attr, throw_invalid_nested_attr, throw_span_err, DiagnosticDeriveError,\n };\n use proc_macro::Span;\n-use proc_macro2::TokenStream;\n+use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote, ToTokens};\n use std::cell::RefCell;\n use std::collections::{BTreeSet, HashMap};\n@@ -395,6 +395,82 @@ pub(super) fn build_field_mapping<'v>(variant: &VariantInfo<'v>) -> HashMap<Stri\n     fields_map\n }\n \n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum AllowMultipleAlternatives {\n+    No,\n+    Yes,\n+}\n+\n+/// Constructs the `format!()` invocation(s) necessary for a `#[suggestion*(code = \"foo\")]` or\n+/// `#[suggestion*(code(\"foo\", \"bar\"))]` attribute field\n+pub(super) fn build_suggestion_code(\n+    code_field: &Ident,\n+    meta: &Meta,\n+    fields: &impl HasFieldMap,\n+    allow_multiple: AllowMultipleAlternatives,\n+) -> TokenStream {\n+    let values = match meta {\n+        // `code = \"foo\"`\n+        Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(s), .. }) => vec![s],\n+        // `code(\"foo\", \"bar\")`\n+        Meta::List(MetaList { nested, .. }) => {\n+            if let AllowMultipleAlternatives::No = allow_multiple {\n+                span_err(\n+                    meta.span().unwrap(),\n+                    \"expected exactly one string literal for `code = ...`\",\n+                )\n+                .emit();\n+                vec![]\n+            } else if nested.is_empty() {\n+                span_err(\n+                    meta.span().unwrap(),\n+                    \"expected at least one string literal for `code(...)`\",\n+                )\n+                .emit();\n+                vec![]\n+            } else {\n+                nested\n+                    .into_iter()\n+                    .filter_map(|item| {\n+                        if let NestedMeta::Lit(syn::Lit::Str(s)) = item {\n+                            Some(s)\n+                        } else {\n+                            span_err(\n+                                item.span().unwrap(),\n+                                \"`code(...)` must contain only string literals\",\n+                            )\n+                            .emit();\n+                            None\n+                        }\n+                    })\n+                    .collect()\n+            }\n+        }\n+        _ => {\n+            span_err(\n+                meta.span().unwrap(),\n+                r#\"`code = \"...\"`/`code(...)` must contain only string literals\"#,\n+            )\n+            .emit();\n+            vec![]\n+        }\n+    };\n+\n+    if let AllowMultipleAlternatives::Yes = allow_multiple {\n+        let formatted_strings: Vec<_> = values\n+            .into_iter()\n+            .map(|value| fields.build_format(&value.value(), value.span()))\n+            .collect();\n+        quote! { let #code_field = [#(#formatted_strings),*].into_iter(); }\n+    } else if let [value] = values.as_slice() {\n+        let formatted_str = fields.build_format(&value.value(), value.span());\n+        quote! { let #code_field = #formatted_str; }\n+    } else {\n+        // error handled previously\n+        quote! { let #code_field = String::new(); }\n+    }\n+}\n+\n /// Possible styles for suggestion subdiagnostics.\n #[derive(Clone, Copy)]\n pub(super) enum SuggestionKind {\n@@ -571,28 +647,35 @@ impl SubdiagnosticKind {\n             let nested_name = meta.path().segments.last().unwrap().ident.to_string();\n             let nested_name = nested_name.as_str();\n \n-            let value = match meta {\n-                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => value,\n+            let string_value = match meta {\n+                Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(value), .. }) => Some(value),\n+\n                 Meta::Path(_) => throw_invalid_nested_attr!(attr, &nested_attr, |diag| {\n                     diag.help(\"a diagnostic slug must be the first argument to the attribute\")\n                 }),\n-                _ => {\n-                    invalid_nested_attr(attr, &nested_attr).emit();\n-                    continue;\n-                }\n+                _ => None,\n             };\n \n             match (nested_name, &mut kind) {\n                 (\"code\", SubdiagnosticKind::Suggestion { code_field, .. }) => {\n-                    let formatted_str = fields.build_format(&value.value(), value.span());\n-                    let code_init = quote! { let #code_field = #formatted_str; };\n+                    let code_init = build_suggestion_code(\n+                        code_field,\n+                        meta,\n+                        fields,\n+                        AllowMultipleAlternatives::Yes,\n+                    );\n                     code.set_once(code_init, span);\n                 }\n                 (\n                     \"applicability\",\n                     SubdiagnosticKind::Suggestion { ref mut applicability, .. }\n                     | SubdiagnosticKind::MultipartSuggestion { ref mut applicability, .. },\n                 ) => {\n+                    let Some(value) = string_value else {\n+                        invalid_nested_attr(attr, &nested_attr).emit();\n+                        continue;\n+                    };\n+\n                     let value = Applicability::from_str(&value.value()).unwrap_or_else(|()| {\n                         span_err(span, \"invalid applicability\").emit();\n                         Applicability::Unspecified\n@@ -623,7 +706,7 @@ impl SubdiagnosticKind {\n                     init\n                 } else {\n                     span_err(span, \"suggestion without `code = \\\"...\\\"`\").emit();\n-                    quote! { let #code_field: String = unreachable!(); }\n+                    quote! { let #code_field = std::iter::empty(); }\n                 };\n             }\n             SubdiagnosticKind::Label\n@@ -644,7 +727,7 @@ impl quote::IdentFragment for SubdiagnosticKind {\n             SubdiagnosticKind::Note => write!(f, \"note\"),\n             SubdiagnosticKind::Help => write!(f, \"help\"),\n             SubdiagnosticKind::Warn => write!(f, \"warn\"),\n-            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestion_with_style\"),\n+            SubdiagnosticKind::Suggestion { .. } => write!(f, \"suggestions_with_style\"),\n             SubdiagnosticKind::MultipartSuggestion { .. } => {\n                 write!(f, \"multipart_suggestion_with_style\")\n             }"}, {"sha": "67c85ef0d3b503f1ecd0b2f21dfae40306868bd1", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -23,7 +23,7 @@ rustc_queries! {\n         desc { \"triggering a delay span bug\" }\n     }\n \n-    query resolutions(_: ()) -> &'tcx ty::ResolverOutputs {\n+    query resolutions(_: ()) -> &'tcx ty::ResolverGlobalCtxt {\n         eval_always\n         no_hash\n         desc { \"getting the resolver outputs\" }"}, {"sha": "94e3f3b63c813aba6dcea8525bc83dc9a9bfa64d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -79,7 +79,7 @@ use std::mem;\n use std::ops::{Bound, Deref};\n use std::sync::Arc;\n \n-use super::{ImplPolarity, RvalueScopes};\n+use super::{ImplPolarity, ResolverOutputs, RvalueScopes};\n \n pub trait OnDiskCache<'tcx>: rustc_data_structures::sync::Sync {\n     /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n@@ -1067,10 +1067,9 @@ pub struct GlobalCtxt<'tcx> {\n     pub consts: CommonConsts<'tcx>,\n \n     definitions: RwLock<Definitions>,\n-    cstore: Box<CrateStoreDyn>,\n \n     /// Output of the resolver.\n-    pub(crate) untracked_resolutions: ty::ResolverOutputs,\n+    pub(crate) untracked_resolutions: ty::ResolverGlobalCtxt,\n     untracked_resolver_for_lowering: Steal<ty::ResolverAstLowering>,\n     /// The entire crate as AST. This field serves as the input for the hir_crate query,\n     /// which lowers it from AST to HIR. It must not be read or used by anything else.\n@@ -1233,10 +1232,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n         hir_arena: &'tcx WorkerLocal<hir::Arena<'tcx>>,\n-        definitions: Definitions,\n-        cstore: Box<CrateStoreDyn>,\n-        untracked_resolutions: ty::ResolverOutputs,\n-        untracked_resolver_for_lowering: ty::ResolverAstLowering,\n+        resolver_outputs: ResolverOutputs,\n         krate: Lrc<ast::Crate>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1245,6 +1241,11 @@ impl<'tcx> TyCtxt<'tcx> {\n         crate_name: &str,\n         output_filenames: OutputFilenames,\n     ) -> GlobalCtxt<'tcx> {\n+        let ResolverOutputs {\n+            definitions,\n+            global_ctxt: untracked_resolutions,\n+            ast_lowering: untracked_resolver_for_lowering,\n+        } = resolver_outputs;\n         let data_layout = TargetDataLayout::parse(&s.target).unwrap_or_else(|err| {\n             s.emit_fatal(err);\n         });\n@@ -1253,7 +1254,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             &interners,\n             s,\n             &definitions,\n-            &*cstore,\n+            &*untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n             &untracked_resolutions.source_span,\n         );\n@@ -1268,7 +1269,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             interners,\n             dep_graph,\n             definitions: RwLock::new(definitions),\n-            cstore,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n@@ -1369,7 +1369,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_key(id)\n         } else {\n-            self.cstore.def_key(id)\n+            self.untracked_resolutions.cstore.def_key(id)\n         }\n     }\n \n@@ -1383,7 +1383,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(id) = id.as_local() {\n             self.definitions_untracked().def_path(id)\n         } else {\n-            self.cstore.def_path(id)\n+            self.untracked_resolutions.cstore.def_path(id)\n         }\n     }\n \n@@ -1393,7 +1393,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.definitions_untracked().def_path_hash(def_id)\n         } else {\n-            self.cstore.def_path_hash(def_id)\n+            self.untracked_resolutions.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1402,7 +1402,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.cstore.stable_crate_id(crate_num)\n+            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1413,7 +1413,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1432,8 +1432,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cnum = self.cstore.stable_crate_id_to_crate_num(stable_crate_id);\n-            self.cstore.def_path_hash_to_def_id(cnum, hash)\n+            let cstore = &*self.untracked_resolutions.cstore;\n+            let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n+            cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n     }\n \n@@ -1445,7 +1446,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &self.cstore;\n+            let cstore = &*self.untracked_resolutions.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1520,7 +1521,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n-        &*self.cstore\n+        &*self.untracked_resolutions.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n@@ -1546,7 +1547,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let hcx = StableHashingContext::new(\n             self.sess,\n             &*definitions,\n-            &*self.cstore,\n+            &*self.untracked_resolutions.cstore,\n             &self.untracked_resolutions.source_span,\n         );\n         f(hcx)\n@@ -2364,7 +2365,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             st,\n             self.sess,\n             &self.definitions.read(),\n-            &*self.cstore,\n+            &*self.untracked_resolutions.cstore,\n             // This is only used to create a stable hashing context.\n             &self.untracked_resolutions.source_span,\n         )"}, {"sha": "9671d3a32f9453d09f7fdd595f5c83801000a129", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -38,11 +38,13 @@ use rustc_data_structures::tagged_ptr::CopyTaggedPtr;\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, LifetimeRes, Res};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::Node;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::{Decodable, Encodable};\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{ExpnId, Span};\n@@ -142,8 +144,15 @@ mod sty;\n \n pub type RegisteredTools = FxHashSet<Ident>;\n \n-#[derive(Debug)]\n pub struct ResolverOutputs {\n+    pub definitions: Definitions,\n+    pub global_ctxt: ResolverGlobalCtxt,\n+    pub ast_lowering: ResolverAstLowering,\n+}\n+\n+#[derive(Debug)]\n+pub struct ResolverGlobalCtxt {\n+    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,"}, {"sha": "12753c6785c9aa5ecb2c5a9a78946c3b382cec47", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -553,39 +553,46 @@ impl<'a> Parser<'a> {\n         match stmt.kind {\n             // Expression without semicolon.\n             StmtKind::Expr(ref mut expr)\n-                if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) =>\n-            {\n+                if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n-                if let Err(mut e) =\n-                    self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)])\n-                {\n-                    if let TokenKind::DocComment(..) = self.token.kind {\n-                        if let Ok(snippet) = self.span_to_snippet(self.token.span) {\n-                            let sp = self.token.span;\n-                            let marker = &snippet[..3];\n-                            let (comment_marker, doc_comment_marker) = marker.split_at(2);\n-\n-                            e.span_suggestion(\n-                                sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n-                                &format!(\n-                                    \"add a space before `{}` to use a regular comment\",\n-                                    doc_comment_marker,\n-                                ),\n-                                format!(\"{} {}\", comment_marker, doc_comment_marker),\n-                                Applicability::MaybeIncorrect,\n-                            );\n+                // `expect_one_of` returns PResult<'a, bool /* recovered */>\n+                let replace_with_err =\n+                    match self.expect_one_of(&[], &[token::Semi, token::CloseDelim(Delimiter::Brace)]) {\n+                    // Recover from parser, skip type error to avoid extra errors.\n+                    Ok(true) => true,\n+                    Err(mut e) => {\n+                        if let TokenKind::DocComment(..) = self.token.kind &&\n+                            let Ok(snippet) = self.span_to_snippet(self.token.span) {\n+                                let sp = self.token.span;\n+                                let marker = &snippet[..3];\n+                                let (comment_marker, doc_comment_marker) = marker.split_at(2);\n+\n+                                e.span_suggestion(\n+                                    sp.with_hi(sp.lo() + BytePos(marker.len() as u32)),\n+                                    &format!(\n+                                        \"add a space before `{}` to use a regular comment\",\n+                                        doc_comment_marker,\n+                                    ),\n+                                    format!(\"{} {}\", comment_marker, doc_comment_marker),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n                         }\n-                    }\n-                    if let Err(mut e) =\n-                        self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n-                    {\n-                        if recover.no() {\n-                            return Err(e);\n+\n+                        if let Err(mut e) =\n+                            self.check_mistyped_turbofish_with_multiple_type_params(e, expr)\n+                        {\n+                            if recover.no() {\n+                                return Err(e);\n+                            }\n+                            e.emit();\n+                            self.recover_stmt();\n                         }\n-                        e.emit();\n-                        self.recover_stmt();\n+                        true\n                     }\n-                    // Don't complain about type errors in body tail after parse error (#57383).\n+                    _ => false\n+                };\n+                if replace_with_err {\n+                    // We already emitted an error, so don't emit another type error\n                     let sp = expr.span.to(self.prev_token.span);\n                     *expr = self.mk_expr_err(sp);\n                 }"}, {"sha": "c2213e8d1e2e3a16c0868873d2b02defe52175c6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -42,9 +42,10 @@ use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n use rustc_middle::span_bug;\n-use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n+use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools};\n+use rustc_middle::ty::{ResolverGlobalCtxt, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, CrateStoreDyn, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -1376,9 +1377,7 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n-    pub fn into_outputs(\n-        self,\n-    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n+    pub fn into_outputs(self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n         let cstore = Box::new(self.crate_loader.into_cstore());\n@@ -1394,7 +1393,8 @@ impl<'a> Resolver<'a> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let access_levels = self.access_levels;\n-        let resolutions = ResolverOutputs {\n+        let global_ctxt = ResolverGlobalCtxt {\n+            cstore,\n             source_span,\n             expn_that_defined,\n             visibilities,\n@@ -1416,7 +1416,7 @@ impl<'a> Resolver<'a> {\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n         };\n-        let resolutions_lowering = ty::ResolverAstLowering {\n+        let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args,\n             partial_res_map: self.partial_res_map,\n             import_res_map: self.import_res_map,\n@@ -1429,16 +1429,15 @@ impl<'a> Resolver<'a> {\n             trait_map: self.trait_map,\n             builtin_macro_kinds: self.builtin_macro_kinds,\n         };\n-        (definitions, cstore, resolutions, resolutions_lowering)\n+        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n     }\n \n-    pub fn clone_outputs(\n-        &self,\n-    ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs, ty::ResolverAstLowering) {\n+    pub fn clone_outputs(&self) -> ResolverOutputs {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions.clone();\n         let cstore = Box::new(self.cstore().clone());\n-        let resolutions = ResolverOutputs {\n+        let global_ctxt = ResolverGlobalCtxt {\n+            cstore,\n             source_span: self.source_span.clone(),\n             expn_that_defined: self.expn_that_defined.clone(),\n             visibilities: self.visibilities.clone(),\n@@ -1460,7 +1459,7 @@ impl<'a> Resolver<'a> {\n             registered_tools: self.registered_tools.clone(),\n             access_levels: self.access_levels.clone(),\n         };\n-        let resolutions_lowering = ty::ResolverAstLowering {\n+        let ast_lowering = ty::ResolverAstLowering {\n             legacy_const_generic_args: self.legacy_const_generic_args.clone(),\n             partial_res_map: self.partial_res_map.clone(),\n             import_res_map: self.import_res_map.clone(),\n@@ -1473,7 +1472,7 @@ impl<'a> Resolver<'a> {\n             trait_map: self.trait_map.clone(),\n             builtin_macro_kinds: self.builtin_macro_kinds.clone(),\n         };\n-        (definitions, cstore, resolutions, resolutions_lowering)\n+        ResolverOutputs { definitions, global_ctxt, ast_lowering }\n     }\n \n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {"}, {"sha": "29f796fad6d5033bd70f3f885eefcd147b8433a6", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -2229,6 +2229,16 @@ pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n     !ptr.is_null() && ptr.is_aligned()\n }\n \n+/// Checks whether an allocation of `len` instances of `T` exceeds\n+/// the maximum allowed allocation size.\n+pub(crate) fn is_valid_allocation_size<T>(len: usize) -> bool {\n+    let max_len = const {\n+        let size = crate::mem::size_of::<T>();\n+        if size == 0 { usize::MAX } else { isize::MAX as usize / size }\n+    };\n+    len <= max_len\n+}\n+\n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {"}, {"sha": "659409557c9107213485fdb1acc1575d1b0ad9d8", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -192,6 +192,7 @@\n #![feature(extern_types)]\n #![feature(fundamental)]\n #![feature(if_let_guard)]\n+#![feature(inline_const)]\n #![feature(intra_doc_pointers)]\n #![feature(intrinsics)]\n #![feature(lang_items)]"}, {"sha": "dace748fed4559f56cdd50874583275b6d42d188", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -1,7 +1,9 @@\n //! Free functions to create `&[T]` and `&mut [T]`.\n \n use crate::array;\n-use crate::intrinsics::{assert_unsafe_precondition, is_aligned_and_not_null};\n+use crate::intrinsics::{\n+    assert_unsafe_precondition, is_aligned_and_not_null, is_valid_allocation_size,\n+};\n use crate::ops::Range;\n use crate::ptr;\n \n@@ -91,8 +93,7 @@ pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T]\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n     unsafe {\n         assert_unsafe_precondition!([T](data: *const T, len: usize) =>\n-            is_aligned_and_not_null(data)\n-                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n         );\n         &*ptr::slice_from_raw_parts(data, len)\n     }\n@@ -135,8 +136,7 @@ pub const unsafe fn from_raw_parts_mut<'a, T>(data: *mut T, len: usize) -> &'a m\n     // SAFETY: the caller must uphold the safety contract for `from_raw_parts_mut`.\n     unsafe {\n         assert_unsafe_precondition!([T](data: *mut T, len: usize) =>\n-            is_aligned_and_not_null(data)\n-                && crate::mem::size_of::<T>().saturating_mul(len) <= isize::MAX as usize\n+            is_aligned_and_not_null(data) && is_valid_allocation_size::<T>(len)\n         );\n         &mut *ptr::slice_from_raw_parts_mut(data, len)\n     }"}, {"sha": "ca77e483d6ff8dd233fd2327e7aeb45a397f47a7", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -758,3 +758,41 @@ struct WithDocComment {\n     #[primary_span]\n     span: Span,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsGood {\n+    #[suggestion(code(\"foo\", \"bar\"))]\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsSingleItem {\n+    #[suggestion(code(\"foo\"))]\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsNoItem {\n+    #[suggestion(code())]\n+    //~^ ERROR expected at least one string literal for `code(...)`\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsInvalidItem {\n+    #[suggestion(code(foo))]\n+    //~^ ERROR `code(...)` must contain only string literals\n+    sub: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(compiletest_example)]\n+struct SuggestionsInvalidLiteral {\n+    #[suggestion(code = 3)]\n+    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    sub: Span,\n+}"}, {"sha": "859c272b6ba9c3a98f3381dc93093c50dd3be53b", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -573,6 +573,24 @@ LL |     #[subdiagnostic(eager)]\n    |\n    = help: eager subdiagnostics are not supported on lints\n \n+error: expected at least one string literal for `code(...)`\n+  --> $DIR/diagnostic-derive.rs:779:18\n+   |\n+LL |     #[suggestion(code())]\n+   |                  ^^^^^^\n+\n+error: `code(...)` must contain only string literals\n+  --> $DIR/diagnostic-derive.rs:787:23\n+   |\n+LL |     #[suggestion(code(foo))]\n+   |                       ^^^\n+\n+error: `code = \"...\"`/`code(...)` must contain only string literals\n+  --> $DIR/diagnostic-derive.rs:795:18\n+   |\n+LL |     #[suggestion(code = 3)]\n+   |                  ^^^^^^^^\n+\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n@@ -647,7 +665,7 @@ LL |         arg: impl IntoDiagnosticArg,\n    |                   ^^^^^^^^^^^^^^^^^ required by this bound in `DiagnosticBuilder::<'a, G>::set_arg`\n    = note: this error originates in the derive macro `Diagnostic` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 80 previous errors\n+error: aborting due to 83 previous errors\n \n Some errors have detailed explanations: E0277, E0425.\n For more information about an error, try `rustc --explain E0277`."}, {"sha": "efec85eb52c2ec90aaa71856264e86c3d4e4e5a5", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -661,3 +661,48 @@ enum BL {\n         span: Span,\n     }\n }\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BM {\n+    #[suggestion_part(code(\"foo\"))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BN {\n+    #[suggestion_part(code(\"foo\", \"bar\"))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BO {\n+    #[suggestion_part(code(3))]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BP {\n+    #[suggestion_part(code())]\n+    //~^ ERROR expected exactly one string literal for `code = ...`\n+    span: Span,\n+    r#type: String,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(parser_add_paren)]\n+struct BQ {\n+    #[suggestion_part(code = 3)]\n+    //~^ ERROR `code = \"...\"`/`code(...)` must contain only string literals\n+    span: Span,\n+    r#type: String,\n+}"}, {"sha": "a85a8711eaca4e983cedf5948977e848446224cd", "filename": "src/test/ui-fulldeps/session-diagnostic/subdiagnostic-derive.stderr", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fsubdiagnostic-derive.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -415,6 +415,36 @@ error: `#[applicability]` has no effect if all `#[suggestion]`/`#[multipart_sugg\n LL |     #[applicability]\n    |     ^^^^^^^^^^^^^^^^\n \n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:668:23\n+   |\n+LL |     #[suggestion_part(code(\"foo\"))]\n+   |                       ^^^^^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:677:23\n+   |\n+LL |     #[suggestion_part(code(\"foo\", \"bar\"))]\n+   |                       ^^^^^^^^^^^^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:686:23\n+   |\n+LL |     #[suggestion_part(code(3))]\n+   |                       ^^^^^^^\n+\n+error: expected exactly one string literal for `code = ...`\n+  --> $DIR/subdiagnostic-derive.rs:695:23\n+   |\n+LL |     #[suggestion_part(code())]\n+   |                       ^^^^^^\n+\n+error: `code = \"...\"`/`code(...)` must contain only string literals\n+  --> $DIR/subdiagnostic-derive.rs:704:23\n+   |\n+LL |     #[suggestion_part(code = 3)]\n+   |                       ^^^^^^^^\n+\n error: cannot find attribute `foo` in this scope\n   --> $DIR/subdiagnostic-derive.rs:63:3\n    |\n@@ -475,6 +505,6 @@ error[E0425]: cannot find value `slug` in module `rustc_errors::fluent`\n LL | #[label(slug)]\n    |         ^^^^ not found in `rustc_errors::fluent`\n \n-error: aborting due to 67 previous errors\n+error: aborting due to 72 previous errors\n \n For more information about this error, try `rustc --explain E0425`."}, {"sha": "ae4d0d5853ca687569c3800263494400d435061b", "filename": "src/test/ui/async-await/multiple-lifetimes/ret-impl-trait-one.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fmultiple-lifetimes%2Fret-impl-trait-one.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -25,7 +25,7 @@ LL | |     (a, b)\n LL | | }\n    | |_^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Trait<'a>` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | async fn async_ret_impl_trait1<'a, 'b>(a: &'a u8, b: &'b u8) -> impl Trait<'a> + 'b {\n    |                                                                                ++++"}, {"sha": "61ad3b8c17ab2fb1bd0430045fc9b65e7d3e8d3a", "filename": "src/test/ui/cfg/cfg-method-receiver-ok.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver-ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver-ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver-ok.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,14 @@\n+// check-pass\n+\n+macro_rules! foo {\n+    () => {\n+        #[allow(unreachable_patterns)]\n+        {\n+            123i32\n+        }\n+    };\n+}\n+\n+fn main() {\n+    let _ = foo!().abs();\n+}"}, {"sha": "71134ff17b5278def8fac46312b82f0a176f833f", "filename": "src/test/ui/cfg/cfg-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -7,6 +7,5 @@ macro_rules! cbor_map {\n \n fn main() {\n     cbor_map! { #[cfg(test)] 4};\n-    //~^ ERROR attributes on expressions are experimental\n-    //~| ERROR removing an expression is not supported in this position\n+    //~^ ERROR removing an expression is not supported in this position\n }"}, {"sha": "5767a7c1b4b1cb4668c97fb93ed501d49b275f1b", "filename": "src/test/ui/cfg/cfg-method-receiver.stderr", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg%2Fcfg-method-receiver.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -1,12 +1,3 @@\n-error[E0658]: attributes on expressions are experimental\n-  --> $DIR/cfg-method-receiver.rs:9:17\n-   |\n-LL |     cbor_map! { #[cfg(test)] 4};\n-   |                 ^^^^^^^^^^^^\n-   |\n-   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n-   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n-\n error: removing an expression is not supported in this position\n   --> $DIR/cfg-method-receiver.rs:9:17\n    |\n@@ -28,7 +19,6 @@ help: you must specify a concrete type for this numeric value, like `i32`\n LL |     cbor_map! { #[cfg(test)] 4_i32};\n    |                              ~~~~~\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0689.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0689`."}, {"sha": "3cc47e1e89da8b4da45aac0b3cf87ae176b5dfc8", "filename": "src/test/ui/impl-trait/hidden-lifetimes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fhidden-lifetimes.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a {\n LL |     x\n    |     ^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Swap + 'a` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_ref<'a, 'b, T: 'static>(x: &'a mut &'b T) -> impl Swap + 'a + 'b {\n    |                                                                     ++++\n@@ -19,7 +19,7 @@ LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl S\n LL |     x\n    |     ^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Swap + 'a` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn hide_rc_refcell<'a, 'b: 'a, T: 'static>(x: Rc<RefCell<&'b T>>) -> impl Swap + 'a + 'b {\n    |                                                                                     ++++"}, {"sha": "ec49a61795a0c4cd03f6eb09efd1191fa125a443", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -7,7 +7,7 @@ LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> im\n LL |     if condition() { a } else { b }\n    |                                 ^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Trait<'d, 'e>` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e> + 'b\n    |                                                                                             ++++"}, {"sha": "c36f9bc6957c62e0c99ee21a334944d1a185e8a1", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -7,7 +7,7 @@ LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a,\n LL |     if condition() { a } else { b }\n    |                                 ^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Trait<'a, 'b>` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b> + 'b\n    |                                                                                 ++++"}, {"sha": "9c81791fbcba541b2141c9527e4ea5af9bc3034a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL | fn elided(x: &i32) -> impl Copy { x }\n    |              |\n    |              hidden type `&i32` captures the anonymous lifetime defined here\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Copy` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided(x: &i32) -> impl Copy + '_ { x }\n    |                                 ++++\n@@ -19,7 +19,7 @@ LL | fn explicit<'a>(x: &'a i32) -> impl Copy { x }\n    |             |\n    |             hidden type `&'a i32` captures the lifetime `'a` as defined here\n    |\n-help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n+help: to declare that `impl Copy` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL | fn explicit<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                          ++++\n@@ -32,7 +32,7 @@ LL | fn elided2(x: &i32) -> impl Copy + 'static { x }\n    |               |\n    |               let's call the lifetime of this reference `'1`\n    |\n-help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+help: consider changing `impl Copy + 'static`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn elided2(x: &i32) -> impl Copy + '_ { x }\n    |                                    ~~\n@@ -47,7 +47,7 @@ error: lifetime may not live long enough\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'static { x }\n    |              -- lifetime `'a` defined here            ^ returning this value requires that `'a` must outlive `'static`\n    |\n-help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+help: consider changing `impl Copy + 'static`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn explicit2<'a>(x: &'a i32) -> impl Copy + 'a { x }\n    |                                             ~~\n@@ -76,7 +76,7 @@ help: to declare that the trait object captures data from argument `x`, you can\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n    |                                       ++++\n-help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Debug` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n    |                                                    ++++\n@@ -87,7 +87,7 @@ error: lifetime may not live long enough\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n    |\n-help: consider changing the `impl Trait`'s explicit `'static` bound to the lifetime of argument `x`\n+help: consider changing `impl LifetimeTrait<'a> + 'static`'s explicit `'static` bound to the lifetime of argument `x`\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'a { x }\n    |                                                           ~~\n@@ -104,7 +104,7 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n LL |     move |_| println!(\"{}\", y)\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'b`, you can add an explicit `'b` lifetime bound\n+help: to declare that `impl Fn(&'a u32)` captures `'b`, you can add an explicit `'b` lifetime bound\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) + 'b {\n    |                                                                              ++++"}, {"sha": "44a790cb1a43abba4b41412e0039477a8ac1ffba", "filename": "src/test/ui/impl-trait/region-escape-via-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fregion-escape-via-bound.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -7,7 +7,7 @@ LL | fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y>\n LL |     x\n    |     ^\n    |\n-help: to declare that the `impl Trait` captures `'x`, you can add an explicit `'x` lifetime bound\n+help: to declare that `impl Trait<'y>` captures `'x`, you can add an explicit `'x` lifetime bound\n    |\n LL | fn foo<'x, 'y>(x: Cell<&'x u32>) -> impl Trait<'y> + 'x\n    |                                                    ++++"}, {"sha": "b365bd8845480ca89abf64df1e5a1502f53c38ac", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Iterator<Item = u32>` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n@@ -19,7 +19,7 @@ LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Iterator<Item = u32>` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n    |                                                           ++++\n@@ -32,7 +32,7 @@ LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n+help: to declare that `impl Iterator<Item = u32>` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++\n@@ -45,7 +45,7 @@ LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n LL |         self.x.iter().map(|a| a.0)\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-help: to declare that the `impl Trait` captures `'a`, you can add an explicit `'a` lifetime bound\n+help: to declare that `impl Iterator<Item = u32>` captures `'a`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n    |                                                             ++++"}, {"sha": "bde0fe1a015742f0674e2e4af9836b91f1c0be93", "filename": "src/test/ui/macros/macro_rules-unmatchable-literals.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,14 @@\n+// Pinning tests for things that don't work to make sure we notice if that changes\n+\n+#![crate_type = \"lib\"]\n+\n+macro_rules! octal_with_bad_digit {\n+    ( 0o1238 ) => {}; //~ ERROR invalid digit\n+}\n+\n+macro_rules! binary_with_bad_digit {\n+    ( 0b012 ) => {}; //~ ERROR invalid digit\n+}\n+\n+// This can't happen for Hex and Decimal as things like `123A` and `0xFFG`\n+// get treated as unknown *suffixes*, rather than digits."}, {"sha": "956a669791d0e1c7ab475316aeeb7c688ff7d958", "filename": "src/test/ui/macros/macro_rules-unmatchable-literals.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_rules-unmatchable-literals.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,14 @@\n+error: invalid digit for a base 8 literal\n+  --> $DIR/macro_rules-unmatchable-literals.rs:6:12\n+   |\n+LL |     ( 0o1238 ) => {};\n+   |            ^\n+\n+error: invalid digit for a base 2 literal\n+  --> $DIR/macro_rules-unmatchable-literals.rs:10:11\n+   |\n+LL |     ( 0b012 ) => {};\n+   |           ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "737cb35841cf59fe72bea1c5f47e71674932638e", "filename": "src/test/ui/nll/ty-outlives/impl-trait-captures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fimpl-trait-captures.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> {\n LL |     x\n    |     ^\n    |\n-help: to declare that the `impl Trait` captures `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrNamed(DefId(0:12 ~ impl_trait_captures[1afc]::foo::'_), '_))`, you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrNamed(DefId(0:12 ~ impl_trait_captures[1afc]::foo::'_), '_))` lifetime bound\n+help: to declare that `Opaque(DefId(0:13 ~ impl_trait_captures[1afc]::foo::{opaque#0}), [ReEarlyBound(0, 'a), T, ReEarlyBound(2, 'a)])` captures `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrNamed(DefId(0:12 ~ impl_trait_captures[1afc]::foo::'_), '_))`, you can add an explicit `ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrNamed(DefId(0:12 ~ impl_trait_captures[1afc]::foo::'_), '_))` lifetime bound\n    |\n LL | fn foo<'a, T>(x: &T) -> impl Foo<'a> + ReFree(DefId(0:8 ~ impl_trait_captures[1afc]::foo), BrNamed(DefId(0:12 ~ impl_trait_captures[1afc]::foo::'_), '_)) {\n    |                                      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++"}, {"sha": "c2f8123ca4e6770aec5010a73de8c5b77863a304", "filename": "src/test/ui/parser/issue-103425.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fparser%2Fissue-103425.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fparser%2Fissue-103425.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103425.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,15 @@\n+fn f() -> f32 {\n+    3\n+    //~^ ERROR expected `;`\n+    5.0\n+}\n+\n+fn k() -> f32 {\n+    2_u32\n+    //~^ ERROR expected `;`\n+    3_i8\n+    //~^ ERROR expected `;`\n+    5.0\n+}\n+\n+fn main() {}"}, {"sha": "0efe3e3ca7117549a64beafff40eebebc0351d40", "filename": "src/test/ui/parser/issue-103425.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fparser%2Fissue-103425.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fparser%2Fissue-103425.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-103425.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,29 @@\n+error: expected `;`, found `5.0`\n+  --> $DIR/issue-103425.rs:2:6\n+   |\n+LL |     3\n+   |      ^ help: add `;` here\n+LL |\n+LL |     5.0\n+   |     --- unexpected token\n+\n+error: expected `;`, found `3_i8`\n+  --> $DIR/issue-103425.rs:8:10\n+   |\n+LL |     2_u32\n+   |          ^ help: add `;` here\n+LL |\n+LL |     3_i8\n+   |     ---- unexpected token\n+\n+error: expected `;`, found `5.0`\n+  --> $DIR/issue-103425.rs:10:9\n+   |\n+LL |     3_i8\n+   |         ^ help: add `;` here\n+LL |\n+LL |     5.0\n+   |     --- unexpected token\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "eb3d3e4a67a98e6a74219a8851804f74f2c3f957", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                          |\n    |                          hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Clone` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                                ++++"}, {"sha": "2c0b2a0d919382d7aaee4b8c60676823d83010b9", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -6,7 +6,7 @@ LL |     fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                    |\n    |                    hidden type `Pin<&Foo>` captures the anonymous lifetime defined here\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Clone` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n    |                                          ++++"}, {"sha": "8ed2b9c9a6330d4107496d00f2f191b233db98ac", "filename": "src/test/ui/suggestions/format-borrow.stderr", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fformat-borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fformat-borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fformat-borrow.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -11,6 +11,10 @@ help: consider removing the borrow\n LL -     let a: String = &String::from(\"a\");\n LL +     let a: String = String::from(\"a\");\n    |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let a: &String = &String::from(\"a\");\n+   |            +\n \n error[E0308]: mismatched types\n   --> $DIR/format-borrow.rs:4:21\n@@ -25,6 +29,10 @@ help: consider removing the borrow\n LL -     let b: String = &format!(\"b\");\n LL +     let b: String = format!(\"b\");\n    |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let b: &String = &format!(\"b\");\n+   |            +\n \n error[E0308]: mismatched types\n   --> $DIR/format-borrow.rs:6:21\n@@ -39,6 +47,10 @@ help: consider removing the borrow\n LL -     let c: String = &mut format!(\"c\");\n LL +     let c: String = format!(\"c\");\n    |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let c: &mut String = &mut format!(\"c\");\n+   |            ++++\n \n error[E0308]: mismatched types\n   --> $DIR/format-borrow.rs:8:21\n@@ -53,6 +65,10 @@ help: consider removing the borrow\n LL -     let d: String = &mut (format!(\"d\"));\n LL +     let d: String = format!(\"d\"));\n    |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let d: &mut String = &mut (format!(\"d\"));\n+   |            ++++\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c1a791d8d857a9c3f4c385cdff5aa7908eb202ff", "filename": "src/test/ui/suggestions/issue-102892.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.rs", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.rs?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,25 @@\n+#![allow(dead_code, unused_variables)]\n+\n+use std::sync::Arc;\n+\n+#[derive(Debug)]\n+struct A;\n+#[derive(Debug)]\n+struct B;\n+\n+fn process_without_annot(arc: &Arc<(A, B)>) {\n+    let (a, b) = **arc; // suggests putting `&**arc` here; with that, fixed!\n+}\n+\n+fn process_with_annot(arc: &Arc<(A, B)>) {\n+    let (a, b): (A, B) = &**arc; // suggests putting `&**arc` here too\n+    //~^ ERROR mismatched types\n+}\n+\n+fn process_with_tuple_annot(mutation: &mut (A, B), arc: &Arc<(A, B)>) {\n+    let (a, b): ((A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "a3dbc7cb861ffe6331c9f024399570ddc1a1a538", "filename": "src/test/ui/suggestions/issue-102892.stderr", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-102892.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -0,0 +1,57 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102892.rs:15:26\n+   |\n+LL |     let (a, b): (A, B) = &**arc; // suggests putting `&**arc` here too\n+   |                 ------   ^^^^^^ expected tuple, found `&(A, B)`\n+   |                 |\n+   |                 expected due to this\n+   |\n+   = note:  expected tuple `(A, B)`\n+           found reference `&(A, B)`\n+help: consider removing the borrow\n+   |\n+LL -     let (a, b): (A, B) = &**arc; // suggests putting `&**arc` here too\n+LL +     let (a, b): (A, B) = **arc; // suggests putting `&**arc` here too\n+   |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let (a, b): &(A, B) = &**arc; // suggests putting `&**arc` here too\n+   |                 +\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102892.rs:20:32\n+   |\n+LL |     let (a, b): ((A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+   |                                ^^^^^^^^^^^^^^ expected tuple, found `&mut (A, B)`\n+   |\n+   = note:          expected tuple `(A, B)`\n+           found mutable reference `&mut (A, B)`\n+help: consider removing the borrow\n+   |\n+LL -     let (a, b): ((A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+LL +     let (a, b): ((A, B), A) = (*mutation, &(**arc).0); // suggests putting `&**arc` here too\n+   |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let (a, b): (&mut (A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+   |                  ++++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-102892.rs:20:48\n+   |\n+LL |     let (a, b): ((A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+   |                                                ^^^^^^^^^^ expected struct `A`, found `&A`\n+   |\n+help: consider removing the borrow\n+   |\n+LL -     let (a, b): ((A, B), A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+LL +     let (a, b): ((A, B), A) = (&mut *mutation, (**arc).0); // suggests putting `&**arc` here too\n+   |\n+help: alternatively, consider changing the type annotation\n+   |\n+LL |     let (a, b): ((A, B), &A) = (&mut *mutation, &(**arc).0); // suggests putting `&**arc` here too\n+   |                          +\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "fa758bf05df5a1d747ccfd521e73439e67801e14", "filename": "src/test/ui/suggestions/lifetimes/missing-lifetimes-in-signature.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Fmissing-lifetimes-in-signature.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -18,7 +18,7 @@ LL | |         *dest = g.get();\n LL | |     }\n    | |_____^\n    |\n-help: to declare that the `impl Trait` captures `'_`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl FnOnce()` captures `'_`, you can add an explicit `'_` lifetime bound\n    |\n LL | fn foo<G, T>(g: G, dest: &mut T) -> impl FnOnce() + '_\n    |                                                   ++++"}, {"sha": "c77ef79e7ed18f47302360117013f27e7efeb2e5", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/629a414d7ba4caa3ca28b0a46c478e2ecb4c0059/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=629a414d7ba4caa3ca28b0a46c478e2ecb4c0059", "patch": "@@ -10,7 +10,7 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'1` must outlive `'static`\n    |\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+help: to declare that `impl Iterator<Item = Box<(dyn Foo + 'static)>>` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n    |\n LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n    |                                                          ++++\n@@ -65,7 +65,7 @@ LL | |             remaining: self.0.iter(),\n LL | |         }\n    | |_________^ returning this value requires that `'a` must outlive `'static`\n    |\n-help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+help: to declare that `impl Iterator<Item = Box<(dyn Foo + 'static)>>` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n    |\n LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n    |                                                                 ++++"}]}