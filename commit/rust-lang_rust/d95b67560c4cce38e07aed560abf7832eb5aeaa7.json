{"sha": "d95b67560c4cce38e07aed560abf7832eb5aeaa7", "node_id": "C_kwDOAAsO6NoAKGQ5NWI2NzU2MGM0Y2NlMzhlMDdhZWQ1NjBhYmY3ODMyZWI1YWVhYTc", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-05-08T17:11:53Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T15:42:14Z"}, "message": "Rework `only_used_in_recursion`", "tree": {"sha": "d37ac454957f6edf1f7a2e9b10708535f9717e70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d37ac454957f6edf1f7a2e9b10708535f9717e70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d95b67560c4cce38e07aed560abf7832eb5aeaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d95b67560c4cce38e07aed560abf7832eb5aeaa7", "html_url": "https://github.com/rust-lang/rust/commit/d95b67560c4cce38e07aed560abf7832eb5aeaa7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d95b67560c4cce38e07aed560abf7832eb5aeaa7/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "477c16d45bb93cc92611b56614ce2b823bffab8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/477c16d45bb93cc92611b56614ce2b823bffab8d", "html_url": "https://github.com/rust-lang/rust/commit/477c16d45bb93cc92611b56614ce2b823bffab8d"}], "stats": {"total": 1310, "additions": 655, "deletions": 655}, "files": [{"sha": "467051cfa6884035fea61136e674bfcd8b02f4ca", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -860,7 +860,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(manual_bits::ManualBits::new(msrv)));\n     store.register_late_pass(|| Box::new(default_union_representation::DefaultUnionRepresentation));\n     store.register_early_pass(|| Box::new(doc_link_with_quotes::DocLinkWithQuotes));\n-    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion));\n+    store.register_late_pass(|| Box::new(only_used_in_recursion::OnlyUsedInRecursion::default()));\n     let allow_dbg_in_tests = conf.allow_dbg_in_tests;\n     store.register_late_pass(move || Box::new(dbg_macro::DbgMacro::new(allow_dbg_in_tests)));\n     let cargo_ignore_publish = conf.cargo_ignore_publish;"}, {"sha": "a4f516df735726505224ea943ff0e00c7e7b9720", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 285, "deletions": 543, "changes": 828, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -1,25 +1,16 @@\n-use std::collections::VecDeque;\n-\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lint_allowed;\n-use itertools::{izip, Itertools};\n-use rustc_ast::{walk_list, Label, Mutability};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::{get_expr_use_or_unification_node, get_parent_node, path_def_id, path_to_local, path_to_local_id};\n+use core::cell::Cell;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n-use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_hir::intravisit::{walk_expr, walk_stmt, FnKind, Visitor};\n-use rustc_hir::{\n-    Arm, Block, Body, Closure, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TyKind, UnOp,\n-};\n+use rustc_hir::hir_id::HirIdMap;\n+use rustc_hir::{Body, Expr, ExprKind, HirId, ImplItem, ImplItemKind, Node, PatKind, TraitItem, TraitItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_middle::ty::{Ty, TyCtxt, TypeckResults};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::symbol::kw;\n-use rustc_span::symbol::Ident;\n+use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n+use rustc_middle::ty::{self, ConstKind};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::Span;\n \n declare_clippy_lint! {\n@@ -92,569 +83,320 @@ declare_clippy_lint! {\n     nursery,\n     \"arguments that is only used in recursion can be removed\"\n }\n-declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        kind: FnKind<'tcx>,\n-        decl: &'tcx rustc_hir::FnDecl<'tcx>,\n-        body: &'tcx Body<'tcx>,\n-        _: Span,\n-        id: HirId,\n-    ) {\n-        if is_lint_allowed(cx, ONLY_USED_IN_RECURSION, id) {\n-            return;\n-        }\n-        if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n-            let def_id = id.owner.to_def_id();\n-            let data = cx.tcx.def_path(def_id).data;\n-\n-            if data.len() > 1 {\n-                match data.get(data.len() - 2) {\n-                    Some(DisambiguatedDefPathData {\n-                        data: DefPathData::Impl,\n-                        disambiguator,\n-                    }) if *disambiguator != 0 => return,\n-                    _ => {},\n-                }\n-            }\n-\n-            let has_self = !matches!(decl.implicit_self, ImplicitSelfKind::None);\n-\n-            let ty_res = cx.typeck_results();\n-            let param_span = body\n-                .params\n-                .iter()\n-                .flat_map(|param| {\n-                    let mut v = Vec::new();\n-                    param.pat.each_binding(|_, hir_id, span, ident| {\n-                        v.push((hir_id, span, ident));\n-                    });\n-                    v\n-                })\n-                .skip(if has_self { 1 } else { 0 })\n-                .filter(|(_, _, ident)| !ident.name.as_str().starts_with('_'))\n-                .collect_vec();\n-\n-            let params = body.params.iter().map(|param| param.pat).collect();\n-\n-            let mut visitor = SideEffectVisit {\n-                graph: FxHashMap::default(),\n-                has_side_effect: FxHashSet::default(),\n-                ret_vars: Vec::new(),\n-                contains_side_effect: false,\n-                break_vars: FxHashMap::default(),\n-                params,\n-                fn_ident: ident,\n-                fn_def_id: def_id,\n-                is_method: matches!(kind, FnKind::Method(..)),\n-                has_self,\n-                ty_res,\n-                tcx: cx.tcx,\n-                visited_exprs: FxHashSet::default(),\n-            };\n-\n-            visitor.visit_expr(&body.value);\n-            let vars = std::mem::take(&mut visitor.ret_vars);\n-            // this would set the return variables to side effect\n-            visitor.add_side_effect(vars);\n-\n-            let mut queue = visitor.has_side_effect.iter().copied().collect::<VecDeque<_>>();\n-\n-            // a simple BFS to check all the variables that have side effect\n-            while let Some(id) = queue.pop_front() {\n-                if let Some(next) = visitor.graph.get(&id) {\n-                    for i in next {\n-                        if !visitor.has_side_effect.contains(i) {\n-                            visitor.has_side_effect.insert(*i);\n-                            queue.push_back(*i);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            for (id, span, ident) in param_span {\n-                // if the variable is not used in recursion, it would be marked as unused\n-                if !visitor.has_side_effect.contains(&id) {\n-                    let mut queue = VecDeque::new();\n-                    let mut visited = FxHashSet::default();\n-\n-                    queue.push_back(id);\n-\n-                    // a simple BFS to check the graph can reach to itself\n-                    // if it can't, it means the variable is never used in recursion\n-                    while let Some(id) = queue.pop_front() {\n-                        if let Some(next) = visitor.graph.get(&id) {\n-                            for i in next {\n-                                if !visited.contains(i) {\n-                                    visited.insert(id);\n-                                    queue.push_back(*i);\n-                                }\n-                            }\n-                        }\n-                    }\n+impl_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n+\n+#[derive(Clone, Copy)]\n+enum FnKind {\n+    Fn,\n+    TraitFn,\n+    // This is a hack. Ideally we would store a `SubstsRef<'tcx>` type here, but a lint pass must be `'static`.\n+    // Substitutions are, however, interned. This allows us to store the pointer as a `usize` when comparing for\n+    // equality.\n+    ImplTraitFn(usize),\n+}\n \n-                    if visited.contains(&id) {\n-                        span_lint_and_sugg(\n-                            cx,\n-                            ONLY_USED_IN_RECURSION,\n-                            span,\n-                            \"parameter is only used in recursion\",\n-                            \"if this is intentional, prefix with an underscore\",\n-                            format!(\"_{}\", ident.name.as_str()),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                }\n-            }\n+struct Param {\n+    /// The function this is a parameter for.\n+    fn_id: DefId,\n+    fn_kind: FnKind,\n+    /// The index of this parameter.\n+    idx: usize,\n+    ident: Ident,\n+    /// Whether this parameter should be linted. Set by `Params::flag_for_linting`.\n+    apply_lint: Cell<bool>,\n+    /// All the uses of this parameter.\n+    uses: Vec<Usage>,\n+}\n+impl Param {\n+    fn new(fn_id: DefId, fn_kind: FnKind, idx: usize, ident: Ident) -> Self {\n+        Self {\n+            fn_id,\n+            fn_kind,\n+            idx,\n+            ident,\n+            apply_lint: Cell::new(true),\n+            uses: Vec::new(),\n         }\n     }\n }\n \n-pub fn is_primitive(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_primitive() || ty.is_str()\n+#[derive(Debug)]\n+struct Usage {\n+    span: Span,\n+    idx: usize,\n }\n-\n-pub fn is_array(ty: Ty<'_>) -> bool {\n-    let ty = ty.peel_refs();\n-    ty.is_array() || ty.is_array_slice()\n+impl Usage {\n+    fn new(span: Span, idx: usize) -> Self {\n+        Self { span, idx }\n+    }\n }\n \n-/// This builds the graph of side effect.\n-/// The edge `a -> b` means if `a` has side effect, `b` will have side effect.\n-///\n-/// There are some example in following code:\n-/// ```rust, ignore\n-/// let b = 1;\n-/// let a = b; // a -> b\n-/// let (c, d) = (a, b); // c -> b, d -> b\n-///\n-/// let e = if a == 0 { // e -> a\n-///     c // e -> c\n-/// } else {\n-///     d // e -> d\n-/// };\n-/// ```\n-pub struct SideEffectVisit<'tcx> {\n-    graph: FxHashMap<HirId, FxHashSet<HirId>>,\n-    has_side_effect: FxHashSet<HirId>,\n-    // bool for if the variable was dereferenced from mutable reference\n-    ret_vars: Vec<(HirId, bool)>,\n-    contains_side_effect: bool,\n-    // break label\n-    break_vars: FxHashMap<Ident, Vec<(HirId, bool)>>,\n-    params: Vec<&'tcx Pat<'tcx>>,\n-    fn_ident: Ident,\n-    fn_def_id: DefId,\n-    is_method: bool,\n-    has_self: bool,\n-    ty_res: &'tcx TypeckResults<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    visited_exprs: FxHashSet<HirId>,\n+/// The parameters being checked by the lint, indexed by both the parameter's `HirId` and the\n+/// `DefId` of the function paired with the parameter's index.\n+#[derive(Default)]\n+struct Params {\n+    params: Vec<Param>,\n+    by_id: HirIdMap<usize>,\n+    by_fn: FxHashMap<(DefId, usize), usize>,\n }\n-\n-impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n-    fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n-        match s.kind {\n-            StmtKind::Local(Local {\n-                pat, init: Some(init), ..\n-            }) => {\n-                self.visit_pat_expr(pat, init, false);\n-            },\n-            StmtKind::Item(_) | StmtKind::Expr(_) | StmtKind::Semi(_) => {\n-                walk_stmt(self, s);\n-            },\n-            StmtKind::Local(_) => {},\n-        }\n-        self.ret_vars.clear();\n+impl Params {\n+    fn insert(&mut self, param: Param, id: HirId) {\n+        let idx = self.params.len();\n+        self.by_id.insert(id, idx);\n+        self.by_fn.insert((param.fn_id, param.idx), idx);\n+        self.params.push(param);\n     }\n \n-    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n-        if !self.visited_exprs.insert(ex.hir_id) {\n-            return;\n-        }\n-        match ex.kind {\n-            ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n-                self.ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            ExprKind::Call(callee, args) => self.visit_fn(callee, args),\n-            ExprKind::MethodCall(path, args, _) => self.visit_method_call(path, args),\n-            ExprKind::Binary(_, lhs, rhs) => {\n-                self.visit_bin_op(lhs, rhs);\n-            },\n-            ExprKind::Unary(op, expr) => self.visit_un_op(op, expr),\n-            ExprKind::Let(Let { pat, init, .. }) => self.visit_pat_expr(pat, init, false),\n-            ExprKind::If(bind, then_expr, else_expr) => {\n-                self.visit_if(bind, then_expr, else_expr);\n-            },\n-            ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n-            // since analysing the closure is not easy, just set all variables in it to side-effect\n-            ExprKind::Closure(&Closure { body, .. }) => {\n-                let body = self.tcx.hir().body(body);\n-                self.visit_body(body);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-            },\n-            ExprKind::Loop(block, label, _, _) | ExprKind::Block(block, label) => {\n-                self.visit_block_label(block, label);\n-            },\n-            ExprKind::Assign(bind, expr, _) => {\n-                self.visit_assign(bind, expr);\n-            },\n-            ExprKind::AssignOp(_, bind, expr) => {\n-                self.visit_assign(bind, expr);\n-                self.visit_bin_op(bind, expr);\n-            },\n-            ExprKind::Field(expr, _) => {\n-                self.visit_expr(expr);\n-                if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Index(expr, index) => {\n-                self.visit_expr(expr);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(index);\n-                self.ret_vars.append(&mut vars);\n-\n-                if !is_array(self.ty_res.expr_ty(expr)) {\n-                    self.add_side_effect(self.ret_vars.clone());\n-                } else if matches!(self.ty_res.expr_ty(expr).kind(), ty::Ref(_, _, Mutability::Mut)) {\n-                    self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n-                }\n-            },\n-            ExprKind::Break(dest, Some(expr)) => {\n-                self.visit_expr(expr);\n-                if let Some(label) = dest.label {\n-                    self.break_vars\n-                        .entry(label.ident)\n-                        .or_insert(Vec::new())\n-                        .append(&mut self.ret_vars);\n-                }\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Ret(Some(expr)) => {\n-                self.visit_expr(expr);\n-                let vars = std::mem::take(&mut self.ret_vars);\n-                self.add_side_effect(vars);\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Break(_, None) | ExprKind::Continue(_) | ExprKind::Ret(None) => {\n-                self.contains_side_effect = true;\n-            },\n-            ExprKind::Struct(_, exprs, expr) => {\n-                let mut ret_vars = exprs\n-                    .iter()\n-                    .flat_map(|field| {\n-                        self.visit_expr(field.expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-\n-                walk_list!(self, visit_expr, expr);\n-                self.ret_vars.append(&mut ret_vars);\n-            },\n-            _ => walk_expr(self, ex),\n+    fn remove_by_id(&mut self, id: HirId) {\n+        if let Some(param) = self.get_by_id_mut(id) {\n+            param.uses = Vec::new();\n+            let key = (param.fn_id, param.idx);\n+            self.by_fn.remove(&key);\n+            self.by_id.remove(&id);\n         }\n     }\n \n-    fn visit_path(&mut self, path: &'tcx Path<'tcx>, _id: HirId) {\n-        if let Res::Local(id) = path.res {\n-            self.ret_vars.push((id, false));\n-        }\n+    fn get_by_id_mut(&mut self, id: HirId) -> Option<&mut Param> {\n+        self.params.get_mut(*self.by_id.get(&id)?)\n     }\n-}\n \n-impl<'tcx> SideEffectVisit<'tcx> {\n-    fn visit_assign(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        // Just support array and tuple unwrapping for now.\n-        //\n-        // ex) `(a, b) = (c, d);`\n-        // The graph would look like this:\n-        //   a -> c\n-        //   b -> d\n-        //\n-        // This would minimize the connection of the side-effect graph.\n-        match (&lhs.kind, &rhs.kind) {\n-            (ExprKind::Array(lhs), ExprKind::Array(rhs)) | (ExprKind::Tup(lhs), ExprKind::Tup(rhs)) => {\n-                // if not, it is a compile error\n-                debug_assert!(lhs.len() == rhs.len());\n-                izip!(*lhs, *rhs).for_each(|(lhs, rhs)| self.visit_assign(lhs, rhs));\n-            },\n-            // in other assigns, we have to connect all each other\n-            // because they can be connected somehow\n-            _ => {\n-                self.visit_expr(lhs);\n-                let lhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.visit_expr(rhs);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, false);\n-            },\n-        }\n+    fn get_by_fn(&self, id: DefId, idx: usize) -> Option<&Param> {\n+        self.params.get(*self.by_fn.get(&(id, idx))?)\n     }\n \n-    fn visit_block_label(&mut self, block: &'tcx Block<'tcx>, label: Option<Label>) {\n-        self.visit_block(block);\n-        let _ = label.and_then(|label| {\n-            self.break_vars\n-                .remove(&label.ident)\n-                .map(|mut break_vars| self.ret_vars.append(&mut break_vars))\n-        });\n-    }\n-\n-    fn visit_bin_op(&mut self, lhs: &'tcx Expr<'tcx>, rhs: &'tcx Expr<'tcx>) {\n-        self.visit_expr(lhs);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(rhs);\n-        self.ret_vars.append(&mut ret_vars);\n-\n-        // the binary operation between non primitive values are overloaded operators\n-        // so they can have side-effects\n-        if !is_primitive(self.ty_res.expr_ty(lhs)) || !is_primitive(self.ty_res.expr_ty(rhs)) {\n-            self.ret_vars.iter().for_each(|id| {\n-                self.has_side_effect.insert(id.0);\n-            });\n-            self.contains_side_effect = true;\n-        }\n+    fn clear(&mut self) {\n+        self.params.clear();\n+        self.by_id.clear();\n+        self.by_fn.clear();\n     }\n \n-    fn visit_un_op(&mut self, op: UnOp, expr: &'tcx Expr<'tcx>) {\n-        self.visit_expr(expr);\n-        let ty = self.ty_res.expr_ty(expr);\n-        // dereferencing a reference has no side-effect\n-        if !is_primitive(ty) && !matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(..))) {\n-            self.add_side_effect(self.ret_vars.clone());\n-        }\n-\n-        if matches!((op, ty.kind()), (UnOp::Deref, ty::Ref(_, _, Mutability::Mut))) {\n-            self.ret_vars.iter_mut().for_each(|(_, b)| *b = true);\n+    /// Sets the `apply_lint` flag on each parameter.\n+    fn flag_for_linting(&mut self) {\n+        // Stores the list of parameters currently being resolved. Needed to avoid cycles.\n+        let mut eval_stack = Vec::new();\n+        for param in &self.params {\n+            self.try_disable_lint_for_param(param, &mut eval_stack);\n         }\n     }\n \n-    fn visit_pat_expr(&mut self, pat: &'tcx Pat<'tcx>, expr: &'tcx Expr<'tcx>, connect_self: bool) {\n-        match (&pat.kind, &expr.kind) {\n-            (PatKind::Tuple(pats, _), ExprKind::Tup(exprs)) => {\n-                self.ret_vars = izip!(*pats, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-            },\n-            (PatKind::Slice(front_exprs, _, back_exprs), ExprKind::Array(exprs)) => {\n-                let mut vars = izip!(*front_exprs, *exprs)\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars = izip!(back_exprs.iter().rev(), exprs.iter().rev())\n-                    .flat_map(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, connect_self);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect();\n-                self.ret_vars.append(&mut vars);\n-            },\n-            _ => {\n-                let mut lhs_vars = Vec::new();\n-                pat.each_binding(|_, id, _, _| lhs_vars.push((id, false)));\n-                self.visit_expr(expr);\n-                let rhs_vars = std::mem::take(&mut self.ret_vars);\n-                self.connect_assign(&lhs_vars, &rhs_vars, connect_self);\n-                self.ret_vars = rhs_vars;\n-            },\n+    // Use by calling `flag_for_linting`.\n+    fn try_disable_lint_for_param(&self, param: &Param, eval_stack: &mut Vec<usize>) -> bool {\n+        if !param.apply_lint.get() {\n+            true\n+        } else if param.uses.is_empty() {\n+            // Don't lint on unused parameters.\n+            param.apply_lint.set(false);\n+            true\n+        } else if eval_stack.contains(&param.idx) {\n+            // Already on the evaluation stack. Returning false will continue to evaluate other dependencies.\n+            false\n+        } else {\n+            eval_stack.push(param.idx);\n+            // Check all cases when used at a different parameter index.\n+            // Needed to catch cases like: `fn f(x: u32, y: u32) { f(y, x) }`\n+            for usage in param.uses.iter().filter(|u| u.idx != param.idx) {\n+                if self\n+                    .get_by_fn(param.fn_id, usage.idx)\n+                    // If the parameter can't be found, then it's used for more than just recursion.\n+                    .map_or(true, |p| self.try_disable_lint_for_param(p, eval_stack))\n+                {\n+                    param.apply_lint.set(false);\n+                    eval_stack.pop();\n+                    return true;\n+                }\n+            }\n+            eval_stack.pop();\n+            false\n         }\n     }\n+}\n \n-    fn visit_fn(&mut self, callee: &'tcx Expr<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        self.visit_expr(callee);\n-        let mut ret_vars = std::mem::take(&mut self.ret_vars);\n-        self.add_side_effect(ret_vars.clone());\n-\n-        let mut is_recursive = false;\n-\n-        if_chain! {\n-            if !self.has_self;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = callee.kind;\n-            if let Res::Def(DefKind::Fn, def_id) = path.res;\n-            if self.fn_def_id == def_id;\n-            then {\n-                is_recursive = true;\n-            }\n-        }\n+#[derive(Default)]\n+pub struct OnlyUsedInRecursion {\n+    /// Track the top-level body entered. Needed to delay reporting when entering nested bodies.\n+    entered_body: Option<HirId>,\n+    params: Params,\n+}\n \n-        if_chain! {\n-            if !self.has_self && self.is_method;\n-            if let ExprKind::Path(QPath::TypeRelative(ty, segment)) = callee.kind;\n-            if segment.ident == self.fn_ident;\n-            if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind;\n-            if let Res::SelfTy{ .. } = path.res;\n-            then {\n-                is_recursive = true;\n-            }\n+impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n+    fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if body.value.span.from_expansion() {\n+            return;\n         }\n-\n-        if is_recursive {\n-            izip!(self.params.clone(), args).for_each(|(pat, expr)| {\n-                self.visit_pat_expr(pat, expr, true);\n-                self.ret_vars.clear();\n-            });\n-        } else {\n-            // This would set arguments used in closure that does not have side-effect.\n-            // Closure itself can be detected whether there is a side-effect, but the\n-            // value of variable that is holding closure can change.\n-            // So, we just check the variables.\n-            self.ret_vars = args\n-                .iter()\n-                .flat_map(|expr| {\n-                    self.visit_expr(expr);\n-                    std::mem::take(&mut self.ret_vars)\n-                })\n-                .collect_vec()\n-                .into_iter()\n-                .map(|id| {\n-                    self.has_side_effect.insert(id.0);\n-                    id\n-                })\n-                .collect();\n-            self.contains_side_effect = true;\n+        // `skip_params` is either `0` or `1` to skip the `self` parameter in trait functions.\n+        // It can't be renamed, and it can't be removed without removing it from multiple functions.\n+        let (fn_id, fn_kind, skip_params) = match get_parent_node(cx.tcx, body.value.hir_id) {\n+            Some(Node::Item(i)) => (i.def_id.to_def_id(), FnKind::Fn, 0),\n+            Some(Node::TraitItem(&TraitItem {\n+                kind: TraitItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => (\n+                def_id.to_def_id(),\n+                FnKind::TraitFn,\n+                if sig.decl.implicit_self.has_implicit_self() {\n+                    1\n+                } else {\n+                    0\n+                },\n+            ),\n+            Some(Node::ImplItem(&ImplItem {\n+                kind: ImplItemKind::Fn(ref sig, _),\n+                def_id,\n+                ..\n+            })) => {\n+                #[allow(trivial_casts)]\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, cx.tcx.hir().local_def_id_to_hir_id(def_id))\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+                    && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n+                {\n+                    (\n+                        trait_item_id,\n+                        FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n+                        if sig.decl.implicit_self.has_implicit_self() {\n+                            1\n+                        } else {\n+                            0\n+                        },\n+                    )\n+                } else {\n+                    (def_id.to_def_id(), FnKind::Fn, 0)\n+                }\n+            },\n+            _ => return,\n+        };\n+        body.params\n+            .iter()\n+            .enumerate()\n+            .skip(skip_params)\n+            .filter_map(|(idx, p)| match p.pat.kind {\n+                PatKind::Binding(_, id, ident, None) if !ident.as_str().starts_with('_') => {\n+                    Some((id, Param::new(fn_id, fn_kind, idx, ident)))\n+                },\n+                _ => None,\n+            })\n+            .for_each(|(id, param)| self.params.insert(param, id));\n+        if self.entered_body.is_none() {\n+            self.entered_body = Some(body.value.hir_id);\n         }\n-\n-        self.ret_vars.append(&mut ret_vars);\n     }\n \n-    fn visit_method_call(&mut self, path: &'tcx PathSegment<'tcx>, args: &'tcx [Expr<'tcx>]) {\n-        if_chain! {\n-            if self.is_method;\n-            if path.ident == self.fn_ident;\n-            if let ExprKind::Path(QPath::Resolved(_, path)) = args.first().unwrap().kind;\n-            if let Res::Local(..) = path.res;\n-            let ident = path.segments.last().unwrap().ident;\n-            if ident.name == kw::SelfLower;\n-            then {\n-                izip!(self.params.clone(), args.iter())\n-                    .for_each(|(pat, expr)| {\n-                        self.visit_pat_expr(pat, expr, true);\n-                        self.ret_vars.clear();\n-                    });\n-            } else {\n-                self.ret_vars = args\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        self.visit_expr(expr);\n-                        std::mem::take(&mut self.ret_vars)\n-                    })\n-                    .collect_vec()\n-                    .into_iter()\n-                    .map(|a| {\n-                        self.has_side_effect.insert(a.0);\n-                        a\n-                    })\n-                    .collect();\n-                self.contains_side_effect = true;\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) {\n+        if let Some(id) = path_to_local(e)\n+            && let Some(param) = self.params.get_by_id_mut(id)\n+        {\n+            let typeck = cx.typeck_results();\n+            let span = e.span;\n+            let mut e = e;\n+            loop {\n+                match get_expr_use_or_unification_node(cx.tcx, e) {\n+                    None | Some((Node::Stmt(_), _)) => return,\n+                    Some((Node::Expr(parent), child_id)) => match parent.kind {\n+                        // Recursive call. Track which index the parameter is used in.\n+                        ExprKind::Call(callee, args)\n+                            if path_def_id(cx, callee).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(callee.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        ExprKind::MethodCall(_, args, _)\n+                            if typeck.type_dependent_def_id(parent.hir_id).map_or(false, |id| {\n+                                id == param.fn_id\n+                                    && has_matching_substs(param.fn_kind, typeck.node_substs(parent.hir_id))\n+                            }) =>\n+                        {\n+                            if let Some(idx) = args.iter().position(|arg| arg.hir_id == child_id) {\n+                                param.uses.push(Usage::new(span, idx));\n+                            }\n+                            return;\n+                        },\n+                        // Assignment to a parameter is fine.\n+                        ExprKind::Assign(lhs, _, _) | ExprKind::AssignOp(_, lhs, _) if lhs.hir_id == child_id => {\n+                            return;\n+                        },\n+                        // Parameter update e.g. `x = x + 1`\n+                        ExprKind::Assign(lhs, rhs, _) | ExprKind::AssignOp(_, lhs, rhs)\n+                            if rhs.hir_id == child_id && path_to_local_id(lhs, id) =>\n+                        {\n+                            return;\n+                        },\n+                        // Side-effect free expressions. Walk to the parent expression.\n+                        ExprKind::Binary(_, lhs, rhs)\n+                            if typeck.expr_ty(lhs).is_primitive() && typeck.expr_ty(rhs).is_primitive() =>\n+                        {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::Unary(_, arg) if typeck.expr_ty(arg).is_primitive() => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        ExprKind::AddrOf(..) | ExprKind::Cast(..) => {\n+                            e = parent;\n+                            continue;\n+                        },\n+                        // Only allow field accesses without auto-deref\n+                        ExprKind::Field(..) if typeck.adjustments().get(child_id).is_none() => {\n+                            e = parent;\n+                            continue\n+                        }\n+                        _ => (),\n+                    },\n+                    _ => (),\n+                }\n+                self.params.remove_by_id(id);\n+                return;\n             }\n         }\n     }\n \n-    fn visit_if(&mut self, bind: &'tcx Expr<'tcx>, then_expr: &'tcx Expr<'tcx>, else_expr: Option<&'tcx Expr<'tcx>>) {\n-        let contains_side_effect = self.contains_side_effect;\n-        self.contains_side_effect = false;\n-        self.visit_expr(bind);\n-        let mut vars = std::mem::take(&mut self.ret_vars);\n-        self.visit_expr(then_expr);\n-        let mut then_vars = std::mem::take(&mut self.ret_vars);\n-        walk_list!(self, visit_expr, else_expr);\n-        if self.contains_side_effect {\n-            self.add_side_effect(vars.clone());\n-        }\n-        self.contains_side_effect |= contains_side_effect;\n-        self.ret_vars.append(&mut vars);\n-        self.ret_vars.append(&mut then_vars);\n-    }\n-\n-    fn visit_match(&mut self, expr: &'tcx Expr<'tcx>, arms: &'tcx [Arm<'tcx>]) {\n-        self.visit_expr(expr);\n-        let mut expr_vars = std::mem::take(&mut self.ret_vars);\n-        self.ret_vars = arms\n-            .iter()\n-            .flat_map(|arm| {\n-                let contains_side_effect = self.contains_side_effect;\n-                self.contains_side_effect = false;\n-                // this would visit `expr` multiple times\n-                // but couldn't think of a better way\n-                self.visit_pat_expr(arm.pat, expr, false);\n-                let mut vars = std::mem::take(&mut self.ret_vars);\n-                let _ = arm.guard.as_ref().map(|guard| {\n-                    self.visit_expr(match guard {\n-                        Guard::If(expr) | Guard::IfLet(Let { init: expr, .. }) => expr,\n-                    });\n-                    vars.append(&mut self.ret_vars);\n-                });\n-                self.visit_expr(arm.body);\n-                if self.contains_side_effect {\n-                    self.add_side_effect(vars.clone());\n-                    self.add_side_effect(expr_vars.clone());\n+    fn check_body_post(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'tcx>) {\n+        if self.entered_body == Some(body.value.hir_id) {\n+            self.entered_body = None;\n+            self.params.flag_for_linting();\n+            for param in &self.params.params {\n+                if param.apply_lint.get() {\n+                    span_lint_and_then(\n+                        cx,\n+                        ONLY_USED_IN_RECURSION,\n+                        param.ident.span,\n+                        \"parameter is only used in recursion\",\n+                        |diag| {\n+                            if param.ident.name != kw::SelfLower {\n+                                diag.span_suggestion(\n+                                    param.ident.span,\n+                                    \"if this is intentional, prefix it with an underscore\",\n+                                    format!(\"_{}\", param.ident.name),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                            diag.span_note(\n+                                param.uses.iter().map(|x| x.span).collect::<Vec<_>>(),\n+                                \"parameter used here\",\n+                            );\n+                        },\n+                    );\n                 }\n-                self.contains_side_effect |= contains_side_effect;\n-                vars.append(&mut self.ret_vars);\n-                vars\n-            })\n-            .collect();\n-        self.ret_vars.append(&mut expr_vars);\n-    }\n-\n-    fn connect_assign(&mut self, lhs: &[(HirId, bool)], rhs: &[(HirId, bool)], connect_self: bool) {\n-        // if mutable dereference is on assignment it can have side-effect\n-        // (this can lead to parameter mutable dereference and change the original value)\n-        // too hard to detect whether this value is from parameter, so this would all\n-        // check mutable dereference assignment to side effect\n-        lhs.iter().filter(|(_, b)| *b).for_each(|(id, _)| {\n-            self.has_side_effect.insert(*id);\n-            self.contains_side_effect = true;\n-        });\n-\n-        // there is no connection\n-        if lhs.is_empty() || rhs.is_empty() {\n-            return;\n-        }\n-\n-        // by connected rhs in cycle, the connections would decrease\n-        // from `n * m` to `n + m`\n-        // where `n` and `m` are length of `lhs` and `rhs`.\n-\n-        // unwrap is possible since rhs is not empty\n-        let rhs_first = rhs.first().unwrap();\n-        for (id, _) in lhs.iter() {\n-            if connect_self || *id != rhs_first.0 {\n-                self.graph\n-                    .entry(*id)\n-                    .or_insert_with(FxHashSet::default)\n-                    .insert(rhs_first.0);\n             }\n+            self.params.clear();\n         }\n-\n-        let rhs = rhs.iter();\n-        izip!(rhs.clone().cycle().skip(1), rhs).for_each(|(from, to)| {\n-            if connect_self || from.0 != to.0 {\n-                self.graph.entry(from.0).or_insert_with(FxHashSet::default).insert(to.0);\n-            }\n-        });\n     }\n+}\n \n-    fn add_side_effect(&mut self, v: Vec<(HirId, bool)>) {\n-        for (id, _) in v {\n-            self.has_side_effect.insert(id);\n-            self.contains_side_effect = true;\n-        }\n+fn has_matching_substs(kind: FnKind, substs: SubstsRef<'_>) -> bool {\n+    match kind {\n+        FnKind::Fn => true,\n+        FnKind::TraitFn => substs.iter().enumerate().all(|(idx, subst)| match subst.unpack() {\n+            GenericArgKind::Lifetime(_) => true,\n+            GenericArgKind::Type(ty) => matches!(*ty.kind(), ty::Param(ty) if ty.index as usize == idx),\n+            GenericArgKind::Const(c) => matches!(c.kind(), ConstKind::Param(c) if c.index as usize == idx),\n+        }),\n+        #[allow(trivial_casts)]\n+        FnKind::ImplTraitFn(expected_substs) => substs as *const _ as usize == expected_substs,\n     }\n }"}, {"sha": "f71e8ead5195ea27653bbfd7f24869490ffcc41b", "filename": "tests/ui/only_used_in_recursion.rs", "status": "modified", "additions": 62, "deletions": 71, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.rs?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -1,122 +1,113 @@\n #![warn(clippy::only_used_in_recursion)]\n \n-fn simple(a: usize, b: usize) -> usize {\n-    if a == 0 { 1 } else { simple(a - 1, b) }\n+fn _simple(x: u32) -> u32 {\n+    x\n }\n \n-fn with_calc(a: usize, b: isize) -> usize {\n-    if a == 0 { 1 } else { with_calc(a - 1, -b + 1) }\n+fn _simple2(x: u32) -> u32 {\n+    _simple(x)\n }\n \n-fn tuple((a, b): (usize, usize)) -> usize {\n-    if a == 0 { 1 } else { tuple((a - 1, b + 1)) }\n+fn _one_unused(flag: u32, a: usize) -> usize {\n+    if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n }\n \n-fn let_tuple(a: usize, b: usize) -> usize {\n-    let (c, d) = (a, b);\n-    if c == 0 { 1 } else { let_tuple(c - 1, d + 1) }\n+fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+    if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n }\n \n-fn array([a, b]: [usize; 2]) -> usize {\n-    if a == 0 { 1 } else { array([a - 1, b + 1]) }\n-}\n-\n-fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-    if a == 0 { 1 } else { index(a - 1, b, c + b[0]) }\n-}\n-\n-fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-    let c = loop {\n-        b += 1;\n-        c += 1;\n-        if c == 10 {\n-            break b;\n-        }\n-    };\n-\n-    if a == 0 { 1 } else { break_(a - 1, c, c) }\n+fn _with_calc(flag: u32, a: i64) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _with_calc(flag - 1, (-a + 10) * 5)\n+    }\n }\n \n-// this has a side effect\n-fn mut_ref(a: usize, b: &mut usize) -> usize {\n-    *b = 1;\n-    if a == 0 { 1 } else { mut_ref(a - 1, b) }\n+// Don't lint\n+fn _used_with_flag(flag: u32, a: u32) -> usize {\n+    if flag == 0 { 0 } else { _used_with_flag(flag ^ a, a - 1) }\n }\n \n-fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-    let mut c = *b;\n-    if a == 0 { 1 } else { mut_ref2(a - 1, &mut c) }\n+fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _used_with_unused(flag - 1, -a, a + b)\n+    }\n }\n \n-fn not_primitive(a: usize, b: String) -> usize {\n-    if a == 0 { 1 } else { not_primitive(a - 1, b) }\n+fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        _codependent_unused(flag - 1, a * b, a + b)\n+    }\n }\n \n-// this doesn't have a side effect,\n-// but `String` is not primitive.\n-fn not_primitive_op(a: usize, b: String, c: &str) -> usize {\n-    if a == 1 { 1 } else { not_primitive_op(a, b + c, c) }\n+fn _not_primitive(flag: u32, b: String) -> usize {\n+    if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n }\n \n struct A;\n \n impl A {\n-    fn method(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::method(a - 1, b - 1) }\n+    fn _method(flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n     }\n \n-    fn method2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.method2(a - 1, b + 1) }\n+    fn _method_self(&self, flag: usize, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n     }\n }\n \n trait B {\n-    fn hello(a: usize, b: usize) -> usize;\n-\n-    fn hello2(&self, a: usize, b: usize) -> usize;\n+    fn method(flag: u32, a: usize) -> usize;\n+    fn method_self(&self, flag: u32, a: usize) -> usize;\n }\n \n impl B for A {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { A::hello(a - 1, b + 1) }\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n     }\n }\n \n-trait C {\n-    fn hello(a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { Self::hello(a - 1, b + 1) }\n+impl B for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n \n-    fn hello2(&self, a: usize, b: usize) -> usize {\n-        if a == 0 { 1 } else { self.hello2(a - 1, b + 1) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n     }\n }\n \n-fn ignore(a: usize, _: usize) -> usize {\n-    if a == 1 { 1 } else { ignore(a - 1, 0) }\n-}\n+impl B for u32 {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { <() as B>::method(flag, a) }\n+    }\n \n-fn ignore2(a: usize, _b: usize) -> usize {\n-    if a == 1 { 1 } else { ignore2(a - 1, _b) }\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { ().method_self(flag, a) }\n+    }\n }\n \n-fn f1(a: u32) -> u32 {\n-    a\n-}\n+trait C {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+    }\n \n-fn f2(a: u32) -> u32 {\n-    f1(a)\n+    fn method_self(&self, flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+    }\n }\n \n-fn inner_fn(a: u32) -> u32 {\n-    fn inner_fn(a: u32) -> u32 {\n-        a\n-    }\n-    inner_fn(a)\n+fn _ignore(flag: usize, _a: usize) -> usize {\n+    if flag == 0 { 0 } else { _ignore(flag - 1, _a) }\n }\n \n fn main() {}"}, {"sha": "74057ddcfda4c2cca6e77a64c43313539fe5066c", "filename": "tests/ui/only_used_in_recursion.stderr", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion.stderr?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -1,82 +1,195 @@\n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:3:21\n+  --> $DIR/only_used_in_recursion.rs:11:27\n    |\n-LL | fn simple(a: usize, b: usize) -> usize {\n-   |                     ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _one_unused(flag: u32, a: usize) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n    = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:12:53\n+   |\n+LL |     if flag == 0 { 0 } else { _one_unused(flag - 1, a) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:27\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                           ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:53\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                     ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:15:35\n+   |\n+LL | fn _two_unused(flag: u32, a: u32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:16:56\n+   |\n+LL |     if flag == 0 { 0 } else { _two_unused(flag - 1, a, b) }\n+   |                                                        ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion.rs:19:26\n+   |\n+LL | fn _with_calc(flag: u32, a: i64) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:23:32\n+   |\n+LL |         _with_calc(flag - 1, (-a + 10) * 5)\n+   |                                ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:7:24\n+  --> $DIR/only_used_in_recursion.rs:32:33\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                 ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:38\n    |\n-LL | fn with_calc(a: usize, b: isize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                      ^  ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:11:14\n+  --> $DIR/only_used_in_recursion.rs:32:41\n+   |\n+LL | fn _used_with_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:36:45\n    |\n-LL | fn tuple((a, b): (usize, usize)) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         _used_with_unused(flag - 1, -a, a + b)\n+   |                                             ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:15:24\n+  --> $DIR/only_used_in_recursion.rs:40:35\n    |\n-LL | fn let_tuple(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:39\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                       ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:20:14\n+  --> $DIR/only_used_in_recursion.rs:40:43\n+   |\n+LL | fn _codependent_unused(flag: u32, a: i32, b: i32) -> usize {\n+   |                                           ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn array([a, b]: [usize; 2]) -> usize {\n-   |              ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:44:43\n+   |\n+LL |         _codependent_unused(flag - 1, a * b, a + b)\n+   |                                           ^      ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:20\n+  --> $DIR/only_used_in_recursion.rs:48:30\n+   |\n+LL | fn _not_primitive(flag: u32, b: String) -> usize {\n+   |                              ^ help: if this is intentional, prefix it with an underscore: `_b`\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                    ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:49:56\n+   |\n+LL |     if flag == 0 { 0 } else { _not_primitive(flag - 1, b) }\n+   |                                                        ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:24:37\n+  --> $DIR/only_used_in_recursion.rs:55:29\n+   |\n+LL |     fn _method(flag: usize, a: usize) -> usize {\n+   |                             ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:56:59\n    |\n-LL | fn index(a: usize, mut b: &[usize], c: usize) -> usize {\n-   |                                     ^ help: if this is intentional, prefix with an underscore: `_c`\n+LL |         if flag == 0 { 0 } else { Self::_method(flag - 1, a) }\n+   |                                                           ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:28:21\n+  --> $DIR/only_used_in_recursion.rs:59:22\n+   |\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                      ^^^^\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:35\n    |\n-LL | fn break_(a: usize, mut b: usize, mut c: usize) -> usize {\n-   |                     ^^^^^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                   ^^^^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:46:23\n+  --> $DIR/only_used_in_recursion.rs:59:41\n    |\n-LL | fn mut_ref2(a: usize, b: &mut usize) -> usize {\n-   |                       ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |     fn _method_self(&self, flag: usize, a: usize) -> usize {\n+   |                                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:60:63\n+   |\n+LL |         if flag == 0 { 0 } else { self._method_self(flag - 1, a) }\n+   |                                                               ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:51:28\n+  --> $DIR/only_used_in_recursion.rs:70:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL | fn not_primitive(a: usize, b: String) -> usize {\n-   |                            ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:71:58\n+   |\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:68:33\n+  --> $DIR/only_used_in_recursion.rs:74:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n    |\n-LL |     fn method2(&self, a: usize, b: usize) -> usize {\n-   |                                 ^ help: if this is intentional, prefix with an underscore: `_b`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:75:62\n+   |\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:90:24\n+  --> $DIR/only_used_in_recursion.rs:100:26\n+   |\n+LL |     fn method(flag: u32, a: usize) -> usize {\n+   |                          ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:101:58\n    |\n-LL |     fn hello(a: usize, b: usize) -> usize {\n-   |                        ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { Self::method(flag - 1, a) }\n+   |                                                          ^\n \n error: parameter is only used in recursion\n-  --> $DIR/only_used_in_recursion.rs:94:32\n+  --> $DIR/only_used_in_recursion.rs:104:38\n+   |\n+LL |     fn method_self(&self, flag: u32, a: usize) -> usize {\n+   |                                      ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion.rs:105:62\n    |\n-LL |     fn hello2(&self, a: usize, b: usize) -> usize {\n-   |                                ^ help: if this is intentional, prefix with an underscore: `_b`\n+LL |         if flag == 0 { 0 } else { self.method_self(flag - 1, a) }\n+   |                                                              ^\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "45dd0553f58acb31b9c15119db4e4f2d066564a2", "filename": "tests/ui/only_used_in_recursion2.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion2.rs?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -0,0 +1,91 @@\n+#![warn(clippy::only_used_in_recursion)]\n+\n+fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+    fn inner(flag: u32, a: u32) -> u32 {\n+        if flag == 0 { 0 } else { inner(flag, a) }\n+    }\n+\n+    let x = inner(flag, a);\n+    if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+}\n+\n+fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+    if let Some(x) = a.and_then(|x| f(x, x)) {\n+        _with_closure(Some(x), b, f)\n+    } else {\n+        0\n+    }\n+}\n+\n+// Issue #8560\n+trait D {\n+    fn foo(&mut self, arg: u32) -> u32;\n+}\n+\n+mod m {\n+    pub struct S(u32);\n+    impl S {\n+        pub fn foo(&mut self, arg: u32) -> u32 {\n+            arg + self.0\n+        }\n+    }\n+}\n+\n+impl D for m::S {\n+    fn foo(&mut self, arg: u32) -> u32 {\n+        self.foo(arg)\n+    }\n+}\n+\n+// Issue #8782\n+fn only_let(x: u32) {\n+    let y = 10u32;\n+    let _z = x * y;\n+}\n+\n+trait E<T: E<()>> {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 {\n+            0\n+        } else {\n+            <T as E<()>>::method(flag - 1, a)\n+        }\n+    }\n+}\n+\n+impl E<()> for () {\n+    fn method(flag: u32, a: usize) -> usize {\n+        if flag == 0 { 0 } else { a }\n+    }\n+}\n+\n+fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+    if flag == 0 {\n+        return 0;\n+    } else if flag > 5 {\n+        a += flag as usize;\n+    } else {\n+        a = 5;\n+    }\n+    overwritten_param(flag, a)\n+}\n+\n+fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_direct(flag - 1, a)\n+    }\n+}\n+\n+fn field_deref(flag: u32, a: &mut Box<(usize,)>) -> usize {\n+    if flag == 0 {\n+        0\n+    } else {\n+        a.0 += 5;\n+        field_deref(flag - 1, a)\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "23f6ffd30c9763de2033510ee3083f84f808874b", "filename": "tests/ui/only_used_in_recursion2.stderr", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d95b67560c4cce38e07aed560abf7832eb5aeaa7/tests%2Fui%2Fonly_used_in_recursion2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fonly_used_in_recursion2.stderr?ref=d95b67560c4cce38e07aed560abf7832eb5aeaa7", "patch": "@@ -0,0 +1,63 @@\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:3:35\n+   |\n+LL | fn _with_inner(flag: u32, a: u32, b: u32) -> usize {\n+   |                                   ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+   = note: `-D clippy::only-used-in-recursion` implied by `-D warnings`\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:9:52\n+   |\n+LL |     if flag == 0 { 0 } else { _with_inner(flag, a, b + x) }\n+   |                                                    ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:4:25\n+   |\n+LL |     fn inner(flag: u32, a: u32) -> u32 {\n+   |                         ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:5:47\n+   |\n+LL |         if flag == 0 { 0 } else { inner(flag, a) }\n+   |                                               ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:12:34\n+   |\n+LL | fn _with_closure(a: Option<u32>, b: u32, f: impl Fn(u32, u32) -> Option<u32>) -> u32 {\n+   |                                  ^ help: if this is intentional, prefix it with an underscore: `_b`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:14:32\n+   |\n+LL |         _with_closure(Some(x), b, f)\n+   |                                ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:62:37\n+   |\n+LL | fn overwritten_param(flag: u32, mut a: usize) -> usize {\n+   |                                     ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:70:29\n+   |\n+LL |     overwritten_param(flag, a)\n+   |                             ^\n+\n+error: parameter is only used in recursion\n+  --> $DIR/only_used_in_recursion2.rs:73:32\n+   |\n+LL | fn field_direct(flag: u32, mut a: (usize,)) -> usize {\n+   |                                ^ help: if this is intentional, prefix it with an underscore: `_a`\n+   |\n+note: parameter used here\n+  --> $DIR/only_used_in_recursion2.rs:78:32\n+   |\n+LL |         field_direct(flag - 1, a)\n+   |                                ^\n+\n+error: aborting due to 5 previous errors\n+"}]}