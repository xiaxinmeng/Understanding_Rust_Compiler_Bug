{"sha": "38060567e89bb142e8a060d91bf53f7e82eaaae6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MDYwNTY3ZTg5YmIxNDJlOGEwNjBkOTFiZjUzZjdlODJlYWFhZTY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-01-11T14:30:02Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-02-09T00:47:01Z"}, "message": "Correct inference of primitive operand type behind binary operation", "tree": {"sha": "f150b16e57e17b41259237f4c00b705fa843751f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f150b16e57e17b41259237f4c00b705fa843751f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38060567e89bb142e8a060d91bf53f7e82eaaae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38060567e89bb142e8a060d91bf53f7e82eaaae6", "html_url": "https://github.com/rust-lang/rust/commit/38060567e89bb142e8a060d91bf53f7e82eaaae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38060567e89bb142e8a060d91bf53f7e82eaaae6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07a34df18b437319a7ff510077bbab95cf7ec6bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/07a34df18b437319a7ff510077bbab95cf7ec6bc", "html_url": "https://github.com/rust-lang/rust/commit/07a34df18b437319a7ff510077bbab95cf7ec6bc"}], "stats": {"total": 54, "additions": 44, "deletions": 10}, "files": [{"sha": "0c1557a59c2bc11553d7e015f05c70c9c753e189", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/38060567e89bb142e8a060d91bf53f7e82eaaae6/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38060567e89bb142e8a060d91bf53f7e82eaaae6/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=38060567e89bb142e8a060d91bf53f7e82eaaae6", "patch": "@@ -25,7 +25,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let ty =\n             if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n-                self.enforce_builtin_binop_types(lhs, lhs_ty, rhs, rhs_ty, op);\n+                self.enforce_builtin_binop_types(&lhs.span, lhs_ty, &rhs.span, rhs_ty, op);\n                 self.tcx.mk_unit()\n             } else {\n                 return_ty\n@@ -86,8 +86,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     && !rhs_ty.is_ty_var()\n                     && is_builtin_binop(lhs_ty, rhs_ty, op)\n                 {\n-                    let builtin_return_ty =\n-                        self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n+                    let builtin_return_ty = self.enforce_builtin_binop_types(\n+                        &lhs_expr.span,\n+                        lhs_ty,\n+                        &rhs_expr.span,\n+                        rhs_ty,\n+                        op,\n+                    );\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n@@ -98,19 +103,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enforce_builtin_binop_types(\n         &self,\n-        lhs_expr: &'tcx hir::Expr<'tcx>,\n+        lhs_span: &Span,\n         lhs_ty: Ty<'tcx>,\n-        rhs_expr: &'tcx hir::Expr<'tcx>,\n+        rhs_span: &Span,\n         rhs_ty: Ty<'tcx>,\n         op: hir::BinOp,\n     ) -> Ty<'tcx> {\n         debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n+        // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+        // (See https://github.com/rust-lang/rust/issues/57447.)\n+        let (lhs_ty, rhs_ty) = (deref_ty_if_possible(lhs_ty), deref_ty_if_possible(rhs_ty));\n+\n         let tcx = self.tcx;\n         match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n-                self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n-                self.demand_suptype(rhs_expr.span, tcx.mk_bool(), rhs_ty);\n+                self.demand_suptype(*lhs_span, tcx.mk_bool(), lhs_ty);\n+                self.demand_suptype(*rhs_span, tcx.mk_bool(), rhs_ty);\n                 tcx.mk_bool()\n             }\n \n@@ -121,13 +130,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             BinOpCategory::Math | BinOpCategory::Bitwise => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 lhs_ty\n             }\n \n             BinOpCategory::Comparison => {\n                 // both LHS and RHS and result will have the same type\n-                self.demand_suptype(rhs_expr.span, lhs_ty, rhs_ty);\n+                self.demand_suptype(*rhs_span, lhs_ty, rhs_ty);\n                 tcx.mk_bool()\n             }\n         }\n@@ -862,6 +871,14 @@ enum Op {\n     Unary(hir::UnOp, Span),\n }\n \n+/// Dereferences a single level of immutable referencing.\n+fn deref_ty_if_possible<'tcx>(ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.kind {\n+        ty::Ref(_, ty, hir::Mutability::Not) => ty,\n+        _ => ty,\n+    }\n+}\n+\n /// Returns `true` if this is a built-in arithmetic operation (e.g., u32\n /// + u32, i16x4 == i16x4) and false if these types would have to be\n /// overloaded to be legal. There are two reasons that we distinguish\n@@ -878,7 +895,11 @@ enum Op {\n /// Reason #2 is the killer. I tried for a while to always use\n /// overloaded logic and just check the types in constants/codegen after\n /// the fact, and it worked fine, except for SIMD types. -nmatsakis\n-fn is_builtin_binop(lhs: Ty<'_>, rhs: Ty<'_>, op: hir::BinOp) -> bool {\n+fn is_builtin_binop<'tcx>(lhs: Ty<'tcx>, rhs: Ty<'tcx>, op: hir::BinOp) -> bool {\n+    // Special-case a single layer of referencing, so that things like `5.0 + &6.0f32` work.\n+    // (See https://github.com/rust-lang/rust/issues/57447.)\n+    let (lhs, rhs) = (deref_ty_if_possible(lhs), deref_ty_if_possible(rhs));\n+\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => true,\n "}, {"sha": "4e41077ba34b0fcb4f7b1606f6b8631ac0161ae2", "filename": "src/test/ui/inference/infer-binary-operand-behind-reference.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/38060567e89bb142e8a060d91bf53f7e82eaaae6/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38060567e89bb142e8a060d91bf53f7e82eaaae6/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Finfer-binary-operand-behind-reference.rs?ref=38060567e89bb142e8a060d91bf53f7e82eaaae6", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+\n+fn main() {\n+    let _: u8 = 0 + 0;\n+    let _: u8 = 0 + &0;\n+    let _: u8 = &0 + 0;\n+    let _: u8 = &0 + &0;\n+\n+    let _: f32 = 0.0 + 0.0;\n+    let _: f32 = 0.0 + &0.0;\n+    let _: f32 = &0.0 + 0.0;\n+    let _: f32 = &0.0 + &0.0;\n+}"}]}