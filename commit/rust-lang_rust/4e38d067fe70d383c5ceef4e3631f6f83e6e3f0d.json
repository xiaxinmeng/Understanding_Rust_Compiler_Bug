{"sha": "4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d", "node_id": "C_kwDOAAsO6NoAKDRlMzhkMDY3ZmU3MGQzODNjNWNlZWY0ZTM2MzFmNmY4M2U2ZTNmMGQ", "commit": {"author": {"name": "Trevor Spiteri", "email": "tspiteri@ieee.org", "date": "2022-10-19T09:40:29Z"}, "committer": {"name": "Trevor Spiteri", "email": "tspiteri@ieee.org", "date": "2022-10-19T11:26:26Z"}, "message": "doc: rewrite doc for signed int::{carrying_add,borrowing_sub}", "tree": {"sha": "579aeeb4e46331312c26c66b04b02482b05b0981", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/579aeeb4e46331312c26c66b04b02482b05b0981"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d", "html_url": "https://github.com/rust-lang/rust/commit/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d/comments", "author": {"login": "tspiteri", "id": 18604588, "node_id": "MDQ6VXNlcjE4NjA0NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/18604588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tspiteri", "html_url": "https://github.com/tspiteri", "followers_url": "https://api.github.com/users/tspiteri/followers", "following_url": "https://api.github.com/users/tspiteri/following{/other_user}", "gists_url": "https://api.github.com/users/tspiteri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tspiteri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tspiteri/subscriptions", "organizations_url": "https://api.github.com/users/tspiteri/orgs", "repos_url": "https://api.github.com/users/tspiteri/repos", "events_url": "https://api.github.com/users/tspiteri/events{/privacy}", "received_events_url": "https://api.github.com/users/tspiteri/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tspiteri", "id": 18604588, "node_id": "MDQ6VXNlcjE4NjA0NTg4", "avatar_url": "https://avatars.githubusercontent.com/u/18604588?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tspiteri", "html_url": "https://github.com/tspiteri", "followers_url": "https://api.github.com/users/tspiteri/followers", "following_url": "https://api.github.com/users/tspiteri/following{/other_user}", "gists_url": "https://api.github.com/users/tspiteri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tspiteri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tspiteri/subscriptions", "organizations_url": "https://api.github.com/users/tspiteri/orgs", "repos_url": "https://api.github.com/users/tspiteri/repos", "events_url": "https://api.github.com/users/tspiteri/events{/privacy}", "received_events_url": "https://api.github.com/users/tspiteri/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84365fff0a99fbf6deab383bd9a8152202b6779b", "url": "https://api.github.com/repos/rust-lang/rust/commits/84365fff0a99fbf6deab383bd9a8152202b6779b", "html_url": "https://github.com/rust-lang/rust/commit/84365fff0a99fbf6deab383bd9a8152202b6779b"}], "stats": {"total": 111, "additions": 75, "deletions": 36}, "files": [{"sha": "c5d7d07cc80317e4723b9790521e942e2b592b15", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 75, "deletions": 36, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=4e38d067fe70d383c5ceef4e3631f6f83e6e3f0d", "patch": "@@ -1506,37 +1506,50 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self + rhs + carry` without the ability to overflow.\n+        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n         ///\n-        /// Performs \"signed ternary addition\" which takes in an extra bit to add, and may return an\n-        /// additional bit of overflow. This signed function is used only on the highest-ordered data,\n-        /// for which the signed overflow result indicates whether the big integer overflowed or not.\n+        /// Performs \"ternary addition\" of two integer operands and a carry-in\n+        /// bit, and returns a tuple of the sum along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n+        /// value is returned.\n         ///\n-        /// # Examples\n+        /// This allows chaining together multiple additions to create a wider\n+        /// addition, and can be useful for bignum addition. This method should\n+        /// only be used for the most significant word; for the less significant\n+        /// words the unsigned method\n+        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n+        /// should be used.\n         ///\n-        /// Basic usage:\n+        /// The output boolean returned by this method is *not* a carry flag,\n+        /// and should *not* be added to a more significant word.\n         ///\n-        /// ```\n-        /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, false), (7, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".carrying_add(2, true), (8, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(0, true), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, true), (\", stringify!($SelfT), \"::MIN + 1, true));\")]\n-        #[doc = concat!(\"assert_eq!(\",\n-            stringify!($SelfT), \"::MAX.carrying_add(\", stringify!($SelfT), \"::MAX, true), \",\n-            \"(-1, true));\"\n-        )]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.carrying_add(-1, true), (\", stringify!($SelfT), \"::MIN, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".carrying_add(\", stringify!($SelfT), \"::MAX, true), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        /// ```\n+        /// If the input carry is false, this method is equivalent to\n+        /// [`overflowing_add`](Self::overflowing_add).\n         ///\n-        /// If `carry` is false, this method is equivalent to [`overflowing_add`](Self::overflowing_add):\n+        /// # Examples\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5_\", stringify!($SelfT), \".carrying_add(2, false), 5_\", stringify!($SelfT), \".overflowing_add(2));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.carrying_add(1, false), \", stringify!($SelfT), \"::MAX.overflowing_add(1));\")]\n+        /// // Only the  most significant word is signed.\n+        /// //\n+        #[doc = concat!(\"//   10  MAX    (a = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n+        #[doc = concat!(\"// + -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n+        /// // ---------\n+        #[doc = concat!(\"//    6    8    (sum = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n+        ///\n+        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n+        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n+        /// let carry0 = false;\n+        ///\n+        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n+        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n+        /// assert_eq!(carry1, true);\n+        ///\n+        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n+        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n+        /// assert_eq!(overflow, false);\n+        ///\n+        /// assert_eq!((sum1, sum0), (6, 8));\n         /// ```\n         #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n         #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]\n@@ -1600,25 +1613,51 @@ macro_rules! int_impl {\n             (a as Self, b)\n         }\n \n-        /// Calculates `self - rhs - borrow` without the ability to overflow.\n+        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n+        /// overflow.\n         ///\n-        /// Performs \"signed ternary subtraction\" which takes in an extra bit to subtract, and may return an\n-        /// additional bit of overflow. This signed function is used only on the highest-ordered data,\n-        /// for which the signed overflow result indicates whether the big integer overflowed or not.\n+        /// Performs \"ternary subtraction\" by subtracting both an integer\n+        /// operandand a borrow-in bit from `self`, and returns a tuple of the\n+        /// difference along with a boolean indicating whether an arithmetic\n+        /// overflow would occur. On overflow, the wrapped value is returned.\n         ///\n-        /// # Examples\n+        /// This allows chaining together multiple subtractions to create a\n+        /// wider subtraction, and can be useful for bignum subtraction. This\n+        /// method should only be used for the most significant word; for the\n+        /// less significant words the unsigned method\n+        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n+        /// should be used.\n         ///\n-        /// Basic usage:\n+        /// The output boolean returned by this method is *not* a borrow flag,\n+        /// and should *not* be subtracted from a more significant word.\n+        ///\n+        /// If the input borrow is false, this method is equivalent to\n+        /// [`overflowing_sub`](Self::overflowing_sub).\n+        ///\n+        /// # Examples\n         ///\n         /// ```\n         /// #![feature(bigint_helper_methods)]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, false), (3, false));\")]\n-        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".borrowing_sub(2, true), (2, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, false), (-1, false));\")]\n-        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".borrowing_sub(1, true), (-2, false));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.borrowing_sub(1, true), (\", stringify!($SelfT), \"::MAX - 1, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.borrowing_sub(-1, false), (\", stringify!($SelfT), \"::MIN, true));\")]\n-        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.borrowing_sub(-1, true), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        /// // Only the  most significant word is signed.\n+        /// //\n+        #[doc = concat!(\"//    6    8    (a = 6 \u00d7 2^\", stringify!($BITS), \" + 8)\")]\n+        #[doc = concat!(\"// - -5    9    (b = -5 \u00d7 2^\", stringify!($BITS), \" + 9)\")]\n+        /// // ---------\n+        #[doc = concat!(\"//   10  MAX    (diff = 10 \u00d7 2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n+        ///\n+        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n+        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n+        /// let borrow0 = false;\n+        ///\n+        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n+        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n+        /// assert_eq!(borrow1, true);\n+        ///\n+        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n+        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n+        /// assert_eq!(overflow, false);\n+        ///\n+        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n         /// ```\n         #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n         #[rustc_const_unstable(feature = \"const_bigint_helper_methods\", issue = \"85532\")]"}]}