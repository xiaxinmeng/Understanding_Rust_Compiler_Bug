{"sha": "2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ODBlY2Q3M2ZmNzQ0M2FkNzJlYjdhZjNjODVlNjczMDI0ZmM3ZmQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-22T22:44:13Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-22T22:44:13Z"}, "message": "Reformat standard library; no code changes.", "tree": {"sha": "b9e703a5e279db41fa36bdbe9674abe8f159e91c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9e703a5e279db41fa36bdbe9674abe8f159e91c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "html_url": "https://github.com/rust-lang/rust/commit/2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "738fe078a43c3f184d0e147f89042474a61fa779", "url": "https://api.github.com/repos/rust-lang/rust/commits/738fe078a43c3f184d0e147f89042474a61fa779", "html_url": "https://github.com/rust-lang/rust/commit/738fe078a43c3f184d0e147f89042474a61fa779"}], "stats": {"total": 1560, "additions": 852, "deletions": 708}, "files": [{"sha": "38e161bcfa204e9582921bfc1edf09287fb77158", "filename": "src/lib/_int.rs", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -19,18 +19,27 @@ fn nonpositive(int x) -> bool { ret x <= 0; }\n fn nonnegative(int x) -> bool { ret x >= 0; }\n \n iter range(mutable int lo, int hi) -> int {\n-  while (lo < hi) {\n-    put lo;\n-    lo += 1;\n-  }\n+    while (lo < hi) {\n+        put lo;\n+        lo += 1;\n+    }\n }\n \n fn to_str(mutable int n, uint radix) -> str\n {\n-  check (0u < radix && radix <= 16u);\n-  if (n < 0) {\n-    ret \"-\" + _uint.to_str((-n) as uint, radix);\n-  } else {\n-    ret _uint.to_str(n as uint, radix);\n-  }\n+    check (0u < radix && radix <= 16u);\n+    if (n < 0) {\n+        ret \"-\" + _uint.to_str((-n) as uint, radix);\n+    } else {\n+        ret _uint.to_str(n as uint, radix);\n+    }\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "0fc7b373950da984bf890ab80a87d4e8465b24ec", "filename": "src/lib/_str.rs", "status": "modified", "additions": 136, "deletions": 135, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -3,58 +3,58 @@ import rustrt.sbuf;\n import std._vec.rustrt.vbuf;\n \n native \"rust\" mod rustrt {\n-  type sbuf;\n-  fn str_buf(str s) -> sbuf;\n-  fn str_byte_len(str s) -> uint;\n-  fn str_alloc(uint n_bytes) -> str;\n-  fn str_from_vec(vec[u8] b) -> str;\n-  fn refcount[T](str s) -> uint;\n+    type sbuf;\n+    fn str_buf(str s) -> sbuf;\n+    fn str_byte_len(str s) -> uint;\n+    fn str_alloc(uint n_bytes) -> str;\n+    fn str_from_vec(vec[u8] b) -> str;\n+    fn refcount[T](str s) -> uint;\n }\n \n fn eq(&str a, &str b) -> bool {\n-  let uint i = byte_len(a);\n-  if (byte_len(b) != i) {\n-    ret false;\n-  }\n-  while (i > 0u) {\n-    i -= 1u;\n-    auto cha = a.(i);\n-    auto chb = b.(i);\n-    if (cha != chb) {\n-      ret false;\n+    let uint i = byte_len(a);\n+    if (byte_len(b) != i) {\n+        ret false;\n+    }\n+    while (i > 0u) {\n+        i -= 1u;\n+        auto cha = a.(i);\n+        auto chb = b.(i);\n+        if (cha != chb) {\n+            ret false;\n+        }\n     }\n-  }\n-  ret true;\n+    ret true;\n }\n \n fn hash(&str s) -> uint {\n-  // djb hash.\n-  // FIXME: replace with murmur.\n-  let uint u = 5381u;\n-  for (u8 c in s) {\n-    u *= 33u;\n-    u += (c as uint);\n-  }\n-  ret u;\n+    // djb hash.\n+    // FIXME: replace with murmur.\n+    let uint u = 5381u;\n+    for (u8 c in s) {\n+        u *= 33u;\n+        u += (c as uint);\n+    }\n+    ret u;\n }\n \n fn is_utf8(vec[u8] v) -> bool {\n-  fail; // FIXME\n+    fail; // FIXME\n }\n \n fn is_ascii(str s) -> bool {\n-  let uint i = byte_len(s);\n-  while (i > 0u) {\n-    i -= 1u;\n-    if ((s.(i) & 0x80u8) != 0u8) {\n-      ret false;\n+    let uint i = byte_len(s);\n+    while (i > 0u) {\n+        i -= 1u;\n+        if ((s.(i) & 0x80u8) != 0u8) {\n+            ret false;\n+        }\n     }\n-  }\n-  ret true;\n+    ret true;\n }\n \n fn alloc(uint n_bytes) -> str {\n-  ret rustrt.str_alloc(n_bytes);\n+    ret rustrt.str_alloc(n_bytes);\n }\n \n // Returns the number of bytes (a.k.a. UTF-8 code units) in s.\n@@ -63,159 +63,160 @@ fn alloc(uint n_bytes) -> str {\n // http://icu-project.org/apiref/icu4c/classBreakIterator.html for a\n // way to implement those.\n fn byte_len(str s) -> uint {\n-  ret rustrt.str_byte_len(s);\n+    ret rustrt.str_byte_len(s);\n }\n \n fn buf(str s) -> sbuf {\n-  ret rustrt.str_buf(s);\n+    ret rustrt.str_buf(s);\n }\n \n fn bytes(str s) -> vec[u8] {\n-  /* FIXME (issue #58):\n-   * Should be...\n-   *\n-   *  fn ith(str s, uint i) -> u8 {\n-   *      ret s.(i);\n-   *  }\n-   *  ret _vec.init_fn[u8](bind ith(s, _), byte_len(s));\n-   *\n-   * but we do not correctly decrement refcount of s when\n-   * the binding dies, so we have to do this manually.\n-   */\n-  let uint n = _str.byte_len(s);\n-  let vec[u8] v = _vec.alloc[u8](n);\n-  let uint i = 0u;\n-  while (i < n) {\n-    v += vec(s.(i));\n-    i += 1u;\n-  }\n-  ret v;\n+    /* FIXME (issue #58):\n+     * Should be...\n+     *\n+     *  fn ith(str s, uint i) -> u8 {\n+     *      ret s.(i);\n+     *  }\n+     *  ret _vec.init_fn[u8](bind ith(s, _), byte_len(s));\n+     *\n+     * but we do not correctly decrement refcount of s when\n+     * the binding dies, so we have to do this manually.\n+     */\n+    let uint n = _str.byte_len(s);\n+    let vec[u8] v = _vec.alloc[u8](n);\n+    let uint i = 0u;\n+    while (i < n) {\n+        v += vec(s.(i));\n+        i += 1u;\n+    }\n+    ret v;\n }\n \n fn from_bytes(vec[u8] v) : is_utf8(v) -> str {\n-  ret rustrt.str_from_vec(v);\n+    ret rustrt.str_from_vec(v);\n }\n \n fn refcount(str s) -> uint {\n-  // -1 because calling this function incremented the refcount.\n-  ret rustrt.refcount[u8](s) - 1u;\n+    // -1 because calling this function incremented the refcount.\n+    ret rustrt.refcount[u8](s) - 1u;\n }\n \n \n // Standard bits from the world of string libraries.\n \n fn index(str s, u8 c) -> int {\n-  let int i = 0;\n-  for (u8 k in s) {\n-    if (k == c) {\n-      ret i;\n+    let int i = 0;\n+    for (u8 k in s) {\n+        if (k == c) {\n+            ret i;\n+        }\n+        i += 1;\n     }\n-    i += 1;\n-  }\n-  ret -1;\n+    ret -1;\n }\n \n fn rindex(str s, u8 c) -> int {\n-  let int n = _str.byte_len(s) as int;\n-  while (n >= 0) {\n-    if (s.(n) == c) {\n-      ret n;\n+    let int n = _str.byte_len(s) as int;\n+    while (n >= 0) {\n+        if (s.(n) == c) {\n+            ret n;\n+        }\n+        n -= 1;\n     }\n-    n -= 1;\n-  }\n-  ret n;\n+    ret n;\n }\n \n fn find(str haystack, str needle) -> int {\n \n-  let int haystack_len = byte_len(haystack) as int;\n-  let int needle_len = byte_len(needle) as int;\n+    let int haystack_len = byte_len(haystack) as int;\n+    let int needle_len = byte_len(needle) as int;\n \n-  if (needle_len == 0) {\n-    ret 0;\n-  }\n+    if (needle_len == 0) {\n+        ret 0;\n+    }\n \n-  fn match_at(&str haystack,\n-              &str needle,\n-              int i) -> bool {\n-    let int j = i;\n-    for (u8 c in needle) {\n-      if (haystack.(j) != c) {\n-        ret false;\n-      }\n-      j += 1;\n+    fn match_at(&str haystack,\n+                &str needle,\n+                int i) -> bool {\n+        let int j = i;\n+        for (u8 c in needle) {\n+            if (haystack.(j) != c) {\n+                ret false;\n+            }\n+            j += 1;\n+        }\n+        ret true;\n     }\n-    ret true;\n-  }\n \n-  let int i = 0;\n-  while (i <= haystack_len - needle_len) {\n-    if (match_at(haystack, needle, i)) {\n-      ret i;\n+    let int i = 0;\n+    while (i <= haystack_len - needle_len) {\n+        if (match_at(haystack, needle, i)) {\n+            ret i;\n+        }\n+        i += 1;\n     }\n-    i += 1;\n-  }\n-  ret  -1;\n+    ret  -1;\n }\n \n fn substr(str s, uint begin, uint len) -> str {\n-  let str accum = \"\";\n-  let uint i = begin;\n-  while (i < begin+len) {\n-    accum += s.(i);\n-    i += 1u;\n-  }\n-  ret accum;\n+    let str accum = \"\";\n+    let uint i = begin;\n+    while (i < begin+len) {\n+        accum += s.(i);\n+        i += 1u;\n+    }\n+    ret accum;\n }\n \n fn split(str s, u8 sep) -> vec[str] {\n-  let vec[str] v = vec();\n-  let str accum = \"\";\n-  let bool ends_with_sep = false;\n-  for (u8 c in s) {\n-    if (c == sep) {\n-      v += accum;\n-      accum = \"\";\n-      ends_with_sep = true;\n-    } else {\n-      accum += c;\n-      ends_with_sep = false;\n+    let vec[str] v = vec();\n+    let str accum = \"\";\n+    let bool ends_with_sep = false;\n+    for (u8 c in s) {\n+        if (c == sep) {\n+            v += accum;\n+            accum = \"\";\n+            ends_with_sep = true;\n+        } else {\n+            accum += c;\n+            ends_with_sep = false;\n+        }\n+    }\n+    if (_str.byte_len(accum) != 0u ||\n+        ends_with_sep) {\n+        v += accum;\n     }\n-  }\n-  if (_str.byte_len(accum) != 0u ||\n-      ends_with_sep) {\n-    v += accum;\n-  }\n-  ret v;\n+    ret v;\n }\n \n fn concat(vec[str] v) -> str {\n-  let str s = \"\";\n-  for (str ss in v) {\n-    s += ss;\n-  }\n-  ret s;\n+    let str s = \"\";\n+    for (str ss in v) {\n+        s += ss;\n+    }\n+    ret s;\n }\n \n fn connect(vec[str] v, str sep) -> str {\n-  let str s = \"\";\n-  let bool first = true;\n-  for (str ss in v) {\n-    if (first) {\n-      first = false;\n-    } else {\n-      s += sep;\n+    let str s = \"\";\n+    let bool first = true;\n+    for (str ss in v) {\n+        if (first) {\n+            first = false;\n+        } else {\n+            s += sep;\n+        }\n+        s += ss;\n     }\n-    s += ss;\n-  }\n-  ret s;\n+    ret s;\n }\n \n \n // Local Variables:\n // mode: rust;\n // fill-column: 78;\n // indent-tabs-mode: nil\n+// c-basic-offset: 4\n // buffer-file-coding-system: utf-8-unix\n // compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n // End:"}, {"sha": "8eece16b508277b268185b0f1931ba76df8e91ec", "filename": "src/lib/_task.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_task.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -1,5 +1,5 @@\n native \"rust\" mod rustrt {\n-  fn task_sleep(uint time_in_us);\n+    fn task_sleep(uint time_in_us);\n }\n \n /**\n@@ -8,5 +8,14 @@ native \"rust\" mod rustrt {\n  * arg: time_in_us maximum number of microseconds to yield control for\n  */\n fn sleep(uint time_in_us) {\n-  ret rustrt.task_sleep(time_in_us);\n-}\n\\ No newline at end of file\n+    ret rustrt.task_sleep(time_in_us);\n+}\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "fa2a79e37d9f26bcc1d3a9c5af171ec17c1d3699", "filename": "src/lib/_u8.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_u8.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -12,9 +12,17 @@ fn ge(u8 x, u8 y) -> bool { ret x >= y; }\n fn gt(u8 x, u8 y) -> bool { ret x > y; }\n \n iter range(mutable u8 lo, u8 hi) -> u8 {\n-  while (lo < hi) {\n-    put lo;\n-    lo += 1u8;\n-  }\n+    while (lo < hi) {\n+        put lo;\n+        lo += 1u8;\n+    }\n }\n \n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "0930cadc093eb9a8261fcb0a5c90dcd577369995", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -14,73 +14,82 @@ fn ge(uint x, uint y) -> bool { ret x >= y; }\n fn gt(uint x, uint y) -> bool { ret x > y; }\n \n iter range(mutable uint lo, uint hi) -> uint {\n-  while (lo < hi) {\n-    put lo;\n-    lo += 1u;\n-  }\n+    while (lo < hi) {\n+        put lo;\n+        lo += 1u;\n+    }\n }\n \n fn next_power_of_two(uint n) -> uint {\n-  // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n-  // world explode.\n-  let uint halfbits = sys.rustrt.size_of[uint]() * 4u;\n-  let uint tmp = n - 1u;\n-  let uint shift = 1u;\n-  while (shift <= halfbits) {\n-    tmp |= tmp >> shift;\n-    shift <<= 1u;\n-  }\n-  ret tmp + 1u;\n+    // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n+    // world explode.\n+    let uint halfbits = sys.rustrt.size_of[uint]() * 4u;\n+    let uint tmp = n - 1u;\n+    let uint shift = 1u;\n+    while (shift <= halfbits) {\n+        tmp |= tmp >> shift;\n+        shift <<= 1u;\n+    }\n+    ret tmp + 1u;\n }\n \n fn to_str(mutable uint n, uint radix) -> str\n {\n-  check (0u < radix && radix <= 16u);\n-  fn digit(uint n) -> char {\n-    alt (n) {\n-      case (0u) { ret '0'; }\n-      case (1u) { ret '1'; }\n-      case (2u) { ret '2'; }\n-      case (3u) { ret '3'; }\n-      case (4u) { ret '4'; }\n-      case (5u) { ret '5'; }\n-      case (6u) { ret '6'; }\n-      case (7u) { ret '7'; }\n-      case (8u) { ret '8'; }\n-      case (9u) { ret '9'; }\n-      case (10u) { ret 'a'; }\n-      case (11u) { ret 'b'; }\n-      case (12u) { ret 'c'; }\n-      case (13u) { ret 'd'; }\n-      case (14u) { ret 'e'; }\n-      case (15u) { ret 'f'; }\n+    check (0u < radix && radix <= 16u);\n+    fn digit(uint n) -> char {\n+        alt (n) {\n+            case (0u) { ret '0'; }\n+            case (1u) { ret '1'; }\n+            case (2u) { ret '2'; }\n+            case (3u) { ret '3'; }\n+            case (4u) { ret '4'; }\n+            case (5u) { ret '5'; }\n+            case (6u) { ret '6'; }\n+            case (7u) { ret '7'; }\n+            case (8u) { ret '8'; }\n+            case (9u) { ret '9'; }\n+            case (10u) { ret 'a'; }\n+            case (11u) { ret 'b'; }\n+            case (12u) { ret 'c'; }\n+            case (13u) { ret 'd'; }\n+            case (14u) { ret 'e'; }\n+            case (15u) { ret 'f'; }\n+        }\n     }\n-  }\n \n-  if (n == 0u) { ret \"0\"; }\n+    if (n == 0u) { ret \"0\"; }\n \n-  let uint r = 1u;\n-  if (n > r) {\n-    while ((r*radix) <= n) {\n-      r *= radix;\n+    let uint r = 1u;\n+    if (n > r) {\n+        while ((r*radix) <= n) {\n+            r *= radix;\n+        }\n     }\n-  }\n \n-  let str s = \"\";\n-  while (n > 0u) {\n+    let str s = \"\";\n+    while (n > 0u) {\n \n-    auto i = n/r;\n+        auto i = n/r;\n \n-    n -= (i * r);\n-    r /= radix;\n+        n -= (i * r);\n+        r /= radix;\n \n-    s += digit(i) as u8;\n-  }\n+        s += digit(i) as u8;\n+    }\n \n-  while (r > 0u) {\n-    s += '0' as u8;\n-    r /= radix;\n-  }\n+    while (r > 0u) {\n+        s += '0' as u8;\n+        r /= radix;\n+    }\n \n-  ret s;\n+    ret s;\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "550206840b9f387e85ac9270d1bf12c7d000ecee", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 75, "deletions": 66, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -2,114 +2,123 @@ import vbuf = rustrt.vbuf;\n import op = util.operator;\n \n native \"rust\" mod rustrt {\n-  type vbuf;\n+    type vbuf;\n \n-  fn vec_buf[T](vec[T] v, uint offset) -> vbuf;\n+    fn vec_buf[T](vec[T] v, uint offset) -> vbuf;\n \n-  fn vec_len[T](vec[T] v) -> uint;\n-  /**\n-   * Sometimes we modify the vec internal data via vec_buf and need to update\n-   * the vec's fill length accordingly.\n-   */\n-  fn vec_len_set[T](vec[T] v, uint n);\n+    fn vec_len[T](vec[T] v) -> uint;\n+    /**\n+     * Sometimes we modify the vec internal data via vec_buf and need to\n+     * update the vec's fill length accordingly.\n+     */\n+    fn vec_len_set[T](vec[T] v, uint n);\n \n-  /**\n-   * The T in vec_alloc[T, U] is the type of the vec to allocate.  The\n-   * U is the type of an element in the vec.  So to allocate a vec[U] we\n-   * want to invoke this as vec_alloc[vec[U], U].\n-   */\n-  fn vec_alloc[T, U](uint n_elts) -> vec[U];\n+    /**\n+     * The T in vec_alloc[T, U] is the type of the vec to allocate.  The\n+     * U is the type of an element in the vec.  So to allocate a vec[U] we\n+     * want to invoke this as vec_alloc[vec[U], U].\n+     */\n+    fn vec_alloc[T, U](uint n_elts) -> vec[U];\n \n-  fn refcount[T](vec[T] v) -> uint;\n+    fn refcount[T](vec[T] v) -> uint;\n \n-  fn vec_print_debug_info[T](vec[T] v);\n+    fn vec_print_debug_info[T](vec[T] v);\n }\n \n fn alloc[T](uint n_elts) -> vec[T] {\n-  ret rustrt.vec_alloc[vec[T], T](n_elts);\n+    ret rustrt.vec_alloc[vec[T], T](n_elts);\n }\n \n fn refcount[T](vec[T] v) -> uint {\n-  // -1 because calling this function incremented the refcount.\n-  ret rustrt.refcount[T](v) - 1u;\n+    // -1 because calling this function incremented the refcount.\n+    ret rustrt.refcount[T](v) - 1u;\n }\n \n type init_op[T] = fn(uint i) -> T;\n \n fn init_fn[T](&init_op[T] op, uint n_elts) -> vec[T] {\n-  let vec[T] v = alloc[T](n_elts);\n-  let uint i = 0u;\n-  while (i < n_elts) {\n-    v += vec(op(i));\n-    i += 1u;\n-  }\n-  ret v;\n+    let vec[T] v = alloc[T](n_elts);\n+    let uint i = 0u;\n+    while (i < n_elts) {\n+        v += vec(op(i));\n+        i += 1u;\n+    }\n+    ret v;\n }\n \n fn init_elt[T](&T t, uint n_elts) -> vec[T] {\n-  /**\n-   * FIXME (issue #81): should be:\n-   *\n-   * fn elt_op[T](&T x, uint i) -> T { ret x; }\n-   * let init_op[T] inner = bind elt_op[T](t, _);\n-   * ret init_fn[T](inner, n_elts);\n-   */\n-  let vec[T] v = alloc[T](n_elts);\n-  let uint i = n_elts;\n-  while (i > 0u) {\n-    i -= 1u;\n-    v += vec(t);\n-  }\n-  ret v;\n+    /**\n+     * FIXME (issue #81): should be:\n+     *\n+     * fn elt_op[T](&T x, uint i) -> T { ret x; }\n+     * let init_op[T] inner = bind elt_op[T](t, _);\n+     * ret init_fn[T](inner, n_elts);\n+     */\n+    let vec[T] v = alloc[T](n_elts);\n+    let uint i = n_elts;\n+    while (i > 0u) {\n+        i -= 1u;\n+        v += vec(t);\n+    }\n+    ret v;\n }\n \n fn buf[T](vec[T] v) -> vbuf {\n-  ret rustrt.vec_buf[T](v, 0u);\n+    ret rustrt.vec_buf[T](v, 0u);\n }\n \n fn len[T](vec[T] v) -> uint {\n-  ret rustrt.vec_len[T](v);\n+    ret rustrt.vec_len[T](v);\n }\n \n fn len_set[T](vec[T] v, uint n) {\n-  rustrt.vec_len_set[T](v, n);\n+    rustrt.vec_len_set[T](v, n);\n }\n \n fn buf_off[T](vec[T] v, uint offset) -> vbuf {\n-  check (offset < len[T](v));\n-  ret rustrt.vec_buf[T](v, offset);\n+    check (offset < len[T](v));\n+    ret rustrt.vec_buf[T](v, offset);\n }\n \n fn print_debug_info[T](vec[T] v) {\n-  rustrt.vec_print_debug_info[T](v);\n+    rustrt.vec_print_debug_info[T](v);\n }\n \n // Returns elements from [start..end) from v.\n fn slice[T](vec[T] v, int start, int end) -> vec[T] {\n-  check (0 <= start);\n-  check (start <= end);\n-  check (end <= (len[T](v) as int));\n-  auto result = alloc[T]((end - start) as uint);\n-  let int i = start;\n-  while (i < end) {\n-    result += vec(v.(i));\n-    i += 1;\n-  }\n-  ret result;\n+    check (0 <= start);\n+    check (start <= end);\n+    check (end <= (len[T](v) as int));\n+    auto result = alloc[T]((end - start) as uint);\n+    let int i = start;\n+    while (i < end) {\n+        result += vec(v.(i));\n+        i += 1;\n+    }\n+    ret result;\n }\n \n fn grow[T](&mutable vec[T] v, int n, &T initval) {\n-  let int i = n;\n-  while (i > 0) {\n-    i -= 1;\n-    v += vec(initval);\n-  }\n+    let int i = n;\n+    while (i > 0) {\n+        i -= 1;\n+        v += vec(initval);\n+    }\n }\n \n fn map[T, U](&op[T,U] f, &vec[T] v) -> vec[U] {\n-  let vec[U] u = alloc[U](len[T](v));\n-  for (T ve in v) {\n-    u += vec(f(ve));\n-  }\n-  ret u;\n+    let vec[U] u = alloc[U](len[T](v));\n+    for (T ve in v) {\n+        u += vec(f(ve));\n+    }\n+    ret u;\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "6c856cf7983f84d86e5bac79025bff9f80087279", "filename": "src/lib/dbg.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fdbg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fdbg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdbg.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -8,33 +8,33 @@\n import std._vec;\n \n native \"rust\" mod rustrt {\n-  fn debug_tydesc[T]();\n-  fn debug_opaque[T](&T x);\n-  fn debug_box[T](@T x);\n-  fn debug_tag[T](&T x);\n-  fn debug_obj[T](&T x, uint nmethods, uint nbytes);\n-  fn debug_fn[T](&T x);\n-  fn debug_ptrcast[T, U](@T x) -> @U;\n+    fn debug_tydesc[T]();\n+    fn debug_opaque[T](&T x);\n+    fn debug_box[T](@T x);\n+    fn debug_tag[T](&T x);\n+    fn debug_obj[T](&T x, uint nmethods, uint nbytes);\n+    fn debug_fn[T](&T x);\n+    fn debug_ptrcast[T, U](@T x) -> @U;\n }\n \n fn debug_vec[T](vec[T] v) {\n-  _vec.print_debug_info[T](v);\n+    _vec.print_debug_info[T](v);\n }\n \n fn debug_tydesc[T]() {\n-  rustrt.debug_tydesc[T]();\n+    rustrt.debug_tydesc[T]();\n }\n \n fn debug_opaque[T](&T x) {\n-  rustrt.debug_opaque[T](x);\n+    rustrt.debug_opaque[T](x);\n }\n \n fn debug_box[T](@T x) {\n-  rustrt.debug_box[T](x);\n+    rustrt.debug_box[T](x);\n }\n \n fn debug_tag[T](&T x) {\n-  rustrt.debug_tag[T](x);\n+    rustrt.debug_tag[T](x);\n }\n \n /**\n@@ -47,13 +47,22 @@ fn debug_tag[T](&T x) {\n  * the front of any obj's data tuple.x\n  */\n fn debug_obj[T](&T x, uint nmethods, uint nbytes) {\n-  rustrt.debug_obj[T](x, nmethods, nbytes);\n+    rustrt.debug_obj[T](x, nmethods, nbytes);\n }\n \n fn debug_fn[T](&T x) {\n-  rustrt.debug_fn[T](x);\n+    rustrt.debug_fn[T](x);\n }\n \n fn ptr_cast[T, U](@T x) -> @U {\n-  ret rustrt.debug_ptrcast[T, U](x);\n+    ret rustrt.debug_ptrcast[T, U](x);\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "959339d8e0411e33c04b9291a0bee2e28b5a63d3", "filename": "src/lib/deque.rs", "status": "modified", "additions": 122, "deletions": 112, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -7,132 +7,142 @@ import std._vec;\n import std._int;\n \n type t[T] = obj {\n-  fn size() -> uint;\n+            fn size() -> uint;\n \n-  fn add_front(&T t);\n-  fn add_back(&T t);\n+            fn add_front(&T t);\n+            fn add_back(&T t);\n \n-  fn pop_front() -> T;\n-  fn pop_back() -> T;\n+            fn pop_front() -> T;\n+            fn pop_back() -> T;\n \n-  fn peek_front() -> T;\n-  fn peek_back() -> T;\n+            fn peek_front() -> T;\n+            fn peek_back() -> T;\n \n-  fn get(int i) -> T;\n+            fn get(int i) -> T;\n };\n \n fn create[T]() -> t[T] {\n \n-  type cell[T] = mutable util.option[T];\n+    type cell[T] = mutable util.option[T];\n \n-  let uint initial_capacity = 32u; // 2^5\n-\n-  /**\n-   * Grow is only called on full elts, so nelts is also len(elts), unlike\n-   * elsewhere.\n-   */\n-  fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n-    check (nelts == _vec.len[cell[T]](elts));\n-\n-    fn fill[T](uint i, uint nelts, uint lo, &vec[cell[T]] old) -> cell[T] {\n-      if (i < nelts) {\n-        ret old.((lo + i) % nelts);\n-      } else {\n-        ret util.none[T];\n-      }\n-    }\n-\n-    let uint nalloc = _uint.next_power_of_two(nelts + 1u);\n-    let _vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n-    ret _vec.init_fn[cell[T]](copy_op, nalloc);\n-  }\n-\n-  fn get[T](vec[cell[T]] elts, uint i) -> T {\n-    alt (elts.(i)) {\n-      case (util.some[T](?t)) { ret t; }\n-      case (_) { fail; }\n-    }\n-  }\n-\n-  obj deque[T](mutable uint nelts,\n-               mutable uint lo,\n-               mutable uint hi,\n-               mutable vec[cell[T]] elts)\n-  {\n-    fn size() -> uint { ret nelts; }\n-\n-    fn add_front(&T t) {\n-      let uint oldlo = lo;\n-\n-      if (lo == 0u) {\n-        lo = _vec.len[cell[T]](elts) - 1u;\n-      } else {\n-        lo -= 1u;\n-      }\n-\n-      if (lo == hi) {\n-        elts = grow[T](nelts, oldlo, elts);\n-        lo = _vec.len[cell[T]](elts) - 1u;\n-        hi = nelts;\n-      }\n-\n-      elts.(lo) = util.some[T](t);\n-      nelts += 1u;\n-    }\n-\n-    fn add_back(&T t) {\n-      if (lo == hi && nelts != 0u) {\n-        elts = grow[T](nelts, lo, elts);\n-        lo = 0u;\n-        hi = nelts;\n-      }\n-\n-      elts.(hi) = util.some[T](t);\n-      hi = (hi + 1u) % _vec.len[cell[T]](elts);\n-      nelts += 1u;\n-    }\n+    let uint initial_capacity = 32u; // 2^5\n \n     /**\n-     * We actually release (turn to none()) the T we're popping so that we\n-     * don't keep anyone's refcount up unexpectedly.\n+     * Grow is only called on full elts, so nelts is also len(elts), unlike\n+     * elsewhere.\n      */\n-    fn pop_front() -> T {\n-      let T t = get[T](elts, lo);\n-      elts.(lo) = util.none[T];\n-      lo = (lo + 1u) % _vec.len[cell[T]](elts);\n-      nelts -= 1u;\n-      ret t;\n-    }\n-\n-    fn pop_back() -> T {\n-      if (hi == 0u) {\n-        hi = _vec.len[cell[T]](elts) - 1u;\n-      } else {\n-        hi -= 1u;\n-      }\n-\n-      let T t = get[T](elts, hi);\n-      elts.(hi) = util.none[T];\n-      nelts -= 1u;\n-      ret t;\n-    }\n-\n-    fn peek_front() -> T {\n-      ret get[T](elts, lo);\n+    fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n+        check (nelts == _vec.len[cell[T]](elts));\n+\n+        fn fill[T](uint i, uint nelts, uint lo,\n+                   &vec[cell[T]] old) -> cell[T] {\n+            if (i < nelts) {\n+                ret old.((lo + i) % nelts);\n+            } else {\n+                ret util.none[T];\n+            }\n+        }\n+\n+        let uint nalloc = _uint.next_power_of_two(nelts + 1u);\n+        let _vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n+        ret _vec.init_fn[cell[T]](copy_op, nalloc);\n     }\n \n-    fn peek_back() -> T {\n-      ret get[T](elts, hi - 1u);\n+    fn get[T](vec[cell[T]] elts, uint i) -> T {\n+        alt (elts.(i)) {\n+            case (util.some[T](?t)) { ret t; }\n+            case (_) { fail; }\n+        }\n     }\n \n-    fn get(int i) -> T {\n-      let uint idx = (lo + (i as uint)) % _vec.len[cell[T]](elts);\n-      ret get[T](elts, idx);\n-    }\n-\n-  }\n-  let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T],\n-                                              initial_capacity);\n-\n-  ret deque[T](0u, 0u, 0u, v);\n+    obj deque[T](mutable uint nelts,\n+                 mutable uint lo,\n+                 mutable uint hi,\n+                 mutable vec[cell[T]] elts)\n+        {\n+            fn size() -> uint { ret nelts; }\n+\n+            fn add_front(&T t) {\n+                let uint oldlo = lo;\n+\n+                if (lo == 0u) {\n+                    lo = _vec.len[cell[T]](elts) - 1u;\n+                } else {\n+                    lo -= 1u;\n+                }\n+\n+                if (lo == hi) {\n+                    elts = grow[T](nelts, oldlo, elts);\n+                    lo = _vec.len[cell[T]](elts) - 1u;\n+                    hi = nelts;\n+                }\n+\n+                elts.(lo) = util.some[T](t);\n+                nelts += 1u;\n+            }\n+\n+            fn add_back(&T t) {\n+                if (lo == hi && nelts != 0u) {\n+                    elts = grow[T](nelts, lo, elts);\n+                    lo = 0u;\n+                    hi = nelts;\n+                }\n+\n+                elts.(hi) = util.some[T](t);\n+                hi = (hi + 1u) % _vec.len[cell[T]](elts);\n+                nelts += 1u;\n+            }\n+\n+            /**\n+             * We actually release (turn to none()) the T we're popping so\n+             * that we don't keep anyone's refcount up unexpectedly.\n+             */\n+            fn pop_front() -> T {\n+                let T t = get[T](elts, lo);\n+                elts.(lo) = util.none[T];\n+                lo = (lo + 1u) % _vec.len[cell[T]](elts);\n+                nelts -= 1u;\n+                ret t;\n+            }\n+\n+            fn pop_back() -> T {\n+                if (hi == 0u) {\n+                    hi = _vec.len[cell[T]](elts) - 1u;\n+                } else {\n+                    hi -= 1u;\n+                }\n+\n+                let T t = get[T](elts, hi);\n+                elts.(hi) = util.none[T];\n+                nelts -= 1u;\n+                ret t;\n+            }\n+\n+            fn peek_front() -> T {\n+                ret get[T](elts, lo);\n+            }\n+\n+            fn peek_back() -> T {\n+                ret get[T](elts, hi - 1u);\n+            }\n+\n+            fn get(int i) -> T {\n+                let uint idx = (lo + (i as uint)) % _vec.len[cell[T]](elts);\n+                ret get[T](elts, idx);\n+            }\n+\n+        }\n+    let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T],\n+                                                initial_capacity);\n+\n+    ret deque[T](0u, 0u, 0u, v);\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "c81d8d70e86d70e5326486094f267a2e90c75720", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -3,38 +3,48 @@ import _vec.vbuf;\n \n native mod libc = \"libc.so.6\" {\n \n-  fn open(sbuf s, int flags, uint mode) -> int;\n-  fn read(int fd, vbuf buf, uint count) -> int;\n-  fn write(int fd, vbuf buf, uint count) -> int;\n-  fn close(int fd) -> int;\n-\n-  type FILE;\n-  fn fopen(sbuf path, sbuf mode) -> FILE;\n-  fn fclose(FILE f);\n-  fn fgetc(FILE f) -> int;\n-  fn ungetc(int c, FILE f);\n-\n-  type dir;\n-  // readdir is a mess; handle via wrapper function in rustrt.\n-  fn opendir(sbuf d) -> dir;\n-  fn closedir(dir d) -> int;\n-\n-  fn getenv(sbuf n) -> sbuf;\n-  fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n-  fn unsetenv(sbuf n) -> int;\n+    fn open(sbuf s, int flags, uint mode) -> int;\n+    fn read(int fd, vbuf buf, uint count) -> int;\n+    fn write(int fd, vbuf buf, uint count) -> int;\n+    fn close(int fd) -> int;\n+\n+    type FILE;\n+    fn fopen(sbuf path, sbuf mode) -> FILE;\n+    fn fclose(FILE f);\n+    fn fgetc(FILE f) -> int;\n+    fn ungetc(int c, FILE f);\n+\n+    type dir;\n+    // readdir is a mess; handle via wrapper function in rustrt.\n+    fn opendir(sbuf d) -> dir;\n+    fn closedir(dir d) -> int;\n+\n+    fn getenv(sbuf n) -> sbuf;\n+    fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n+    fn unsetenv(sbuf n) -> int;\n }\n \n mod libc_constants {\n-  fn O_RDONLY() -> int { ret 0x0000; }\n-  fn O_WRONLY() -> int { ret 0x0001; }\n-  fn O_RDWR()   -> int { ret 0x0002; }\n-  fn O_APPEND() -> int { ret 0x0400; }\n-  fn O_CREAT()  -> int { ret 0x0040; }\n-  fn O_EXCL()   -> int { ret 0x0080; }\n-  fn O_TRUNC()  -> int { ret 0x0200; }\n-  fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in linux libc\n-  fn O_BINARY() -> int { ret 0x0000; } // nonexistent in linux libc\n-\n-  fn S_IRUSR() -> uint { ret 0x0100u; }\n-  fn S_IWUSR() -> uint { ret 0x0080u; }\n+    fn O_RDONLY() -> int { ret 0x0000; }\n+    fn O_WRONLY() -> int { ret 0x0001; }\n+    fn O_RDWR()   -> int { ret 0x0002; }\n+    fn O_APPEND() -> int { ret 0x0400; }\n+    fn O_CREAT()  -> int { ret 0x0040; }\n+    fn O_EXCL()   -> int { ret 0x0080; }\n+    fn O_TRUNC()  -> int { ret 0x0200; }\n+    fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in linux libc\n+    fn O_BINARY() -> int { ret 0x0000; } // nonexistent in linux libc\n+\n+    fn S_IRUSR() -> uint { ret 0x0100u; }\n+    fn S_IWUSR() -> uint { ret 0x0080u; }\n }\n+\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "5025818151ddc2ba14b5298b10b27b77000ad730", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 40, "deletions": 31, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -3,38 +3,47 @@ import _vec.vbuf;\n \n native mod libc = \"libc.dylib\" {\n \n-  fn open(sbuf s, int flags, uint mode) -> int;\n-  fn read(int fd, vbuf buf, uint count) -> int;\n-  fn write(int fd, vbuf buf, uint count) -> int;\n-  fn close(int fd) -> int;\n-\n-  type FILE;\n-  fn fopen(sbuf path, sbuf mode) -> FILE;\n-  fn fclose(FILE f);\n-  fn fgetc(FILE f) -> int;\n-  fn ungetc(int c, FILE f);\n-\n-  type dir;\n-  // readdir is a mess; handle via wrapper function in rustrt.\n-  fn opendir(sbuf d) -> dir;\n-  fn closedir(dir d) -> int;\n-\n-  fn getenv(sbuf n) -> sbuf;\n-  fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n-  fn unsetenv(sbuf n) -> int;\n+    fn open(sbuf s, int flags, uint mode) -> int;\n+    fn read(int fd, vbuf buf, uint count) -> int;\n+    fn write(int fd, vbuf buf, uint count) -> int;\n+    fn close(int fd) -> int;\n+\n+    type FILE;\n+    fn fopen(sbuf path, sbuf mode) -> FILE;\n+    fn fclose(FILE f);\n+    fn fgetc(FILE f) -> int;\n+    fn ungetc(int c, FILE f);\n+\n+    type dir;\n+    // readdir is a mess; handle via wrapper function in rustrt.\n+    fn opendir(sbuf d) -> dir;\n+    fn closedir(dir d) -> int;\n+\n+    fn getenv(sbuf n) -> sbuf;\n+    fn setenv(sbuf n, sbuf v, int overwrite) -> int;\n+    fn unsetenv(sbuf n) -> int;\n }\n \n mod libc_constants {\n-  fn O_RDONLY() -> int { ret 0x0000; }\n-  fn O_WRONLY() -> int { ret 0x0001; }\n-  fn O_RDWR()   -> int { ret 0x0002; }\n-  fn O_APPEND() -> int { ret 0x0008; }\n-  fn O_CREAT()  -> int { ret 0x0200; }\n-  fn O_EXCL()   -> int { ret 0x0800; }\n-  fn O_TRUNC()  -> int { ret 0x0400; }\n-  fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in darwin libc\n-  fn O_BINARY() -> int { ret 0x0000; } // nonexistent in darwin libc\n-\n-  fn S_IRUSR() -> uint { ret 0x0400u; }\n-  fn S_IWUSR() -> uint { ret 0x0200u; }\n+    fn O_RDONLY() -> int { ret 0x0000; }\n+    fn O_WRONLY() -> int { ret 0x0001; }\n+    fn O_RDWR()   -> int { ret 0x0002; }\n+    fn O_APPEND() -> int { ret 0x0008; }\n+    fn O_CREAT()  -> int { ret 0x0200; }\n+    fn O_EXCL()   -> int { ret 0x0800; }\n+    fn O_TRUNC()  -> int { ret 0x0400; }\n+    fn O_TEXT()   -> int { ret 0x0000; } // nonexistent in darwin libc\n+    fn O_BINARY() -> int { ret 0x0000; } // nonexistent in darwin libc\n+\n+    fn S_IRUSR() -> uint { ret 0x0400u; }\n+    fn S_IWUSR() -> uint { ret 0x0200u; }\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "1ad83957015d5995a36bdb111b78997aeb9bb539", "filename": "src/lib/map.rs", "status": "modified", "additions": 200, "deletions": 183, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -13,206 +13,223 @@ type hashfn[K] = fn(&K) -> uint;\n type eqfn[K] = fn(&K, &K) -> bool;\n \n type hashmap[K, V] = obj {\n-  fn size() -> uint;\n-  fn insert(&K key, &V val) -> bool;\n-  fn contains_key(&K key) -> bool;\n-  fn get(&K key) -> V;\n-  fn find(&K key) -> util.option[V];\n-  fn remove(&K key) -> util.option[V];\n-  fn rehash();\n+                     fn size() -> uint;\n+                     fn insert(&K key, &V val) -> bool;\n+                     fn contains_key(&K key) -> bool;\n+                     fn get(&K key) -> V;\n+                     fn find(&K key) -> util.option[V];\n+                     fn remove(&K key) -> util.option[V];\n+                     fn rehash();\n };\n \n fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n \n-  let uint initial_capacity = 32u; // 2^5\n-  let util.rational load_factor = rec(num=3, den=4);\n-\n-  tag bucket[K, V] {\n-    nil;\n-    deleted;\n-    some(K, V);\n-  }\n-\n-  fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n-    ret _vec.init_elt[mutable bucket[K, V]](nil[K, V], nbkts);\n-  }\n-\n-  // Derive two hash functions from the one given by taking the upper\n-  // half and lower half of the uint bits.  Our bucket probing\n-  // sequence is then defined by\n-  //\n-  //   hash(key, i) := hashl(key) + i * hashr(key)   for i = 0, 1, 2, ...\n-  //\n-  // Tearing the hash function apart this way is kosher in practice\n-  // as, assuming 32-bit uints, the table would have to be at 2^32\n-  // buckets before the resulting pair of hash functions no longer\n-  // probes all buckets for a fixed key.  Note that hashr is made to\n-  // output odd numbers (hence coprime to the number of nbkts, which\n-  // is always a power of 2), so that all buckets are probed for a\n-  // fixed key.\n-\n-  fn hashl[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n-    ret (hasher(key) >>> (sys.rustrt.size_of[uint]() * 8u / 2u));\n-  }\n-\n-  fn hashr[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n-    ret ((((~ 0u) >>> (sys.rustrt.size_of[uint]() * 8u / 2u))\n-          & hasher(key)) * 2u + 1u);\n-  }\n-\n-  fn hash[K](&hashfn[K] hasher, uint nbkts, &K key, uint i) -> uint {\n-    ret (hashl[K](hasher, nbkts, key)\n-         + i * hashr[K](hasher, nbkts, key)) % nbkts;\n-  }\n-\n-  /**\n-   * We attempt to never call this with a full table.  If we do, it\n-   * will fail.\n-   */\n-  fn insert_common[K, V](&hashfn[K] hasher,\n-                         &eqfn[K] eqer,\n-                         vec[mutable bucket[K, V]] bkts,\n-                         uint nbkts,\n-                         &K key,\n-                         &V val)\n-    -> bool\n-  {\n-    let uint i = 0u;\n-    while (i < nbkts) {\n-      let uint j = hash[K](hasher, nbkts, key, i);\n-      alt (bkts.(j)) {\n-        case (some[K, V](?k, _)) {\n-          if (eqer(key, k)) {\n-            bkts.(j) = some[K, V](k, val);\n-            ret false;\n-          }\n-          i += 1u;\n-        }\n-        case (_) {\n-          bkts.(j) = some[K, V](key, val);\n-          ret true;\n-        }\n-      }\n-    }\n-    fail; // full table\n-  }\n-\n-  fn find_common[K, V](&hashfn[K] hasher,\n-                       &eqfn[K] eqer,\n-                       vec[mutable bucket[K, V]] bkts,\n-                       uint nbkts,\n-                       &K key)\n-    -> util.option[V]\n-  {\n-    let uint i = 0u;\n-    while (i < nbkts) {\n-      let uint j = (hash[K](hasher, nbkts, key, i));\n-      alt (bkts.(j)) {\n-        case (some[K, V](?k, ?v)) {\n-          if (eqer(key, k)) {\n-            ret util.some[V](v);\n-          }\n-        }\n-        case (nil[K, V]) {\n-          ret util.none[V];\n-        }\n-        case (deleted[K, V]) { }\n-      }\n-      i += 1u;\n-    }\n-    ret util.none[V];\n-  }\n-\n-\n-  fn rehash[K, V](&hashfn[K] hasher,\n-                  &eqfn[K] eqer,\n-                  vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n-                  vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n-  {\n-    for (bucket[K, V] b in oldbkts) {\n-      alt (b) {\n-        case (some[K, V](?k, ?v)) {\n-          insert_common[K, V](hasher, eqer, newbkts, nnewbkts, k, v);\n-        }\n-        case (_) { }\n-      }\n+    let uint initial_capacity = 32u; // 2^5\n+    let util.rational load_factor = rec(num=3, den=4);\n+\n+    tag bucket[K, V] {\n+        nil;\n+        deleted;\n+        some(K, V);\n     }\n-  }\n-\n-  obj hashmap[K, V](hashfn[K] hasher,\n-                    eqfn[K] eqer,\n-                    mutable vec[mutable bucket[K, V]] bkts,\n-                    mutable uint nbkts,\n-                    mutable uint nelts,\n-                    util.rational lf)\n-  {\n-    fn size() -> uint { ret nelts; }\n-\n-    fn insert(&K key, &V val) -> bool {\n-      let util.rational load = rec(num=(nelts + 1u) as int, den=nbkts as int);\n-      if (!util.rational_leq(load, lf)) {\n-        let uint nnewbkts = _uint.next_power_of_two(nbkts + 1u);\n-        let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nnewbkts);\n-        rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nnewbkts);\n-        bkts = newbkts;\n-        nbkts = nnewbkts;\n-      }\n-\n-      if (insert_common[K, V](hasher, eqer, bkts, nbkts, key, val)) {\n-        nelts += 1u;\n-        ret true;\n-      }\n-      ret false;\n+\n+    fn make_buckets[K, V](uint nbkts) -> vec[mutable bucket[K, V]] {\n+        ret _vec.init_elt[mutable bucket[K, V]](nil[K, V], nbkts);\n     }\n \n-    fn contains_key(&K key) -> bool {\n-      alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-        case (util.some[V](_)) { ret true; }\n-        case (_) { ret false; }\n-      }\n+    // Derive two hash functions from the one given by taking the upper\n+    // half and lower half of the uint bits.  Our bucket probing\n+    // sequence is then defined by\n+    //\n+    //   hash(key, i) := hashl(key) + i * hashr(key)   for i = 0, 1, 2, ...\n+    //\n+    // Tearing the hash function apart this way is kosher in practice\n+    // as, assuming 32-bit uints, the table would have to be at 2^32\n+    // buckets before the resulting pair of hash functions no longer\n+    // probes all buckets for a fixed key.  Note that hashr is made to\n+    // output odd numbers (hence coprime to the number of nbkts, which\n+    // is always a power of 2), so that all buckets are probed for a\n+    // fixed key.\n+\n+    fn hashl[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+        ret (hasher(key) >>> (sys.rustrt.size_of[uint]() * 8u / 2u));\n     }\n \n-    fn get(&K key) -> V {\n-      alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n-        case (util.some[V](?val)) { ret val; }\n-        case (_) { fail; }\n-      }\n+    fn hashr[K](&hashfn[K] hasher, uint nbkts, &K key) -> uint {\n+        ret ((((~ 0u) >>> (sys.rustrt.size_of[uint]() * 8u / 2u))\n+              & hasher(key)) * 2u + 1u);\n     }\n \n-    fn find(&K key) -> util.option[V] {\n-      be find_common[K, V](hasher, eqer, bkts, nbkts, key);\n+    fn hash[K](&hashfn[K] hasher, uint nbkts, &K key, uint i) -> uint {\n+        ret (hashl[K](hasher, nbkts, key)\n+             + i * hashr[K](hasher, nbkts, key)) % nbkts;\n     }\n \n-    fn remove(&K key) -> util.option[V] {\n-      let uint i = 0u;\n-      while (i < nbkts) {\n-        let uint j = (hash[K](hasher, nbkts, key, i));\n-        alt (bkts.(j)) {\n-          case (some[K, V](?k, ?v)) {\n-            if (eqer(key, k)) {\n-              bkts.(j) = deleted[K, V];\n-              nelts -= 1u;\n-              ret util.some[V](v);\n+    /**\n+     * We attempt to never call this with a full table.  If we do, it\n+     * will fail.\n+     */\n+    fn insert_common[K, V](&hashfn[K] hasher,\n+                           &eqfn[K] eqer,\n+                           vec[mutable bucket[K, V]] bkts,\n+                           uint nbkts,\n+                           &K key,\n+                           &V val)\n+        -> bool\n+        {\n+            let uint i = 0u;\n+            while (i < nbkts) {\n+                let uint j = hash[K](hasher, nbkts, key, i);\n+                alt (bkts.(j)) {\n+                    case (some[K, V](?k, _)) {\n+                        if (eqer(key, k)) {\n+                            bkts.(j) = some[K, V](k, val);\n+                            ret false;\n+                        }\n+                        i += 1u;\n+                    }\n+                    case (_) {\n+                        bkts.(j) = some[K, V](key, val);\n+                        ret true;\n+                    }\n+                }\n+            }\n+            fail; // full table\n+        }\n+\n+    fn find_common[K, V](&hashfn[K] hasher,\n+                         &eqfn[K] eqer,\n+                         vec[mutable bucket[K, V]] bkts,\n+                         uint nbkts,\n+                         &K key)\n+        -> util.option[V]\n+        {\n+            let uint i = 0u;\n+            while (i < nbkts) {\n+                let uint j = (hash[K](hasher, nbkts, key, i));\n+                alt (bkts.(j)) {\n+                    case (some[K, V](?k, ?v)) {\n+                        if (eqer(key, k)) {\n+                            ret util.some[V](v);\n+                        }\n+                    }\n+                    case (nil[K, V]) {\n+                        ret util.none[V];\n+                    }\n+                    case (deleted[K, V]) { }\n+                }\n+                i += 1u;\n             }\n-          }\n-          case (deleted[K, V]) { }\n-          case (nil[K, V]) {\n             ret util.none[V];\n-          }\n         }\n-        i += 1u;\n-      }\n-      ret util.none[V];\n-    }\n \n-    fn rehash() {\n-      let vec[mutable bucket[K, V]] newbkts = make_buckets[K, V](nbkts);\n-      rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nbkts);\n-      bkts = newbkts;\n-    }\n-  }\n \n-  let vec[mutable bucket[K, V]] bkts = make_buckets[K, V](initial_capacity);\n+    fn rehash[K, V](&hashfn[K] hasher,\n+                    &eqfn[K] eqer,\n+                    vec[mutable bucket[K, V]] oldbkts, uint noldbkts,\n+                    vec[mutable bucket[K, V]] newbkts, uint nnewbkts)\n+        {\n+            for (bucket[K, V] b in oldbkts) {\n+                alt (b) {\n+                    case (some[K, V](?k, ?v)) {\n+                        insert_common[K, V](hasher, eqer, newbkts,\n+                                            nnewbkts, k, v);\n+                    }\n+                    case (_) { }\n+                }\n+            }\n+        }\n+\n+    obj hashmap[K, V](hashfn[K] hasher,\n+                      eqfn[K] eqer,\n+                      mutable vec[mutable bucket[K, V]] bkts,\n+                      mutable uint nbkts,\n+                      mutable uint nelts,\n+                      util.rational lf)\n+        {\n+            fn size() -> uint { ret nelts; }\n+\n+            fn insert(&K key, &V val) -> bool {\n+                let util.rational load = rec(num=(nelts + 1u) as int,\n+                                             den=nbkts as int);\n+                if (!util.rational_leq(load, lf)) {\n+                    let uint nnewbkts = _uint.next_power_of_two(nbkts + 1u);\n+                    let vec[mutable bucket[K, V]] newbkts =\n+                        make_buckets[K, V](nnewbkts);\n+                    rehash[K, V](hasher, eqer, bkts, nbkts,\n+                                 newbkts, nnewbkts);\n+                    bkts = newbkts;\n+                    nbkts = nnewbkts;\n+                }\n+\n+                if (insert_common[K, V](hasher, eqer, bkts,\n+                                        nbkts, key, val)) {\n+                    nelts += 1u;\n+                    ret true;\n+                }\n+                ret false;\n+            }\n+\n+            fn contains_key(&K key) -> bool {\n+                alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n+                    case (util.some[V](_)) { ret true; }\n+                    case (_) { ret false; }\n+                }\n+            }\n \n-  ret hashmap[K, V](hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n+            fn get(&K key) -> V {\n+                alt (find_common[K, V](hasher, eqer, bkts, nbkts, key)) {\n+                    case (util.some[V](?val)) { ret val; }\n+                    case (_) { fail; }\n+                }\n+            }\n+\n+            fn find(&K key) -> util.option[V] {\n+                be find_common[K, V](hasher, eqer, bkts, nbkts, key);\n+            }\n+\n+            fn remove(&K key) -> util.option[V] {\n+                let uint i = 0u;\n+                while (i < nbkts) {\n+                    let uint j = (hash[K](hasher, nbkts, key, i));\n+                    alt (bkts.(j)) {\n+                        case (some[K, V](?k, ?v)) {\n+                            if (eqer(key, k)) {\n+                                bkts.(j) = deleted[K, V];\n+                                nelts -= 1u;\n+                                ret util.some[V](v);\n+                            }\n+                        }\n+                        case (deleted[K, V]) { }\n+                        case (nil[K, V]) {\n+                            ret util.none[V];\n+                        }\n+                    }\n+                    i += 1u;\n+                }\n+                ret util.none[V];\n+            }\n+\n+            fn rehash() {\n+                let vec[mutable bucket[K, V]] newbkts =\n+                    make_buckets[K, V](nbkts);\n+                rehash[K, V](hasher, eqer, bkts, nbkts, newbkts, nbkts);\n+                bkts = newbkts;\n+            }\n+        }\n+\n+    let vec[mutable bucket[K, V]] bkts =\n+        make_buckets[K, V](initial_capacity);\n+\n+    ret hashmap[K, V](hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }\n+\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "06eb2f06fd7cb79bb7994d002a2edb38ca9f1384", "filename": "src/lib/rand.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frand.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -3,23 +3,32 @@\n  */\n \n native \"rust\" mod rustrt {\n-  type rctx;\n-  fn rand_new() -> rctx;\n-  fn rand_next(rctx c) -> u32;\n-  fn rand_free(rctx c);\n+    type rctx;\n+    fn rand_new() -> rctx;\n+    fn rand_next(rctx c) -> u32;\n+    fn rand_free(rctx c);\n }\n \n type rng = obj { fn next() -> u32; };\n \n fn mk_rng() -> rng {\n-  obj rt_rng(rustrt.rctx c) {\n-    fn next() -> u32 {\n-      ret rustrt.rand_next(c);\n+    obj rt_rng(rustrt.rctx c) {\n+        fn next() -> u32 {\n+            ret rustrt.rand_next(c);\n+        }\n+        drop {\n+            rustrt.rand_free(c);\n+        }\n     }\n-    drop {\n-      rustrt.rand_free(c);\n-    }\n-  }\n \n-  ret rt_rng(rustrt.rand_new());\n+    ret rt_rng(rustrt.rand_new());\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "184a71abaffa82986f2ce2cae2deff1ca083b703", "filename": "src/lib/std.rc", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -38,17 +38,26 @@ auth rand.mk_rng = unsafe;\n // Target-OS module.\n \n alt (target_os) {\n-  case (\"win32\") {\n-    mod os = \"win32_os.rs\";\n-  } case (\"macos\") {\n-    mod os = \"macos_os.rs\";\n-  } else {\n-    mod os = \"linux_os.rs\";\n-  }\n-}\n+    case (\"win32\") {\n+        mod os = \"win32_os.rs\";\n+    } case (\"macos\") {\n+        mod os = \"macos_os.rs\";\n+    } else {\n+        mod os = \"linux_os.rs\";\n+    }\n+ }\n \n // FIXME: parametric \n mod map;\n mod deque;\n mod rand;\n mod dbg;\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "90e5cc49ff21c1883589e3f93937586fef30c853", "filename": "src/lib/sys.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -2,21 +2,29 @@ export rustrt;\n \n native \"rust\" mod rustrt {\n \n-  // Explicitly re-export native stuff we want to be made\n-  // available outside this crate. Otherwise it's\n-  // visible-in-crate, but not re-exported.\n+    // Explicitly re-export native stuff we want to be made\n+    // available outside this crate. Otherwise it's\n+    // visible-in-crate, but not re-exported.\n \n-  export last_os_error;\n-  export size_of;\n-  export align_of;\n-  export refcount;\n-  export gc;\n+    export last_os_error;\n+    export size_of;\n+    export align_of;\n+    export refcount;\n+    export gc;\n \n-  fn last_os_error() -> str;\n-  fn size_of[T]() -> uint;\n-  fn align_of[T]() -> uint;\n-  fn refcount[T](@T t) -> uint;\n-  fn gc();\n-  fn unsupervise();\n+    fn last_os_error() -> str;\n+    fn size_of[T]() -> uint;\n+    fn align_of[T]() -> uint;\n+    fn refcount[T](@T t) -> uint;\n+    fn gc();\n+    fn unsupervise();\n }\n \n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "f6e1327be15a80508fefe685d6257bf7dc914799", "filename": "src/lib/util.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -1,30 +1,39 @@\n tag option[T] {\n-  none;\n-  some(T);\n+    none;\n+    some(T);\n }\n \n type operator[T, U] = fn(&T) -> U;\n \n fn option_map[T, U](&operator[T, U] f, &option[T] opt) -> option[U] {\n-  alt (opt) {\n-    case (some[T](?x)) {\n-      ret some[U](f(x));\n+    alt (opt) {\n+        case (some[T](?x)) {\n+            ret some[U](f(x));\n+        }\n+        case (none[T]) {\n+            ret none[U];\n+        }\n     }\n-    case (none[T]) {\n-      ret none[U];\n-    }\n-  }\n }\n \n fn id[T](&T x) -> T {\n-  ret x;\n+    ret x;\n }\n \n /* FIXME (issue #141):  See test/run-pass/constrained-type.rs.  Uncomment\n  * the constraint once fixed. */\n type rational = rec(int num, int den); // : _int.positive(*.den);\n \n fn rational_leq(&rational x, &rational y) -> bool {\n-  // NB: Uses the fact that rationals have positive denominators WLOG.\n-  ret x.num * y.den <= y.num * x.den;\n+    // NB: Uses the fact that rationals have positive denominators WLOG.\n+    ret x.num * y.den <= y.num * x.den;\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "e0ad4188fa3d30829fe470ae4946b7f01e801c85", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2880ecd73ff7443ad72eb7af3c85e673024fc7fd/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=2880ecd73ff7443ad72eb7af3c85e673024fc7fd", "patch": "@@ -2,29 +2,38 @@ import _str.sbuf;\n import _vec.vbuf;\n \n native mod libc = \"msvcrt.dll\" {\n-  fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n-  fn read(int fd, vbuf buf, uint count) -> int = \"_read\";\n-  fn write(int fd, vbuf buf, uint count) -> int = \"_write\";\n-  fn close(int fd) -> int = \"_close\";\n+    fn open(sbuf s, int flags, uint mode) -> int = \"_open\";\n+    fn read(int fd, vbuf buf, uint count) -> int = \"_read\";\n+    fn write(int fd, vbuf buf, uint count) -> int = \"_write\";\n+    fn close(int fd) -> int = \"_close\";\n \n-  type FILE;\n-  fn fopen(sbuf path, sbuf mode) -> FILE;\n-  fn fclose(FILE f);\n-  fn fgetc(FILE f) -> int;\n-  fn ungetc(int c, FILE f);\n+    type FILE;\n+    fn fopen(sbuf path, sbuf mode) -> FILE;\n+    fn fclose(FILE f);\n+    fn fgetc(FILE f) -> int;\n+    fn ungetc(int c, FILE f);\n }\n \n mod libc_constants {\n-  fn O_RDONLY() -> int { ret 0x0000; }\n-  fn O_WRONLY() -> int { ret 0x0001; }\n-  fn O_RDWR()   -> int { ret 0x0002; }\n-  fn O_APPEND() -> int { ret 0x0400; }\n-  fn O_CREAT()  -> int { ret 0x0040; }\n-  fn O_EXCL()   -> int { ret 0x0080; }\n-  fn O_TRUNC()  -> int { ret 0x0200; }\n-  fn O_TEXT()   -> int { ret 0x4000; }\n-  fn O_BINARY() -> int { ret 0x8000; }\n+    fn O_RDONLY() -> int { ret 0x0000; }\n+    fn O_WRONLY() -> int { ret 0x0001; }\n+    fn O_RDWR()   -> int { ret 0x0002; }\n+    fn O_APPEND() -> int { ret 0x0400; }\n+    fn O_CREAT()  -> int { ret 0x0040; }\n+    fn O_EXCL()   -> int { ret 0x0080; }\n+    fn O_TRUNC()  -> int { ret 0x0200; }\n+    fn O_TEXT()   -> int { ret 0x4000; }\n+    fn O_BINARY() -> int { ret 0x8000; }\n \n-  fn S_IRUSR() -> uint { ret 0x0100u; } // really _S_IREAD  in win32\n-  fn S_IWUSR() -> uint { ret 0x0080u; } // really _S_IWRITE in win32\n+    fn S_IRUSR() -> uint { ret 0x0100u; } // really _S_IREAD  in win32\n+    fn S_IWUSR() -> uint { ret 0x0080u; } // really _S_IWRITE in win32\n }\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}]}