{"sha": "4372f1145f0f745d974842a785ee9dc1fe99a366", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNzJmMTE0NWYwZjc0NWQ5NzQ4NDJhNzg1ZWU5ZGMxZmU5OWEzNjY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-06-17T00:58:18Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-07-25T08:19:27Z"}, "message": "add locking data structures and lock checks\n\nThis brings back some of the memory range ideas that were deleted with the packed refactoring.", "tree": {"sha": "1339dfcbad92e3dbfe3e4270f1a0a7dfe3adaf04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1339dfcbad92e3dbfe3e4270f1a0a7dfe3adaf04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4372f1145f0f745d974842a785ee9dc1fe99a366", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAll2/w8ACgkQpp+NIls6\n19nlQRAAnu9poPqEKEIOhhlfEo+9V+oHEGgimw9UTyQHRIOXXKlz/Crne7wp4uP0\nlHx+Ui0u2nBcjUNZcDpVR8kXksA7GcbstO3IHPZouzIPvO/ZjevEaptw+YEkt4Q3\nQY2KvagZyj1pqhTsEHejTqX7rcoUZ0vzmfwAepDnQ/eXTXPoQUwAH7+PfGR1rA1y\nrEU5qDziGD8vutbuKMsOT5Mr66JhuZpjv27F3tMtTXlwb9nFLJ9pwQBKfrumaQO5\nCVVz++Kk6jMT23fs4TYOGivotVZUE+VdQv5ZH2b8kfYy0MmkZl9o9xiovIX8mzaU\n6EljkkRcFoKQ9Y26zz/bj7+HZMeHDDS3gMP210zeq/5dX5eHKDv/Ps0s6UTC/jpH\noIM4S56xnMkJdOLdk8vbF11Ae0mNdyTIsS+tSyhTItgmw+z800jqJqdjCx0VvwVR\n11jyX2eDlubA+cJUvQXPHYEjLYfigAtYYagepR5BNOsFkO8BdZR383Xm5GjUwAFz\nGoUe2Mn+v/HULJT/0AFx1kvawGFOEOQxXk7nI4/8yAPuOqor2oAjDSGM328lwmLz\nq5Ipi0KpWm03UsVrwVuKv/F/b2u5+TvHxs5LjUuWUwScduDGb6IIgUfUuqEYrteQ\nB6Lo+ox6V5t7DIoDgcVSFcGZ9B+pt7LYz/UqK+AR27Sh0gP/VdU=\n=ra5T\n-----END PGP SIGNATURE-----", "payload": "tree 1339dfcbad92e3dbfe3e4270f1a0a7dfe3adaf04\nparent d2a9235c63c8b51fd5363db895ce3fec17ce082a\nauthor Ralf Jung <post@ralfj.de> 1497661098 -0700\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1500970767 +0200\n\nadd locking data structures and lock checks\n\nThis brings back some of the memory range ideas that were deleted with the packed refactoring.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4372f1145f0f745d974842a785ee9dc1fe99a366", "html_url": "https://github.com/rust-lang/rust/commit/4372f1145f0f745d974842a785ee9dc1fe99a366", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4372f1145f0f745d974842a785ee9dc1fe99a366/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a9235c63c8b51fd5363db895ce3fec17ce082a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2a9235c63c8b51fd5363db895ce3fec17ce082a", "html_url": "https://github.com/rust-lang/rust/commit/d2a9235c63c8b51fd5363db895ce3fec17ce082a"}], "stats": {"total": 171, "additions": 160, "deletions": 11}, "files": [{"sha": "e0eb3d28d8a4bc500eda1f786a8d940e6576e2f3", "filename": "src/librustc_mir/interpret/error.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ferror.rs?ref=4372f1145f0f745d974842a785ee9dc1fe99a366", "patch": "@@ -2,7 +2,7 @@ use std::error::Error;\n use std::fmt;\n use rustc::mir;\n use rustc::ty::{FnSig, Ty, layout};\n-use memory::{MemoryPointer, Kind};\n+use memory::{MemoryPointer, LockInfo, AccessKind, Kind};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -51,6 +51,12 @@ pub enum EvalError<'tcx> {\n         required: u64,\n         has: u64,\n     },\n+    MemoryLockViolation {\n+        ptr: MemoryPointer,\n+        len: u64,\n+        access: AccessKind,\n+        lock: LockInfo,\n+    },\n     CalledClosureAsFunction,\n     VtableForArgumentlessMethod,\n     ModifiedConstantMemory,\n@@ -59,6 +65,7 @@ pub enum EvalError<'tcx> {\n     TypeNotPrimitive(Ty<'tcx>),\n     ReallocatedWrongMemoryKind(Kind, Kind),\n     DeallocatedWrongMemoryKind(Kind, Kind),\n+    DeallocatedLockedMemory,\n     ReallocateNonBasePtr,\n     DeallocateNonBasePtr,\n     IncorrectAllocationInformation,\n@@ -97,6 +104,10 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"pointer offset outside bounds of allocation\",\n             InvalidNullPointerUsage =>\n                 \"invalid use of NULL pointer\",\n+            MemoryLockViolation { .. } =>\n+                \"memory access conflicts with lock\",\n+            DeallocatedLockedMemory =>\n+                \"deallocated memory while a lock was held\",\n             ReadPointerAsBytes =>\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n@@ -196,6 +207,10 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                        if access { \"memory access\" } else { \"pointer computed\" },\n                        ptr.offset, ptr.alloc_id, allocation_size)\n             },\n+            MemoryLockViolation { ptr, len, access, lock } => {\n+                write!(f, \"{:?} access at {:?}, size {}, is in conflict with lock {:?}\",\n+                       access, ptr, len, lock)\n+            }\n             NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n             FunctionPointerTyMismatch(sig, got) =>\n                 write!(f, \"tried to call a function with sig {} through a function pointer of type {}\", sig, got),"}, {"sha": "2d691be9ac68883671bda0e16f2ae7c7d155f14b", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=4372f1145f0f745d974842a785ee9dc1fe99a366", "patch": "@@ -169,6 +169,12 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &self.stack\n     }\n \n+    #[inline]\n+    pub fn cur_frame(&self) -> usize {\n+        assert!(self.stack.len() > 0);\n+        self.stack.len() - 1\n+    }\n+\n     /// Returns true if the current frame or any parent frame is part of a ctfe.\n     ///\n     /// Used to disable features in const eval, which do not have a rfc enabling\n@@ -1551,9 +1557,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         if let Lvalue::Local { frame, local } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n-            let last_frame = self.stack.len() - 1;\n-            if frame != last_frame {\n-                write!(msg, \" ({} frames up)\", last_frame - frame).unwrap();\n+            if frame != self.cur_frame() {\n+                write!(msg, \" ({} frames up)\", self.cur_frame() - frame).unwrap();\n             }\n             write!(msg, \":\").unwrap();\n "}, {"sha": "34d8e77b615aee823c2058154cacda3306372dd7", "filename": "src/librustc_mir/interpret/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Flvalue.rs?ref=4372f1145f0f745d974842a785ee9dc1fe99a366", "patch": "@@ -211,7 +211,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc::mir::Lvalue::*;\n         let lvalue = match *mir_lvalue {\n             Local(mir::RETURN_POINTER) => self.frame().return_lvalue,\n-            Local(local) => Lvalue::Local { frame: self.stack.len() - 1, local },\n+            Local(local) => Lvalue::Local { frame: self.cur_frame(), local },\n \n             Static(ref static_) => {\n                 let instance = ty::Instance::mono(self.tcx, static_.def_id);"}, {"sha": "b37a5abb672b4310989a64ccc04bada19427b7d8", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 131, "deletions": 5, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=4372f1145f0f745d974842a785ee9dc1fe99a366", "patch": "@@ -1,15 +1,111 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n-use std::{fmt, iter, ptr, mem, io};\n+use std::{fmt, iter, ptr, mem, io, ops};\n \n use rustc::ty;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n+use rustc::middle::region::CodeExtent;\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, Pointer};\n use eval_context::EvalContext;\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Locks\n+////////////////////////////////////////////////////////////////////////////////\n+\n+mod range {\n+    use super::*;\n+\n+    // The derived `Ord` impl sorts first by the first field, then, if the fields are the same\n+    // by the second field.\n+    // This is exactly what we need for our purposes, since a range query on a BTReeSet/BTreeMap will give us all\n+    // `MemoryRange`s whose `start` is <= than the one we're looking for, but not > the end of the range we're checking.\n+    // At the same time the `end` is irrelevant for the sorting and range searching, but used for the check.\n+    // This kind of search breaks, if `end < start`, so don't do that!\n+    #[derive(Eq, PartialEq, Ord, PartialOrd, Debug)]\n+    pub struct MemoryRange {\n+        start: u64,\n+        end: u64,\n+    }\n+\n+    impl MemoryRange {\n+        pub fn new(offset: u64, len: u64) -> MemoryRange {\n+            assert!(len > 0);\n+            MemoryRange {\n+                start: offset,\n+                end: offset + len,\n+            }\n+        }\n+\n+        pub fn range(offset: u64, len: u64) -> ops::Range<MemoryRange> {\n+            assert!(len > 0);\n+            // We select all elements that are within\n+            // the range given by the offset into the allocation and the length.\n+            // This is sound if \"self.contains() || self.overlaps() == true\" implies that self is in-range.\n+            let left = MemoryRange {\n+                start: 0,\n+                end: offset,\n+            };\n+            let right = MemoryRange {\n+                start: offset + len + 1,\n+                end: 0,\n+            };\n+            left..right\n+        }\n+\n+        pub fn contains(&self, offset: u64, len: u64) -> bool {\n+            assert!(len > 0);\n+            self.start <= offset && (offset + len) <= self.end\n+        }\n+\n+        pub fn overlaps(&self, offset: u64, len: u64) -> bool {\n+            assert!(len > 0);\n+            //let non_overlap = (offset + len) <= self.start || self.end <= offset;\n+            (offset + len) > self.start && self.end > offset\n+        }\n+    }\n+}\n+use self::range::*;\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum AccessKind {\n+    Read,\n+    Write,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+struct DynamicLifetime {\n+    frame: usize,\n+    region: CodeExtent,\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+enum LockStatus {\n+    Held,\n+    RecoverAfter(DynamicLifetime),\n+}\n+\n+/// Information about a lock that is or will be held.\n+#[derive(Copy, Clone, Debug)]\n+pub struct LockInfo {\n+    kind: AccessKind,\n+    lifetime: DynamicLifetime,\n+    status: LockStatus,\n+}\n+\n+impl LockInfo {\n+    fn access_permitted(&self, frame: usize, access: AccessKind) -> bool {\n+        use self::AccessKind::*;\n+        match (self.kind, access) {\n+            (Read, Read) => true, // Read access to read-locked region is okay, no matter who's holding the read lock.\n+            (Write, _) if self.lifetime.frame == frame => true, // All access is okay when we hold the write lock.\n+            _ => false, // Somebody else holding the write lock is not okay\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n ////////////////////////////////////////////////////////////////////////////////\n@@ -41,6 +137,8 @@ pub struct Allocation {\n     /// allocation is modified or deallocated in the future.\n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n     pub kind: Kind,\n+    /// Memory regions that are locked by some function\n+    locks: BTreeMap<MemoryRange, LockInfo>,\n }\n \n #[derive(Debug, PartialEq, Copy, Clone)]\n@@ -96,6 +194,10 @@ impl<'tcx> MemoryPointer {\n     }\n }\n \n+////////////////////////////////////////////////////////////////////////////////\n+// Top-level interpreter memory\n+////////////////////////////////////////////////////////////////////////////////\n+\n pub type TlsKey = usize;\n \n #[derive(Copy, Clone, Debug)]\n@@ -104,10 +206,6 @@ pub struct TlsEntry<'tcx> {\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Top-level interpreter memory\n-////////////////////////////////////////////////////////////////////////////////\n-\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     alloc_map: HashMap<AllocId, Allocation>,\n@@ -151,6 +249,9 @@ pub struct Memory<'a, 'tcx> {\n     /// alignment checking is currently enforced for read and/or write accesses.\n     reads_are_aligned: bool,\n     writes_are_aligned: bool,\n+\n+    /// The current stack frame.  Used to check accesses against locks.\n+    cur_frame: usize,\n }\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n@@ -169,6 +270,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             next_thread_local: 0,\n             reads_are_aligned: true,\n             writes_are_aligned: true,\n+            cur_frame: usize::max_value(),\n         }\n     }\n \n@@ -220,6 +322,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             align,\n             kind,\n             mutable: Mutability::Mutable,\n+            locks: BTreeMap::new(),\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n@@ -260,6 +363,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if alloc.kind != kind {\n             return Err(EvalError::DeallocatedWrongMemoryKind(alloc.kind, kind));\n         }\n+        if !alloc.locks.is_empty() {\n+            return Err(EvalError::DeallocatedLockedMemory);\n+        }\n         if let Some((size, align)) = size_and_align {\n             if size != alloc.bytes.len() as u64 || align != alloc.align {\n                 return Err(EvalError::IncorrectAllocationInformation);\n@@ -321,6 +427,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         Ok(())\n     }\n \n+    pub(crate) fn check_locks(&self, ptr: MemoryPointer, len: u64, access: AccessKind) -> EvalResult<'tcx> {\n+        let alloc = self.get(ptr.alloc_id)?;\n+        for (range, lock) in alloc.locks.range(MemoryRange::range(ptr.offset, len)) {\n+            // Check if the lock is active, overlaps this access, and is in conflict with the access.\n+            if let LockStatus::Held = lock.status {\n+                if range.overlaps(ptr.offset, len) && !lock.access_permitted(self.cur_frame, access) {\n+                    return Err(EvalError::MemoryLockViolation { ptr, len, access, lock: *lock });\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    pub(crate) fn set_cur_frame(&mut self, cur_frame: usize) {\n+        self.cur_frame = cur_frame;\n+    }\n+\n     pub(crate) fn create_tls_key(&mut self, dtor: Option<ty::Instance<'tcx>>) -> TlsKey {\n         let new_key = self.next_thread_local;\n         self.next_thread_local += 1;\n@@ -540,6 +663,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&[]);\n         }\n+        self.check_locks(ptr, size, AccessKind::Read)?;\n         self.check_bounds(ptr.offset(size, self)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -556,6 +680,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         if size == 0 {\n             return Ok(&mut []);\n         }\n+        self.check_locks(ptr, size, AccessKind::Write)?;\n         self.check_bounds(ptr.offset(size, self.layout)?, true)?; // if ptr.offset is in bounds, then so is ptr (because offset checks for overflow)\n         let alloc = self.get_mut(ptr.alloc_id)?;\n         assert_eq!(ptr.offset as usize as u64, ptr.offset);\n@@ -694,6 +819,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     return Err(EvalError::ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, (size + 1) as u64)?;\n+                self.check_locks(ptr, (size + 1) as u64, AccessKind::Read)?;\n                 Ok(&alloc.bytes[offset..offset + size])\n             },\n             None => Err(EvalError::UnterminatedCString(ptr)),"}, {"sha": "1bb1d1e94800c5af438eb0c265acbf88a68e3ed5", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4372f1145f0f745d974842a785ee9dc1fe99a366/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=4372f1145f0f745d974842a785ee9dc1fe99a366", "patch": "@@ -34,6 +34,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             return Ok(false);\n         }\n \n+        let cur_frame = self.cur_frame();\n+        self.memory.set_cur_frame(cur_frame);\n+\n         let block = self.frame().block;\n         let stmt_id = self.frame().stmt;\n         let mir = self.mir();\n@@ -116,7 +119,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // Mark locals as dead or alive.\n             StorageLive(ref lvalue) | StorageDead(ref lvalue)=> {\n                 let (frame, local) = match self.eval_lvalue(lvalue)? {\n-                    Lvalue::Local{ frame, local } if self.stack.len() == frame+1 => (frame, local),\n+                    Lvalue::Local{ frame, local } if self.cur_frame() == frame => (frame, local),\n                     _ => return Err(EvalError::Unimplemented(\"Storage annotations must refer to locals of the topmost stack frame.\".to_owned())) // FIXME maybe this should get its own error type\n                 };\n                 let old_val = match stmt.kind {"}]}