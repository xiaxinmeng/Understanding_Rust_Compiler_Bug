{"sha": "8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMDY5Y2ViYTgxYTBmZmZjMWNlOTVhYWY3ZTgzMzllMTFiZjI3OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-01T08:41:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-08-01T08:41:36Z"}, "message": "Auto merge of #52937 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 30 pull requests\n\nSuccessful merges:\n\n - #52340 (Document From trait implementations for OsStr, OsString, CString, and CStr)\n - #52628 (Cleanup some rustdoc code)\n - #52732 (Remove unstable and deprecated APIs)\n - #52745 (Update clippy to latest master)\n - #52771 (Clarify thread::park semantics)\n - #52778 (Improve readability of serialize.rs)\n - #52810 ([NLL] Don't make \"fake\" match variables mutable)\n - #52821 (pretty print for std::collections::vecdeque)\n - #52822 (Fix From<LocalWaker>)\n - #52824 (Fix -Wpessimizing-move warnings in rustllvm/PassWrapper)\n - #52825 (Make sure #47772 does not regress)\n - #52831 (remove references to AUTHORS.txt file)\n - #52842 (update comment)\n - #52846 (Add timeout to use of `curl` in bootstrap.py.)\n - #52851 (Make the tool_lints actually usable)\n - #52853 (Improve bootstrap help on stages)\n - #52859 (Use Vec::extend in SmallVec::extend when applicable)\n - #52861 (Add targets for HermitCore (https://hermitcore.org) to the Rust compiler and port libstd to it.)\n - #52867 (releases.md: fix 2 typos)\n - #52870 (Implement Unpin for FutureObj and LocalFutureObj)\n - #52876 (run-pass/const-endianness: negate before to_le())\n - #52878 (Fix wrong issue number in the test name)\n - #52883 (Include lifetime in mutability suggestion in NLL messages)\n - #52888 (Use suggestions for shell format arguments)\n - #52904 (NLL: sort diagnostics by span)\n - #52905 (Fix a typo in unsize.rs)\n - #52907 (NLL: On \"cannot move out of type\" error, print original before rewrite)\n - #52914 (Only run the sparc-abi test on sparc)\n - #52918 (Backport 1.27.2 release notes)\n - #52929 (Update compatibility note for 1.28.0 to be correct)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "8a5ed09d41da8989dac5899b2663bd974dde1800", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a5ed09d41da8989dac5899b2663bd974dde1800"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "html_url": "https://github.com/rust-lang/rust/commit/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c63bb1d6a7e7ede79ddc5ddf41087668266824ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c63bb1d6a7e7ede79ddc5ddf41087668266824ea", "html_url": "https://github.com/rust-lang/rust/commit/c63bb1d6a7e7ede79ddc5ddf41087668266824ea"}, {"sha": "850b613b608326d04910700c779fa88baee1b454", "url": "https://api.github.com/repos/rust-lang/rust/commits/850b613b608326d04910700c779fa88baee1b454", "html_url": "https://github.com/rust-lang/rust/commit/850b613b608326d04910700c779fa88baee1b454"}], "stats": {"total": 3826, "additions": 2101, "deletions": 1725}, "files": [{"sha": "e2d0ed77224e3d8344da35984bf03cf0088cfc1a", "filename": "COPYRIGHT", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/COPYRIGHT", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/COPYRIGHT", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/COPYRIGHT?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -10,8 +10,8 @@ Copyrights in the Rust project are retained by their contributors. No\n copyright assignment is required to contribute to the Rust project.\n \n Some files include explicit copyright notices and/or license notices.\n-For full authorship information, see AUTHORS.txt and the version control\n-history.\n+For full authorship information, see the version control history or\n+https://thanks.rust-lang.org\n \n Except as otherwise noted (below and/or in individual files), Rust is\n licensed under the Apache License, Version 2.0 <LICENSE-APACHE> or"}, {"sha": "13042ab07e2175178d1d57574ec592fbb0a96821", "filename": "RELEASES.md", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -94,9 +94,9 @@ Misc\n \n Compatibility Notes\n -------------------\n-- [Rust will no longer consider trait objects with duplicated constraints to\n-  have implementations.][51276] For example the below code will now fail\n-  to compile.\n+- [Rust will consider trait objects with duplicated constraints to be the same\n+  type as without the duplicated constraint.][51276] For example the below code will\n+  now fail to compile.\n   ```rust\n   trait Trait {}\n \n@@ -160,6 +160,17 @@ Compatibility Notes\n [`{Any + Send + Sync}::downcast_ref`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.downcast_ref-2\n [`{Any + Send + Sync}::is`]: https://doc.rust-lang.org/std/any/trait.Any.html#method.is-2\n \n+Version 1.27.2 (2018-07-20)\n+===========================\n+\n+Compatibility Notes\n+-------------------\n+\n+- The borrow checker was fixed to avoid potential unsoundness when using\n+  match ergonomics: [#52213][52213].\n+\n+[52213]: https://github.com/rust-lang/rust/issues/52213\n+\n Version 1.27.1 (2018-07-10)\n ===========================\n \n@@ -190,7 +201,7 @@ Version 1.27.0 (2018-06-21)\n Language\n --------\n - [Removed 'proc' from the reserved keywords list.][49699] This allows `proc` to\n-  be used as an identifer.\n+  be used as an identifier.\n - [The dyn syntax is now available.][49968] This syntax is equivalent to the\n   bare `Trait` syntax, and should make it clearer when being used in tandem with\n   `impl Trait`. Since it is equivalent to the following syntax:\n@@ -4795,7 +4806,7 @@ Language\n --------\n \n * Patterns with `ref mut` now correctly invoke [`DerefMut`] when\n-  matching against dereferencable values.\n+  matching against dereferenceable values.\n \n Libraries\n ---------"}, {"sha": "b2e41589893cc4a55827e0fe3d67dce390defa7c", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -2612,18 +2612,9 @@ dependencies = [\n  \"rustc_lsan 0.0.0\",\n  \"rustc_msan 0.0.0\",\n  \"rustc_tsan 0.0.0\",\n- \"std_unicode 0.0.0\",\n  \"unwind 0.0.0\",\n ]\n \n-[[package]]\n-name = \"std_unicode\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"compiler_builtins 0.0.0\",\n- \"core 0.0.0\",\n-]\n-\n [[package]]\n name = \"string_cache\"\n version = \"0.7.3\""}, {"sha": "829487163a945ec21f9850c997901520105ec9b4", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -88,7 +88,10 @@ def _download(path, url, probably_big, verbose, exception):\n             option = \"-#\"\n         else:\n             option = \"-s\"\n-        run([\"curl\", option, \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n+        run([\"curl\", option,\n+             \"-y\", \"30\", \"-Y\", \"10\",    # timeout if speed is < 10 bytes/sec for > 30 seconds\n+             \"--connect-timeout\", \"30\", # timeout if cannot connect within 30 seconds\n+             \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n             exception=exception)\n "}, {"sha": "8c4f2df60fe6ff1ca0f7576bb91365613987504a", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -157,7 +157,6 @@ pub fn std_cargo(builder: &Builder,\n         cargo.arg(\"--features\").arg(\"c mem\")\n             .args(&[\"-p\", \"alloc\"])\n             .args(&[\"-p\", \"compiler_builtins\"])\n-            .args(&[\"-p\", \"std_unicode\"])\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/rustc/compiler_builtins_shim/Cargo.toml\"));\n     } else {"}, {"sha": "188e64cd668ddc6bb2bdc68c34051254656d1a7a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -856,7 +856,6 @@ impl Step for Src {\n             \"src/librustc_msan\",\n             \"src/librustc_tsan\",\n             \"src/libstd\",\n-            \"src/libstd_unicode\",\n             \"src/libunwind\",\n             \"src/rustc/compiler_builtins_shim\",\n             \"src/rustc/libc_shim\","}, {"sha": "ed9b5b1773fae0de01342200b363505902394a12", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -489,7 +489,7 @@ impl Step for Std {\n         // Keep a whitelist so we do not build internal stdlib crates, these will be\n         // build by the rustc step later if enabled.\n         cargo.arg(\"--no-deps\");\n-        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\"] {\n             cargo.arg(\"-p\").arg(krate);\n             // Create all crate output directories first to make sure rustdoc uses\n             // relative links."}, {"sha": "60b4d65f444014133bd81262a7cbdcabea84bdfe", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -121,7 +121,10 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         opts.optmulti(\"\", \"exclude\", \"build paths to exclude\", \"PATH\");\n         opts.optopt(\"\", \"on-fail\", \"command to run on failure\", \"CMD\");\n         opts.optflag(\"\", \"dry-run\", \"dry run; don't build anything\");\n-        opts.optopt(\"\", \"stage\", \"stage to build\", \"N\");\n+        opts.optopt(\"\", \"stage\",\n+            \"stage to build (indicates compiler to use/test, e.g. stage 0 uses the \\\n+             bootstrap compiler, stage 1 the stage 0 rustc artifacts, etc.)\",\n+            \"N\");\n         opts.optmulti(\"\", \"keep-stage\", \"stage(s) to keep without recompiling\", \"N\");\n         opts.optopt(\"\", \"src\", \"path to the root of the rust checkout\", \"DIR\");\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n@@ -258,7 +261,7 @@ Arguments:\n \n         ./x.py build --stage 1 src/libtest\n \n-    This will first build everything once (like --stage 0 without further\n+    This will first build everything once (like `--stage 0` without further\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\",\n@@ -290,10 +293,14 @@ Arguments:\n \n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n-        ./x.py test src/libstd --stage 0\n+        ./x.py test src/libstd --stage 0 --no-doc\n         ./x.py test src/test/ui --bless\n         ./x.py test src/test/ui --compare-mode nll\n \n+    Note that `test src/test/* --stage N` does NOT depend on `build src/rustc --stage N`;\n+    just like `build src/libstd --stage N` it tests the compiler produced by the previous\n+    stage.\n+\n     If no arguments are passed then the complete artifacts for that stage are\n     compiled and tested.\n "}, {"sha": "d7f78e8f6f4de7ddf10e6547932ada586e2a319b", "filename": "src/doc/man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fdoc%2Fman%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fdoc%2Fman%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustdoc.1?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -119,7 +119,7 @@ See <\\fBhttps://github.com/rust\\-lang/rust/issues\\fR>\n for issues.\n \n .SH \"AUTHOR\"\n-See \\fIAUTHORS.txt\\fR in the Rust source distribution.\n+See the version control history or <\\fBhttps://thanks.rust\\-lang.org\\fR>\n \n .SH \"COPYRIGHT\"\n This work is dual\\[hy]licensed under Apache\\ 2.0 and MIT terms."}, {"sha": "87c7b21bb8a35f20110ba9bc44c653586fc1aba8", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -47,6 +47,7 @@\n TYPE_KIND_FIXED_SIZE_VEC    = 16\n TYPE_KIND_REGULAR_UNION     = 17\n TYPE_KIND_OS_STRING         = 18\n+TYPE_KIND_STD_VECDEQUE      = 19\n \n ENCODED_ENUM_PREFIX = \"RUST$ENCODED$ENUM$\"\n ENUM_DISR_FIELD_NAME = \"RUST$ENUM$DISR\"\n@@ -62,6 +63,14 @@\n STD_VEC_FIELD_NAMES = [STD_VEC_FIELD_NAME_BUF,\n                        STD_VEC_FIELD_NAME_LENGTH]\n \n+# std::collections::VecDeque<> related constants\n+STD_VECDEQUE_FIELD_NAME_TAIL = \"tail\"\n+STD_VECDEQUE_FIELD_NAME_HEAD = \"head\"\n+STD_VECDEQUE_FIELD_NAME_BUF = \"buf\"\n+STD_VECDEQUE_FIELD_NAMES = [STD_VECDEQUE_FIELD_NAME_TAIL,\n+                            STD_VECDEQUE_FIELD_NAME_HEAD,\n+                            STD_VECDEQUE_FIELD_NAME_BUF]\n+\n # std::String related constants\n STD_STRING_FIELD_NAMES = [\"vec\"]\n \n@@ -161,6 +170,11 @@ def __classify_struct(self):\n             self.__conforms_to_field_layout(STD_VEC_FIELD_NAMES)):\n             return TYPE_KIND_STD_VEC\n \n+        # STD COLLECTION VECDEQUE\n+        if (unqualified_type_name.startswith(\"VecDeque<\") and\n+            self.__conforms_to_field_layout(STD_VECDEQUE_FIELD_NAMES)):\n+            return TYPE_KIND_STD_VECDEQUE\n+\n         # STD STRING\n         if (unqualified_type_name.startswith(\"String\") and\n             self.__conforms_to_field_layout(STD_STRING_FIELD_NAMES)):\n@@ -325,6 +339,25 @@ def extract_length_ptr_and_cap_from_std_vec(vec_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (length, data_ptr, capacity)\n \n+\n+def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n+    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_VECDEQUE\n+    tail_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_TAIL)\n+    head_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_HEAD)\n+    buf_field_index = STD_VECDEQUE_FIELD_NAMES.index(STD_VECDEQUE_FIELD_NAME_BUF)\n+\n+    tail = vec_val.get_child_at_index(tail_field_index).as_integer()\n+    head = vec_val.get_child_at_index(head_field_index).as_integer()\n+    buf = vec_val.get_child_at_index(buf_field_index)\n+\n+    vec_ptr_val = buf.get_child_at_index(0)\n+    capacity = buf.get_child_at_index(1).as_integer()\n+    unique_ptr_val = vec_ptr_val.get_child_at_index(0)\n+    data_ptr = unique_ptr_val.get_child_at_index(0)\n+    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n+    return (tail, head, data_ptr, capacity)\n+\n+\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)"}, {"sha": "b7de42a93841757abc7e8e815d01c24632f9a334", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -124,6 +124,9 @@ def rust_pretty_printer_lookup_function(gdb_val):\n     if type_kind == rustpp.TYPE_KIND_STD_VEC:\n         return RustStdVecPrinter(val)\n \n+    if type_kind == rustpp.TYPE_KIND_STD_VECDEQUE:\n+        return RustStdVecDequePrinter(val)\n+\n     if type_kind == rustpp.TYPE_KIND_STD_STRING:\n         return RustStdStringPrinter(val)\n \n@@ -274,6 +277,28 @@ def children(self):\n             yield (str(index), (gdb_ptr + index).dereference())\n \n \n+class RustStdVecDequePrinter(object):\n+    def __init__(self, val):\n+        self.__val = val\n+\n+    @staticmethod\n+    def display_hint():\n+        return \"array\"\n+\n+    def to_string(self):\n+        (tail, head, data_ptr, cap) = \\\n+            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n+        return (self.__val.type.get_unqualified_type_name() +\n+                (\"(len: %i, cap: %i)\" % (head - tail, cap)))\n+\n+    def children(self):\n+        (tail, head, data_ptr, cap) = \\\n+            rustpp.extract_tail_head_ptr_and_cap_from_std_vecdeque(self.__val)\n+        gdb_ptr = data_ptr.get_wrapped_value()\n+        for index in xrange(tail, head):\n+            yield (str(index), (gdb_ptr + index).dereference())\n+\n+\n class RustStdStringPrinter(object):\n     def __init__(self, val):\n         self.__val = val"}, {"sha": "8e30b0d5d5a17c23371e0945fbaf3872754afa27", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -174,7 +174,10 @@ mod platform {\n         }\n     }\n \n-    #[cfg(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\"))]\n+    #[cfg(any(target_os = \"android\",\n+              target_os = \"hermit\",\n+              target_os = \"redox\",\n+              target_os = \"solaris\"))]\n     #[inline]\n     unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         // On android we currently target API level 9 which unfortunately\n@@ -197,7 +200,10 @@ mod platform {\n         libc::memalign(layout.align(), layout.size()) as *mut u8\n     }\n \n-    #[cfg(not(any(target_os = \"android\", target_os = \"redox\", target_os = \"solaris\")))]\n+    #[cfg(not(any(target_os = \"android\",\n+                  target_os = \"hermit\",\n+                  target_os = \"redox\",\n+                  target_os = \"solaris\")))]\n     #[inline]\n     unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n         let mut out = ptr::null_mut();"}, {"sha": "cc52f048b891b578f258dd47bf2f4b03de2d5f93", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -11,135 +11,8 @@\n //! UTF-8 and UTF-16 decoding iterators\n \n use fmt;\n-use iter::FusedIterator;\n use super::from_u32_unchecked;\n \n-/// An iterator over an iterator of bytes of the characters the bytes represent\n-/// as UTF-8\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Clone, Debug)]\n-#[allow(deprecated)]\n-pub struct DecodeUtf8<I: Iterator<Item = u8>>(::iter::Peekable<I>);\n-\n-/// Decodes an `Iterator` of bytes as UTF-8.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[allow(deprecated)]\n-#[inline]\n-pub fn decode_utf8<I: IntoIterator<Item = u8>>(i: I) -> DecodeUtf8<I::IntoIter> {\n-    DecodeUtf8(i.into_iter().peekable())\n-}\n-\n-/// `<DecodeUtf8 as Iterator>::next` returns this for an invalid input sequence.\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(PartialEq, Eq, Debug)]\n-#[allow(deprecated)]\n-pub struct InvalidSequence(());\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[allow(deprecated)]\n-impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n-    type Item = Result<char, InvalidSequence>;\n-    #[inline]\n-\n-    fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|first_byte| {\n-            // Emit InvalidSequence according to\n-            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n-            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n-\n-            // Roughly: consume at least one byte,\n-            // then validate one byte at a time and stop before the first unexpected byte\n-            // (which might be the valid start of the next byte sequence).\n-\n-            let mut code_point;\n-            macro_rules! first_byte {\n-                ($mask: expr) => {\n-                    code_point = u32::from(first_byte & $mask)\n-                }\n-            }\n-            macro_rules! continuation_byte {\n-                () => { continuation_byte!(0x80..=0xBF) };\n-                ($range: pat) => {\n-                    match self.0.peek() {\n-                        Some(&byte @ $range) => {\n-                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n-                            self.0.next();\n-                        }\n-                        _ => return Err(InvalidSequence(()))\n-                    }\n-                }\n-            }\n-\n-            match first_byte {\n-                0x00..=0x7F => {\n-                    first_byte!(0b1111_1111);\n-                }\n-                0xC2..=0xDF => {\n-                    first_byte!(0b0001_1111);\n-                    continuation_byte!();\n-                }\n-                0xE0 => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0xA0..=0xBF);  // 0x80..=0x9F here are overlong\n-                    continuation_byte!();\n-                }\n-                0xE1..=0xEC | 0xEE..=0xEF => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xED => {\n-                    first_byte!(0b0000_1111);\n-                    continuation_byte!(0x80..=0x9F);  // 0xA0..0xBF here are surrogates\n-                    continuation_byte!();\n-                }\n-                0xF0 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x90..=0xBF);  // 0x80..0x8F here are overlong\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF1..=0xF3 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                0xF4 => {\n-                    first_byte!(0b0000_0111);\n-                    continuation_byte!(0x80..=0x8F);  // 0x90..0xBF here are beyond char::MAX\n-                    continuation_byte!();\n-                    continuation_byte!();\n-                }\n-                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n-            }\n-            unsafe {\n-                Ok(from_u32_unchecked(code_point))\n-            }\n-        })\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        let (lower, upper) = self.0.size_hint();\n-\n-        // A code point is at most 4 bytes long.\n-        let min_code_points = lower / 4;\n-\n-        (min_code_points, upper)\n-    }\n-}\n-\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[allow(deprecated)]\n-impl<I: FusedIterator<Item = u8>> FusedIterator for DecodeUtf8<I> {}\n-\n /// An iterator that decodes UTF-16 encoded code points from an iterator of `u16`s.\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n #[derive(Clone, Debug)]"}, {"sha": "5be673db3200d8b3696749443520c48bafeb964b", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -50,11 +50,6 @@ pub use self::decode::{decode_utf16, DecodeUtf16, DecodeUtf16Error};\n pub use unicode::tables::UNICODE_VERSION;\n #[unstable(feature = \"unicode_version\", issue = \"49726\")]\n pub use unicode::version::UnicodeVersion;\n-#[unstable(feature = \"decode_utf8\", issue = \"33906\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[allow(deprecated)]\n-pub use self::decode::{decode_utf8, DecodeUtf8, InvalidSequence};\n \n use fmt::{self, Write};\n use iter::FusedIterator;"}, {"sha": "6045fac2b4b3d7fe096152772e6d6993d1383083", "filename": "src/libcore/future/future_obj.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ffuture%2Ffuture_obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture_obj.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -36,6 +36,8 @@ pub struct LocalFutureObj<'a, T> {\n     _marker: PhantomData<&'a ()>,\n }\n \n+impl<'a, T> Unpin for LocalFutureObj<'a, T> {}\n+\n impl<'a, T> LocalFutureObj<'a, T> {\n     /// Create a `LocalFutureObj` from a custom trait object representation.\n     #[inline]\n@@ -104,6 +106,7 @@ impl<'a, T> Drop for LocalFutureObj<'a, T> {\n ///   information #44874)\n pub struct FutureObj<'a, T>(LocalFutureObj<'a, T>);\n \n+impl<'a, T> Unpin for FutureObj<'a, T> {}\n unsafe impl<'a, T> Send for FutureObj<'a, T> {}\n \n impl<'a, T> FutureObj<'a, T> {"}, {"sha": "da72f3748425d9f1e77b54c837dddf9a339b9a28", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -13,7 +13,7 @@ use marker::Unsize;\n /// Trait that indicates that this is a pointer or a wrapper for one,\n /// where unsizing can be performed on the pointee.\n ///\n-/// See the [DST coercion RfC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n+/// See the [DST coercion RFC][dst-coerce] and [the nomicon entry on coercion][nomicon-coerce]\n /// for more details.\n ///\n /// For builtin pointer types, pointers to `T` will coerce to pointers to `U` if `T: Unsize<U>`"}, {"sha": "479c10c4ffbae40ecd0a169687381da1fb5e28dd", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -680,46 +680,6 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers ia not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// This function returns `None` if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(offset_to)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// fn main() {\n-    ///     let a = [0; 5];\n-    ///     let ptr1: *const i32 = &a[1];\n-    ///     let ptr2: *const i32 = &a[3];\n-    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n-    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n-    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n-    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Replaced by `wrapping_offset_from`, with the \\\n-        opposite argument order.  If you're writing unsafe code, consider `offset_from`.\")]\n-    #[inline]\n-    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n-        let size = mem::size_of::<T>();\n-        if size == 0 {\n-            None\n-        } else {\n-            Some(other.wrapping_offset_from(self))\n-        }\n-    }\n-\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///\n@@ -1464,46 +1424,6 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers ia not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// This function returns `None` if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(offset_to)]\n-    /// #![allow(deprecated)]\n-    ///\n-    /// fn main() {\n-    ///     let mut a = [0; 5];\n-    ///     let ptr1: *mut i32 = &mut a[1];\n-    ///     let ptr2: *mut i32 = &mut a[3];\n-    ///     assert_eq!(ptr1.offset_to(ptr2), Some(2));\n-    ///     assert_eq!(ptr2.offset_to(ptr1), Some(-2));\n-    ///     assert_eq!(unsafe { ptr1.offset(2) }, ptr2);\n-    ///     assert_eq!(unsafe { ptr2.offset(-2) }, ptr1);\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"offset_to\", issue = \"41079\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Replaced by `wrapping_offset_from`, with the \\\n-        opposite argument order.  If you're writing unsafe code, consider `offset_from`.\")]\n-    #[inline]\n-    pub fn offset_to(self, other: *const T) -> Option<isize> where T: Sized {\n-        let size = mem::size_of::<T>();\n-        if size == 0 {\n-            None\n-        } else {\n-            Some(other.wrapping_offset_from(self))\n-        }\n-    }\n-\n     /// Calculates the distance between two pointers. The returned value is in\n     /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n     ///"}, {"sha": "d770536ef4279aebad5730209851c70ae0d63ec4", "filename": "src/libcore/task/wake.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ftask%2Fwake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ftask%2Fwake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fwake.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -42,7 +42,7 @@ impl Waker {\n     /// `Arc` type and the safe `Wake` trait.\n     #[inline]\n     pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        Waker { inner: inner }\n+        Waker { inner }\n     }\n \n     /// Wake up the task associated with this `Waker`.\n@@ -120,7 +120,7 @@ impl LocalWaker {\n     /// on the current thread.\n     #[inline]\n     pub unsafe fn new(inner: NonNull<dyn UnsafeWake>) -> Self {\n-        LocalWaker { inner: inner }\n+        LocalWaker { inner }\n     }\n \n     /// Wake up the task associated with this `LocalWaker`.\n@@ -159,7 +159,9 @@ impl LocalWaker {\n impl From<LocalWaker> for Waker {\n     #[inline]\n     fn from(local_waker: LocalWaker) -> Self {\n-        Waker { inner: local_waker.inner }\n+        let inner = local_waker.inner;\n+        mem::forget(local_waker);\n+        Waker { inner }\n     }\n }\n "}, {"sha": "46c54056e2cc9e67b8f4882e294c1ef110d1dcaf", "filename": "src/libcore/tests/char.rs", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ftests%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibcore%2Ftests%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fchar.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -363,54 +363,3 @@ fn eu_iterator_specializations() {\n     check('\\u{12340}');\n     check('\\u{10FFFF}');\n }\n-\n-#[test]\n-#[allow(deprecated)]\n-fn test_decode_utf8() {\n-    macro_rules! assert_decode_utf8 {\n-        ($input_bytes: expr, $expected_str: expr) => {\n-            let input_bytes: &[u8] = &$input_bytes;\n-            let s = char::decode_utf8(input_bytes.iter().cloned())\n-                .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))\n-                .collect::<String>();\n-            assert_eq!(s, $expected_str,\n-                       \"input bytes: {:?}, expected str: {:?}, result: {:?}\",\n-                       input_bytes, $expected_str, s);\n-            assert_eq!(String::from_utf8_lossy(&$input_bytes), $expected_str);\n-        }\n-    }\n-\n-    assert_decode_utf8!([], \"\");\n-    assert_decode_utf8!([0x41], \"A\");\n-    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\ufffd\");\n-    assert_decode_utf8!([0xE2, 0x99, 0xA5], \"\u2665\");\n-    assert_decode_utf8!([0xE2, 0x99, 0xA5, 0x41], \"\u2665A\");\n-    assert_decode_utf8!([0xE2, 0x99], \"\ufffd\");\n-    assert_decode_utf8!([0xE2, 0x99, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xC0], \"\ufffd\");\n-    assert_decode_utf8!([0xC0, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0x80], \"\ufffd\");\n-    assert_decode_utf8!([0x80, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xFE], \"\ufffd\");\n-    assert_decode_utf8!([0xFE, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xFF], \"\ufffd\");\n-    assert_decode_utf8!([0xFF, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xC0, 0x80], \"\ufffd\ufffd\");\n-\n-    // Surrogates\n-    assert_decode_utf8!([0xED, 0x9F, 0xBF], \"\\u{D7FF}\");\n-    assert_decode_utf8!([0xED, 0xA0, 0x80], \"\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xED, 0xBF, 0x80], \"\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xEE, 0x80, 0x80], \"\\u{E000}\");\n-\n-    // char::MAX\n-    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0xBF], \"\\u{10FFFF}\");\n-    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0x41], \"\ufffdA\");\n-    assert_decode_utf8!([0xF4, 0x90, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\");\n-\n-    // 5 and 6 bytes sequence\n-    // Part of the original design of UTF-8,\n-    // but invalid now that UTF-8 is artificially restricted to match the range of UTF-16.\n-    assert_decode_utf8!([0xF8, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\");\n-    assert_decode_utf8!([0xFC, 0x80, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n-}"}, {"sha": "15630157722fa502ea3c715648c4ad01f7508914", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 43, "deletions": 21, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -42,7 +42,7 @@ use util::nodemap::FxHashMap;\n use std::default::Default as StdDefault;\n use syntax::ast;\n use syntax::edition;\n-use syntax_pos::{MultiSpan, Span};\n+use syntax_pos::{MultiSpan, Span, symbol::LocalInternedString};\n use errors::DiagnosticBuilder;\n use hir;\n use hir::def_id::LOCAL_CRATE;\n@@ -133,6 +133,12 @@ pub enum CheckLintNameResult<'a> {\n     /// The lint is either renamed or removed. This is the warning\n     /// message, and an optional new name (`None` if removed).\n     Warning(String, Option<String>),\n+    /// The lint is from a tool. If the Option is None, then either\n+    /// the lint does not exist in the tool or the code was not\n+    /// compiled with the tool and therefore the lint was never\n+    /// added to the `LintStore`. Otherwise the `LintId` will be\n+    /// returned as if it where a rustc lint.\n+    Tool(Option<&'a [LintId]>),\n }\n \n impl LintStore {\n@@ -288,14 +294,15 @@ impl LintStore {\n                                    sess: &Session,\n                                    lint_name: &str,\n                                    level: Level) {\n-        let db = match self.check_lint_name(lint_name) {\n+        let db = match self.check_lint_name(lint_name, None) {\n             CheckLintNameResult::Ok(_) => None,\n             CheckLintNameResult::Warning(ref msg, _) => {\n                 Some(sess.struct_warn(msg))\n             },\n             CheckLintNameResult::NoLint => {\n                 Some(struct_err!(sess, E0602, \"unknown lint: `{}`\", lint_name))\n             }\n+            CheckLintNameResult::Tool(_) => unreachable!(),\n         };\n \n         if let Some(mut db) = db {\n@@ -319,26 +326,41 @@ impl LintStore {\n     /// it emits non-fatal warnings and there are *two* lint passes that\n     /// inspect attributes, this is only run from the late pass to avoid\n     /// printing duplicate warnings.\n-    pub fn check_lint_name(&self, lint_name: &str) -> CheckLintNameResult {\n-        match self.by_name.get(lint_name) {\n-            Some(&Renamed(ref new_name, _)) => {\n-                CheckLintNameResult::Warning(\n-                    format!(\"lint `{}` has been renamed to `{}`\", lint_name, new_name),\n-                    Some(new_name.to_owned())\n-                )\n-            },\n-            Some(&Removed(ref reason)) => {\n-                CheckLintNameResult::Warning(\n-                    format!(\"lint `{}` has been removed: `{}`\", lint_name, reason),\n-                    None\n-                )\n-            },\n-            None => {\n-                match self.lint_groups.get(lint_name) {\n-                    None => CheckLintNameResult::NoLint,\n-                    Some(ids) => CheckLintNameResult::Ok(&ids.0),\n-                }\n+    pub fn check_lint_name(\n+        &self,\n+        lint_name: &str,\n+        tool_name: Option<LocalInternedString>,\n+    ) -> CheckLintNameResult {\n+        let complete_name = if let Some(tool_name) = tool_name {\n+            format!(\"{}::{}\", tool_name, lint_name)\n+        } else {\n+            lint_name.to_string()\n+        };\n+        if let Some(_) = tool_name {\n+            match self.by_name.get(&complete_name) {\n+                None => match self.lint_groups.get(&*complete_name) {\n+                    None => return CheckLintNameResult::Tool(None),\n+                    Some(ids) => return CheckLintNameResult::Tool(Some(&ids.0)),\n+                },\n+                Some(&Id(ref id)) => return CheckLintNameResult::Tool(Some(slice::from_ref(id))),\n+                // If the lint was registered as removed or renamed by the lint tool, we don't need\n+                // to treat tool_lints and rustc lints different and can use the code below.\n+                _ => {}\n             }\n+        }\n+        match self.by_name.get(&complete_name) {\n+            Some(&Renamed(ref new_name, _)) => CheckLintNameResult::Warning(\n+                format!(\"lint `{}` has been renamed to `{}`\", lint_name, new_name),\n+                Some(new_name.to_owned()),\n+            ),\n+            Some(&Removed(ref reason)) => CheckLintNameResult::Warning(\n+                format!(\"lint `{}` has been removed: `{}`\", lint_name, reason),\n+                None,\n+            ),\n+            None => match self.lint_groups.get(&*complete_name) {\n+                None => CheckLintNameResult::NoLint,\n+                Some(ids) => CheckLintNameResult::Ok(&ids.0),\n+            },\n             Some(&Id(ref id)) => CheckLintNameResult::Ok(slice::from_ref(id)),\n         }\n     }"}, {"sha": "483e2ea8a96cd8607c51deab2f0717e301355e66", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -227,17 +227,18 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue\n                     }\n                 };\n-                if let Some(lint_tool) = word.is_scoped() {\n-                    if !self.sess.features_untracked().tool_lints {\n+                let tool_name = if let Some(lint_tool) = word.is_scoped() {\n+                    let gate_feature = !self.sess.features_untracked().tool_lints;\n+                    let known_tool = attr::is_known_lint_tool(lint_tool);\n+                    if gate_feature {\n                         feature_gate::emit_feature_err(&sess.parse_sess,\n                                                        \"tool_lints\",\n                                                        word.span,\n                                                        feature_gate::GateIssue::Language,\n                                                        &format!(\"scoped lint `{}` is experimental\",\n                                                                 word.ident));\n                     }\n-\n-                    if !attr::is_known_lint_tool(lint_tool) {\n+                    if !known_tool {\n                         span_err!(\n                             sess,\n                             lint_tool.span,\n@@ -247,17 +248,37 @@ impl<'a> LintLevelsBuilder<'a> {\n                         );\n                     }\n \n-                    continue\n-                }\n+                    if gate_feature || !known_tool {\n+                        continue\n+                    }\n+\n+                    Some(lint_tool.as_str())\n+                } else {\n+                    None\n+                };\n                 let name = word.name();\n-                match store.check_lint_name(&name.as_str()) {\n+                match store.check_lint_name(&name.as_str(), tool_name) {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span);\n                         for id in ids {\n                             specs.insert(*id, (level, src));\n                         }\n                     }\n \n+                    CheckLintNameResult::Tool(result) => {\n+                        if let Some(ids) = result {\n+                            let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n+                            let src = LintSource::Node(Symbol::intern(complete_name), li.span);\n+                            for id in ids {\n+                                specs.insert(*id, (level, src));\n+                            }\n+                        }\n+                        // If Tool(None) is returned, then either the lint does not exist in the\n+                        // tool or the code was not compiled with the tool and therefore the lint\n+                        // was never added to the `LintStore`. To detect this is the responsibility\n+                        // of the lint tool.\n+                    }\n+\n                     _ if !self.warn_about_weird_lints => {}\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n@@ -298,7 +319,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         if name.as_str().chars().any(|c| c.is_uppercase()) {\n                             let name_lower = name.as_str().to_lowercase().to_string();\n                             if let CheckLintNameResult::NoLint =\n-                                    store.check_lint_name(&name_lower) {\n+                                    store.check_lint_name(&name_lower, tool_name) {\n                                 db.emit();\n                             } else {\n                                 db.span_suggestion_with_applicability("}, {"sha": "d267c1812773b07ab6116b4bd3851af2326a6c7e", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -139,6 +139,26 @@ macro_rules! declare_lint {\n     );\n }\n \n+#[macro_export]\n+macro_rules! declare_tool_lint {\n+    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr) => (\n+        declare_tool_lint!{$vis $tool::$NAME, $Level, $desc, false}\n+    );\n+    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr,\n+     report_in_external_macro: $rep: expr) => (\n+         declare_tool_lint!{$vis $tool::$NAME, $Level, $desc, $rep}\n+    );\n+    ($vis: vis $tool: ident ::$NAME: ident, $Level: ident, $desc: expr, $external: expr) => (\n+        $vis static $NAME: &$crate::lint::Lint = &$crate::lint::Lint {\n+            name: &concat!(stringify!($tool), \"::\", stringify!($NAME)),\n+            default_level: $crate::lint::$Level,\n+            desc: $desc,\n+            edition_lint_opts: None,\n+            report_in_external_macro: $external,\n+        };\n+    );\n+}\n+\n /// Declare a static `LintArray` and return it as an expression.\n #[macro_export]\n macro_rules! lint_array {"}, {"sha": "b5f52d54ae471bd7bca2569b46a3eea2283a8332", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 128, "deletions": 4, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -169,10 +169,18 @@ impl<A: Array> FromIterator<A::Element> for SmallVec<A> {\n \n impl<A: Array> Extend<A::Element> for SmallVec<A> {\n     fn extend<I: IntoIterator<Item=A::Element>>(&mut self, iter: I) {\n-        let iter = iter.into_iter();\n-        self.reserve(iter.size_hint().0);\n-        for el in iter {\n-            self.push(el);\n+        if self.is_array() {\n+            let iter = iter.into_iter();\n+            self.reserve(iter.size_hint().0);\n+\n+            for el in iter {\n+                self.push(el);\n+            }\n+        } else {\n+            match self.0 {\n+                AccumulateVec::Heap(ref mut vec) => vec.extend(iter),\n+                _ => unreachable!()\n+            }\n         }\n     }\n }\n@@ -213,3 +221,119 @@ impl<A> Decodable for SmallVec<A>\n         })\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate test;\n+    use self::test::Bencher;\n+\n+    use super::*;\n+\n+    #[bench]\n+    fn fill_small_vec_1_10_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 1]> = SmallVec::with_capacity(10);\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_1_10_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 1]> = SmallVec::new();\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_8_10_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 8]> = SmallVec::with_capacity(10);\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_8_10_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 8]> = SmallVec::new();\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_32_10_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 32]> = SmallVec::with_capacity(10);\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_32_10_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 32]> = SmallVec::new();\n+\n+            sv.extend(0..10);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_1_50_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 1]> = SmallVec::with_capacity(50);\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_1_50_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 1]> = SmallVec::new();\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_8_50_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 8]> = SmallVec::with_capacity(50);\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_8_50_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 8]> = SmallVec::new();\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_32_50_with_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 32]> = SmallVec::with_capacity(50);\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+\n+    #[bench]\n+    fn fill_small_vec_32_50_wo_cap(b: &mut Bencher) {\n+        b.iter(|| {\n+            let mut sv: SmallVec<[usize; 32]> = SmallVec::new();\n+\n+            sv.extend(0..50);\n+        })\n+    }\n+}"}, {"sha": "27221296ff31fc467856f7f46c0525f76d327576", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -331,6 +331,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     }\n \n     if mbcx.errors_buffer.len() > 0 {\n+        mbcx.errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+\n         if tcx.migrate_borrowck() {\n             match tcx.borrowck(def_id).signalled_any_error {\n                 SignalledError::NoErrorsSeen => {"}, {"sha": "4d988fef450b8a527f5a5e341dca51b9a62e779d", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -341,7 +341,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 // another match arm\n                 binds_to.sort();\n                 binds_to.dedup();\n-                for local in binds_to {\n+                let mut multipart_suggestion = Vec::with_capacity(binds_to.len());\n+                for (j, local) in binds_to.into_iter().enumerate() {\n                     let bind_to = &self.mir.local_decls[local];\n                     let binding_span = bind_to.source_info.span;\n \n@@ -350,13 +351,15 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         Mutability::Not => \"ref\",\n                         Mutability::Mut => \"ref mut\",\n                     };\n+                    if j == 0 {\n+                        err.span_label(binding_span, format!(\"data moved here\"));\n+                    } else {\n+                        err.span_label(binding_span, format!(\"... and here\"));\n+                    }\n                     match bind_to.name {\n                         Some(name) => {\n-                            err.span_suggestion(\n-                                binding_span,\n-                                \"to prevent move, use ref or ref mut\",\n-                                format!(\"{} {:?}\", ref_kind, name),\n-                            );\n+                            multipart_suggestion.push((binding_span,\n+                                                       format!(\"{} {}\", ref_kind, name)));\n                         }\n                         None => {\n                             err.span_label(\n@@ -366,6 +369,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                 }\n+                err.multipart_suggestion(\"to prevent move, use ref or ref mut\",\n+                                         multipart_suggestion);\n             }\n             // Nothing to suggest.\n             GroupedMoveError::OtherIllegalMove { .. } => (),"}, {"sha": "cd2de3247cfbada221c2dda044ba974c17be04ab", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 43, "deletions": 11, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -307,7 +307,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 let local_decl = &self.mir.local_decls[*local];\n                 let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n                     ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n-                        Some(suggest_ampmut_self(local_decl))\n+                        Some(suggest_ampmut_self(self.tcx, local_decl))\n                     }\n \n                     ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n@@ -418,8 +418,22 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(local_decl: &mir::LocalDecl<'tcx>) -> (Span, String) {\n-    (local_decl.source_info.span, \"&mut self\".to_string())\n+fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    local_decl: &mir::LocalDecl<'tcx>,\n+) -> (Span, String) {\n+    let sp = local_decl.source_info.span;\n+    (sp, match tcx.sess.codemap().span_to_snippet(sp) {\n+        Ok(snippet) => {\n+            let lt_pos = snippet.find('\\'');\n+            if let Some(lt_pos) = lt_pos {\n+                format!(\"&{}mut self\", &snippet[lt_pos..snippet.len() - 4])\n+            } else {\n+                \"&mut self\".to_string()\n+            }\n+        }\n+        _ => \"&mut self\".to_string()\n+    })\n }\n \n // When we want to suggest a user change a local variable to be a `&mut`, there\n@@ -447,9 +461,15 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n     let locations = mir.find_assignments(local);\n     if locations.len() > 0 {\n         let assignment_rhs_span = mir.source_info(locations[0]).span;\n-        let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n-        if let Ok(src) = snippet {\n-            if src.starts_with('&') {\n+        if let Ok(src) = tcx.sess.codemap().span_to_snippet(assignment_rhs_span) {\n+            if let (true, Some(ws_pos)) = (\n+                src.starts_with(\"&'\"),\n+                src.find(|c: char| -> bool { c.is_whitespace() }),\n+            ) {\n+                let lt_name = &src[1..ws_pos];\n+                let ty = &src[ws_pos..];\n+                return (assignment_rhs_span, format!(\"&{} mut {}\", lt_name, ty));\n+            } else if src.starts_with('&') {\n                 let borrowed_expr = src[1..].to_string();\n                 return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n             }\n@@ -466,13 +486,25 @@ fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n         None => local_decl.source_info.span,\n     };\n \n+    if let Ok(src) = tcx.sess.codemap().span_to_snippet(highlight_span) {\n+        if let (true, Some(ws_pos)) = (\n+            src.starts_with(\"&'\"),\n+            src.find(|c: char| -> bool { c.is_whitespace() }),\n+        ) {\n+            let lt_name = &src[1..ws_pos];\n+            let ty = &src[ws_pos..];\n+            return (highlight_span, format!(\"&{} mut{}\", lt_name, ty));\n+        }\n+    }\n+\n     let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n     assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n-    if local_decl.ty.is_region_ptr() {\n-        (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n-    } else {\n-        (highlight_span, format!(\"*mut {}\", ty_mut.ty))\n-    }\n+    (highlight_span,\n+     if local_decl.ty.is_region_ptr() {\n+         format!(\"&mut {}\", ty_mut.ty)\n+     } else {\n+         format!(\"*mut {}\", ty_mut.ty)\n+     })\n }\n \n fn is_closure_or_generator(ty: ty::Ty) -> bool {"}, {"sha": "6a447d81dc3cb5f92f549b63621f1e5081df975a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1213,11 +1213,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n             let mut vals_for_guard = Vec::with_capacity(num_patterns);\n             for _ in 0..num_patterns {\n-                let val_for_guard_idx =  self.local_decls.push(local.clone());\n+                let val_for_guard_idx = self.local_decls.push(LocalDecl {\n+                    // This variable isn't mutated but has a name, so has to be\n+                    // immutable to avoid the unused mut lint.\n+                    mutability: Mutability::Not,\n+                    ..local.clone()\n+                });\n                 vals_for_guard.push(val_for_guard_idx);\n             }\n             let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n-                mutability,\n+                // See previous comment.\n+                mutability: Mutability::Not,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n                 name: Some(name),\n                 source_info,"}, {"sha": "6b81c62e48b87c57077f64a2f170ade5732414eb", "filename": "src/librustc_target/spec/aarch64_unknown_hermit.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_hermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_hermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Faarch64_unknown_hermit.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::hermit_base::opts();\n+    base.max_atomic_width = Some(128);\n+    base.abi_blacklist = super::arm_base::abi_blacklist();\n+    base.linker = Some(\"aarch64-hermit-gcc\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"aarch64-unknown-hermit\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n+        arch: \"aarch64\".to_string(),\n+        target_os: \"hermit\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "2a24f771e92897811a9c5ad1ed48fd0c547ee038", "filename": "src/librustc_target/spec/hermit_base.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fhermit_base.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkArgs, LinkerFlavor, PanicStrategy, TargetOptions};\n+use std::default::Default;\n+\n+pub fn opts() -> TargetOptions {\n+    let mut args = LinkArgs::new();\n+    args.insert(LinkerFlavor::Gcc, vec![\n+        \"-Wl,-Bstatic\".to_string(),\n+        \"-Wl,--no-dynamic-linker\".to_string(),\n+        \"-Wl,--gc-sections\".to_string(),\n+        \"-Wl,--as-needed\".to_string(),\n+    ]);\n+\n+    TargetOptions {\n+        exe_allocation_crate: None,\n+        executables: true,\n+        has_elf_tls: true,\n+        linker_is_gnu: true,\n+        no_default_libraries: false,\n+        panic_strategy: PanicStrategy::Abort,\n+        position_independent_executables: false,\n+        pre_link_args: args,\n+        relocation_model: \"static\".to_string(),\n+        target_family: Some(\"unix\".to_string()),\n+        tls_model: \"local-exec\".to_string(),\n+        .. Default::default()\n+    }\n+}"}, {"sha": "6c2d16d6a17eb7d9298fbf1582c498db30ca41e2", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -62,6 +62,7 @@ mod cloudabi_base;\n mod dragonfly_base;\n mod freebsd_base;\n mod haiku_base;\n+mod hermit_base;\n mod linux_base;\n mod linux_musl_base;\n mod openbsd_base;\n@@ -373,6 +374,9 @@ supported_targets! {\n     (\"armv7-unknown-cloudabi-eabihf\", armv7_unknown_cloudabi_eabihf),\n     (\"i686-unknown-cloudabi\", i686_unknown_cloudabi),\n     (\"x86_64-unknown-cloudabi\", x86_64_unknown_cloudabi),\n+\n+    (\"aarch64-unknown-hermit\", aarch64_unknown_hermit),\n+    (\"x86_64-unknown-hermit\", x86_64_unknown_hermit),\n }\n \n /// Everything `rustc` knows about how to compile for a specific target."}, {"sha": "9f9f2e6ec43e9bbde72d01e86f94c6b5d639fc60", "filename": "src/librustc_target/spec/x86_64_unknown_hermit.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fx86_64_unknown_hermit.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use spec::{LinkerFlavor, Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::hermit_base::opts();\n+    base.cpu = \"x86-64\".to_string();\n+    base.pre_link_args.get_mut(&LinkerFlavor::Gcc).unwrap().push(\"-m64\".to_string());\n+    base.linker = Some(\"x86_64-hermit-gcc\".to_string());\n+    base.max_atomic_width = Some(64);\n+\n+    Ok(Target {\n+        llvm_target: \"x86_64-unknown-hermit\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n+        target_c_int_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-i64:64-f80:128-n8:16:32:64-S128\".to_string(),\n+        arch: \"x86_64\".to_string(),\n+        target_os: \"hermit\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        linker_flavor: LinkerFlavor::Gcc,\n+        options: base,\n+    })\n+}"}, {"sha": "9631ea059cc4300f0337ac755716024033e3133a", "filename": "src/librustdoc/externalfiles.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fexternalfiles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fexternalfiles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fexternalfiles.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -12,7 +12,9 @@ use std::fs;\n use std::path::Path;\n use std::str;\n use errors;\n-use html::markdown::Markdown;\n+use syntax::feature_gate::UnstableFeatures;\n+use html::markdown::{IdMap, ErrorCodes, Markdown};\n+use std::cell::RefCell;\n \n #[derive(Clone)]\n pub struct ExternalHtml {\n@@ -29,24 +31,28 @@ pub struct ExternalHtml {\n \n impl ExternalHtml {\n     pub fn load(in_header: &[String], before_content: &[String], after_content: &[String],\n-                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler)\n+                md_before_content: &[String], md_after_content: &[String], diag: &errors::Handler,\n+                id_map: &mut IdMap)\n             -> Option<ExternalHtml> {\n+        let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n         load_external_files(in_header, diag)\n             .and_then(|ih|\n                 load_external_files(before_content, diag)\n                     .map(|bc| (ih, bc))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(md_before_content, diag)\n-                    .map(|m_bc| (ih, format!(\"{}{}\", bc, Markdown(&m_bc, &[]))))\n+                    .map(|m_bc| (ih,\n+                            format!(\"{}{}\", bc, Markdown(&m_bc, &[], RefCell::new(id_map), codes))))\n             )\n             .and_then(|(ih, bc)|\n                 load_external_files(after_content, diag)\n                     .map(|ac| (ih, bc, ac))\n             )\n             .and_then(|(ih, bc, ac)|\n                 load_external_files(md_after_content, diag)\n-                    .map(|m_ac| (ih, bc, format!(\"{}{}\", ac, Markdown(&m_ac, &[]))))\n+                    .map(|m_ac| (ih, bc,\n+                            format!(\"{}{}\", ac, Markdown(&m_ac, &[], RefCell::new(id_map), codes))))\n             )\n             .map(|(ih, bc, ac)|\n                 ExternalHtml {"}, {"sha": "73d7a9ab8599d75015d62301eeb2c21e1cdddc3b", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 22, "deletions": 38, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -13,12 +13,7 @@\n //! This module uses libsyntax's lexer to provide token-based highlighting for\n //! the HTML documentation generated by rustdoc.\n //!\n-//! If you just want to syntax highlighting for a Rust program, then you can use\n-//! the `render_inner_with_highlighting` or `render_with_highlighting`\n-//! functions. For more advanced use cases (if you want to supply your own css\n-//! classes or control how the HTML is generated, or even generate something\n-//! other then HTML), then you should implement the `Writer` trait and use a\n-//! `Classifier`.\n+//! Use the `render_with_highlighting` to highlight some rust code.\n \n use html::escape::Escape;\n \n@@ -33,7 +28,7 @@ use syntax::parse;\n use syntax_pos::{Span, FileName};\n \n /// Highlights `src`, returning the HTML output.\n-pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n+pub fn render_with_highlighting(src: &str, class: Option<&str>,\n                                 extension: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n@@ -46,7 +41,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n                      class='tooltiptext'>{}</span></div></div>\",\n                class, tooltip).unwrap();\n     }\n-    write_header(class, id, &mut out).unwrap();\n+    write_header(class, &mut out).unwrap();\n \n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm, None), sess.codemap());\n     if let Err(_) = classifier.write_source(&mut out) {\n@@ -63,7 +58,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// Processes a program (nested in the internal `lexer`), classifying strings of\n /// text by highlighting category (`Class`). Calls out to a `Writer` to write\n /// each span of text in sequence.\n-pub struct Classifier<'a> {\n+struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n     codemap: &'a CodeMap,\n \n@@ -75,7 +70,7 @@ pub struct Classifier<'a> {\n \n /// How a span of text is classified. Mostly corresponds to token kinds.\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n-pub enum Class {\n+enum Class {\n     None,\n     Comment,\n     DocComment,\n@@ -103,19 +98,17 @@ pub enum Class {\n /// The classifier will call into the `Writer` implementation as it finds spans\n /// of text to highlight. Exactly how that text should be highlighted is up to\n /// the implementation.\n-pub trait Writer {\n+trait Writer {\n     /// Called when we start processing a span of text that should be highlighted.\n     /// The `Class` argument specifies how it should be highlighted.\n     fn enter_span(&mut self, _: Class) -> io::Result<()>;\n \n     /// Called at the end of a span of highlighted text.\n     fn exit_span(&mut self) -> io::Result<()>;\n \n-    /// Called for a span of text, usually, but not always, a single token. If\n-    /// the string of text (`T`) does correspond to a token, then the token will\n-    /// also be passed. If the text should be highlighted differently from the\n-    /// surrounding text, then the `Class` argument will be a value other than\n-    /// `None`.\n+    /// Called for a span of text.  If the text should be highlighted differently from the\n+    /// surrounding text, then the `Class` argument will be a value other than `None`.\n+    ///\n     /// The following sequences of callbacks are equivalent:\n     /// ```plain\n     ///     enter_span(Foo), string(\"text\", None), exit_span()\n@@ -125,8 +118,7 @@ pub trait Writer {\n     /// more flexible.\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          tok: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()>;\n }\n \n@@ -135,8 +127,7 @@ pub trait Writer {\n impl<U: Write> Writer for U {\n     fn string<T: Display>(&mut self,\n                           text: T,\n-                          klass: Class,\n-                          _tas: Option<&TokenAndSpan>)\n+                          klass: Class)\n                           -> io::Result<()> {\n         match klass {\n             Class::None => write!(self, \"{}\", text),\n@@ -154,7 +145,7 @@ impl<U: Write> Writer for U {\n }\n \n impl<'a> Classifier<'a> {\n-    pub fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+    fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n             codemap,\n@@ -186,7 +177,7 @@ impl<'a> Classifier<'a> {\n     /// is used. All source code emission is done as slices from the source map,\n     /// not from the tokens themselves, in order to stay true to the original\n     /// source.\n-    pub fn write_source<W: Writer>(&mut self,\n+    fn write_source<W: Writer>(&mut self,\n                                    out: &mut W)\n                                    -> io::Result<()> {\n         loop {\n@@ -208,7 +199,7 @@ impl<'a> Classifier<'a> {\n                               -> io::Result<()> {\n         let klass = match tas.tok {\n             token::Shebang(s) => {\n-                out.string(Escape(&s.as_str()), Class::None, Some(&tas))?;\n+                out.string(Escape(&s.as_str()), Class::None)?;\n                 return Ok(());\n             },\n \n@@ -272,8 +263,8 @@ impl<'a> Classifier<'a> {\n                         self.in_attribute = true;\n                         out.enter_span(Class::Attribute)?;\n                     }\n-                    out.string(\"#\", Class::None, None)?;\n-                    out.string(\"!\", Class::None, None)?;\n+                    out.string(\"#\", Class::None)?;\n+                    out.string(\"!\", Class::None)?;\n                     return Ok(());\n                 }\n \n@@ -282,13 +273,13 @@ impl<'a> Classifier<'a> {\n                     self.in_attribute = true;\n                     out.enter_span(Class::Attribute)?;\n                 }\n-                out.string(\"#\", Class::None, None)?;\n+                out.string(\"#\", Class::None)?;\n                 return Ok(());\n             }\n             token::CloseDelim(token::Bracket) => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    out.string(\"]\", Class::None, None)?;\n+                    out.string(\"]\", Class::None)?;\n                     out.exit_span()?;\n                     return Ok(());\n                 } else {\n@@ -344,7 +335,7 @@ impl<'a> Classifier<'a> {\n \n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        out.string(Escape(&self.snip(tas.sp)), klass, Some(&tas))\n+        out.string(Escape(&self.snip(tas.sp)), klass)\n     }\n \n     // Helper function to get a snippet from the codemap.\n@@ -355,7 +346,7 @@ impl<'a> Classifier<'a> {\n \n impl Class {\n     /// Returns the css class expected by rustdoc for each `Class`.\n-    pub fn rustdoc_class(self) -> &'static str {\n+    fn rustdoc_class(self) -> &'static str {\n         match self {\n             Class::None => \"\",\n             Class::Comment => \"comment\",\n@@ -379,15 +370,8 @@ impl Class {\n     }\n }\n \n-fn write_header(class: Option<&str>,\n-                id: Option<&str>,\n-                out: &mut dyn Write)\n-                -> io::Result<()> {\n-    write!(out, \"<pre \")?;\n-    if let Some(id) = id {\n-        write!(out, \"id='{}' \", id)?;\n-    }\n-    write!(out, \"class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n+fn write_header(class: Option<&str>, out: &mut dyn Write) -> io::Result<()> {\n+    write!(out, \"<pre class=\\\"rust {}\\\">\\n\", class.unwrap_or(\"\"))\n }\n \n fn write_footer(out: &mut dyn Write) -> io::Result<()> {"}, {"sha": "b22e239e20a0eeaf166b3b34935ceb6eaaed5655", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 169, "deletions": 91, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -18,27 +18,25 @@\n //! ```\n //! #![feature(rustc_private)]\n //!\n-//! use rustdoc::html::markdown::Markdown;\n+//! use rustdoc::html::markdown::{IdMap, Markdown, ErrorCodes};\n+//! use std::cell::RefCell;\n //!\n //! let s = \"My *markdown* _text_\";\n-//! let html = format!(\"{}\", Markdown(s, &[]));\n+//! let mut id_map = IdMap::new();\n+//! let html = format!(\"{}\", Markdown(s, &[], RefCell::new(&mut id_map), ErrorCodes::Yes));\n //! // ... something using html\n //! ```\n \n #![allow(non_camel_case_types)]\n \n-use rustc::session;\n use std::cell::RefCell;\n use std::collections::{HashMap, VecDeque};\n use std::default::Default;\n use std::fmt::{self, Write};\n use std::borrow::Cow;\n use std::ops::Range;\n use std::str;\n-use syntax::feature_gate::UnstableFeatures;\n-use syntax::codemap::Span;\n \n-use html::render::derive_id;\n use html::toc::TocBuilder;\n use html::highlight;\n use test;\n@@ -50,15 +48,38 @@ use pulldown_cmark::{Options, OPTION_ENABLE_FOOTNOTES, OPTION_ENABLE_TABLES};\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n /// The second parameter is a list of link replacements\n-pub struct Markdown<'a>(pub &'a str, pub &'a [(String, String)]);\n+pub struct Markdown<'a>(\n+    pub &'a str, pub &'a [(String, String)], pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown with a\n /// table of contents.\n-pub struct MarkdownWithToc<'a>(pub &'a str);\n+pub struct MarkdownWithToc<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders the markdown escaping HTML tags.\n-pub struct MarkdownHtml<'a>(pub &'a str);\n+pub struct MarkdownHtml<'a>(pub &'a str, pub RefCell<&'a mut IdMap>, pub ErrorCodes);\n /// A unit struct like `Markdown`, that renders only the first paragraph.\n pub struct MarkdownSummaryLine<'a>(pub &'a str, pub &'a [(String, String)]);\n \n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum ErrorCodes {\n+    Yes,\n+    No,\n+}\n+\n+impl ErrorCodes {\n+    pub fn from(b: bool) -> Self {\n+        match b {\n+            true => ErrorCodes::Yes,\n+            false => ErrorCodes::No,\n+        }\n+    }\n+\n+    pub fn as_bool(self) -> bool {\n+        match self {\n+            ErrorCodes::Yes => true,\n+            ErrorCodes::No => false,\n+        }\n+    }\n+}\n+\n /// Controls whether a line will be hidden or shown in HTML output.\n ///\n /// All lines are used in documentation tests.\n@@ -129,12 +150,14 @@ thread_local!(pub static PLAYGROUND: RefCell<Option<(Option<String>, String)>> =\n /// Adds syntax highlighting and playground Run buttons to rust code blocks.\n struct CodeBlocks<'a, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n+    check_error_codes: ErrorCodes,\n }\n \n impl<'a, I: Iterator<Item = Event<'a>>> CodeBlocks<'a, I> {\n-    fn new(iter: I) -> Self {\n+    fn new(iter: I, error_codes: ErrorCodes) -> Self {\n         CodeBlocks {\n             inner: iter,\n+            check_error_codes: error_codes,\n         }\n     }\n }\n@@ -147,7 +170,7 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n         let compile_fail;\n         let ignore;\n         if let Some(Event::Start(Tag::CodeBlock(lang))) = event {\n-            let parse_result = LangString::parse(&lang);\n+            let parse_result = LangString::parse(&lang, self.check_error_codes);\n             if !parse_result.rust {\n                 return Some(Event::Start(Tag::CodeBlock(lang)));\n             }\n@@ -224,7 +247,6 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'a, I> {\n                                       if ignore { \" ignore\" }\n                                       else if compile_fail { \" compile_fail\" }\n                                       else { \"\" })),\n-                        None,\n                         playground_button.as_ref().map(String::as_str),\n                         tooltip));\n             Some(Event::Html(s.into()))\n@@ -266,23 +288,25 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I>\n }\n \n /// Make headings links with anchor ids and build up TOC.\n-struct HeadingLinks<'a, 'b, I: Iterator<Item = Event<'a>>> {\n+struct HeadingLinks<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n     toc: Option<&'b mut TocBuilder>,\n     buf: VecDeque<Event<'a>>,\n+    id_map: &'ids mut IdMap,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, I> {\n-    fn new(iter: I, toc: Option<&'b mut TocBuilder>) -> Self {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> HeadingLinks<'a, 'b, 'ids, I> {\n+    fn new(iter: I, toc: Option<&'b mut TocBuilder>, ids: &'ids mut IdMap) -> Self {\n         HeadingLinks {\n             inner: iter,\n             toc,\n             buf: VecDeque::new(),\n+            id_map: ids,\n         }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I> {\n+impl<'a, 'b, 'ids, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, 'ids, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -301,7 +325,7 @@ impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for HeadingLinks<'a, 'b, I>\n                 }\n                 self.buf.push_back(event);\n             }\n-            let id = derive_id(id);\n+            let id = self.id_map.derive(id);\n \n             if let Some(ref mut builder) = self.toc {\n                 let mut html_header = String::new();\n@@ -467,10 +491,17 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for Footnotes<'a, I> {\n     }\n }\n \n-pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Span,\n-                          sess: Option<&session::Session>) {\n-    tests.set_position(position);\n+pub struct TestableCodeError(());\n \n+impl fmt::Display for TestableCodeError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"invalid start of a new code block\")\n+    }\n+}\n+\n+pub fn find_testable_code(\n+    doc: &str, tests: &mut test::Collector, error_codes: ErrorCodes,\n+) -> Result<(), TestableCodeError> {\n     let mut parser = Parser::new(doc);\n     let mut prev_offset = 0;\n     let mut nb_lines = 0;\n@@ -481,7 +512,7 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                 let block_info = if s.is_empty() {\n                     LangString::all_false()\n                 } else {\n-                    LangString::parse(&*s)\n+                    LangString::parse(&*s, error_codes)\n                 };\n                 if !block_info.rust {\n                     continue\n@@ -510,18 +541,10 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n                     let text = lines.collect::<Vec<Cow<str>>>().join(\"\\n\");\n                     nb_lines += doc[prev_offset..offset].lines().count();\n                     let line = tests.get_line() + (nb_lines - 1);\n-                    let filename = tests.get_filename();\n-                    tests.add_test(text.to_owned(),\n-                                   block_info.should_panic, block_info.no_run,\n-                                   block_info.ignore, block_info.test_harness,\n-                                   block_info.compile_fail, block_info.error_codes,\n-                                   line, filename, block_info.allow_fail);\n+                    tests.add_test(text, block_info, line);\n                     prev_offset = offset;\n                 } else {\n-                    if let Some(ref sess) = sess {\n-                        sess.span_warn(position, \"invalid start of a new code block\");\n-                    }\n-                    break;\n+                    return Err(TestableCodeError(()));\n                 }\n             }\n             Event::Start(Tag::Header(level)) => {\n@@ -539,19 +562,20 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector, position: Sp\n             _ => {}\n         }\n     }\n+    Ok(())\n }\n \n #[derive(Eq, PartialEq, Clone, Debug)]\n-struct LangString {\n+pub struct LangString {\n     original: String,\n-    should_panic: bool,\n-    no_run: bool,\n-    ignore: bool,\n-    rust: bool,\n-    test_harness: bool,\n-    compile_fail: bool,\n-    error_codes: Vec<String>,\n-    allow_fail: bool,\n+    pub should_panic: bool,\n+    pub no_run: bool,\n+    pub ignore: bool,\n+    pub rust: bool,\n+    pub test_harness: bool,\n+    pub compile_fail: bool,\n+    pub error_codes: Vec<String>,\n+    pub allow_fail: bool,\n }\n \n impl LangString {\n@@ -569,14 +593,11 @@ impl LangString {\n         }\n     }\n \n-    fn parse(string: &str) -> LangString {\n+    fn parse(string: &str, allow_error_code_check: ErrorCodes) -> LangString {\n+        let allow_error_code_check = allow_error_code_check.as_bool();\n         let mut seen_rust_tags = false;\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n-        let mut allow_error_code_check = false;\n-        if UnstableFeatures::from_environment().is_nightly_build() {\n-            allow_error_code_check = true;\n-        }\n \n         data.original = string.to_owned();\n         let tokens = string.split(|c: char|\n@@ -623,7 +644,8 @@ impl LangString {\n \n impl<'a> fmt::Display for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let Markdown(md, links) = *self;\n+        let Markdown(md, links, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -643,20 +665,20 @@ impl<'a> fmt::Display for Markdown<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(\n-                            CodeBlocks::new(\n-                                LinkReplacer::new(\n-                                    HeadingLinks::new(p, None),\n-                                    links))));\n+        let p = HeadingLinks::new(p, None, &mut ids);\n+        let p = LinkReplacer::new(p, links);\n+        let p = CodeBlocks::new(p, codes);\n+        let p = Footnotes::new(p);\n+        html::push_html(&mut s, p);\n \n         fmt.write_str(&s)\n     }\n }\n \n impl<'a> fmt::Display for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownWithToc(md) = *self;\n+        let MarkdownWithToc(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         let mut opts = Options::empty();\n         opts.insert(OPTION_ENABLE_TABLES);\n@@ -668,8 +690,12 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n         let mut toc = TocBuilder::new();\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, Some(&mut toc)))));\n+        {\n+            let p = HeadingLinks::new(p, Some(&mut toc), &mut ids);\n+            let p = CodeBlocks::new(p, codes);\n+            let p = Footnotes::new(p);\n+            html::push_html(&mut s, p);\n+        }\n \n         write!(fmt, \"<nav id=\\\"TOC\\\">{}</nav>\", toc.into_toc())?;\n \n@@ -679,7 +705,8 @@ impl<'a> fmt::Display for MarkdownWithToc<'a> {\n \n impl<'a> fmt::Display for MarkdownHtml<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        let MarkdownHtml(md) = *self;\n+        let MarkdownHtml(md, ref ids, codes) = *self;\n+        let mut ids = ids.borrow_mut();\n \n         // This is actually common enough to special-case\n         if md.is_empty() { return Ok(()) }\n@@ -697,8 +724,10 @@ impl<'a> fmt::Display for MarkdownHtml<'a> {\n \n         let mut s = String::with_capacity(md.len() * 3 / 2);\n \n-        html::push_html(&mut s,\n-                        Footnotes::new(CodeBlocks::new(HeadingLinks::new(p, None))));\n+        let p = HeadingLinks::new(p, None, &mut ids);\n+        let p = CodeBlocks::new(p, codes);\n+        let p = Footnotes::new(p);\n+        html::push_html(&mut s, p);\n \n         fmt.write_str(&s)\n     }\n@@ -812,7 +841,10 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n         let p = Parser::new_with_broken_link_callback(md, opts,\n             Some(&push));\n \n-        let iter = Footnotes::new(HeadingLinks::new(p, None));\n+        // There's no need to thread an IdMap through to here because\n+        // the IDs generated aren't going to be emitted anywhere.\n+        let mut ids = IdMap::new();\n+        let iter = Footnotes::new(HeadingLinks::new(p, None, &mut ids));\n \n         for ev in iter {\n             if let Event::Start(Tag::Link(dest, _)) = ev {\n@@ -831,18 +863,74 @@ pub fn markdown_links(md: &str) -> Vec<(String, Option<Range<usize>>)> {\n     links\n }\n \n+#[derive(Default)]\n+pub struct IdMap {\n+    map: HashMap<String, usize>,\n+}\n+\n+impl IdMap {\n+    pub fn new() -> Self {\n+        IdMap::default()\n+    }\n+\n+    pub fn populate<I: IntoIterator<Item=String>>(&mut self, ids: I) {\n+        for id in ids {\n+            let _ = self.derive(id);\n+        }\n+    }\n+\n+    pub fn reset(&mut self) {\n+        self.map = HashMap::new();\n+    }\n+\n+    pub fn derive(&mut self, candidate: String) -> String {\n+        let id = match self.map.get_mut(&candidate) {\n+            None => candidate,\n+            Some(a) => {\n+                let id = format!(\"{}-{}\", candidate, *a);\n+                *a += 1;\n+                id\n+            }\n+        };\n+\n+        self.map.insert(id.clone(), 1);\n+        id\n+    }\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_unique_id() {\n+    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n+                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n+                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n+    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n+                    \"method.into_iter-1\", \"foo-1\", \"main\", \"search\", \"methods\",\n+                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n+\n+    let map = RefCell::new(IdMap::new());\n+    let test = || {\n+        let mut map = map.borrow_mut();\n+        let actual: Vec<String> = input.iter().map(|s| map.derive(s.to_string())).collect();\n+        assert_eq!(&actual[..], expected);\n+    };\n+    test();\n+    map.borrow_mut().reset();\n+    test();\n+}\n+\n #[cfg(test)]\n mod tests {\n-    use super::{LangString, Markdown, MarkdownHtml};\n+    use super::{ErrorCodes, LangString, Markdown, MarkdownHtml, IdMap};\n     use super::plain_summary_line;\n-    use html::render::reset_ids;\n+    use std::cell::RefCell;\n \n     #[test]\n     fn test_lang_string_parse() {\n         fn t(s: &str,\n             should_panic: bool, no_run: bool, ignore: bool, rust: bool, test_harness: bool,\n             compile_fail: bool, allow_fail: bool, error_codes: Vec<String>) {\n-            assert_eq!(LangString::parse(s), LangString {\n+            assert_eq!(LangString::parse(s, ErrorCodes::Yes), LangString {\n                 should_panic,\n                 no_run,\n                 ignore,\n@@ -878,19 +966,12 @@ mod tests {\n         t(\"text,no_run\",           false,        true,   false,  false, false, false, false, v());\n     }\n \n-    #[test]\n-    fn issue_17736() {\n-        let markdown = \"# title\";\n-        Markdown(markdown, &[]).to_string();\n-        reset_ids(true);\n-    }\n-\n     #[test]\n     fn test_header() {\n         fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[]).to_string();\n+            let mut map = IdMap::new();\n+            let output = Markdown(input, &[], RefCell::new(&mut map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n-            reset_ids(true);\n         }\n \n         t(\"# Foo bar\", \"<h1 id=\\\"foo-bar\\\" class=\\\"section-header\\\">\\\n@@ -909,28 +990,24 @@ mod tests {\n \n     #[test]\n     fn test_header_ids_multiple_blocks() {\n-        fn t(input: &str, expect: &str) {\n-            let output = Markdown(input, &[]).to_string();\n+        let mut map = IdMap::new();\n+        fn t(map: &mut IdMap, input: &str, expect: &str) {\n+            let output = Markdown(input, &[], RefCell::new(map), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n \n-        let test = || {\n-            t(\"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics\\\">Panics</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-1\\\">Example</a></h1>\");\n-            t(\"# Main\", \"<h1 id=\\\"main-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#main-1\\\">Main</a></h1>\");\n-            t(\"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#example-2\\\">Example</a></h1>\");\n-            t(\"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n-              <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n-        };\n-        test();\n-        reset_ids(true);\n-        test();\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics\\\">Panics</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-1\\\">Example</a></h1>\");\n+        t(&mut map, \"# Main\", \"<h1 id=\\\"main\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#main\\\">Main</a></h1>\");\n+        t(&mut map, \"# Example\", \"<h1 id=\\\"example-2\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#example-2\\\">Example</a></h1>\");\n+        t(&mut map, \"# Panics\", \"<h1 id=\\\"panics-1\\\" class=\\\"section-header\\\">\\\n+            <a href=\\\"#panics-1\\\">Panics</a></h1>\");\n     }\n \n     #[test]\n@@ -951,7 +1028,8 @@ mod tests {\n     #[test]\n     fn test_markdown_html_escape() {\n         fn t(input: &str, expect: &str) {\n-            let output = MarkdownHtml(input).to_string();\n+            let mut idmap = IdMap::new();\n+            let output = MarkdownHtml(input, RefCell::new(&mut idmap), ErrorCodes::Yes).to_string();\n             assert_eq!(output, expect, \"original: {}\", input);\n         }\n "}, {"sha": "c2978a62489a0d86bd787212f9abc144d2d4dc81", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 68, "deletions": 95, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -50,12 +50,14 @@ use std::mem;\n use std::path::{PathBuf, Path, Component};\n use std::str;\n use std::sync::Arc;\n+use std::rc::Rc;\n \n use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::ast;\n use syntax::codemap::FileName;\n+use syntax::feature_gate::UnstableFeatures;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -72,7 +74,7 @@ use html::format::{GenericBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::format::fmt_impl_for_trait_page;\n use html::item_type::ItemType;\n-use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use html::markdown::{self, Markdown, MarkdownHtml, MarkdownSummaryLine, ErrorCodes, IdMap};\n use html::{highlight, layout};\n \n use minifier;\n@@ -88,7 +90,7 @@ pub type NameDoc = (String, Option<String>);\n /// easily cloned because it is cloned per work-job (about once per item in the\n /// rustdoc tree).\n #[derive(Clone)]\n-pub struct Context {\n+struct Context {\n     /// Current hierarchy of components leading down to what's currently being\n     /// rendered\n     pub current: Vec<String>,\n@@ -99,10 +101,13 @@ pub struct Context {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     pub render_redirect_pages: bool,\n+    pub codes: ErrorCodes,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n }\n \n-pub struct SharedContext {\n+struct SharedContext {\n     /// The path to the crate root source minus the file name.\n     /// Used for simplifying paths to the highlighted source code files.\n     pub src_root: PathBuf,\n@@ -450,9 +455,8 @@ impl ToJson for IndexItemFunctionType {\n \n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> = RefCell::new(Vec::new()));\n-thread_local!(pub static USED_ID_MAP: RefCell<FxHashMap<String, usize>> = RefCell::new(init_ids()));\n \n-fn init_ids() -> FxHashMap<String, usize> {\n+pub fn initial_ids() -> Vec<String> {\n     [\n      \"main\",\n      \"search\",\n@@ -470,36 +474,7 @@ fn init_ids() -> FxHashMap<String, usize> {\n      \"methods\",\n      \"deref-methods\",\n      \"implementations\",\n-    ].into_iter().map(|id| (String::from(*id), 1)).collect()\n-}\n-\n-/// This method resets the local table of used ID attributes. This is typically\n-/// used at the beginning of rendering an entire HTML page to reset from the\n-/// previous state (if any).\n-pub fn reset_ids(embedded: bool) {\n-    USED_ID_MAP.with(|s| {\n-        *s.borrow_mut() = if embedded {\n-            init_ids()\n-        } else {\n-            FxHashMap()\n-        };\n-    });\n-}\n-\n-pub fn derive_id(candidate: String) -> String {\n-    USED_ID_MAP.with(|map| {\n-        let id = match map.borrow_mut().get_mut(&candidate) {\n-            None => candidate,\n-            Some(a) => {\n-                let id = format!(\"{}-{}\", candidate, *a);\n-                *a += 1;\n-                id\n-            }\n-        };\n-\n-        map.borrow_mut().insert(id.clone(), 1);\n-        id\n-    })\n+    ].into_iter().map(|id| (String::from(*id))).collect()\n }\n \n /// Generates the documentation for `crate` into the directory `dst`\n@@ -513,7 +488,8 @@ pub fn run(mut krate: clean::Crate,\n            renderinfo: RenderInfo,\n            sort_modules_alphabetically: bool,\n            themes: Vec<PathBuf>,\n-           enable_minification: bool) -> Result<(), Error> {\n+           enable_minification: bool,\n+           id_map: IdMap) -> Result<(), Error> {\n     let src_root = match krate.src {\n         FileName::Real(ref p) => match p.parent() {\n             Some(p) => p.to_path_buf(),\n@@ -581,6 +557,8 @@ pub fn run(mut krate: clean::Crate,\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n+        codes: ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build()),\n+        id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n     };\n \n@@ -1708,6 +1686,11 @@ impl<'a> fmt::Display for Settings<'a> {\n }\n \n impl Context {\n+    fn derive_id(&self, id: String) -> String {\n+        let mut map = self.id_map.borrow_mut();\n+        map.derive(id)\n+    }\n+\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n     fn root_path(&self) -> String {\n@@ -1862,7 +1845,10 @@ impl Context {\n             resource_suffix: &self.shared.resource_suffix,\n         };\n \n-        reset_ids(true);\n+        {\n+            self.id_map.borrow_mut().reset();\n+            self.id_map.borrow_mut().populate(initial_ids());\n+        }\n \n         if !self.render_redirect_pages {\n             layout::render(writer, &self.shared.layout, &page,\n@@ -2219,14 +2205,17 @@ fn document(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item) -> fmt::Re\n \n /// Render md_text as markdown.\n fn render_markdown(w: &mut fmt::Formatter,\n+                   cx: &Context,\n                    md_text: &str,\n                    links: Vec<(String, String)>,\n-                   prefix: &str,)\n+                   prefix: &str)\n                    -> fmt::Result {\n-    write!(w, \"<div class='docblock'>{}{}</div>\", prefix, Markdown(md_text, &links))\n+    let mut ids = cx.id_map.borrow_mut();\n+    write!(w, \"<div class='docblock'>{}{}</div>\",\n+        prefix, Markdown(md_text, &links, RefCell::new(&mut ids), cx.codes))\n }\n \n-fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLink,\n+fn document_short(w: &mut fmt::Formatter, cx: &Context, item: &clean::Item, link: AssocItemLink,\n                   prefix: &str) -> fmt::Result {\n     if let Some(s) = item.doc_value() {\n         let markdown = if s.contains('\\n') {\n@@ -2235,7 +2224,7 @@ fn document_short(w: &mut fmt::Formatter, item: &clean::Item, link: AssocItemLin\n         } else {\n             plain_summary_line(Some(s)).to_string()\n         };\n-        render_markdown(w, &markdown, item.links(), prefix)?;\n+        render_markdown(w, cx, &markdown, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2250,7 +2239,6 @@ fn render_assoc_const_value(item: &clean::Item) -> String {\n                 None,\n                 None,\n                 None,\n-                None,\n             )\n         }\n         _ => String::new(),\n@@ -2261,7 +2249,7 @@ fn document_full(w: &mut fmt::Formatter, item: &clean::Item,\n                  cx: &Context, prefix: &str) -> fmt::Result {\n     if let Some(s) = cx.shared.maybe_collapsed_doc_value(item) {\n         debug!(\"Doc block: =====\\n{}\\n=====\", s);\n-        render_markdown(w, &*s, item.links(), prefix)?;\n+        render_markdown(w, cx, &*s, item.links(), prefix)?;\n     } else if !prefix.is_empty() {\n         write!(w, \"<div class='docblock'>{}</div>\", prefix)?;\n     }\n@@ -2427,7 +2415,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n             let (short, name) = item_ty_to_strs(&myty.unwrap());\n             write!(w, \"<h2 id='{id}' class='section-header'>\\\n                        <a href=\\\"#{id}\\\">{name}</a></h2>\\n<table>\",\n-                   id = derive_id(short.to_owned()), name = name)?;\n+                   id = cx.derive_id(short.to_owned()), name = name)?;\n         }\n \n         match myitem.inner {\n@@ -2508,6 +2496,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<String> {\n     let mut stability = vec![];\n+    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n \n     if let Some(stab) = item.stability.as_ref() {\n         let deprecated_reason = if show_reason && !stab.deprecated_reason.is_empty() {\n@@ -2521,14 +2510,12 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             } else {\n                 String::new()\n             };\n+            let mut ids = cx.id_map.borrow_mut();\n+            let html = MarkdownHtml(&deprecated_reason, RefCell::new(&mut ids), error_codes);\n             let text = if stability::deprecation_in_effect(&stab.deprecated_since) {\n-                format!(\"Deprecated{}{}\",\n-                        since,\n-                        MarkdownHtml(&deprecated_reason))\n+                format!(\"Deprecated{}{}\", since, html)\n             } else {\n-                format!(\"Deprecating in {}{}\",\n-                        Escape(&stab.deprecated_since),\n-                        MarkdownHtml(&deprecated_reason))\n+                format!(\"Deprecating in {}{}\", Escape(&stab.deprecated_since), html)\n             };\n             stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n         };\n@@ -2555,11 +2542,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                                             </div>\",\n                                            unstable_extra));\n                 } else {\n+                    let mut ids = cx.id_map.borrow_mut();\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n                                         This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n                                        unstable_extra,\n-                                       MarkdownHtml(&stab.unstable_reason));\n+                                       MarkdownHtml(\n+                                           &stab.unstable_reason,\n+                                           RefCell::new(&mut ids),\n+                                           error_codes));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\",\n                                    text));\n                 }\n@@ -2579,14 +2570,15 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n             String::new()\n         };\n \n+        let mut ids = cx.id_map.borrow_mut();\n         let text = if stability::deprecation_in_effect(&depr.since) {\n             format!(\"Deprecated{}{}\",\n                     since,\n-                    MarkdownHtml(&note))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         } else {\n             format!(\"Deprecating in {}{}\",\n                     Escape(&depr.since),\n-                    MarkdownHtml(&note))\n+                    MarkdownHtml(&note, RefCell::new(&mut ids), error_codes))\n         };\n         stability.push(format!(\"<div class='stab deprecated'>{}</div>\", text))\n     }\n@@ -2827,8 +2819,8 @@ fn item_trait(\n                   -> fmt::Result {\n         let name = m.name.as_ref().unwrap();\n         let item_type = m.type_();\n-        let id = derive_id(format!(\"{}.{}\", item_type, name));\n-        let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+        let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+        let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n         write!(w, \"{extra}<h3 id='{id}' class='method'>\\\n                    <span id='{ns_id}' class='invisible'><code>\",\n                extra = render_spotlight_traits(m)?,\n@@ -3183,10 +3175,10 @@ fn item_struct(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                        document_non_exhaustive_header(it))?;\n             document_non_exhaustive(w, it)?;\n             for (field, ty) in fields {\n-                let id = derive_id(format!(\"{}.{}\",\n+                let id = cx.derive_id(format!(\"{}.{}\",\n                                            ItemType::StructField,\n                                            field.name.as_ref().unwrap()));\n-                let ns_id = derive_id(format!(\"{}.{}\",\n+                let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                               field.name.as_ref().unwrap(),\n                                               ItemType::StructField.name_space()));\n                 write!(w, \"<span id=\\\"{id}\\\" class=\\\"{item_type} small-section-header\\\">\n@@ -3317,10 +3309,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                    document_non_exhaustive_header(it))?;\n         document_non_exhaustive(w, it)?;\n         for variant in &e.variants {\n-            let id = derive_id(format!(\"{}.{}\",\n+            let id = cx.derive_id(format!(\"{}.{}\",\n                                        ItemType::Variant,\n                                        variant.name.as_ref().unwrap()));\n-            let ns_id = derive_id(format!(\"{}.{}\",\n+            let ns_id = cx.derive_id(format!(\"{}.{}\",\n                                           variant.name.as_ref().unwrap(),\n                                           ItemType::Variant.name_space()));\n             write!(w, \"<span id=\\\"{id}\\\" class=\\\"variant small-section-header\\\">\\\n@@ -3348,7 +3340,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             if let clean::VariantItem(Variant {\n                 kind: VariantKind::Struct(ref s)\n             }) = variant.inner {\n-                let variant_id = derive_id(format!(\"{}.{}.fields\",\n+                let variant_id = cx.derive_id(format!(\"{}.{}.fields\",\n                                                    ItemType::Variant,\n                                                    variant.name.as_ref().unwrap()));\n                 write!(w, \"<span class='docblock autohide sub-variant' id='{id}'>\",\n@@ -3358,10 +3350,10 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 for field in &s.fields {\n                     use clean::StructFieldItem;\n                     if let StructFieldItem(ref ty) = field.inner {\n-                        let id = derive_id(format!(\"variant.{}.field.{}\",\n+                        let id = cx.derive_id(format!(\"variant.{}.field.{}\",\n                                                    variant.name.as_ref().unwrap(),\n                                                    field.name.as_ref().unwrap()));\n-                        let ns_id = derive_id(format!(\"{}.{}.{}.{}\",\n+                        let ns_id = cx.derive_id(format!(\"{}.{}.{}.{}\",\n                                                       variant.name.as_ref().unwrap(),\n                                                       ItemType::Variant.name_space(),\n                                                       field.name.as_ref().unwrap(),\n@@ -3790,7 +3782,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                render_mode: RenderMode, outer_version: Option<&str>,\n                show_def_docs: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n-        let id = derive_id(match i.inner_impl().trait_ {\n+        let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => format!(\"impl-{}\", small_url_encode(&format!(\"{:#}\", t))),\n             None => \"impl\".to_string(),\n         });\n@@ -3810,8 +3802,9 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n         }\n         write!(w, \"</span></td></tr></tbody></table></h3>\")?;\n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n+            let mut ids = cx.id_map.borrow_mut();\n             write!(w, \"<div class='docblock'>{}</div>\",\n-                   Markdown(&*dox, &i.impl_item.links()))?;\n+                   Markdown(&*dox, &i.impl_item.links(), RefCell::new(&mut ids), cx.codes))?;\n         }\n     }\n \n@@ -3832,8 +3825,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             clean::TyMethodItem(clean::TyMethod{ ref decl, .. }) => {\n                 // Only render when the method is not static or we allow static methods\n                 if render_method_item {\n-                    let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                    let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                    let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                    let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                     write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                     write!(w, \"{}\", spotlight_decl(decl)?)?;\n                     write!(w, \"<span id='{}' class='invisible'>\", ns_id)?;\n@@ -3854,24 +3847,24 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                 }\n             }\n             clean::TypedefItem(ref tydef, _) => {\n-                let id = derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", ItemType::AssociatedType, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, &Vec::new(), Some(&tydef.type_), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedConstItem(ref ty, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_const(w, item, ty, default.as_ref(), link.anchor(&id))?;\n                 write!(w, \"</code></span></h4>\\n\")?;\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n-                let id = derive_id(format!(\"{}.{}\", item_type, name));\n-                let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n+                let id = cx.derive_id(format!(\"{}.{}\", item_type, name));\n+                let ns_id = cx.derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n                 write!(w, \"<h4 id='{}' class=\\\"{}\\\">\", id, item_type)?;\n                 write!(w, \"<span id='{}' class='invisible'><code>\", ns_id)?;\n                 assoc_type(w, item, bounds, default.as_ref(), link.anchor(&id))?;\n@@ -3897,7 +3890,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                         } else if show_def_docs {\n                             // In case the item isn't documented,\n                             // provide short documentation from the trait.\n-                            document_short(w, it, link, &prefix)?;\n+                            document_short(w, cx, it, link, &prefix)?;\n                         }\n                     }\n                 } else {\n@@ -3909,7 +3902,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             } else {\n                 document_stability(w, cx, item)?;\n                 if show_def_docs {\n-                    document_short(w, item, link, &prefix)?;\n+                    document_short(w, cx, item, link, &prefix)?;\n                 }\n             }\n         }\n@@ -4557,7 +4550,7 @@ impl<'a> fmt::Display for Source<'a> {\n         }\n         write!(fmt, \"</pre>\")?;\n         write!(fmt, \"{}\",\n-               highlight::render_with_highlighting(s, None, None, None, None))?;\n+               highlight::render_with_highlighting(s, None, None, None))?;\n         Ok(())\n     }\n }\n@@ -4568,7 +4561,6 @@ fn item_macro(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         w.write_str(&highlight::render_with_highlighting(&t.source,\n                                                          Some(\"macro\"),\n                                                          None,\n-                                                         None,\n                                                          None))\n     })?;\n     document(w, cx, it)\n@@ -4715,25 +4707,6 @@ pub fn cache() -> Arc<Cache> {\n     CACHE_KEY.with(|c| c.borrow().clone())\n }\n \n-#[cfg(test)]\n-#[test]\n-fn test_unique_id() {\n-    let input = [\"foo\", \"examples\", \"examples\", \"method.into_iter\",\"examples\",\n-                 \"method.into_iter\", \"foo\", \"main\", \"search\", \"methods\",\n-                 \"examples\", \"method.into_iter\", \"assoc_type.Item\", \"assoc_type.Item\"];\n-    let expected = [\"foo\", \"examples\", \"examples-1\", \"method.into_iter\", \"examples-2\",\n-                    \"method.into_iter-1\", \"foo-1\", \"main-1\", \"search-1\", \"methods-1\",\n-                    \"examples-3\", \"method.into_iter-2\", \"assoc_type.Item\", \"assoc_type.Item-1\"];\n-\n-    let test = || {\n-        let actual: Vec<String> = input.iter().map(|s| derive_id(s.to_string())).collect();\n-        assert_eq!(&actual[..], expected);\n-    };\n-    test();\n-    reset_ids(true);\n-    test();\n-}\n-\n #[cfg(test)]\n #[test]\n fn test_name_key() {"}, {"sha": "0a4955f4fbd10a83448eaee3a115d719b5191233", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -500,12 +500,14 @@ fn main_args(args: &[String]) -> isize {\n         }\n     }\n \n+    let mut id_map = html::markdown::IdMap::new();\n+    id_map.populate(html::render::initial_ids());\n     let external_html = match ExternalHtml::load(\n             &matches.opt_strs(\"html-in-header\"),\n             &matches.opt_strs(\"html-before-content\"),\n             &matches.opt_strs(\"html-after-content\"),\n             &matches.opt_strs(\"markdown-before-content\"),\n-            &matches.opt_strs(\"markdown-after-content\"), &diag) {\n+            &matches.opt_strs(\"markdown-after-content\"), &diag, &mut id_map) {\n         Some(eh) => eh,\n         None => return 3,\n     };\n@@ -562,7 +564,7 @@ fn main_args(args: &[String]) -> isize {\n                                   renderinfo,\n                                   sort_modules_alphabetically,\n                                   themes,\n-                                  enable_minification)\n+                                  enable_minification, id_map)\n                     .expect(\"failed to generate documentation\");\n                 0\n             }"}, {"sha": "05661dc6856637f0c97410136318d2e60e26da26", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -12,21 +12,22 @@ use std::default::Default;\n use std::fs::File;\n use std::io::prelude::*;\n use std::path::{PathBuf, Path};\n+use std::cell::RefCell;\n \n use errors;\n use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::{Externs, CodegenOptions};\n use syntax::codemap::DUMMY_SP;\n+use syntax::feature_gate::UnstableFeatures;\n use syntax::edition::Edition;\n \n use externalfiles::{ExternalHtml, LoadStringError, load_string};\n \n-use html::render::reset_ids;\n use html::escape::Escape;\n use html::markdown;\n-use html::markdown::{Markdown, MarkdownWithToc, find_testable_code};\n+use html::markdown::{ErrorCodes, IdMap, Markdown, MarkdownWithToc, find_testable_code};\n use test::{TestOptions, Collector};\n \n /// Separate any lines at the start of the file that begin with `# ` or `%`.\n@@ -86,12 +87,12 @@ pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n     }\n     let title = metadata[0];\n \n-    reset_ids(false);\n-\n+    let mut ids = IdMap::new();\n+    let error_codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n     let text = if include_toc {\n-        MarkdownWithToc(text).to_string()\n+        MarkdownWithToc(text, RefCell::new(&mut ids), error_codes).to_string()\n     } else {\n-        Markdown(text, &[]).to_string()\n+        Markdown(text, &[], RefCell::new(&mut ids), error_codes).to_string()\n     };\n \n     let err = write!(\n@@ -156,7 +157,12 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                                        true, opts, maybe_sysroot, None,\n                                        Some(PathBuf::from(input)),\n                                        linker, edition);\n-    find_testable_code(&input_str, &mut collector, DUMMY_SP, None);\n+    collector.set_position(DUMMY_SP);\n+    let codes = ErrorCodes::from(UnstableFeatures::from_environment().is_nightly_build());\n+    let res = find_testable_code(&input_str, &mut collector, codes);\n+    if let Err(err) = res {\n+        diag.span_warn(DUMMY_SP, &err.to_string());\n+    }\n     test_args.insert(0, \"rustdoctest\".to_string());\n     testing::test_main(&test_args, collector.tests,\n                        testing::Options::new().display_output(display_warnings));"}, {"sha": "650a2408aa6edba9d60ab6e73d67902ff8cc4e3a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -42,7 +42,7 @@ use errors;\n use errors::emitter::ColorConfig;\n \n use clean::Attributes;\n-use html::markdown;\n+use html::markdown::{self, ErrorCodes, LangString};\n \n #[derive(Clone, Default)]\n pub struct TestOptions {\n@@ -145,7 +145,8 @@ pub fn run(input_path: &Path,\n             let mut hir_collector = HirCollector {\n                 sess: &sess,\n                 collector: &mut collector,\n-                map: &map\n+                map: &map,\n+                codes: ErrorCodes::from(sess.opts.unstable_features.is_nightly_build()),\n             };\n             hir_collector.visit_testable(\"\".to_string(), &krate.attrs, |this| {\n                 intravisit::walk_crate(this, krate);\n@@ -533,10 +534,8 @@ impl Collector {\n         format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n     }\n \n-    pub fn add_test(&mut self, test: String,\n-                    should_panic: bool, no_run: bool, should_ignore: bool,\n-                    as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize, filename: FileName, allow_fail: bool) {\n+    pub fn add_test(&mut self, test: String, config: LangString, line: usize) {\n+        let filename = self.get_filename();\n         let name = self.generate_name(line, &filename);\n         let cfgs = self.cfgs.clone();\n         let libs = self.libs.clone();\n@@ -551,10 +550,10 @@ impl Collector {\n         self.tests.push(testing::TestDescAndFn {\n             desc: testing::TestDesc {\n                 name: testing::DynTestName(name.clone()),\n-                ignore: should_ignore,\n+                ignore: config.ignore,\n                 // compiler failures are test failures\n                 should_panic: testing::ShouldPanic::No,\n-                allow_fail,\n+                allow_fail: config.allow_fail,\n             },\n             testfn: testing::DynTestFn(box move || {\n                 let panic = io::set_panic(None);\n@@ -572,11 +571,11 @@ impl Collector {\n                                  libs,\n                                  cg,\n                                  externs,\n-                                 should_panic,\n-                                 no_run,\n-                                 as_test_harness,\n-                                 compile_fail,\n-                                 error_codes,\n+                                 config.should_panic,\n+                                 config.no_run,\n+                                 config.test_harness,\n+                                 config.compile_fail,\n+                                 config.error_codes,\n                                  &opts,\n                                  maybe_sysroot,\n                                  linker,\n@@ -604,7 +603,7 @@ impl Collector {\n         self.position = position;\n     }\n \n-    pub fn get_filename(&self) -> FileName {\n+    fn get_filename(&self) -> FileName {\n         if let Some(ref codemap) = self.codemap {\n             let filename = codemap.span_to_filename(self.position);\n             if let FileName::Real(ref filename) = filename {\n@@ -664,7 +663,8 @@ impl Collector {\n struct HirCollector<'a, 'hir: 'a> {\n     sess: &'a session::Session,\n     collector: &'a mut Collector,\n-    map: &'a hir::map::Map<'hir>\n+    map: &'a hir::map::Map<'hir>,\n+    codes: ErrorCodes,\n }\n \n impl<'a, 'hir> HirCollector<'a, 'hir> {\n@@ -689,10 +689,12 @@ impl<'a, 'hir> HirCollector<'a, 'hir> {\n         // the collapse-docs pass won't combine sugared/raw doc attributes, or included files with\n         // anything else, this will combine them for us\n         if let Some(doc) = attrs.collapsed_doc_value() {\n-            markdown::find_testable_code(&doc,\n-                                         self.collector,\n-                                         attrs.span.unwrap_or(DUMMY_SP),\n-                                         Some(self.sess));\n+            self.collector.set_position(attrs.span.unwrap_or(DUMMY_SP));\n+            let res = markdown::find_testable_code(&doc, self.collector, self.codes);\n+            if let Err(err) = res {\n+                self.sess.diagnostic().span_warn(attrs.span.unwrap_or(DUMMY_SP),\n+                    &err.to_string());\n+            }\n         }\n \n         nested(self);"}, {"sha": "ed94194ffcc05be5411eb9ca3cd5fb397e4f8fab", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 116, "deletions": 83, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -46,58 +46,67 @@ pub trait Encoder {\n \n     // Compound types:\n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n-\n-    fn emit_enum_variant<F>(&mut self, _v_name: &str,\n-                            v_id: usize,\n-                            _len: usize,\n-                            f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant<F>(&mut self, _v_name: &str, v_id: usize, _len: usize, f: F)\n+        -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(v_id)?;\n         f(self)\n     }\n-    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F)\n-                                -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n \n-    fn emit_enum_struct_variant<F>(&mut self, v_name: &str,\n-                                   v_id: usize,\n-                                   len: usize,\n-                                   f: F) -> Result<(), Self::Error>\n+    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_enum_struct_variant<F>(&mut self, v_name: &str, v_id: usize, len: usize, f: F)\n+        -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant(v_name, v_id, len, f)\n     }\n-    fn emit_enum_struct_variant_field<F>(&mut self,\n-                                         _f_name: &str,\n-                                         f_idx: usize,\n-                                         f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+\n+    fn emit_enum_struct_variant_field<F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n+        -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_enum_variant_arg(f_idx, f)\n     }\n \n-    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F)\n-                      -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F) -> Result<(), Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n+\n     fn emit_struct_field<F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n-                            -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        -> Result<(), Self::Error> where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n \n     fn emit_tuple<F>(&mut self, _len: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n+\n     fn emit_tuple_arg<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F)\n-                            -> Result<(), Self::Error>\n+    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple(len, f)\n     }\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F)\n-                                -> Result<(), Self::Error>\n+\n+    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_tuple_arg(f_idx, f)\n@@ -109,13 +118,14 @@ pub trait Encoder {\n     {\n         self.emit_enum(\"Option\", f)\n     }\n+\n     fn emit_option_none(&mut self) -> Result<(), Self::Error> {\n         self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n     }\n+\n     fn emit_option_some<F>(&mut self, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n-\n         self.emit_enum_variant(\"Some\", 1, 1, f)\n     }\n \n@@ -125,19 +135,31 @@ pub trait Encoder {\n         self.emit_usize(len)?;\n         f(self)\n     }\n+\n     fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n \n     fn emit_map<F>(&mut self, len: usize, f: F) -> Result<(), Self::Error>\n         where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n     {\n         self.emit_usize(len)?;\n         f(self)\n     }\n+\n     fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n+\n     fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<(), Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<(), Self::Error>\n+    {\n+        f(self)\n+    }\n }\n \n pub trait Decoder {\n@@ -165,59 +187,67 @@ pub trait Decoder {\n \n     // Compound types:\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n \n-    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F)\n-                               -> Result<T, Self::Error>\n+    fn read_enum_variant<T, F>(&mut self, _names: &[&str], mut f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let disr = self.read_usize()?;\n         f(self, disr)\n     }\n-    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F)\n-                                   -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n \n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F)\n-                                      -> Result<T, Self::Error>\n+    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, Self::Error>\n         where F: FnMut(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant(names, f)\n     }\n-    fn read_enum_struct_variant_field<T, F>(&mut self,\n-                                            _f_name: &str,\n-                                            f_idx: usize,\n-                                            f: F)\n-                                            -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+\n+    fn read_enum_struct_variant_field<T, F>(&mut self, _f_name: &str, f_idx: usize, f: F)\n+        -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_enum_variant_arg(f_idx, f)\n     }\n \n-    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F)\n-                         -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n-    fn read_struct_field<T, F>(&mut self,\n-                               _f_name: &str,\n-                               _f_idx: usize,\n-                               f: F)\n-                               -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn read_struct_field<T, F>(&mut self, _f_name: &str, _f_idx: usize, f: F)\n+        -> Result<T, Self::Error> where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n \n     fn read_tuple<T, F>(&mut self, _len: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n-    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F)\n-                            -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n \n-    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F)\n-                               -> Result<T, Self::Error>\n+    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple(len, f)\n     }\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F)\n-                                   -> Result<T, Self::Error>\n+\n+    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n     {\n         self.read_tuple_arg(a_idx, f)\n@@ -244,21 +274,31 @@ pub trait Decoder {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n+\n     fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n \n     fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n         where F: FnOnce(&mut Self, usize) -> Result<T, Self::Error>\n     {\n         let len = self.read_usize()?;\n         f(self, len)\n     }\n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F)\n-                              -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F)\n-                              -> Result<T, Self::Error>\n-        where F: FnOnce(&mut Self) -> Result<T, Self::Error> { f(self) }\n+\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n+\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<T, Self::Error>\n+    {\n+        f(self)\n+    }\n \n     // Failure\n     fn error(&mut self, err: &str) -> Self::Error;\n@@ -567,9 +607,7 @@ impl<T:Decodable> Decodable for Vec<T> {\n     }\n }\n \n-impl<'a, T:Encodable> Encodable for Cow<'a, [T]>\n-where [T]: ToOwned<Owned = Vec<T>>\n-{\n+impl<'a, T:Encodable> Encodable for Cow<'a, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n@@ -580,9 +618,7 @@ where [T]: ToOwned<Owned = Vec<T>>\n     }\n }\n \n-impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]>\n-where [T]: ToOwned<Owned = Vec<T>>\n-{\n+impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]> where [T]: ToOwned<Owned = Vec<T>> {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n@@ -685,8 +721,7 @@ macro_rules! tuple {\n                 let len: usize = count_idents!($($name,)*);\n                 d.read_tuple(len, |d| {\n                     let mut i = 0;\n-                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 },\n-                                                  |d| -> Result<$name,D::Error> {\n+                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name, D::Error> {\n                         Decodable::decode(d)\n                     })?,)*);\n                     Ok(ret)\n@@ -778,13 +813,11 @@ pub trait SpecializationError {\n     /// `T` is the type being encoded/decoded, and\n     /// the arguments are the names of the trait\n     /// and method that should've been overridden.\n-    fn not_found<S, T: ?Sized>(trait_name: &'static str,\n-                               method_name: &'static str) -> Self;\n+    fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> Self;\n }\n \n impl<E> SpecializationError for E {\n-    default fn not_found<S, T: ?Sized>(trait_name: &'static str,\n-                                       method_name: &'static str) -> E {\n+    default fn not_found<S, T: ?Sized>(trait_name: &'static str, method_name: &'static str) -> E {\n         panic!(\"missing specialization: `<{} as {}<{}>>::{}` not overridden\",\n                unsafe { intrinsics::type_name::<S>() },\n                trait_name,"}, {"sha": "5348c9a0f349842e057985b7fdfce779d3714082", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -22,7 +22,6 @@ core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n-std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }\n \n [dev-dependencies]"}, {"sha": "0c8e95aa4262409b48a57f4834528781d36fb48f", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 0, "deletions": 310, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -154,180 +154,6 @@ pub trait AsciiExt {\n     /// [`to_ascii_lowercase`]: #tymethod.to_ascii_lowercase\n     #[stable(feature = \"ascii\", since = \"1.9.0\")]\n     fn make_ascii_lowercase(&mut self);\n-\n-    /// Checks if the value is an ASCII alphabetic character:\n-    /// U+0041 'A' ... U+005A 'Z' or U+0061 'a' ... U+007A 'z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII alphabetic.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_alphabetic)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_alphabetic)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_alphabetic(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII uppercase character:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII uppercase.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_uppercase)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_uppercase)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_uppercase(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII lowercase character:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII lowercase.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_lowercase)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_lowercase)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_lowercase(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII alphanumeric character:\n-    /// U+0041 'A' ... U+005A 'Z', U+0061 'a' ... U+007A 'z', or\n-    /// U+0030 '0' ... U+0039 '9'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII alphanumeric.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_alphanumeric)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_alphanumeric)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_alphanumeric(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII digits.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_digit)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_digit)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_digit(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII hexadecimal digit:\n-    /// U+0030 '0' ... U+0039 '9', U+0041 'A' ... U+0046 'F', or\n-    /// U+0061 'a' ... U+0066 'f'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII hex digits.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_hexdigit)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_hexdigit)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_hexdigit(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII punctuation character:\n-    ///\n-    /// U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`\n-    /// U+003A ... U+0040 `: ; < = > ? @`\n-    /// U+005B ... U+0060 ``[ \\\\ ] ^ _ ` ``\n-    /// U+007B ... U+007E `{ | } ~`\n-    ///\n-    /// For strings, true if all characters in the string are\n-    /// ASCII punctuation.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_punctuation)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_punctuation)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_punctuation(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII graphic character:\n-    /// U+0021 '!' ... U+007E '~'.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII graphic characters.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_graphic)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_graphic)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_graphic(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII whitespace character:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    /// For strings, true if all characters in the string are\n-    /// ASCII whitespace.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw].  There are several other definitions in\n-    /// wide use.  For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_whitespace)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_whitespace)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_whitespace(&self) -> bool { unimplemented!(); }\n-\n-    /// Checks if the value is an ASCII control character:\n-    /// U+0000 NUL ... U+001F UNIT SEPARATOR, or U+007F DELETE.\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    ///\n-    /// # Note\n-    ///\n-    /// This method will be deprecated in favor of the identically-named\n-    /// inherent methods on `u8` and `char`.\n-    /// For `[u8]` use `.iter().all(u8::is_ascii_control)`.\n-    /// For `str` use `.bytes().all(u8::is_ascii_control)`.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use inherent methods instead\")]\n-    fn is_ascii_control(&self) -> bool { unimplemented!(); }\n }\n \n macro_rules! delegating_ascii_methods {\n@@ -352,47 +178,12 @@ macro_rules! delegating_ascii_methods {\n     }\n }\n \n-macro_rules! delegating_ascii_ctype_methods {\n-    () => {\n-        #[inline]\n-        fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n-\n-        #[inline]\n-        fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n-\n-        #[inline]\n-        fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n-\n-        #[inline]\n-        fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n-\n-        #[inline]\n-        fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n-\n-        #[inline]\n-        fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n-\n-        #[inline]\n-        fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n-\n-        #[inline]\n-        fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n-\n-        #[inline]\n-        fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n-\n-        #[inline]\n-        fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n impl AsciiExt for u8 {\n     type Owned = u8;\n \n     delegating_ascii_methods!();\n-    delegating_ascii_ctype_methods!();\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -401,7 +192,6 @@ impl AsciiExt for char {\n     type Owned = char;\n \n     delegating_ascii_methods!();\n-    delegating_ascii_ctype_methods!();\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -410,56 +200,6 @@ impl AsciiExt for [u8] {\n     type Owned = Vec<u8>;\n \n     delegating_ascii_methods!();\n-\n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_digit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_control())\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -468,54 +208,4 @@ impl AsciiExt for str {\n     type Owned = String;\n \n     delegating_ascii_methods!();\n-\n-    #[inline]\n-    fn is_ascii_alphabetic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_uppercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_lowercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_alphanumeric(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_digit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_digit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_hexdigit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_punctuation(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_graphic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_whitespace(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    #[inline]\n-    fn is_ascii_control(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_control())\n-    }\n }"}, {"sha": "b2777f5c48541f13171259a711e7885a159da6b4", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -642,6 +642,12 @@ impl fmt::Debug for CString {\n \n #[stable(feature = \"cstring_into\", since = \"1.7.0\")]\n impl From<CString> for Vec<u8> {\n+    /// Converts a [`CString`] into a [`Vec`]`<u8>`.\n+    ///\n+    /// The conversion consumes the [`CString`], and removes the terminating NUL byte.\n+    ///\n+    /// [`Vec`]: ../vec/struct.Vec.html\n+    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: CString) -> Vec<u8> {\n         s.into_bytes()\n@@ -700,6 +706,10 @@ impl<'a> From<&'a CStr> for Box<CStr> {\n \n #[stable(feature = \"c_string_from_box\", since = \"1.18.0\")]\n impl From<Box<CStr>> for CString {\n+    /// Converts a [`Box`]`<CStr>` into a [`CString`] without copying or allocating.\n+    ///\n+    /// [`Box`]: ../boxed/struct.Box.html\n+    /// [`CString`]: ../ffi/struct.CString.html\n     #[inline]\n     fn from(s: Box<CStr>) -> CString {\n         s.into_c_string()\n@@ -716,6 +726,10 @@ impl Clone for Box<CStr> {\n \n #[stable(feature = \"box_from_c_string\", since = \"1.20.0\")]\n impl From<CString> for Box<CStr> {\n+    /// Converts a [`CString`] into a [`Box`]`<CStr>` without copying or allocating.\n+    ///\n+    /// [`CString`]: ../ffi/struct.CString.html\n+    /// [`Box`]: ../boxed/struct.Box.html\n     #[inline]\n     fn from(s: CString) -> Box<CStr> {\n         s.into_boxed_c_str()\n@@ -748,6 +762,10 @@ impl<'a> From<&'a CString> for Cow<'a, CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Arc<CStr> {\n+    /// Converts a [`CString`] into a [`Arc`]`<CStr>` without copying or allocating.\n+    ///\n+    /// [`CString`]: ../ffi/struct.CString.html\n+    /// [`Arc`]: ../sync/struct.Arc.html\n     #[inline]\n     fn from(s: CString) -> Arc<CStr> {\n         let arc: Arc<[u8]> = Arc::from(s.into_inner());\n@@ -766,6 +784,10 @@ impl<'a> From<&'a CStr> for Arc<CStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<CString> for Rc<CStr> {\n+    /// Converts a [`CString`] into a [`Rc`]`<CStr>` without copying or allocating.\n+    ///\n+    /// [`CString`]: ../ffi/struct.CString.html\n+    /// [`Rc`]: ../rc/struct.Rc.html\n     #[inline]\n     fn from(s: CString) -> Rc<CStr> {\n         let rc: Rc<[u8]> = Rc::from(s.into_inner());\n@@ -839,6 +861,10 @@ impl fmt::Display for NulError {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<NulError> for io::Error {\n+    /// Converts a [`NulError`] into a [`io::Error`].\n+    ///\n+    /// [`NulError`]: ../ffi/struct.NulError.html\n+    /// [`io::Error`]: ../io/struct.Error.html\n     fn from(_: NulError) -> io::Error {\n         io::Error::new(io::ErrorKind::InvalidInput,\n                        \"data provided contains a nul byte\")"}, {"sha": "9e501a84e05ec6e9176a5904c31f4674dfb746e0", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -348,6 +348,12 @@ impl OsString {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl From<String> for OsString {\n+    /// Converts a [`String`] into a [`OsString`].\n+    ///\n+    /// The conversion copies the data, and includes an allocation on the heap.\n+    ///\n+    /// [`String`]: ../string/struct.String.html\n+    /// [`OsString`]: struct.OsString.html\n     fn from(s: String) -> OsString {\n         OsString { inner: Buf::from_string(s) }\n     }\n@@ -630,13 +636,21 @@ impl<'a> From<&'a OsStr> for Box<OsStr> {\n \n #[stable(feature = \"os_string_from_box\", since = \"1.18.0\")]\n impl From<Box<OsStr>> for OsString {\n+    /// Converts a `Box<OsStr>` into a `OsString` without copying or allocating.\n+    ///\n+    /// [`Box`]: ../boxed/struct.Box.html\n+    /// [`OsString`]: ../ffi/struct.OsString.html\n     fn from(boxed: Box<OsStr>) -> OsString {\n         boxed.into_os_string()\n     }\n }\n \n #[stable(feature = \"box_from_os_string\", since = \"1.20.0\")]\n impl From<OsString> for Box<OsStr> {\n+    /// Converts a [`OsString`] into a [`Box`]`<OsStr>` without copying or allocating.\n+    ///\n+    /// [`Box`]: ../boxed/struct.Box.html\n+    /// [`OsString`]: ../ffi/struct.OsString.html\n     fn from(s: OsString) -> Box<OsStr> {\n         s.into_boxed_os_str()\n     }\n@@ -652,6 +666,10 @@ impl Clone for Box<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Arc<OsStr> {\n+    /// Converts a [`OsString`] into a [`Arc`]`<OsStr>` without copying or allocating.\n+    ///\n+    /// [`Arc`]: ../sync/struct.Arc.html\n+    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Arc<OsStr> {\n         let arc = s.inner.into_arc();\n@@ -670,6 +688,10 @@ impl<'a> From<&'a OsStr> for Arc<OsStr> {\n \n #[stable(feature = \"shared_from_slice2\", since = \"1.24.0\")]\n impl From<OsString> for Rc<OsStr> {\n+    /// Converts a [`OsString`] into a [`Rc`]`<OsStr>` without copying or allocating.\n+    ///\n+    /// [`Rc`]: ../rc/struct.Rc.html\n+    /// [`OsString`]: ../ffi/struct.OsString.html\n     #[inline]\n     fn from(s: OsString) -> Rc<OsStr> {\n         let rc = s.inner.into_rc();"}, {"sha": "03c97de6ec1e9b8418c9da79ded78dca8777d2d0", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -154,33 +154,6 @@ impl<R: Read> BufReader<R> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut R { &mut self.inner }\n \n-    /// Returns `true` if there are no bytes in the internal buffer.\n-    ///\n-    /// # Examples\n-    //\n-    /// ```no_run\n-    /// # #![feature(bufreader_is_empty)]\n-    /// use std::io::BufReader;\n-    /// use std::io::BufRead;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let f1 = File::open(\"log.txt\")?;\n-    ///     let mut reader = BufReader::new(f1);\n-    ///     assert!(reader.is_empty());\n-    ///\n-    ///     if reader.fill_buf()?.len() > 0 {\n-    ///         assert!(!reader.is_empty());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"bufreader_is_empty\", issue = \"45323\", reason = \"recently added\")]\n-    #[rustc_deprecated(since = \"1.26.0\", reason = \"use .buffer().is_empty() instead\")]\n-    pub fn is_empty(&self) -> bool {\n-        self.buffer().is_empty()\n-    }\n-\n     /// Returns a reference to the internally buffered data.\n     ///\n     /// Unlike `fill_buf`, this will not attempt to fill the buffer if it is empty.\n@@ -1265,25 +1238,6 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn read_char_buffered() {\n-        let buf = [195, 159];\n-        let reader = BufReader::with_capacity(1, &buf[..]);\n-        assert_eq!(reader.chars().next().unwrap().unwrap(), '\u00df');\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_chars() {\n-        let buf = [195, 159, b'a'];\n-        let reader = BufReader::with_capacity(1, &buf[..]);\n-        let mut it = reader.chars();\n-        assert_eq!(it.next().unwrap().unwrap(), '\u00df');\n-        assert_eq!(it.next().unwrap().unwrap(), 'a');\n-        assert!(it.next().is_none());\n-    }\n-\n     #[test]\n     #[should_panic]\n     fn dont_panic_in_drop_on_panicked_flush() {"}, {"sha": "14f20151dca861c9ef6e3518392fdac9b4e49ce1", "filename": "src/libstd/io/cursor.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcursor.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -550,26 +550,6 @@ mod tests {\n         assert_eq!(reader.read(&mut buf).unwrap(), 0);\n     }\n \n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_read_char() {\n-        let b = &b\"Vi\\xE1\\xBB\\x87t\"[..];\n-        let mut c = Cursor::new(b).chars();\n-        assert_eq!(c.next().unwrap().unwrap(), 'V');\n-        assert_eq!(c.next().unwrap().unwrap(), 'i');\n-        assert_eq!(c.next().unwrap().unwrap(), '\u1ec7');\n-        assert_eq!(c.next().unwrap().unwrap(), 't');\n-        assert!(c.next().is_none());\n-    }\n-\n-    #[test]\n-    #[allow(deprecated)]\n-    fn test_read_bad_char() {\n-        let b = &b\"\\x80\"[..];\n-        let mut c = Cursor::new(b).chars();\n-        assert!(c.next().unwrap().is_err());\n-    }\n-\n     #[test]\n     fn seek_past_end() {\n         let buf = [0xff];"}, {"sha": "5e89ad45f81d24031ec06999eb8b2acfd101e84f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 0, "deletions": 148, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -270,10 +270,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use cmp;\n-use core::str as core_str;\n-use error as std_error;\n use fmt;\n-use result;\n use str;\n use memchr;\n use ptr;\n@@ -800,53 +797,6 @@ pub trait Read {\n         Bytes { inner: self }\n     }\n \n-    /// Transforms this `Read` instance to an [`Iterator`] over [`char`]s.\n-    ///\n-    /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n-    /// sequence of characters. The returned iterator will return [`None`] once\n-    /// EOF is reached for this reader. Otherwise each element yielded will be a\n-    /// [`Result`]`<`[`char`]`, E>` where `E` may contain information about what I/O error\n-    /// occurred or where decoding failed.\n-    ///\n-    /// Currently this adaptor will discard intermediate data read, and should\n-    /// be avoided if this is not desired.\n-    ///\n-    /// # Examples\n-    ///\n-    /// [`File`]s implement `Read`:\n-    ///\n-    /// [`File`]: ../fs/struct.File.html\n-    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n-    /// [`Result`]: ../../std/result/enum.Result.html\n-    /// [`char`]: ../../std/primitive.char.html\n-    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n-    ///\n-    /// ```no_run\n-    /// #![feature(io)]\n-    /// use std::io;\n-    /// use std::io::prelude::*;\n-    /// use std::fs::File;\n-    ///\n-    /// fn main() -> io::Result<()> {\n-    ///     let mut f = File::open(\"foo.txt\")?;\n-    ///\n-    ///     for c in f.chars() {\n-    ///         println!(\"{}\", c.unwrap());\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n-                                         of where errors happen is currently \\\n-                                         unclear and may change\",\n-               issue = \"27802\")]\n-    #[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-        https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-    #[allow(deprecated)]\n-    fn chars(self) -> Chars<Self> where Self: Sized {\n-        Chars { inner: self }\n-    }\n-\n     /// Creates an adaptor which will chain this stream with another.\n     ///\n     /// The returned `Read` instance will first read all bytes from this object\n@@ -2005,104 +1955,6 @@ impl<R: Read> Iterator for Bytes<R> {\n     }\n }\n \n-/// An iterator over the `char`s of a reader.\n-///\n-/// This struct is generally created by calling [`chars`][chars] on a reader.\n-/// Please see the documentation of `chars()` for more details.\n-///\n-/// [chars]: trait.Read.html#method.chars\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Debug)]\n-#[allow(deprecated)]\n-pub struct Chars<R> {\n-    inner: R,\n-}\n-\n-/// An enumeration of possible errors that can be generated from the `Chars`\n-/// adapter.\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[rustc_deprecated(since = \"1.27.0\", reason = \"Use str::from_utf8 instead:\n-    https://doc.rust-lang.org/nightly/std/str/struct.Utf8Error.html#examples\")]\n-#[derive(Debug)]\n-#[allow(deprecated)]\n-pub enum CharsError {\n-    /// Variant representing that the underlying stream was read successfully\n-    /// but it did not contain valid utf8 data.\n-    NotUtf8,\n-\n-    /// Variant representing that an I/O error occurred.\n-    Other(Error),\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl<R: Read> Iterator for Chars<R> {\n-    type Item = result::Result<char, CharsError>;\n-\n-    fn next(&mut self) -> Option<result::Result<char, CharsError>> {\n-        let first_byte = match read_one_byte(&mut self.inner)? {\n-            Ok(b) => b,\n-            Err(e) => return Some(Err(CharsError::Other(e))),\n-        };\n-        let width = core_str::utf8_char_width(first_byte);\n-        if width == 1 { return Some(Ok(first_byte as char)) }\n-        if width == 0 { return Some(Err(CharsError::NotUtf8)) }\n-        let mut buf = [first_byte, 0, 0, 0];\n-        {\n-            let mut start = 1;\n-            while start < width {\n-                match self.inner.read(&mut buf[start..width]) {\n-                    Ok(0) => return Some(Err(CharsError::NotUtf8)),\n-                    Ok(n) => start += n,\n-                    Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,\n-                    Err(e) => return Some(Err(CharsError::Other(e))),\n-                }\n-            }\n-        }\n-        Some(match str::from_utf8(&buf[..width]).ok() {\n-            Some(s) => Ok(s.chars().next().unwrap()),\n-            None => Err(CharsError::NotUtf8),\n-        })\n-    }\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl std_error::Error for CharsError {\n-    fn description(&self) -> &str {\n-        match *self {\n-            CharsError::NotUtf8 => \"invalid utf8 encoding\",\n-            CharsError::Other(ref e) => std_error::Error::description(e),\n-        }\n-    }\n-    fn cause(&self) -> Option<&dyn std_error::Error> {\n-        match *self {\n-            CharsError::NotUtf8 => None,\n-            CharsError::Other(ref e) => e.cause(),\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"io\", reason = \"awaiting stability of Read::chars\",\n-           issue = \"27802\")]\n-#[allow(deprecated)]\n-impl fmt::Display for CharsError {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            CharsError::NotUtf8 => {\n-                \"byte stream did not contain valid utf8\".fmt(f)\n-            }\n-            CharsError::Other(ref e) => e.fmt(f),\n-        }\n-    }\n-}\n-\n /// An iterator over the contents of an instance of `BufRead` split on a\n /// particular byte.\n ///"}, {"sha": "d2e751668a67b1bf6f4f27dda2b516f84bde687b", "filename": "src/libstd/os/hermit/fs.rs", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Ffs.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,389 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+\n+use libc;\n+\n+use fs::Metadata;\n+use sys_common::AsInner;\n+\n+#[allow(deprecated)]\n+use os::hermit::raw;\n+\n+/// OS-specific extensions to [`fs::Metadata`].\n+///\n+/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+pub trait MetadataExt {\n+    /// Gain a reference to the underlying `stat` structure which contains\n+    /// the raw information returned by the OS.\n+    ///\n+    /// The contents of the returned [`stat`] are **not** consistent across\n+    /// Unix platforms. The `os::unix::fs::MetadataExt` trait contains the\n+    /// cross-Unix abstractions contained within the raw stat.\n+    ///\n+    /// [`stat`]: ../../../../std/os/linux/raw/struct.stat.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     let stat = meta.as_raw_stat();\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+    #[rustc_deprecated(since = \"1.8.0\",\n+                       reason = \"deprecated in favor of the accessor \\\n+                                 methods of this trait\")]\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat;\n+\n+    /// Returns the device ID on which this file resides.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_dev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_dev(&self) -> u64;\n+    /// Returns the inode number.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ino());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ino(&self) -> u64;\n+    /// Returns the file type and mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mode());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mode(&self) -> u32;\n+    /// Returns the number of hard links to file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_nlink());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_nlink(&self) -> u64;\n+    /// Returns the user ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_uid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_uid(&self) -> u32;\n+    /// Returns the group ID of the file owner.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_gid());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_gid(&self) -> u32;\n+    /// Returns the device ID that this file represents. Only relevant for special file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_rdev());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_rdev(&self) -> u64;\n+    /// Returns the size of the file (if it is a regular file or a symbolic link) in bytes.\n+    ///\n+    /// The size of a symbolic link is the length of the pathname it contains,\n+    /// without a terminating null byte.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_size());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_size(&self) -> u64;\n+    /// Returns the last access time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime(&self) -> i64;\n+    /// Returns the last access time, nano seconds part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_atime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_atime_nsec(&self) -> i64;\n+    /// Returns the last modification time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime(&self) -> i64;\n+    /// Returns the last modification time, nano seconds part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_mtime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_mtime_nsec(&self) -> i64;\n+    /// Returns the last status change time.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime(&self) -> i64;\n+    /// Returns the last status change time, nano seconds part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_ctime_nsec());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_ctime_nsec(&self) -> i64;\n+    /// Returns the \"preferred\" blocksize for efficient filesystem I/O.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blksize());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blksize(&self) -> u64;\n+    /// Returns the number of blocks allocated to the file, 512-byte units.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs;\n+    /// use std::io;\n+    /// use std::os::linux::fs::MetadataExt;\n+    ///\n+    /// fn main() -> io::Result<()> {\n+    ///     let meta = fs::metadata(\"some_file\")?;\n+    ///     println!(\"{}\", meta.st_blocks());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"metadata_ext2\", since = \"1.8.0\")]\n+    fn st_blocks(&self) -> u64;\n+}\n+\n+#[stable(feature = \"metadata_ext\", since = \"1.1.0\")]\n+impl MetadataExt for Metadata {\n+    #[allow(deprecated)]\n+    fn as_raw_stat(&self) -> &raw::stat {\n+        unsafe {\n+            &*(self.as_inner().as_inner() as *const libc::stat64\n+                                          as *const raw::stat)\n+        }\n+    }\n+    fn st_dev(&self) -> u64 {\n+        self.as_inner().as_inner().st_dev as u64\n+    }\n+    fn st_ino(&self) -> u64 {\n+        self.as_inner().as_inner().st_ino as u64\n+    }\n+    fn st_mode(&self) -> u32 {\n+        self.as_inner().as_inner().st_mode as u32\n+    }\n+    fn st_nlink(&self) -> u64 {\n+        self.as_inner().as_inner().st_nlink as u64\n+    }\n+    fn st_uid(&self) -> u32 {\n+        self.as_inner().as_inner().st_uid as u32\n+    }\n+    fn st_gid(&self) -> u32 {\n+        self.as_inner().as_inner().st_gid as u32\n+    }\n+    fn st_rdev(&self) -> u64 {\n+        self.as_inner().as_inner().st_rdev as u64\n+    }\n+    fn st_size(&self) -> u64 {\n+        self.as_inner().as_inner().st_size as u64\n+    }\n+    fn st_atime(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime as i64\n+    }\n+    fn st_atime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_atime_nsec as i64\n+    }\n+    fn st_mtime(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime as i64\n+    }\n+    fn st_mtime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_mtime_nsec as i64\n+    }\n+    fn st_ctime(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime as i64\n+    }\n+    fn st_ctime_nsec(&self) -> i64 {\n+        self.as_inner().as_inner().st_ctime_nsec as i64\n+    }\n+    fn st_blksize(&self) -> u64 {\n+        self.as_inner().as_inner().st_blksize as u64\n+    }\n+    fn st_blocks(&self) -> u64 {\n+        self.as_inner().as_inner().st_blocks as u64\n+    }\n+}"}, {"sha": "fcb22cdad641f1bbd3f6fc8cf43755ab088d00ad", "filename": "src/libstd/os/hermit/mod.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! HermitCore-specific definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+\n+pub mod raw;\n+pub mod fs;"}, {"sha": "282afe0b6e1c028d401511242cbea6aa31251c8b", "filename": "src/libstd/os/hermit/raw.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fhermit%2Fraw.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! HermitCore-specific raw type definitions\n+\n+#![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(since = \"1.8.0\",\n+                    reason = \"these type aliases are no longer supported by \\\n+                              the standard library, the `libc` crate on \\\n+                              crates.io should be used instead for the correct \\\n+                              definitions\")]\n+#![allow(deprecated)]\n+#![allow(missing_debug_implementations)]\n+\n+#[stable(feature = \"pthread_t\", since = \"1.8.0\")]\n+pub use libc::pthread_t;\n+\n+#[doc(inline)]\n+#[stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+pub use libc::{dev_t, mode_t, off_t, ino_t, nlink_t, blksize_t, blkcnt_t, stat, time_t};"}, {"sha": "c384ec9168ac4428889fd2ea5df4760f3f1ddd65", "filename": "src/libstd/os/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fos%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -47,6 +47,7 @@ cfg_if! {\n         #[cfg(target_os = \"solaris\")]    pub mod solaris;\n         #[cfg(target_os = \"emscripten\")] pub mod emscripten;\n         #[cfg(target_os = \"fuchsia\")]    pub mod fuchsia;\n+        #[cfg(target_os = \"hermit\")]     pub mod hermit;\n \n         #[cfg(any(target_os = \"redox\", unix))]\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "7e32ec1347e9e7be99f48221c64a793d4e2f72ee", "filename": "src/libstd/sys/unix/args.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fargs.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -66,7 +66,8 @@ impl DoubleEndedIterator for Args {\n           target_os = \"emscripten\",\n           target_os = \"haiku\",\n           target_os = \"l4re\",\n-          target_os = \"fuchsia\"))]\n+          target_os = \"fuchsia\",\n+          target_os = \"hermit\"))]\n mod imp {\n     use os::unix::prelude::*;\n     use ptr;"}, {"sha": "2007da7b1f6bec59b502a35fcf4cd2b80c9fbdf2", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -41,13 +41,15 @@ impl Condvar {\n     #[cfg(any(target_os = \"macos\",\n               target_os = \"ios\",\n               target_os = \"l4re\",\n-              target_os = \"android\"))]\n+              target_os = \"android\",\n+              target_os = \"hermit\"))]\n     pub unsafe fn init(&mut self) {}\n \n     #[cfg(not(any(target_os = \"macos\",\n                   target_os = \"ios\",\n                   target_os = \"l4re\",\n-                  target_os = \"android\")))]\n+                  target_os = \"android\",\n+                  target_os = \"hermit\")))]\n     pub unsafe fn init(&mut self) {\n         use mem;\n         let mut attr: libc::pthread_condattr_t = mem::uninitialized();\n@@ -83,7 +85,10 @@ impl Condvar {\n     // where we configure condition variable to use monotonic clock (instead of\n     // default system clock). This approach avoids all problems that result\n     // from changes made to the system time.\n-    #[cfg(not(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\")))]\n+    #[cfg(not(any(target_os = \"macos\",\n+                  target_os = \"ios\",\n+                  target_os = \"android\",\n+                  target_os = \"hermit\")))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         use mem;\n \n@@ -113,7 +118,7 @@ impl Condvar {\n     // This implementation is modeled after libcxx's condition_variable\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n-    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\"))]\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"android\", target_os = \"hermit\"))]\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, mut dur: Duration) -> bool {\n         use ptr;\n         use time::Instant;"}, {"sha": "ad116c57f557e1c73fe8ae440073d2641d671fa7", "filename": "src/libstd/sys/unix/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fenv.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -172,3 +172,14 @@ pub mod os {\n     pub const EXE_SUFFIX: &'static str = \"\";\n     pub const EXE_EXTENSION: &'static str = \"\";\n }\n+\n+#[cfg(target_os = \"hermit\")]\n+pub mod os {\n+    pub const FAMILY: &'static str = \"unix\";\n+    pub const OS: &'static str = \"hermit\";\n+    pub const DLL_PREFIX: &'static str = \"lib\";\n+    pub const DLL_SUFFIX: &'static str = \".so\";\n+    pub const DLL_EXTENSION: &'static str = \"so\";\n+    pub const EXE_SUFFIX: &'static str = \"\";\n+    pub const EXE_EXTENSION: &'static str = \"\";\n+}"}, {"sha": "c13a0fea1e05c8f09b1aa29956f28d7d1dcc5b61", "filename": "src/libstd/sys/unix/fast_thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffast_thread_local.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -20,7 +20,7 @@\n // fallback implementation to use as well.\n //\n // Due to rust-lang/rust#18804, make sure this is not generic!\n-#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\"))]\n+#[cfg(any(target_os = \"linux\", target_os = \"fuchsia\", target_os = \"hermit\"))]\n pub unsafe fn register_dtor(t: *mut u8, dtor: unsafe extern fn(*mut u8)) {\n     use libc;\n     use mem;"}, {"sha": "7a89d9857bbcf341c95c3a8955b82933e6c26560", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -325,12 +325,12 @@ impl DirEntry {\n         lstat(&self.path())\n     }\n \n-    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\"))]\n+    #[cfg(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\"))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         lstat(&self.path()).map(|m| m.file_type())\n     }\n \n-    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\")))]\n+    #[cfg(not(any(target_os = \"solaris\", target_os = \"haiku\", target_os = \"hermit\")))]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         match self.entry.d_type {\n             libc::DT_CHR => Ok(FileType { mode: libc::S_IFCHR }),\n@@ -352,7 +352,8 @@ impl DirEntry {\n               target_os = \"solaris\",\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n-              target_os = \"fuchsia\"))]\n+              target_os = \"fuchsia\",\n+              target_os = \"hermit\"))]\n     pub fn ino(&self) -> u64 {\n         self.entry.d_ino as u64\n     }\n@@ -383,7 +384,8 @@ impl DirEntry {\n               target_os = \"linux\",\n               target_os = \"emscripten\",\n               target_os = \"l4re\",\n-              target_os = \"haiku\"))]\n+              target_os = \"haiku\",\n+              target_os = \"hermit\"))]\n     fn name_bytes(&self) -> &[u8] {\n         unsafe {\n             CStr::from_ptr(self.entry.d_name.as_ptr()).to_bytes()"}, {"sha": "c738003caf1d9b220a980c1006b79f7ce6eeeb5d", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -28,6 +28,7 @@ use libc;\n #[cfg(all(not(dox), target_os = \"emscripten\"))] pub use os::emscripten as platform;\n #[cfg(all(not(dox), target_os = \"fuchsia\"))]   pub use os::fuchsia as platform;\n #[cfg(all(not(dox), target_os = \"l4re\"))]      pub use os::linux as platform;\n+#[cfg(all(not(dox), target_os = \"hermit\"))]    pub use os::hermit as platform;\n \n pub use self::rand::hashmap_random_keys;\n pub use libc::strlen;"}, {"sha": "1d92e8fc97c7aa5690389bc17a75f5f942f75ebb", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -47,6 +47,7 @@ extern {\n                    target_os = \"netbsd\",\n                    target_os = \"openbsd\",\n                    target_os = \"android\",\n+                   target_os = \"hermit\",\n                    target_env = \"newlib\"),\n                link_name = \"__errno\")]\n     #[cfg_attr(target_os = \"solaris\", link_name = \"___errno\")]\n@@ -376,7 +377,7 @@ pub fn current_exe() -> io::Result<PathBuf> {\n     }\n }\n \n-#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\"))]\n+#[cfg(any(target_os = \"fuchsia\", target_os = \"l4re\", target_os = \"hermit\"))]\n pub fn current_exe() -> io::Result<PathBuf> {\n     use io::ErrorKind;\n     Err(io::Error::new(ErrorKind::Other, \"Not yet implemented!\"))"}, {"sha": "f3a45d24657399dd33cdd564bc1b09c95f0c1dfc", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -138,7 +138,8 @@ impl Thread {\n               target_os = \"solaris\",\n               target_os = \"haiku\",\n               target_os = \"l4re\",\n-              target_os = \"emscripten\"))]\n+              target_os = \"emscripten\",\n+              target_os = \"hermit\"))]\n     pub fn set_name(_name: &CStr) {\n         // Newlib, Illumos, Haiku, and Emscripten have no way to set a thread name.\n     }"}, {"sha": "0b1fb726357e1056d8685ce50e338843d842c5a8", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -345,9 +345,9 @@ mod inner {\n         }\n     }\n \n-    #[cfg(not(target_os = \"dragonfly\"))]\n+    #[cfg(not(any(target_os = \"dragonfly\", target_os = \"hermit\")))]\n     pub type clock_t = libc::c_int;\n-    #[cfg(target_os = \"dragonfly\")]\n+    #[cfg(any(target_os = \"dragonfly\", target_os = \"hermit\"))]\n     pub type clock_t = libc::c_ulong;\n \n     fn now(clock: clock_t) -> Timespec {"}, {"sha": "bbe80df7e8bdbc54cfc7d132af0d485304440d90", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -731,7 +731,8 @@ const NOTIFIED: usize = 2;\n ///   specifying a maximum time to block the thread for.\n ///\n /// * The [`unpark`] method on a [`Thread`] atomically makes the token available\n-///   if it wasn't already.\n+///   if it wasn't already. Because the token is initially absent, [`unpark`]\n+///   followed by [`park`] will result in the second call returning immediately.\n ///\n /// In other words, each [`Thread`] acts a bit like a spinlock that can be\n /// locked and unlocked using `park` and `unpark`.\n@@ -766,6 +767,8 @@ const NOTIFIED: usize = 2;\n /// // Let some time pass for the thread to be spawned.\n /// thread::sleep(Duration::from_millis(10));\n ///\n+/// // There is no race condition here, if `unpark`\n+/// // happens first, `park` will return immediately.\n /// println!(\"Unpark the thread\");\n /// parked_thread.thread().unpark();\n ///"}, {"sha": "b1c55c2e4b6ced7aa3520322031f1e36cba8b4f3", "filename": "src/libstd_unicode/Cargo.toml", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c63bb1d6a7e7ede79ddc5ddf41087668266824ea/src%2Flibstd_unicode%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/c63bb1d6a7e7ede79ddc5ddf41087668266824ea/src%2Flibstd_unicode%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2FCargo.toml?ref=c63bb1d6a7e7ede79ddc5ddf41087668266824ea", "patch": "@@ -1,14 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-name = \"std_unicode\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"std_unicode\"\n-path = \"lib.rs\"\n-test = false\n-bench = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }\n-compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }"}, {"sha": "c0d47f1fcb42bbc680d352a1ae86b7f23d34f14d", "filename": "src/libstd_unicode/lib.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c63bb1d6a7e7ede79ddc5ddf41087668266824ea/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c63bb1d6a7e7ede79ddc5ddf41087668266824ea/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=c63bb1d6a7e7ede79ddc5ddf41087668266824ea", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! # The Unicode Library\n-//!\n-//! Unicode-intensive functions for `char` and `str` types.\n-//!\n-//! This crate provides a collection of Unicode-related functionality,\n-//! including decompositions, conversions, etc., and provides traits\n-//! implementing these functions for the `char` and `str` types.\n-//!\n-//! The functionality included here is only that which is necessary to\n-//! provide for basic string-related manipulations. This crate does not\n-//! (yet) aim to provide a full set of Unicode tables.\n-\n-#![unstable(feature = \"unicode\", issue = \"27783\")]\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n-       test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n-#![no_std]\n-\n-#![feature(unicode_internals)]\n-#![feature(staged_api)]\n-#![rustc_deprecated(since = \"1.27.0\", reason = \"moved into libcore\")]\n-\n-pub use core::unicode::*;"}, {"sha": "37a021a95291437578f3bb80b33d8b69fba20297", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -396,7 +396,7 @@ declare_features! (\n     // Infer outlives requirements; RFC 2093\n     (active, infer_outlives_requirements, \"1.26.0\", Some(44493), None),\n \n-    // Infer outlives requirements; RFC 2093\n+    // Infer static outlives requirements; RFC 2093\n     (active, infer_static_outlives_requirements, \"1.26.0\", Some(44493), None),\n \n     // Multiple patterns with `|` in `if let` and `while let`"}, {"sha": "6eba3c4f2bbc9c96e64daf43f1e68516dad911cd", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -774,31 +774,41 @@ pub mod shell {\n \n     #[derive(Clone, PartialEq, Debug)]\n     pub enum Substitution<'a> {\n-        Ordinal(u8),\n-        Name(&'a str),\n-        Escape,\n+        Ordinal(u8, (usize, usize)),\n+        Name(&'a str, (usize, usize)),\n+        Escape((usize, usize)),\n     }\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> String {\n-            match *self {\n-                Substitution::Ordinal(n) => format!(\"${}\", n),\n-                Substitution::Name(n) => format!(\"${}\", n),\n-                Substitution::Escape => \"$$\".into(),\n+            match self {\n+                Substitution::Ordinal(n, _) => format!(\"${}\", n),\n+                Substitution::Name(n, _) => format!(\"${}\", n),\n+                Substitution::Escape(_) => \"$$\".into(),\n             }\n         }\n \n         pub fn position(&self) -> Option<(usize, usize)> {\n-            match *self {\n-                _ => None,\n+            match self {\n+                Substitution::Ordinal(_, pos) |\n+                Substitution::Name(_, pos) |\n+                Substitution::Escape(pos) => Some(*pos),\n+            }\n+        }\n+\n+        pub fn set_position(&mut self, start: usize, end: usize) {\n+            match self {\n+                Substitution::Ordinal(_, ref mut pos) |\n+                Substitution::Name(_, ref mut pos) |\n+                Substitution::Escape(ref mut pos) => *pos = (start, end),\n             }\n         }\n \n         pub fn translate(&self) -> Option<String> {\n             match *self {\n-                Substitution::Ordinal(n) => Some(format!(\"{{{}}}\", n)),\n-                Substitution::Name(n) => Some(format!(\"{{{}}}\", n)),\n-                Substitution::Escape => None,\n+                Substitution::Ordinal(n, _) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Name(n, _) => Some(format!(\"{{{}}}\", n)),\n+                Substitution::Escape(_) => None,\n             }\n         }\n     }\n@@ -807,20 +817,26 @@ pub mod shell {\n     pub fn iter_subs(s: &str) -> Substitutions {\n         Substitutions {\n             s,\n+            pos: 0,\n         }\n     }\n \n     /// Iterator over substitutions in a string.\n     pub struct Substitutions<'a> {\n         s: &'a str,\n+        pos: usize,\n     }\n \n     impl<'a> Iterator for Substitutions<'a> {\n         type Item = Substitution<'a>;\n         fn next(&mut self) -> Option<Self::Item> {\n             match parse_next_substitution(self.s) {\n-                Some((sub, tail)) => {\n+                Some((mut sub, tail)) => {\n                     self.s = tail;\n+                    if let Some((start, end)) = sub.position() {\n+                        sub.set_position(start + self.pos, end + self.pos);\n+                        self.pos += end;\n+                    }\n                     Some(sub)\n                 },\n                 None => None,\n@@ -837,15 +853,15 @@ pub mod shell {\n         let at = {\n             let start = s.find('$')?;\n             match s[start+1..].chars().next()? {\n-                '$' => return Some((Substitution::Escape, &s[start+2..])),\n+                '$' => return Some((Substitution::Escape((start, start+2)), &s[start+2..])),\n                 c @ '0' ..= '9' => {\n                     let n = (c as u8) - b'0';\n-                    return Some((Substitution::Ordinal(n), &s[start+2..]));\n+                    return Some((Substitution::Ordinal(n, (start, start+2)), &s[start+2..]));\n                 },\n                 _ => {/* fall-through */},\n             }\n \n-            Cur::new_at_start(&s[start..])\n+            Cur::new_at(&s[..], start)\n         };\n \n         let at = at.at_next_cp()?;\n@@ -855,7 +871,10 @@ pub mod shell {\n             None\n         } else {\n             let end = at_next_cp_while(inner, is_ident_tail);\n-            Some((Substitution::Name(at.slice_between(end).unwrap()), end.slice_after()))\n+            let slice = at.slice_between(end).unwrap();\n+            let start = at.at - 1;\n+            let end_pos = at.at + slice.len();\n+            Some((Substitution::Name(slice, (start, end_pos)), end.slice_after()))\n         }\n     }\n \n@@ -907,24 +926,24 @@ pub mod shell {\n         fn test_escape() {\n             assert_eq!(pns(\"has no escapes\"), None);\n             assert_eq!(pns(\"has no escapes, either $\"), None);\n-            assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape, \" escape\")));\n-            assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape, \" leading escape\")));\n-            assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape, \"\")));\n+            assert_eq!(pns(\"*so* has a $$ escape\"), Some((S::Escape((11, 13)), \" escape\")));\n+            assert_eq!(pns(\"$$ leading escape\"), Some((S::Escape((0, 2)), \" leading escape\")));\n+            assert_eq!(pns(\"trailing escape $$\"), Some((S::Escape((16, 18)), \"\")));\n         }\n \n         #[test]\n         fn test_parse() {\n             macro_rules! assert_pns_eq_sub {\n-                ($in_:expr, $kind:ident($arg:expr)) => {\n-                    assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into()), \"!\")))\n+                ($in_:expr, $kind:ident($arg:expr, $pos:expr)) => {\n+                    assert_eq!(pns(concat!($in_, \"!\")), Some((S::$kind($arg.into(), $pos), \"!\")))\n                 };\n             }\n \n-            assert_pns_eq_sub!(\"$0\", Ordinal(0));\n-            assert_pns_eq_sub!(\"$1\", Ordinal(1));\n-            assert_pns_eq_sub!(\"$9\", Ordinal(9));\n-            assert_pns_eq_sub!(\"$N\", Name(\"N\"));\n-            assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\"));\n+            assert_pns_eq_sub!(\"$0\", Ordinal(0, (0, 2)));\n+            assert_pns_eq_sub!(\"$1\", Ordinal(1, (0, 2)));\n+            assert_pns_eq_sub!(\"$9\", Ordinal(9, (0, 2)));\n+            assert_pns_eq_sub!(\"$N\", Name(\"N\", (0, 2)));\n+            assert_pns_eq_sub!(\"$NAME\", Name(\"NAME\", (0, 5)));\n         }\n \n         #[test]\n@@ -961,13 +980,6 @@ mod strcursor {\n     }\n \n     impl<'a> StrCursor<'a> {\n-        pub fn new_at_start(s: &'a str) -> StrCursor<'a> {\n-            StrCursor {\n-                s,\n-                at: 0,\n-            }\n-        }\n-\n         pub fn new_at(s: &'a str, at: usize) -> StrCursor<'a> {\n             StrCursor {\n                 s,"}, {"sha": "a13e4ffa8f8295cc50da40d3c3fe3b0735c6128a", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1075,7 +1075,7 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n     auto MOrErr = getLazyBitcodeModule(Memory, Context, true, true);\n \n     if (!MOrErr)\n-      return std::move(MOrErr);\n+      return MOrErr;\n \n     // The rest of this closure is a workaround for\n     // https://bugs.llvm.org/show_bug.cgi?id=38184 where during ThinLTO imports\n@@ -1093,14 +1093,14 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n     // shouldn't be a perf hit.\n     if (Error Err = (*MOrErr)->materializeMetadata()) {\n       Expected<std::unique_ptr<Module>> Ret(std::move(Err));\n-      return std::move(Ret);\n+      return Ret;\n     }\n \n     auto *WasmCustomSections = (*MOrErr)->getNamedMetadata(\"wasm.custom_sections\");\n     if (WasmCustomSections)\n       WasmCustomSections->eraseFromParent();\n \n-    return std::move(MOrErr);\n+    return MOrErr;\n   };\n   FunctionImporter Importer(Data->Index, Loader);\n   Expected<bool> Result = Importer.importFunctions(Mod, ImportList);"}, {"sha": "a6c846d7dab51862a185e42b53543bee84f4d6ec", "filename": "src/test/codegen/slice-position-bounds-check.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fcodegen%2Fslice-position-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fcodegen%2Fslice-position-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-position-bounds-check.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,42 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-system-llvm\n+// compile-flags: -O -C panic=abort\n+#![crate_type = \"lib\"]\n+\n+fn search<T: Ord + Eq>(arr: &mut [T], a: &T) -> Result<usize, ()> {\n+    match arr.iter().position(|x| x == a) {\n+        Some(p) => {\n+            Ok(p)\n+        },\n+        None => Err(()),\n+    }\n+}\n+\n+// CHECK-LABEL: @position_no_bounds_check\n+#[no_mangle]\n+pub fn position_no_bounds_check(y: &mut [u32], x: &u32, z: &u32) -> bool {\n+    // This contains \"call assume\" so we cannot just rule out all calls\n+    // CHECK-NOT: panic_bounds_check\n+    if let Ok(p) = search(y, x) {\n+      y[p] == *z\n+    } else {\n+      false\n+    }\n+}\n+\n+// just to make sure that panicking really emits \"panic_bounds_check\" somewhere in the IR\n+// CHECK-LABEL: @test_check\n+#[no_mangle]\n+pub fn test_check(y: &[i32]) -> i32 {\n+    // CHECK: panic_bounds_check\n+    y[12]\n+}"}, {"sha": "56c4364d598e75f45b50eeff6acf7556cb98606f", "filename": "src/test/codegen/sparc-struct-abi.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsparc-struct-abi.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -11,6 +11,7 @@\n // Checks that we correctly codegen extern \"C\" functions returning structs.\n // See issue #52638.\n \n+// only-sparc64\n // compile-flags: -O --target=sparc64-unknown-linux-gnu --crate-type=rlib\n #![feature(no_core, lang_items)]\n #![no_core]"}, {"sha": "95c738d3ec49a7301b510af618234e6dd57a5bdf", "filename": "src/test/run-pass/const-endianess.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Frun-pass%2Fconst-endianess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-endianess.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -25,7 +25,7 @@ fn main() {\n     #[cfg(not(target_arch = \"asmjs\"))]\n     {\n         const BE_U128: u128 = 999999u128.to_be();\n-        const LE_I128: i128 = -999999i128.to_le();\n+        const LE_I128: i128 = (-999999i128).to_le();\n         assert_eq!(BE_U128, b(999999u128).to_be());\n         assert_eq!(LE_I128, b(-999999i128).to_le());\n     }"}, {"sha": "dbc65569afa876bab3c59bd270d7073c4ccd9483", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 26)' panicked at 'couldn't compile the test', librustdoc/test.rs:332:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 26)' panicked at 'couldn't compile the test', librustdoc/test.rs:333:13\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 20) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 20)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` for a backtrace.\n \n-', librustdoc/test.rs:367:17\n+', librustdoc/test.rs:368:17\n \n \n failures:"}, {"sha": "01fa2f3459ea71d4a6cb1c6897c1f4042c25b802", "filename": "src/test/ui-fulldeps/auxiliary/lint_tool_test.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_tool_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_tool_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fauxiliary%2Flint_tool_test.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(plugin_registrar)]\n+#![feature(box_syntax, rustc_private)]\n+#![feature(macro_vis_matcher)]\n+#![feature(macro_at_most_once_rep)]\n+\n+extern crate syntax;\n+\n+// Load rustc as a plugin to get macros\n+#[macro_use]\n+extern crate rustc;\n+extern crate rustc_plugin;\n+\n+use rustc::lint::{EarlyContext, LintContext, LintPass, EarlyLintPass,\n+                  LintArray};\n+use rustc_plugin::Registry;\n+use syntax::ast;\n+declare_tool_lint!(pub clippy::TEST_LINT, Warn, \"Warn about stuff\");\n+\n+struct Pass;\n+\n+impl LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(TEST_LINT)\n+    }\n+}\n+\n+impl EarlyLintPass for Pass {\n+    fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n+        if it.ident.name == \"lintme\" {\n+            cx.span_lint(TEST_LINT, it.span, \"item is named 'lintme'\");\n+        }\n+    }\n+}\n+\n+#[plugin_registrar]\n+pub fn plugin_registrar(reg: &mut Registry) {\n+    reg.register_early_lint_pass(box Pass);\n+}"}, {"sha": "ccdcd2df31b4f49afd20bd2202f1088986c2afa3", "filename": "src/test/ui-fulldeps/lint_tool_test.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// aux-build:lint_tool_test.rs\n+// ignore-stage1\n+#![feature(plugin)]\n+#![feature(tool_lints)]\n+#![plugin(lint_tool_test)]\n+#![allow(dead_code)]\n+\n+fn lintme() { } //~ WARNING item is named 'lintme'\n+\n+#[allow(clippy::test_lint)]\n+pub fn main() {\n+    fn lintme() { }\n+}"}, {"sha": "22d0f458e7d7b487690175a9f3547adc8d99bec5", "filename": "src/test/ui-fulldeps/lint_tool_test.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Flint_tool_test.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -0,0 +1,8 @@\n+warning: item is named 'lintme'\n+  --> $DIR/lint_tool_test.rs:19:1\n+   |\n+LL | fn lintme() { } //~ WARNING item is named 'lintme'\n+   | ^^^^^^^^^^^^^^^\n+   |\n+   = note: #[warn(clippy::test_lint)] on by default\n+"}, {"sha": "1b913471924b799a19fbcefa11978ce2bef67d0a", "filename": "src/test/ui/borrowck/borrowck-move-error-with-note.nll.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-error-with-note.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -19,14 +19,16 @@ error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n    |\n LL |     match (S {f: \"foo\".to_string(), g: \"bar\".to_string()}) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n+...\n+LL |             f: _s,\n+   |                -- data moved here\n+LL |             g: _t\n+   |                -- ... and here\n help: to prevent move, use ref or ref mut\n    |\n LL |             f: ref _s,\n-   |                ^^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n LL |             g: ref _t\n-   |                ^^^^^^\n+   |\n \n error[E0507]: cannot move out of borrowed content\n   --> $DIR/borrowck-move-error-with-note.rs:57:11"}, {"sha": "95a7894d532546e1f8dd942b7c11e536c906eb22", "filename": "src/test/ui/borrowck/borrowck-move-out-of-vec-tail.nll.stderr", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-move-out-of-vec-tail.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -3,14 +3,19 @@ error[E0508]: cannot move out of type `[Foo]`, a non-copy slice\n    |\n LL |             match tail {\n    |                   ^^^^ cannot move out of here\n+LL |                 &[Foo { string: a },\n+   |                                 - data moved here\n+...\n+LL |                   Foo { string: b }] => {\n+   |                                 - ... and here\n help: to prevent move, use ref or ref mut\n    |\n LL |                 &[Foo { string: ref a },\n-   |                                 ^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n+LL |                 //~^ ERROR cannot move out of type `[Foo]`\n+LL |                 //~| cannot move out\n+LL |                 //~| to prevent move\n LL |                   Foo { string: ref b }] => {\n-   |                                 ^^^^^\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "2779132590e2c00b57e1b06f1a9d372b2af166fd", "filename": "src/test/ui/borrowck/borrowck-vec-pattern-nesting.nll.stderr", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-vec-pattern-nesting.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -28,7 +28,10 @@ error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy sli\n LL |     match vec {\n    |           ^^^ cannot move out of here\n LL |         &mut [_a, //~ ERROR cannot move out\n-   |               -- help: to prevent move, use ref or ref mut: `ref _a`\n+   |               --\n+   |               |\n+   |               data moved here\n+   |               help: to prevent move, use ref or ref mut: `ref _a`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:57:13\n@@ -46,7 +49,10 @@ LL |     match vec {\n    |           ^^^ cannot move out of here\n ...\n LL |          _b] => {}\n-   |          -- help: to prevent move, use ref or ref mut: `ref _b`\n+   |          --\n+   |          |\n+   |          data moved here\n+   |          help: to prevent move, use ref or ref mut: `ref _b`\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:70:13\n@@ -62,18 +68,15 @@ error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy sli\n    |\n LL |     match vec {\n    |           ^^^ cannot move out of here\n+LL |         &mut [_a, _b, _c] => {}  //~ ERROR cannot move out\n+   |               --  --  -- ... and here\n+   |               |   |\n+   |               |   ... and here\n+   |               data moved here\n help: to prevent move, use ref or ref mut\n    |\n-LL |         &mut [ref _a, _b, _c] => {}  //~ ERROR cannot move out\n-   |               ^^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n-LL |         &mut [_a, ref _b, _c] => {}  //~ ERROR cannot move out\n-   |                   ^^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n-LL |         &mut [_a, _b, ref _c] => {}  //~ ERROR cannot move out\n-   |                       ^^^^^^\n+LL |         &mut [ref _a, ref _b, ref _c] => {}  //~ ERROR cannot move out\n+   |               ^^^^^^  ^^^^^^  ^^^^^^\n \n error[E0508]: cannot move out of type `[std::boxed::Box<isize>]`, a non-copy slice\n   --> $DIR/borrowck-vec-pattern-nesting.rs:82:13"}, {"sha": "b6e005a6673ebc53a74a9e3c0cdb1dbd33daf99f", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -17,41 +17,41 @@ LL |         if let Some(thing) = maybe {\n    = note: move occurs because the value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `maybe` (Mir)\n-  --> $DIR/issue-41962.rs:17:30\n+  --> $DIR/issue-41962.rs:17:16\n    |\n LL |         if let Some(thing) = maybe {\n-   |                     -----    ^^^^^ value used here after move\n-   |                     |\n-   |                     value moved here\n+   |                ^^^^^-----^\n+   |                |    |\n+   |                |    value moved here\n+   |                value used here after move\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n-error[E0382]: borrow of moved value: `maybe` (Mir)\n-  --> $DIR/issue-41962.rs:17:30\n+error[E0382]: use of moved value (Mir)\n+  --> $DIR/issue-41962.rs:17:21\n    |\n LL |         if let Some(thing) = maybe {\n-   |                     -----    ^^^^^ value borrowed here after move\n-   |                     |\n-   |                     value moved here\n+   |                     ^^^^^ value moved here in previous iteration of loop\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `maybe` (Mir)\n-  --> $DIR/issue-41962.rs:17:16\n+  --> $DIR/issue-41962.rs:17:30\n    |\n LL |         if let Some(thing) = maybe {\n-   |                ^^^^^-----^\n-   |                |    |\n-   |                |    value moved here\n-   |                value used here after move\n+   |                     -----    ^^^^^ value used here after move\n+   |                     |\n+   |                     value moved here\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n-error[E0382]: use of moved value (Mir)\n-  --> $DIR/issue-41962.rs:17:21\n+error[E0382]: borrow of moved value: `maybe` (Mir)\n+  --> $DIR/issue-41962.rs:17:30\n    |\n LL |         if let Some(thing) = maybe {\n-   |                     ^^^^^ value moved here in previous iteration of loop\n+   |                     -----    ^^^^^ value borrowed here after move\n+   |                     |\n+   |                     value moved here\n    |\n    = note: move occurs because value has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n "}, {"sha": "20713c3392e8e9c23e0f2cfe66337beee321ede3", "filename": "src/test/ui/borrowck/issue-51415.nll.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-51415.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,6 +4,7 @@ error[E0507]: cannot move out of borrowed content\n LL |     let opt = a.iter().enumerate().find(|(_, &s)| {\n    |                                          ^^^^^-^\n    |                                          |    |\n+   |                                          |    data moved here\n    |                                          |    help: to prevent move, use ref or ref mut: `ref s`\n    |                                          cannot move out of borrowed content\n "}, {"sha": "a7e1dd95364533bb206d2b95b9b039c272c99f7d", "filename": "src/test/ui/borrowck/two-phase-multi-mut.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multi-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multi-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Ftwo-phase-multi-mut.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,21 +1,21 @@\n error[E0499]: cannot borrow `foo` as mutable more than once at a time\n-  --> $DIR/two-phase-multi-mut.rs:23:16\n+  --> $DIR/two-phase-multi-mut.rs:23:5\n    |\n LL |     foo.method(&mut foo);\n-   |     -----------^^^^^^^^-\n+   |     ^^^^^^^^^^^--------^\n    |     |          |\n-   |     |          second mutable borrow occurs here\n-   |     first mutable borrow occurs here\n+   |     |          first mutable borrow occurs here\n+   |     second mutable borrow occurs here\n    |     borrow later used here\n \n error[E0499]: cannot borrow `foo` as mutable more than once at a time\n-  --> $DIR/two-phase-multi-mut.rs:23:5\n+  --> $DIR/two-phase-multi-mut.rs:23:16\n    |\n LL |     foo.method(&mut foo);\n-   |     ^^^^^^^^^^^--------^\n+   |     -----------^^^^^^^^-\n    |     |          |\n-   |     |          first mutable borrow occurs here\n-   |     second mutable borrow occurs here\n+   |     |          second mutable borrow occurs here\n+   |     first mutable borrow occurs here\n    |     borrow later used here\n \n error: aborting due to 2 previous errors"}, {"sha": "a1fbcf1430db93b2b4a40c3077ee87db39a4cce9", "filename": "src/test/ui/codemap_tests/overlapping_spans.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Foverlapping_spans.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,7 +4,10 @@ error[E0509]: cannot move out of type `S`, which implements the `Drop` trait\n LL |     match (S {f:\"foo\".to_string()}) {\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of here\n LL |         S {f:_s} => {} //~ ERROR cannot move out\n-   |              -- help: to prevent move, use ref or ref mut: `ref _s`\n+   |              --\n+   |              |\n+   |              data moved here\n+   |              help: to prevent move, use ref or ref mut: `ref _s`\n \n error: aborting due to previous error\n "}, {"sha": "8c848b33241ca44ea8e19912e0e91ec53f6f6955", "filename": "src/test/ui/did_you_mean/issue-39544.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -10,7 +10,7 @@ error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:26:17\n    |\n LL |     fn foo<'z>(&'z self) {\n-   |                -------- help: consider changing this to be a mutable reference: `&mut self`\n+   |                -------- help: consider changing this to be a mutable reference: `&'z mut self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n@@ -35,7 +35,7 @@ error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:35:17\n    |\n LL |     fn foo2<'a>(&'a self, other: &Z) {\n-   |                 -------- help: consider changing this to be a mutable reference: `&mut self`\n+   |                 -------- help: consider changing this to be a mutable reference: `&'a mut self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n@@ -52,7 +52,7 @@ error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:40:17\n    |\n LL |     fn foo3<'a>(self: &'a Self, other: &Z) {\n-   |                       -------- help: consider changing this to be a mutable reference: `&mut Z`\n+   |                       -------- help: consider changing this to be a mutable reference: `&'a mut Self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n "}, {"sha": "56b77714991ca61e7d5d5ca72684aad75686a1cb", "filename": "src/test/ui/hygiene/fields-move.nll.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Ffields-move.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,27 +1,27 @@\n error[E0382]: use of moved value: `foo.x`\n-  --> $DIR/fields-move.rs:38:42\n+  --> $DIR/fields-move.rs:28:9\n    |\n LL |    $foo.x\n    |    ------ value moved here\n ...\n+LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n+   |         ^^^^^^ value used here after move\n+...\n LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n-   |                                          ^^^^^ value used here after move\n+   |                                          ----- value moved here\n+LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n+   |                       ----------------- in this macro invocation\n    |\n    = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n \n error[E0382]: use of moved value: `foo.x`\n-  --> $DIR/fields-move.rs:28:9\n+  --> $DIR/fields-move.rs:38:42\n    |\n LL |    $foo.x\n    |    ------ value moved here\n ...\n-LL |         $foo.x //~ ERROR use of moved value: `foo.x`\n-   |         ^^^^^^ value used here after move\n-...\n LL |     assert_two_copies(copy_modern!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n-   |                                          ----- value moved here\n-LL |     assert_two_copies(copy_legacy!(foo), foo.x); //~ ERROR use of moved value: `foo.x`\n-   |                       ----------------- in this macro invocation\n+   |                                          ^^^^^ value used here after move\n    |\n    = note: move occurs because `foo.x` has type `NonCopy`, which does not implement the `Copy` trait\n "}, {"sha": "29bda252b9115f180495870e819928142669be9c", "filename": "src/test/ui/issue-12567.nll.stderr", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fissue-12567.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fissue-12567.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-12567.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -3,28 +3,40 @@ error[E0508]: cannot move out of type `[T]`, a non-copy slice\n    |\n LL |     match (l1, l2) {\n    |           ^^^^^^^^ cannot move out of here\n+LL |         (&[], &[]) => println!(\"both empty\"),\n+LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n+   |                 -- data moved here\n+...\n+LL |         (&[hd1, ..], &[hd2, ..])\n+   |                        --- ... and here\n help: to prevent move, use ref or ref mut\n    |\n LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n-   |                 ^^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n+LL |             => println!(\"one empty\"),\n+LL |         //~^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n+LL |         //~^^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n LL |         (&[hd1, ..], &[ref hd2, ..])\n-   |                        ^^^^^^^\n+   |\n \n error[E0508]: cannot move out of type `[T]`, a non-copy slice\n   --> $DIR/issue-12567.rs:14:11\n    |\n LL |     match (l1, l2) {\n    |           ^^^^^^^^ cannot move out of here\n+LL |         (&[], &[]) => println!(\"both empty\"),\n+LL |         (&[], &[hd, ..]) | (&[hd, ..], &[])\n+   |                 -- data moved here\n+...\n+LL |         (&[hd1, ..], &[hd2, ..])\n+   |            --- ... and here\n help: to prevent move, use ref or ref mut\n    |\n LL |         (&[], &[ref hd, ..]) | (&[hd, ..], &[])\n-   |                 ^^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n+LL |             => println!(\"one empty\"),\n+LL |         //~^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n+LL |         //~^^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n LL |         (&[ref hd1, ..], &[hd2, ..])\n-   |            ^^^^^^^\n+   |\n \n error: aborting due to 2 previous errors\n "}, {"sha": "36a15e79ac825d5b872146eda6e2127ac78ad88a", "filename": "src/test/ui/issue-27592.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fissue-27592.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fissue-27592.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27592.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,11 +1,3 @@\n-error[E0597]: borrowed value does not live long enough\n-  --> $DIR/issue-27592.rs:26:33\n-   |\n-LL |     write(|| format_args!(\"{}\", String::from(\"Hello world\")));\n-   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^- temporary value only lives until here\n-   |                                 |\n-   |                                 temporary value does not live long enough\n-\n error[E0597]: borrowed value does not live long enough\n   --> $DIR/issue-27592.rs:26:27\n    |\n@@ -14,6 +6,14 @@ LL |     write(|| format_args!(\"{}\", String::from(\"Hello world\")));\n    |                           |\n    |                           temporary value does not live long enough\n \n+error[E0597]: borrowed value does not live long enough\n+  --> $DIR/issue-27592.rs:26:33\n+   |\n+LL |     write(|| format_args!(\"{}\", String::from(\"Hello world\")));\n+   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^- temporary value only lives until here\n+   |                                 |\n+   |                                 temporary value does not live long enough\n+\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "ac00ce3af9624dcef68b92bff544d83dd86efdaa", "filename": "src/test/ui/macros/format-foreign.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -22,4 +22,6 @@ fn main() {\n     println!(\"{} %f\", \"one\", 2.0); //~ ERROR never used\n \n     println!(\"Hi there, $NAME.\", NAME=\"Tim\"); //~ ERROR never used\n+    println!(\"$1 $0 $$ $NAME\", 1, 2, NAME=3);\n+    //~^ ERROR multiple unused formatting arguments\n }"}, {"sha": "d5e2b514c405c09994d34f0ae875cb72795d40d1", "filename": "src/test/ui/macros/format-foreign.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-foreign.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -52,10 +52,25 @@ error: named argument never used\n   --> $DIR/format-foreign.rs:24:39\n    |\n LL |     println!(\"Hi there, $NAME.\", NAME=\"Tim\"); //~ ERROR never used\n-   |                                       ^^^^^\n+   |                         -----         ^^^^^\n+   |                         |\n+   |                         help: format specifiers use curly braces: `{NAME}`\n    |\n-   = help: `$NAME` should be written as `{NAME}`\n    = note: shell formatting not supported; see the documentation for `std::fmt`\n \n-error: aborting due to 5 previous errors\n+error: multiple unused formatting arguments\n+  --> $DIR/format-foreign.rs:25:32\n+   |\n+LL |     println!(\"$1 $0 $$ $NAME\", 1, 2, NAME=3);\n+   |              ----------------  ^  ^       ^\n+   |              |\n+   |              multiple missing formatting specifiers\n+   |\n+   = note: shell formatting not supported; see the documentation for `std::fmt`\n+help: format specifiers use curly braces\n+   |\n+LL |     println!(\"{1} {0} $$ {NAME}\", 1, 2, NAME=3);\n+   |               ^^^ ^^^    ^^^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "67ffeec67cc8b05f8e83190e96dc8c761b1e152c", "filename": "src/test/ui/macros/format-unused-lables.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-unused-lables.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -30,7 +30,10 @@ error: multiple unused formatting arguments\n   --> $DIR/format-unused-lables.rs:24:9\n    |\n LL |     println!(\"Some more $STUFF\",\n-   |              ------------------ multiple missing formatting specifiers\n+   |              ------------------\n+   |              |          |\n+   |              |          help: format specifiers use curly braces: `{STUFF}`\n+   |              multiple missing formatting specifiers\n LL |         \"woo!\",  //~ ERROR multiple unused formatting arguments\n    |         ^^^^^^\n LL |             STUFF=\n@@ -39,7 +42,6 @@ LL |        \"things\"\n LL |              , UNUSED=\"args\");\n    |                       ^^^^^^\n    |\n-   = help: `$STUFF` should be written as `{STUFF}`\n    = note: shell formatting not supported; see the documentation for `std::fmt`\n \n error: aborting due to 4 previous errors"}, {"sha": "862d1f0b179c0e34a9e412ede8be5fe019efc35a", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,15 +4,6 @@ warning: not reporting region error due to nll\n LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |                                                  ^\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/escape-argument-callee.rs:36:45\n-   |\n-LL |         let mut closure = expect_sig(|p, y| *p = y);\n-   |                                       -  -  ^^^^^^ requires that `'1` must outlive `'2`\n-   |                                       |  |\n-   |                                       |  has type `&'1 i32`\n-   |                                       has type `&mut &'2 i32`\n-\n note: No external requirements\n   --> $DIR/escape-argument-callee.rs:36:38\n    |\n@@ -24,6 +15,15 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n                for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) mut &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) i32, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't0)) i32))\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/escape-argument-callee.rs:36:45\n+   |\n+LL |         let mut closure = expect_sig(|p, y| *p = y);\n+   |                                       -  -  ^^^^^^ requires that `'1` must outlive `'2`\n+   |                                       |  |\n+   |                                       |  has type `&'1 i32`\n+   |                                       has type `&mut &'2 i32`\n+\n note: No external requirements\n   --> $DIR/escape-argument-callee.rs:30:1\n    |"}, {"sha": "72b7104b99dd3c5a3dcb0d4ebc155d8de5adfcb4", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,17 +4,6 @@ warning: not reporting region error due to nll\n LL |             let p = x.get();\n    |                     ^^^^^^^\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n-   |\n-LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n-   |          ----------              ---------- has type `std::cell::Cell<&'2 &u32>`\n-   |          |\n-   |          has type `std::cell::Cell<&&'1 u32>`\n-...\n-LL |             demand_y(x, y, p) //~ ERROR\n-   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n-\n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n    |\n@@ -31,6 +20,17 @@ LL | |         },\n                for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n+   |\n+LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n+   |          ----------              ---------- has type `std::cell::Cell<&'2 &u32>`\n+   |          |\n+   |          has type `std::cell::Cell<&&'1 u32>`\n+...\n+LL |             demand_y(x, y, p) //~ ERROR\n+   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+\n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:48:1\n    |"}, {"sha": "43c39dee2448a1c5793579421402015233dd34b2", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,17 +4,6 @@ warning: not reporting region error due to nll\n LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n-error: borrowed data escapes outside of closure\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n-   |\n-LL |     foo(cell, |cell_a, cell_x| {\n-   |                ------  ------ `cell_x` is a reference that is only valid in the closure body\n-   |                |\n-   |                `cell_a` is declared here, outside of the closure body\n-LL |         //~^ WARNING not reporting region error due to nll\n-LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^ `cell_x` escapes the closure body here\n-\n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15\n    |\n@@ -31,6 +20,17 @@ LL | |     })\n                for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) u32>))\n            ]\n \n+error: borrowed data escapes outside of closure\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n+   |\n+LL |     foo(cell, |cell_a, cell_x| {\n+   |                ------  ------ `cell_x` is a reference that is only valid in the closure body\n+   |                |\n+   |                `cell_a` is declared here, outside of the closure body\n+LL |         //~^ WARNING not reporting region error due to nll\n+LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ `cell_x` escapes the closure body here\n+\n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:28:1\n    |"}, {"sha": "c3bbf1035dbc574081c9d1a7d093606a5c1b54fa", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -23,19 +23,6 @@ LL | |     });\n    = note: number of external vids: 4\n    = note: where '_#1r: '_#0r\n \n-error: borrowed data escapes outside of function\n-  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n-   |\n-LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |                     ------ `cell_a` is a reference that is only valid in the function body\n-LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-LL | |         //~^ ERROR\n-LL | |\n-LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n-LL | |     });\n-   | |______^ `cell_a` escapes the function body here\n-\n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:44:1\n    |\n@@ -50,5 +37,18 @@ LL | | }\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_no_bound[317d]::supply[0]) with substs []\n \n+error: borrowed data escapes outside of function\n+  --> $DIR/propagate-approximated-shorter-to-static-no-bound.rs:45:5\n+   |\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                     ------ `cell_a` is a reference that is only valid in the function body\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+LL | |         //~^ ERROR\n+LL | |\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n+LL | |     });\n+   | |______^ `cell_a` escapes the function body here\n+\n error: aborting due to previous error\n "}, {"sha": "9f259e2dee5904616ae14b850d277e817d93f8d6", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -23,19 +23,6 @@ LL | |     });\n    = note: number of external vids: 5\n    = note: where '_#1r: '_#0r\n \n-error: borrowed data escapes outside of function\n-  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n-   |\n-LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |                     ------ `cell_a` is a reference that is only valid in the function body\n-LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-LL | |         //~^ ERROR\n-LL | |         // Only works if 'x: 'y:\n-LL | |         demand_y(x, y, x.get())\n-LL | |         //~^ WARNING not reporting region error due to nll\n-LL | |     });\n-   | |______^ `cell_a` escapes the function body here\n-\n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:47:1\n    |\n@@ -50,5 +37,18 @@ LL | | }\n    |\n    = note: defining type: DefId(0/0:6 ~ propagate_approximated_shorter_to_static_wrong_bound[317d]::supply[0]) with substs []\n \n+error: borrowed data escapes outside of function\n+  --> $DIR/propagate-approximated-shorter-to-static-wrong-bound.rs:48:5\n+   |\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                     ------ `cell_a` is a reference that is only valid in the function body\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+LL | |         //~^ ERROR\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(x, y, x.get())\n+LL | |         //~^ WARNING not reporting region error due to nll\n+LL | |     });\n+   | |______^ `cell_a` escapes the function body here\n+\n error: aborting due to previous error\n "}, {"sha": "cd5e6f29f5f480cc2862f714777b826c80527414", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,17 +4,6 @@ warning: not reporting region error due to nll\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n-   |\n-LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n-   |                                                ---------  - has type `&std::cell::Cell<&'1 u32>`\n-   |                                                |\n-   |                                                has type `&std::cell::Cell<&'2 &u32>`\n-LL |         // Only works if 'x: 'y:\n-LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n-\n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47\n    |\n@@ -32,6 +21,17 @@ LL | |     });\n                for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't1)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) u32>))\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n+   |\n+LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n+   |                                                ---------  - has type `&std::cell::Cell<&'1 u32>`\n+   |                                                |\n+   |                                                has type `&std::cell::Cell<&'2 &u32>`\n+LL |         // Only works if 'x: 'y:\n+LL |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+\n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:44:1\n    |"}, {"sha": "2176575e0aa128e7067afdad22b870fd0edbcc80", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,17 +4,6 @@ warning: not reporting region error due to nll\n LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n-   |\n-LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                                                ----------  ---------- has type `&std::cell::Cell<&'2 &u32>`\n-   |                                                |\n-   |                                                has type `&std::cell::Cell<&'1 &u32>`\n-LL |         // Only works if 'x: 'y:\n-LL |         demand_y(x, y, x.get())\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n-\n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47\n    |\n@@ -32,6 +21,17 @@ LL | |     });\n                for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't0)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't1)) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't2)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) u32>, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't3)) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 't1)) u32>))\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n+   |\n+LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+   |                                                ----------  ---------- has type `&std::cell::Cell<&'2 &u32>`\n+   |                                                |\n+   |                                                has type `&std::cell::Cell<&'1 &u32>`\n+LL |         // Only works if 'x: 'y:\n+LL |         demand_y(x, y, x.get())\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n+\n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:48:1\n    |"}, {"sha": "8f8a99df5f0529dcef540ee13de8b348d85d654b", "filename": "src/test/ui/nll/closure-requirements/propagate-from-trait-match.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-from-trait-match.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -26,21 +26,6 @@ LL | |     });\n    = note: number of external vids: 3\n    = note: where T: '_#1r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/propagate-from-trait-match.rs:42:36\n-   |\n-LL |       establish_relationships(value, |value| {\n-   |  ____________________________________^\n-LL | |         //~^ ERROR the parameter type `T` may not live long enough\n-LL | |\n-LL | |         // This function call requires that\n-...  |\n-LL | |         //~^ WARNING not reporting region error due to nll\n-LL | |     });\n-   | |_____^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/propagate-from-trait-match.rs:38:1\n    |\n@@ -58,6 +43,21 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/propagate-from-trait-match.rs:42:36\n+   |\n+LL |       establish_relationships(value, |value| {\n+   |  ____________________________________^\n+LL | |         //~^ ERROR the parameter type `T` may not live long enough\n+LL | |\n+LL | |         // This function call requires that\n+...  |\n+LL | |         //~^ WARNING not reporting region error due to nll\n+LL | |     });\n+   | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "d2e088815e11803a83f08dea0767f7904ade647c", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -4,15 +4,6 @@ warning: not reporting region error due to nll\n LL |     expect_sig(|a, b| b); // ought to return `a`\n    |                       ^\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/return-wrong-bound-region.rs:21:23\n-   |\n-LL |     expect_sig(|a, b| b); // ought to return `a`\n-   |                 -  -  ^ closure was supposed to return data with lifetime `'1` but it is returning data with lifetime `'2`\n-   |                 |  |\n-   |                 |  has type `&'1 i32`\n-   |                 has type `&'2 i32`\n-\n note: No external requirements\n   --> $DIR/return-wrong-bound-region.rs:21:16\n    |\n@@ -24,6 +15,15 @@ LL |     expect_sig(|a, b| b); // ought to return `a`\n                for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) i32, &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 's)) i32)) -> &ReLateBound(DebruijnIndex(0), BrNamed(crate0:DefIndex(0:0), 'r)) i32\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/return-wrong-bound-region.rs:21:23\n+   |\n+LL |     expect_sig(|a, b| b); // ought to return `a`\n+   |                 -  -  ^ closure was supposed to return data with lifetime `'1` but it is returning data with lifetime `'2`\n+   |                 |  |\n+   |                 |  has type `&'1 i32`\n+   |                 has type `&'2 i32`\n+\n note: No external requirements\n   --> $DIR/return-wrong-bound-region.rs:20:1\n    |"}, {"sha": "472ac2cf1e84c2415236a4b2f348416b3be84d60", "filename": "src/test/ui/nll/extra-unused-mut.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fextra-unused-mut.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -55,10 +55,19 @@ fn parse_dot_or_call_expr_with(mut attrs: Vec<u32>) {\n     );\n }\n \n+// Found when trying to bootstrap rustc\n+fn if_guard(x: Result<i32, i32>) {\n+    match x {\n+        Ok(mut r) | Err(mut r) if true => r = 1,\n+        _ => (),\n+    }\n+}\n+\n fn main() {\n     ref_argument(0);\n     mutable_upvar();\n     generator_mutable_upvar();\n     ref_closure_argument();\n     parse_dot_or_call_expr_with(Vec::new());\n+    if_guard(Ok(0));\n }"}, {"sha": "1c509c5d224618584db790d1705eef70904731b9", "filename": "src/test/ui/nll/issue-52113.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "previous_filename": "src/test/ui/nll/issue-52133.rs"}, {"sha": "4a7c10c3f1af860af15f34e791d1da6d60da8f2e", "filename": "src/test/ui/nll/issue-52113.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-52113.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,5 +1,5 @@\n error[E0623]: lifetime mismatch\n-  --> $DIR/issue-52133.rs:43:9\n+  --> $DIR/issue-52113.rs:43:9\n    |\n LL | fn produce_err<'a, 'b: 'a>(data: &'b mut Vec<&'b u32>, value: &'a u32) -> impl Bazinga + 'b {\n    |                                  --------------------         ------- these two types are declared with different lifetimes...", "previous_filename": "src/test/ui/nll/issue-52133.stderr"}, {"sha": "53d60d3f6d649a4b4ec0b3d9efbc1dc8c14f4ba7", "filename": "src/test/ui/nll/move-errors.stderr", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmove-errors.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -59,6 +59,7 @@ error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n LL |     let C(D(s)) = c;\n    |             -     ^ cannot move out of here\n    |             |\n+   |             data moved here\n    |             help: to prevent move, use ref or ref mut: `ref s`\n \n error[E0507]: cannot move out of borrowed content\n@@ -88,7 +89,10 @@ LL |     match x {\n    |           ^ cannot move out of here\n ...\n LL |         B::U(D(s)) => (),\n-   |                - help: to prevent move, use ref or ref mut: `ref s`\n+   |                -\n+   |                |\n+   |                data moved here\n+   |                help: to prevent move, use ref or ref mut: `ref s`\n \n error[E0509]: cannot move out of type `D`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:105:11\n@@ -97,7 +101,10 @@ LL |     match x {\n    |           ^ cannot move out of here\n ...\n LL |         (D(s), &t) => (),\n-   |            - help: to prevent move, use ref or ref mut: `ref s`\n+   |            -\n+   |            |\n+   |            data moved here\n+   |            help: to prevent move, use ref or ref mut: `ref s`\n \n error[E0507]: cannot move out of borrowed content\n   --> $DIR/move-errors.rs:105:11\n@@ -106,21 +113,25 @@ LL |     match x {\n    |           ^ cannot move out of borrowed content\n ...\n LL |         (D(s), &t) => (),\n-   |                 - help: to prevent move, use ref or ref mut: `ref t`\n+   |                 -\n+   |                 |\n+   |                 data moved here\n+   |                 help: to prevent move, use ref or ref mut: `ref t`\n \n error[E0509]: cannot move out of type `F`, which implements the `Drop` trait\n   --> $DIR/move-errors.rs:115:11\n    |\n LL |     match x {\n    |           ^ cannot move out of here\n+LL |     //~^ ERROR\n+LL |         F(s, mut t) => (),\n+   |           -  ----- ... and here\n+   |           |\n+   |           data moved here\n help: to prevent move, use ref or ref mut\n    |\n-LL |         F(ref s, mut t) => (),\n-   |           ^^^^^\n-help: to prevent move, use ref or ref mut\n-   |\n-LL |         F(s, ref mut t) => (),\n-   |              ^^^^^^^^^\n+LL |         F(ref s, ref mut t) => (),\n+   |           ^^^^^  ^^^^^^^^^\n \n error[E0507]: cannot move out of borrowed content\n   --> $DIR/move-errors.rs:123:11"}, {"sha": "6d2170729ffb9f9db5f8db532bfbdf92710f3819", "filename": "src/test/ui/nll/ty-outlives/projection-no-regions-closure.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-no-regions-closure.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -25,14 +25,6 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: number of external vids: 4\n    = note: where <T as std::iter::Iterator>::Item: '_#2r\n \n-error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n-  --> $DIR/projection-no-regions-closure.rs:35:23\n-   |\n-LL |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:31:1\n    |\n@@ -50,6 +42,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n+  --> $DIR/projection-no-regions-closure.rs:35:23\n+   |\n+LL |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-no-regions-closure.rs:45:23\n    |\n@@ -97,14 +97,6 @@ LL |     with_signature(x, |mut y| Box::new(y.next()))\n    = note: number of external vids: 5\n    = note: where <T as std::iter::Iterator>::Item: '_#3r\n \n-error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n-  --> $DIR/projection-no-regions-closure.rs:53:23\n-   |\n-LL |     with_signature(x, |mut y| Box::new(y.next()))\n-   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/projection-no-regions-closure.rs:49:1\n    |\n@@ -123,6 +115,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the associated type `<T as std::iter::Iterator>::Item` may not live long enough\n+  --> $DIR/projection-no-regions-closure.rs:53:23\n+   |\n+LL |     with_signature(x, |mut y| Box::new(y.next()))\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as std::iter::Iterator>::Item: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-no-regions-closure.rs:64:23\n    |"}, {"sha": "ed8491349a257ba3db4e68ed7bd3c10f4446f745", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-closure.stderr", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-closure.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -32,20 +32,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where T: '_#2r\n    = note: where '_#1r: '_#2r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:55:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n-\n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:55:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:51:1\n    |\n@@ -63,6 +49,20 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-closure.rs:55:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:55:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ projection_one_region_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:16), 'a))`...\n+\n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:67:29\n    |\n@@ -80,20 +80,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where T: '_#3r\n    = note: where '_#2r: '_#3r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:67:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n-\n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:67:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:62:1\n    |\n@@ -112,6 +98,20 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-closure.rs:67:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:67:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:89:29\n    |\n@@ -129,20 +129,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: where T: '_#3r\n    = note: where '_#2r: '_#3r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/projection-one-region-closure.rs:89:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n-\n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-closure.rs:89:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-closure.rs:74:1\n    |\n@@ -161,6 +147,20 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-closure.rs:89:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/projection-one-region-closure.rs:89:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-one-region-closure.rs:102:29\n    |"}, {"sha": "8318ce10745d32f5bfbe14151a9275337f9af8b6", "filename": "src/test/ui/nll/ty-outlives/projection-one-region-trait-bound-closure.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-one-region-trait-bound-closure.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -31,12 +31,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 5\n    = note: where '_#1r: '_#2r\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:47:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:43:1\n    |\n@@ -54,6 +48,12 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:47:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:58:29\n    |\n@@ -70,12 +70,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 5\n    = note: where '_#2r: '_#3r\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:58:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:53:1\n    |\n@@ -94,6 +88,12 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:58:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:79:29\n    |\n@@ -110,12 +110,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 5\n    = note: where '_#2r: '_#3r\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-one-region-trait-bound-closure.rs:79:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:64:1\n    |\n@@ -134,6 +128,12 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-one-region-trait-bound-closure.rs:79:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n note: External requirements\n   --> $DIR/projection-one-region-trait-bound-closure.rs:90:29\n    |"}, {"sha": "1452573d57a255226ea99e8461ab4d7331f1ed40", "filename": "src/test/ui/nll/ty-outlives/projection-two-region-trait-bound-closure.stderr", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fprojection-two-region-trait-bound-closure.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -38,14 +38,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 6\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#2r)>>::AssocType: '_#3r\n \n-error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReFree(DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:18), 'a))`...\n-\n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:44:1\n    |\n@@ -64,6 +56,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the associated type `<T as Anything<'_#6r, '_#7r>>::AssocType` may not live long enough\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:48:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#6r, '_#7r>>::AssocType: ReFree(DefId(0/0:8 ~ projection_two_region_trait_bound_closure[317d]::no_relationships_late[0]), BrNamed(crate0:DefIndex(1:18), 'a))`...\n+\n note: External requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:59:29\n    |\n@@ -81,14 +81,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 6\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n \n-error[E0309]: the associated type `<T as Anything<'_#7r, '_#8r>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:59:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#7r, '_#8r>>::AssocType: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:54:1\n    |\n@@ -108,6 +100,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the associated type `<T as Anything<'_#7r, '_#8r>>::AssocType` may not live long enough\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:59:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#7r, '_#8r>>::AssocType: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:80:29\n    |\n@@ -125,14 +125,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 6\n    = note: where <T as Anything<ReClosureBound('_#2r), ReClosureBound('_#3r)>>::AssocType: '_#4r\n \n-error[E0309]: the associated type `<T as Anything<'_#7r, '_#8r>>::AssocType` may not live long enough\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:80:29\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `<T as Anything<'_#7r, '_#8r>>::AssocType: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:65:1\n    |\n@@ -152,6 +144,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the associated type `<T as Anything<'_#7r, '_#8r>>::AssocType` may not live long enough\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:80:29\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `<T as Anything<'_#7r, '_#8r>>::AssocType: ReEarlyBound(0, 'a)`...\n+\n note: External requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:91:29\n    |\n@@ -239,12 +239,6 @@ LL |     with_signature(cell, t, |cell, t| require(cell, t));\n    = note: number of external vids: 5\n    = note: where <T as Anything<ReClosureBound('_#1r), ReClosureBound('_#1r)>>::AssocType: '_#2r\n \n-error: unsatisfied lifetime constraints\n-  --> $DIR/projection-two-region-trait-bound-closure.rs:108:5\n-   |\n-LL |     with_signature(cell, t, |cell, t| require(cell, t));\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n-\n note: No external requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:104:1\n    |\n@@ -262,6 +256,12 @@ LL | | }\n                T\n            ]\n \n+error: unsatisfied lifetime constraints\n+  --> $DIR/projection-two-region-trait-bound-closure.rs:108:5\n+   |\n+LL |     with_signature(cell, t, |cell, t| require(cell, t));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'b` must outlive `'a`\n+\n note: External requirements\n   --> $DIR/projection-two-region-trait-bound-closure.rs:119:29\n    |"}, {"sha": "87f55b4e14d9652caca1fdd974a41026978f9b60", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -60,14 +60,6 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    = note: number of external vids: 4\n    = note: where T: '_#1r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-approximate-lower-bound.rs:42:24\n-   |\n-LL |     twice(cell, value, |a, b| invoke(a, b));\n-   |                        ^^^^^^^^^^^^^^^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]), BrNamed(crate0:DefIndex(1:15), 'a))`...\n-\n note: No external requirements\n   --> $DIR/ty-param-closure-approximate-lower-bound.rs:41:1\n    |\n@@ -83,6 +75,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-closure-approximate-lower-bound.rs:42:24\n+   |\n+LL |     twice(cell, value, |a, b| invoke(a, b));\n+   |                        ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_approximate_lower_bound[317d]::generic_fail[0]), BrNamed(crate0:DefIndex(1:15), 'a))`...\n+\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0309`."}, {"sha": "aec0d98c79aa47671f49d165350dbeb87d2838fe", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-return-type.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-return-type.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -25,14 +25,6 @@ LL |     with_signature(x, |y| y)\n    = note: number of external vids: 4\n    = note: where T: '_#2r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-return-type.rs:36:23\n-   |\n-LL |     with_signature(x, |y| y)\n-   |                       ^^^^^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n-\n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:25:1\n    |\n@@ -50,6 +42,14 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-closure-outlives-from-return-type.rs:36:23\n+   |\n+LL |     with_signature(x, |y| y)\n+   |                       ^^^^^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReEarlyBound(0, 'a)`...\n+\n error[E0309]: the parameter type `T` may not live long enough\n   --> $DIR/ty-param-closure-outlives-from-return-type.rs:52:5\n    |"}, {"sha": "67a158860d64c1d7ffcf6705472c5bb65499c852", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-outlives-from-where-clause.stderr", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-outlives-from-where-clause.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -31,21 +31,6 @@ LL | |     })\n    = note: number of external vids: 4\n    = note: where T: '_#1r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:26\n-   |\n-LL |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-LL | |         //~^ ERROR the parameter type `T` may not live long enough\n-LL | |         //\n-LL | |         // See `correct_region`, which explains the point of this\n-...  |\n-LL | |         //~^ WARNING not reporting region error due to nll\n-LL | |     })\n-   | |_____^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]), BrNamed(crate0:DefIndex(1:14), 'a))`...\n-\n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:36:1\n    |\n@@ -62,6 +47,21 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:37:26\n+   |\n+LL |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+LL | |         //~^ ERROR the parameter type `T` may not live long enough\n+LL | |         //\n+LL | |         // See `correct_region`, which explains the point of this\n+...  |\n+LL | |         //~^ WARNING not reporting region error due to nll\n+LL | |     })\n+   | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:6 ~ ty_param_closure_outlives_from_where_clause[317d]::no_region[0]), BrNamed(crate0:DefIndex(1:14), 'a))`...\n+\n note: External requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:54:26\n    |\n@@ -122,20 +122,6 @@ LL | |     })\n    = note: number of external vids: 5\n    = note: where T: '_#2r\n \n-error[E0309]: the parameter type `T` may not live long enough\n-  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:75:26\n-   |\n-LL |       with_signature(a, b, |x, y| {\n-   |  __________________________^\n-LL | |         //~^ ERROR the parameter type `T` may not live long enough\n-LL | |         // See `correct_region`\n-LL | |         require(&x, &y)\n-LL | |         //~^ WARNING not reporting region error due to nll\n-LL | |     })\n-   | |_____^\n-   |\n-   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]), BrNamed(crate0:DefIndex(1:20), 'a))`...\n-\n note: No external requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:71:1\n    |\n@@ -153,6 +139,20 @@ LL | | }\n                T\n            ]\n \n+error[E0309]: the parameter type `T` may not live long enough\n+  --> $DIR/ty-param-closure-outlives-from-where-clause.rs:75:26\n+   |\n+LL |       with_signature(a, b, |x, y| {\n+   |  __________________________^\n+LL | |         //~^ ERROR the parameter type `T` may not live long enough\n+LL | |         // See `correct_region`\n+LL | |         require(&x, &y)\n+LL | |         //~^ WARNING not reporting region error due to nll\n+LL | |     })\n+   | |_____^\n+   |\n+   = help: consider adding an explicit lifetime bound `T: ReFree(DefId(0/0:8 ~ ty_param_closure_outlives_from_where_clause[317d]::wrong_region[0]), BrNamed(crate0:DefIndex(1:20), 'a))`...\n+\n note: External requirements\n   --> $DIR/ty-param-closure-outlives-from-where-clause.rs:89:26\n    |"}, {"sha": "4a693a3b05d4ea1f38770055e1a9857d8b71b25f", "filename": "src/test/ui/span/borrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -26,7 +26,7 @@ error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:102:5\n    |\n LL | fn assign_field2<'a>(x: &'a Own<Point>) {\n-   |                         -------------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n+   |                         -------------- help: consider changing this to be a mutable reference: `&'a mut Own<Point>`\n LL |     x.y = 3; //~ ERROR cannot borrow\n    |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n@@ -58,7 +58,7 @@ error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:143:6\n    |\n LL | fn assign_method2<'a>(x: &'a Own<Point>) {\n-   |                          -------------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n+   |                          -------------- help: consider changing this to be a mutable reference: `&'a mut Own<Point>`\n LL |     *x.y_mut() = 3; //~ ERROR cannot borrow\n    |      ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n "}, {"sha": "44a5062cb4d430f13ab1299268f80c8b6a5bc4f0", "filename": "src/test/ui/span/borrowck-borrow-overloaded-deref-mut.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -10,7 +10,7 @@ error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:51:11\n    |\n LL | fn deref_extend_mut1<'a>(x: &'a Own<isize>) -> &'a mut isize {\n-   |                             -------------- help: consider changing this to be a mutable reference: `&mut Own<isize>`\n+   |                             -------------- help: consider changing this to be a mutable reference: `&'a mut Own<isize>`\n LL |     &mut **x //~ ERROR cannot borrow\n    |           ^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n@@ -26,7 +26,7 @@ error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:63:6\n    |\n LL | fn assign2<'a>(x: &'a Own<isize>) {\n-   |                   -------------- help: consider changing this to be a mutable reference: `&mut Own<isize>`\n+   |                   -------------- help: consider changing this to be a mutable reference: `&'a mut Own<isize>`\n LL |     **x = 3; //~ ERROR cannot borrow\n    |      ^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n "}, {"sha": "76a25fa661ece728276f263d55f84559589eeba4", "filename": "src/test/ui/span/dropck_arr_cycle_checked.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,25 +1,25 @@\n-error[E0597]: `b3` does not live long enough\n-  --> $DIR/dropck_arr_cycle_checked.rs:105:24\n+error[E0597]: `b2` does not live long enough\n+  --> $DIR/dropck_arr_cycle_checked.rs:103:24\n    |\n-LL |     b1.a[1].v.set(Some(&b3));\n+LL |     b1.a[0].v.set(Some(&b2));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `b3` dropped here while still borrowed\n+   | `b2` dropped here while still borrowed\n    | borrow later used here, when `b1` is dropped\n \n-error[E0597]: `b2` does not live long enough\n-  --> $DIR/dropck_arr_cycle_checked.rs:103:24\n+error[E0597]: `b3` does not live long enough\n+  --> $DIR/dropck_arr_cycle_checked.rs:105:24\n    |\n-LL |     b1.a[0].v.set(Some(&b2));\n+LL |     b1.a[1].v.set(Some(&b3));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `b2` dropped here while still borrowed\n+   | `b3` dropped here while still borrowed\n    | borrow later used here, when `b1` is dropped\n \n error[E0597]: `b1` does not live long enough"}, {"sha": "e6f43e0a71b56f5f34ac8db460714b4255a2e951", "filename": "src/test/ui/span/dropck_vec_cycle_checked.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,25 +1,25 @@\n-error[E0597]: `c3` does not live long enough\n-  --> $DIR/dropck_vec_cycle_checked.rs:115:24\n+error[E0597]: `c2` does not live long enough\n+  --> $DIR/dropck_vec_cycle_checked.rs:113:24\n    |\n-LL |     c1.v[1].v.set(Some(&c3));\n+LL |     c1.v[0].v.set(Some(&c2));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `c3` dropped here while still borrowed\n+   | `c2` dropped here while still borrowed\n    | borrow later used here, when `c1` is dropped\n \n-error[E0597]: `c2` does not live long enough\n-  --> $DIR/dropck_vec_cycle_checked.rs:113:24\n+error[E0597]: `c3` does not live long enough\n+  --> $DIR/dropck_vec_cycle_checked.rs:115:24\n    |\n-LL |     c1.v[0].v.set(Some(&c2));\n+LL |     c1.v[1].v.set(Some(&c3));\n    |                        ^^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `c2` dropped here while still borrowed\n+   | `c3` dropped here while still borrowed\n    | borrow later used here, when `c1` is dropped\n \n error[E0597]: `c1` does not live long enough"}, {"sha": "f42cf6500e2ead35b20b5605e5576c8f670f9106", "filename": "src/test/ui/span/mut-arg-hint.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -10,7 +10,7 @@ error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:18:5\n    |\n LL | pub fn foo<'a>(mut a: &'a String) {\n-   |                       ---------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n+   |                       ---------- help: consider changing this to be a mutable reference: `&'a mut String`\n LL |     a.push_str(\"foo\"); //~ ERROR cannot borrow immutable borrowed content\n    |     ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n "}, {"sha": "2a82e1b8ada8c9c26ae4d70599258c83534149a0", "filename": "src/test/ui/span/range-2.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Frange-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Frange-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Frange-2.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,21 +1,21 @@\n-error[E0597]: `b` does not live long enough\n-  --> $DIR/range-2.rs:17:13\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/range-2.rs:17:9\n    |\n LL |         &a..&b\n-   |             ^^ borrowed value does not live long enough\n+   |         ^^ borrowed value does not live long enough\n LL |     };\n-   |     - `b` dropped here while still borrowed\n+   |     - `a` dropped here while still borrowed\n ...\n LL |     r.use_ref();\n    |     - borrow later used here\n \n-error[E0597]: `a` does not live long enough\n-  --> $DIR/range-2.rs:17:9\n+error[E0597]: `b` does not live long enough\n+  --> $DIR/range-2.rs:17:13\n    |\n LL |         &a..&b\n-   |         ^^ borrowed value does not live long enough\n+   |             ^^ borrowed value does not live long enough\n LL |     };\n-   |     - `a` dropped here while still borrowed\n+   |     - `b` dropped here while still borrowed\n ...\n LL |     r.use_ref();\n    |     - borrow later used here"}, {"sha": "4d81211673e6ee014631ed5bcf6b40a74d4fbd60", "filename": "src/test/ui/span/regions-escape-loop-via-vec.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fregions-escape-loop-via-vec.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -20,6 +20,17 @@ LL |         let mut z = x; //~ ERROR cannot use `x` because it was mutably borr\n LL |         _y.push(&mut z);\n    |         -- borrow later used here\n \n+error[E0597]: `z` does not live long enough\n+  --> $DIR/regions-escape-loop-via-vec.rs:17:17\n+   |\n+LL |         _y.push(&mut z);\n+   |         --      ^^^^^^ borrowed value does not live long enough\n+   |         |\n+   |         borrow later used here\n+...\n+LL |     }\n+   |     - `z` dropped here while still borrowed\n+\n error[E0503]: cannot use `x` because it was mutably borrowed\n   --> $DIR/regions-escape-loop-via-vec.rs:19:9\n    |\n@@ -32,17 +43,6 @@ LL |         //~^ ERROR `z` does not live long enough\n LL |         x += 1; //~ ERROR cannot assign\n    |         ^^^^^^ use of borrowed `x`\n \n-error[E0597]: `z` does not live long enough\n-  --> $DIR/regions-escape-loop-via-vec.rs:17:17\n-   |\n-LL |         _y.push(&mut z);\n-   |         --      ^^^^^^ borrowed value does not live long enough\n-   |         |\n-   |         borrow later used here\n-...\n-LL |     }\n-   |     - `z` dropped here while still borrowed\n-\n error: aborting due to 4 previous errors\n \n Some errors occurred: E0503, E0597."}, {"sha": "1753f710b88426b72f92e0d97c3dbb4a136b5b43", "filename": "src/test/ui/span/send-is-not-static-ensures-scoping.nll.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fsend-is-not-static-ensures-scoping.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,3 +1,15 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/send-is-not-static-ensures-scoping.rs:26:17\n+   |\n+LL |         let y = &x;\n+   |                 ^^ borrowed value does not live long enough\n+...\n+LL |     };\n+   |     - `x` dropped here while still borrowed\n+LL | \n+LL |     bad.join();\n+   |     --- borrow later used here\n+\n error[E0597]: `y` does not live long enough\n   --> $DIR/send-is-not-static-ensures-scoping.rs:29:16\n    |\n@@ -13,18 +25,6 @@ LL |\n LL |       bad.join();\n    |       --- borrow later used here\n \n-error[E0597]: `x` does not live long enough\n-  --> $DIR/send-is-not-static-ensures-scoping.rs:26:17\n-   |\n-LL |         let y = &x;\n-   |                 ^^ borrowed value does not live long enough\n-...\n-LL |     };\n-   |     - `x` dropped here while still borrowed\n-LL | \n-LL |     bad.join();\n-   |     --- borrow later used here\n-\n error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0597`."}, {"sha": "60905367063a48d47c82cd3fa96862618ace5e55", "filename": "src/test/ui/span/vec_refs_data_with_early_death.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvec_refs_data_with_early_death.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1,27 +1,27 @@\n-error[E0597]: `y` does not live long enough\n-  --> $DIR/vec_refs_data_with_early_death.rs:29:12\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/vec_refs_data_with_early_death.rs:27:12\n    |\n-LL |     v.push(&y);\n+LL |     v.push(&x);\n    |            ^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `y` dropped here while still borrowed\n+   | `x` dropped here while still borrowed\n    | borrow later used here, when `v` is dropped\n    |\n    = note: values in a scope are dropped in the opposite order they are defined\n \n-error[E0597]: `x` does not live long enough\n-  --> $DIR/vec_refs_data_with_early_death.rs:27:12\n+error[E0597]: `y` does not live long enough\n+  --> $DIR/vec_refs_data_with_early_death.rs:29:12\n    |\n-LL |     v.push(&x);\n+LL |     v.push(&y);\n    |            ^^ borrowed value does not live long enough\n ...\n LL | }\n    | -\n    | |\n-   | `x` dropped here while still borrowed\n+   | `y` dropped here while still borrowed\n    | borrow later used here, when `v` is dropped\n    |\n    = note: values in a scope are dropped in the opposite order they are defined"}, {"sha": "56897baeb4eff8db1f3c8172531cb8a0f01510a7", "filename": "src/test/ui/trivial-bounds-inconsistent-copy-reborrow.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -2,15 +2,15 @@ error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:16:5\n    |\n LL | fn reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                        --------------- help: consider changing this to be a mutable reference: `&mut &mut i32`\n+   |                        --------------- help: consider changing this to be a mutable reference: `&'a mut &'a mut i32`\n LL |     *t //~ ERROR\n    |     ^^ `t` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:20:6\n    |\n LL | fn copy_reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n-   |                             --------------- help: consider changing this to be a mutable reference: `&mut &mut i32`\n+   |                             --------------- help: consider changing this to be a mutable reference: `&'a mut &'a mut i32`\n LL |     {*t} //~ ERROR\n    |      ^^ `t` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n "}, {"sha": "bbce87a7c9adf699d81c27099087c2815cccdc57", "filename": "src/tools/build-manifest/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fbuild-manifest%2Fsrc%2Fmain.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -109,6 +109,7 @@ static TARGETS: &'static [&'static str] = &[\n     \"x86_64-sun-solaris\",\n     \"x86_64-unknown-cloudabi\",\n     \"x86_64-unknown-freebsd\",\n+    \"x86_64-unknown-hermit\",\n     \"x86_64-unknown-linux-gnu\",\n     \"x86_64-unknown-linux-gnux32\",\n     \"x86_64-unknown-linux-musl\","}, {"sha": "b0dabce47803c18b935ec5390de69e04ad5304c2", "filename": "src/tools/clippy", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -1 +1 @@\n-Subproject commit afd91248eda02cf2968e4e02c77b6c10ecd3fd4f\n+Subproject commit b0dabce47803c18b935ec5390de69e04ad5304c2"}, {"sha": "2a716970ca7b9a03edead9992cc41fa2dc203e0b", "filename": "src/tools/compiletest/src/util.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Futil.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -25,6 +25,7 @@ const OS_TABLE: &'static [(&'static str, &'static str)] = &[\n     (\"freebsd\", \"freebsd\"),\n     (\"fuchsia\", \"fuchsia\"),\n     (\"haiku\", \"haiku\"),\n+    (\"hermit\", \"hermit\"),\n     (\"ios\", \"ios\"),\n     (\"l4re\", \"l4re\"),\n     (\"linux\", \"linux\"),"}, {"sha": "40917cc5db0d5f6eba8086615706c1774d4d9793", "filename": "src/tools/error_index_generator/main.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c069ceba81a0fffc1ce95aaf7e8339e11bf2796/src%2Ftools%2Ferror_index_generator%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ferror_index_generator%2Fmain.rs?ref=8c069ceba81a0fffc1ce95aaf7e8339e11bf2796", "patch": "@@ -21,10 +21,11 @@ use std::fs::{read_dir, File};\n use std::io::{Read, Write};\n use std::path::Path;\n use std::path::PathBuf;\n+use std::cell::RefCell;\n \n use syntax::diagnostics::metadata::{get_metadata_dir, ErrorMetadataMap, ErrorMetadata};\n \n-use rustdoc::html::markdown::{Markdown, PLAYGROUND};\n+use rustdoc::html::markdown::{Markdown, IdMap, ErrorCodes, PLAYGROUND};\n use rustc_serialize::json;\n \n enum OutputFormat {\n@@ -36,7 +37,7 @@ enum OutputFormat {\n impl OutputFormat {\n     fn from(format: &str) -> OutputFormat {\n         match &*format.to_lowercase() {\n-            \"html\"     => OutputFormat::HTML(HTMLFormatter),\n+            \"html\"     => OutputFormat::HTML(HTMLFormatter(RefCell::new(IdMap::new()))),\n             \"markdown\" => OutputFormat::Markdown(MarkdownFormatter),\n             s          => OutputFormat::Unknown(s.to_owned()),\n         }\n@@ -51,7 +52,7 @@ trait Formatter {\n     fn footer(&self, output: &mut dyn Write) -> Result<(), Box<dyn Error>>;\n }\n \n-struct HTMLFormatter;\n+struct HTMLFormatter(RefCell<IdMap>);\n struct MarkdownFormatter;\n \n impl Formatter for HTMLFormatter {\n@@ -100,7 +101,11 @@ impl Formatter for HTMLFormatter {\n \n         // Description rendered as markdown.\n         match info.description {\n-            Some(ref desc) => write!(output, \"{}\", Markdown(desc, &[]))?,\n+            Some(ref desc) => {\n+                let mut id_map = self.0.borrow_mut();\n+                write!(output, \"{}\",\n+                    Markdown(desc, &[], RefCell::new(&mut id_map), ErrorCodes::Yes))?\n+            },\n             None => write!(output, \"<p>No description.</p>\\n\")?,\n         }\n "}]}