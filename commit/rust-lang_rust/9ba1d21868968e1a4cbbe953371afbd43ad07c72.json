{"sha": "9ba1d21868968e1a4cbbe953371afbd43ad07c72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliYTFkMjE4Njg5NjhlMWE0Y2JiZTk1MzM3MWFmYmQ0M2FkMDdjNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-09T02:27:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-09T02:27:33Z"}, "message": "Auto merge of #77519 - jyn514:track-doc-er, r=GuillaumeGomez\n\nResolve intra-doc links on additional documentation for re-exports in lexical scope\n\nFixes https://github.com/rust-lang/rust/issues/77254.\n\n- Preserve the parent module of `DocFragment`s\n  + Add `parent_module` to `DocFragment`\n  + Require the `parent_module` of the item being inlined\n  + Preserve the hir_id for ExternCrates so rustdoc can find the parent module later\n  + Take an optional `parent_module` for `build_impl` and `merge_attrs`.\n    Preserve the difference between parent modules for each doc-comment.\n  + Support a single additional re-exports in from_ast. Originally this took a vec but I ended up not using it.\n  + Don't require the parent_module for all `impl`s, just inlined items\n\n    In particular, this will be `None` whenever the attribute is not on a\n    re-export.\n\n  + Only store the parent_module, not the HirId\n\n    When re-exporting a re-export, the HirId is not available. Fortunately,\n    `collect_intra_doc_links` doesn't actually need all the info from a\n    HirId, just the parent module.\n\n- Introduce `Divider`\n\n  This distinguishes between documentation on the original from docs on  the re-export.\n\n- Use the new module information for intra-doc links\n\n  + Make the parent module conditional on whether the docs are on a re-export\n  + Make `resolve_link` take `&Item` instead of `&mut Item`\n\n    Previously the borrow checker gave an error about multiple mutable\n    borrows, because `dox` borrowed from `item`.\n\n  + Fix `crate::` for re-exports\n\n    `crate` means something different depending on where the attribute\n    came from.\n\n  + Make it work for `#[doc]` attributes too\n\n    This required combining several attributes as one so they would keep\n    the links.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "4222a141e26b86266c60ce9c3c8e8f0ee6de2eea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4222a141e26b86266c60ce9c3c8e8f0ee6de2eea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ba1d21868968e1a4cbbe953371afbd43ad07c72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ba1d21868968e1a4cbbe953371afbd43ad07c72", "html_url": "https://github.com/rust-lang/rust/commit/9ba1d21868968e1a4cbbe953371afbd43ad07c72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ba1d21868968e1a4cbbe953371afbd43ad07c72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03ef8a081ef713609a65e71ed41c6775aeb138aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/03ef8a081ef713609a65e71ed41c6775aeb138aa", "html_url": "https://github.com/rust-lang/rust/commit/03ef8a081ef713609a65e71ed41c6775aeb138aa"}, {"sha": "e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9", "html_url": "https://github.com/rust-lang/rust/commit/e39a86019d79d0f2dc5f6cc94fcdf2f073b478e9"}], "stats": {"total": 347, "additions": 235, "deletions": 112}, "files": [{"sha": "a6c754ab67f617b7ce295bf0bbbc02f1fdca1e5c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 40, "deletions": 21, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -15,7 +15,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n \n-use crate::clean::{self, GetDefId, ToSource, TypeKind};\n+use crate::clean::{self, Attributes, GetDefId, ToSource, TypeKind};\n use crate::core::DocContext;\n use crate::doctree;\n \n@@ -35,8 +35,11 @@ type Attrs<'hir> = rustc_middle::ty::Attributes<'hir>;\n ///\n /// The returned value is `None` if the definition could not be inlined,\n /// and `Some` of a vector of items if it was successfully expanded.\n+///\n+/// `parent_module` refers to the parent of the *re-export*, not the original item.\n pub fn try_inline(\n     cx: &DocContext<'_>,\n+    parent_module: DefId,\n     res: Res,\n     name: Symbol,\n     attrs: Option<Attrs<'_>>,\n@@ -48,12 +51,13 @@ pub fn try_inline(\n     }\n     let mut ret = Vec::new();\n \n+    debug!(\"attrs={:?}\", attrs);\n     let attrs_clone = attrs;\n \n     let inner = match res {\n         Res::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n         Res::Def(DefKind::Fn, did) => {\n@@ -62,27 +66,27 @@ pub fn try_inline(\n         }\n         Res::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::StructItem(build_struct(cx, did))\n         }\n         Res::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::UnionItem(build_union(cx, did))\n         }\n         Res::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n         Res::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::EnumItem(build_enum(cx, did))\n         }\n         Res::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n-            ret.extend(build_impls(cx, did, attrs));\n+            ret.extend(build_impls(cx, Some(parent_module), did, attrs));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n@@ -117,7 +121,7 @@ pub fn try_inline(\n     };\n \n     let target_attrs = load_attrs(cx, did);\n-    let attrs = merge_attrs(cx, target_attrs, attrs_clone);\n+    let attrs = merge_attrs(cx, Some(parent_module), target_attrs, attrs_clone);\n \n     cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n@@ -291,40 +295,52 @@ pub fn build_ty(cx: &DocContext<'_>, did: DefId) -> Option<clean::Type> {\n }\n \n /// Builds all inherent implementations of an ADT (struct/union/enum) or Trait item/path/reexport.\n-pub fn build_impls(cx: &DocContext<'_>, did: DefId, attrs: Option<Attrs<'_>>) -> Vec<clean::Item> {\n+pub fn build_impls(\n+    cx: &DocContext<'_>,\n+    parent_module: Option<DefId>,\n+    did: DefId,\n+    attrs: Option<Attrs<'_>>,\n+) -> Vec<clean::Item> {\n     let tcx = cx.tcx;\n     let mut impls = Vec::new();\n \n     // for each implementation of an item represented by `did`, build the clean::Item for that impl\n     for &did in tcx.inherent_impls(did).iter() {\n-        build_impl(cx, did, attrs, &mut impls);\n+        build_impl(cx, parent_module, did, attrs, &mut impls);\n     }\n \n     impls\n }\n \n+/// `parent_module` refers to the parent of the re-export, not the original item\n fn merge_attrs(\n     cx: &DocContext<'_>,\n-    attrs: Attrs<'_>,\n-    other_attrs: Option<Attrs<'_>>,\n+    parent_module: Option<DefId>,\n+    old_attrs: Attrs<'_>,\n+    new_attrs: Option<Attrs<'_>>,\n ) -> clean::Attributes {\n     // NOTE: If we have additional attributes (from a re-export),\n     // always insert them first. This ensure that re-export\n     // doc comments show up before the original doc comments\n     // when we render them.\n-    let merged_attrs = if let Some(inner) = other_attrs {\n-        let mut both = inner.to_vec();\n-        both.extend_from_slice(attrs);\n-        both\n+    if let Some(inner) = new_attrs {\n+        if let Some(new_id) = parent_module {\n+            let diag = cx.sess().diagnostic();\n+            Attributes::from_ast(diag, old_attrs, Some((inner, new_id)))\n+        } else {\n+            let mut both = inner.to_vec();\n+            both.extend_from_slice(old_attrs);\n+            both.clean(cx)\n+        }\n     } else {\n-        attrs.to_vec()\n-    };\n-    merged_attrs.clean(cx)\n+        old_attrs.clean(cx)\n+    }\n }\n \n /// Builds a specific implementation of a type. The `did` could be a type method or trait method.\n pub fn build_impl(\n     cx: &DocContext<'_>,\n+    parent_module: impl Into<Option<DefId>>,\n     did: DefId,\n     attrs: Option<Attrs<'_>>,\n     ret: &mut Vec<clean::Item>,\n@@ -333,7 +349,8 @@ pub fn build_impl(\n         return;\n     }\n \n-    let attrs = merge_attrs(cx, load_attrs(cx, did), attrs);\n+    let attrs = merge_attrs(cx, parent_module.into(), load_attrs(cx, did), attrs);\n+    debug!(\"merged_attrs={:?}\", attrs);\n \n     let tcx = cx.tcx;\n     let associated_trait = tcx.impl_trait_ref(did);\n@@ -499,7 +516,9 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n                             },\n                         )),\n                     });\n-                } else if let Some(i) = try_inline(cx, item.res, item.ident.name, None, visited) {\n+                } else if let Some(i) =\n+                    try_inline(cx, did, item.res, item.ident.name, None, visited)\n+                {\n                     items.extend(i)\n                 }\n             }"}, {"sha": "ca9135cd11a1682a0a68c20d2a55d075028f7d3a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -284,7 +284,7 @@ impl Clean<Item> for doctree::Module<'_> {\n \n impl Clean<Attributes> for [ast::Attribute] {\n     fn clean(&self, cx: &DocContext<'_>) -> Attributes {\n-        Attributes::from_ast(cx.sess().diagnostic(), self)\n+        Attributes::from_ast(cx.sess().diagnostic(), self, None)\n     }\n }\n \n@@ -2205,9 +2205,14 @@ impl Clean<Vec<Item>> for doctree::ExternCrate<'_> {\n \n             let res = Res::Def(DefKind::Mod, DefId { krate: self.cnum, index: CRATE_DEF_INDEX });\n \n-            if let Some(items) =\n-                inline::try_inline(cx, res, self.name, Some(self.attrs), &mut visited)\n-            {\n+            if let Some(items) = inline::try_inline(\n+                cx,\n+                cx.tcx.parent_module(self.hir_id).to_def_id(),\n+                res,\n+                self.name,\n+                Some(self.attrs),\n+                &mut visited,\n+            ) {\n                 return items;\n             }\n         }\n@@ -2268,9 +2273,14 @@ impl Clean<Vec<Item>> for doctree::Import<'_> {\n             }\n             if !denied {\n                 let mut visited = FxHashSet::default();\n-                if let Some(items) =\n-                    inline::try_inline(cx, path.res, name, Some(self.attrs), &mut visited)\n-                {\n+                if let Some(items) = inline::try_inline(\n+                    cx,\n+                    cx.tcx.parent_module(self.id).to_def_id(),\n+                    path.res,\n+                    name,\n+                    Some(self.attrs),\n+                    &mut visited,\n+                ) {\n                     return items;\n                 }\n             }"}, {"sha": "179cf248846a8018d82b3d508dea4c2cc71362a4", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 85, "deletions": 42, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -373,6 +373,11 @@ impl<I: IntoIterator<Item = ast::NestedMetaItem>> NestedAttributesExt for I {\n pub struct DocFragment {\n     pub line: usize,\n     pub span: rustc_span::Span,\n+    /// The module this doc-comment came from.\n+    ///\n+    /// This allows distinguishing between the original documentation and a pub re-export.\n+    /// If it is `None`, the item was not re-exported.\n+    pub parent_module: Option<DefId>,\n     pub doc: String,\n     pub kind: DocFragmentKind,\n }\n@@ -386,6 +391,24 @@ pub enum DocFragmentKind {\n     /// A doc fragment created from a `#[doc(include=\"filename\")]` attribute. Contains both the\n     /// given filename and the file contents.\n     Include { filename: String },\n+    /// A doc fragment used to distinguish between documentation in different modules.\n+    ///\n+    /// In particular, this prevents `collapse_docs` from turning all documentation comments\n+    /// into a single giant attributes even when the item is re-exported with documentation on the re-export.\n+    Divider,\n+}\n+\n+impl DocFragment {\n+    /// Creates a dummy doc-fragment which divides earlier and later fragments.\n+    fn divider() -> Self {\n+        DocFragment {\n+            line: 0,\n+            span: DUMMY_SP,\n+            parent_module: None,\n+            doc: String::new(),\n+            kind: DocFragmentKind::Divider,\n+        }\n+    }\n }\n \n impl<'a> FromIterator<&'a DocFragment> for String {\n@@ -521,57 +544,77 @@ impl Attributes {\n         false\n     }\n \n-    pub fn from_ast(diagnostic: &::rustc_errors::Handler, attrs: &[ast::Attribute]) -> Attributes {\n-        let mut doc_strings = vec![];\n+    pub fn from_ast(\n+        diagnostic: &::rustc_errors::Handler,\n+        attrs: &[ast::Attribute],\n+        additional_attrs: Option<(&[ast::Attribute], DefId)>,\n+    ) -> Attributes {\n+        let doc_strings = RefCell::new(vec![]);\n         let mut sp = None;\n         let mut cfg = Cfg::True;\n         let mut doc_line = 0;\n \n-        let other_attrs = attrs\n-            .iter()\n-            .filter_map(|attr| {\n-                if let Some(value) = attr.doc_str() {\n-                    let value = beautify_doc_string(value);\n-                    let kind = if attr.is_doc_comment() {\n-                        DocFragmentKind::SugaredDoc\n-                    } else {\n-                        DocFragmentKind::RawDoc\n-                    };\n-\n-                    let line = doc_line;\n-                    doc_line += value.lines().count();\n-                    doc_strings.push(DocFragment { line, span: attr.span, doc: value, kind });\n-\n-                    if sp.is_none() {\n-                        sp = Some(attr.span);\n-                    }\n-                    None\n+        let clean_attr = |(attr, parent_module): (&ast::Attribute, _)| {\n+            if let Some(value) = attr.doc_str() {\n+                trace!(\"got doc_str={:?}\", value);\n+                let value = beautify_doc_string(value);\n+                let kind = if attr.is_doc_comment() {\n+                    DocFragmentKind::SugaredDoc\n                 } else {\n-                    if attr.has_name(sym::doc) {\n-                        if let Some(mi) = attr.meta() {\n-                            if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n-                                // Extracted #[doc(cfg(...))]\n-                                match Cfg::parse(cfg_mi) {\n-                                    Ok(new_cfg) => cfg &= new_cfg,\n-                                    Err(e) => diagnostic.span_err(e.span, e.msg),\n-                                }\n-                            } else if let Some((filename, contents)) =\n-                                Attributes::extract_include(&mi)\n-                            {\n-                                let line = doc_line;\n-                                doc_line += contents.lines().count();\n-                                doc_strings.push(DocFragment {\n-                                    line,\n-                                    span: attr.span,\n-                                    doc: contents,\n-                                    kind: DocFragmentKind::Include { filename },\n-                                });\n+                    DocFragmentKind::RawDoc\n+                };\n+\n+                let line = doc_line;\n+                doc_line += value.lines().count();\n+                doc_strings.borrow_mut().push(DocFragment {\n+                    line,\n+                    span: attr.span,\n+                    doc: value,\n+                    kind,\n+                    parent_module,\n+                });\n+\n+                if sp.is_none() {\n+                    sp = Some(attr.span);\n+                }\n+                None\n+            } else {\n+                if attr.has_name(sym::doc) {\n+                    if let Some(mi) = attr.meta() {\n+                        if let Some(cfg_mi) = Attributes::extract_cfg(&mi) {\n+                            // Extracted #[doc(cfg(...))]\n+                            match Cfg::parse(cfg_mi) {\n+                                Ok(new_cfg) => cfg &= new_cfg,\n+                                Err(e) => diagnostic.span_err(e.span, e.msg),\n                             }\n+                        } else if let Some((filename, contents)) = Attributes::extract_include(&mi)\n+                        {\n+                            let line = doc_line;\n+                            doc_line += contents.lines().count();\n+                            doc_strings.borrow_mut().push(DocFragment {\n+                                line,\n+                                span: attr.span,\n+                                doc: contents,\n+                                kind: DocFragmentKind::Include { filename },\n+                                parent_module: parent_module,\n+                            });\n                         }\n                     }\n-                    Some(attr.clone())\n                 }\n+                Some(attr.clone())\n+            }\n+        };\n+\n+        // Additional documentation should be shown before the original documentation\n+        let other_attrs = additional_attrs\n+            .into_iter()\n+            .map(|(attrs, id)| {\n+                doc_strings.borrow_mut().push(DocFragment::divider());\n+                attrs.iter().map(move |attr| (attr, Some(id)))\n             })\n+            .flatten()\n+            .chain(attrs.iter().map(|attr| (attr, None)))\n+            .filter_map(clean_attr)\n             .collect();\n \n         // treat #[target_feature(enable = \"feat\")] attributes as if they were\n@@ -597,7 +640,7 @@ impl Attributes {\n             .map_or(true, |a| a.style == AttrStyle::Inner);\n \n         Attributes {\n-            doc_strings,\n+            doc_strings: doc_strings.into_inner(),\n             other_attrs,\n             cfg: if cfg == Cfg::True { None } else { Some(Arc::new(cfg)) },\n             span: sp,"}, {"sha": "913342e271513f4ce8d9a080501eae32302f035d", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -361,7 +361,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n         let primitive = match *target {\n             ResolvedPath { did, .. } if did.is_local() => continue,\n             ResolvedPath { did, .. } => {\n-                ret.extend(inline::build_impls(cx, did, None));\n+                ret.extend(inline::build_impls(cx, None, did, None));\n                 continue;\n             }\n             _ => match target.primitive_type() {\n@@ -371,7 +371,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n         };\n         for &did in primitive.impls(tcx) {\n             if !did.is_local() {\n-                inline::build_impl(cx, did, None, ret);\n+                inline::build_impl(cx, None, did, None, ret);\n             }\n         }\n     }"}, {"sha": "eb33890fb5fceeb9b16306d00240965cb5dc312f", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -927,7 +927,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n         sp: Span,\n         nested: F,\n     ) {\n-        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs);\n+        let mut attrs = Attributes::from_ast(self.sess.diagnostic(), attrs, None);\n         if let Some(ref cfg) = attrs.cfg {\n             if !cfg.matches(&self.sess.parse_sess, Some(&self.sess.features_untracked())) {\n                 return;"}, {"sha": "6bb9b58bead65422f588509905eaaec8375fc429", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -8,6 +8,7 @@ use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n+use rustc_hir::HirId;\n \n pub struct Module<'hir> {\n     pub name: Option<Symbol>,\n@@ -236,6 +237,7 @@ pub struct Macro<'hir> {\n \n pub struct ExternCrate<'hir> {\n     pub name: Symbol,\n+    pub hir_id: HirId,\n     pub cnum: CrateNum,\n     pub path: Option<String>,\n     pub vis: &'hir hir::Visibility<'hir>,"}, {"sha": "b9be3e2f92b4696653d6a4d48f68750ff0330e89", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -8,7 +8,7 @@ use rustc_hir::def::{\n     Namespace::{self, *},\n     PerNS, Res,\n };\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{CrateNum, DefId};\n use rustc_middle::ty;\n use rustc_resolve::ParentScope;\n use rustc_session::lint::{\n@@ -767,9 +767,6 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             self.mod_ids.push(item.def_id);\n         }\n \n-        let dox = item.attrs.collapsed_doc_value().unwrap_or_else(String::new);\n-        trace!(\"got documentation '{}'\", dox);\n-\n         // find item's parent to resolve `Self` in item's docs below\n         let parent_name = self.cx.as_local_hir_id(item.def_id).and_then(|item_hir| {\n             let parent_hir = self.cx.tcx.hir().get_parent_item(item_hir);\n@@ -807,16 +804,53 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             }\n         });\n \n-        for (ori_link, link_range) in markdown_links(&dox) {\n-            self.resolve_link(\n-                &mut item,\n-                &dox,\n-                &current_item,\n-                parent_node,\n-                &parent_name,\n-                ori_link,\n-                link_range,\n-            );\n+        // We want to resolve in the lexical scope of the documentation.\n+        // In the presence of re-exports, this is not the same as the module of the item.\n+        // Rather than merging all documentation into one, resolve it one attribute at a time\n+        // so we know which module it came from.\n+        let mut attrs = item.attrs.doc_strings.iter().peekable();\n+        while let Some(attr) = attrs.next() {\n+            // `collapse_docs` does not have the behavior we want:\n+            // we want `///` and `#[doc]` to count as the same attribute,\n+            // but currently it will treat them as separate.\n+            // As a workaround, combine all attributes with the same parent module into the same attribute.\n+            let mut combined_docs = attr.doc.clone();\n+            loop {\n+                match attrs.peek() {\n+                    Some(next) if next.parent_module == attr.parent_module => {\n+                        combined_docs.push('\\n');\n+                        combined_docs.push_str(&attrs.next().unwrap().doc);\n+                    }\n+                    _ => break,\n+                }\n+            }\n+            debug!(\"combined_docs={}\", combined_docs);\n+\n+            let (krate, parent_node) = if let Some(id) = attr.parent_module {\n+                trace!(\"docs {:?} came from {:?}\", attr.doc, id);\n+                (id.krate, Some(id))\n+            } else {\n+                trace!(\"no parent found for {:?}\", attr.doc);\n+                (item.def_id.krate, parent_node)\n+            };\n+            // NOTE: if there are links that start in one crate and end in another, this will not resolve them.\n+            // This is a degenerate case and it's not supported by rustdoc.\n+            // FIXME: this will break links that start in `#[doc = ...]` and end as a sugared doc. Should this be supported?\n+            for (ori_link, link_range) in markdown_links(&combined_docs) {\n+                let link = self.resolve_link(\n+                    &item,\n+                    &combined_docs,\n+                    &current_item,\n+                    parent_node,\n+                    &parent_name,\n+                    krate,\n+                    ori_link,\n+                    link_range,\n+                );\n+                if let Some(link) = link {\n+                    item.attrs.links.push(link);\n+                }\n+            }\n         }\n \n         if item.is_mod() && !item.attrs.inner_docs {\n@@ -838,36 +872,37 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n impl LinkCollector<'_, '_> {\n     fn resolve_link(\n         &self,\n-        item: &mut Item,\n+        item: &Item,\n         dox: &str,\n         current_item: &Option<String>,\n         parent_node: Option<DefId>,\n         parent_name: &Option<String>,\n+        krate: CrateNum,\n         ori_link: String,\n         link_range: Option<Range<usize>>,\n-    ) {\n+    ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link);\n \n         // Bail early for real links.\n         if ori_link.contains('/') {\n-            return;\n+            return None;\n         }\n \n         // [] is mostly likely not supposed to be a link\n         if ori_link.is_empty() {\n-            return;\n+            return None;\n         }\n \n         let cx = self.cx;\n         let link = ori_link.replace(\"`\", \"\");\n         let parts = link.split('#').collect::<Vec<_>>();\n         let (link, extra_fragment) = if parts.len() > 2 {\n             anchor_failure(cx, &item, &link, dox, link_range, AnchorFailure::MultipleAnchors);\n-            return;\n+            return None;\n         } else if parts.len() == 2 {\n             if parts[0].trim().is_empty() {\n                 // This is an anchor to an element of the current page, nothing to do in here!\n-                return;\n+                return None;\n             }\n             (parts[0], Some(parts[1].to_owned()))\n         } else {\n@@ -888,7 +923,7 @@ impl LinkCollector<'_, '_> {\n             .trim();\n \n             if path_str.contains(|ch: char| !(ch.is_alphanumeric() || ch == ':' || ch == '_')) {\n-                return;\n+                return None;\n             }\n \n             // We stripped `()` and `!` when parsing the disambiguator.\n@@ -928,7 +963,7 @@ impl LinkCollector<'_, '_> {\n                     link_range,\n                     smallvec![err_kind],\n                 );\n-                return;\n+                return None;\n             };\n \n             // replace `Self` with suitable item's parent name\n@@ -947,7 +982,7 @@ impl LinkCollector<'_, '_> {\n                 // (consider `crate::char`). Instead, change it to `self::`. This works because 'self' is now the crate root.\n                 resolved_self = format!(\"self::{}\", &path_str[\"crate::\".len()..]);\n                 path_str = &resolved_self;\n-                module_id = DefId { krate: item.def_id.krate, index: CRATE_DEF_INDEX };\n+                module_id = DefId { krate, index: CRATE_DEF_INDEX };\n             }\n \n             match self.resolve_with_disambiguator(\n@@ -962,7 +997,7 @@ impl LinkCollector<'_, '_> {\n                 link_range.clone(),\n             ) {\n                 Some(x) => x,\n-                None => return,\n+                None => return None,\n             }\n         };\n \n@@ -986,15 +1021,15 @@ impl LinkCollector<'_, '_> {\n                             link_range,\n                             AnchorFailure::RustdocAnchorConflict(prim),\n                         );\n-                        return;\n+                        return None;\n                     }\n                     res = prim;\n                     fragment = Some(path.to_owned());\n                 } else {\n                     // `[char]` when a `char` module is in scope\n                     let candidates = vec![res, prim];\n                     ambiguity_error(cx, &item, path_str, dox, link_range, candidates);\n-                    return;\n+                    return None;\n                 }\n             }\n         }\n@@ -1018,16 +1053,11 @@ impl LinkCollector<'_, '_> {\n         if let Res::PrimTy(..) = res {\n             match disambiguator {\n                 Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                    item.attrs.links.push(ItemLink {\n-                        link: ori_link,\n-                        link_text,\n-                        did: None,\n-                        fragment,\n-                    });\n+                    Some(ItemLink { link: ori_link, link_text, did: None, fragment })\n                 }\n                 Some(other) => {\n                     report_mismatch(other, Disambiguator::Primitive);\n-                    return;\n+                    None\n                 }\n             }\n         } else {\n@@ -1050,7 +1080,7 @@ impl LinkCollector<'_, '_> {\n                     (actual, Some(Disambiguator::Kind(expected))) if actual == expected => {}\n                     (_, Some(specified @ Disambiguator::Kind(_) | specified @ Disambiguator::Primitive)) => {\n                         report_mismatch(specified, Disambiguator::Kind(kind));\n-                        return;\n+                        return None;\n                     }\n                 }\n             }\n@@ -1073,14 +1103,14 @@ impl LinkCollector<'_, '_> {\n                 }\n             }\n             let id = register_res(cx, res);\n-            item.attrs.links.push(ItemLink { link: ori_link, link_text, did: Some(id), fragment });\n+            Some(ItemLink { link: ori_link, link_text, did: Some(id), fragment })\n         }\n     }\n \n     fn resolve_with_disambiguator(\n         &self,\n         disambiguator: Option<Disambiguator>,\n-        item: &mut Item,\n+        item: &Item,\n         dox: &str,\n         path_str: &str,\n         current_item: &Option<String>,"}, {"sha": "5eb3f98b12371b0686e3249431b9e995a750e2da", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -30,15 +30,15 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     for &cnum in cx.tcx.crates().iter() {\n         for &(did, _) in cx.tcx.all_trait_implementations(cnum).iter() {\n             cx.tcx.sess.time(\"build_extern_trait_impl\", || {\n-                inline::build_impl(cx, did, None, &mut new_items);\n+                inline::build_impl(cx, None, did, None, &mut new_items);\n             });\n         }\n     }\n \n     // Also try to inline primitive impls from other crates.\n     for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n         if !def_id.is_local() {\n-            inline::build_impl(cx, def_id, None, &mut new_items);\n+            inline::build_impl(cx, None, def_id, None, &mut new_items);\n \n             // FIXME(eddyb) is this `doc(hidden)` check needed?\n             if !cx.tcx.get_attrs(def_id).lists(sym::doc).has_word(sym::hidden) {\n@@ -90,7 +90,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         for &impl_node in cx.tcx.hir().trait_impls(trait_did) {\n             let impl_did = cx.tcx.hir().local_def_id(impl_node);\n             cx.tcx.sess.time(\"build_local_trait_impl\", || {\n-                inline::build_impl(cx, impl_did.to_def_id(), None, &mut new_items);\n+                inline::build_impl(cx, None, impl_did.to_def_id(), None, &mut new_items);\n             });\n         }\n     }"}, {"sha": "cbfd2199d9fd6503ea6ec0dd57772ee470e2d194", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -399,6 +399,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.extern_crates.push(ExternCrate {\n                     cnum: self.cx.tcx.extern_mod_stmt_cnum(def_id).unwrap_or(LOCAL_CRATE),\n                     name: ident.name,\n+                    hir_id: item.hir_id,\n                     path: orig_name.map(|x| x.to_string()),\n                     vis: &item.vis,\n                     attrs: &item.attrs,"}, {"sha": "adb072a7ed5552384f3d00139eff000ecdb43f0c", "filename": "src/test/rustdoc/intra-link-reexport-additional-docs.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ba1d21868968e1a4cbbe953371afbd43ad07c72/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-reexport-additional-docs.rs?ref=9ba1d21868968e1a4cbbe953371afbd43ad07c72", "patch": "@@ -0,0 +1,18 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/struct.JoinPathsError.html '//a[@href=\"../foo/fn.with_code.html\"]' 'crate::with_code'\n+/// [crate::with_code]\n+// @has - '//a[@href=\"../foo/fn.with_code.html\"]' 'different text'\n+/// [different text][with_code]\n+// @has - '//a[@href=\"../foo/fn.me_too.html\"]' 'me_too'\n+#[doc = \"[me_too]\"]\n+// @has - '//a[@href=\"../foo/fn.me_three.html\"]' 'reference link'\n+/// This [reference link]\n+#[doc = \"has an attr in the way\"]\n+///\n+/// [reference link]: me_three\n+pub use std::env::JoinPathsError;\n+\n+pub fn with_code() {}\n+pub fn me_too() {}\n+pub fn me_three() {}"}]}