{"sha": "09f53fd45c14a9fb796eca54a8954e943bf09477", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZjUzZmQ0NWMxNGE5ZmI3OTZlY2E1NGE4OTU0ZTk0M2JmMDk0Nzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-14T21:09:40Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2015-02-14T21:09:40Z"}, "message": "Audit integer types in libunicode, libcore/(char, str) and libstd/ascii", "tree": {"sha": "4d89b00f3fba3bdbc3ed8688a83e0e8699ee87c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d89b00f3fba3bdbc3ed8688a83e0e8699ee87c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09f53fd45c14a9fb796eca54a8954e943bf09477", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09f53fd45c14a9fb796eca54a8954e943bf09477", "html_url": "https://github.com/rust-lang/rust/commit/09f53fd45c14a9fb796eca54a8954e943bf09477", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09f53fd45c14a9fb796eca54a8954e943bf09477/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df54632601ee01b1ff0e608d9e33fc865c1f2598", "url": "https://api.github.com/repos/rust-lang/rust/commits/df54632601ee01b1ff0e608d9e33fc865c1f2598", "html_url": "https://github.com/rust-lang/rust/commit/df54632601ee01b1ff0e608d9e33fc865c1f2598"}], "stats": {"total": 281, "additions": 141, "deletions": 140}, "files": [{"sha": "dc8716d1378df6ce3296716f204ad70a444f0c88", "filename": "src/etc/unicode.py", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -366,7 +366,7 @@ def emit_conversions_module(f, lowerupper, upperlower):\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -449,13 +449,13 @@ def emit_charwidth_module(f, width_table):\n \"\"\")\n \n     f.write(\"\"\"\n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n \n@@ -610,7 +610,7 @@ def optimize_width_table(wtable):\n         rf.write(\"\"\"\n /// The version of [Unicode](http://www.unicode.org/)\n /// that the `UnicodeChar` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (%s, %s, %s);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (%s, %s, %s);\n \"\"\" % unicode_version)\n         (canon_decomp, compat_decomp, gencats, combines,\n                 lowerupper, upperlower) = load_unicode_data(\"UnicodeData.txt\")"}, {"sha": "683e450acb230ba84df9e8ce11548c7a647fc6aa", "filename": "src/libcore/char.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -119,16 +119,16 @@ pub fn from_u32(i: u32) -> Option<char> {\n /// ```\n #[inline]\n #[unstable(feature = \"core\", reason = \"pending integer conventions\")]\n-pub fn from_digit(num: uint, radix: uint) -> Option<char> {\n+pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n     if radix > 36 {\n         panic!(\"from_digit: radix is too high (maximum 36)\");\n     }\n     if num < radix {\n         unsafe {\n             if num < 10 {\n-                Some(transmute(('0' as uint + num) as u32))\n+                Some(transmute('0' as u32 + num))\n             } else {\n-                Some(transmute(('a' as uint + num - 10) as u32))\n+                Some(transmute('a' as u32 + num - 10))\n             }\n         }\n     } else {\n@@ -164,7 +164,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -189,7 +189,7 @@ pub trait CharExt {\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape of a character, as `char`s.\n     ///\n@@ -275,7 +275,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 2);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the number of bytes this character would need if encoded in UTF-16.\n     ///\n@@ -287,7 +287,7 @@ pub trait CharExt {\n     /// assert_eq!(n, 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer, and then returns the number\n     /// of bytes written.\n@@ -317,7 +317,7 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer, and then returns the\n     /// number of `u16`s written.\n@@ -347,27 +347,27 @@ pub trait CharExt {\n     /// assert_eq!(result, None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool {\n+    fn is_digit(self, radix: u32) -> bool {\n         self.to_digit(radix).is_some()\n     }\n \n     #[unstable(feature = \"core\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> {\n+    fn to_digit(self, radix: u32) -> Option<u32> {\n         if radix > 36 {\n             panic!(\"to_digit: radix is too high (maximum 36)\");\n         }\n         let val = match self {\n-          '0' ... '9' => self as uint - ('0' as uint),\n-          'a' ... 'z' => self as uint + 10 - ('a' as uint),\n-          'A' ... 'Z' => self as uint + 10 - ('A' as uint),\n+          '0' ... '9' => self as u32 - '0' as u32,\n+          'a' ... 'z' => self as u32 - 'a' as u32 + 10,\n+          'A' ... 'Z' => self as u32 - 'A' as u32 + 10,\n           _ => return None,\n         };\n         if val < radix { Some(val) }\n@@ -396,7 +396,7 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint {\n+    fn len_utf8(self) -> usize {\n         let code = self as u32;\n         match () {\n             _ if code < MAX_ONE_B   => 1,\n@@ -408,22 +408,22 @@ impl CharExt for char {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint {\n+    fn len_utf16(self) -> usize {\n         let ch = self as u32;\n         if (ch & 0xFFFF_u32) == ch { 1 } else { 2 }\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> {\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> {\n         encode_utf8_raw(self as u32, dst)\n     }\n \n     #[inline]\n     #[unstable(feature = \"core\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> {\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> {\n         encode_utf16_raw(self as u32, dst)\n     }\n }\n@@ -435,7 +435,7 @@ impl CharExt for char {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n+pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if code < MAX_ONE_B && dst.len() >= 1 {\n         dst[0] = code as u8;\n@@ -467,7 +467,7 @@ pub fn encode_utf8_raw(code: u32, dst: &mut [u8]) -> Option<uint> {\n /// and a `None` will be returned.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<uint> {\n+pub fn encode_utf16_raw(mut ch: u32, dst: &mut [u16]) -> Option<usize> {\n     // Marked #[inline] to allow llvm optimizing it away\n     if (ch & 0xFFFF_u32) == ch  && dst.len() >= 1 {\n         // The BMP falls through (assuming non-surrogate, as it should)\n@@ -499,7 +499,7 @@ enum EscapeUnicodeState {\n     Backslash,\n     Type,\n     LeftBrace,\n-    Value(uint),\n+    Value(usize),\n     RightBrace,\n     Done,\n }"}, {"sha": "ce26abe606dd4b432e7f85101e41e1de83e507d9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 79, "deletions": 77, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -41,7 +41,7 @@ macro_rules! delegate_iter {\n         delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n-            fn len(&self) -> uint {\n+            fn len(&self) -> usize {\n                 self.0.len()\n             }\n         }\n@@ -56,7 +56,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -78,7 +78,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -100,7 +100,7 @@ macro_rules! delegate_iter {\n                 self.0.next()\n             }\n             #[inline]\n-            fn size_hint(&self) -> (uint, Option<uint>) {\n+            fn size_hint(&self) -> (usize, Option<usize>) {\n                 self.0.size_hint()\n             }\n         }\n@@ -178,7 +178,7 @@ pub enum Utf8Error {\n     /// The offset is guaranteed to be in bounds of the slice in question, and\n     /// the byte at the specified offset was the first invalid byte in the\n     /// sequence detected.\n-    InvalidByte(uint),\n+    InvalidByte(usize),\n \n     /// The byte slice was invalid because more bytes were needed but no more\n     /// bytes were available.\n@@ -227,7 +227,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n     let mut len = 0;\n-    while *s.offset(len as int) != 0 {\n+    while *s.offset(len as isize) != 0 {\n         len += 1;\n     }\n     let v: &'static [u8] = ::mem::transmute(Slice { data: s, len: len });\n@@ -250,7 +250,7 @@ impl CharEq for char {\n     fn matches(&mut self, c: char) -> bool { *self == c }\n \n     #[inline]\n-    fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n+    fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n impl<F> CharEq for F where F: FnMut(char) -> bool {\n@@ -383,7 +383,7 @@ impl<'a> Iterator for Chars<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (len, _) = self.iter.size_hint();\n         (len.saturating_add(3) / 4, Some(len))\n     }\n@@ -428,16 +428,16 @@ impl<'a> DoubleEndedIterator for Chars<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct CharIndices<'a> {\n-    front_offset: uint,\n+    front_offset: usize,\n     iter: Chars<'a>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for CharIndices<'a> {\n-    type Item = (uint, char);\n+    type Item = (usize, char);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, char)> {\n+    fn next(&mut self) -> Option<(usize, char)> {\n         let (pre_len, _) = self.iter.iter.size_hint();\n         match self.iter.next() {\n             None => None,\n@@ -451,15 +451,15 @@ impl<'a> Iterator for CharIndices<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> DoubleEndedIterator for CharIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, char)> {\n+    fn next_back(&mut self) -> Option<(usize, char)> {\n         match self.iter.next_back() {\n             None => None,\n             Some(ch) => {\n@@ -512,7 +512,7 @@ struct CharSplits<'a, Sep> {\n struct CharSplitsN<'a, Sep> {\n     iter: CharSplits<'a, Sep>,\n     /// The number of splits remaining\n-    count: uint,\n+    count: usize,\n     invert: bool,\n }\n \n@@ -636,15 +636,15 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n /// within a larger string using naive search\n #[derive(Clone)]\n struct NaiveSearcher {\n-    position: uint\n+    position: usize\n }\n \n impl NaiveSearcher {\n     fn new() -> NaiveSearcher {\n         NaiveSearcher { position: 0 }\n     }\n \n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n         while self.position + needle.len() <= haystack.len() {\n             if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n@@ -663,13 +663,13 @@ impl NaiveSearcher {\n #[derive(Clone)]\n struct TwoWaySearcher {\n     // constants\n-    crit_pos: uint,\n-    period: uint,\n+    crit_pos: usize,\n+    period: usize,\n     byteset: u64,\n \n     // variables\n-    position: uint,\n-    memory: uint\n+    position: usize,\n+    memory: usize\n }\n \n /*\n@@ -756,7 +756,7 @@ impl TwoWaySearcher {\n \n         // This isn't in the original algorithm, as far as I'm aware.\n         let byteset = needle.iter()\n-                            .fold(0, |a, &b| (1 << ((b & 0x3f) as uint)) | a);\n+                            .fold(0, |a, &b| (1 << ((b & 0x3f) as usize)) | a);\n \n         // A particularly readable explanation of what's going on here can be found\n         // in Crochemore and Rytter's book \"Text Algorithms\", ch 13. Specifically\n@@ -794,7 +794,8 @@ impl TwoWaySearcher {\n     // How far we can jump when we encounter a mismatch is all based on the fact\n     // that (u, v) is a critical factorization for the needle.\n     #[inline]\n-    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool) -> Option<(uint, uint)> {\n+    fn next(&mut self, haystack: &[u8], needle: &[u8], long_period: bool)\n+            -> Option<(usize, usize)> {\n         'search: loop {\n             // Check that we have room to search in\n             if self.position + needle.len() > haystack.len() {\n@@ -804,7 +805,7 @@ impl TwoWaySearcher {\n             // Quickly skip by large portions unrelated to our substring\n             if (self.byteset >>\n                     ((haystack[self.position + needle.len() - 1] & 0x3f)\n-                     as uint)) & 1 == 0 {\n+                     as usize)) & 1 == 0 {\n                 self.position += needle.len();\n                 if !long_period {\n                     self.memory = 0;\n@@ -851,7 +852,7 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n-    fn maximal_suffix(arr: &[u8], reversed: bool) -> (uint, uint) {\n+    fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n         let mut offset = 1; // Corresponds to k in the paper\n@@ -937,16 +938,16 @@ pub struct MatchIndices<'a> {\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n pub struct SplitStr<'a> {\n     it: MatchIndices<'a>,\n-    last_end: uint,\n+    last_end: usize,\n     finished: bool\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for MatchIndices<'a> {\n-    type Item = (uint, uint);\n+    type Item = (usize, usize);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, uint)> {\n+    fn next(&mut self) -> Option<(usize, usize)> {\n         match self.searcher {\n             Naive(ref mut searcher)\n                 => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n@@ -991,8 +992,9 @@ Section: Comparing strings\n /// to compare &[u8] byte slices that are not necessarily valid UTF-8.\n #[inline]\n fn eq_slice_(a: &str, b: &str) -> bool {\n+    // NOTE: In theory n should be libc::size_t and not usize, but libc is not available here\n     #[allow(improper_ctypes)]\n-    extern { fn memcmp(s1: *const i8, s2: *const i8, n: uint) -> i32; }\n+    extern { fn memcmp(s1: *const i8, s2: *const i8, n: usize) -> i32; }\n     a.len() == b.len() && unsafe {\n         memcmp(a.as_ptr() as *const i8,\n                b.as_ptr() as *const i8,\n@@ -1049,7 +1051,7 @@ fn run_utf8_validation_iterator(iter: &mut slice::Iter<u8>)\n         // ASCII characters are always valid, so only large\n         // bytes need more examination.\n         if first >= 128 {\n-            let w = UTF8_CHAR_WIDTH[first as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[first as usize] as usize;\n             let second = next!();\n             // 2-byte encoding is for codepoints  \\u{0080} to  \\u{07ff}\n             //        first  C2 80        last DF BF\n@@ -1124,7 +1126,7 @@ pub struct CharRange {\n     /// Current `char`\n     pub ch: char,\n     /// Index of the first byte of the next `char`\n-    pub next: uint,\n+    pub next: usize,\n }\n \n /// Mask of the value bits of a continuation byte\n@@ -1209,10 +1211,10 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::Range<uint>> for str {\n+    impl ops::Index<ops::Range<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::Range<uint>) -> &str {\n+        fn index(&self, index: &ops::Range<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if index.start <= index.end &&\n                self.is_char_boundary(index.start) &&\n@@ -1232,10 +1234,10 @@ mod traits {\n     /// Panics when `end` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeTo<uint>> for str {\n+    impl ops::Index<ops::RangeTo<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeTo<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.end) {\n                 unsafe { self.slice_unchecked(0, index.end) }\n@@ -1252,10 +1254,10 @@ mod traits {\n     /// Panics when `begin` does not point to a valid character, or is\n     /// out of bounds.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl ops::Index<ops::RangeFrom<uint>> for str {\n+    impl ops::Index<ops::RangeFrom<usize>> for str {\n         type Output = str;\n         #[inline]\n-        fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n+        fn index(&self, index: &ops::RangeFrom<usize>) -> &str {\n             // is_char_boundary checks that the index is in [0, .len()]\n             if self.is_char_boundary(index.start) {\n                 unsafe { self.slice_unchecked(index.start, self.len()) }\n@@ -1332,40 +1334,40 @@ pub trait StrExt {\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n     fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> SplitN<'a, P>;\n+    fn splitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n     fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: uint, pat: P) -> RSplitN<'a, P>;\n+    fn rsplitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n-    fn char_len(&self) -> uint;\n-    fn slice_chars<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n-    unsafe fn slice_unchecked<'a>(&'a self, begin: uint, end: uint) -> &'a str;\n+    fn char_len(&self) -> usize;\n+    fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n+    unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     fn starts_with(&self, pat: &str) -> bool;\n     fn ends_with(&self, pat: &str) -> bool;\n     fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n     fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn is_char_boundary(&self, index: uint) -> bool;\n-    fn char_range_at(&self, start: uint) -> CharRange;\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange;\n-    fn char_at(&self, i: uint) -> char;\n-    fn char_at_reverse(&self, i: uint) -> char;\n+    fn is_char_boundary(&self, index: usize) -> bool;\n+    fn char_range_at(&self, start: usize) -> CharRange;\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange;\n+    fn char_at(&self, i: usize) -> char;\n+    fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<uint>;\n-    fn find_str(&self, pat: &str) -> Option<uint>;\n+    fn find<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize>;\n+    fn find_str(&self, pat: &str) -> Option<usize>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n-    fn subslice_offset(&self, inner: &str) -> uint;\n+    fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n-    fn len(&self) -> uint;\n+    fn len(&self) -> usize;\n     fn is_empty(&self) -> bool;\n     fn parse<T: FromStr>(&self) -> Result<T, T::Err>;\n }\n \n #[inline(never)]\n-fn slice_error_fail(s: &str, begin: uint, end: uint) -> ! {\n+fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n     assert!(begin <= end);\n     panic!(\"index {} and/or {} in `{}` do not lie on character boundary\",\n           begin, end, s);\n@@ -1409,7 +1411,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n+    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1426,7 +1428,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n+    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1470,9 +1472,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_len(&self) -> uint { self.chars().count() }\n+    fn char_len(&self) -> usize { self.chars().count() }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &str {\n+    fn slice_chars(&self, begin: usize, end: usize) -> &str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -1496,9 +1498,9 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n+    unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as int),\n+            data: self.as_ptr().offset(begin as isize),\n             len: end - begin,\n         })\n     }\n@@ -1550,7 +1552,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn is_char_boundary(&self, index: uint) -> bool {\n+    fn is_char_boundary(&self, index: usize) -> bool {\n         if index == self.len() { return true; }\n         match self.as_bytes().get(index) {\n             None => false,\n@@ -1559,13 +1561,13 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_range_at(&self, i: uint) -> CharRange {\n+    fn char_range_at(&self, i: usize) -> CharRange {\n         let (c, n) = char_range_at_raw(self.as_bytes(), i);\n         CharRange { ch: unsafe { mem::transmute(c) }, next: n }\n     }\n \n     #[inline]\n-    fn char_range_at_reverse(&self, start: uint) -> CharRange {\n+    fn char_range_at_reverse(&self, start: usize) -> CharRange {\n         let mut prev = start;\n \n         prev = prev.saturating_sub(1);\n@@ -1574,14 +1576,14 @@ impl StrExt for str {\n         }\n \n         // Multibyte case is a fn to allow char_range_at_reverse to inline cleanly\n-        fn multibyte_char_range_at_reverse(s: &str, mut i: uint) -> CharRange {\n+        fn multibyte_char_range_at_reverse(s: &str, mut i: usize) -> CharRange {\n             // while there is a previous byte == 10......\n             while i > 0 && s.as_bytes()[i] & !CONT_MASK == TAG_CONT_U8 {\n                 i -= 1;\n             }\n \n             let mut val = s.as_bytes()[i] as u32;\n-            let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+            let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n             assert!((w != 0));\n \n             val = utf8_first_byte!(val, w);\n@@ -1596,12 +1598,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn char_at(&self, i: uint) -> char {\n+    fn char_at(&self, i: usize) -> char {\n         self.char_range_at(i).ch\n     }\n \n     #[inline]\n-    fn char_at_reverse(&self, i: uint) -> char {\n+    fn char_at_reverse(&self, i: usize) -> char {\n         self.char_range_at_reverse(i).ch\n     }\n \n@@ -1610,7 +1612,7 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn find<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().position(|b| pat.matches(b as char))\n         } else {\n@@ -1621,7 +1623,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<uint> {\n+    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n         if pat.only_ascii() {\n             self.bytes().rposition(|b| pat.matches(b as char))\n         } else {\n@@ -1632,7 +1634,7 @@ impl StrExt for str {\n         }\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<uint> {\n+    fn find_str(&self, needle: &str) -> Option<usize> {\n         if needle.is_empty() {\n             Some(0)\n         } else {\n@@ -1653,10 +1655,10 @@ impl StrExt for str {\n         }\n     }\n \n-    fn subslice_offset(&self, inner: &str) -> uint {\n-        let a_start = self.as_ptr() as uint;\n+    fn subslice_offset(&self, inner: &str) -> usize {\n+        let a_start = self.as_ptr() as usize;\n         let a_end = a_start + self.len();\n-        let b_start = inner.as_ptr() as uint;\n+        let b_start = inner.as_ptr() as usize;\n         let b_end = b_start + inner.len();\n \n         assert!(a_start <= b_start);\n@@ -1670,7 +1672,7 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn len(&self) -> uint { self.repr().len }\n+    fn len(&self) -> usize { self.repr().len }\n \n     #[inline]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n@@ -1683,15 +1685,15 @@ impl StrExt for str {\n /// index of the next code point.\n #[inline]\n #[unstable(feature = \"core\")]\n-pub fn char_range_at_raw(bytes: &[u8], i: uint) -> (u32, usize) {\n+pub fn char_range_at_raw(bytes: &[u8], i: usize) -> (u32, usize) {\n     if bytes[i] < 128u8 {\n         return (bytes[i] as u32, i + 1);\n     }\n \n     // Multibyte case is a fn to allow char_range_at to inline cleanly\n-    fn multibyte_char_range_at(bytes: &[u8], i: uint) -> (u32, usize) {\n+    fn multibyte_char_range_at(bytes: &[u8], i: usize) -> (u32, usize) {\n         let mut val = bytes[i] as u32;\n-        let w = UTF8_CHAR_WIDTH[val as uint] as uint;\n+        let w = UTF8_CHAR_WIDTH[val as usize] as usize;\n         assert!((w != 0));\n \n         val = utf8_first_byte!(val, w);\n@@ -1718,7 +1720,7 @@ impl<'a> Iterator for Lines<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1734,7 +1736,7 @@ impl<'a> Iterator for LinesAny<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<&'a str> { self.inner.next() }\n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.inner.size_hint() }\n+    fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0a3abd5d1acc3cbe3787d7478d06d77e0dadc598", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -159,12 +159,12 @@ impl AsciiExt for u8 {\n \n     #[inline]\n     fn to_ascii_uppercase(&self) -> u8 {\n-        ASCII_UPPERCASE_MAP[*self as uint]\n+        ASCII_UPPERCASE_MAP[*self as usize]\n     }\n \n     #[inline]\n     fn to_ascii_lowercase(&self) -> u8 {\n-        ASCII_LOWERCASE_MAP[*self as uint]\n+        ASCII_LOWERCASE_MAP[*self as usize]\n     }\n \n     #[inline]"}, {"sha": "deffc1fe8da75a06fe98645f8d308195e7b5abd1", "filename": "src/libunicode/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Flib.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -32,7 +32,6 @@\n #![feature(no_std)]\n #![no_std]\n #![feature(slicing_syntax)]\n-#![feature(int_uint)]\n #![feature(core)]\n \n extern crate core;"}, {"sha": "61f447a3dd3b687a836c4f17f308aabd76ab41ca", "filename": "src/libunicode/tables.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Ftables.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -14,7 +14,7 @@\n \n /// The version of [Unicode](http://www.unicode.org/)\n /// that the unicode parts of `CharExt` and `UnicodeStrPrelude` traits are based on.\n-pub const UNICODE_VERSION: (uint, uint, uint) = (7, 0, 0);\n+pub const UNICODE_VERSION: (u64, u64, u64) = (7, 0, 0);\n \n fn bsearch_range_table(c: char, r: &'static [(char,char)]) -> bool {\n     use core::cmp::Ordering::{Equal, Less, Greater};\n@@ -6977,7 +6977,7 @@ pub mod conversions {\n         }\n     }\n \n-    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<uint> {\n+    fn bsearch_case_table(c: char, table: &'static [(char, char)]) -> Option<usize> {\n         match table.binary_search_by(|&(key, _)| {\n             if c == key { Equal }\n             else if key < c { Less }\n@@ -7613,13 +7613,13 @@ pub mod charwidth {\n         }\n     }\n \n-    pub fn width(c: char, is_cjk: bool) -> Option<uint> {\n-        match c as uint {\n+    pub fn width(c: char, is_cjk: bool) -> Option<usize> {\n+        match c as usize {\n             _c @ 0 => Some(0),          // null is zero width\n             cu if cu < 0x20 => None,    // control sequences have no width\n             cu if cu < 0x7F => Some(1), // ASCII\n             cu if cu < 0xA0 => None,    // more control sequences\n-            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as uint)\n+            _ => Some(bsearch_range_value_table(c, is_cjk, charwidth_table) as usize)\n         }\n     }\n "}, {"sha": "c0f45ca4d7247e948143cc06a86595df4a3a5e09", "filename": "src/libunicode/u_char.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Fu_char.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Fu_char.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_char.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -36,7 +36,7 @@ pub trait CharExt {\n     /// Panics if given a radix > 36.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool;\n+    fn is_digit(self, radix: u32) -> bool;\n \n     /// Converts a character to the corresponding digit.\n     ///\n@@ -51,7 +51,7 @@ pub trait CharExt {\n     /// Panics if given a radix outside the range [0..36].\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint>;\n+    fn to_digit(self, radix: u32) -> Option<u32>;\n \n     /// Returns an iterator that yields the hexadecimal Unicode escape\n     /// of a character, as `char`s.\n@@ -80,12 +80,12 @@ pub trait CharExt {\n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-8.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint;\n+    fn len_utf8(self) -> usize;\n \n     /// Returns the amount of bytes this character would need if encoded in\n     /// UTF-16.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint;\n+    fn len_utf16(self) -> usize;\n \n     /// Encodes this character as UTF-8 into the provided byte buffer,\n     /// and then returns the number of bytes written.\n@@ -94,7 +94,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint>;\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize>;\n \n     /// Encodes this character as UTF-16 into the provided `u16` buffer,\n     /// and then returns the number of `u16`s written.\n@@ -103,7 +103,7 @@ pub trait CharExt {\n     /// and a `None` will be returned.\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint>;\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize>;\n \n     /// Returns whether the specified character is considered a Unicode\n     /// alphabetic code point.\n@@ -216,31 +216,31 @@ pub trait CharExt {\n     /// `is_cjk` = `false`) if the context cannot be reliably determined.\n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint>;\n+    fn width(self, is_cjk: bool) -> Option<usize>;\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl CharExt for char {\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn is_digit(self, radix: uint) -> bool { C::is_digit(self, radix) }\n+    fn is_digit(self, radix: u32) -> bool { C::is_digit(self, radix) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending integer conventions\")]\n-    fn to_digit(self, radix: uint) -> Option<uint> { C::to_digit(self, radix) }\n+    fn to_digit(self, radix: u32) -> Option<u32> { C::to_digit(self, radix) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_unicode(self) -> char::EscapeUnicode { C::escape_unicode(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn escape_default(self) -> char::EscapeDefault { C::escape_default(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf8(self) -> uint { C::len_utf8(self) }\n+    fn len_utf8(self) -> usize { C::len_utf8(self) }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn len_utf16(self) -> uint { C::len_utf16(self) }\n+    fn len_utf16(self) -> usize { C::len_utf16(self) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf8(self, dst: &mut [u8]) -> Option<uint> { C::encode_utf8(self, dst) }\n+    fn encode_utf8(self, dst: &mut [u8]) -> Option<usize> { C::encode_utf8(self, dst) }\n     #[unstable(feature = \"unicode\",\n                reason = \"pending decision about Iterator/Writer/Reader\")]\n-    fn encode_utf16(self, dst: &mut [u16]) -> Option<uint> { C::encode_utf16(self, dst) }\n+    fn encode_utf16(self, dst: &mut [u16]) -> Option<usize> { C::encode_utf16(self, dst) }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn is_alphabetic(self) -> bool {\n@@ -313,5 +313,5 @@ impl CharExt for char {\n \n     #[unstable(feature = \"unicode\",\n                reason = \"needs expert opinion. is_cjk flag stands out as ugly\")]\n-    fn width(self, is_cjk: bool) -> Option<uint> { charwidth::width(self, is_cjk) }\n+    fn width(self, is_cjk: bool) -> Option<usize> { charwidth::width(self, is_cjk) }\n }"}, {"sha": "9bd8c5525a056828966e0838637722518d0370f6", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09f53fd45c14a9fb796eca54a8954e943bf09477/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=09f53fd45c14a9fb796eca54a8954e943bf09477", "patch": "@@ -43,7 +43,7 @@ pub trait UnicodeStr {\n     fn words<'a>(&'a self) -> Words<'a>;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn width(&self, is_cjk: bool) -> uint;\n+    fn width(&self, is_cjk: bool) -> usize;\n     fn trim<'a>(&'a self) -> &'a str;\n     fn trim_left<'a>(&'a self) -> &'a str;\n     fn trim_right<'a>(&'a self) -> &'a str;\n@@ -57,7 +57,7 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        GraphemeIndices { start_offset: self.as_ptr() as uint, iter: self.graphemes(is_extended) }\n+        GraphemeIndices { start_offset: self.as_ptr() as usize, iter: self.graphemes(is_extended) }\n     }\n \n     #[inline]\n@@ -78,7 +78,7 @@ impl UnicodeStr for str {\n     fn is_alphanumeric(&self) -> bool { self.chars().all(|c| c.is_alphanumeric()) }\n \n     #[inline]\n-    fn width(&self, is_cjk: bool) -> uint {\n+    fn width(&self, is_cjk: bool) -> usize {\n         self.chars().map(|c| c.width(is_cjk).unwrap_or(0)).sum()\n     }\n \n@@ -101,28 +101,28 @@ impl UnicodeStr for str {\n /// External iterator for grapheme clusters and byte offsets.\n #[derive(Clone)]\n pub struct GraphemeIndices<'a> {\n-    start_offset: uint,\n+    start_offset: usize,\n     iter: Graphemes<'a>,\n }\n \n impl<'a> Iterator for GraphemeIndices<'a> {\n-    type Item = (uint, &'a str);\n+    type Item = (usize, &'a str);\n \n     #[inline]\n-    fn next(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n }\n \n impl<'a> DoubleEndedIterator for GraphemeIndices<'a> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<(uint, &'a str)> {\n-        self.iter.next_back().map(|s| (s.as_ptr() as uint - self.start_offset, s))\n+    fn next_back(&mut self) -> Option<(usize, &'a str)> {\n+        self.iter.next_back().map(|s| (s.as_ptr() as usize - self.start_offset, s))\n     }\n }\n \n@@ -151,7 +151,7 @@ impl<'a> Iterator for Graphemes<'a> {\n     type Item = &'a str;\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let slen = self.string.len();\n         (cmp::min(slen, 1), Some(slen))\n     }\n@@ -378,8 +378,8 @@ static UTF8_CHAR_WIDTH: [u8; 256] = [\n \n /// Given a first byte, determine how many bytes are in this UTF-8 character\n #[inline]\n-pub fn utf8_char_width(b: u8) -> uint {\n-    return UTF8_CHAR_WIDTH[b as uint] as uint;\n+pub fn utf8_char_width(b: u8) -> usize {\n+    return UTF8_CHAR_WIDTH[b as usize] as usize;\n }\n \n /// Determines if a vector of `u16` contains valid UTF-16\n@@ -468,7 +468,7 @@ impl<'a> Iterator for Utf16Items<'a> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.iter.size_hint();\n         // we could be entirely valid surrogates (2 elements per\n         // char), or entirely non-surrogates (1 element per char)\n@@ -534,7 +534,7 @@ impl<I> Iterator for Utf16Encoder<I> where I: Iterator<Item=char> {\n     }\n \n     #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n         let (low, high) = self.chars.size_hint();\n         // every char gets either one u16 or two u16,\n         // so this iterator is between 1 or 2 times as"}]}