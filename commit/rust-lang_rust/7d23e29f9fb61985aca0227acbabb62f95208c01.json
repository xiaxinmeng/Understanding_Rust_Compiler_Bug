{"sha": "7d23e29f9fb61985aca0227acbabb62f95208c01", "node_id": "C_kwDOAAsO6NoAKDdkMjNlMjlmOWZiNjE5ODVhY2EwMjI3YWNiYWJiNjJmOTUyMDhjMDE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-07T20:30:42Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-08T04:59:10Z"}, "message": "Pull out logic into distinct functions", "tree": {"sha": "ab55f3a542900404040835e8513434288e9763f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab55f3a542900404040835e8513434288e9763f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d23e29f9fb61985aca0227acbabb62f95208c01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d23e29f9fb61985aca0227acbabb62f95208c01", "html_url": "https://github.com/rust-lang/rust/commit/7d23e29f9fb61985aca0227acbabb62f95208c01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d23e29f9fb61985aca0227acbabb62f95208c01/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57b722688d03fc8115987375eee1d076cc89bc68", "url": "https://api.github.com/repos/rust-lang/rust/commits/57b722688d03fc8115987375eee1d076cc89bc68", "html_url": "https://github.com/rust-lang/rust/commit/57b722688d03fc8115987375eee1d076cc89bc68"}], "stats": {"total": 349, "additions": 165, "deletions": 184}, "files": [{"sha": "f4672a70072b2b30ce8435d350d898bfa2e8c4c3", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 165, "deletions": 184, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/7d23e29f9fb61985aca0227acbabb62f95208c01/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d23e29f9fb61985aca0227acbabb62f95208c01/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=7d23e29f9fb61985aca0227acbabb62f95208c01", "patch": "@@ -1,3 +1,4 @@\n+use hir::def_id::DefId;\n use rustc_hir as hir;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n@@ -6,7 +7,7 @@ use rustc_middle::ty::layout::{\n     IntegerExt, LayoutCx, LayoutError, LayoutOf, TyAndLayout, MAX_SIMD_LANES,\n };\n use rustc_middle::ty::{\n-    self, subst::SubstsRef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n+    self, subst::SubstsRef, AdtDef, EarlyBinder, ReprOptions, Ty, TyCtxt, TypeVisitable,\n };\n use rustc_session::{DataTypeKind, FieldInfo, SizeKind, VariantInfo};\n use rustc_span::symbol::Symbol;\n@@ -815,206 +816,186 @@ fn record_layout_for_printing_outlined<'tcx>(\n     };\n \n     match *layout.ty.kind() {\n-        ty::Adt(ref adt_def, _) => {\n+        ty::Adt(adt_def, _) => {\n             debug!(\"print-type-size t: `{:?}` process adt\", layout.ty);\n             let adt_kind = adt_def.adt_kind();\n             let adt_packed = adt_def.repr().pack.is_some();\n-\n-            let build_variant_info =\n-                |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n-                    let mut min_size = Size::ZERO;\n-                    let field_info: Vec<_> = flds\n-                        .iter()\n-                        .enumerate()\n-                        .map(|(i, &name)| {\n-                            let field_layout = layout.field(cx, i);\n-                            let offset = layout.fields.offset(i);\n-                            min_size = min_size.max(offset + field_layout.size);\n-                            FieldInfo {\n-                                name,\n-                                offset: offset.bytes(),\n-                                size: field_layout.size.bytes(),\n-                                align: field_layout.align.abi.bytes(),\n-                            }\n-                        })\n-                        .collect();\n-\n-                    VariantInfo {\n-                        name: n,\n-                        kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n-                        align: layout.align.abi.bytes(),\n-                        size: if min_size.bytes() == 0 {\n-                            layout.size.bytes()\n-                        } else {\n-                            min_size.bytes()\n-                        },\n-                        fields: field_info,\n-                    }\n-                };\n-\n-            match layout.variants {\n-                Variants::Single { index } => {\n-                    if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n-                        debug!(\n-                            \"print-type-size `{:#?}` variant {}\",\n-                            layout,\n-                            adt_def.variant(index).name\n-                        );\n-                        let variant_def = &adt_def.variant(index);\n-                        let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n-                        record(\n-                            adt_kind.into(),\n-                            adt_packed,\n-                            None,\n-                            vec![build_variant_info(Some(variant_def.name), &fields, layout)],\n-                        );\n-                    } else {\n-                        // (This case arises for *empty* enums; so give it\n-                        // zero variants.)\n-                        record(adt_kind.into(), adt_packed, None, vec![]);\n-                    }\n-                }\n-\n-                Variants::Multiple { tag, ref tag_encoding, .. } => {\n-                    debug!(\n-                        \"print-type-size `{:#?}` adt general variants def {}\",\n-                        layout.ty,\n-                        adt_def.variants().len()\n-                    );\n-                    let variant_infos: Vec<_> = adt_def\n-                        .variants()\n-                        .iter_enumerated()\n-                        .map(|(i, variant_def)| {\n-                            let fields: Vec<_> =\n-                                variant_def.fields.iter().map(|f| f.name).collect();\n-                            build_variant_info(\n-                                Some(variant_def.name),\n-                                &fields,\n-                                layout.for_variant(cx, i),\n-                            )\n-                        })\n-                        .collect();\n-                    record(\n-                        adt_kind.into(),\n-                        adt_packed,\n-                        match tag_encoding {\n-                            TagEncoding::Direct => Some(tag.size(cx)),\n-                            _ => None,\n-                        },\n-                        variant_infos,\n-                    );\n-                }\n-            }\n+            let (variant_infos, opt_discr_size) = variant_info_for_adt(cx, layout, adt_def);\n+            record(adt_kind.into(), adt_packed, opt_discr_size, variant_infos);\n         }\n \n         ty::Generator(def_id, substs, _) => {\n             debug!(\"print-type-size t: `{:?}` record generator\", layout.ty);\n             // Generators always have a begin/poisoned/end state with additional suspend points\n-            match layout.variants {\n-                Variants::Multiple { tag, ref tag_encoding, .. } => {\n-                    let (generator, state_specific_names) =\n-                        cx.tcx.generator_layout_and_saved_local_names(def_id);\n-                    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n-\n-                    let mut upvars_size = Size::ZERO;\n-                    let upvar_fields: Vec<_> = substs\n-                        .as_generator()\n-                        .upvar_tys()\n-                        .zip(upvar_names)\n-                        .enumerate()\n-                        .map(|(field_idx, (_, name))| {\n-                            let field_layout = layout.field(cx, field_idx);\n-                            let offset = layout.fields.offset(field_idx);\n-                            upvars_size = upvars_size.max(offset + field_layout.size);\n-                            FieldInfo {\n-                                name: Symbol::intern(&name),\n-                                offset: offset.bytes(),\n-                                size: field_layout.size.bytes(),\n-                                align: field_layout.align.abi.bytes(),\n-                            }\n-                        })\n-                        .collect();\n-\n-                    let variant_infos: Vec<_> = generator\n-                        .variant_fields\n-                        .iter_enumerated()\n-                        .map(|(variant_idx, variant_def)| {\n-                            let variant_layout = layout.for_variant(cx, variant_idx);\n-                            let mut variant_size = Size::ZERO;\n-                            let fields = variant_def\n-                                .iter()\n-                                .enumerate()\n-                                .map(|(field_idx, local)| {\n-                                    let field_layout = variant_layout.field(cx, field_idx);\n-                                    let offset = variant_layout.fields.offset(field_idx);\n-                                    // The struct is as large as the last field's end\n-                                    variant_size = variant_size.max(offset + field_layout.size);\n-                                    FieldInfo {\n-                                        name: state_specific_names\n-                                            .get(*local)\n-                                            .copied()\n-                                            .flatten()\n-                                            .unwrap_or(Symbol::intern(&format!(\n-                                                \".generator_field{}\",\n-                                                local.as_usize()\n-                                            ))),\n-                                        offset: offset.bytes(),\n-                                        size: field_layout.size.bytes(),\n-                                        align: field_layout.align.abi.bytes(),\n-                                    }\n-                                })\n-                                .chain(upvar_fields.iter().copied())\n-                                .collect();\n-\n-                            // If the variant has no state-specific fields, then it's the size of the upvars.\n-                            if variant_size == Size::ZERO {\n-                                variant_size = upvars_size;\n-                            }\n-                            // We need to add the discriminant size back into min_size, since it is subtracted\n-                            // later during printing.\n-                            variant_size += match tag_encoding {\n-                                TagEncoding::Direct => tag.size(cx),\n-                                _ => Size::ZERO,\n-                            };\n-\n-                            VariantInfo {\n-                                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(\n-                                    variant_idx,\n-                                ))),\n-                                kind: SizeKind::Exact,\n-                                size: variant_size.bytes(),\n-                                align: variant_layout.align.abi.bytes(),\n-                                fields,\n-                            }\n-                        })\n-                        .collect();\n-                    record(\n-                        DataTypeKind::Generator,\n-                        false,\n-                        match tag_encoding {\n-                            TagEncoding::Direct => Some(tag.size(cx)),\n-                            _ => None,\n-                        },\n-                        variant_infos,\n-                    );\n-                }\n-                _ => {\n-                    // This should never happen, but I would rather not panic.\n-                    record(DataTypeKind::Generator, false, None, vec![]);\n-                    return;\n-                }\n-            }\n+            let (variant_infos, opt_discr_size) =\n+                variant_info_for_generator(cx, layout, def_id, substs);\n+            record(DataTypeKind::Generator, false, opt_discr_size, variant_infos);\n         }\n \n         ty::Closure(..) => {\n             debug!(\"print-type-size t: `{:?}` record closure\", layout.ty);\n             record(DataTypeKind::Closure, false, None, vec![]);\n-            return;\n         }\n \n         _ => {\n             debug!(\"print-type-size t: `{:?}` skip non-nominal\", layout.ty);\n-            return;\n         }\n     };\n }\n+\n+fn variant_info_for_adt<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    adt_def: AdtDef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n+    let build_variant_info = |n: Option<Symbol>, flds: &[Symbol], layout: TyAndLayout<'tcx>| {\n+        let mut min_size = Size::ZERO;\n+        let field_info: Vec<_> = flds\n+            .iter()\n+            .enumerate()\n+            .map(|(i, &name)| {\n+                let field_layout = layout.field(cx, i);\n+                let offset = layout.fields.offset(i);\n+                min_size = min_size.max(offset + field_layout.size);\n+                FieldInfo {\n+                    name,\n+                    offset: offset.bytes(),\n+                    size: field_layout.size.bytes(),\n+                    align: field_layout.align.abi.bytes(),\n+                }\n+            })\n+            .collect();\n+\n+        VariantInfo {\n+            name: n,\n+            kind: if layout.is_unsized() { SizeKind::Min } else { SizeKind::Exact },\n+            align: layout.align.abi.bytes(),\n+            size: if min_size.bytes() == 0 { layout.size.bytes() } else { min_size.bytes() },\n+            fields: field_info,\n+        }\n+    };\n+\n+    match layout.variants {\n+        Variants::Single { index } => {\n+            if !adt_def.variants().is_empty() && layout.fields != FieldsShape::Primitive {\n+                debug!(\"print-type-size `{:#?}` variant {}\", layout, adt_def.variant(index).name);\n+                let variant_def = &adt_def.variant(index);\n+                let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n+                (vec![build_variant_info(Some(variant_def.name), &fields, layout)], None)\n+            } else {\n+                (vec![], None)\n+            }\n+        }\n+\n+        Variants::Multiple { tag, ref tag_encoding, .. } => {\n+            debug!(\n+                \"print-type-size `{:#?}` adt general variants def {}\",\n+                layout.ty,\n+                adt_def.variants().len()\n+            );\n+            let variant_infos: Vec<_> = adt_def\n+                .variants()\n+                .iter_enumerated()\n+                .map(|(i, variant_def)| {\n+                    let fields: Vec<_> = variant_def.fields.iter().map(|f| f.name).collect();\n+                    build_variant_info(Some(variant_def.name), &fields, layout.for_variant(cx, i))\n+                })\n+                .collect();\n+\n+            (\n+                variant_infos,\n+                match tag_encoding {\n+                    TagEncoding::Direct => Some(tag.size(cx)),\n+                    _ => None,\n+                },\n+            )\n+        }\n+    }\n+}\n+\n+fn variant_info_for_generator<'tcx>(\n+    cx: &LayoutCx<'tcx, TyCtxt<'tcx>>,\n+    layout: TyAndLayout<'tcx>,\n+    def_id: DefId,\n+    substs: ty::SubstsRef<'tcx>,\n+) -> (Vec<VariantInfo>, Option<Size>) {\n+    let Variants::Multiple { tag, ref tag_encoding, .. } = layout.variants else {\n+        return (vec![], None);\n+    };\n+\n+    let (generator, state_specific_names) = cx.tcx.generator_layout_and_saved_local_names(def_id);\n+    let upvar_names = cx.tcx.closure_saved_names_of_captured_variables(def_id);\n+\n+    let mut upvars_size = Size::ZERO;\n+    let upvar_fields: Vec<_> = substs\n+        .as_generator()\n+        .upvar_tys()\n+        .zip(upvar_names)\n+        .enumerate()\n+        .map(|(field_idx, (_, name))| {\n+            let field_layout = layout.field(cx, field_idx);\n+            let offset = layout.fields.offset(field_idx);\n+            upvars_size = upvars_size.max(offset + field_layout.size);\n+            FieldInfo {\n+                name: Symbol::intern(&name),\n+                offset: offset.bytes(),\n+                size: field_layout.size.bytes(),\n+                align: field_layout.align.abi.bytes(),\n+            }\n+        })\n+        .collect();\n+\n+    let variant_infos: Vec<_> = generator\n+        .variant_fields\n+        .iter_enumerated()\n+        .map(|(variant_idx, variant_def)| {\n+            let variant_layout = layout.for_variant(cx, variant_idx);\n+            let mut variant_size = Size::ZERO;\n+            let fields = variant_def\n+                .iter()\n+                .enumerate()\n+                .map(|(field_idx, local)| {\n+                    let field_layout = variant_layout.field(cx, field_idx);\n+                    let offset = variant_layout.fields.offset(field_idx);\n+                    // The struct is as large as the last field's end\n+                    variant_size = variant_size.max(offset + field_layout.size);\n+                    FieldInfo {\n+                        name: state_specific_names.get(*local).copied().flatten().unwrap_or(\n+                            Symbol::intern(&format!(\".generator_field{}\", local.as_usize())),\n+                        ),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size.bytes(),\n+                        align: field_layout.align.abi.bytes(),\n+                    }\n+                })\n+                .chain(upvar_fields.iter().copied())\n+                .collect();\n+\n+            // If the variant has no state-specific fields, then it's the size of the upvars.\n+            if variant_size == Size::ZERO {\n+                variant_size = upvars_size;\n+            }\n+            // We need to add the discriminant size back into min_size, since it is subtracted\n+            // later during printing.\n+            variant_size += match tag_encoding {\n+                TagEncoding::Direct => tag.size(cx),\n+                _ => Size::ZERO,\n+            };\n+\n+            VariantInfo {\n+                name: Some(Symbol::intern(&ty::GeneratorSubsts::variant_name(variant_idx))),\n+                kind: SizeKind::Exact,\n+                size: variant_size.bytes(),\n+                align: variant_layout.align.abi.bytes(),\n+                fields,\n+            }\n+        })\n+        .collect();\n+    (\n+        variant_infos,\n+        match tag_encoding {\n+            TagEncoding::Direct => Some(tag.size(cx)),\n+            _ => None,\n+        },\n+    )\n+}"}]}