{"sha": "9c5a45044af4dd6b7d539b57be120ef158da9c84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNWE0NTA0NGFmNGRkNmI3ZDUzOWI1N2JlMTIwZWYxNThkYTljODQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-25T13:58:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-28T23:47:03Z"}, "message": "port `fold_regions` and friends to use debruijn indices directly\n\nThey no longer talk about plain integers.\n\nCo-authored-by: csmoe <35686186+csmoe@users.noreply.github.com>", "tree": {"sha": "67b10f880347e33878cca48b2bba48d3d904246d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67b10f880347e33878cca48b2bba48d3d904246d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c5a45044af4dd6b7d539b57be120ef158da9c84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5a45044af4dd6b7d539b57be120ef158da9c84", "html_url": "https://github.com/rust-lang/rust/commit/9c5a45044af4dd6b7d539b57be120ef158da9c84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c5a45044af4dd6b7d539b57be120ef158da9c84/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69ab6f2995cf445df7016f89f54220e7438f4f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/69ab6f2995cf445df7016f89f54220e7438f4f37", "html_url": "https://github.com/rust-lang/rust/commit/69ab6f2995cf445df7016f89f54220e7438f4f37"}], "stats": {"total": 175, "additions": 125, "deletions": 50}, "files": [{"sha": "47fc8d96b55501697c386fbe3862a256aadcf22f", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=9c5a45044af4dd6b7d539b57be120ef158da9c84", "patch": "@@ -473,7 +473,7 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             _ => true\n         });\n \n-        fldr(region, ty::DebruijnIndex::new(current_depth))\n+        fldr(region, current_depth)\n     })\n }\n \n@@ -734,7 +734,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // trait checking, and all of the skolemized regions\n                     // appear inside predicates, which always have\n                     // binders, so this assert is satisfied.\n-                    assert!(current_depth > 1);\n+                    assert!(current_depth > ty::DebruijnIndex::INNERMOST);\n \n                     // since leak-check passed, this skolemized region\n                     // should only have incoming edges from variables\n@@ -750,7 +750,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         r, br);\n \n                     self.tcx.mk_region(ty::ReLateBound(\n-                        ty::DebruijnIndex::new(current_depth - 1), br.clone()))\n+                        current_depth.shifted_out(1),\n+                        br.clone(),\n+                    ))\n                 }\n             }\n         });"}, {"sha": "df8fd102cc54c1bfa9585d84ec3f013722c731ea", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 68, "deletions": 40, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=9c5a45044af4dd6b7d539b57be120ef158da9c84", "patch": "@@ -66,6 +66,15 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.visit_with(&mut HasEscapingRegionsVisitor { depth: depth })\n     }\n+\n+    /// True if `self` has any late-bound regions that are either\n+    /// bound by `binder` or bound by some binder outside of `binder`.\n+    /// If `binder` is `ty::DebruijnIndex::INNERMOST`, this indicates whether\n+    /// there are any late-bound regions that appear free.\n+    fn has_regions_bound_by_or_escaping(&self, binder: ty::DebruijnIndex) -> bool {\n+        self.has_regions_escaping_depth(binder.depth - 1)\n+    }\n+\n     fn has_escaping_regions(&self) -> bool {\n         self.has_regions_escaping_depth(0)\n     }\n@@ -207,7 +216,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     {\n         let mut have_bound_regions = false;\n         self.fold_regions(value, &mut have_bound_regions, |r, d| {\n-            region_set.insert(self.mk_region(r.from_depth(d)));\n+            region_set.insert(self.mk_region(r.shifted_out_to_binder(d)));\n             r\n         });\n         have_bound_regions\n@@ -216,13 +225,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Folds the escaping and free regions in `value` using `f`, and\n     /// sets `skipped_regions` to true if any late-bound region was found\n     /// and skipped.\n-    pub fn fold_regions<T,F>(self,\n+    pub fn fold_regions<T>(\n+        self,\n         value: &T,\n         skipped_regions: &mut bool,\n-        mut f: F)\n-        -> T\n-        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>,\n-              T : TypeFoldable<'tcx>,\n+        mut f: impl FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n+    ) -> T\n+    where\n+        T : TypeFoldable<'tcx>,\n     {\n         value.fold_with(&mut RegionFolder::new(self, skipped_regions, &mut f))\n     }\n@@ -277,21 +287,32 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n pub struct RegionFolder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     skipped_regions: &'a mut bool,\n-    current_depth: u32,\n-    fld_r: &'a mut (dyn FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx> + 'a),\n+\n+    /// Stores the index of a binder *just outside* the stuff we have\n+    /// visited.  So this begins as INNERMOST; when we pass through a\n+    /// binder, it is incremented (via `shift_in`).\n+    current_index: ty::DebruijnIndex,\n+\n+    /// Callback invokes for each free region. The `DebruijnIndex`\n+    /// points to the binder *just outside* the ones we have passed\n+    /// through.\n+    fold_region_fn: &'a mut (dyn FnMut(\n+        ty::Region<'tcx>,\n+        ty::DebruijnIndex,\n+    ) -> ty::Region<'tcx> + 'a),\n }\n \n impl<'a, 'gcx, 'tcx> RegionFolder<'a, 'gcx, 'tcx> {\n-    pub fn new<F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                  skipped_regions: &'a mut bool,\n-                  fld_r: &'a mut F) -> RegionFolder<'a, 'gcx, 'tcx>\n-        where F : FnMut(ty::Region<'tcx>, u32) -> ty::Region<'tcx>\n-    {\n+    pub fn new(\n+        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+        skipped_regions: &'a mut bool,\n+        fold_region_fn: &'a mut dyn FnMut(ty::Region<'tcx>, ty::DebruijnIndex) -> ty::Region<'tcx>,\n+    ) -> RegionFolder<'a, 'gcx, 'tcx> {\n         RegionFolder {\n             tcx,\n             skipped_regions,\n-            current_depth: 1,\n-            fld_r,\n+            current_index: ty::DebruijnIndex::INNERMOST,\n+            fold_region_fn,\n         }\n     }\n }\n@@ -300,24 +321,24 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.current_depth += 1;\n+        self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n-        self.current_depth -= 1;\n+        self.current_index.shift_out(1);\n         t\n     }\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n-                debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current depth={})\",\n-                       r, self.current_depth);\n+            ty::ReLateBound(debruijn, _) if debruijn < self.current_index => {\n+                debug!(\"RegionFolder.fold_region({:?}) skipped bound region (current index={:?})\",\n+                       r, self.current_index);\n                 *self.skipped_regions = true;\n                 r\n             }\n             _ => {\n-                debug!(\"RegionFolder.fold_region({:?}) folding free region (current_depth={})\",\n-                       r, self.current_depth);\n-                (self.fld_r)(r, self.current_depth)\n+                debug!(\"RegionFolder.fold_region({:?}) folding free region (current_index={:?})\",\n+                       r, self.current_index);\n+                (self.fold_region_fn)(r, self.current_index)\n             }\n         }\n     }\n@@ -330,7 +351,11 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionFolder<'a, 'gcx, 'tcx> {\n \n struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    current_depth: u32,\n+\n+    /// As with `RegionFolder`, represents the index of a binder *just outside*\n+    /// the ones we have visited.\n+    current_index: ty::DebruijnIndex,\n+\n     fld_r: &'a mut (dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx> + 'a),\n     map: BTreeMap<ty::BoundRegion, ty::Region<'tcx>>\n }\n@@ -372,20 +397,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }).0\n     }\n \n-    /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n+    /// Flattens multiple binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n     pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n                                          -> Binder<T>\n         where T: TypeFoldable<'tcx>\n     {\n         let bound0_value = bound2_value.skip_binder().skip_binder();\n-        let value = self.fold_regions(bound0_value, &mut false,\n-                                      |region, current_depth| {\n+        let value = self.fold_regions(bound0_value, &mut false, |region, current_depth| {\n             match *region {\n-                ty::ReLateBound(debruijn, br) if debruijn.depth >= current_depth => {\n-                    // should be true if no escaping regions from bound2_value\n-                    assert!(debruijn.depth - current_depth <= 1);\n-                    self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(current_depth), br))\n+                ty::ReLateBound(debruijn, br) => {\n+                    // We assume no regions bound *outside* of the\n+                    // binders in `bound2_value` (nmatsakis added in\n+                    // the course of this PR; seems like a reasonable\n+                    // sanity check though).\n+                    assert!(debruijn == current_depth);\n+                    self.mk_region(ty::ReLateBound(current_depth, br))\n                 }\n                 _ => {\n                     region\n@@ -446,7 +473,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let mut counter = 0;\n         Binder::bind(self.replace_late_bound_regions(sig, |_| {\n             counter += 1;\n-            self.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(counter)))\n+            self.mk_region(ty::ReLateBound(ty::DebruijnIndex::INNERMOST, ty::BrAnon(counter)))\n         }).0)\n     }\n }\n@@ -458,7 +485,7 @@ impl<'a, 'gcx, 'tcx> RegionReplacer<'a, 'gcx, 'tcx> {\n     {\n         RegionReplacer {\n             tcx,\n-            current_depth: 1,\n+            current_index: ty::DebruijnIndex::INNERMOST,\n             fld_r,\n             map: BTreeMap::default()\n         }\n@@ -469,14 +496,14 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n     fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.tcx }\n \n     fn fold_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T> {\n-        self.current_depth += 1;\n+        self.current_index.shift_in(1);\n         let t = t.super_fold_with(self);\n-        self.current_depth -= 1;\n+        self.current_index.shift_out(1);\n         t\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.has_regions_escaping_depth(self.current_depth-1) {\n+        if !t.has_regions_bound_by_or_escaping(self.current_index) {\n             return t;\n         }\n \n@@ -485,14 +512,15 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for RegionReplacer<'a, 'gcx, 'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match *r {\n-            ty::ReLateBound(debruijn, br) if debruijn.depth == self.current_depth => {\n+            ty::ReLateBound(debruijn, br) if debruijn == self.current_index => {\n                 let fld_r = &mut self.fld_r;\n                 let region = *self.map.entry(br).or_insert_with(|| fld_r(br));\n                 if let ty::ReLateBound(debruijn1, br) = *region {\n                     // If the callback returns a late-bound region,\n-                    // that region should always use depth 1. Then we\n-                    // adjust it to the correct depth.\n-                    assert_eq!(debruijn1.depth, 1);\n+                    // that region should always use the INNERMOST\n+                    // debruijn index. Then we adjust it to the\n+                    // correct depth.\n+                    assert_eq!(debruijn1, ty::DebruijnIndex::INNERMOST);\n                     self.tcx.mk_region(ty::ReLateBound(debruijn, br))\n                 } else {\n                     region"}, {"sha": "7e45d8a22698936a3e99f32bdf436e4907a4cc93", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9c5a45044af4dd6b7d539b57be120ef158da9c84", "patch": "@@ -1259,6 +1259,8 @@ impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n }\n \n impl DebruijnIndex {\n+    pub const INNERMOST: DebruijnIndex = DebruijnIndex { depth: 1 };\n+\n     pub fn new(depth: u32) -> DebruijnIndex {\n         assert!(depth > 0);\n         DebruijnIndex { depth: depth }\n@@ -1296,6 +1298,30 @@ impl DebruijnIndex {\n     pub fn shift_out(&mut self, amount: u32) {\n         *self = self.shifted_out(amount);\n     }\n+\n+    /// Adjusts any Debruijn Indices so as to make `to_binder` the\n+    /// innermost binder. That is, if we have something bound at `to_binder`,\n+    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n+    /// when moving a region out from inside binders:\n+    ///\n+    /// ```\n+    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n+    /// // Binder:  D3           D2        D1            ^^\n+    /// ```\n+    ///\n+    /// Here, the region `'a` would have the debruijn index D3,\n+    /// because it is the bound 3 binders out. However, if we wanted\n+    /// to refer to that region `'a` in the second argument (the `_`),\n+    /// those two binders would not be in scope. In that case, we\n+    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n+    /// debruijn index of `'a` to D1 (the innermost binder).\n+    ///\n+    /// If we invoke `shift_out_to_binder` and the region is in fact\n+    /// bound by one of the binders we are shifting out of, that is an\n+    /// error (and should fail an assertion failure).\n+    pub fn shifted_out_to_binder(self, to_binder: DebruijnIndex) -> Self {\n+        self.shifted_out(to_binder.depth - Self::INNERMOST.depth)\n+    }\n }\n \n /// Region utilities\n@@ -1314,12 +1340,32 @@ impl RegionKind {\n         }\n     }\n \n-    /// Returns the depth of `self` from the (1-based) binding level `depth`\n-    pub fn from_depth(&self, depth: u32) -> RegionKind {\n+    /// Adjusts any Debruijn Indices so as to make `to_binder` the\n+    /// innermost binder. That is, if we have something bound at `to_binder`,\n+    /// it will now be bound at INNERMOST. This is an appropriate thing to do\n+    /// when moving a region out from inside binders:\n+    ///\n+    /// ```\n+    ///             for<'a>   fn(for<'b>   for<'c>   fn(&'a u32), _)\n+    /// // Binder:  D3           D2        D1            ^^\n+    /// ```\n+    ///\n+    /// Here, the region `'a` would have the debruijn index D3,\n+    /// because it is the bound 3 binders out. However, if we wanted\n+    /// to refer to that region `'a` in the second argument (the `_`),\n+    /// those two binders would not be in scope. In that case, we\n+    /// might invoke `shift_out_to_binder(D3)`. This would adjust the\n+    /// debruijn index of `'a` to D1 (the innermost binder).\n+    ///\n+    /// If we invoke `shift_out_to_binder` and the region is in fact\n+    /// bound by one of the binders we are shifting out of, that is an\n+    /// error (and should fail an assertion failure).\n+    pub fn shifted_out_to_binder(&self, to_binder: ty::DebruijnIndex) -> RegionKind {\n         match *self {\n-            ty::ReLateBound(debruijn, r) => ty::ReLateBound(DebruijnIndex {\n-                depth: debruijn.depth - (depth - 1)\n-            }, r),\n+            ty::ReLateBound(debruijn, r) => ty::ReLateBound(\n+                debruijn.shifted_out_to_binder(to_binder),\n+                r,\n+            ),\n             r => r\n         }\n     }"}, {"sha": "e234e2f01925f1422f22a705ff8e3b6ad49310e7", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c5a45044af4dd6b7d539b57be120ef158da9c84/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=9c5a45044af4dd6b7d539b57be120ef158da9c84", "patch": "@@ -125,8 +125,7 @@ pub fn resolve_interior<'a, 'gcx, 'tcx>(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     let mut counter = 0;\n     let type_list = fcx.tcx.fold_regions(&type_list, &mut false, |_, current_depth| {\n         counter += 1;\n-        fcx.tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(current_depth),\n-                                        ty::BrAnon(counter)))\n+        fcx.tcx.mk_region(ty::ReLateBound(current_depth, ty::BrAnon(counter)))\n     });\n \n     let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));"}]}