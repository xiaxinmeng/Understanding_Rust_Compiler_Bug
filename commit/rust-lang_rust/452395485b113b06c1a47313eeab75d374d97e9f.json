{"sha": "452395485b113b06c1a47313eeab75d374d97e9f", "node_id": "C_kwDOAAsO6NoAKDQ1MjM5NTQ4NWIxMTNiMDZjMWE0NzMxM2VlYWI3NWQzNzRkOTdlOWY", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-06-05T19:45:04Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-08-19T14:31:41Z"}, "message": "Move `MapClone` into `Methods` lint pass", "tree": {"sha": "36f858f32a6a29c49c2ff33f2a7f10151ea705be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36f858f32a6a29c49c2ff33f2a7f10151ea705be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/452395485b113b06c1a47313eeab75d374d97e9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/452395485b113b06c1a47313eeab75d374d97e9f", "html_url": "https://github.com/rust-lang/rust/commit/452395485b113b06c1a47313eeab75d374d97e9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/452395485b113b06c1a47313eeab75d374d97e9f/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bc8813cdd4f33f42c4dc17572d148c284d3e81b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc8813cdd4f33f42c4dc17572d148c284d3e81b", "html_url": "https://github.com/rust-lang/rust/commit/5bc8813cdd4f33f42c4dc17572d148c284d3e81b"}], "stats": {"total": 332, "additions": 159, "deletions": 173}, "files": [{"sha": "c496fd289bb8607cd8b71b69a00b1e27e37cd98e", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -127,7 +127,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(manual_rem_euclid::MANUAL_REM_EUCLID),\n     LintId::of(manual_retain::MANUAL_RETAIN),\n     LintId::of(manual_strip::MANUAL_STRIP),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n     LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n@@ -179,6 +178,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n     LintId::of(methods::MANUAL_SPLIT_ONCE),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),"}, {"sha": "c7ea7f703f2fbe5de551b3ecc6e75544a835a067", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -246,7 +246,6 @@ store.register_lints(&[\n     manual_rem_euclid::MANUAL_REM_EUCLID,\n     manual_retain::MANUAL_RETAIN,\n     manual_strip::MANUAL_STRIP,\n-    map_clone::MAP_CLONE,\n     map_err_ignore::MAP_ERR_IGNORE,\n     map_unit_fn::OPTION_MAP_UNIT_FN,\n     map_unit_fn::RESULT_MAP_UNIT_FN,\n@@ -325,6 +324,7 @@ store.register_lints(&[\n     methods::MANUAL_SATURATING_ARITHMETIC,\n     methods::MANUAL_SPLIT_ONCE,\n     methods::MANUAL_STR_REPEAT,\n+    methods::MAP_CLONE,\n     methods::MAP_COLLECT_RESULT_UNIT,\n     methods::MAP_FLATTEN,\n     methods::MAP_IDENTITY,"}, {"sha": "52bf019c82e9135d071f3452f5401843f75ce2c8", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -45,7 +45,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(manual_bits::MANUAL_BITS),\n     LintId::of(manual_empty_string_creations::MANUAL_EMPTY_STRING_CREATIONS),\n     LintId::of(manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n-    LintId::of(map_clone::MAP_CLONE),\n     LintId::of(match_result_ok::MATCH_RESULT_OK),\n     LintId::of(matches::COLLAPSIBLE_MATCH),\n     LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -69,6 +68,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(methods::ITER_NTH_ZERO),\n     LintId::of(methods::ITER_SKIP_NEXT),\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n+    LintId::of(methods::MAP_CLONE),\n     LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n     LintId::of(methods::NEW_RET_NO_SELF),\n     LintId::of(methods::OBFUSCATED_IF_ELSE),"}, {"sha": "8f31e4b938c7978a7e7acdcbc51cfb507d773fb0", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -273,7 +273,6 @@ mod manual_non_exhaustive;\n mod manual_rem_euclid;\n mod manual_retain;\n mod manual_strip;\n-mod map_clone;\n mod map_err_ignore;\n mod map_unit_fn;\n mod match_result_ok;\n@@ -628,8 +627,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(needless_question_mark::NeedlessQuestionMark));\n     store.register_late_pass(move || Box::new(casts::Casts::new(msrv)));\n     store.register_early_pass(move || Box::new(unnested_or_patterns::UnnestedOrPatterns::new(msrv)));\n-    store.register_late_pass(move || Box::new(map_clone::MapClone::new(msrv)));\n-\n     store.register_late_pass(|| Box::new(size_of_in_element_count::SizeOfInElementCount));\n     store.register_late_pass(|| Box::new(same_name_method::SameNameMethod));\n     let max_suggested_slice_pattern_length = conf.max_suggested_slice_pattern_length;"}, {"sha": "95c312f1fe26b19216c0573697d3ca5cca040920", "filename": "clippy_lints/src/map_clone.rs", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5bc8813cdd4f33f42c4dc17572d148c284d3e81b/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bc8813cdd4f33f42c4dc17572d148c284d3e81b/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=5bc8813cdd4f33f42c4dc17572d148c284d3e81b", "patch": "@@ -1,167 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n-use clippy_utils::{is_trait_method, meets_msrv, msrvs, peel_blocks};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::mir::Mutability;\n-use rustc_middle::ty;\n-use rustc_middle::ty::adjustment::Adjust;\n-use rustc_semver::RustcVersion;\n-use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Checks for usage of `map(|x| x.clone())` or\n-    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n-    /// and suggests `cloned()` or `copied()` instead\n-    ///\n-    /// ### Why is this bad?\n-    /// Readability, this can be written more concisely\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.map(|i| *i);\n-    /// ```\n-    ///\n-    /// The correct use would be:\n-    ///\n-    /// ```rust\n-    /// let x = vec![42, 43];\n-    /// let y = x.iter();\n-    /// let z = y.cloned();\n-    /// ```\n-    #[clippy::version = \"pre 1.29.0\"]\n-    pub MAP_CLONE,\n-    style,\n-    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n-}\n-\n-pub struct MapClone {\n-    msrv: Option<RustcVersion>,\n-}\n-\n-impl_lint_pass!(MapClone => [MAP_CLONE]);\n-\n-impl MapClone {\n-    pub fn new(msrv: Option<RustcVersion>) -> Self {\n-        Self { msrv }\n-    }\n-}\n-\n-impl<'tcx> LateLintPass<'tcx> for MapClone {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, e: &hir::Expr<'_>) {\n-        if e.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let hir::ExprKind::MethodCall(method, args, _) = e.kind;\n-            if args.len() == 2;\n-            if method.ident.name == sym::map;\n-            let ty = cx.typeck_results().expr_ty(&args[0]);\n-            if is_type_diagnostic_item(cx, ty, sym::Option) || is_trait_method(cx, e, sym::Iterator);\n-            if let hir::ExprKind::Closure(&hir::Closure { body, .. }) = args[1].kind;\n-            then {\n-                let closure_body = cx.tcx.hir().body(body);\n-                let closure_expr = peel_blocks(&closure_body.value);\n-                match closure_body.params[0].pat.kind {\n-                    hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n-                        hir::BindingAnnotation::Unannotated, .., name, None\n-                    ) = inner.kind {\n-                        if ident_eq(name, closure_expr) {\n-                            self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                        }\n-                    },\n-                    hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n-                        match closure_expr.kind {\n-                            hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n-                                if ident_eq(name, inner) {\n-                                    if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n-                                        self.lint_explicit_closure(cx, e.span, args[0].span, true);\n-                                    }\n-                                }\n-                            },\n-                            hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n-                                if ident_eq(name, obj) && method.ident.name == sym::clone;\n-                                if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n-                                if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n-                                if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n-                                // no autoderefs\n-                                if !cx.typeck_results().expr_adjustments(obj).iter()\n-                                    .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n-                                then {\n-                                    let obj_ty = cx.typeck_results().expr_ty(obj);\n-                                    if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n-                                        if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, *ty);\n-                                            self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n-                                        }\n-                                    } else {\n-                                        lint_needless_cloning(cx, e.span, args[0].span);\n-                                    }\n-                                }\n-                            },\n-                            _ => {},\n-                        }\n-                    },\n-                    _ => {},\n-                }\n-            }\n-        }\n-    }\n-\n-    extract_msrv_attr!(LateContext);\n-}\n-\n-fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n-    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n-        path.segments.len() == 1 && path.segments[0].ident == name\n-    } else {\n-        false\n-    }\n-}\n-\n-fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n-    span_lint_and_sugg(\n-        cx,\n-        MAP_CLONE,\n-        root.trim_start(receiver).unwrap(),\n-        \"you are needlessly cloning iterator elements\",\n-        \"remove the `map` call\",\n-        String::new(),\n-        Applicability::MachineApplicable,\n-    );\n-}\n-\n-impl MapClone {\n-    fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n-        let mut applicability = Applicability::MachineApplicable;\n-\n-        let (message, sugg_method) = if is_copy && meets_msrv(self.msrv, msrvs::ITERATOR_COPIED) {\n-            (\"you are using an explicit closure for copying elements\", \"copied\")\n-        } else {\n-            (\"you are using an explicit closure for cloning elements\", \"cloned\")\n-        };\n-\n-        span_lint_and_sugg(\n-            cx,\n-            MAP_CLONE,\n-            replace,\n-            message,\n-            &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n-            format!(\n-                \"{}.{}()\",\n-                snippet_with_applicability(cx, root, \"..\", &mut applicability),\n-                sugg_method,\n-            ),\n-            applicability,\n-        );\n-    }\n-}"}, {"sha": "ffedda95ff8e57870170c940bebf4933f107e3e4", "filename": "clippy_lints/src/methods/map_clone.rs", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_clone.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -0,0 +1,122 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_copy, is_type_diagnostic_item};\n+use clippy_utils::{is_diag_trait_item, meets_msrv, msrvs, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::mir::Mutability;\n+use rustc_middle::ty;\n+use rustc_middle::ty::adjustment::Adjust;\n+use rustc_semver::RustcVersion;\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, Span};\n+\n+use super::MAP_CLONE;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'_>,\n+    e: &hir::Expr<'_>,\n+    recv: &hir::Expr<'_>,\n+    arg: &'tcx hir::Expr<'_>,\n+    msrv: Option<RustcVersion>,\n+) {\n+    if_chain! {\n+        if let Some(method_id) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n+        if cx.tcx.impl_of_method(method_id)\n+            .map_or(false, |id| is_type_diagnostic_item(cx, cx.tcx.type_of(id), sym::Option))\n+            || is_diag_trait_item(cx, method_id, sym::Iterator);\n+        if let hir::ExprKind::Closure(&hir::Closure{ body, .. }) = arg.kind;\n+        then {\n+            let closure_body = cx.tcx.hir().body(body);\n+            let closure_expr = peel_blocks(&closure_body.value);\n+            match closure_body.params[0].pat.kind {\n+                hir::PatKind::Ref(inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n+                    hir::BindingAnnotation::Unannotated, .., name, None\n+                ) = inner.kind {\n+                    if ident_eq(name, closure_expr) {\n+                        lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                    }\n+                },\n+                hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, .., name, None) => {\n+                    match closure_expr.kind {\n+                        hir::ExprKind::Unary(hir::UnOp::Deref, inner) => {\n+                            if ident_eq(name, inner) {\n+                                if let ty::Ref(.., Mutability::Not) = cx.typeck_results().expr_ty(inner).kind() {\n+                                    lint_explicit_closure(cx, e.span, recv.span, true, msrv);\n+                                }\n+                            }\n+                        },\n+                        hir::ExprKind::MethodCall(method, [obj], _) => if_chain! {\n+                            if ident_eq(name, obj) && method.ident.name == sym::clone;\n+                            if let Some(fn_id) = cx.typeck_results().type_dependent_def_id(closure_expr.hir_id);\n+                            if let Some(trait_id) = cx.tcx.trait_of_item(fn_id);\n+                            if cx.tcx.lang_items().clone_trait().map_or(false, |id| id == trait_id);\n+                            // no autoderefs\n+                            if !cx.typeck_results().expr_adjustments(obj).iter()\n+                                .any(|a| matches!(a.kind, Adjust::Deref(Some(..))));\n+                            then {\n+                                let obj_ty = cx.typeck_results().expr_ty(obj);\n+                                if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n+                                    if matches!(mutability, Mutability::Not) {\n+                                        let copy = is_copy(cx, *ty);\n+                                        lint_explicit_closure(cx, e.span, recv.span, copy, msrv);\n+                                    }\n+                                } else {\n+                                    lint_needless_cloning(cx, e.span, recv.span);\n+                                }\n+                            }\n+                        },\n+                        _ => {},\n+                    }\n+                },\n+                _ => {},\n+            }\n+        }\n+    }\n+}\n+\n+fn ident_eq(name: Ident, path: &hir::Expr<'_>) -> bool {\n+    if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = path.kind {\n+        path.segments.len() == 1 && path.segments[0].ident == name\n+    } else {\n+        false\n+    }\n+}\n+\n+fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        root.trim_start(receiver).unwrap(),\n+        \"you are needlessly cloning iterator elements\",\n+        \"remove the `map` call\",\n+        String::new(),\n+        Applicability::MachineApplicable,\n+    );\n+}\n+\n+fn lint_explicit_closure(cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool, msrv: Option<RustcVersion>) {\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    let (message, sugg_method) = if is_copy && meets_msrv(msrv, msrvs::ITERATOR_COPIED) {\n+        (\"you are using an explicit closure for copying elements\", \"copied\")\n+    } else {\n+        (\"you are using an explicit closure for cloning elements\", \"cloned\")\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MAP_CLONE,\n+        replace,\n+        message,\n+        &format!(\"consider calling the dedicated `{}` method\", sugg_method),\n+        format!(\n+            \"{}.{}()\",\n+            snippet_with_applicability(cx, root, \"..\", &mut applicability),\n+            sugg_method,\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "02592da1aae9eba15a55cff437bba414eb4917e9", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/452395485b113b06c1a47313eeab75d374d97e9f/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=452395485b113b06c1a47313eeab75d374d97e9f", "patch": "@@ -45,6 +45,7 @@ mod iterator_step_by_zero;\n mod manual_ok_or;\n mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n+mod map_clone;\n mod map_collect_result_unit;\n mod map_flatten;\n mod map_identity;\n@@ -2511,6 +2512,35 @@ declare_clippy_lint! {\n     \"finds patterns that can be encoded more concisely with `Option::ok_or`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for usage of `map(|x| x.clone())` or\n+    /// dereferencing closures for `Copy` types, on `Iterator` or `Option`,\n+    /// and suggests `cloned()` or `copied()` instead\n+    ///\n+    /// ### Why is this bad?\n+    /// Readability, this can be written more concisely\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.map(|i| *i);\n+    /// ```\n+    ///\n+    /// The correct use would be:\n+    ///\n+    /// ```rust\n+    /// let x = vec![42, 43];\n+    /// let y = x.iter();\n+    /// let z = y.cloned();\n+    /// ```\n+    #[clippy::version = \"pre 1.29.0\"]\n+    pub MAP_CLONE,\n+    style,\n+    \"using `iterator.map(|x| x.clone())`, or dereferencing closures for `Copy` types\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2620,6 +2650,7 @@ impl_lint_pass!(Methods => [\n     CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n     GET_FIRST,\n     MANUAL_OK_OR,\n+    MAP_CLONE,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2949,6 +2980,9 @@ impl Methods {\n                     }\n                 },\n                 (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n+                    if name == \"map\" {\n+                        map_clone::check(cx, expr, recv, m_arg, self.msrv);\n+                    }\n                     if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n                         match (name, args) {\n                             (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),"}]}