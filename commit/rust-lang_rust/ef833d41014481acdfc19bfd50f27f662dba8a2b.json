{"sha": "ef833d41014481acdfc19bfd50f27f662dba8a2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmODMzZDQxMDE0NDgxYWNkZmMxOWJmZDUwZjI3ZjY2MmRiYThhMmI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-17T03:22:48Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-11-21T20:44:51Z"}, "message": "Introduce a T_err type for type errors\n\nThis allows more errors to be non-fatal, as per #1871.\n\nI only went through and started changing span_fatal to span_err in\ncheck.rs. There are probably more errors that could be made\nnon-fatal. So if you see derived type errors appearing from now on,\nfile a bug!\n\nr=graydon\n\nCloses #1871", "tree": {"sha": "33d854748f777d562f64c94d45b0b79f6ff1945c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33d854748f777d562f64c94d45b0b79f6ff1945c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef833d41014481acdfc19bfd50f27f662dba8a2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef833d41014481acdfc19bfd50f27f662dba8a2b", "html_url": "https://github.com/rust-lang/rust/commit/ef833d41014481acdfc19bfd50f27f662dba8a2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef833d41014481acdfc19bfd50f27f662dba8a2b/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77ef4e717667ddbe925a81efc85994662183a445", "url": "https://api.github.com/repos/rust-lang/rust/commits/77ef4e717667ddbe925a81efc85994662183a445", "html_url": "https://github.com/rust-lang/rust/commit/77ef4e717667ddbe925a81efc85994662183a445"}], "stats": {"total": 402, "additions": 256, "deletions": 146}, "files": [{"sha": "232fb7c3b3d7446b32ab8d3f286311f47ebf4cf4", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -318,6 +318,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n           debug!(\"~~~~ %s\", ~\"]\");\n           w.write_char(']');\n       }\n+      ty::ty_err => fail ~\"Shouldn't encode error type\"\n     }\n }\n "}, {"sha": "5c4380ffe85f0886f6b9c6ad5e63501b06e20327", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -266,6 +266,7 @@ impl reflector {\n           // Miscallaneous extra types\n           ty::ty_trait(_, _, _) => self.leaf(~\"trait\"),\n           ty::ty_infer(_) => self.leaf(~\"infer\"),\n+          ty::ty_err => self.leaf(~\"err\"),\n           ty::ty_param(p) => self.visit(~\"param\", ~[self.c_uint(p.idx)]),\n           ty::ty_self => self.leaf(~\"self\"),\n           ty::ty_type => self.leaf(~\"type\"),"}, {"sha": "604bad2312f724d802aeefd8db40602b203c7f48", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -179,6 +179,7 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n       ty::ty_param(*) => cx.tcx.sess.bug(~\"type_of with ty_param\"),\n+      ty::ty_err(*) => cx.tcx.sess.bug(~\"type_of with ty_err\")\n     };\n \n     cx.lltypes.insert(t, llty);"}, {"sha": "cb567028ac99cd703e721549c99f7cfaa9be81d6", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -57,7 +57,7 @@ export lookup_item_type;\n export lookup_public_fields;\n export method;\n export method_idx;\n-export mk_class;\n+export mk_class, mk_err;\n export mk_ctxt;\n export mk_with_id, type_def_id;\n export mt;\n@@ -87,6 +87,7 @@ export ty_fn_proto, ty_fn_purity, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n export mk_f32, mk_f64;\n+export ty_err;\n export ty_estr, mk_estr, type_is_str;\n export ty_evec, mk_evec, type_is_vec;\n export ty_unboxed_vec, mk_unboxed_vec, mk_mut_unboxed_vec;\n@@ -127,7 +128,7 @@ export kind_is_owned;\n export meta_kind, kind_lteq, type_kind;\n export operators;\n export type_err, terr_vstore_kind;\n-export terr_onceness_mismatch;\n+export terr_mismatch, terr_onceness_mismatch;\n export type_err_to_str, note_and_explain_type_err;\n export expected_found;\n export type_needs_drop;\n@@ -673,6 +674,9 @@ enum sty {\n     ty_self, // special, implicit `self` type parameter\n \n     ty_infer(InferTy), // soething used only during inference/typeck\n+    ty_err, // Also only used during inference/typeck, to represent\n+            // the type of an erroneous expression (helps cut down\n+            // on non-useful type error messages)\n \n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n@@ -1062,7 +1066,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n-      ty_opaque_box => (),\n+      ty_opaque_box | ty_err => (),\n       ty_param(_) => flags |= has_params as uint,\n       ty_infer(_) => flags |= needs_infer as uint,\n       ty_self => flags |= has_self as uint,\n@@ -1094,6 +1098,8 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n \n fn mk_nil(cx: ctxt) -> t { mk_t(cx, ty_nil) }\n \n+fn mk_err(cx: ctxt) -> t { mk_t(cx, ty_err) }\n+\n fn mk_bot(cx: ctxt) -> t { mk_t(cx, ty_bot) }\n \n fn mk_bool(cx: ctxt) -> t { mk_t(cx, ty_bool) }\n@@ -1301,7 +1307,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_estr(_) | ty_type | ty_opaque_box | ty_self |\n-      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) => {\n+      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n       }\n       ty_box(tm) | ty_evec(tm, _) | ty_unboxed_vec(tm) |\n       ty_ptr(tm) | ty_rptr(_, tm) => {\n@@ -1386,7 +1392,7 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             ty_class(did, fold_substs(substs, fldop))\n         }\n         ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n+        ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n         ty_opaque_box | ty_infer(_) | ty_param(*) | ty_self => {\n             *sty\n         }\n@@ -1794,7 +1800,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n       ty_trait(_, _, vstore_fixed(_)) |\n       ty_trait(_, _, vstore_slice(_)) => false,\n \n-      ty_param(*) | ty_infer(*) => true,\n+      ty_param(*) | ty_infer(*) | ty_err => true,\n \n       ty_evec(mt, vstore_fixed(_)) => type_needs_drop(cx, mt.ty),\n       ty_unboxed_vec(mt) => type_needs_drop(cx, mt.ty),\n@@ -2270,7 +2276,7 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n         cx.sess.bug(~\"Asked to compute kind of a type variable\");\n       }\n       ty_type | ty_opaque_closure_ptr(_)\n-      | ty_opaque_box | ty_unboxed_vec(_) => {\n+      | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n         cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n       }\n     };\n@@ -2341,7 +2347,7 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n         cx.sess.bug(~\"Asked to compute kind of a type variable\");\n       }\n       ty_type | ty_opaque_closure_ptr(_)\n-      | ty_opaque_box | ty_unboxed_vec(_) => {\n+      | ty_opaque_box | ty_unboxed_vec(_) | ty_err => {\n         cx.sess.bug(~\"Asked to compute kind of fictitious type\");\n       }\n     }\n@@ -2384,6 +2390,7 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_estr(_) |\n           ty_fn(_) |\n           ty_infer(_) |\n+          ty_err |\n           ty_param(_) |\n           ty_self |\n           ty_type |\n@@ -2589,7 +2596,7 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         result = false;\n       }\n \n-      ty_infer(*) | ty_self(*) => {\n+      ty_infer(*) | ty_self(*) | ty_err => {\n         cx.sess.bug(~\"non concrete type in type_is_pod\");\n       }\n     }\n@@ -2862,6 +2869,8 @@ impl sty : to_bytes::IterBytes {\n \n           ty_rptr(ref r, ref mt) =>\n           to_bytes::iter_bytes_3(&24u8, r, mt, lsb0, f),\n+\n+          ty_err => 25u8.iter_bytes(lsb0, f)\n         }\n     }\n }\n@@ -3357,7 +3366,8 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n       ty_infer(FloatVar(_)) => ~\"floating-point variable\",\n       ty_param(_) => ~\"type parameter\",\n-      ty_self => ~\"self\"\n+      ty_self => ~\"self\",\n+      ty_err => ~\"type error\"\n     }\n }\n \n@@ -4787,6 +4797,12 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n+            ty_err => {\n+                match (*other) {\n+                    ty_err => true,\n+                    _ => false\n+                }\n+            }\n             ty_param(e0a) => {\n                 match (*other) {\n                     ty_param(e0b) => e0a == e0b,\n@@ -4944,6 +4960,12 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n+            ty_err => {\n+                match (*other) {\n+                    ty_err => true,\n+                    _ => false\n+                }\n+            }\n             ty_param(e0a) => {\n                 match (*other) {\n                     ty_param(e0b) => e0a == e0b,"}, {"sha": "5a45e13a16f7332bd9c77820468d2b9aa072151d", "filename": "src/librustc/middle/typeck/check.rs", "status": "modified", "additions": 168, "deletions": 119, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -702,16 +702,6 @@ impl @fn_ctxt {\n         self.inh.node_type_substs.find(id)\n     }\n \n-    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n-                               err: &ty::type_err) {\n-        self.ccx.tcx.sess.span_err(\n-            sp,\n-            fmt!(\"mismatched types: expected `%s` but found `%s` (%s)\",\n-                 self.infcx().ty_to_str(e),\n-                 self.infcx().ty_to_str(a),\n-                 ty::type_err_to_str(self.ccx.tcx, err)));\n-        ty::note_and_explain_type_err(self.ccx.tcx, err);\n-    }\n \n     fn mk_subty(a_is_expected: bool, span: span,\n                 sub: ty::t, sup: ty::t) -> Result<(), ty::type_err> {\n@@ -775,6 +765,17 @@ impl @fn_ctxt {\n         rp.map(\n             |_rp| self.infcx().next_region_var_with_lb(span, lower_bound))\n     }\n+\n+    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n+                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+        self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n+    }\n+\n+    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+                               err: &ty::type_err) {\n+        self.infcx().report_mismatched_types(sp, e, a, err);\n+    }\n+\n }\n \n fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> (ty::t, uint) {\n@@ -979,6 +980,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         args: ~[@ast::expr],\n         deref_args: DerefArgs) -> {fty: ty::t, bot: bool} {\n \n+        let tcx = fcx.ccx.tcx;\n         let mut bot = false;\n \n         // Replace all region parameters in the arguments and return\n@@ -987,58 +989,60 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n                fcx.infcx().ty_to_str(in_fty));\n \n+        let mut formal_tys;\n+\n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n         // process the types bound by the function but not by any nested\n         // functions.  Therefore, we match one level of structure.\n-        let fn_ty =\n+        let fty =\n             match structure_of(fcx, sp, in_fty) {\n               ty::ty_fn(ref fn_ty) => {\n-                replace_bound_regions_in_fn_ty(\n-                    fcx.ccx.tcx, @Nil, None, fn_ty,\n-                    |_br| fcx.infcx().next_region_var(sp,\n-                                                      call_expr_id)).fn_ty\n+                  let fn_ty = replace_bound_regions_in_fn_ty(tcx, @Nil,\n+                      None, fn_ty, |_br| fcx.infcx().next_region_var(sp,\n+                                                      call_expr_id)).fn_ty;\n+\n+                  let supplied_arg_count = args.len();\n+\n+                  // Grab the argument types, supplying fresh type variables\n+                  // if the wrong number of arguments were supplied\n+                  let expected_arg_count = fn_ty.sig.inputs.len();\n+                  formal_tys = if expected_arg_count == supplied_arg_count {\n+                      fn_ty.sig.inputs.map(|a| a.ty)\n+                  } else {\n+                      tcx.sess.span_err(\n+                          sp, fmt!(\"this function takes %u parameter%s but \\\n+                                    %u parameter%s supplied\",\n+                                   expected_arg_count,\n+                                   if expected_arg_count == 1 {\n+                                       ~\"\"\n+                                   } else {\n+                                       ~\"s\"\n+                                   },\n+                                   supplied_arg_count,\n+                                   if supplied_arg_count == 1 {\n+                                       ~\" was\"\n+                                   } else {\n+                                       ~\"s were\"\n+                                   }));\n+                      fcx.infcx().next_ty_vars(supplied_arg_count)\n+                  };\n+                  ty::mk_fn(tcx, fn_ty)\n               }\n               _ => {\n-                // I would like to make this span_err, but it's\n-                // really hard due to the way that expr_bind() is\n-                // written.\n-                fcx.ccx.tcx.sess.span_fatal(sp, ~\"mismatched types: \\\n-                                            expected function or foreign \\\n-                                            function but found \"\n-                                            + fcx.infcx().ty_to_str(in_fty));\n+                  fcx.type_error_message(sp, |actual| {\n+                      fmt!(\"expected function or foreign function but \\\n+                            found `%s`\", actual) }, in_fty, None);\n+                  // check each arg against \"error\", in order to set up\n+                  // all the node type bindings\n+                  formal_tys = args.map(|_x| ty::mk_err(tcx));\n+                  ty::mk_err(tcx)\n               }\n             };\n \n-        let fty = ty::mk_fn(fcx.tcx(), fn_ty);\n         debug!(\"check_call_inner: after universal quant., fty=%s\",\n                fcx.infcx().ty_to_str(fty));\n \n-        let supplied_arg_count = args.len();\n-\n-        // Grab the argument types, supplying fresh type variables\n-        // if the wrong number of arguments were supplied\n-        let expected_arg_count = fn_ty.sig.inputs.len();\n-        let formal_tys = if expected_arg_count == supplied_arg_count {\n-            fn_ty.sig.inputs.map(|a| a.ty)\n-        } else {\n-            fcx.ccx.tcx.sess.span_err(\n-                sp, fmt!(\"this function takes %u parameter%s but %u \\\n-                          parameter%s supplied\", expected_arg_count,\n-                         if expected_arg_count == 1u {\n-                             ~\"\"\n-                         } else {\n-                             ~\"s\"\n-                         },\n-                         supplied_arg_count,\n-                         if supplied_arg_count == 1u {\n-                             ~\" was\"\n-                         } else {\n-                             ~\"s were\"\n-                         }));\n-            fcx.infcx().next_ty_vars(supplied_arg_count)\n-        };\n-\n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n         // that are not anonymous functions, then we typecheck the anonymous\n@@ -1129,11 +1133,16 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // Pull the return type out of the type of the function.\n         match structure_of(fcx, sp, fty) {\n           ty::ty_fn(ref f) => {\n-            bot |= (f.meta.ret_style == ast::noreturn);\n-            fcx.write_ty(call_expr_id, f.sig.output);\n-            return bot;\n+              bot |= (f.meta.ret_style == ast::noreturn);\n+              fcx.write_ty(call_expr_id, f.sig.output);\n+              return bot;\n+          }\n+          _ => {\n+              fcx.write_ty(call_expr_id, ty::mk_err(fcx.ccx.tcx));\n+              fcx.type_error_message(sp, |_actual| {\n+                  ~\"expected function\"}, fty, None);\n+              return bot;\n           }\n-          _ => fcx.ccx.tcx.sess.span_fatal(sp, ~\"calling non-function\")\n         }\n     }\n \n@@ -1239,8 +1248,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n         }\n \n+        // A hack, but this prevents multiple errors for the same code\n+        // (since check_user_binop calls structurally_resolve_type)\n         let (result, rhs_bot) =\n-            check_user_binop(fcx, expr, lhs, lhs_t, op, rhs);\n+           match ty::deref(fcx.tcx(), lhs_t, false).map(\n+                      |tt| structurally_resolved_type(fcx,\n+                                                      expr.span, tt.ty)) {\n+                Some(t) if ty::get(t).sty == ty::ty_err => (t, false),\n+                _ => check_user_binop(fcx, expr, lhs, lhs_t, op, rhs)\n+           };\n         fcx.write_ty(expr.id, result);\n         return lhs_bot | rhs_bot;\n     }\n@@ -1262,12 +1278,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ => ()\n         }\n         check_expr(fcx, rhs, None);\n-\n-        tcx.sess.span_err(\n-            ex.span, ~\"binary operation \" + ast_util::binop_to_str(op) +\n-            ~\" cannot be applied to type `\" +\n-            fcx.infcx().ty_to_str(lhs_resolved_t) +\n-            ~\"`\");\n+        fcx.type_error_message(ex.span,\n+           |actual| {\n+               fmt!(\"binary operation %s cannot be applied to type `%s`\",\n+                    ast_util::binop_to_str(op), actual)\n+           },\n+           lhs_resolved_t, None);\n \n         // If the or operator is used it might be that the user forgot to\n         // supply the do keyword.  Let's be more helpful in that situation.\n@@ -1292,10 +1308,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                DontDerefArgs) {\n           Some((ret_ty, _)) => ret_ty,\n           _ => {\n-            fcx.ccx.tcx.sess.span_err(\n-                ex.span, fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, fcx.infcx().ty_to_str(rhs_t)));\n-            rhs_t\n+              fcx.type_error_message(ex.span, |actual| {\n+                  fmt!(\"cannot apply unary operator `%s` to type `%s`\",\n+                              op_str, actual)\n+              }, rhs_t, None);\n+              rhs_t\n           }\n         }\n     }\n@@ -1454,17 +1471,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 }\n             }\n             None => {\n-                let t_err =\n-                    fcx.infcx().resolve_type_vars_if_possible(expr_t);\n-                let msg =\n-                    fmt!(\n-                        \"attempted access of field `%s` on type `%s`, \\\n-                         but no field or method with that name was found\",\n-                        tcx.sess.str_of(field),\n-                        fcx.infcx().ty_to_str(t_err));\n-                tcx.sess.span_err(expr.span, msg);\n-                // NB: Add bogus type to allow typechecking to continue\n-                fcx.write_ty(expr.id, fcx.infcx().next_ty_var());\n+                fcx.type_error_message(expr.span,\n+                  |actual| {\n+                      fmt!(\"attempted access of field `%s` on type `%s`, but \\\n+                            no field or method with that name was found\",\n+                           tcx.sess.str_of(field), actual)\n+                  },\n+                  expr_t, None);\n+                // Add error type for the result\n+                fcx.write_ty(expr.id, ty::mk_err(tcx));\n             }\n         }\n \n@@ -1802,10 +1817,9 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                           field\");\n                   }\n                   _ => {\n-                    tcx.sess.span_err(\n-                        expr.span,\n-                        fmt!(\"type %s cannot be dereferenced\",\n-                             fcx.infcx().ty_to_str(oprnd_t)));\n+                      fcx.type_error_message(expr.span, |actual| {\n+                          fmt!(\"type %s cannot be dereferenced\", actual)\n+                      }, oprnd_t, None);\n                   }\n                 }\n               }\n@@ -1958,18 +1972,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // appear in the context of a call, so we get the expected type of the\n         // parameter. The catch here is that we need to validate two things:\n         // 1. a closure that returns a bool is expected\n-        // 2. the cloure that was given returns unit\n+        // 2. the closure that was given returns unit\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n           Some(ty::ty_fn(fty)) => {\n             match fcx.mk_subty(false, expr.span,\n                                fty.sig.output, ty::mk_bool(tcx)) {\n               result::Ok(_) => (),\n               result::Err(_) => {\n-                tcx.sess.span_fatal(\n-                    expr.span, fmt!(\"a `loop` function's last argument \\\n-                                     should return `bool`, not `%s`\",\n-                                    fcx.infcx().ty_to_str(fty.sig.output)));\n+                   fcx.type_error_message(expr.span,\n+                      |actual| {\n+                          fmt!(\"a `loop` function's last argument \\\n+                                should return `bool`, not `%s`\", actual)\n+                      },\n+                      fty.sig.output, None);\n+                fcx.write_ty(id, ty::mk_err(tcx));\n+                return true;\n               }\n             }\n             ty::mk_fn(tcx, FnTyBase {\n@@ -1978,11 +1996,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                             ..fty.sig}\n             })\n           }\n-          _ => {\n-            tcx.sess.span_fatal(expr.span, ~\"a `loop` function's last \\\n-                                            argument should be of function \\\n-                                            type\");\n-          }\n+          _ =>\n+              match expected {\n+                  Some(expected_t) => {\n+                      fcx.type_error_message(expr.span, |actual| {\n+                          fmt!(\"a `loop` function's last \\\n+                                argument should be of function \\\n+                                type, not `%s`\",\n+                               actual)\n+                      },\n+                                             expected_t, None);\n+                      fcx.write_ty(id, ty::mk_err(tcx));\n+                      return true;\n+                  }\n+                  None => fcx.tcx().sess.impossible_case(expr.span,\n+                            ~\"loop body must have an expected type\")\n+              }\n         };\n         match b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n@@ -2012,13 +2041,21 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let expected_sty = unpack_expected(fcx, expected, |x| Some(x));\n         let inner_ty = match expected_sty {\n           Some(ty::ty_fn(fty)) => {\n-            ty::mk_fn(tcx, fty)\n-          }\n-          _ => {\n-            tcx.sess.span_fatal(expr.span, ~\"Non-function passed to a `do` \\\n-              function as its last argument, or wrong number of arguments \\\n-              passed to a `do` function\");\n+              ty::mk_fn(tcx, fty)\n           }\n+          _ => match expected {\n+                  Some(expected_t) => {\n+                      fcx.type_error_message(expr.span, |_actual| {\n+                          ~\"Non-function passed to a `do` \\\n+                            function as its last argument, or wrong number \\\n+                            of arguments passed to a `do` function\"\n+                      }, expected_t, None);\n+                      fcx.write_ty(id, ty::mk_err(tcx));\n+                      return true;\n+                  }\n+                  None => fcx.tcx().sess.impossible_case(expr.span,\n+                              ~\"do body must have expected type\")\n+              }\n         };\n         match b.node {\n           ast::expr_fn_block(decl, body, cap_clause) => {\n@@ -2067,13 +2104,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n           _ => {\n             if ty::type_is_nil(t_e) {\n-                tcx.sess.span_err(expr.span, ~\"cast from nil: \" +\n-                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx().ty_to_str(t_1));\n+                fcx.type_error_message(expr.span, |actual| {\n+                    fmt!(\"cast from nil: `%s` as `%s`\", actual,\n+                         fcx.infcx().ty_to_str(t_1))\n+                }, t_e, None);\n             } else if ty::type_is_nil(t_1) {\n-                tcx.sess.span_err(expr.span, ~\"cast to nil: \" +\n-                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx().ty_to_str(t_1));\n+                fcx.type_error_message(expr.span, |actual| {\n+                    fmt!(\"cast to nil: `%s` as `%s`\", actual,\n+                         fcx.infcx().ty_to_str(t_1))\n+                }, t_e, None);\n             }\n \n             let t_1_is_scalar = type_is_scalar(fcx, expr.span, t_1);\n@@ -2085,10 +2124,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 supported here, then file an enhancement issue and record the\n                 issue number in this comment.\n                 */\n-                tcx.sess.span_err(expr.span,\n-                                  ~\"non-scalar cast: \" +\n-                                  fcx.infcx().ty_to_str(t_e) + ~\" as \" +\n-                                  fcx.infcx().ty_to_str(t_1));\n+                fcx.type_error_message(expr.span, |actual| {\n+                    fmt!(\"non-scalar cast: `%s` as `%s`\", actual,\n+                         fcx.infcx().ty_to_str(t_1))\n+                }, t_e, None);\n             }\n           }\n         }\n@@ -2157,8 +2196,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             let base_fields =  match structure_of(fcx, expr.span, bexpr_t) {\n               ty::ty_rec(flds) => flds,\n               _ => {\n-                tcx.sess.span_fatal(expr.span,\n-                                    ~\"record update has non-record base\");\n+                  fcx.type_error_message(expr.span, |_actual| {\n+                      ~\"record update has non-record base\"\n+                  }, bexpr_t, None);\n+                fcx.write_ty(id, ty::mk_err(tcx));\n+                return true;\n               }\n             };\n             fcx.write_ty(id, bexpr_t);\n@@ -2171,9 +2213,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     }\n                 }\n                 if !found {\n-                    tcx.sess.span_fatal(f.span,\n+                    tcx.sess.span_err(f.span,\n                                         ~\"unknown field in record update: \" +\n                                         tcx.sess.str_of(f.node.ident));\n+                    fcx.write_ty(id, ty::mk_err(tcx));\n+                    return true;\n                 }\n             }\n           }\n@@ -2220,9 +2264,11 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                          ~[idx], DontDerefArgs) {\n                       Some((ret_ty, _)) => fcx.write_ty(id, ret_ty),\n                       _ => {\n-                          tcx.sess.span_fatal(\n-                              expr.span, ~\"cannot index a value of type `\" +\n-                              fcx.infcx().ty_to_str(base_t) + ~\"`\");\n+                          fcx.type_error_message(expr.span, |actual|\n+                              fmt!(\"cannot index a value of type `%s`\",\n+                                   actual), base_t, None);\n+                          fcx.write_ty(id, ty::mk_err(tcx));\n+                          return true;\n                       }\n                   }\n               }\n@@ -2247,9 +2293,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n \n fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n-        fcx.ccx.tcx.sess.span_err(sp, ~\"mismatched types: expected \\\n-                                       integral type but found `\"\n-                                  + fcx.infcx().ty_to_str(t) + ~\"`\");\n+        fcx.type_error_message(sp, |actual| {\n+            fmt!(\"mismatched types: expected integral type but found `%s`\",\n+                 actual)\n+        }, t, None);\n     }\n }\n \n@@ -2403,8 +2450,8 @@ fn check_instantiable(tcx: ty::ctxt,\n     let item_ty = ty::node_id_to_type(tcx, item_id);\n     if !ty::is_instantiable(tcx, item_ty) {\n         tcx.sess.span_err(sp, fmt!(\"this type cannot be instantiated \\\n-                                    without an instance of itself; \\\n-                                    consider using `option<%s>`\",\n+                  without an instance of itself; \\\n+                  consider using `option<%s>`\",\n                                    ty_to_str(tcx, item_ty)));\n     }\n }\n@@ -2507,8 +2554,8 @@ fn check_enum_variants(ccx: @crate_ctxt,\n         }\n     }) {\n         ccx.tcx.sess.span_err(sp, ~\"illegal recursive enum type; \\\n-                                   wrap the inner value in a box to \\\n-                                   make it representable\");\n+                                 wrap the inner value in a box to \\\n+                                 make it representable\");\n     }\n \n     // Check that it is possible to instantiate this enum:\n@@ -2657,8 +2704,10 @@ fn structurally_resolved_type(fcx: @fn_ctxt, sp: span, tp: ty::t) -> ty::t {\n     match infer::resolve_type(fcx.infcx(), tp, force_tvar) {\n         Ok(t_s) if !ty::type_is_ty_var(t_s) => return t_s,\n         _ => {\n-            fcx.ccx.tcx.sess.span_fatal\n-                (sp, ~\"the type of this value must be known in this context\");\n+            fcx.type_error_message(sp, |_actual| {\n+                ~\"the type of this value must be known in this context\"\n+            }, tp, None);\n+            return ty::mk_err(fcx.tcx());\n         }\n     }\n }"}, {"sha": "78cd677725738376bb98b3897406bb052fb57d8a", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -697,6 +697,8 @@ impl LookupContext {\n                     |m,r| ty::mk_rptr(tcx, r, {ty:self_ty, mutbl:m}))\n             }\n \n+            ty_err => None,\n+\n             ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n             ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n                 self.bug(fmt!(\"Unexpected type: %s\","}, {"sha": "7de2de708cc984e410b16a43309be838765dad49", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -476,13 +476,7 @@ fn demand_suptype(vcx: &VtableContext, sp: span, e: ty::t, a: ty::t) {\n     match infer::mk_subty(vcx.infcx, false, sp, a, e) {\n         result::Ok(()) => {} // Ok.\n         result::Err(ref err) => {\n-            vcx.tcx().sess.span_err(\n-                sp,\n-                fmt!(\"mismatched types: expected `%s` but found `%s` (%s)\",\n-                     vcx.infcx.ty_to_str(e),\n-                     vcx.infcx.ty_to_str(a),\n-                     ty::type_err_to_str(vcx.tcx(), err)));\n-            ty::note_and_explain_type_err(vcx.tcx(), err);\n+            vcx.infcx.report_mismatched_types(sp, e, a, err);\n         }\n     }\n }"}, {"sha": "97968e11ffa9217b09d2a130229c850c9ea23500", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -13,7 +13,7 @@ use middle::ty::{DerivedMethodInfo, ProvidedMethodSource, get};\n use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_class};\n use middle::ty::{ty_bool, ty_enum, ty_int, ty_nil, ty_ptr, ty_rptr, ty_uint};\n use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec, ty_uniq};\n-use middle::ty::{ty_fn, ty_trait, ty_tup, ty_infer};\n+use middle::ty::{ty_err, ty_fn, ty_trait, ty_tup, ty_infer};\n use middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n@@ -76,7 +76,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n         ty_estr(*) | ty_evec(*) | ty_rec(*) |\n         ty_fn(*) | ty_tup(*) | ty_infer(*) |\n         ty_param(*) | ty_self | ty_type | ty_opaque_box |\n-        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) => {\n+        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err => {\n             debug!(\"(getting base type) no base type; found %?\",\n                    get(original_type).sty);\n             None"}, {"sha": "56befd97342152fadbce8aaf630753d87d7532ea", "filename": "src/librustc/middle/typeck/infer.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -684,5 +684,43 @@ impl infer_ctxt {\n           result::Err(_) => typ\n         }\n     }\n+\n+    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n+                          actual_ty: ty::t, err: Option<&ty::type_err>) {\n+        let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n+\n+        // Don't report an error if actual type is ty_err.\n+        match ty::get(actual_ty).sty {\n+            ty::ty_err => return,\n+            _           => ()\n+        }\n+        let error_str = err.map_default(~\"\", |t_err|\n+                         fmt!(\" (%s)\",\n+                              ty::type_err_to_str(self.tcx, *t_err)));\n+        self.tcx.sess.span_err(sp,\n+           fmt!(\"%s%s\", mk_msg(self.ty_to_str(actual_ty)),\n+                error_str));\n+        err.iter(|err|\n+             ty::note_and_explain_type_err(self.tcx, *err));\n+    }\n+\n+    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+                               err: &ty::type_err) {\n+        // Don't report an error if expected is ty_err\n+        let resolved_expected =\n+            self.resolve_type_vars_if_possible(e);\n+        let mk_msg = match ty::get(resolved_expected).sty {\n+            ty::ty_err => return,\n+            _ => {\n+                // if I leave out : ~str, it infers &str and complains\n+                |actual: ~str| {\n+                    fmt!(\"mismatched types: expected `%s` but found `%s`\",\n+                         self.ty_to_str(resolved_expected), actual)\n+                }\n+            }\n+        };\n+        self.type_error_message(sp, mk_msg, a, Some(err));\n+    }\n+\n }\n "}, {"sha": "57c8f79b78a2ee19050fc978d5a4698fcb4ddb65", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -9,7 +9,7 @@ use middle::ty::{mt, t, param_bound};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n-use middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n+use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n@@ -390,6 +390,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                   f.meta.ret_style)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n+      ty_err => ~\"[type error]\",\n       ty_param({idx: id, _}) => {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }"}, {"sha": "b7cf35e6f1b37391209a3d019d4945741e02d4ba", "filename": "src/test/compile-fail/cast-from-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-from-nil.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern: cast from nil: () as u32\n+// error-pattern: cast from nil: `()` as `u32`\n fn main() { let u = (assert true) as u32; }\n\\ No newline at end of file"}, {"sha": "5c5d456484ab850974e38a92a7f48165088f85e0", "filename": "src/test/compile-fail/cast-to-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-to-nil.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -1,2 +1,2 @@\n-// error-pattern: cast to nil: u32 as ()\n+// error-pattern: cast to nil: `u32` as `()`\n fn main() { let u = 0u32 as (); }\n\\ No newline at end of file"}, {"sha": "4ed32e16d3304c981e4e7a513307f02b069548b6", "filename": "src/test/compile-fail/extern-no-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-no-call.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern:expected function or foreign function but found *u8\n+// error-pattern:expected function or foreign function but found `*u8`\n extern fn f() {\n }\n "}, {"sha": "99458b835f01efe0c951c725715f775da3b12f43", "filename": "src/test/compile-fail/issue-1871.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -1,11 +1,12 @@\n-// xfail-test\n+// Tests that we don't generate a spurious error about f.honk's type\n+// being undeterminable\n fn main() {\n   let f = 42;\n \n   let _g = if f < 5 {\n-      f.honk();\n+      f.honk() //~ ERROR attempted access of field `honk`\n   }\n   else {\n-    12\n+      ()\n   };\n }"}, {"sha": "b9ccfc667039d0299ce7b0c54bc28eb94874996a", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef833d41014481acdfc19bfd50f27f662dba8a2b/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=ef833d41014481acdfc19bfd50f27f662dba8a2b", "patch": "@@ -11,5 +11,5 @@ impl<A> ~[A]: vec_monad<A> {\n    }\n }\n fn main() {\n-    [\"hi\"].bind({|x| [x] });\n+    [\"hi\"].bind({|x| [x] }); //~ ERROR attempted access of field `bind`\n }"}]}