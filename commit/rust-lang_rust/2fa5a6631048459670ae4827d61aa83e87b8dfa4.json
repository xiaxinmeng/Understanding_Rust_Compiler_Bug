{"sha": "2fa5a6631048459670ae4827d61aa83e87b8dfa4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYTVhNjYzMTA0ODQ1OTY3MGFlNDgyN2Q2MWFhODNlODdiOGRmYTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-22T01:28:39Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-22T03:07:14Z"}, "message": "remove mutable cycle from ast_fold", "tree": {"sha": "65fa29d5f0c7e7d231d45a0dbbbe65549e1af0e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65fa29d5f0c7e7d231d45a0dbbbe65549e1af0e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa5a6631048459670ae4827d61aa83e87b8dfa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa5a6631048459670ae4827d61aa83e87b8dfa4", "html_url": "https://github.com/rust-lang/rust/commit/2fa5a6631048459670ae4827d61aa83e87b8dfa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa5a6631048459670ae4827d61aa83e87b8dfa4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bec7eafb1443873504f1702d72b749ae2c90cc0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bec7eafb1443873504f1702d72b749ae2c90cc0", "html_url": "https://github.com/rust-lang/rust/commit/2bec7eafb1443873504f1702d72b749ae2c90cc0"}], "stats": {"total": 437, "additions": 180, "deletions": 257}, "files": [{"sha": "7e30d81709eebd025e6afb8f50248e5c972800af", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -188,9 +188,9 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n         }\n     }\n     let afp =\n-        {fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n-                                                  newexpr.node, _, _, tm))\n-         with *fold::default_ast_fold()};\n+        @{fold_expr: fold::wrap(bind fold_expr_rep(j, i,\n+                                                   newexpr.node, _, _, tm))\n+          with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2\n@@ -211,8 +211,8 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::ty,\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n     let afp =\n-        {fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n-            with *fold::default_ast_fold()};\n+        @{fold_ty: fold::wrap(bind fold_ty_rep(j, i, newty.node, _, _, tm))\n+         with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     *crate2"}, {"sha": "dc632d6b6ac571fe0b47a1c47347a2e8b81aacda", "filename": "src/librustsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fauto_serialize.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -235,7 +235,7 @@ impl helpers for ext_ctxt {\n     }\n \n     fn clone_folder() -> fold::ast_fold {\n-        fold::make_fold({\n+        fold::make_fold(@{\n             new_id: {|_id| self.next_id()}\n             with *fold::default_ast_fold()\n         })\n@@ -265,7 +265,7 @@ impl helpers for ext_ctxt {\n             }\n         }\n \n-        let fld = fold::make_fold({\n+        let fld = fold::make_fold(@{\n             new_span: repl_sp(_, ast_util::dummy_sp(), span)\n             with *fold::default_ast_fold()\n         });"}, {"sha": "90487e279565c1788a392ea4cc26ef72330459c5", "filename": "src/librustsyntax/ext/expand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fexpand.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -130,11 +130,11 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n     let f_pre =\n-        {fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n-         fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n-         fold_item: bind expand_item(cx, _, _, afp.fold_item),\n-         new_span: bind new_span(cx, _)\n-            with *afp};\n+        @{fold_expr: bind expand_expr(exts, cx, _, _, _, afp.fold_expr),\n+          fold_mod: bind expand_mod_items(exts, cx, _, _, afp.fold_mod),\n+          fold_item: bind expand_item(cx, _, _, afp.fold_item),\n+          new_span: bind new_span(cx, _)\n+          with *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(\"<core-macros>\",\n                                         @core_macros(),"}, {"sha": "02d3c3d095b7e5c0b1522e87c08e3d2c04ce5da8", "filename": "src/librustsyntax/ext/qquote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fqquote.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -278,11 +278,11 @@ fn replace<T>(node: T, repls: [fragment], ff: fn (ast_fold, T) -> T)\n     -> T\n {\n     let aft = default_ast_fold();\n-    let f_pre = {fold_expr: bind replace_expr(repls, _, _, _,\n-                                              aft.fold_expr),\n-                 fold_ty: bind replace_ty(repls, _, _, _,\n-                                          aft.fold_ty)\n-                 with *aft};\n+    let f_pre = @{fold_expr: bind replace_expr(repls, _, _, _,\n+                                               aft.fold_expr),\n+                  fold_ty: bind replace_ty(repls, _, _, _,\n+                                           aft.fold_ty)\n+                  with *aft};\n     ret ff(make_fold(f_pre), node);\n }\n fn fold_crate(f: ast_fold, &&n: @ast::crate) -> @ast::crate {"}, {"sha": "76b78cb2b86c394be8d8f5df7be2749696fb9d87", "filename": "src/librustsyntax/ext/simplext.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fext%2Fsimplext.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -189,16 +189,17 @@ fn transcribe(cx: ext_ctxt, b: bindings, body: @expr) -> @expr {\n     }\n     let afp = default_ast_fold();\n     let f_pre =\n-        {fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n-         fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n-         fold_expr:\n-             bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n-         fold_ty: bind transcribe_type(cx, b, idx_path, _, _, _, afp.fold_ty),\n-         fold_block:\n-             bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n-         map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n-         new_id: bind new_id(_, cx)\n-         with *afp};\n+        @{fold_ident: bind transcribe_ident(cx, b, idx_path, _, _),\n+          fold_path: bind transcribe_path(cx, b, idx_path, _, _),\n+          fold_expr:\n+              bind transcribe_expr(cx, b, idx_path, _, _, _, afp.fold_expr),\n+          fold_ty: bind transcribe_type(cx, b, idx_path,\n+                                        _, _, _, afp.fold_ty),\n+          fold_block:\n+              bind transcribe_block(cx, b, idx_path, _, _, _, afp.fold_block),\n+          map_exprs: bind transcribe_exprs(cx, b, idx_path, _, _),\n+          new_id: bind new_id(_, cx)\n+          with *afp};\n     let f = make_fold(f_pre);\n     let result = f.fold_expr(body);\n     ret result;\n@@ -247,8 +248,8 @@ fn free_vars(b: bindings, e: @expr, it: fn(ident)) {\n     // using fold is a hack: we want visit, but it doesn't hit idents ) :\n     // solve this with macros\n     let f_pre =\n-        {fold_ident: bind mark_ident(_, _, b, idents)\n-            with *default_ast_fold()};\n+        @{fold_ident: bind mark_ident(_, _, b, idents)\n+          with *default_ast_fold()};\n     let f = make_fold(f_pre);\n     f.fold_expr(e); // ignore result\n     for idents.each_key {|x| it(x); };"}, {"sha": "f98c9c173e9c14de202d277b6497c538379319e0", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 141, "deletions": 219, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -17,96 +17,67 @@ export fold_ty_param;\n export fold_ty_params;\n export fold_fn_decl;\n \n-type ast_fold = @mut a_f;\n+iface ast_fold {\n+    fn fold_crate(crate) -> crate;\n+    fn fold_crate_directive(&&@crate_directive) -> @crate_directive;\n+    fn fold_view_item(&&@view_item) -> @view_item;\n+    fn fold_native_item(&&@native_item) -> @native_item;\n+    fn fold_item(&&@item) -> @item;\n+    fn fold_class_item(&&@class_member) -> @class_member;\n+    fn fold_item_underscore(item_) -> item_;\n+    fn fold_method(&&@method) -> @method;\n+    fn fold_block(blk) -> blk;\n+    fn fold_stmt(&&@stmt) -> @stmt;\n+    fn fold_arm(arm) -> arm;\n+    fn fold_pat(&&@pat) -> @pat;\n+    fn fold_decl(&&@decl) -> @decl;\n+    fn fold_expr(&&@expr) -> @expr;\n+    fn fold_ty(&&@ty) -> @ty;\n+    fn fold_constr(&&@constr) -> @constr;\n+    fn fold_ty_constr(&&@ty_constr) -> @ty_constr;\n+    fn fold_mod(_mod) -> _mod;\n+    fn fold_native_mod(native_mod) -> native_mod;\n+    fn fold_variant(variant) -> variant;\n+    fn fold_ident(&&ident) -> ident;\n+    fn fold_path(&&@path) -> @path;\n+    fn fold_local(&&@local) -> @local;\n+    fn map_exprs(fn@(&&@expr) -> @expr, [@expr]) -> [@expr];\n+    fn new_id(node_id) -> node_id;\n+    fn new_span(span) -> span;\n+}\n \n // We may eventually want to be able to fold over type parameters, too\n \n-type ast_fold_precursor =\n+type ast_fold_precursor = @{\n     //unlike the others, item_ is non-trivial\n-    {fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n-     fold_crate_directive: fn@(crate_directive_, span,\n-                               ast_fold) -> (crate_directive_, span),\n-     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n-     fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n-     fold_item: fn@(&&@item, ast_fold) -> @item,\n-     fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n-     fold_item_underscore: fn@(item_, ast_fold) -> item_,\n-     fold_method: fn@(&&@method, ast_fold) -> @method,\n-     fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n-     fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n-     fold_arm: fn@(arm, ast_fold) -> arm,\n-     fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n-     fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n-     fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n-     fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n-     fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n-     fold_ty_constr: fn@(ast::ty_constr_, span, ast_fold)\n+    fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n+    fold_crate_directive: fn@(crate_directive_, span,\n+                              ast_fold) -> (crate_directive_, span),\n+    fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n+    fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n+    fold_item: fn@(&&@item, ast_fold) -> @item,\n+    fold_class_item: fn@(&&@class_member, ast_fold) -> @class_member,\n+    fold_item_underscore: fn@(item_, ast_fold) -> item_,\n+    fold_method: fn@(&&@method, ast_fold) -> @method,\n+    fold_block: fn@(blk_, span, ast_fold) -> (blk_, span),\n+    fold_stmt: fn@(stmt_, span, ast_fold) -> (stmt_, span),\n+    fold_arm: fn@(arm, ast_fold) -> arm,\n+    fold_pat: fn@(pat_, span, ast_fold) -> (pat_, span),\n+    fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n+    fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n+    fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n+    fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n+    fold_ty_constr: fn@(ast::ty_constr_, span, ast_fold)\n         -> (ty_constr_, span),\n-     fold_mod: fn@(_mod, ast_fold) -> _mod,\n-     fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n-     fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n-     fold_ident: fn@(&&ident, ast_fold) -> ident,\n-     fold_path: fn@(path, ast_fold) -> path,\n-     fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n-     map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n-     new_id: fn@(node_id) -> node_id,\n-     new_span: fn@(span) -> span};\n-\n-type a_f =\n-    {fold_crate: fn@(crate) -> crate,\n-     fold_crate_directive: fn@(&&@crate_directive) -> @crate_directive,\n-     fold_view_item: fn@(&&@view_item) -> @view_item,\n-     fold_native_item: fn@(&&@native_item) -> @native_item,\n-     fold_item: fn@(&&@item) -> @item,\n-     fold_class_item: fn@(&&@class_member) -> @class_member,\n-     fold_item_underscore: fn@(item_) -> item_,\n-     fold_method: fn@(&&@method) -> @method,\n-     fold_block: fn@(blk) -> blk,\n-     fold_stmt: fn@(&&@stmt) -> @stmt,\n-     fold_arm: fn@(arm) -> arm,\n-     fold_pat: fn@(&&@pat) -> @pat,\n-     fold_decl: fn@(&&@decl) -> @decl,\n-     fold_expr: fn@(&&@expr) -> @expr,\n-     fold_ty: fn@(&&@ty) -> @ty,\n-     fold_constr: fn@(&&@constr) -> @constr,\n-     fold_ty_constr: fn@(&&@ty_constr) -> @ty_constr,\n-     fold_mod: fn@(_mod) -> _mod,\n-     fold_native_mod: fn@(native_mod) -> native_mod,\n-     fold_variant: fn@(variant) -> variant,\n-     fold_ident: fn@(&&ident) -> ident,\n-     fold_path: fn@(&&@path) -> @path,\n-     fold_local: fn@(&&@local) -> @local,\n-     map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n-     new_id: fn@(node_id) -> node_id,\n-     new_span: fn@(span) -> span};\n-\n-\n-//fn nf_dummy<T>(&T node) -> T { fail; }\n-fn nf_crate_dummy(_c: crate) -> crate { fail; }\n-fn nf_crate_directive_dummy(&&_c: @crate_directive) -> @crate_directive {\n-    fail;\n-}\n-fn nf_view_item_dummy(&&_v: @view_item) -> @view_item { fail; }\n-fn nf_native_item_dummy(&&_n: @native_item) -> @native_item { fail; }\n-fn nf_item_dummy(&&_i: @item) -> @item { fail; }\n-fn nf_class_item_dummy(&&_ci: @class_member) -> @class_member { fail; }\n-fn nf_item_underscore_dummy(_i: item_) -> item_ { fail; }\n-fn nf_method_dummy(&&_m: @method) -> @method { fail; }\n-fn nf_blk_dummy(_b: blk) -> blk { fail; }\n-fn nf_stmt_dummy(&&_s: @stmt) -> @stmt { fail; }\n-fn nf_arm_dummy(_a: arm) -> arm { fail; }\n-fn nf_pat_dummy(&&_p: @pat) -> @pat { fail; }\n-fn nf_decl_dummy(&&_d: @decl) -> @decl { fail; }\n-fn nf_expr_dummy(&&_e: @expr) -> @expr { fail; }\n-fn nf_ty_dummy(&&_t: @ty) -> @ty { fail; }\n-fn nf_constr_dummy(&&_c: @constr) -> @constr { fail; }\n-fn nf_ty_constr_dummy(&&_c: @ty_constr) -> @ty_constr { fail; }\n-fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n-fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n-fn nf_variant_dummy(_v: variant) -> variant { fail; }\n-fn nf_ident_dummy(&&_i: ident) -> ident { fail; }\n-fn nf_path_dummy(&&_p: @path) -> @path { fail; }\n-fn nf_local_dummy(&&_o: @local) -> @local { fail; }\n+    fold_mod: fn@(_mod, ast_fold) -> _mod,\n+    fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n+    fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n+    fold_ident: fn@(&&ident, ast_fold) -> ident,\n+    fold_path: fn@(path, ast_fold) -> path,\n+    fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n+    map_exprs: fn@(fn@(&&@expr) -> @expr, [@expr]) -> [@expr],\n+    new_id: fn@(node_id) -> node_id,\n+    new_span: fn@(span) -> span};\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n@@ -604,8 +575,7 @@ fn noop_id(i: node_id) -> node_id { ret i; }\n \n fn noop_span(sp: span) -> span { ret sp; }\n \n-\n-fn default_ast_fold() -> @ast_fold_precursor {\n+fn default_ast_fold() -> ast_fold_precursor {\n     ret @{fold_crate: wrap(noop_fold_crate),\n           fold_crate_directive: wrap(noop_fold_crate_directive),\n           fold_view_item: noop_fold_view_item,\n@@ -634,177 +604,129 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           new_span: noop_span};\n }\n \n-fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n-    // FIXME: Have to bind all the bare functions into shared functions\n-    // because @mut is invariant with respect to its contents\n-    // I assume this has something to do with Issue #1973 - tjc\n-    let result: ast_fold =\n-        @mut {fold_crate: bind nf_crate_dummy(_),\n-                  fold_crate_directive: bind nf_crate_directive_dummy(_),\n-                  fold_view_item: bind nf_view_item_dummy(_),\n-                  fold_native_item: bind nf_native_item_dummy(_),\n-                  fold_item: bind nf_item_dummy(_),\n-                  fold_class_item: bind nf_class_item_dummy(_),\n-                  fold_item_underscore: bind nf_item_underscore_dummy(_),\n-                  fold_method: bind nf_method_dummy(_),\n-                  fold_block: bind nf_blk_dummy(_),\n-                  fold_stmt: bind nf_stmt_dummy(_),\n-                  fold_arm: bind nf_arm_dummy(_),\n-                  fold_pat: bind nf_pat_dummy(_),\n-                  fold_decl: bind nf_decl_dummy(_),\n-                  fold_expr: bind nf_expr_dummy(_),\n-                  fold_ty: bind nf_ty_dummy(_),\n-                  fold_constr: bind nf_constr_dummy(_),\n-                  fold_ty_constr: bind nf_ty_constr_dummy(_),\n-                  fold_mod: bind nf_mod_dummy(_),\n-                  fold_native_mod: bind nf_native_mod_dummy(_),\n-                  fold_variant: bind nf_variant_dummy(_),\n-                  fold_ident: bind nf_ident_dummy(_),\n-                  fold_path: bind nf_path_dummy(_),\n-                  fold_local: bind nf_local_dummy(_),\n-                  map_exprs: bind noop_map_exprs(_, _),\n-                  new_id: bind noop_id(_),\n-                  new_span: bind noop_span(_)};\n-\n+impl of ast_fold for ast_fold_precursor {\n     /* naturally, a macro to write these would be nice */\n-    fn f_crate(afp: ast_fold_precursor, f: ast_fold, c: crate) -> crate {\n-        let (n, s) = afp.fold_crate(c.node, c.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n+    fn fold_crate(c: crate) -> crate {\n+        let (n, s) = self.fold_crate(c.node, c.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n     }\n-    fn f_crate_directive(afp: ast_fold_precursor, f: ast_fold,\n-                         &&c: @crate_directive) -> @crate_directive {\n-        let (n, s) = afp.fold_crate_directive(c.node, c.span, f);\n+    fn fold_crate_directive(&&c: @crate_directive) -> @crate_directive {\n+        let (n, s) = self.fold_crate_directive(c.node, c.span,\n+                                               self as ast_fold);\n         ret @{node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_view_item(afp: ast_fold_precursor, f: ast_fold, &&x: @view_item) ->\n+    fn fold_view_item(&&x: @view_item) ->\n        @view_item {\n-        ret @{node: afp.fold_view_item(x.node, f),\n-              attrs: vec::map(x.attrs, {|a| fold_attribute_(a, f)}),\n+        ret @{node: self.fold_view_item(x.node, self as ast_fold),\n+              attrs: vec::map(x.attrs, {|a|\n+                  fold_attribute_(a, self as ast_fold)}),\n               vis: x.vis,\n-              span: afp.new_span(x.span)};\n+              span: self.new_span(x.span)};\n     }\n-    fn f_native_item(afp: ast_fold_precursor, f: ast_fold, &&x: @native_item)\n+    fn fold_native_item(&&x: @native_item)\n         -> @native_item {\n-        ret afp.fold_native_item(x, f);\n+        ret self.fold_native_item(x, self as ast_fold);\n     }\n-    fn f_item(afp: ast_fold_precursor, f: ast_fold, &&i: @item) -> @item {\n-        ret afp.fold_item(i, f);\n+    fn fold_item(&&i: @item) -> @item {\n+        ret self.fold_item(i, self as ast_fold);\n     }\n-    fn f_class_item(afp: ast_fold_precursor, f: ast_fold,\n-                      &&ci: @class_member) -> @class_member {\n+    fn fold_class_item(&&ci: @class_member) -> @class_member {\n         @{node: alt ci.node {\n            instance_var(nm, t, mt, id, p) {\n-               instance_var(nm, f_ty(afp, f, t),\n+               instance_var(nm, (self as ast_fold).fold_ty(t),\n                             mt, id, p)\n            }\n            class_method(m) {\n-               class_method(afp.fold_method(m, f))\n+               class_method(self.fold_method(m, self as ast_fold))\n            }\n-          }, span: afp.new_span(ci.span)}\n+          }, span: self.new_span(ci.span)}\n     }\n-    fn f_item_underscore(afp: ast_fold_precursor, f: ast_fold, i: item_) ->\n+    fn fold_item_underscore(i: item_) ->\n        item_ {\n-        ret afp.fold_item_underscore(i, f);\n+        ret self.fold_item_underscore(i, self as ast_fold);\n     }\n-    fn f_method(afp: ast_fold_precursor, f: ast_fold, &&x: @method)\n+    fn fold_method(&&x: @method)\n         -> @method {\n-        ret afp.fold_method(x, f);\n+        ret self.fold_method(x, self as ast_fold);\n     }\n-    fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n-        let (n, s) = afp.fold_block(x.node, x.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n+    fn fold_block(x: blk) -> blk {\n+        let (n, s) = self.fold_block(x.node, x.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n     }\n-    fn f_stmt(afp: ast_fold_precursor, f: ast_fold, &&x: @stmt) -> @stmt {\n-        let (n, s) = afp.fold_stmt(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+    fn fold_stmt(&&x: @stmt) -> @stmt {\n+        let (n, s) = self.fold_stmt(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_arm(afp: ast_fold_precursor, f: ast_fold, x: arm) -> arm {\n-        ret afp.fold_arm(x, f);\n+    fn fold_arm(x: arm) -> arm {\n+        ret self.fold_arm(x, self as ast_fold);\n     }\n-    fn f_pat(afp: ast_fold_precursor, f: ast_fold, &&x: @pat) -> @pat {\n-        let (n, s) =  afp.fold_pat(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id),\n+    fn fold_pat(&&x: @pat) -> @pat {\n+        let (n, s) =  self.fold_pat(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id),\n               node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_decl(afp: ast_fold_precursor, f: ast_fold, &&x: @decl) -> @decl {\n-        let (n, s) = afp.fold_decl(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+    fn fold_decl(&&x: @decl) -> @decl {\n+        let (n, s) = self.fold_decl(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_expr(afp: ast_fold_precursor, f: ast_fold, &&x: @expr) -> @expr {\n-        let (n, s) = afp.fold_expr(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id),\n+    fn fold_expr(&&x: @expr) -> @expr {\n+        let (n, s) = self.fold_expr(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id),\n               node: n,\n-              span: afp.new_span(s)};\n+              span: self.new_span(s)};\n     }\n-    fn f_ty(afp: ast_fold_precursor, f: ast_fold, &&x: @ty) -> @ty {\n-        let (n, s) = afp.fold_ty(x.node, x.span, f);\n-        ret @{id: afp.new_id(x.id), node: n, span: afp.new_span(s)};\n+    fn fold_ty(&&x: @ty) -> @ty {\n+        let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n+        ret @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n     }\n-    fn f_constr(afp: ast_fold_precursor, f: ast_fold, &&x: @ast::constr) ->\n+    fn fold_constr(&&x: @ast::constr) ->\n        @ast::constr {\n-        let (n, s) = afp.fold_constr(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+        let (n, s) = self.fold_constr(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_ty_constr(afp: ast_fold_precursor, f: ast_fold,\n-                   &&x: @ast::ty_constr) ->\n+    fn fold_ty_constr(&&x: @ast::ty_constr) ->\n        @ast::ty_constr {\n         let (n, s) : (ty_constr_, span) =\n-            afp.fold_ty_constr(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n+            self.fold_ty_constr(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n     }\n-    fn f_mod(afp: ast_fold_precursor, f: ast_fold, x: _mod) -> _mod {\n-        ret afp.fold_mod(x, f);\n+    fn fold_mod(x: _mod) -> _mod {\n+        ret self.fold_mod(x, self as ast_fold);\n     }\n-    fn f_native_mod(afp: ast_fold_precursor, f: ast_fold, x: native_mod) ->\n+    fn fold_native_mod(x: native_mod) ->\n        native_mod {\n-        ret afp.fold_native_mod(x, f);\n+        ret self.fold_native_mod(x, self as ast_fold);\n     }\n-    fn f_variant(afp: ast_fold_precursor, f: ast_fold, x: variant) ->\n+    fn fold_variant(x: variant) ->\n        variant {\n-        let (n, s) = afp.fold_variant(x.node, x.span, f);\n-        ret {node: n, span: afp.new_span(s)};\n-    }\n-    fn f_ident(afp: ast_fold_precursor, f: ast_fold, &&x: ident) -> ident {\n-        ret afp.fold_ident(x, f);\n-    }\n-    fn f_path(afp: ast_fold_precursor, f: ast_fold, &&x: @path) -> @path {\n-        @afp.fold_path(*x, f)\n-    }\n-    fn f_local(afp: ast_fold_precursor, f: ast_fold, &&x: @local) -> @local {\n-        let (n, s) = afp.fold_local(x.node, x.span, f);\n-        ret @{node: n, span: afp.new_span(s)};\n-    }\n-\n-    *result =\n-        {fold_crate: bind f_crate(afp, result, _),\n-         fold_crate_directive: bind f_crate_directive(afp, result, _),\n-         fold_view_item: bind f_view_item(afp, result, _),\n-         fold_native_item: bind f_native_item(afp, result, _),\n-         fold_item: bind f_item(afp, result, _),\n-         fold_class_item: bind f_class_item(afp, result, _),\n-         fold_item_underscore: bind f_item_underscore(afp, result, _),\n-         fold_method: bind f_method(afp, result, _),\n-         fold_block: bind f_block(afp, result, _),\n-         fold_stmt: bind f_stmt(afp, result, _),\n-         fold_arm: bind f_arm(afp, result, _),\n-         fold_pat: bind f_pat(afp, result, _),\n-         fold_decl: bind f_decl(afp, result, _),\n-         fold_expr: bind f_expr(afp, result, _),\n-         fold_ty: bind f_ty(afp, result, _),\n-         fold_constr: bind f_constr(afp, result, _),\n-         fold_ty_constr: bind f_ty_constr(afp, result, _),\n-         fold_mod: bind f_mod(afp, result, _),\n-         fold_native_mod: bind f_native_mod(afp, result, _),\n-         fold_variant: bind f_variant(afp, result, _),\n-         fold_ident: bind f_ident(afp, result, _),\n-         fold_path: bind f_path(afp, result, _),\n-         fold_local: bind f_local(afp, result, _),\n-         map_exprs: afp.map_exprs,\n-         new_id: afp.new_id,\n-         new_span: afp.new_span};\n-    ret result;\n+        let (n, s) = self.fold_variant(x.node, x.span, self as ast_fold);\n+        ret {node: n, span: self.new_span(s)};\n+    }\n+    fn fold_ident(&&x: ident) -> ident {\n+        ret self.fold_ident(x, self as ast_fold);\n+    }\n+    fn fold_path(&&x: @path) -> @path {\n+        @self.fold_path(*x, self as ast_fold)\n+    }\n+    fn fold_local(&&x: @local) -> @local {\n+        let (n, s) = self.fold_local(x.node, x.span, self as ast_fold);\n+        ret @{node: n, span: self.new_span(s)};\n+    }\n+    fn map_exprs(f: fn@(&&@expr) -> @expr, e: [@expr]) -> [@expr] {\n+        self.map_exprs(f, e)\n+    }\n+    fn new_id(node_id: ast::node_id) -> node_id {\n+        self.new_id(node_id)\n+    }\n+    fn new_span(span: span) -> span {\n+        self.new_span(span)\n+    }\n+}\n+\n+fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n+    afp as ast_fold\n }\n \n //"}, {"sha": "3a9dfff1ae283e0f07618353a8610b90a44a22e9", "filename": "src/rustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fconfig.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -24,10 +24,10 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n     let ctxt = @{in_cfg: in_cfg};\n \n     let precursor =\n-        {fold_mod: bind fold_mod(ctxt, _, _),\n-         fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n-         fold_native_mod: bind fold_native_mod(ctxt, _, _)\n-            with *fold::default_ast_fold()};\n+        @{fold_mod: bind fold_mod(ctxt, _, _),\n+          fold_block: fold::wrap(bind fold_block(ctxt, _, _)),\n+          fold_native_mod: bind fold_native_mod(ctxt, _, _)\n+          with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);"}, {"sha": "b410cb75ad6f76298bd6a607b237e24bbd3cd2ee", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -43,9 +43,9 @@ fn generate_test_harness(sess: session::session,\n           mut testfns: []};\n \n     let precursor =\n-        {fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n-         fold_item: bind fold_item(cx, _, _),\n-         fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n+        @{fold_crate: fold::wrap(bind fold_crate(cx, _, _)),\n+          fold_item: bind fold_item(cx, _, _),\n+          fold_mod: bind fold_mod(cx, _, _) with *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);"}, {"sha": "e0164ad3bfec945d0e7effd0938a499d159bccc1", "filename": "src/rustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa5a6631048459670ae4827d61aa83e87b8dfa4/src%2Frustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fastencode.rs?ref=2fa5a6631048459670ae4827d61aa83e87b8dfa4", "patch": "@@ -401,7 +401,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n \n-    let fld = fold::make_fold({\n+    let fld = fold::make_fold(@{\n         fold_block: fold::wrap(drop_nested_items)\n         with *fold::default_ast_fold()\n     });\n@@ -434,7 +434,7 @@ fn decode_ast(par_doc: ebml::doc) -> ast::inlined_item {\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = fold::make_fold({\n+    let fld = fold::make_fold(@{\n         new_id: xcx.tr_id(_),\n         new_span: xcx.tr_span(_)\n         with *fold::default_ast_fold()"}]}