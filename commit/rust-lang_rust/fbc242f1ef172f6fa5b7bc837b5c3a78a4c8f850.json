{"sha": "fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzI0MmYxZWYxNzJmNmZhNWI3YmM4MzdiNWMzYTc4YTRjOGY4NTA=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-23T09:44:31Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-10-24T15:28:04Z"}, "message": "Turn Finish into WaiterQueue", "tree": {"sha": "ef803368fd1f427c948bf2910e3f1fb2ab315c3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef803368fd1f427c948bf2910e3f1fb2ab315c3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "html_url": "https://github.com/rust-lang/rust/commit/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1479c22a390a6b95706d4280cd7be24e4410dc77", "url": "https://api.github.com/repos/rust-lang/rust/commits/1479c22a390a6b95706d4280cd7be24e4410dc77", "html_url": "https://github.com/rust-lang/rust/commit/1479c22a390a6b95706d4280cd7be24e4410dc77"}], "stats": {"total": 44, "additions": 21, "deletions": 23}, "files": [{"sha": "01cb7582d38dc6d5dbfc44b5467b6572bdbbb1ad", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 21, "deletions": 23, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=fbc242f1ef172f6fa5b7bc837b5c3a78a4c8f850", "patch": "@@ -139,13 +139,15 @@ struct Waiter {\n     next: *const Waiter,\n }\n \n-// Helper struct used to clean up after a closure call with a `Drop`\n-// implementation to also run on panic.\n-struct Finish<'a> {\n-    panicked: bool,\n-    me: &'a Once,\n+// Head of a linked list of waiters.\n+// Every node is a struct on the stack of a waiting thread.\n+// Will wake up the waiters when it gets dropped, i.e. also on panic.\n+struct WaiterQueue<'a> {\n+    state_and_queue: &'a AtomicUsize,\n+    set_state_on_drop_to: usize,\n }\n \n+\n impl Once {\n     /// Creates a new `Once` value.\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n@@ -379,18 +381,16 @@ impl Once {\n                         state_and_queue = old;\n                         continue\n                     }\n-\n-                    // Run the initialization routine, letting it know if we're\n-                    // poisoned or not. The `Finish` struct is then dropped, and\n-                    // the `Drop` implementation here is responsible for waking\n-                    // up other waiters both in the normal return and panicking\n-                    // case.\n-                    let mut complete = Finish {\n-                        panicked: true,\n-                        me: self,\n+                    // `waiter_queue` will manage other waiting threads, and\n+                    // wake them up on drop.\n+                    let mut waiter_queue = WaiterQueue {\n+                        state_and_queue: &self.state_and_queue,\n+                        set_state_on_drop_to: POISONED,\n                     };\n+                    // Run the initialization function, letting it know if we're\n+                    // poisoned or not.\n                     init(state_and_queue == POISONED);\n-                    complete.panicked = false;\n+                    waiter_queue.set_state_on_drop_to = COMPLETE;\n                     return\n                 }\n \n@@ -453,15 +453,13 @@ impl fmt::Debug for Once {\n     }\n }\n \n-impl Drop for Finish<'_> {\n+impl Drop for WaiterQueue<'_> {\n     fn drop(&mut self) {\n-        // Swap out our state with however we finished. We should only ever see\n-        // an old state which was RUNNING.\n-        let state_and_queue = if self.panicked {\n-            self.me.state_and_queue.swap(POISONED, Ordering::SeqCst)\n-        } else {\n-            self.me.state_and_queue.swap(COMPLETE, Ordering::SeqCst)\n-        };\n+        // Swap out our state with however we finished.\n+        let state_and_queue = self.state_and_queue.swap(self.set_state_on_drop_to,\n+                                                        Ordering::SeqCst);\n+\n+        // We should only ever see an old state which was RUNNING.\n         assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n \n         // Decode the RUNNING to a list of waiters, then walk that entire list"}]}