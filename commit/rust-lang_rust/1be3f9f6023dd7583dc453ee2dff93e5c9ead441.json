{"sha": "1be3f9f6023dd7583dc453ee2dff93e5c9ead441", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFiZTNmOWY2MDIzZGQ3NTgzZGM0NTNlZTJkZmY5M2U1YzllYWQ0NDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-04T11:37:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-04T11:37:50Z"}, "message": "Auto merge of #29200 - tshepang:rustfmt-path, r=aturon", "tree": {"sha": "48e335ab89e2b69a3abe9b33b6ee08c2bb0806ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48e335ab89e2b69a3abe9b33b6ee08c2bb0806ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1be3f9f6023dd7583dc453ee2dff93e5c9ead441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1be3f9f6023dd7583dc453ee2dff93e5c9ead441", "html_url": "https://github.com/rust-lang/rust/commit/1be3f9f6023dd7583dc453ee2dff93e5c9ead441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1be3f9f6023dd7583dc453ee2dff93e5c9ead441/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ad89e0de6d62c36f78a71c08556d86605e08064", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad89e0de6d62c36f78a71c08556d86605e08064", "html_url": "https://github.com/rust-lang/rust/commit/1ad89e0de6d62c36f78a71c08556d86605e08064"}, {"sha": "37735b4d6d6e0c4acbea2351794abdcd78ff9363", "url": "https://api.github.com/repos/rust-lang/rust/commits/37735b4d6d6e0c4acbea2351794abdcd78ff9363", "html_url": "https://github.com/rust-lang/rust/commit/37735b4d6d6e0c4acbea2351794abdcd78ff9363"}], "stats": {"total": 261, "additions": 165, "deletions": 96}, "files": [{"sha": "b9a58a117643a45838c13f7664d32c59f36d5614", "filename": "src/libstd/path.rs", "status": "modified", "additions": 165, "deletions": 96, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/1be3f9f6023dd7583dc453ee2dff93e5c9ead441/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1be3f9f6023dd7583dc453ee2dff93e5c9ead441/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=1be3f9f6023dd7583dc453ee2dff93e5c9ead441", "patch": "@@ -48,7 +48,8 @@\n //! The path APIs are built around the notion of \"components\", which roughly\n //! correspond to the substrings between path separators (`/` and, on Windows,\n //! `\\`). The APIs for path parsing are largely specified in terms of the path's\n-//! components, so it's important to clearly understand how those are determined.\n+//! components, so it's important to clearly understand how those are\n+//! determined.\n //!\n //! A path can always be reconstructed into an *equivalent* path by\n //! putting together its components via `push`. Syntactically, the\n@@ -191,10 +192,9 @@ mod platform {\n                         // \\\\?\\UNC\\server\\share\n                         path = &path[4..];\n                         let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                            Some((server, share)) => (u8_slice_as_os_str(server),\n-                                                      u8_slice_as_os_str(share)),\n-                            None => (u8_slice_as_os_str(path),\n-                                     u8_slice_as_os_str(&[])),\n+                            Some((server, share)) =>\n+                                (u8_slice_as_os_str(server), u8_slice_as_os_str(share)),\n+                            None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n                         };\n                         return Some(VerbatimUNC(server, share));\n                     } else {\n@@ -207,7 +207,7 @@ mod platform {\n                                 return Some(VerbatimDisk(c.to_ascii_uppercase()));\n                             }\n                         }\n-                        let slice = &path[.. idx.unwrap_or(path.len())];\n+                        let slice = &path[..idx.unwrap_or(path.len())];\n                         return Some(Verbatim(u8_slice_as_os_str(slice)));\n                     }\n                 } else if path.starts_with(b\".\\\\\") {\n@@ -220,10 +220,9 @@ mod platform {\n                 match parse_two_comps(path, is_sep_byte) {\n                     Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n                         // \\\\server\\share\n-                        return Some(UNC(u8_slice_as_os_str(server),\n-                                        u8_slice_as_os_str(share)));\n+                        return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n                     }\n-                    _ => ()\n+                    _ => (),\n                 }\n             } else if path.len() > 1 && path[1] == b':' {\n                 // C:\n@@ -238,11 +237,11 @@ mod platform {\n         fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n             let first = match path.iter().position(|x| f(*x)) {\n                 None => return None,\n-                Some(x) => &path[.. x]\n+                Some(x) => &path[..x],\n             };\n-            path = &path[(first.len()+1)..];\n+            path = &path[(first.len() + 1)..];\n             let idx = path.iter().position(|x| f(*x));\n-            let second = &path[.. idx.unwrap_or(path.len())];\n+            let second = &path[..idx.unwrap_or(path.len())];\n             Some((first, second))\n         }\n     }\n@@ -299,15 +298,25 @@ impl<'a> Prefix<'a> {\n         }\n         match *self {\n             Verbatim(x) => 4 + os_str_len(x),\n-            VerbatimUNC(x,y) => 8 + os_str_len(x) +\n-                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                else { 0 },\n+            VerbatimUNC(x, y) => {\n+                8 + os_str_len(x) +\n+                if os_str_len(y) > 0 {\n+                    1 + os_str_len(y)\n+                } else {\n+                    0\n+                }\n+            },\n             VerbatimDisk(_) => 6,\n-            UNC(x,y) => 2 + os_str_len(x) +\n-                if os_str_len(y) > 0 { 1 + os_str_len(y) }\n-                else { 0 },\n+            UNC(x, y) => {\n+                2 + os_str_len(x) +\n+                if os_str_len(y) > 0 {\n+                    1 + os_str_len(y)\n+                } else {\n+                    0\n+                }\n+            },\n             DeviceNS(x) => 4 + os_str_len(x),\n-            Disk(_) => 2\n+            Disk(_) => 2,\n         }\n \n     }\n@@ -368,14 +377,18 @@ pub const MAIN_SEPARATOR: char = platform::MAIN_SEP;\n // Iterate through `iter` while it matches `prefix`; return `None` if `prefix`\n // is not a prefix of `iter`, otherwise return `Some(iter_after_prefix)` giving\n // `iter` after having exhausted `prefix`.\n-fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I> where\n-    I: Iterator<Item=A> + Clone, J: Iterator<Item=A>, A: PartialEq\n+fn iter_after<A, I, J>(mut iter: I, mut prefix: J) -> Option<I>\n+    where I: Iterator<Item = A> + Clone,\n+          J: Iterator<Item = A>,\n+          A: PartialEq\n {\n     loop {\n         let mut iter_next = iter.clone();\n         match (iter_next.next(), prefix.next()) {\n             (Some(x), Some(y)) => {\n-                if x != y { return None }\n+                if x != y {\n+                    return None;\n+                }\n             }\n             (Some(_), None) => return Some(iter),\n             (None, None) => return Some(iter),\n@@ -399,14 +412,20 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n \n /// Says whether the first byte after the prefix is a separator.\n fn has_physical_root(s: &[u8], prefix: Option<Prefix>) -> bool {\n-    let path = if let Some(p) = prefix { &s[p.len()..] } else { s };\n+    let path = if let Some(p) = prefix {\n+        &s[p.len()..]\n+    } else {\n+        s\n+    };\n     !path.is_empty() && is_sep_byte(path[0])\n }\n \n // basic workhorse for splitting stem and extension\n fn split_file_at_dot(file: &OsStr) -> (Option<&OsStr>, Option<&OsStr>) {\n     unsafe {\n-        if os_str_as_u8_slice(file) == b\"..\" { return (Some(file), None) }\n+        if os_str_as_u8_slice(file) == b\"..\" {\n+            return (Some(file), None);\n+        }\n \n         // The unsafety here stems from converting between &OsStr and &[u8]\n         // and back. This is safe to do because (1) we only look at ASCII\n@@ -589,7 +608,7 @@ pub struct Components<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Iter<'a> {\n-    inner: Components<'a>\n+    inner: Components<'a>,\n }\n \n impl<'a> Components<'a> {\n@@ -617,8 +636,16 @@ impl<'a> Components<'a> {\n     // Given the iteration so far, how much of the pre-State::Body path is left?\n     #[inline]\n     fn len_before_body(&self) -> usize {\n-        let root = if self.front <= State::StartDir && self.has_physical_root { 1 } else { 0 };\n-        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() { 1 } else { 0 };\n+        let root = if self.front <= State::StartDir && self.has_physical_root {\n+            1\n+        } else {\n+            0\n+        };\n+        let cur_dir = if self.front <= State::StartDir && self.include_cur_dir() {\n+            1\n+        } else {\n+            0\n+        };\n         self.prefix_remaining() + root + cur_dir\n     }\n \n@@ -653,28 +680,38 @@ impl<'a> Components<'a> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n-        if comps.front == State::Body { comps.trim_left(); }\n-        if comps.back == State::Body { comps.trim_right(); }\n+        if comps.front == State::Body {\n+            comps.trim_left();\n+        }\n+        if comps.back == State::Body {\n+            comps.trim_right();\n+        }\n         unsafe { Path::from_u8_slice(comps.path) }\n     }\n \n     /// Is the *original* path rooted?\n     fn has_root(&self) -> bool {\n-        if self.has_physical_root { return true }\n+        if self.has_physical_root {\n+            return true;\n+        }\n         if let Some(p) = self.prefix {\n-            if p.has_implicit_root() { return true }\n+            if p.has_implicit_root() {\n+                return true;\n+            }\n         }\n         false\n     }\n \n     /// Should the normalized path include a leading . ?\n     fn include_cur_dir(&self) -> bool {\n-        if self.has_root() { return false }\n+        if self.has_root() {\n+            return false;\n+        }\n         let mut iter = self.path[self.prefix_len()..].iter();\n         match (iter.next(), iter.next()) {\n             (Some(&b'.'), None) => true,\n             (Some(&b'.'), Some(&b)) => self.is_sep_byte(b),\n-            _ => false\n+            _ => false,\n         }\n     }\n \n@@ -687,7 +724,7 @@ impl<'a> Components<'a> {\n                           // separately via `include_cur_dir`\n             b\"..\" => Some(Component::ParentDir),\n             b\"\" => None,\n-            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) }))\n+            _ => Some(Component::Normal(unsafe { u8_slice_as_os_str(comp) })),\n         }\n     }\n \n@@ -697,7 +734,7 @@ impl<'a> Components<'a> {\n         debug_assert!(self.front == State::Body);\n         let (extra, comp) = match self.path.iter().position(|b| self.is_sep_byte(*b)) {\n             None => (0, self.path),\n-            Some(i) => (1, &self.path[.. i]),\n+            Some(i) => (1, &self.path[..i]),\n         };\n         (comp.len() + extra, self.parse_single_component(comp))\n     }\n@@ -708,8 +745,8 @@ impl<'a> Components<'a> {\n         debug_assert!(self.back == State::Body);\n         let start = self.len_before_body();\n         let (extra, comp) = match self.path[start..].iter().rposition(|b| self.is_sep_byte(*b)) {\n-            None => (0, &self.path[start ..]),\n-            Some(i) => (1, &self.path[start + i + 1 ..]),\n+            None => (0, &self.path[start..]),\n+            Some(i) => (1, &self.path[start + i + 1..]),\n         };\n         (comp.len() + extra, self.parse_single_component(comp))\n     }\n@@ -721,7 +758,7 @@ impl<'a> Components<'a> {\n             if comp.is_some() {\n                 return;\n             } else {\n-                self.path = &self.path[size ..];\n+                self.path = &self.path[size..];\n             }\n         }\n     }\n@@ -733,7 +770,7 @@ impl<'a> Components<'a> {\n             if comp.is_some() {\n                 return;\n             } else {\n-                self.path = &self.path[.. self.path.len() - size];\n+                self.path = &self.path[..self.path.len() - size];\n             }\n         }\n     }\n@@ -807,12 +844,12 @@ impl<'a> Iterator for Components<'a> {\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.front = State::StartDir;\n                     debug_assert!(self.prefix_len() <= self.path.len());\n-                    let raw = &self.path[.. self.prefix_len()];\n-                    self.path = &self.path[self.prefix_len() .. ];\n+                    let raw = &self.path[..self.prefix_len()];\n+                    self.path = &self.path[self.prefix_len()..];\n                     return Some(Component::Prefix(PrefixComponent {\n                         raw: unsafe { u8_slice_as_os_str(raw) },\n-                        parsed: self.prefix.unwrap()\n-                    }))\n+                        parsed: self.prefix.unwrap(),\n+                    }));\n                 }\n                 State::Prefix => {\n                     self.front = State::StartDir;\n@@ -822,26 +859,28 @@ impl<'a> Iterator for Components<'a> {\n                     if self.has_physical_root {\n                         debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n-                        return Some(Component::RootDir)\n+                        return Some(Component::RootDir);\n                     } else if let Some(p) = self.prefix {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n-                            return Some(Component::RootDir)\n+                            return Some(Component::RootDir);\n                         }\n                     } else if self.include_cur_dir() {\n                         debug_assert!(!self.path.is_empty());\n                         self.path = &self.path[1..];\n-                        return Some(Component::CurDir)\n+                        return Some(Component::CurDir);\n                     }\n                 }\n                 State::Body if !self.path.is_empty() => {\n                     let (size, comp) = self.parse_next_component();\n-                    self.path = &self.path[size ..];\n-                    if comp.is_some() { return comp }\n+                    self.path = &self.path[size..];\n+                    if comp.is_some() {\n+                        return comp;\n+                    }\n                 }\n                 State::Body => {\n                     self.front = State::Done;\n                 }\n-                State::Done => unreachable!()\n+                State::Done => unreachable!(),\n             }\n         }\n         None\n@@ -855,38 +894,40 @@ impl<'a> DoubleEndedIterator for Components<'a> {\n             match self.back {\n                 State::Body if self.path.len() > self.len_before_body() => {\n                     let (size, comp) = self.parse_next_component_back();\n-                    self.path = &self.path[.. self.path.len() - size];\n-                    if comp.is_some() { return comp }\n+                    self.path = &self.path[..self.path.len() - size];\n+                    if comp.is_some() {\n+                        return comp;\n+                    }\n                 }\n                 State::Body => {\n                     self.back = State::StartDir;\n                 }\n                 State::StartDir => {\n                     self.back = State::Prefix;\n                     if self.has_physical_root {\n-                        self.path = &self.path[.. self.path.len() - 1];\n-                        return Some(Component::RootDir)\n+                        self.path = &self.path[..self.path.len() - 1];\n+                        return Some(Component::RootDir);\n                     } else if let Some(p) = self.prefix {\n                         if p.has_implicit_root() && !p.is_verbatim() {\n-                            return Some(Component::RootDir)\n+                            return Some(Component::RootDir);\n                         }\n                     } else if self.include_cur_dir() {\n-                        self.path = &self.path[.. self.path.len() - 1];\n-                        return Some(Component::CurDir)\n+                        self.path = &self.path[..self.path.len() - 1];\n+                        return Some(Component::CurDir);\n                     }\n                 }\n                 State::Prefix if self.prefix_len() > 0 => {\n                     self.back = State::Done;\n                     return Some(Component::Prefix(PrefixComponent {\n                         raw: unsafe { u8_slice_as_os_str(self.path) },\n-                        parsed: self.prefix.unwrap()\n-                    }))\n+                        parsed: self.prefix.unwrap(),\n+                    }));\n                 }\n                 State::Prefix => {\n                     self.back = State::Done;\n-                    return None\n+                    return None;\n                 }\n-                State::Done => unreachable!()\n+                State::Done => unreachable!(),\n             }\n         }\n         None\n@@ -943,7 +984,7 @@ impl<'a> cmp::Ord for Components<'a> {\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PathBuf {\n-    inner: OsString\n+    inner: OsString,\n }\n \n impl PathBuf {\n@@ -984,10 +1025,8 @@ impl PathBuf {\n         // in the special case of `C:` on Windows, do *not* add a separator\n         {\n             let comps = self.components();\n-            if comps.prefix_len() > 0 &&\n-                comps.prefix_len() == comps.path.len() &&\n-                comps.prefix.unwrap().is_drive()\n-            {\n+            if comps.prefix_len() > 0 && comps.prefix_len() == comps.path.len() &&\n+               comps.prefix.unwrap().is_drive() {\n                 need_sep = false\n             }\n         }\n@@ -1020,7 +1059,7 @@ impl PathBuf {\n                 self.as_mut_vec().truncate(len);\n                 true\n             }\n-            None => false\n+            None => false,\n         }\n     }\n \n@@ -1067,7 +1106,9 @@ impl PathBuf {\n     }\n \n     fn _set_extension(&mut self, extension: &OsStr) -> bool {\n-        if self.file_name().is_none() { return false; }\n+        if self.file_name().is_none() {\n+            return false;\n+        }\n \n         let mut stem = match self.file_stem() {\n             Some(stem) => stem.to_os_string(),\n@@ -1185,7 +1226,9 @@ impl<'a> From<PathBuf> for Cow<'a, Path> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for Path {\n     type Owned = PathBuf;\n-    fn to_owned(&self) -> PathBuf { self.to_path_buf() }\n+    fn to_owned(&self) -> PathBuf {\n+        self.to_path_buf()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1257,7 +1300,7 @@ impl Into<OsString> for PathBuf {\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Path {\n-    inner: OsStr\n+    inner: OsStr,\n }\n \n impl Path {\n@@ -1380,8 +1423,7 @@ impl Path {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_absolute(&self) -> bool {\n-        self.has_root() &&\n-            (cfg!(unix) || self.prefix().is_some())\n+        self.has_root() && (cfg!(unix) || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n@@ -1428,7 +1470,7 @@ impl Path {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn has_root(&self) -> bool {\n-         self.components().has_root()\n+        self.components().has_root()\n     }\n \n     /// The path without its final component, if any.\n@@ -1452,11 +1494,13 @@ impl Path {\n     pub fn parent(&self) -> Option<&Path> {\n         let mut comps = self.components();\n         let comp = comps.next_back();\n-        comp.and_then(|p| match p {\n-            Component::Normal(_) |\n-            Component::CurDir |\n-            Component::ParentDir => Some(comps.as_path()),\n-            _ => None\n+        comp.and_then(|p| {\n+            match p {\n+                Component::Normal(_) |\n+                Component::CurDir |\n+                Component::ParentDir => Some(comps.as_path()),\n+                _ => None,\n+            }\n         })\n     }\n \n@@ -1478,9 +1522,11 @@ impl Path {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n-        self.components().next_back().and_then(|p| match p {\n-            Component::Normal(p) => Some(p.as_ref()),\n-            _ => None\n+        self.components().next_back().and_then(|p| {\n+            match p {\n+                Component::Normal(p) => Some(p.as_ref()),\n+                _ => None,\n+            }\n         })\n     }\n \n@@ -1490,8 +1536,7 @@ impl Path {\n     /// returns false), then `relative_from` returns `None`.\n     #[unstable(feature = \"path_relative_from\", reason = \"see #23284\",\n                issue = \"23284\")]\n-    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path>\n-    {\n+    pub fn relative_from<'a, P: ?Sized + AsRef<Path>>(&'a self, base: &'a P) -> Option<&Path> {\n         self._relative_from(base.as_ref())\n     }\n \n@@ -1815,7 +1860,7 @@ impl fmt::Debug for Path {\n /// Helper struct for safely printing paths with `format!()` and `{}`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Display<'a> {\n-    path: &'a Path\n+    path: &'a Path,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1867,32 +1912,44 @@ impl cmp::Ord for Path {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for Path {\n-    fn as_ref(&self) -> &Path { self }\n+    fn as_ref(&self) -> &Path {\n+        self\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsStr {\n-    fn as_ref(&self) -> &Path { Path::new(self) }\n+    fn as_ref(&self) -> &Path {\n+        Path::new(self)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for OsString {\n-    fn as_ref(&self) -> &Path { Path::new(self) }\n+    fn as_ref(&self) -> &Path {\n+        Path::new(self)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for str {\n-    fn as_ref(&self) -> &Path { Path::new(self) }\n+    fn as_ref(&self) -> &Path {\n+        Path::new(self)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for String {\n-    fn as_ref(&self) -> &Path { Path::new(self) }\n+    fn as_ref(&self) -> &Path {\n+        Path::new(self)\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl AsRef<Path> for PathBuf {\n-    fn as_ref(&self) -> &Path { self }\n+    fn as_ref(&self) -> &Path {\n+        self\n+    }\n }\n \n #[stable(feature = \"path_into_iter\", since = \"1.6.0\")]\n@@ -2990,20 +3047,26 @@ mod tests {\n             tp!(\"C:a\\\\b\\\\c\", \"C:d\", \"C:d\");\n             tp!(\"C:\", r\"a\\b\\c\", r\"C:a\\b\\c\");\n             tp!(\"C:\", r\"..\\a\", r\"C:..\\a\");\n-            tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\server\\\\share\\\\foo\",\n+                \"bar\",\n+                \"\\\\\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\server\\\\share\\\\foo\", \"C:baz\", \"C:baz\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:a\\\\b\", \"C:c\\\\d\", \"C:c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"C:\\\\c\\\\d\", \"C:\\\\c\\\\d\");\n             tp!(\"\\\\\\\\?\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\?\\\\foo\\\\bar\\\\baz\");\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\", \"bar\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\",\n+                \"bar\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\foo\\\\bar\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:\\\\a\", \"C:\\\\a\");\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"C:a\", \"C:a\");\n \n             // Note: modified from old path API\n             tp!(\"\\\\\\\\?\\\\UNC\\\\server\", \"foo\", \"\\\\\\\\?\\\\UNC\\\\server\\\\foo\");\n \n-            tp!(\"C:\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n+            tp!(\"C:\\\\a\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"baz\", \"\\\\\\\\.\\\\foo\\\\bar\\\\baz\");\n             tp!(\"\\\\\\\\.\\\\foo\\\\bar\", \"C:a\", \"C:a\");\n             // again, not sure about the following, but I'm assuming \\\\.\\ should be verbatim\n@@ -3056,9 +3119,15 @@ mod tests {\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\\\\b\", \"\\\\\\\\?\\\\C:\\\\a\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\a\", \"\\\\\\\\?\\\\C:\\\\\", true);\n             tp!(\"\\\\\\\\?\\\\C:\\\\\", \"\\\\\\\\?\\\\C:\\\\\", false);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\", true);\n-            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\", \"\\\\\\\\?\\\\UNC\\\\server\\\\share\", false);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\\\\b\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n+                true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\a\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\\\\\",\n+                true);\n+            tp!(\"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n+                \"\\\\\\\\?\\\\UNC\\\\server\\\\share\",\n+                false);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\\\\c\", \"\\\\\\\\.\\\\a\\\\b\", true);\n             tp!(\"\\\\\\\\.\\\\a\\\\b\", \"\\\\\\\\.\\\\a\\\\\", true);\n             tp!(\"\\\\\\\\.\\\\a\", \"\\\\\\\\.\\\\a\", false);\n@@ -3124,7 +3193,7 @@ mod tests {\n         tfe!(\".\", \"foo\", \".\", false);\n         tfe!(\"foo/\", \"bar\", \"foo.bar\", true);\n         tfe!(\"foo/.\", \"bar\", \"foo.bar\", true);\n-        tfe!(\"..\", \"foo\", \"..\",  false);\n+        tfe!(\"..\", \"foo\", \"..\", false);\n         tfe!(\"foo/..\", \"bar\", \"foo/..\", false);\n         tfe!(\"/\", \"foo\", \"/\", false);\n     }"}]}