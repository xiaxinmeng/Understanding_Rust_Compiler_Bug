{"sha": "35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YTkzZTYxZDQ4MGMwZjQyNDRhMGVhZjdhYjkyY2Q0NGYzNDcxMGU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-16T05:06:19Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-04-17T02:48:00Z"}, "message": "rewrite region resolution so it takes place in typeck", "tree": {"sha": "ef32279722d146675d7cf898190e098549084e53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef32279722d146675d7cf898190e098549084e53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "html_url": "https://github.com/rust-lang/rust/commit/35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a532ad282887a4e0f40cf20a0e893acf861f8413", "url": "https://api.github.com/repos/rust-lang/rust/commits/a532ad282887a4e0f40cf20a0e893acf861f8413", "html_url": "https://github.com/rust-lang/rust/commit/a532ad282887a4e0f40cf20a0e893acf861f8413"}], "stats": {"total": 1921, "additions": 1026, "deletions": 895}, "files": [{"sha": "70be86ff577f4cd7ea020519612d9e3d5c0cc134", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -1270,7 +1270,7 @@ are written after the name of the implementation, or if that is not\n specified, after the `impl` keyword.\n \n ~~~~\n-# iface seq { }\n+# iface seq<T> { }\n \n impl <T> of seq<T> for [T] {\n     /* ... */"}, {"sha": "b2cc30e7cfee4dc0a2c26542f800bb850285d98c", "filename": "src/etc/indenter", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Fetc%2Findenter", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Fetc%2Findenter", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Findenter?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -1,6 +1,6 @@\n #!/usr/bin/perl -w\n \n-$ident = 0;\n+$indent = 0;\n while (<>) {\n     if (/^rust: \">>/) {\n         $indent += 1;"}, {"sha": "eff29d1e55b7df4650078db133a3fe7bd8c659a1", "filename": "src/libcore/option.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -101,6 +101,15 @@ impl extensions<T:copy> for option<T> {\n     #[doc = \"Performs an operation on the contained value or does nothing\"]\n     fn iter(f: fn(T)) { iter(self, f) }\n \n+    #[doc = \"Converts `none` to a zero-element list and `some` to a \\\n+             one-element list.\"]\n+    fn to_vec() -> [T] {\n+        alt self {\n+          some(t) { [t] }\n+          none { [] }\n+        }\n+    }\n+\n     #[doc = \"Performs an operation on the contained value or does nothing\"]\n     fn each(f: fn(T) -> bool) {\n         alt self {"}, {"sha": "477a22773da1784127d98cd80e1b70c5de42dbbc", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -451,9 +451,8 @@ type region = {id: node_id, node: region_};\n \n #[auto_serialize]\n enum region_ {\n-    re_inferred,\n+    re_anon,\n     re_named(ident),\n-    re_self,\n     re_static\n }\n "}, {"sha": "93bc76e37b4efe64ad7e75d1f27b599b44146470", "filename": "src/librustsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fparser.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -451,15 +451,13 @@ fn parse_ret_ty(p: parser) -> (ast::ret_style, @ast::ty) {\n fn region_from_name(p: parser, s: option<str>) -> ast::region {\n     let r = alt s {\n       some (string) {\n-        if string == \"self\" {\n-            ast::re_self\n-        } else if string == \"static\" {\n+        if string == \"static\" {\n             ast::re_static\n         } else {\n             ast::re_named(string)\n         }\n       }\n-      none { ast::re_inferred }\n+      none { ast::re_anon }\n     };\n \n     {id: p.get_id(), node: r}"}, {"sha": "4aa994bf2bd6b19ca1cd084de8c53a6b57e9419c", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -320,9 +320,8 @@ fn print_native_mod(s: ps, nmod: ast::native_mod, attrs: [ast::attribute]) {\n \n fn print_region(s: ps, region: ast::region) {\n     alt region.node {\n-      ast::re_inferred { /* no-op */ }\n+      ast::re_anon { /* no-op */ }\n       ast::re_named(name) { word(s.s, name); word(s.s, \".\"); }\n-      ast::re_self { word(s.s, \"self\"); word(s.s, \".\"); }\n       ast::re_static { word(s.s, \"static\"); word(s.s, \".\"); }\n     }\n }\n@@ -826,8 +825,7 @@ fn print_vstore(s: ps, t: ast::vstore) {\n       ast::vstore_box { word_space(s, \"/@\"); }\n       ast::vstore_slice(r) {\n         alt r.node {\n-          ast::re_inferred { word_space(s, \"/&\"); }\n-          ast::re_self { word_space(s, \"/&self\"); }\n+          ast::re_anon { word_space(s, \"/&\"); }\n           ast::re_static { word_space(s, \"/&static\"); }\n           ast::re_named(name) {\n             word(s.s, \"/&\");"}, {"sha": "5815dbf87a5b7e3d8b54adc5048dfd0f9958ad87", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -104,10 +104,8 @@ fn enc_bound_region(w: io::writer, br: ty::bound_region) {\n     alt br {\n       ty::br_self { w.write_char('s') }\n       ty::br_anon { w.write_char('a') }\n-      ty::br_param(id, s) {\n+      ty::br_named(s) {\n         w.write_char('[');\n-        w.write_uint(id);\n-        w.write_char('|');\n         w.write_str(s);\n         w.write_char(']')\n       }\n@@ -132,9 +130,6 @@ fn enc_region(w: io::writer, r: ty::region) {\n         w.write_int(nid);\n         w.write_char('|');\n       }\n-      ty::re_default {\n-        w.write_char('i');\n-      }\n       ty::re_var(id) {\n         w.write_char('v');\n         w.write_uint(id.to_uint());"}, {"sha": "074ba50e02c9a439185fbf3cad0fbcfb25b601cd", "filename": "src/rustc/middle/infer.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Finfer.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -592,7 +592,7 @@ impl resolve_methods for infer_ctxt {\n             self.rb,\n             {|_t| false },\n             rid,\n-            {|| err(unresolved_region(rid)) });\n+            {|| ok(ty::re_static) });\n     }\n \n     fn resolve_ty(typ: ty::t) -> fres<ty::t> {\n@@ -1169,7 +1169,10 @@ impl of combine for sub {\n     }\n \n     fn regions(a: ty::region, b: ty::region) -> cres<ty::region> {\n-        #debug[\"regions(%s <= %s)\", a.to_str(*self), b.to_str(*self)];\n+        #debug[\"%s.regions(%s, %s)\",\n+               self.tag(),\n+               a.to_str(self.infcx()),\n+               b.to_str(self.infcx())];\n         indent {||\n             alt (a, b) {\n               (ty::re_var(a_id), ty::re_var(b_id)) {\n@@ -1376,8 +1379,7 @@ impl of combine for lub {\n                            {|x, y| self.regions(x, y) })\n               }\n \n-              (ty::re_var(v_id), r) |\n-              (r, ty::re_var(v_id)) {\n+              (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n                 lattice_var_t(self, self.infcx().rb,\n                               v_id, r,\n                               {|x, y| self.regions(x, y) })\n@@ -1415,12 +1417,6 @@ impl of combine for lub {\n                     err(ty::terr_regions_differ(b, a))\n                 }\n               }\n-\n-              (ty::re_default, _) |\n-              (_, ty::re_default) {\n-                // actually a compiler bug, I think.\n-                err(ty::terr_regions_differ(b, a))\n-              }\n             }\n         }\n     }\n@@ -1561,10 +1557,10 @@ impl of combine for glb {\n                              {|x, y| self.regions(x, y) })\n               }\n \n-              (ty::re_var(v_id), _) | (_, ty::re_var(v_id)) {\n-               lattice_var_t(self, self.infcx().rb,\n-                             v_id, b,\n-                             {|x, y| self.regions(x, y) })\n+              (ty::re_var(v_id), r) | (r, ty::re_var(v_id)) {\n+                lattice_var_t(self, self.infcx().rb,\n+                              v_id, r,\n+                              {|x, y| self.regions(x, y) })\n               }\n \n               (f @ ty::re_free(f_id, f_br), ty::re_scope(s_id)) |\n@@ -1601,12 +1597,6 @@ impl of combine for glb {\n                     err(ty::terr_regions_differ(b, a))\n                 }\n               }\n-\n-              (ty::re_default, _) |\n-              (_, ty::re_default) {\n-                // actually a compiler bug, I think.\n-                err(ty::terr_regions_differ(b, a))\n-              }\n             }\n         }\n     }\n@@ -1727,7 +1717,7 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     let {root: a_vid, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n     let {root: b_vid, bounds: b_bounds} = self.infcx().get(vb, b_vid);\n \n-    #debug[\"%s.vars(%s=%s <: %s=%s)\",\n+    #debug[\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n            a_vid.to_str(), a_bounds.to_str(self.infcx()),\n            b_vid.to_str(), b_bounds.to_str(self.infcx())];\n@@ -1758,15 +1748,15 @@ fn lattice_vars<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n \n fn lattice_var_t<V:copy vid, T:copy to_str st, L:lattice_ops combine>(\n     self: L, vb: vals_and_bindings<V, T>,\n-    a_vid: V, b: T,\n+    a_id: V, b: T,\n     c_ts: fn(T, T) -> cres<T>) -> cres<T> {\n \n-    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_vid);\n+    let {root: a_id, bounds: a_bounds} = self.infcx().get(vb, a_id);\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n-    #debug[\"%s.var_ty(%s=%s <: %s)\",\n+    #debug[\"%s.lattice_vart(%s=%s <: %s)\",\n            self.tag(),\n            a_id.to_str(), a_bounds.to_str(self.infcx()),\n            b.to_str(self.infcx())];"}, {"sha": "e27d41d4ee02aa1c9893c1a97cd35b880eb9faa2", "filename": "src/rustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 117, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregion.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -162,12 +162,9 @@ type binding = {node_id: ast::node_id,\n type region_map = {\n     /* Mapping from a block/function expression to its parent. */\n     parents: hashmap<ast::node_id,ast::node_id>,\n-    /* Mapping from a region type in the AST to its resolved region. */\n-    ast_type_to_region: hashmap<ast::node_id,ty::region>,\n+\n     /* Mapping from a local variable to its containing block. */\n-    local_blocks: hashmap<ast::node_id,ast::node_id>,\n-    /* Mapping from an AST type node to the region that `&` resolves to. */\n-    ast_type_to_inferred_region: hashmap<ast::node_id,ty::region>,\n+    local_blocks: hashmap<ast::node_id,ast::node_id>\n };\n \n type region_scope = @{\n@@ -198,69 +195,6 @@ impl methods for region_scope {\n     fn self_subscope(node_id: ast::node_id) -> region_scope {\n         @{node_id: node_id, kind: rsk_self(self)}\n     }\n-\n-    fn find(nm: str) -> option<binding> {\n-        alt self.kind {\n-          rsk_root { none }\n-          rsk_body(parent) { parent.find(nm) }\n-          rsk_self(parent) { parent.find(nm) }\n-          rsk_binding(parent, bs) {\n-            alt (*bs).find({|b| b.name == nm }) {\n-              none { parent.find(nm) }\n-              some(b) { some(b) }\n-            }\n-          }\n-        }\n-    }\n-\n-    // fn resolve_anon() -> option<ty::region> {\n-    //     alt self.kind {\n-    //       rsk_root { none }\n-    //       rsk_body(_) { none }\n-    //       rsk_self(_) { none }\n-    //       rsk_binding(_, _) { ty::re_bound(ty::br_anon) }\n-    //     }\n-    // }\n-\n-    fn resolve_self_helper(bound: bool) -> option<ty::region> {\n-        alt self.kind {\n-          rsk_root { none }\n-          rsk_self(_) if bound { some(ty::re_bound(ty::br_self)) }\n-          rsk_self(_) { some(ty::re_free(self.node_id, ty::br_self)) }\n-          rsk_binding(p, _) { p.resolve_self_helper(bound) }\n-          rsk_body(p) { p.resolve_self_helper(false) }\n-        }\n-    }\n-\n-    fn resolve_self() -> option<ty::region> {\n-        self.resolve_self_helper(true)\n-    }\n-\n-    fn resolve_ident(nm: str) -> option<ty::region> {\n-        alt self.find(nm) {\n-          some(b) if b.node_id == self.node_id {\n-            some(ty::re_bound(b.br))\n-          }\n-\n-          some(b) {\n-            some(ty::re_free(b.node_id, b.br))\n-          }\n-\n-          none {\n-            alt self.kind {\n-              rsk_self(_) | rsk_root | rsk_body(_) { none }\n-              rsk_binding(_, bs) {\n-                let idx = (*bs).len();\n-                let br = ty::br_param(idx, nm);\n-                vec::push(*bs, {node_id: self.node_id,\n-                                name: nm,\n-                                br: br});\n-                some(ty::re_bound(br))\n-              }\n-            }\n-          }\n-        }\n-    }\n }\n \n type ctxt = {\n@@ -351,50 +285,6 @@ fn get_inferred_region(cx: ctxt, sp: syntax::codemap::span) -> ty::region {\n     }\n }\n \n-fn resolve_region_binding(cx: ctxt, span: span,\n-                          region: ast::region) -> ty::region {\n-    alt region.node {\n-      ast::re_inferred { ty::re_default }\n-      ast::re_static { ty::re_static }\n-      ast::re_named(ident) {\n-        alt cx.scope.resolve_ident(ident) {\n-          some(r) { r }\n-          none {\n-            cx.sess.span_fatal(\n-                span,\n-                #fmt[\"the region `%s` is not declared\", ident]);\n-          }\n-        }\n-      }\n-      ast::re_self {\n-        alt cx.scope.resolve_self() {\n-          some(r) { r }\n-          none {\n-            cx.sess.span_fatal(\n-                span,\n-                \"the `self` region is not allowed here\");\n-          }\n-        }\n-      }\n-    }\n-}\n-\n-fn resolve_ty(ty: @ast::ty, cx: ctxt, visitor: visit::vt<ctxt>) {\n-    let inferred_region = get_inferred_region(cx, ty.span);\n-    cx.region_map.ast_type_to_inferred_region.insert(ty.id, inferred_region);\n-\n-    alt ty.node {\n-      ast::ty_vstore(_, ast::vstore_slice(r)) |\n-      ast::ty_rptr(r, _) {\n-        let region = resolve_region_binding(cx, ty.span, r);\n-        cx.region_map.ast_type_to_region.insert(ty.id, region);\n-      }\n-      _ { /* nothing to do */ }\n-    }\n-\n-    visit::visit_ty(ty, cx, visitor);\n-}\n-\n fn opt_parent_id(cx: ctxt) -> option<ast::node_id> {\n     alt cx.parent {\n       pa_fn_item(parent_id) |\n@@ -531,16 +421,12 @@ fn resolve_crate(sess: session, def_map: resolve::def_map, crate: @ast::crate)\n     let cx: ctxt = {sess: sess,\n                     def_map: def_map,\n                     region_map: @{parents: map::int_hash(),\n-                                  ast_type_to_region: map::int_hash(),\n-                                  local_blocks: map::int_hash(),\n-                                  ast_type_to_inferred_region:\n-                                    map::int_hash()},\n+                                  local_blocks: map::int_hash()},\n                     scope: root_scope(0),\n                     parent: pa_crate};\n     let visitor = visit::mk_vt(@{\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n-        visit_ty: resolve_ty,\n         visit_arm: resolve_arm,\n         visit_pat: resolve_pat,\n         visit_expr: resolve_expr,"}, {"sha": "58c165717c7d39639007f710ac8faa873cb3f73e", "filename": "src/rustc/middle/regionck.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fregionck.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -15,12 +15,13 @@ fn check_expr(expr: @ast::expr,\n     visit::visit_expr(expr, tcx, visitor);\n \n     let t = ty::expr_ty(tcx, expr);\n-    if !ty::type_has_rptrs(t) { ret; }\n+    if !ty::type_has_regions(t) { ret; }\n     ty::walk_ty(t) { |t|\n         alt ty::get(t).struct {\n           ty::ty_rptr(region, _) {\n             alt region {\n-              ty::re_bound(_) | ty::re_free(_, _) | ty::re_static {\n+              ty::re_bound(_) | ty::re_free(_, _) | ty::re_static |\n+              ty::re_var(_) {\n                 /* ok */\n               }\n               ty::re_scope(id) {\n@@ -31,9 +32,6 @@ fn check_expr(expr: @ast::expr,\n                              ppaux::re_scope_id_to_str(tcx, id)]);\n                 }\n               }\n-              ty::re_default | ty::re_var(_) {\n-                tcx.sess.span_bug(expr.span, \"unresolved region\");\n-              }\n             }\n           }\n           _ { /* no-op */ }"}, {"sha": "20cb0990dd3ba92a0ddc50e86b99d21e08b83c5d", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -36,7 +36,7 @@ export expr_ty;\n export expr_ty_params_and_ty;\n export expr_is_lval;\n export field_ty;\n-export fold_ty, fold_sty_to_ty, fold_region, fold_ty_var;\n+export fold_ty, fold_sty_to_ty, fold_region, fold_regions, fold_ty_var;\n export field;\n export field_idx;\n export get_field;\n@@ -99,7 +99,7 @@ export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n export ty_var, mk_var;\n export ty_self, mk_self;\n export region, bound_region;\n-export get, type_has_params, type_has_vars, type_has_rptrs, type_id;\n+export get, type_has_params, type_has_vars, type_has_regions, type_id;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n@@ -230,7 +230,7 @@ type t_box = @{struct: sty,\n                id: uint,\n                has_params: bool,\n                has_vars: bool,\n-               has_rptrs: bool,\n+               has_regions: bool,\n                o_def_id: option<ast::def_id>};\n \n // To reduce refcounting cost, we're representing types as unsafe pointers\n@@ -250,7 +250,7 @@ pure fn get(t: t) -> t_box unsafe {\n \n fn type_has_params(t: t) -> bool { get(t).has_params }\n fn type_has_vars(t: t) -> bool { get(t).has_vars }\n-fn type_has_rptrs(t: t) -> bool { get(t).has_rptrs }\n+fn type_has_regions(t: t) -> bool { get(t).has_regions }\n fn type_def_id(t: t) -> option<ast::def_id> { get(t).o_def_id }\n fn type_id(t: t) -> uint { get(t).id }\n \n@@ -272,20 +272,13 @@ enum region {\n     re_free(node_id, bound_region),\n     re_scope(node_id),\n     re_var(region_vid),\n-    re_static, // effectively `top` in the region lattice\n-    re_default\n+    re_static // effectively `top` in the region lattice\n }\n \n enum bound_region {\n-    // The `self` region for a given class/impl/iface.  The defining item may\n-    // appear in another crate.\n-    br_self,\n-\n-    // The anonymous region parameter for a given function.\n-    br_anon,\n-\n-    // A named region parameter.\n-    br_param(uint, str)\n+    br_self,      // The self region for classes, impls\n+    br_anon,      // The anonymous region parameter for a given function.\n+    br_named(str) // A named region parameter.\n }\n \n // NB: If you change this, you'll probably want to change the corresponding\n@@ -461,21 +454,21 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       some(t) { unsafe { ret unsafe::reinterpret_cast(t); } }\n       _ {}\n     }\n-    let mut has_params = false, has_vars = false, has_rptrs = false;\n-    fn derive_flags(&has_params: bool, &has_vars: bool, &has_rptrs: bool,\n+    let mut has_params = false, has_vars = false, has_regions = false;\n+    fn derive_flags(&has_params: bool, &has_vars: bool, &has_regions: bool,\n                     tt: t) {\n         let t = get(tt);\n         has_params |= t.has_params;\n         has_vars |= t.has_vars;\n-        has_rptrs |= t.has_rptrs;\n+        has_regions |= t.has_regions;\n     }\n     alt st {\n       ty_estr(vstore_slice(_)) {\n-        has_rptrs = true;\n+        has_regions = true;\n       }\n       ty_evec(mt, vstore_slice(_)) {\n-        has_rptrs = true;\n-        derive_flags(has_params, has_vars, has_rptrs, mt.ty);\n+        has_regions = true;\n+        derive_flags(has_params, has_vars, has_regions, mt.ty);\n       }\n       ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_str | ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) |\n@@ -484,49 +477,50 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n       ty_var(_) | ty_self(_) { has_vars = true; }\n       ty_enum(_, tys) | ty_iface(_, tys) | ty_class(_, tys) {\n         for tys.each {|tt|\n-            derive_flags(has_params, has_vars, has_rptrs, tt);\n+            derive_flags(has_params, has_vars, has_regions, tt);\n         }\n       }\n       ty_box(m) | ty_uniq(m) | ty_vec(m) | ty_evec(m, _) | ty_ptr(m) {\n-        derive_flags(has_params, has_vars, has_rptrs, m.ty);\n+        derive_flags(has_params, has_vars, has_regions, m.ty);\n       }\n       ty_rptr(r, m) {\n         alt r {\n           ty::re_var(_) { has_vars = true; }\n           _ { }\n         }\n-        has_rptrs = true;\n-        derive_flags(has_params, has_vars, has_rptrs, m.ty);\n+        has_regions = true;\n+        derive_flags(has_params, has_vars, has_regions, m.ty);\n       }\n       ty_rec(flds) {\n         for flds.each {|f|\n-          derive_flags(has_params, has_vars, has_rptrs, f.mt.ty);\n+          derive_flags(has_params, has_vars, has_regions, f.mt.ty);\n         }\n       }\n       ty_tup(ts) {\n-        for ts.each {|tt| derive_flags(has_params, has_vars, has_rptrs, tt); }\n+        for ts.each {|tt| derive_flags(has_params, has_vars,\n+                                       has_regions, tt); }\n       }\n       ty_fn(f) {\n         for f.inputs.each {|a|\n-          derive_flags(has_params, has_vars, has_rptrs, a.ty);\n+          derive_flags(has_params, has_vars, has_regions, a.ty);\n         }\n-        derive_flags(has_params, has_vars, has_rptrs, f.output);\n+        derive_flags(has_params, has_vars, has_regions, f.output);\n       }\n       ty_res(_, tt, tps) {\n-        derive_flags(has_params, has_vars, has_rptrs, tt);\n+        derive_flags(has_params, has_vars, has_regions, tt);\n         for tps.each {|tt|\n-            derive_flags(has_params, has_vars, has_rptrs, tt);\n+            derive_flags(has_params, has_vars, has_regions, tt);\n         }\n       }\n       ty_constr(tt, _) {\n-        derive_flags(has_params, has_vars, has_rptrs, tt);\n+        derive_flags(has_params, has_vars, has_regions, tt);\n       }\n     }\n     let t = @{struct: st,\n               id: cx.next_id,\n               has_params: has_params,\n               has_vars: has_vars,\n-              has_rptrs: has_rptrs,\n+              has_regions: has_regions,\n               o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n     cx.next_id += 1u;\n@@ -771,11 +765,53 @@ fn fold_ty_var(cx: ctxt, t0: t, fldop: fn(ty_vid) -> t) -> t {\n     }\n }\n \n+// n.b. this function is intended to eventually replace fold_region() below,\n+// that is why its name is so similar.\n+fn fold_regions(\n+    cx: ctxt,\n+    ty: t,\n+    fldr: fn(r: region, in_fn: bool) -> region) -> t {\n+\n+    fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n+               fldr: fn(region, bool) -> region) -> t {\n+        let tb = ty::get(ty);\n+        if !tb.has_regions { ret ty; }\n+        alt tb.struct {\n+          ty::ty_rptr(r, mt) {\n+            let m_r = fldr(r, in_fn);\n+            let m_t = do_fold(cx, mt.ty, in_fn, fldr);\n+            ty::mk_rptr(cx, m_r, {ty: m_t, mutbl: mt.mutbl})\n+          }\n+          ty_estr(vstore_slice(r)) {\n+            let m_r = fldr(r, in_fn);\n+            ty::mk_estr(cx, vstore_slice(m_r))\n+          }\n+          ty_evec(mt, vstore_slice(r)) {\n+            let m_r = fldr(r, in_fn);\n+            let m_t = do_fold(cx, mt.ty, in_fn, fldr);\n+            ty::mk_evec(cx, {ty: m_t, mutbl: mt.mutbl}, vstore_slice(m_r))\n+          }\n+          sty @ ty_fn(_) {\n+            fold_sty_to_ty(cx, sty) {|t|\n+                do_fold(cx, t, true, fldr)\n+            }\n+          }\n+          sty {\n+            fold_sty_to_ty(cx, sty) {|t|\n+                do_fold(cx, t, in_fn, fldr)\n+            }\n+          }\n+        }\n+    }\n+\n+    do_fold(cx, ty, false, fldr)\n+}\n+\n fn fold_region(cx: ctxt, t0: t, fldop: fn(region, bool) -> region) -> t {\n     fn do_fold(cx: ctxt, t0: t, under_r: bool,\n                fldop: fn(region, bool) -> region) -> t {\n         let tb = get(t0);\n-        if !tb.has_rptrs { ret t0; }\n+        if !tb.has_regions { ret t0; }\n         alt tb.struct {\n           ty_rptr(r, {ty: t1, mutbl: m}) {\n             let m_r = fldop(r, under_r);\n@@ -1544,9 +1580,9 @@ fn type_autoderef(cx: ctxt, t: t) -> t {\n \n fn hash_bound_region(br: bound_region) -> uint {\n     alt br { // no idea if this is any good\n-      br_self { 0u }\n-      br_anon { 1u }\n-      br_param(id, _) { id }\n+      ty::br_self { 0u }\n+      ty::br_anon { 1u }\n+      ty::br_named(str) { str::hash(str) }\n     }\n }\n \n@@ -1588,8 +1624,7 @@ fn hash_type_structure(st: sty) -> uint {\n                                (hash_bound_region(br)) << 2u | 1u }\n           re_scope(id)  { ((id as uint) << 2u) | 2u }\n           re_var(id)    { (id.to_uint() << 2u) | 3u }\n-          re_default    { 4u }\n-          re_bot        { 5u }\n+          re_bot        { 4u }\n         }\n     }\n     alt st {"}, {"sha": "03410694283f1e0efa2cf2845ff1e23102ab75fd", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 899, "deletions": 690, "changes": 1589, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -21,6 +21,8 @@ import std::serialization::{serialize_uint, deserialize_uint};\n import std::ufind;\n import syntax::print::pprust::*;\n import util::common::indent;\n+import std::list;\n+import list::{list, nil, cons};\n \n export check_crate;\n export method_map;\n@@ -65,6 +67,10 @@ type crate_ctxt = {impl_map: resolve::impl_map,\n \n type class_map = hashmap<ast::node_id, ty::t>;\n \n+// a list of mapping from in-scope-region-names (\"isr\") to the\n+// corresponding ty::region\n+type isr_alist = @list<(str, ty::region)>;\n+\n type fn_ctxt =\n     // var_bindings, locals and next_var_id are shared\n     // with any nested functions that capture the environment\n@@ -77,8 +83,10 @@ type fn_ctxt =\n      proto: ast::proto,\n      infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, ty_vid>,\n-     next_var_id: @mut uint,\n-     next_region_var_id: @mut uint,\n+     ty_var_counter: @mut uint,\n+     region_var_counter: @mut uint,\n+\n+     in_scope_regions: isr_alist,\n \n      // While type checking a function, the intermediate types for the\n      // expressions, blocks, and so forth contained within the function are\n@@ -225,7 +233,7 @@ fn instantiate_path(fcx: @fn_ctxt, pth: @ast::path,\n                 sp, \"this item does not take type parameters\");\n         }\n         let substs = vec::map(pth.node.types, {|aty|\n-            ast_ty_to_ty_crate(fcx.ccx, aty)\n+            fcx.to_ty(aty)\n         });\n         fcx.write_ty_substs(id, tpt.ty, substs);\n     } else if ty_param_count > 0u {\n@@ -281,26 +289,6 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n     ret ty::type_is_c_like_enum(fcx.ccx.tcx, typ_s);\n }\n \n-enum mode { m_collect, m_check, m_check_tyvar(@fn_ctxt), }\n-\n-fn ast_ty_vstore_to_vstore(tcx: ty::ctxt, ty: @ast::ty,\n-                           v: ast::vstore) -> ty::vstore {\n-    alt v {\n-      ast::vstore_fixed(none) {\n-        tcx.sess.span_bug(ty.span,\n-                          \"implied fixed length in ast_ty_vstore_to_vstore\");\n-      }\n-      ast::vstore_fixed(some(u)) {\n-        ty::vstore_fixed(u)\n-      }\n-      ast::vstore_uniq { ty::vstore_uniq }\n-      ast::vstore_box { ty::vstore_box }\n-      ast::vstore_slice(r) {\n-        ty::vstore_slice(tcx.region_map.ast_type_to_region.get(ty.id))\n-      }\n-    }\n-}\n-\n fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n                              v: ast::vstore) -> ty::vstore {\n     alt v {\n@@ -315,216 +303,345 @@ fn ast_expr_vstore_to_vstore(fcx: @fn_ctxt, e: @ast::expr, n: uint,\n       ast::vstore_uniq { ty::vstore_uniq }\n       ast::vstore_box { ty::vstore_box }\n       ast::vstore_slice(r) {\n-        ty::vstore_slice(region_of(fcx, e))\n+        ty::vstore_slice(ast_region_to_region(fcx, fcx, e.span, r))\n       }\n     }\n }\n \n-// Parses the programmer's textual representation of a type into our\n-// internal notion of a type. `getter` is a function that returns the type\n-// corresponding to a definition ID:\n-fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n-    fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n-            -> ty::ty_param_bounds_and_ty {\n-\n-        alt mode {\n-          m_check | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n-          m_collect {\n-            if id.crate != ast::local_crate { csearch::get_type(tcx, id) }\n-            else {\n-                alt tcx.items.find(id.node) {\n-                  some(ast_map::node_item(item, _)) {\n-                    ty_of_item(tcx, mode, item)\n-                  }\n-                  some(ast_map::node_native_item(native_item, _, _)) {\n-                    ty_of_native_item(tcx, mode, native_item)\n-                  }\n-                  _ {\n-                    tcx.sess.bug(\"unexpected sort of item in ast_ty_to_ty\");\n-                  }\n-                }\n+iface ast_conv {\n+    fn tcx() -> ty::ctxt;\n+    fn ccx() -> @crate_ctxt;\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty;\n+    fn ty_infer(span: span) -> ty::t;\n+}\n+\n+impl of ast_conv for @crate_ctxt {\n+    fn tcx() -> ty::ctxt { self.tcx }\n+    fn ccx() -> @crate_ctxt { self }\n+\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        if id.crate != ast::local_crate {\n+            csearch::get_type(self.tcx, id)\n+        } else {\n+            alt self.tcx.items.find(id.node) {\n+              some(ast_map::node_item(item, _)) {\n+                ty_of_item(self, item)\n+              }\n+              some(ast_map::node_native_item(native_item, _, _)) {\n+                ty_of_native_item(self, native_item)\n+              }\n+              x {\n+                self.tcx.sess.bug(#fmt[\"unexpected sort of item \\\n+                                        in get_item_ty(): %?\", x]);\n+              }\n             }\n-          }\n         }\n     }\n-    fn ast_mt_to_mt(tcx: ty::ctxt, mode: mode, mt: ast::mt) -> ty::mt {\n-        ret {ty: do_ast_ty_to_ty(tcx, mode, mt.ty), mutbl: mt.mutbl};\n+\n+    fn ty_infer(span: span) -> ty::t {\n+        self.tcx.sess.span_bug(span,\n+                               \"found `ty_infer` in unexpected place\");\n+    }\n+}\n+\n+impl of ast_conv for @fn_ctxt {\n+    fn tcx() -> ty::ctxt { self.ccx.tcx }\n+    fn ccx() -> @crate_ctxt { self.ccx }\n+\n+    fn get_item_ty(id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+        ty::lookup_item_type(self.tcx(), id)\n+    }\n+\n+    fn ty_infer(_span: span) -> ty::t {\n+        self.next_ty_var()\n+    }\n+}\n+\n+iface region_scope {\n+    fn anon_region() -> ty::region;\n+    fn named_region(id: str) -> option<ty::region>;\n+}\n+\n+enum base_rscope { base_rscope }\n+impl of region_scope for base_rscope {\n+    fn anon_region() -> ty::region { ty::re_bound(ty::br_anon) }\n+    fn named_region(_id: str) -> option<ty::region> { none }\n+}\n+\n+impl of region_scope for @fn_ctxt {\n+    fn anon_region() -> ty::region { self.next_region_var() }\n+    fn named_region(id: str) -> option<ty::region> {\n+        self.in_scope_regions.find(id)\n     }\n-    fn instantiate(tcx: ty::ctxt, sp: span, mode: mode, id: ast::def_id,\n-                   path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n-        let ty_param_bounds_and_ty = getter(tcx, mode, id);\n-        if vec::len(*ty_param_bounds_and_ty.bounds) == 0u {\n-            ret ty_param_bounds_and_ty.ty;\n+}\n+\n+enum anon_rscope = {anon: ty::region, base: region_scope};\n+fn in_anon_rscope<RS: region_scope>(self: RS, r: ty::region) -> @anon_rscope {\n+    @anon_rscope({anon: r, base: self as region_scope})\n+}\n+impl of region_scope for @anon_rscope {\n+    fn anon_region() -> ty::region { self.anon }\n+    fn named_region(id: str) -> option<ty::region> {\n+        self.base.named_region(id)\n+    }\n+}\n+\n+enum self_rscope { self_rscope }\n+impl of region_scope for self_rscope {\n+    fn anon_region() -> ty::region { ty::re_bound(ty::br_self) }\n+    fn named_region(id: str) -> option<ty::region> {\n+        if id == \"self\" {some(self.anon_region())} else {none}\n+    }\n+}\n+\n+enum binding_rscope = {base: region_scope};\n+fn in_binding_rscope<RS: region_scope>(self: RS) -> @binding_rscope {\n+    let base = self as region_scope;\n+    @binding_rscope({base: base})\n+}\n+impl of region_scope for @binding_rscope {\n+    fn anon_region() -> ty::region { ty::re_bound(ty::br_anon) }\n+    fn named_region(id: str) -> option<ty::region> {\n+        let nr = self.base.named_region(id);\n+        alt nr {\n+          some(r) { some(r) }\n+          none { some(ty::re_bound(ty::br_named(id))) }\n         }\n+    }\n+}\n \n-        // The typedef is type-parametric. Do the type substitution.\n-        let mut param_bindings: [ty::t] = [];\n-        if vec::len(args) != vec::len(*ty_param_bounds_and_ty.bounds) {\n-            tcx.sess.span_fatal(sp, \"wrong number of type arguments for a \\\n-                                     polymorphic type\");\n+fn ast_region_to_region<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS, span: span, a_r: ast::region) -> ty::region {\n+\n+    alt a_r.node {\n+      ast::re_anon {\n+        rscope.anon_region()\n+      }\n+      ast::re_named(id) {\n+        alt rscope.named_region(id) {\n+          some(r) { r }\n+          none {\n+            self.tcx().sess.span_err(\n+                span,\n+                #fmt[\"named region `%s` not in scope here\", id]);\n+            rscope.anon_region()\n+          }\n         }\n-        for args.each {|ast_ty|\n-            param_bindings += [do_ast_ty_to_ty(tcx, mode, ast_ty)];\n+      }\n+      ast::re_static {\n+        ty::re_static\n+      }\n+    }\n+}\n+\n+// Parses the programmer's textual representation of a type into our\n+// internal notion of a type. `getter` is a function that returns the type\n+// corresponding to a definition ID:\n+fn ast_ty_to_ty<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS, &&ast_ty: @ast::ty) -> ty::t {\n+\n+    fn ast_mt_to_mt<AC: ast_conv, RS: region_scope>(\n+        self: AC, rscope: RS, mt: ast::mt) -> ty::mt {\n+\n+        ret {ty: ast_ty_to_ty(self, rscope, mt.ty), mutbl: mt.mutbl};\n+    }\n+\n+    fn instantiate<AC: ast_conv, RS: region_scope>(\n+        self: AC, rscope: RS, sp: span, id: ast::def_id,\n+        path_id: ast::node_id, args: [@ast::ty]) -> ty::t {\n+\n+        let tcx = self.tcx();\n+        let {bounds, ty} = self.get_item_ty(id);\n+\n+        // The type of items may include a reference to the bound anon region.\n+        // Replace it with the current binding for that region in this\n+        // context.\n+        //\n+        // n.b. Ordinarily, one should do all substitutions at once to avoid\n+        // capture problems.  But in this instance it is ok to substitute for\n+        // the bound region first and then type parameters second, as the\n+        // bound region cannot be replaced with a type parameter.\n+        let ty = subst_anon_region(tcx, rscope.anon_region(), ty);\n+\n+        // The typedef is type-parametric. Do the type substitution.\n+        if vec::len(args) != vec::len(*bounds) {\n+            tcx.sess.span_fatal(\n+                sp, \"wrong number of type arguments for a \\\n+                     polymorphic type\");\n         }\n-        #debug(\"substituting(%s into %s)\",\n-               str::concat(vec::map(param_bindings, {|t| ty_to_str(tcx, t)})),\n-               ty_to_str(tcx, ty_param_bounds_and_ty.ty));\n-        let typ =\n-            ty::substitute_type_params(tcx, param_bindings,\n-                                       ty_param_bounds_and_ty.ty);\n+        let param_bindings = args.map { |t| ast_ty_to_ty(self, rscope, t) };\n+        #debug(\"substituting(%? into %?)\",\n+               vec::map(param_bindings) {|t| ty_to_str(tcx, t)},\n+               ty_to_str(tcx, ty));\n+        let ty = ty::substitute_type_params(tcx, param_bindings, ty);\n         write_substs_to_tcx(tcx, path_id, param_bindings);\n-        ret typ;\n+        ret ty;\n     }\n-    fn do_ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty)\n-            -> ty::t {\n \n-        alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n-          some(ty::atttce_resolved(ty)) { ret ty; }\n-          some(ty::atttce_unresolved) {\n-            tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n-                                              insert a enum in the cycle, \\\n-                                              if this is desired)\");\n+    fn mk_vstore<AC: ast_conv, RS: region_scope>(\n+        self: AC, rscope: RS, a_seq_ty: @ast::ty, vst: ty::vstore) -> ty::t {\n+\n+        let tcx = self.tcx();\n+        let seq_ty = ast_ty_to_ty(self, rscope, a_seq_ty);\n+        alt ty::get(seq_ty).struct {\n+          ty::ty_vec(mt) { ty::mk_evec(tcx, mt, vst) }\n+          ty::ty_str { ty::mk_estr(tcx, vst) }\n+          _ {\n+            tcx.sess.span_bug(a_seq_ty.span,\n+                              \"found sequence storage modifier \\\n+                               on non-sequence type\")\n           }\n-          none { /* go on */ }\n         }\n+    }\n \n-        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n-        let typ = alt ast_ty.node {\n-          ast::ty_nil { ty::mk_nil(tcx) }\n-          ast::ty_bot { ty::mk_bot(tcx) }\n-          ast::ty_box(mt) {\n-            ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt))\n-          }\n-          ast::ty_uniq(mt) {\n-            ty::mk_uniq(tcx, ast_mt_to_mt(tcx, mode, mt))\n-          }\n-          ast::ty_vec(mt) {\n-            ty::mk_vec(tcx, ast_mt_to_mt(tcx, mode, mt))\n-          }\n-          ast::ty_ptr(mt) {\n-            ty::mk_ptr(tcx, ast_mt_to_mt(tcx, mode, mt))\n-          }\n-          ast::ty_rptr(region, mt) {\n-            let region = tcx.region_map.ast_type_to_region.get(ast_ty.id);\n-            ty::mk_rptr(tcx, region, ast_mt_to_mt(tcx, mode, mt))\n-          }\n-          ast::ty_tup(fields) {\n-            let flds = vec::map(fields, bind do_ast_ty_to_ty(tcx, mode, _));\n-            ty::mk_tup(tcx, flds)\n+    let tcx = self.tcx();\n+\n+    alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n+      some(ty::atttce_resolved(ty)) { ret ty; }\n+      some(ty::atttce_unresolved) {\n+        tcx.sess.span_fatal(ast_ty.span, \"illegal recursive type. \\\n+                                          insert a enum in the cycle, \\\n+                                          if this is desired)\");\n+      }\n+      none { /* go on */ }\n+    }\n+\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_unresolved);\n+    let typ = alt ast_ty.node {\n+      ast::ty_nil { ty::mk_nil(tcx) }\n+      ast::ty_bot { ty::mk_bot(tcx) }\n+      ast::ty_box(mt) {\n+        ty::mk_box(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_uniq(mt) {\n+        ty::mk_uniq(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_vec(mt) {\n+        ty::mk_vec(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_ptr(mt) {\n+        ty::mk_ptr(tcx, ast_mt_to_mt(self, rscope, mt))\n+      }\n+      ast::ty_rptr(region, mt) {\n+        let r = ast_region_to_region(self, rscope, ast_ty.span, region);\n+        let mt = ast_mt_to_mt(self, in_anon_rscope(rscope, r), mt);\n+        ty::mk_rptr(tcx, r, mt)\n+      }\n+      ast::ty_tup(fields) {\n+        let flds = vec::map(fields) { |t| ast_ty_to_ty(self, rscope, t) };\n+        ty::mk_tup(tcx, flds)\n+      }\n+      ast::ty_rec(fields) {\n+        let flds = fields.map {|f|\n+            let tm = ast_mt_to_mt(self, rscope, f.node.mt);\n+            {ident: f.node.ident, mt: tm}\n+        };\n+        ty::mk_rec(tcx, flds)\n+      }\n+      ast::ty_fn(proto, decl) {\n+        ty::mk_fn(tcx, ty_of_fn_decl(self, rscope, proto, decl))\n+      }\n+      ast::ty_path(path, id) {\n+        let a_def = alt tcx.def_map.find(id) {\n+          none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n+                                                       path_to_str(path))); }\n+          some(d) { d }};\n+        alt a_def {\n+          ast::def_ty(did) | ast::def_class(did) {\n+            instantiate(self, rscope, ast_ty.span, did, id, path.node.types)\n           }\n-          ast::ty_rec(fields) {\n-            let mut flds: [field] = [];\n-            for fields.each {|f|\n-                let tm = ast_mt_to_mt(tcx, mode, f.node.mt);\n-                flds += [{ident: f.node.ident, mt: tm}];\n+          ast::def_prim_ty(nty) {\n+            alt nty {\n+              ast::ty_bool { ty::mk_bool(tcx) }\n+              ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n+              ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n+              ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n+              ast::ty_str { ty::mk_str(tcx) }\n             }\n-            ty::mk_rec(tcx, flds)\n           }\n-          ast::ty_fn(proto, decl) {\n-            ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl))\n-          }\n-          ast::ty_path(path, id) {\n-            let a_def = alt tcx.def_map.find(id) {\n-              none { tcx.sess.span_fatal(ast_ty.span, #fmt(\"unbound path %s\",\n-                                                       path_to_str(path))); }\n-              some(d) { d }};\n-            alt a_def {\n-              ast::def_ty(did) | ast::def_class(did) {\n-                instantiate(tcx, ast_ty.span, mode, did,\n-                            id, path.node.types)\n-              }\n-              ast::def_prim_ty(nty) {\n-                alt nty {\n-                  ast::ty_bool { ty::mk_bool(tcx) }\n-                  ast::ty_int(it) { ty::mk_mach_int(tcx, it) }\n-                  ast::ty_uint(uit) { ty::mk_mach_uint(tcx, uit) }\n-                  ast::ty_float(ft) { ty::mk_mach_float(tcx, ft) }\n-                  ast::ty_str { ty::mk_str(tcx) }\n-                }\n-              }\n-              ast::def_ty_param(id, n) {\n-                if vec::len(path.node.types) > 0u {\n-                    tcx.sess.span_err(ast_ty.span, \"provided type parameters \\\n-                                                    to a type parameter\");\n-                }\n-                ty::mk_param(tcx, n, id)\n-              }\n-              ast::def_self(self_id) {\n-                alt check tcx.items.get(self_id) {\n-                  ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n-                    if vec::len(tps) != vec::len(path.node.types) {\n-                        tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n-                                                        type parameters to \\\n-                                                        self type\");\n-                    }\n-                    ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n-                        do_ast_ty_to_ty(tcx, mode, ast_ty)\n-                    }))\n-                  }\n-                }\n-              }\n-             _ {\n-                tcx.sess.span_fatal(ast_ty.span,\n-                                    \"found type name used as a variable\");\n-              }\n+          ast::def_ty_param(id, n) {\n+            if vec::len(path.node.types) > 0u {\n+                tcx.sess.span_err(ast_ty.span, \"provided type parameters \\\n+                                                to a type parameter\");\n             }\n+            ty::mk_param(tcx, n, id)\n           }\n-          ast::ty_vstore(t, vst) {\n-            let vst = ast_ty_vstore_to_vstore(tcx, ast_ty, vst);\n-            let ty = alt ty::get(do_ast_ty_to_ty(tcx, mode, t)).struct {\n-              ty::ty_vec(mt) { ty::mk_evec(tcx, mt, vst) }\n-              ty::ty_str { ty::mk_estr(tcx, vst) }\n-              _ {\n-                tcx.sess.span_fatal(ast_ty.span,\n-                                    \"found sequence storage modifier \\\n-                                     on non-sequence type\");\n+          ast::def_self(self_id) {\n+            alt check tcx.items.get(self_id) {\n+              ast_map::node_item(@{node: ast::item_iface(tps, _), _}, _) {\n+                if vec::len(tps) != vec::len(path.node.types) {\n+                    tcx.sess.span_err(ast_ty.span, \"incorrect number of \\\n+                                                    type parameters to \\\n+                                                    self type\");\n+                }\n+                ty::mk_self(tcx, vec::map(path.node.types, {|ast_ty|\n+                    ast_ty_to_ty(self, rscope, ast_ty)\n+                }))\n               }\n-            };\n-            fixup_regions_to_block(tcx, ty, ast_ty)\n-          }\n-          ast::ty_constr(t, cs) {\n-            let mut out_cs = [];\n-            for cs.each {|constr|\n-                out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n             }\n-            ty::mk_constr(tcx, do_ast_ty_to_ty(tcx, mode, t), out_cs)\n           }\n-          ast::ty_infer {\n-            alt mode {\n-              m_check_tyvar(fcx) { ret fcx.next_ty_var(); }\n-              _ { tcx.sess.span_bug(ast_ty.span,\n-                                    \"found `ty_infer` in unexpected place\"); }\n-            }\n-          }\n-          ast::ty_mac(_) {\n-              tcx.sess.span_bug(ast_ty.span,\n-                                    \"found `ty_mac` in unexpected place\");\n+          _ {\n+            tcx.sess.span_fatal(ast_ty.span,\n+                                \"found type name used as a variable\");\n           }\n-        };\n-\n-        tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n-        ret typ;\n-    }\n+        }\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_slice(a_r)) {\n+        let r = ast_region_to_region(self, rscope, ast_ty.span, a_r);\n+        mk_vstore(self, in_anon_rscope(rscope, r), a_t, ty::vstore_slice(r))\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_uniq) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_uniq)\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_box) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_box)\n+      }\n+      ast::ty_vstore(a_t, ast::vstore_fixed(some(u))) {\n+        mk_vstore(self, rscope, a_t, ty::vstore_fixed(u))\n+      }\n+      ast::ty_vstore(_, ast::vstore_fixed(none)) {\n+        tcx.sess.span_bug(\n+            ast_ty.span,\n+            \"implied fixed length in ast_ty_vstore_to_vstore\");\n+      }\n+      ast::ty_constr(t, cs) {\n+        let mut out_cs = [];\n+        for cs.each {|constr|\n+            out_cs += [ty::ast_constr_to_constr(tcx, constr)];\n+        }\n+        ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n+      }\n+      ast::ty_infer {\n+        self.ty_infer(ast_ty.span)\n+      }\n+      ast::ty_mac(_) {\n+        tcx.sess.span_bug(ast_ty.span,\n+                          \"found `ty_mac` in unexpected place\");\n+      }\n+    };\n \n-    ret do_ast_ty_to_ty(tcx, mode, ast_ty);\n+    tcx.ast_ty_to_ty_cache.insert(ast_ty, ty::atttce_resolved(typ));\n+    ret typ;\n }\n \n-fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n+fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n     -> ty::ty_param_bounds_and_ty {\n+\n     let def_id = local_def(it.id);\n+    let tcx = ccx.tcx;\n     alt tcx.tcache.find(def_id) {\n       some(tpt) { ret tpt; }\n       _ {}\n     }\n     alt it.node {\n       ast::item_const(t, _) {\n-        let typ = ast_ty_to_ty(tcx, mode, t);\n+        let typ = ccx.to_ty(t);\n         let tpt = {bounds: @[], ty: typ};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_fn(decl, tps, _) {\n-        ret ty_of_fn(tcx, mode, decl, tps, local_def(it.id));\n+        ret ty_of_fn(ccx, decl, tps, local_def(it.id));\n       }\n       ast::item_ty(t, tps) {\n         alt tcx.tcache.find(local_def(it.id)) {\n@@ -534,48 +651,46 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         // Tell ast_ty_to_ty() that we want to perform a recursive\n         // call to resolve any named types.\n         let tpt = {\n-            let t0 = ast_ty_to_ty(tcx, mode, t);\n-            let t1 = {\n+            let ty = {\n+                let t0 = ccx.to_ty(t);\n                 // Do not associate a def id with a named, parameterized type\n                 // like \"foo<X>\".  This is because otherwise ty_to_str will\n                 // print the name as merely \"foo\", as it has no way to\n                 // reconstruct the value of X.\n-                if vec::is_empty(tps) {\n+                if !vec::is_empty(tps) { t0 } else {\n                     ty::mk_with_id(tcx, t0, def_id)\n-                } else {\n-                    t0\n                 }\n             };\n-            {bounds: ty_param_bounds(tcx, mode, tps), ty: t1}\n+            {bounds: ty_param_bounds(ccx, tps), ty: ty}\n         };\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_res(decl, tps, _, _, _) {\n-        let {bounds, params} = mk_ty_params(tcx, tps);\n-        let t_arg = ty_of_arg(tcx, mode, decl.inputs[0]);\n+        let {bounds, params} = mk_ty_params(ccx, tps);\n+        let t_arg = ty_of_arg(ccx, base_rscope, decl.inputs[0]);\n         let t = ty::mk_res(tcx, local_def(it.id), t_arg.ty, params);\n         let t_res = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), t_res);\n         ret t_res;\n       }\n       ast::item_enum(_, tps) {\n         // Create a new generic polytype.\n-        let {bounds, params} = mk_ty_params(tcx, tps);\n+        let {bounds, params} = mk_ty_params(ccx, tps);\n         let t = ty::mk_enum(tcx, local_def(it.id), params);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_iface(tps, ms) {\n-        let {bounds, params} = mk_ty_params(tcx, tps);\n+        let {bounds, params} = mk_ty_params(ccx, tps);\n         let t = ty::mk_iface(tcx, local_def(it.id), params);\n         let tpt = {bounds: bounds, ty: t};\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n       ast::item_class(tps,_,_,_) {\n-          let {bounds,params} = mk_ty_params(tcx, tps);\n+          let {bounds,params} = mk_ty_params(ccx, tps);\n           let t = ty::mk_class(tcx, local_def(it.id), params);\n           let tpt = {bounds: bounds, ty: t};\n           tcx.tcache.insert(local_def(it.id), tpt);\n@@ -585,61 +700,128 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n       ast::item_native_mod(_) { fail; }\n     }\n }\n-fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n+fn ty_of_native_item(ccx: @crate_ctxt, it: @ast::native_item)\n     -> ty::ty_param_bounds_and_ty {\n     alt it.node {\n       ast::native_item_fn(fn_decl, params) {\n-        ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n+        ret ty_of_native_fn_decl(ccx, fn_decl, params,\n                                  local_def(it.id));\n       }\n     }\n }\n \n type next_region_param_id = { mut id: uint };\n \n-fn replace_default_region(tcx: ty::ctxt,\n-                          with_region: ty::region,\n-                          ty: ty::t) -> ty::t {\n-    let mut last_region = with_region;\n-    ret ty::fold_region(tcx, ty) {|region, under_rptr|\n-        if !under_rptr {\n-            last_region = alt region {\n-              ty::re_default { with_region }\n-              _ { region }\n+fn collect_named_regions_in_tys(\n+    tcx: ty::ctxt,\n+    isr: isr_alist,\n+    tys: [ty::t],\n+    to_r: fn(str) -> ty::region) -> isr_alist {\n+\n+    tys.foldl(isr) { |isr, t|\n+        collect_named_regions_in_ty(tcx, isr, t, to_r)\n+    }\n+}\n+\n+fn collect_named_regions_in_ty(\n+    _tcx: ty::ctxt,\n+    isr: isr_alist,\n+    ty: ty::t,\n+    to_r: fn(str) -> ty::region) -> isr_alist {\n+\n+    fn append_isr(isr: isr_alist,\n+                  to_r: fn(str) -> ty::region,\n+                  r: ty::region) -> isr_alist {\n+        alt r {\n+          ty::re_free(_, _) | ty::re_static | ty::re_scope(_) |\n+          ty::re_var(_) | ty::re_bound(ty::br_anon) |\n+          ty::re_bound(ty::br_self) {\n+            isr\n+          }\n+          ty::re_bound(br @ ty::br_named(id)) {\n+            alt isr.find(id) {\n+              some(_) { isr }\n+              none { @cons((id, to_r(id)), isr) }\n             }\n+          }\n         }\n-        last_region\n-   };\n-}\n+    }\n \n-fn default_region_to_bound_anon(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n-    replace_default_region(tcx, ty::re_bound(ty::br_anon), ty)\n-}\n+    let mut isr = isr;\n+\n+    ty::maybe_walk_ty(ty) {|t|\n+        alt ty::get(t).struct {\n+          // do not walk fn contents\n+          ty::ty_fn(_) { false }\n+\n+          // collect named regions into the isr list\n+          ty::ty_evec(_, ty::vstore_slice(r)) |\n+          ty::ty_estr(ty::vstore_slice(r)) |\n+          ty::ty_rptr(r, _) { isr = append_isr(isr, to_r, r); true }\n+\n+          // otherwise just walk the types\n+          _ { true }\n+        }\n+    }\n \n-fn default_region_to_bound_self(tcx: ty::ctxt, ty: ty::t) -> ty::t {\n-    replace_default_region(tcx, ty::re_bound(ty::br_self), ty)\n+    ret isr;\n }\n \n-fn fixup_regions_to_block(tcx: ty::ctxt, ty: ty::t, ast_ty: @ast::ty)\n-        -> ty::t {\n-    let region = tcx.region_map.ast_type_to_inferred_region.get(ast_ty.id);\n-    replace_default_region(tcx, region, ty)\n+fn replace_bound_self(\n+    tcx: ty::ctxt,\n+    self_r: ty::region,\n+    ty: ty::t) -> ty::t {\n+\n+    ty::fold_regions(tcx, ty) { |r, _in_fn|\n+        if r == ty::re_bound(ty::br_self) {self_r} else {r}\n+    }\n }\n \n-fn replace_bound_regions_with_free_regions(\n+fn replace_bound_regions(\n     tcx: ty::ctxt,\n-    id: ast::node_id,\n+    span: span,\n+    anon_r: ty::region,\n+    isr: isr_alist,\n     ty: ty::t) -> ty::t {\n \n-    ty::fold_region(tcx, ty) {|region, _under_rptr|\n-        alt region {\n-          ty::re_bound(br) { ty::re_free(id, br) }\n-          _ { region }\n+    ty::fold_regions(tcx, ty) { |r, in_fn|\n+        alt r {\n+          ty::re_bound(ty::br_named(id)) {\n+            alt isr.find(id) {\n+              // In most cases, all named, bound regions will be mapped to\n+              // some free region.\n+              some(fr) { fr }\n+\n+              // But in the case of a fn() type, there may be named regions\n+              // within that remain bound:\n+              none { assert in_fn; r }\n+            }\n+          }\n+\n+          // As long as we are not within a fn() type, `&T` is mapped to the\n+          // free region anon_r.  But within a fn type, it remains bound.\n+          ty::re_bound(ty::br_anon) if !in_fn { anon_r }\n+          ty::re_bound(ty::br_anon) { r }\n+\n+          // The &self region is special.  Any bound references to self should\n+          // have already been replaced using replace_bound_self() when\n+          // this function is called.\n+          ty::re_bound(ty::br_self) {\n+            tcx.sess.span_bug(span, \"Bound self region found\");\n+          }\n+\n+          // Free regions like these just stay the same:\n+          ty::re_static |\n+          ty::re_scope(_) |\n+          ty::re_free(_, _) |\n+          ty::re_var(_) { r }\n         }\n     }\n }\n \n-fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n+fn ty_of_arg<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS, a: ast::arg) -> ty::arg {\n+\n     fn arg_mode(tcx: ty::ctxt, m: ast::mode, ty: ty::t) -> ast::mode {\n         alt m {\n           ast::infer(_) {\n@@ -663,117 +845,113 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n         }\n     }\n \n-    let ty = ast_ty_to_ty(tcx, mode, a.ty);\n-    let mode = arg_mode(tcx, a.mode, ty);\n+    let ty = ast_ty_to_ty(self, rscope, a.ty);\n+    let mode = arg_mode(self.tcx(), a.mode, ty);\n     {mode: mode, ty: ty}\n }\n-fn ty_of_fn_decl(tcx: ty::ctxt,\n-                 mode: mode,\n-                 proto: ast::proto,\n-                 decl: ast::fn_decl) -> ty::fn_ty {\n-    let input_tys = vec::map(decl.inputs) {|a|\n-        let arg_ty = ty_of_arg(tcx, mode, a);\n-        {ty: default_region_to_bound_anon(tcx, arg_ty.ty)\n-         with arg_ty}\n-    };\n+fn ty_of_fn_decl<AC: ast_conv, RS: region_scope>(\n+    self: AC, rscope: RS,\n+    proto: ast::proto,\n+    decl: ast::fn_decl) -> ty::fn_ty {\n+\n+    #debug[\"ty_of_fn_decl\"];\n+    indent {||\n+        // new region names that appear inside of the fn decl are bound to\n+        // that function type\n+        let rb = in_binding_rscope(rscope);\n+        let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(self, rb, a) };\n+        let output_ty = ast_ty_to_ty(self, rb, decl.output);\n+        let out_constrs = vec::map(decl.constraints) {|constr|\n+            ty::ast_constr_to_constr(self.tcx(), constr)\n+        };\n+        {proto: proto, inputs: input_tys,\n+         output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n+    }\n+}\n \n-    let output_ty = {\n-        let t = ast_ty_to_ty(tcx, mode, decl.output);\n-        default_region_to_bound_anon(tcx, t)\n-    };\n+fn ty_of_fn(ccx: @crate_ctxt,\n+            decl: ast::fn_decl,\n+            ty_params: [ast::ty_param],\n+            def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n \n-    let out_constrs = vec::map(decl.constraints) {|constr|\n-        ty::ast_constr_to_constr(tcx, constr)\n-    };\n-    {proto: proto, inputs: input_tys,\n-     output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n-}\n-fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n-            ty_params: [ast::ty_param], def_id: ast::def_id)\n-    -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(tcx, mode, ty_params);\n-    let tofd = ty_of_fn_decl(tcx, mode, ast::proto_bare, decl);\n-    let tpt = {bounds: bounds, ty: ty::mk_fn(tcx, tofd)};\n-    tcx.tcache.insert(def_id, tpt);\n+    let bounds = ty_param_bounds(ccx, ty_params);\n+    let tofd = ty_of_fn_decl(ccx, base_rscope, ast::proto_bare, decl);\n+    let tpt = {bounds: bounds, ty: ty::mk_fn(ccx.tcx, tofd)};\n+    ccx.tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n-fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n-                        ty_params: [ast::ty_param], def_id: ast::def_id)\n-    -> ty::ty_param_bounds_and_ty {\n-    let bounds = ty_param_bounds(tcx, mode, ty_params);\n-    let input_tys = vec::map(decl.inputs) {|a|\n-        ty_of_arg(tcx, mode, a)\n-    };\n-    let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n \n-    let t_fn = ty::mk_fn(tcx, {proto: ast::proto_bare,\n-                               inputs: input_tys,\n-                               output: output_ty,\n-                               ret_style: ast::return_val,\n-                               constraints: []});\n+fn ty_of_native_fn_decl(ccx: @crate_ctxt,\n+                        decl: ast::fn_decl,\n+                        ty_params: [ast::ty_param],\n+                        def_id: ast::def_id) -> ty::ty_param_bounds_and_ty {\n+\n+    let bounds = ty_param_bounds(ccx, ty_params);\n+    let rb = in_binding_rscope(base_rscope);\n+    let input_tys = vec::map(decl.inputs) { |a| ty_of_arg(ccx, rb, a) };\n+    let output_ty = ast_ty_to_ty(ccx, rb, decl.output);\n+\n+    let t_fn = ty::mk_fn(ccx.tcx, {proto: ast::proto_bare,\n+                                   inputs: input_tys,\n+                                   output: output_ty,\n+                                   ret_style: ast::return_val,\n+                                   constraints: []});\n     let tpt = {bounds: bounds, ty: t_fn};\n-    tcx.tcache.insert(def_id, tpt);\n+    ccx.tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n-fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n-    -> @[ty::param_bounds] {\n-    let mut result = [];\n-    for params.each {|param|\n-        result += [alt tcx.ty_param_bounds.find(param.id) {\n+\n+fn ty_param_bounds(ccx: @crate_ctxt,\n+                   params: [ast::ty_param]) -> @[ty::param_bounds] {\n+\n+    @params.map { |param|\n+        alt ccx.tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n           none {\n-            let mut bounds = [];\n-            for vec::each(*param.bounds) {|b|\n-                bounds += [alt b {\n+            let bounds = @vec::map(*param.bounds) { |b|\n+                alt b {\n                   ast::bound_send { ty::bound_send }\n                   ast::bound_copy { ty::bound_copy }\n                   ast::bound_iface(t) {\n-                    let ity = ast_ty_to_ty(tcx, mode, t);\n+                    let ity = ccx.to_ty(t);\n                     alt ty::get(ity).struct {\n                       ty::ty_iface(_, _) {}\n                       _ {\n-                        tcx.sess.span_fatal(\n+                        ccx.tcx.sess.span_fatal(\n                             t.span, \"type parameter bounds must be \\\n                                      interface types\");\n                       }\n                     }\n                     ty::bound_iface(ity)\n                   }\n-                }];\n-            }\n-            let boxed = @bounds;\n-            tcx.ty_param_bounds.insert(param.id, boxed);\n-            boxed\n+                }\n+            };\n+            ccx.tcx.ty_param_bounds.insert(param.id, bounds);\n+            bounds\n           }\n-        }];\n+        }\n     }\n-    @result\n }\n-fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n+\n+fn ty_of_method(ccx: @crate_ctxt, m: @ast::method) -> ty::method {\n+    {ident: m.ident, tps: ty_param_bounds(ccx, m.tps),\n+     fty: ty_of_fn_decl(ccx, base_rscope, ast::proto_bare, m.decl),\n      purity: m.decl.purity, privacy: m.privacy}\n }\n-fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n-    -> ty::method {\n-    {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl),\n-    // assume public, because this is only invoked on iface methods\n-     purity: m.decl.purity, privacy: ast::pub}\n-}\n \n-// A convenience function to use a crate_ctxt to resolve names for\n-// ast_ty_to_ty.\n-fn ast_ty_to_ty_crate(ccx: @crate_ctxt, &&ast_ty: @ast::ty) -> ty::t {\n-    ret ast_ty_to_ty(ccx.tcx, m_check, ast_ty);\n+fn ty_of_ty_method(self: @crate_ctxt, m: ast::ty_method) -> ty::method {\n+    {ident: m.ident,\n+     tps: ty_param_bounds(self, m.tps),\n+     fty: ty_of_fn_decl(self, base_rscope, ast::proto_bare, m.decl),\n+     // assume public, because this is only invoked on iface methods\n+     purity: m.decl.purity, privacy: ast::pub}\n }\n \n // A wrapper around ast_ty_to_ty_crate that handles ty_infer.\n-fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n-   option<ty::t> {\n+fn ast_ty_to_ty_infer(fcx: @fn_ctxt, &&ast_ty: @ast::ty) -> option<ty::t> {\n     alt ast_ty.node {\n       ast::ty_infer { none }\n-      _ { some(ast_ty_to_ty_crate(ccx, ast_ty)) }\n+      _ { some(fcx.to_ty(ast_ty)) }\n     }\n }\n \n@@ -785,7 +963,9 @@ fn write_ty_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t) {\n }\n fn write_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id,\n                        +substs: [ty::t]) {\n-    tcx.node_type_substs.insert(node_id, substs);\n+    if substs.len() > 0u {\n+        tcx.node_type_substs.insert(node_id, substs);\n+    }\n }\n fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n                    +substs: [ty::t]) {\n@@ -798,8 +978,27 @@ fn write_ty_substs_to_tcx(tcx: ty::ctxt, node_id: ast::node_id, ty: ty::t,\n     }\n }\n \n+impl methods for @crate_ctxt {\n+    fn to_ty(ast_ty: @ast::ty) -> ty::t {\n+        ast_ty_to_ty(self, base_rscope, ast_ty)\n+    }\n+\n+    fn to_self_ty(ast_ty: @ast::ty) -> ty::t {\n+        ast_ty_to_ty(self, self_rscope, ast_ty)\n+    }\n+}\n+\n+impl methods for isr_alist {\n+    fn find(id: str) -> option<ty::region> {\n+        for list::each(*self) { |isr|\n+            let (isr_id, isr_r) = isr;\n+            if isr_id == id { ret some(isr_r); }\n+        }\n+        ret none;\n+    }\n+}\n+\n impl methods for @fn_ctxt {\n-    fn tcx() -> ty::ctxt { self.ccx.tcx }\n     fn tag() -> str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n     fn ty_to_str(t: ty::t) -> str {\n         ty_to_str(self.ccx.tcx, resolve_type_vars_if_possible(self, t))\n@@ -828,6 +1027,10 @@ impl methods for @fn_ctxt {\n         self.write_ty(node_id, ty::mk_bot(self.tcx()));\n     }\n \n+    fn to_ty(ast_t: @ast::ty) -> ty::t {\n+        ast_ty_to_ty(self, self, ast_t)\n+    }\n+\n     fn expr_ty(ex: @ast::expr) -> ty::t {\n         alt self.node_types.find(ex.id as uint) {\n           some(t) { t }\n@@ -863,8 +1066,8 @@ impl methods for @fn_ctxt {\n         self.node_type_substs.find(id)\n     }\n     fn next_ty_var_id() -> ty_vid {\n-        let id = *self.next_var_id;\n-        *self.next_var_id += 1u;\n+        let id = *self.ty_var_counter;\n+        *self.ty_var_counter += 1u;\n         ret ty_vid(id);\n     }\n     fn next_ty_var() -> ty::t {\n@@ -873,6 +1076,14 @@ impl methods for @fn_ctxt {\n     fn next_ty_vars(n: uint) -> [ty::t] {\n         vec::from_fn(n) {|_i| self.next_ty_var() }\n     }\n+    fn next_region_var_id() -> region_vid {\n+        let id = *self.region_var_counter;\n+        *self.region_var_counter += 1u;\n+        ret region_vid(id);\n+    }\n+    fn next_region_var() -> ty::region {\n+        ret ty::re_var(self.next_region_var_id());\n+    }\n     fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n                                err: ty::type_err) {\n         self.ccx.tcx.sess.span_err(\n@@ -884,13 +1095,14 @@ impl methods for @fn_ctxt {\n     }\n }\n \n-fn mk_ty_params(tcx: ty::ctxt, atps: [ast::ty_param])\n+fn mk_ty_params(ccx: @crate_ctxt, atps: [ast::ty_param])\n     -> {bounds: @[ty::param_bounds], params: [ty::t]} {\n+\n     let mut i = 0u;\n-    let bounds = ty_param_bounds(tcx, m_collect, atps);\n+    let bounds = ty_param_bounds(ccx, atps);\n     {bounds: bounds,\n      params: vec::map(atps, {|atp|\n-         let t = ty::mk_param(tcx, i, local_def(atp.id));\n+         let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n          i += 1u;\n          t\n      })}\n@@ -1050,9 +1262,11 @@ fn instantiate_bound_regions(tcx: ty::ctxt, region: ty::region, &&ty: ty::t)\n // We then annotate the AST with the resulting types and return the annotated\n // AST, along with a table mapping item IDs to their types.\n mod collect {\n-    fn get_enum_variant_types(tcx: ty::ctxt, enum_ty: ty::t,\n+    fn get_enum_variant_types(ccx: @crate_ctxt, enum_ty: ty::t,\n                               variants: [ast::variant],\n                               ty_params: [ast::ty_param]) {\n+        let tcx = ccx.tcx;\n+\n         // Create a set of parameter types shared among all the variants.\n         for variants.each {|variant|\n             // Nullary enum constructors get turned into constants; n-ary enum\n@@ -1062,170 +1276,174 @@ mod collect {\n             } else {\n                 // As above, tell ast_ty_to_ty() that trans_ty_item_to_ty()\n                 // should be called to resolve named types.\n-                let mut args: [arg] = [];\n-                for variant.node.args.each {|va|\n-                    let arg_ty = {\n-                        // NDM We need BOUNDS here.  It should be that this\n-                        // yields a type like \"foo &anon\".  Basically every\n-                        // nominal type is going to require a region bound.\n-                        let arg_ty = ast_ty_to_ty(tcx, m_collect, va.ty);\n-                        default_region_to_bound_anon(tcx, arg_ty)\n-                    };\n-\n-                    args += [{mode: ast::expl(ast::by_copy), ty: arg_ty}];\n-                }\n+                let args = variant.node.args.map { |va|\n+                    {mode: ast::expl(ast::by_copy),\n+                     ty: ccx.to_ty(va.ty)}\n+                };\n                 // FIXME: this will be different for constrained types\n                 ty::mk_fn(tcx,\n                           {proto: ast::proto_box,\n                            inputs: args, output: enum_ty,\n                            ret_style: ast::return_val, constraints: []})\n             };\n-            let tpt = {bounds: ty_param_bounds(tcx, m_collect, ty_params),\n+            let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n                        ty: result_ty};\n             tcx.tcache.insert(local_def(variant.node.id), tpt);\n             write_ty_to_tcx(tcx, variant.node.id, result_ty);\n         }\n     }\n-    fn ensure_iface_methods(tcx: ty::ctxt, id: ast::node_id) {\n-        fn store_methods<T>(tcx: ty::ctxt, id: ast::node_id,\n+\n+    fn ensure_iface_methods(ccx: @crate_ctxt, id: ast::node_id) {\n+        fn store_methods<T>(ccx: @crate_ctxt, id: ast::node_id,\n                             stuff: [T], f: fn@(T) -> ty::method) {\n-            ty::store_iface_methods(tcx, id, @vec::map(stuff, f));\n+            ty::store_iface_methods(ccx.tcx, id, @vec::map(stuff, f));\n         }\n \n+        let tcx = ccx.tcx;\n         alt check tcx.items.get(id) {\n           ast_map::node_item(@{node: ast::item_iface(_, ms), _}, _) {\n-              store_methods::<ast::ty_method>(tcx, id, ms, {|m|\n-                          ty_of_ty_method(tcx, m_collect, m)});\n+              store_methods::<ast::ty_method>(ccx, id, ms) {|m|\n+                  ty_of_ty_method(ccx, m)\n+              };\n           }\n           ast_map::node_item(@{node: ast::item_class(_,_,its,_), _}, _) {\n               let (_,ms) = split_class_items(its);\n               // All methods need to be stored, since lookup_method\n               // relies on the same method cache for self-calls\n-              store_methods::<@ast::method>(tcx, id, ms, {|m|\n-                          ty_of_method(tcx, m_collect, m)});\n+              store_methods::<@ast::method>(ccx, id, ms) {|m|\n+                  ty_of_method(ccx, m)\n+              };\n           }\n         }\n     }\n-    fn check_methods_against_iface(tcx: ty::ctxt, tps: [ast::ty_param],\n-                          selfty: ty::t, t: @ast::ty, ms: [@ast::method]) {\n-      let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n-      let my_methods = convert_methods(tcx, ms, i_bounds, some(selfty));\n-      let iface_ty = ast_ty_to_ty(tcx, m_collect, t);\n-      alt ty::get(iface_ty).struct {\n-        ty::ty_iface(did, tys) {\n-         // Store the iface type in the type node\n-         alt check t.node {\n-           ast::ty_path(_, t_id) {\n-             write_ty_to_tcx(tcx, t_id, iface_ty);\n-           }\n-         }\n-         if did.crate == ast::local_crate {\n-             ensure_iface_methods(tcx, did.node);\n-         }\n-         for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n-            alt vec::find(my_methods,\n-                          {|m| if_m.ident == m.mty.ident}) {\n-              some({mty: m, id, span}) {\n-               if m.purity != if_m.purity {\n-                  tcx.sess.span_err(\n-                     span, \"method `\" + m.ident + \"`'s purity \\\n-                       not match the iface method's \\\n-                       purity\");\n-               }\n-               let mt = compare_impl_method(\n-                         tcx, span, m, vec::len(tps), if_m, tys,\n-                         selfty);\n-               let old = tcx.tcache.get(local_def(id));\n-               if old.ty != mt {\n-                  tcx.tcache.insert(local_def(id),\n-                                    {bounds: old.bounds,\n-                                     ty: mt});\n-                  write_ty_to_tcx(tcx, id, mt);\n-               }\n-              }\n-              none {\n-                   tcx.sess.span_err(t.span, \"missing method `\" +\n-                      if_m.ident + \"`\");\n+\n+    fn check_methods_against_iface(ccx: @crate_ctxt, tps: [ast::ty_param],\n+                                   selfty: ty::t, t: @ast::ty,\n+                                   ms: [@ast::method]) {\n+\n+        let tcx = ccx.tcx;\n+        let i_bounds = ty_param_bounds(ccx, tps);\n+        let my_methods = convert_methods(ccx, ms, i_bounds, some(selfty));\n+        let iface_ty = ccx.to_ty(t);\n+        alt ty::get(iface_ty).struct {\n+          ty::ty_iface(did, tys) {\n+            // Store the iface type in the type node\n+            alt check t.node {\n+              ast::ty_path(_, t_id) {\n+                write_ty_to_tcx(tcx, t_id, iface_ty);\n               }\n-            } // alt\n-          } // |if_m|\n-        } // for\n-        _ {\n+            }\n+            if did.crate == ast::local_crate {\n+                ensure_iface_methods(ccx, did.node);\n+            }\n+            for vec::each(*ty::iface_methods(tcx, did)) {|if_m|\n+                alt vec::find(my_methods,\n+                              {|m| if_m.ident == m.mty.ident}) {\n+                  some({mty: m, id, span}) {\n+                    if m.purity != if_m.purity {\n+                        ccx.tcx.sess.span_err(\n+                            span, #fmt[\"method `%s`'s purity \\\n+                                        not match the iface method's \\\n+                                        purity\", m.ident]);\n+                    }\n+                    let mt = compare_impl_method(\n+                        ccx.tcx, span, m, vec::len(tps),\n+                        if_m, tys, selfty);\n+                    let old = tcx.tcache.get(local_def(id));\n+                    if old.ty != mt {\n+                        tcx.tcache.insert(local_def(id),\n+                                          {bounds: old.bounds,\n+                                           ty: mt});\n+                        write_ty_to_tcx(tcx, id, mt);\n+                    }\n+                  }\n+                  none {\n+                    tcx.sess.span_err(t.span, \"missing method `\" +\n+                                      if_m.ident + \"`\");\n+                  }\n+                } // alt\n+            } // |if_m|\n+          } // for\n+          _ {\n             tcx.sess.span_fatal(t.span, \"can only implement \\\n                                          interface types\");\n         }\n-     }\n+      }\n     }\n \n-    fn convert_class_item(tcx: ty::ctxt, v: ast_util::ivar) {\n+    fn convert_class_item(ccx: @crate_ctxt, v: ast_util::ivar) {\n         /* we want to do something here, b/c within the\n          scope of the class, it's ok to refer to fields &\n         methods unqualified */\n \n         /* they have these types *within the scope* of the\n          class. outside the class, it's done with expr_field */\n-        let tt = ast_ty_to_ty(tcx, m_collect, v.ty);\n+        let tt = ccx.to_self_ty(v.ty);\n         #debug(\"convert_class_item: %s %?\", v.ident, v.id);\n-        write_ty_to_tcx(tcx, v.id, tt);\n+        write_ty_to_tcx(ccx.tcx, v.id, tt);\n     }\n-    fn convert_methods(tcx: ty::ctxt, ms: [@ast::method],\n-        i_bounds: @[ty::param_bounds], maybe_self: option<ty::t>)\n+\n+    fn convert_methods(ccx: @crate_ctxt, ms: [@ast::method],\n+                       i_bounds: @[ty::param_bounds],\n+                       maybe_self: option<ty::t>)\n         -> [{mty: ty::method, id: ast::node_id, span: span}] {\n-        let mut my_methods = [];\n-        for ms.each {|m|\n-           alt maybe_self {\n+\n+        let tcx = ccx.tcx;\n+        vec::map(ms) { |m|\n+            alt maybe_self {\n               some(selfty) {\n                 write_ty_to_tcx(tcx, m.self_id, selfty);\n               }\n-              _ {}\n+             _ {}\n            }\n-           let bounds = ty_param_bounds(tcx, m_collect, m.tps);\n-           let mty = ty_of_method(tcx, m_collect, m);\n-           my_methods += [{mty: mty, id: m.id, span: m.span}];\n-           let fty = ty::mk_fn(tcx, mty.fty);\n-           tcx.tcache.insert(local_def(m.id),\n-                             {bounds: @(*i_bounds + *bounds),\n-                                     ty: fty});\n-           write_ty_to_tcx(tcx, m.id, fty);\n+            let bounds = ty_param_bounds(ccx, m.tps);\n+            let mty = ty_of_method(ccx, m);\n+            let fty = ty::mk_fn(tcx, mty.fty);\n+            tcx.tcache.insert(local_def(m.id),\n+                              {bounds: @(*i_bounds + *bounds),\n+                               ty: fty});\n+            write_ty_to_tcx(tcx, m.id, fty);\n+            {mty: mty, id: m.id, span: m.span}\n         }\n-        my_methods\n     }\n-    fn convert(tcx: ty::ctxt, it: @ast::item) {\n+\n+    fn convert(ccx: @crate_ctxt, it: @ast::item) {\n+        let tcx = ccx.tcx;\n         alt it.node {\n           // These don't define types.\n           ast::item_mod(_) {}\n           ast::item_native_mod(m) {\n             if syntax::attr::native_abi(it.attrs) ==\n                either::right(ast::native_abi_rust_intrinsic) {\n-                for m.items.each {|item| check_intrinsic_type(tcx, item); }\n+                for m.items.each { |item| check_intrinsic_type(ccx, item); }\n             }\n           }\n           ast::item_enum(variants, ty_params) {\n-            let tpt = ty_of_item(tcx, m_collect, it);\n+            let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            get_enum_variant_types(tcx, tpt.ty, variants, ty_params);\n+            get_enum_variant_types(ccx, tpt.ty, variants, ty_params);\n           }\n           ast::item_impl(tps, ifce, selfty, ms) {\n-            let i_bounds = ty_param_bounds(tcx, m_collect, tps);\n-            let selfty = ast_ty_to_ty(tcx, m_collect, selfty);\n+            let i_bounds = ty_param_bounds(ccx, tps);\n+            let selfty = ccx.to_self_ty(selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n-            tcx.tcache.insert(local_def(it.id), {bounds: i_bounds,\n-                                                 ty: selfty});\n+            tcx.tcache.insert(local_def(it.id),\n+                              {bounds: i_bounds, ty: selfty});\n             alt ifce {\n               some(t) {\n-                  check_methods_against_iface(tcx, tps, selfty,\n-                                                    t, ms); }\n+                check_methods_against_iface(ccx, tps, selfty, t, ms);\n+              }\n               _ {\n-                  // Still have to do this to write method types\n-                  // into the table\n-                convert_methods(tcx, ms, i_bounds, some(selfty));\n+                // Still have to do this to write method types\n+                // into the table\n+                convert_methods(ccx, ms, i_bounds, some(selfty));\n               }\n             }\n           }\n           ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n-            let {bounds, params} = mk_ty_params(tcx, tps);\n+            let {bounds, params} = mk_ty_params(ccx, tps);\n             let def_id = local_def(it.id);\n-            let t_arg = ty_of_arg(tcx, m_collect, decl.inputs[0]);\n+            let t_arg = ty_of_arg(ccx, base_rscope, decl.inputs[0]);\n             let t_res = ty::mk_res(tcx, def_id, t_arg.ty, params);\n             let t_ctor = ty::mk_fn(tcx, {\n                 proto: ast::proto_box,\n@@ -1246,34 +1464,36 @@ mod collect {\n             write_ty_to_tcx(tcx, dtor_id, t_dtor);\n           }\n           ast::item_iface(_, ms) {\n-            let tpt = ty_of_item(tcx, m_collect, it);\n+            let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n-            ensure_iface_methods(tcx, it.id);\n+            ensure_iface_methods(ccx, it.id);\n           }\n           ast::item_class(tps, ifaces, members, ctor) {\n               // Write the class type\n-              let tpt = ty_of_item(tcx, m_collect, it);\n+              let tpt = ty_of_item(ccx, it);\n               write_ty_to_tcx(tcx, it.id, tpt.ty);\n               // Write the ctor type\n-              let t_ctor = ty::mk_fn(tcx,\n-                                     ty_of_fn_decl(tcx, m_collect,\n-                                             ast::proto_any, ctor.node.dec));\n+              let t_ctor =\n+                  ty::mk_fn(tcx,\n+                            ty_of_fn_decl(ccx, base_rscope,\n+                                          ast::proto_any,\n+                                          ctor.node.dec));\n               write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n               tcx.tcache.insert(local_def(ctor.node.id),\n                                    {bounds: tpt.bounds, ty: t_ctor});\n-              ensure_iface_methods(tcx, it.id);\n+              ensure_iface_methods(ccx, it.id);\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               let (fields, methods) = split_class_items(members);\n               for fields.each {|f|\n-                 convert_class_item(tcx, f);\n+                 convert_class_item(ccx, f);\n               }\n               // The selfty is just the class type\n               let selfty = ty::mk_class(tcx, local_def(it.id),\n-                                        mk_ty_params(tcx, tps).params);\n+                                        mk_ty_params(ccx, tps).params);\n               // Need to convert all methods so we can check internal\n               // references to private methods\n-              convert_methods(tcx, methods, @[], some(selfty));\n+              convert_methods(ccx, methods, @[], some(selfty));\n               /*\n                 Finally, check that the class really implements the ifaces\n                 that it claims to implement.\n@@ -1284,8 +1504,8 @@ mod collect {\n                      let t = ty::lookup_item_type(tcx, t_id).ty;\n                      alt ty::get(t).struct {\n                         ty::ty_iface(_,_) {\n-                            write_ty_to_tcx(tcx, ifce.id, t);\n-                            check_methods_against_iface(tcx, tps, selfty,\n+                          write_ty_to_tcx(tcx, ifce.id, t);\n+                            check_methods_against_iface(ccx, tps, selfty,\n                                @{id: ifce.id,\n                                  node: ast::ty_path(ifce.path, ifce.id),\n                                  span: ifce.path.span},\n@@ -1304,26 +1524,26 @@ mod collect {\n             // This call populates the type cache with the converted type\n             // of the item in passing. All we have to do here is to write\n             // it into the node type table.\n-            let tpt = ty_of_item(tcx, m_collect, it);\n+            let tpt = ty_of_item(ccx, it);\n             write_ty_to_tcx(tcx, it.id, tpt.ty);\n           }\n         }\n     }\n-    fn convert_native(tcx: ty::ctxt, i: @ast::native_item) {\n+    fn convert_native(ccx: @crate_ctxt, i: @ast::native_item) {\n         // As above, this call populates the type table with the converted\n         // type of the native item. We simply write it into the node type\n         // table.\n-        let tpt = ty_of_native_item(tcx, m_collect, i);\n+        let tpt = ty_of_native_item(ccx, i);\n         alt i.node {\n           ast::native_item_fn(_, _) {\n-            write_ty_to_tcx(tcx, i.id, tpt.ty);\n+            write_ty_to_tcx(ccx.tcx, i.id, tpt.ty);\n           }\n         }\n     }\n-    fn collect_item_types(tcx: ty::ctxt, crate: @ast::crate) {\n+    fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n         visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-            visit_item: bind convert(tcx, _),\n-            visit_native_item: bind convert_native(tcx, _)\n+            visit_item: bind convert(ccx, _),\n+            visit_native_item: bind convert_native(ccx, _)\n             with *visit::default_simple_visitor()\n         }));\n     }\n@@ -1661,23 +1881,24 @@ mod writeback {\n \n }\n \n-fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n-    fn param(tcx: ty::ctxt, n: uint) -> ty::t {\n-        ty::mk_param(tcx, n, local_def(0))\n+fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::native_item) {\n+    fn param(ccx: @crate_ctxt, n: uint) -> ty::t {\n+        ty::mk_param(ccx.tcx, n, local_def(0))\n     }\n     fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n         {mode: ast::expl(m), ty: ty}\n     }\n+    let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = alt it.ident {\n-      \"size_of\" | \"align_of\" { (1u, [], ty::mk_uint(tcx)) }\n+      \"size_of\" | \"align_of\" { (1u, [], ty::mk_uint(ccx.tcx)) }\n       \"get_tydesc\" { (1u, [], ty::mk_nil_ptr(tcx)) }\n-      \"init\" { (1u, [], param(tcx, 0u)) }\n-      \"forget\" { (1u, [arg(ast::by_move, param(tcx, 0u))],\n+      \"init\" { (1u, [], param(ccx, 0u)) }\n+      \"forget\" { (1u, [arg(ast::by_move, param(ccx, 0u))],\n                   ty::mk_nil(tcx)) }\n-      \"reinterpret_cast\" { (2u, [arg(ast::by_ref, param(tcx, 0u))],\n-                            param(tcx, 1u)) }\n-      \"addr_of\" { (1u, [arg(ast::by_ref, param(tcx, 0u))],\n-                   ty::mk_imm_ptr(tcx, param(tcx, 0u))) }\n+      \"reinterpret_cast\" { (2u, [arg(ast::by_ref, param(ccx, 0u))],\n+                            param(ccx, 1u)) }\n+      \"addr_of\" { (1u, [arg(ast::by_ref, param(ccx, 0u))],\n+                   ty::mk_imm_ptr(tcx, param(ccx, 0u))) }\n       other {\n         tcx.sess.span_err(it.span, \"unrecognized intrinsic function: `\" +\n                           other + \"`\");\n@@ -1688,7 +1909,7 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n                               inputs: inputs, output: output,\n                               ret_style: ast::return_val,\n                               constraints: []});\n-    let i_ty = ty_of_native_item(tcx, m_collect, it);\n+    let i_ty = ty_of_native_item(ccx, it);\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {\n         tcx.sess.span_err(it.span, #fmt(\"intrinsic has wrong number \\\n@@ -1699,7 +1920,7 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n             tcx, it.span, i_ty.ty, fty,\n             {|| #fmt[\"intrinsic has wrong type. \\\n                       expected %s\",\n-                     ty_to_str(tcx, fty)]});\n+                     ty_to_str(ccx.tcx, fty)]});\n     }\n }\n \n@@ -1708,101 +1929,7 @@ fn check_intrinsic_type(tcx: ty::ctxt, it: @ast::native_item) {\n type gather_result =\n     {infcx: infer::infer_ctxt,\n      locals: hashmap<ast::node_id, ty_vid>,\n-     next_var_id: @mut uint};\n-\n-// Used only as a helper for check_fn.\n-fn gather_locals(ccx: @crate_ctxt,\n-                 decl: ast::fn_decl,\n-                 body: ast::blk,\n-                 arg_tys: [ty::t],\n-                 old_fcx: option<@fn_ctxt>) -> gather_result {\n-    let {infcx, locals, nvi} = alt old_fcx {\n-      none {\n-        {infcx: infer::new_infer_ctxt(ccx.tcx),\n-         locals: int_hash(),\n-         nvi: @mut 0u}\n-      }\n-      some(fcx) {\n-        {infcx: fcx.infcx,\n-         locals: fcx.locals,\n-         nvi: fcx.next_var_id}\n-      }\n-    };\n-    let tcx = ccx.tcx;\n-\n-    let next_var_id = fn@() -> uint {\n-        let rv = *nvi; *nvi += 1u; ret rv;\n-    };\n-\n-    let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n-        let var_id = ty_vid(next_var_id());\n-        locals.insert(nid, var_id);\n-        alt ty_opt {\n-          none {/* nothing to do */ }\n-          some(typ) {\n-            infer::mk_eqty(infcx, ty::mk_var(tcx, var_id), typ);\n-          }\n-        }\n-    };\n-\n-    // Add formal parameters.\n-    vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n-        assign(input.id, some(arg_ty));\n-        #debug[\"Argument %s is assigned to %s\",\n-               input.ident, locals.get(input.id).to_str()];\n-    }\n-\n-    // Add explicitly-declared locals.\n-    let visit_local = fn@(local: @ast::local, &&e: (), v: visit::vt<()>) {\n-        let mut local_ty_opt = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n-        alt local_ty_opt {\n-            some(local_ty) if ty::type_has_rptrs(local_ty) {\n-                local_ty_opt = some(fixup_regions_to_block(ccx.tcx, local_ty,\n-                                                           local.node.ty));\n-            }\n-            _ { /* nothing to do */ }\n-        }\n-\n-        assign(local.node.id, local_ty_opt);\n-        #debug[\"Local variable %s is assigned to %s\",\n-               pat_to_str(local.node.pat),\n-               locals.get(local.node.id).to_str()];\n-        visit::visit_local(local, e, v);\n-    };\n-\n-    // Add pattern bindings.\n-    let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n-        alt p.node {\n-          ast::pat_ident(path, _)\n-          if !pat_util::pat_is_variant(ccx.tcx.def_map, p) {\n-            assign(p.id, none);\n-            #debug[\"Pattern binding %s is assigned to %s\",\n-                   path.node.idents[0],\n-                   locals.get(p.id).to_str()];\n-          }\n-          _ {}\n-        }\n-        visit::visit_pat(p, e, v);\n-    };\n-\n-    // Don't descend into fns and items\n-    fn visit_fn<T>(_fk: visit::fn_kind, _decl: ast::fn_decl, _body: ast::blk,\n-                   _sp: span, _id: ast::node_id, _t: T, _v: visit::vt<T>) {\n-    }\n-    fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n-\n-    let visit =\n-        @{visit_local: visit_local,\n-          visit_pat: visit_pat,\n-          visit_fn: bind visit_fn(_, _, _, _, _, _, _),\n-          visit_item: bind visit_item(_, _, _)\n-              with *visit::default_visitor()};\n-\n-    visit::visit_block(body, (), visit::mk_vt(visit));\n-    ret {infcx: infcx,\n-         locals: locals,\n-         next_var_id: nvi};\n-}\n+     ty_var_counter: @mut uint};\n \n // AST fragment checking\n fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n@@ -1816,9 +1943,9 @@ fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n     }\n }\n \n-fn valid_range_bounds(tcx: ty::ctxt, from: @ast::expr, to: @ast::expr)\n+fn valid_range_bounds(ccx: @crate_ctxt, from: @ast::expr, to: @ast::expr)\n     -> bool {\n-    const_eval::compare_lit_exprs(tcx, from, to) <= 0\n+    const_eval::compare_lit_exprs(ccx.tcx, from, to) <= 0\n }\n \n type pat_ctxt = {\n@@ -1830,76 +1957,75 @@ type pat_ctxt = {\n     pat_region: ty::region\n };\n \n-fn count_region_params(ty: ty::t) -> uint {\n-    if (!ty::type_has_rptrs(ty)) { ret 0u; }\n-\n-    let count = @mut 0u;\n-    ty::walk_ty(ty) {|ty|\n-        alt ty::get(ty).struct {\n-            ty::ty_rptr(ty::re_bound(ty::br_param(param_id, _)), _) {\n-                if param_id > *count {\n-                    *count = param_id;\n-                }\n-            }\n-            _ { /* no-op */ }\n-        }\n-    };\n-    ret *count;\n+fn subst_anon_region(tcx: ty::ctxt,\n+                     with_r: ty::region,\n+                     ty: ty::t) -> ty::t {\n+    ty::fold_regions(tcx, ty) {|r, in_fn|\n+        if !in_fn && r == ty::re_bound(ty::br_anon) {with_r} else {r}\n+    }\n }\n \n-type region_env = hashmap<ty::bound_region, region_vid>;\n-\n-fn region_env() -> @region_env {\n-    ret @ty::br_hashmap();\n+// Helper for the other universally_quantify_*() routines.  Extracts the bound\n+// regions from bound_tys and then replaces those same regions with fresh\n+// variables in `sty`, returning the resulting type.\n+fn universally_quantify_from_sty(fcx: @fn_ctxt,\n+                                 span: span,\n+                                 bound_tys: [ty::t],\n+                                 sty: ty::sty) -> ty::t {\n+\n+    let tcx = fcx.tcx();\n+    let isr = collect_named_regions_in_tys(tcx, @nil, bound_tys) { |_id|\n+        fcx.next_region_var()\n+    };\n+    let anon_r = fcx.next_region_var();\n+    ty::fold_sty_to_ty(fcx.ccx.tcx, sty) {|t|\n+        replace_bound_regions(tcx, span, anon_r, isr, t)\n+    }\n }\n \n // Replaces all region parameters in the given type with region variables.\n // Does not descend into fn types.  This is used when deciding whether an impl\n // applies at a given call site.  See also universally_quantify_before_call().\n-fn universally_quantify_regions(fcx: @fn_ctxt, renv: @region_env,\n+fn universally_quantify_regions(fcx: @fn_ctxt,\n+                                span: span,\n                                 ty: ty::t) -> ty::t {\n-    ty::fold_region(fcx.ccx.tcx, ty) {|r, _under_rptr|\n-        alt r {\n-          ty::re_bound(br) {\n-            alt (*renv).find(br) {\n-              some(var_id) { ty::re_var(var_id) }\n-              none {\n-                let var_id = next_region_var_id(fcx);\n-                (*renv).insert(br, var_id);\n-                ty::re_var(var_id)\n-              }\n-            }\n-          }\n-          _ { r }\n-        }\n-    }\n+    universally_quantify_from_sty(fcx, span, [ty], ty::get(ty).struct)\n }\n \n // Expects a function type.  Replaces all region parameters in the arguments\n // and return type with fresh region variables. This is used when typechecking\n // function calls, bind expressions, and method calls.\n-fn universally_quantify_before_call(\n-    fcx: @fn_ctxt, renv: @region_env, ty: ty::t) -> ty::t {\n-    if ty::type_has_rptrs(ty) {\n-        // This is subtle: we expect `ty` to be a function type, but\n-        // fold_region() will not descend into function types.  As it happens\n-        // we only want to descend 1 level, so we just bypass fold_region for\n-        // the outer type and apply it to all of the types contained with\n-        // `ty`.\n-        alt ty::get(ty).struct {\n-          sty @ ty::ty_fn(_) {\n-            ty::fold_sty_to_ty(fcx.ccx.tcx, sty) {|t|\n-                universally_quantify_regions(fcx, renv, t)\n-            }\n-          }\n-          _ {\n-            // if not a function type, we're gonna' report an error\n-            // at some point, since the user is trying to call this thing\n-            ty\n-          }\n-        }\n-    } else {\n+fn universally_quantify_before_call(fcx: @fn_ctxt,\n+                                    span: span,\n+                                    ty: ty::t) -> ty::t {\n+    if !ty::type_has_regions(ty) { ret ty; }\n+\n+    // This is subtle: we expect `ty` to be a function type, which normally\n+    // introduce a level of binding.  In this case, we want to process the\n+    // types bound by the function but not by any nested functions.\n+    // Therefore, we match one level of structure.\n+    //\n+    // Specifically what we do is:\n+    // - Find the set of named regions that appear in arguments, return\n+    //   type, etc. We use collect_named_regions_in_ty(), which\n+    //   returns a free version of the region---not quite what we want.\n+    //\n+    // - So then we map the resulting map so that we each bound region\n+    //   will be mapped to a fresh variable.\n+    //\n+    // - Finally, we can use fold_sty_to_ty() and replace_bound_regions()\n+    //   to replace the bound regions as well as the bound anonymous region.\n+    //   We have to use fold_sty_to_ty() to ignore the outer fn().\n+    alt ty::get(ty).struct {\n+      sty @ ty::ty_fn(fty) {\n+        let all_tys = fty.inputs.map({|a| a.ty}) + [fty.output];\n+        universally_quantify_from_sty(fcx, span, all_tys, sty)\n+      }\n+      _ {\n+        // if not a function type, we're gonna' report an error\n+        // at some point, since the user is trying to call this thing\n         ty\n+      }\n     }\n }\n \n@@ -1993,7 +2119,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n             tcx.sess.span_err(pat.span, \"non-numeric type used in range\");\n-        } else if !valid_range_bounds(tcx, begin, end) {\n+        } else if !valid_range_bounds(pcx.fcx.ccx, begin, end) {\n             tcx.sess.span_err(begin.span, \"lower range bound must be less \\\n                                            than upper\");\n         }\n@@ -2200,7 +2326,7 @@ fn impl_self_ty(fcx: @fn_ctxt, did: ast::def_id) -> ty_param_substs_and_ty {\n           ast_map::node_item(@{node: ast::item_impl(ts, _, st, _),\n                                _}, _) {\n             {n_tps: vec::len(ts),\n-             raw_ty: ast_ty_to_ty(tcx, m_check, st)}\n+             raw_ty: fcx.to_ty(st)}\n           }\n         }\n     } else {\n@@ -2348,7 +2474,7 @@ impl methods for lookup {\n         if did.crate == ast::local_crate {\n             alt check self.tcx().items.get(did.node) {\n               ast_map::node_method(m, _, _) {\n-                let mt = ty_of_method(self.tcx(), m_check, m);\n+                let mt = ty_of_method(self.fcx.ccx, m);\n                 ty::mk_fn(self.tcx(), {proto: ast::proto_box with mt.fty})\n               }\n             }\n@@ -2364,7 +2490,7 @@ impl methods for lookup {\n     fn method_from_scope() -> option<method_origin> {\n         let impls_vecs = self.fcx.ccx.impl_map.get(self.expr.id);\n \n-        for std::list::each(impls_vecs) {|impls|\n+        for list::each(impls_vecs) {|impls|\n             let mut results = [];\n             for vec::each(*impls) {|im|\n                 // Check whether this impl has a method with the right name.\n@@ -2376,12 +2502,14 @@ impl methods for lookup {\n                         impl_self_ty(self.fcx, im.did);\n \n                     // Here \"self\" refers to the callee side...\n-                    let self_ty = universally_quantify_regions(\n-                        self.fcx, region_env(), self_ty);\n+                    let self_ty =\n+                        universally_quantify_regions(\n+                            self.fcx, self.expr.span, self_ty);\n \n                     // ... and \"ty\" refers to the caller side.\n-                    let ty = universally_quantify_regions(\n-                        self.fcx, region_env(), self.self_ty);\n+                    let ty =\n+                        universally_quantify_regions(\n+                            self.fcx, self.expr.span, self.self_ty);\n \n                     // if we can assign the caller to the callee, that's a\n                     // potential match.  Collect those in the vector.\n@@ -2477,7 +2605,7 @@ impl methods for lookup {\n             self.fcx.write_ty(self.node_id, fty);\n         }\n \n-        if ty::type_has_rptrs(ty::ty_fn_ret(fty)) {\n+        if ty::type_has_regions(ty::ty_fn_ret(fty)) {\n             let fty = self.fcx.node_ty(self.node_id);\n             let self_region = region_of(self.fcx, self.expr);\n             let fty = replace_self_region(self.tcx(), self_region, fty);\n@@ -2491,10 +2619,13 @@ impl methods for lookup {\n // Only for fields! Returns <none> for methods>\n // FIXME: privacy flags\n fn lookup_field_ty(tcx: ty::ctxt, class_id: ast::def_id,\n-   items:[ty::field_ty], fieldname: ast::ident, substs: [ty::t])\n-    -> option<ty::t> {\n-    option::map(vec::find(items, {|f| f.ident == fieldname}),\n-                {|f| ty::lookup_field_type(tcx, class_id, f.id, substs) })\n+                   items:[ty::field_ty], fieldname: ast::ident,\n+                   substs: [ty::t]) -> option<ty::t> {\n+\n+    let o_field = vec::find(items, {|f| f.ident == fieldname});\n+    option::map(o_field) {|f|\n+        ty::lookup_field_type(tcx, class_id, f.id, substs)\n+    }\n }\n \n /* Returns the region that &expr should be placed into.  If expr is an\n@@ -2548,8 +2679,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               is_loop_body: bool,\n                               unifier: fn()) {\n     let tcx = fcx.ccx.tcx;\n-    let fty = ty::mk_fn(tcx,\n-                        ty_of_fn_decl(tcx, m_check_tyvar(fcx), proto, decl));\n+    let fty = ty::mk_fn(tcx, ty_of_fn_decl(fcx, fcx, proto, decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n            expr_to_str(expr), fcx.ty_to_str(fty));\n@@ -2584,7 +2714,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         fcx: @fn_ctxt, sp: span, fty: ty::t,\n         args: [option<@ast::expr>]) -> {fty: ty::t, bot: bool} {\n \n-        let fty = universally_quantify_before_call(fcx, region_env(), fty);\n+        let fty = universally_quantify_before_call(fcx, sp, fty);\n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n                fcx.ty_to_str(fty)];\n         let sty = structure_of(fcx, sp, fty);\n@@ -2871,17 +3001,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     let id = expr.id;\n     let mut bot = false;\n     alt expr.node {\n-\n       ast::expr_vstore(ev, vst) {\n-        let mut typ = alt ev.node {\n+        let typ = alt ev.node {\n           ast::expr_lit(@{node: ast::lit_str(s), span:_}) {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev,\n-                                               str::len(s), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, str::len(s), vst);\n             ty::mk_estr(tcx, tt)\n           }\n           ast::expr_vec(args, mutbl) {\n-            let tt = ast_expr_vstore_to_vstore(fcx, ev,\n-                                               vec::len(args), vst);\n+            let tt = ast_expr_vstore_to_vstore(fcx, ev, vec::len(args), vst);\n             let t: ty::t = fcx.next_ty_var();\n             for args.each {|e| bot |= check_expr_with(fcx, e, t); }\n             ty::mk_evec(tcx, {ty: t, mutbl: mutbl}, tt)\n@@ -2890,13 +3017,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             tcx.sess.span_bug(expr.span, \"vstore modifier on non-sequence\")\n           }\n         };\n-        alt vst {\n-          ast::vstore_slice(_) {\n-            let r = ty::re_scope(fcx.ccx.tcx.region_map.parents.get(ev.id));\n-            typ = replace_default_region(tcx, r, typ);\n-          }\n-          _ { }\n-        }\n         fcx.write_ty(ev.id, typ);\n         fcx.write_ty(id, typ);\n       }\n@@ -3028,8 +3148,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         };\n         alt expr_opt {\n           none {\n-            let nil = ty::mk_nil(tcx);\n-            if !are_compatible(fcx, ret_ty, nil) {\n+            if !are_compatible(fcx, ret_ty, ty::mk_nil(tcx)) {\n                 tcx.sess.span_err(expr.span,\n                                   \"ret; in function returning non-nil\");\n             }\n@@ -3248,7 +3367,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_cast(e, t) {\n         bot = check_expr(fcx, e);\n-        let t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n+        let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n         alt ty::get(t_1).struct {\n@@ -3395,7 +3514,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ {}\n         }\n         if !handled {\n-            let tps = vec::map(tys, {|ty| ast_ty_to_ty_crate(fcx.ccx, ty)});\n+            let tps = vec::map(tys) { |ty| fcx.to_ty(ty) };\n             let lkup = lookup({fcx: fcx,\n                                expr: expr,\n                                node_id: expr.id,\n@@ -3526,17 +3645,6 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     }\n }\n \n-fn next_region_var_id(fcx: @fn_ctxt) -> region_vid {\n-    let id = *fcx.next_region_var_id;\n-    *fcx.next_region_var_id += 1u;\n-    ret region_vid(id);\n-}\n-\n-fn next_region_var(fcx: @fn_ctxt) -> ty::region {\n-    ret ty::re_var(next_region_var_id(fcx));\n-}\n-\n-\n fn check_decl_initializer(fcx: @fn_ctxt, nid: ast::node_id,\n                           init: ast::initializer) -> bool {\n     let lty = ty::mk_var(fcx.ccx.tcx, lookup_local(fcx, init.expr.span, nid));\n@@ -3657,8 +3765,9 @@ fn check_const(ccx: @crate_ctxt, _sp: span, e: @ast::expr, id: ast::node_id) {\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n-          next_var_id: @mut 0u,\n-          next_region_var_id: @mut 0u,\n+          ty_var_counter: @mut 0u,\n+          region_var_counter: @mut 0u,\n+          in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n           ccx: ccx};\n@@ -3694,8 +3803,9 @@ fn check_enum_variants(ccx: @crate_ctxt, sp: span, vs: [ast::variant],\n           proto: ast::proto_box,\n           infcx: infer::new_infer_ctxt(ccx.tcx),\n           locals: int_hash(),\n-          next_var_id: @mut 0u,\n-          next_region_var_id: @mut 0u,\n+          ty_var_counter: @mut 0u,\n+          region_var_counter: @mut 0u,\n+          in_scope_regions: @nil,\n           node_types: smallintmap::mk(),\n           node_type_substs: map::int_hash(),\n           ccx: ccx};\n@@ -3882,59 +3992,84 @@ fn check_fn(ccx: @crate_ctxt,\n             old_fcx: option<@fn_ctxt>,\n             self_ty: option<ty::t>) {\n \n+    let tcx = ccx.tcx;\n+\n     // See big comment in region.rs.\n+    let isr = {\n+        let all_tys = arg_tys + [ret_ty] + self_ty.to_vec();\n+        let old_isr = option::map_default(old_fcx, @nil) {\n+            |fcx| fcx.in_scope_regions };\n+        collect_named_regions_in_tys(tcx, old_isr, all_tys) {\n+            |id| ty::re_free(fid, ty::br_named(id)) }\n+    };\n+    let anon_r = ty::re_free(fid, ty::br_anon);\n+    let self_r = ty::re_free(fid, ty::br_self);\n     let arg_tys = arg_tys.map {|arg_ty|\n-        replace_bound_regions_with_free_regions(ccx.tcx, fid, arg_ty)\n+        let arg_ty = replace_bound_self(tcx, self_r, arg_ty);\n+        replace_bound_regions(tcx, body.span, anon_r, isr, arg_ty)\n     };\n-    let ret_ty =\n-        replace_bound_regions_with_free_regions(ccx.tcx, fid, ret_ty);\n-    let self_ty = option::map(self_ty) {|st|\n-        replace_bound_regions_with_free_regions(ccx.tcx, fid, st)\n+    let ret_ty = replace_bound_self(tcx, self_r, ret_ty);\n+    let ret_ty = replace_bound_regions(tcx, body.span, anon_r, isr, ret_ty);\n+    let self_ty = option::map(self_ty) {|self_ty|\n+        let self_ty = replace_bound_self(tcx, self_r, self_ty);\n+        replace_bound_regions(tcx, body.span, anon_r, isr, self_ty)\n     };\n \n     #debug[\"check_fn(arg_tys=%?, ret_ty=%?, self_ty=%?)\",\n-           arg_tys.map {|a| ty_to_str(ccx.tcx, a) },\n-           ty_to_str(ccx.tcx, ret_ty),\n-           option::map(self_ty) {|st| ty_to_str(ccx.tcx, st) }];\n+           arg_tys.map {|a| ty_to_str(tcx, a) },\n+           ty_to_str(tcx, ret_ty),\n+           option::map(self_ty) {|st| ty_to_str(tcx, st) }];\n \n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n-    let {purity, node_types, node_type_substs} = alt old_fcx {\n-      none {\n-        {purity: decl.purity,\n-         node_types: smallintmap::mk(),\n-         node_type_substs: map::int_hash()}\n-      }\n-      some(f) {\n-        assert decl.purity == ast::impure_fn;\n-        {purity: f.purity,\n-         node_types: f.node_types,\n-         node_type_substs: f.node_type_substs}\n-      }\n-    };\n+    let fcx: @fn_ctxt = {\n+        let {infcx, locals, tvc, rvc, purity,\n+             node_types, node_type_substs} = alt old_fcx {\n+          none {\n+            {infcx: infer::new_infer_ctxt(tcx),\n+             locals: int_hash(),\n+             tvc: @mut 0u,\n+             rvc: @mut 0u,\n+             purity: decl.purity,\n+             node_types: smallintmap::mk(),\n+             node_type_substs: map::int_hash()}\n+          }\n+          some(fcx) {\n+            assert decl.purity == ast::impure_fn;\n+            {infcx: fcx.infcx,\n+             locals: fcx.locals,\n+             tvc: fcx.ty_var_counter,\n+             rvc: fcx.region_var_counter,\n+             purity: fcx.purity,\n+             node_types: fcx.node_types,\n+             node_type_substs: fcx.node_type_substs}\n+          }\n+        };\n+\n+        let indirect_ret_ty = if indirect_ret {\n+            let ofcx = option::get(old_fcx);\n+            alt ofcx.indirect_ret_ty {\n+              some(t) { some(t) }\n+              none { some(ofcx.ret_ty) }\n+            }\n+        } else { none };\n \n-    let gather_result = gather_locals(ccx, decl, body, arg_tys, old_fcx);\n-    let indirect_ret_ty = if indirect_ret {\n-        let ofcx = option::get(old_fcx);\n-        alt ofcx.indirect_ret_ty {\n-          some(t) { some(t) }\n-          none { some(ofcx.ret_ty) }\n-        }\n-    } else { none };\n-    let fcx: @fn_ctxt =\n         @{self_ty: self_ty,\n           ret_ty: ret_ty,\n           indirect_ret_ty: indirect_ret_ty,\n           purity: purity,\n           proto: proto,\n-          infcx: gather_result.infcx,\n-          locals: gather_result.locals,\n-          next_var_id: gather_result.next_var_id,\n-          next_region_var_id: @mut 0u,\n+          infcx: infcx,\n+          locals: locals,\n+          ty_var_counter: tvc,\n+          region_var_counter: rvc,\n+          in_scope_regions: isr,\n           node_types: node_types,\n           node_type_substs: node_type_substs,\n-          ccx: ccx};\n+          ccx: ccx}\n+    };\n \n+    gather_locals(fcx, decl, body, arg_tys);\n     check_constraints(fcx, decl.constraints, decl.inputs);\n     check_block(fcx, body);\n \n@@ -3962,6 +4097,76 @@ fn check_fn(ccx: @crate_ctxt,\n         vtable::resolve_in_block(fcx, body);\n         writeback::resolve_type_vars_in_fn(fcx, decl, body);\n     }\n+\n+    fn gather_locals(fcx: @fn_ctxt,\n+                     decl: ast::fn_decl,\n+                     body: ast::blk,\n+                     arg_tys: [ty::t]) {\n+        let tcx = fcx.ccx.tcx;\n+\n+        let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n+            let var_id = fcx.next_ty_var_id();\n+            fcx.locals.insert(nid, var_id);\n+            alt ty_opt {\n+              none {/* nothing to do */ }\n+              some(typ) {\n+                infer::mk_eqty(fcx.infcx, ty::mk_var(tcx, var_id), typ);\n+              }\n+            }\n+        };\n+\n+        // Add formal parameters.\n+        vec::iter2(arg_tys, decl.inputs) {|arg_ty, input|\n+            assign(input.id, some(arg_ty));\n+            #debug[\"Argument %s is assigned to %s\",\n+                   input.ident, fcx.locals.get(input.id).to_str()];\n+        }\n+\n+        // Add explicitly-declared locals.\n+        let visit_local = fn@(local: @ast::local,\n+                              &&e: (), v: visit::vt<()>) {\n+            let o_ty = alt local.node.ty.node {\n+              ast::ty_infer { none }\n+              _ { some(fcx.to_ty(local.node.ty)) }\n+            };\n+            assign(local.node.id, o_ty);\n+            #debug[\"Local variable %s is assigned to %s\",\n+                   pat_to_str(local.node.pat),\n+                   fcx.locals.get(local.node.id).to_str()];\n+            visit::visit_local(local, e, v);\n+        };\n+\n+        // Add pattern bindings.\n+        let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {\n+            alt p.node {\n+              ast::pat_ident(path, _)\n+              if !pat_util::pat_is_variant(fcx.ccx.tcx.def_map, p) {\n+                assign(p.id, none);\n+                #debug[\"Pattern binding %s is assigned to %s\",\n+                       path.node.idents[0],\n+                       fcx.locals.get(p.id).to_str()];\n+              }\n+              _ {}\n+            }\n+            visit::visit_pat(p, e, v);\n+        };\n+\n+        // Don't descend into fns and items\n+        fn visit_fn<T>(_fk: visit::fn_kind, _decl: ast::fn_decl,\n+                       _body: ast::blk, _sp: span,\n+                       _id: ast::node_id, _t: T, _v: visit::vt<T>) {\n+        }\n+        fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n+\n+        let visit =\n+            @{visit_local: visit_local,\n+              visit_pat: visit_pat,\n+              visit_fn: bind visit_fn(_, _, _, _, _, _, _),\n+              visit_item: bind visit_item(_, _, _)\n+              with *visit::default_visitor()};\n+\n+        visit::visit_block(body, (), visit::mk_vt(visit));\n+    }\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method, self_ty: ty::t) {\n@@ -3973,11 +4178,11 @@ fn class_types(ccx: @crate_ctxt, members: [@ast::class_member]) -> class_map {\n     for members.each {|m|\n       alt m.node {\n          ast::instance_var(_,t,_,id,_) {\n-           rslt.insert(id, ast_ty_to_ty(ccx.tcx, m_collect, t));\n+           rslt.insert(id, ccx.to_ty(t));\n          }\n          ast::class_method(mth) {\n              rslt.insert(mth.id, ty::mk_fn(ccx.tcx,\n-                ty_of_method(ccx.tcx, m_collect, mth).fty));\n+                ty_of_method(ccx, mth).fty));\n          }\n       }\n     }\n@@ -4006,7 +4211,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n         check_bare_fn(ccx, decl, body, dtor_id, none);\n       }\n       ast::item_impl(tps, _, ty, ms) {\n-        let self_ty = ast_ty_to_ty(ccx.tcx, m_check, ty);\n+        let self_ty = ccx.to_self_ty(ty);\n         let self_region = ty::re_free(it.id, ty::br_self);\n         let self_ty = replace_self_region(ccx.tcx, self_region, self_ty);\n         for ms.each {|m| check_method(ccx, m, self_ty);}\n@@ -4044,7 +4249,11 @@ fn arg_is_argv_ty(_tcx: ty::ctxt, a: ty::arg) -> bool {\n     }\n }\n \n-fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id, main_span: span) {\n+fn check_main_fn_ty(ccx: @crate_ctxt,\n+                    main_id: ast::node_id,\n+                    main_span: span) {\n+\n+    let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     alt ty::get(main_t).struct {\n       ty::ty_fn({proto: ast::proto_bare, inputs, output,\n@@ -4082,10 +4291,11 @@ fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id, main_span: span) {\n     }\n }\n \n-fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n+fn check_for_main_fn(ccx: @crate_ctxt, crate: @ast::crate) {\n+    let tcx = ccx.tcx;\n     if !tcx.sess.building_library {\n         alt tcx.sess.main_fn {\n-          some((id, sp)) { check_main_fn_ty(tcx, id, sp); }\n+          some((id, sp)) { check_main_fn_ty(ccx, id, sp); }\n           none { tcx.sess.span_err(crate.span, \"main function not found\"); }\n         }\n     }\n@@ -4165,7 +4375,7 @@ mod vtable {\n           }\n           _ {\n             let mut found = none;\n-            std::list::iter(isc) {|impls|\n+            list::iter(isc) {|impls|\n                 if option::is_none(found) {\n                     for vec::each(*impls) {|im|\n                         let match = alt ty::impl_iface(tcx, im.did) {\n@@ -4314,20 +4524,19 @@ mod vtable {\n \n fn check_crate(tcx: ty::ctxt, impl_map: resolve::impl_map,\n                crate: @ast::crate) -> (method_map, vtable_map) {\n-    collect::collect_item_types(tcx, crate);\n-\n     let ccx = @{impl_map: impl_map,\n                 method_map: std::map::int_hash(),\n                 vtable_map: std::map::int_hash(),\n                 enclosing_class_id: none,\n                 enclosing_class: std::map::int_hash(),\n                 tcx: tcx};\n+    collect::collect_item_types(ccx, crate);\n     let visit = visit::mk_simple_visitor(@{\n         visit_item: bind check_item(ccx, _)\n         with *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);\n-    check_for_main_fn(tcx, crate);\n+    check_for_main_fn(ccx, crate);\n     tcx.sess.abort_if_errors();\n     (ccx.method_map, ccx.vtable_map)\n }"}, {"sha": "4050f8ced92f455d28482396956377f44e59cde0", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -13,7 +13,7 @@ import driver::session::session;\n fn bound_region_to_str(_cx: ctxt, br: bound_region) -> str {\n     alt br {\n       br_anon          { \"&\" }\n-      br_param(_, str) { #fmt[\"&%s\", str] }\n+      br_named(str)    { #fmt[\"&%s\", str] }\n       br_self          { \"&self\" }\n     }\n }\n@@ -53,7 +53,6 @@ fn region_to_str(cx: ctxt, region: region) -> str {\n \n       // These two should not be seen by end-users (very often, anyhow):\n       re_var(id)    { #fmt(\"&%s\", id.to_str()) }\n-      re_default    { \"&(default)\" }\n       re_static     { \"&static\" }\n     }\n }"}, {"sha": "d21c2871be354246503ded67777f68d67882801a", "filename": "src/test/compile-fail/seq-args.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Ftest%2Fcompile-fail%2Fseq-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fseq-args.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -0,0 +1,13 @@\n+use std;\n+fn main() {\n+iface seq { }\n+\n+impl <T> of seq<T> for [T] {\n+    //!^ ERROR wrong number of type arguments for a polymorphic type\n+    /* ... */\n+}\n+impl of seq<bool> for u32 {\n+   /* Treat the integer as a sequence of bits */\n+}\n+\n+}"}, {"sha": "084192c3aa72b094b2d89cb8ab04840c12f08bf4", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35a93e61d480c0f4244a0eaf7ab92cd44f34710e/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=35a93e61d480c0f4244a0eaf7ab92cd44f34710e", "patch": "@@ -1,3 +1,5 @@\n+// xfail-test\n+\n enum int_wrapper {\n     int_wrapper_ctor(&int)\n }"}]}