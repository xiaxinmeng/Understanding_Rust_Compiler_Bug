{"sha": "1ad0cba5e6a837fdebf5f5543d4b169929972705", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZDBjYmE1ZTZhODM3ZmRlYmY1ZjU1NDNkNGIxNjk5Mjk5NzI3MDU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-01T13:51:23Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-05-02T12:54:55Z"}, "message": "regex_macros: simplify using AstBuilder & the improved quoting.\n\nchar literals now work in a quotation.\n\nThere were several instances of duplicated functionality in regex_macros\ncompared to AstBuilder so refactor those out.", "tree": {"sha": "ea84f3c26b36c8e89db6f9473ee1b2230cb1209a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea84f3c26b36c8e89db6f9473ee1b2230cb1209a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ad0cba5e6a837fdebf5f5543d4b169929972705", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ad0cba5e6a837fdebf5f5543d4b169929972705", "html_url": "https://github.com/rust-lang/rust/commit/1ad0cba5e6a837fdebf5f5543d4b169929972705", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ad0cba5e6a837fdebf5f5543d4b169929972705/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d43a98deadf9d1866d99e253db14651c36726e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d43a98deadf9d1866d99e253db14651c36726e3", "html_url": "https://github.com/rust-lang/rust/commit/1d43a98deadf9d1866d99e253db14651c36726e3"}], "stats": {"total": 124, "additions": 37, "deletions": 87}, "files": [{"sha": "36325b96d44696c3a34b2c1cd152173e307e273c", "filename": "src/libregex_macros/lib.rs", "status": "modified", "additions": 37, "deletions": 87, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/1ad0cba5e6a837fdebf5f5543d4b169929972705/src%2Flibregex_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ad0cba5e6a837fdebf5f5543d4b169929972705/src%2Flibregex_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex_macros%2Flib.rs?ref=1ad0cba5e6a837fdebf5f5543d4b169929972705", "patch": "@@ -24,8 +24,11 @@\n extern crate regex;\n extern crate syntax;\n \n+use std::rc::Rc;\n+\n use syntax::ast;\n use syntax::codemap;\n+use syntax::ext::build::AstBuilder;\n use syntax::ext::base::{\n     SyntaxExtension, ExtCtxt, MacResult, MacExpr, DummyResult,\n     NormalTT, BasicMacroExpander,\n@@ -112,24 +115,26 @@ impl<'a> NfaGen<'a> {\n         // expression returned.\n         let num_cap_locs = 2 * self.prog.num_captures();\n         let num_insts = self.prog.insts.len();\n-        let cap_names = self.vec_expr(self.names.as_slice(),\n-            |cx, name| match name {\n-                &Some(ref name) => {\n+        let cap_names = self.vec_expr(self.names.as_slice().iter(),\n+            |cx, name| match *name {\n+                Some(ref name) => {\n                     let name = name.as_slice();\n                     quote_expr!(cx, Some(~$name))\n                 }\n-                &None => quote_expr!(cx, None),\n+                None => cx.expr_none(self.sp),\n             }\n         );\n         let prefix_anchor =\n             match self.prog.insts.as_slice()[1] {\n                 EmptyBegin(flags) if flags & FLAG_MULTI == 0 => true,\n                 _ => false,\n             };\n-        let init_groups = self.vec_from_fn(num_cap_locs,\n-                                           |cx| quote_expr!(cx, None));\n-        let prefix_bytes = self.vec_expr(self.prog.prefix.as_slice().as_bytes(),\n-                                         |cx, b| quote_expr!(cx, $b));\n+        let init_groups = self.vec_expr(range(0, num_cap_locs),\n+                                        |cx, _| cx.expr_none(self.sp));\n+\n+        let prefix_lit = Rc::new(Vec::from_slice(self.prog.prefix.as_slice().as_bytes()));\n+        let prefix_bytes = self.cx.expr_lit(self.sp, ast::LitBinary(prefix_lit));\n+\n         let check_prefix = self.check_prefix();\n         let step_insts = self.step_insts();\n         let add_insts = self.add_insts();\n@@ -320,12 +325,11 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n             let nextpc = pc + 1;\n             let body = match *inst {\n                 EmptyBegin(flags) => {\n-                    let nl = '\\n';\n                     let cond =\n                         if flags & FLAG_MULTI > 0 {\n                             quote_expr!(self.cx,\n                                 self.chars.is_begin()\n-                                || self.chars.prev == Some($nl)\n+                                || self.chars.prev == Some('\\n')\n                             )\n                         } else {\n                             quote_expr!(self.cx, self.chars.is_begin())\n@@ -336,12 +340,11 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                     })\n                 }\n                 EmptyEnd(flags) => {\n-                    let nl = '\\n';\n                     let cond =\n                         if flags & FLAG_MULTI > 0 {\n                             quote_expr!(self.cx,\n                                 self.chars.is_end()\n-                                || self.chars.cur == Some($nl)\n+                                || self.chars.cur == Some('\\n')\n                             )\n                         } else {\n                             quote_expr!(self.cx, self.chars.is_end())\n@@ -489,16 +492,16 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n                     if flags & FLAG_DOTNL > 0 {\n                         quote_expr!(self.cx, self.add(nlist, $nextpc, caps))\n                     } else {\n-                        let nl = '\\n'; // no char lits allowed? wtf?\n                         quote_expr!(self.cx, {\n-                            if self.chars.prev != Some($nl) {\n+                            if self.chars.prev != Some('\\n') {\n                                 self.add(nlist, $nextpc, caps)\n                             }\n+                            ()\n                         })\n                     }\n                 }\n                 // EmptyBegin, EmptyEnd, EmptyWordBoundary, Save, Jump, Split\n-                _ => quote_expr!(self.cx, {}),\n+                _ => self.empty_block(),\n             };\n             self.arm_inst(pc, body)\n         }).collect::<Vec<ast::Arm>>();\n@@ -510,36 +513,30 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // This avoids a binary search (and is hopefully replaced by a jump\n     // table).\n     fn match_class(&self, casei: bool, ranges: &[(char, char)]) -> @ast::Expr {\n+        let expr_true = quote_expr!(self.cx, true);\n+\n         let mut arms = ranges.iter().map(|&(mut start, mut end)| {\n             if casei {\n                 start = start.to_uppercase();\n                 end = end.to_uppercase();\n             }\n-            ast::Arm {\n-                attrs: vec!(),\n-                pats: vec!(@ast::Pat{\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: self.sp,\n-                    node: ast::PatRange(quote_expr!(self.cx, $start),\n-                                        quote_expr!(self.cx, $end)),\n-                }),\n-                guard: None,\n-                body: quote_expr!(self.cx, true),\n-            }\n+            let pat = self.cx.pat(self.sp, ast::PatRange(quote_expr!(self.cx, $start),\n+                                                         quote_expr!(self.cx, $end)));\n+            self.cx.arm(self.sp, vec!(pat), expr_true)\n         }).collect::<Vec<ast::Arm>>();\n \n         arms.push(self.wild_arm_expr(quote_expr!(self.cx, false)));\n \n         let match_on = quote_expr!(self.cx, c);\n-        self.dummy_expr(ast::ExprMatch(match_on, arms))\n+        self.cx.expr_match(self.sp, match_on, arms)\n     }\n \n     // Generates code for checking a literal prefix of the search string.\n     // The code is only generated if the regex *has* a literal prefix.\n     // Otherwise, a no-op is returned.\n     fn check_prefix(&self) -> @ast::Expr {\n         if self.prog.prefix.len() == 0 {\n-            quote_expr!(self.cx, {})\n+            self.empty_block()\n         } else {\n             quote_expr!(self.cx,\n                 if clist.size == 0 {\n@@ -562,24 +559,20 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n     // never be used, but is added to satisfy the compiler complaining about\n     // non-exhaustive patterns.\n     fn match_insts(&self, mut arms: Vec<ast::Arm>) -> @ast::Expr {\n-        let mat_pc = quote_expr!(self.cx, pc);\n-        arms.push(self.wild_arm_expr(quote_expr!(self.cx, {})));\n-        self.dummy_expr(ast::ExprMatch(mat_pc, arms))\n+        arms.push(self.wild_arm_expr(self.empty_block()));\n+        self.cx.expr_match(self.sp, quote_expr!(self.cx, pc), arms)\n+    }\n+\n+    fn empty_block(&self) -> @ast::Expr {\n+        quote_expr!(self.cx, {})\n     }\n \n     // Creates a match arm for the instruction at `pc` with the expression\n     // `body`.\n     fn arm_inst(&self, pc: uint, body: @ast::Expr) -> ast::Arm {\n-        ast::Arm {\n-            attrs: vec!(),\n-            pats: vec!(@ast::Pat{\n-                id: ast::DUMMY_NODE_ID,\n-                span: self.sp,\n-                node: ast::PatLit(quote_expr!(self.cx, $pc)),\n-            }),\n-            guard: None,\n-            body: body,\n-        }\n+        let pc_pat = self.cx.pat_lit(self.sp, quote_expr!(self.cx, $pc));\n+\n+        self.cx.arm(self.sp, vec!(pc_pat), body)\n     }\n \n     // Creates a wild-card match arm with the expression `body`.\n@@ -596,56 +589,13 @@ fn exec<'t>(which: ::regex::native::MatchKind, input: &'t str,\n         }\n     }\n \n-    // Builds a `[a, b, .., len]` expression where each element is the result\n-    // of executing `to_expr`.\n-    fn vec_from_fn(&self, len: uint, to_expr: |&ExtCtxt| -> @ast::Expr)\n-                  -> @ast::Expr {\n-        self.vec_expr(Vec::from_elem(len, ()).as_slice(),\n-                      |cx, _| to_expr(cx))\n-    }\n \n     // Converts `xs` to a `[x1, x2, .., xN]` expression by calling `to_expr`\n     // on each element in `xs`.\n-    fn vec_expr<T>(&self, xs: &[T], to_expr: |&ExtCtxt, &T| -> @ast::Expr)\n+    fn vec_expr<T, It: Iterator<T>>(&self, xs: It, to_expr: |&ExtCtxt, T| -> @ast::Expr)\n                   -> @ast::Expr {\n-        let mut exprs = vec!();\n-        for x in xs.iter() {\n-            exprs.push(to_expr(self.cx, x))\n-        }\n-        let vec_exprs = self.dummy_expr(ast::ExprVec(exprs));\n-        quote_expr!(self.cx, $vec_exprs)\n-    }\n-\n-    // Creates an expression with a dummy node ID given an underlying\n-    // `ast::Expr_`.\n-    fn dummy_expr(&self, e: ast::Expr_) -> @ast::Expr {\n-        @ast::Expr {\n-            id: ast::DUMMY_NODE_ID,\n-            node: e,\n-            span: self.sp,\n-        }\n-    }\n-}\n-\n-// This trait is defined in the quote module in the syntax crate, but I\n-// don't think it's exported.\n-// Interestingly, quote_expr! only requires that a 'to_tokens' method be\n-// defined rather than satisfying a particular trait.\n-#[doc(hidden)]\n-trait ToTokens {\n-    fn to_tokens(&self, cx: &ExtCtxt) -> Vec<ast::TokenTree>;\n-}\n-\n-impl ToTokens for char {\n-    fn to_tokens(&self, _: &ExtCtxt) -> Vec<ast::TokenTree> {\n-        vec!(ast::TTTok(codemap::DUMMY_SP, token::LIT_CHAR((*self) as u32)))\n-    }\n-}\n-\n-impl ToTokens for bool {\n-    fn to_tokens(&self, _: &ExtCtxt) -> Vec<ast::TokenTree> {\n-        let ident = token::IDENT(token::str_to_ident(self.to_str()), false);\n-        vec!(ast::TTTok(codemap::DUMMY_SP, ident))\n+        let exprs = xs.map(|x| to_expr(self.cx, x)).collect();\n+        self.cx.expr_vec(self.sp, exprs)\n     }\n }\n "}]}