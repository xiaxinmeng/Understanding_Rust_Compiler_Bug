{"sha": "e9e8514ca076118267875a1a640551a7e2524801", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5ZTg1MTRjYTA3NjExODI2Nzg3NWExYTY0MDU1MWE3ZTI1MjQ4MDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T19:26:35Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-05-22T23:05:42Z"}, "message": "add `Span` information into `Qself`", "tree": {"sha": "5586d79bb1c2ea3814bf23cf3fe5a18db55fe3fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5586d79bb1c2ea3814bf23cf3fe5a18db55fe3fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9e8514ca076118267875a1a640551a7e2524801", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9e8514ca076118267875a1a640551a7e2524801", "html_url": "https://github.com/rust-lang/rust/commit/e9e8514ca076118267875a1a640551a7e2524801", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9e8514ca076118267875a1a640551a7e2524801/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d034ae53c43352b06341455fb1394cb5d4069999", "url": "https://api.github.com/repos/rust-lang/rust/commits/d034ae53c43352b06341455fb1394cb5d4069999", "html_url": "https://github.com/rust-lang/rust/commit/d034ae53c43352b06341455fb1394cb5d4069999"}], "stats": {"total": 67, "additions": 57, "deletions": 10}, "files": [{"sha": "e228374f10039f5312048abe8c9f8049da4a41b3", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e9e8514ca076118267875a1a640551a7e2524801", "patch": "@@ -3139,6 +3139,17 @@ impl<'a> Resolver<'a> {\n                      span: Span,\n                      global_by_default: bool)\n                      -> Option<PathResolution> {\n+        debug!(\n+            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, \\\n+             ns={:?}, span={:?}, global_by_default={:?})\",\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            global_by_default,\n+        );\n+\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // FIXME: Create some fake resolution that can't possibly be a type.\n@@ -3231,6 +3242,15 @@ impl<'a> Resolver<'a> {\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n+        debug!(\n+            \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, path_span={:?}, crate_lint={:?})\",\n+            path,\n+            opt_ns,\n+            record_used,\n+            path_span,\n+            crate_lint,\n+        );\n+\n         for (i, &ident) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?}\", i, ident);\n             let is_last = i == path.len() - 1;\n@@ -4454,6 +4474,7 @@ pub enum MakeGlobMap {\n     No,\n }\n \n+#[derive(Debug)]\n enum CrateLint {\n     /// Do not issue the lint\n     No,"}, {"sha": "72d5323a8722aa70a7dc4f88293ea4ed735ec2c1", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e9e8514ca076118267875a1a640551a7e2524801", "patch": "@@ -1211,6 +1211,11 @@ pub enum ExprKind {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct QSelf {\n     pub ty: P<Ty>,\n+\n+    /// The span of `a::b::Trait` in a path like `<Vec<T> as\n+    /// a::b::Trait>::AssociatedItem`; in the case where `position ==\n+    /// 0`, this is an empty span.\n+    pub path_span: Span,\n     pub position: usize\n }\n "}, {"sha": "6664c0a5982ee5e826e0fb50166fbe79315cf84a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e9e8514ca076118267875a1a640551a7e2524801", "patch": "@@ -373,6 +373,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n         (ast::QSelf {\n             ty: self_type,\n+            path_span: path.span,\n             position: path.segments.len() - 1\n         }, path)\n     }"}, {"sha": "525a82b61345224353ad7734709da1cc3f327b92", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e9e8514ca076118267875a1a640551a7e2524801", "patch": "@@ -390,9 +390,10 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::Tup(tys) => TyKind::Tup(tys.move_map(|ty| fld.fold_ty(ty))),\n             TyKind::Paren(ty) => TyKind::Paren(fld.fold_ty(ty)),\n             TyKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n+                let qself = qself.map(|QSelf { ty, path_span, position }| {\n                     QSelf {\n                         ty: fld.fold_ty(ty),\n+                        path_span: fld.new_span(path_span),\n                         position,\n                     }\n                 });\n@@ -1131,7 +1132,11 @@ pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n             }\n             PatKind::Path(opt_qself, pth) => {\n                 let opt_qself = opt_qself.map(|qself| {\n-                    QSelf { ty: folder.fold_ty(qself.ty), position: qself.position }\n+                    QSelf {\n+                        ty: folder.fold_ty(qself.ty),\n+                        path_span: folder.new_span(qself.path_span),\n+                        position: qself.position,\n+                    }\n                 });\n                 PatKind::Path(opt_qself, folder.fold_path(pth))\n             }\n@@ -1292,9 +1297,10 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                                 lim)\n             }\n             ExprKind::Path(qself, path) => {\n-                let qself = qself.map(|QSelf { ty, position }| {\n+                let qself = qself.map(|QSelf { ty, path_span, position }| {\n                     QSelf {\n                         ty: folder.fold_ty(ty),\n+                        path_span: folder.new_span(path_span),\n                         position,\n                     }\n                 });"}, {"sha": "1429d881fe9bc9844c0f3be92a2777e9bd4a288b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9e8514ca076118267875a1a640551a7e2524801/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e9e8514ca076118267875a1a640551a7e2524801", "patch": "@@ -1715,8 +1715,11 @@ impl<'a> Parser<'a> {\n         self.parse_path_segments(&mut segments, T::PATH_STYLE, true)?;\n \n         let span = ty.span.to(self.prev_span);\n-        let recovered =\n-            base.to_recovered(Some(QSelf { ty, position: 0 }), ast::Path { segments, span });\n+        let path_span = span.to(span); // use an empty path since `position` == 0\n+        let recovered = base.to_recovered(\n+            Some(QSelf { ty, path_span, position: 0 }),\n+            ast::Path { segments, span },\n+        );\n \n         self.diagnostic()\n             .struct_span_err(span, \"missing angle brackets in associated item path\")\n@@ -1905,21 +1908,32 @@ impl<'a> Parser<'a> {\n     /// `qualified_path = <type [as trait_ref]>::path`\n     ///\n     /// # Examples\n+    /// `<T>::default`\n     /// `<T as U>::a`\n     /// `<T as U>::F::a<S>` (without disambiguator)\n     /// `<T as U>::F::a::<S>` (with disambiguator)\n     fn parse_qpath(&mut self, style: PathStyle) -> PResult<'a, (QSelf, ast::Path)> {\n         let lo = self.prev_span;\n         let ty = self.parse_ty()?;\n-        let mut path = if self.eat_keyword(keywords::As) {\n-            self.parse_path(PathStyle::Type)?\n+\n+        // `path` will contain the prefix of the path up to the `>`,\n+        // if any (e.g., `U` in the `<T as U>::*` examples\n+        // above). `path_span` has the span of that path, or an empty\n+        // span in the case of something like `<T>::Bar`.\n+        let (mut path, path_span);\n+        if self.eat_keyword(keywords::As) {\n+            let path_lo = self.span;\n+            path = self.parse_path(PathStyle::Type)?;\n+            path_span = path_lo.to(self.prev_span);\n         } else {\n-            ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP }\n-        };\n+            path = ast::Path { segments: Vec::new(), span: syntax_pos::DUMMY_SP };\n+            path_span = self.span.to(self.span);\n+        }\n+\n         self.expect(&token::Gt)?;\n         self.expect(&token::ModSep)?;\n \n-        let qself = QSelf { ty, position: path.segments.len() };\n+        let qself = QSelf { ty, path_span, position: path.segments.len() };\n         self.parse_path_segments(&mut path.segments, style, true)?;\n \n         Ok((qself, ast::Path { segments: path.segments, span: lo.to(self.prev_span) }))"}]}