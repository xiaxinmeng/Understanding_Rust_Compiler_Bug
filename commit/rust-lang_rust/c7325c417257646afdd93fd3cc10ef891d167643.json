{"sha": "c7325c417257646afdd93fd3cc10ef891d167643", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MzI1YzQxNzI1NzY0NmFmZGQ5M2ZkM2NjMTBlZjg5MWQxNjc2NDM=", "commit": {"author": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-02-24T21:14:12Z"}, "committer": {"name": "Jed Davis", "email": "jld@panix.com", "date": "2013-03-07T04:41:57Z"}, "message": "Convert the rest of the adt GEPi's in _match", "tree": {"sha": "41331f7aba41880faa3aa0f934c0210e920ef103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41331f7aba41880faa3aa0f934c0210e920ef103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7325c417257646afdd93fd3cc10ef891d167643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7325c417257646afdd93fd3cc10ef891d167643", "html_url": "https://github.com/rust-lang/rust/commit/c7325c417257646afdd93fd3cc10ef891d167643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7325c417257646afdd93fd3cc10ef891d167643/comments", "author": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jld", "id": 254973, "node_id": "MDQ6VXNlcjI1NDk3Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/254973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jld", "html_url": "https://github.com/jld", "followers_url": "https://api.github.com/users/jld/followers", "following_url": "https://api.github.com/users/jld/following{/other_user}", "gists_url": "https://api.github.com/users/jld/gists{/gist_id}", "starred_url": "https://api.github.com/users/jld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jld/subscriptions", "organizations_url": "https://api.github.com/users/jld/orgs", "repos_url": "https://api.github.com/users/jld/repos", "events_url": "https://api.github.com/users/jld/events{/privacy}", "received_events_url": "https://api.github.com/users/jld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a4714d92e49564c1cfc86fae5573510de7c2e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a4714d92e49564c1cfc86fae5573510de7c2e31", "html_url": "https://github.com/rust-lang/rust/commit/3a4714d92e49564c1cfc86fae5573510de7c2e31"}], "stats": {"total": 32, "additions": 21, "deletions": 11}, "files": [{"sha": "5a9d6c3b6c66297d4c3e3bc3549411e0e3600d91", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c7325c417257646afdd93fd3cc10ef891d167643/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7325c417257646afdd93fd3cc10ef891d167643/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c7325c417257646afdd93fd3cc10ef891d167643", "patch": "@@ -1267,14 +1267,14 @@ pub fn compile_submatch(bcx: block,\n     }\n \n     bcx = root_pats_as_necessary(bcx, m, col, val);\n-\n     let rec_fields = collect_record_or_struct_fields(bcx, m, col);\n     if rec_fields.len() > 0 {\n         let pat_ty = node_id_type(bcx, pat_id);\n-        do expr::with_field_tys(tcx, pat_ty, None) |_has_dtor, field_tys| {\n+        let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+        do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n             let rec_vals = rec_fields.map(|field_name| {\n                 let ix = ty::field_idx_strict(tcx, *field_name, field_tys);\n-                GEPi(bcx, val, struct_field(ix))\n+                adt::trans_GEP(bcx, &pat_repr, val, discr, ix)\n             });\n             compile_submatch(\n                 bcx,\n@@ -1287,11 +1287,14 @@ pub fn compile_submatch(bcx: block,\n \n     if any_tup_pat(m, col) {\n         let tup_ty = node_id_type(bcx, pat_id);\n+        let tup_repr = adt::represent_type(bcx.ccx(), tup_ty);\n         let n_tup_elts = match /*bad*/copy ty::get(tup_ty).sty {\n           ty::ty_tup(elts) => elts.len(),\n           _ => ccx.sess.bug(~\"non-tuple type in tuple pattern\")\n         };\n-        let tup_vals = vec::from_fn(n_tup_elts, |i| GEPi(bcx, val, [0u, i]));\n+        let tup_vals = do vec::from_fn(n_tup_elts) |i| {\n+            adt::trans_GEP(bcx, &tup_repr, val, 0, i)\n+        };\n         compile_submatch(bcx, enter_tup(bcx, dm, m, col, val, n_tup_elts),\n                          vec::append(tup_vals, vals_left), chk);\n         return;\n@@ -1310,8 +1313,10 @@ pub fn compile_submatch(bcx: block,\n             }\n         }\n \n-        let llstructvals = vec::from_fn(\n-            struct_element_count, |i| GEPi(bcx, val, struct_field(i)));\n+        let struct_repr = adt::represent_type(bcx.ccx(), struct_ty);\n+        let llstructvals = do vec::from_fn(struct_element_count) |i| {\n+            adt::trans_GEP(bcx, &struct_repr, val, 0, i)\n+        };\n         compile_submatch(bcx,\n                          enter_tuple_struct(bcx, dm, m, col, val,\n                                             struct_element_count),\n@@ -1745,9 +1750,11 @@ pub fn bind_irrefutable_pat(bcx: block,\n                             // This is a unit-like struct. Nothing to do here.\n                         }\n                         Some(elems) => {\n-                            // This is the tuple variant case.\n+                            // This is the tuple struct case.\n+                            let repr = adt::represent_node(bcx, pat.id);\n                             for vec::eachi(elems) |i, elem| {\n-                                let fldptr = GEPi(bcx, val, struct_field(i));\n+                                let fldptr = adt::trans_GEP(bcx, &repr,\n+                                                            val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n                                                            *elem,\n                                                            fldptr,\n@@ -1765,10 +1772,12 @@ pub fn bind_irrefutable_pat(bcx: block,\n         ast::pat_rec(fields, _) | ast::pat_struct(_, fields, _) => {\n             let tcx = bcx.tcx();\n             let pat_ty = node_id_type(bcx, pat.id);\n-            do expr::with_field_tys(tcx, pat_ty, None) |_hd, field_tys| {\n+            let pat_repr = adt::represent_type(bcx.ccx(), pat_ty);\n+            do expr::with_field_tys(tcx, pat_ty, None) |discr, field_tys| {\n                 for vec::each(fields) |f| {\n                     let ix = ty::field_idx_strict(tcx, f.ident, field_tys);\n-                    let fldptr = GEPi(bcx, val, struct_field(ix));\n+                    let fldptr = adt::trans_GEP(bcx, &pat_repr, val,\n+                                                discr, ix);\n                     bcx = bind_irrefutable_pat(bcx,\n                                                f.pat,\n                                                fldptr,\n@@ -1778,8 +1787,9 @@ pub fn bind_irrefutable_pat(bcx: block,\n             }\n         }\n         ast::pat_tup(elems) => {\n+            let repr = adt::represent_node(bcx, pat.id);\n             for vec::eachi(elems) |i, elem| {\n-                let fldptr = GEPi(bcx, val, [0u, i]);\n+                let fldptr = adt::trans_GEP(bcx, &repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,\n                                            fldptr,"}]}