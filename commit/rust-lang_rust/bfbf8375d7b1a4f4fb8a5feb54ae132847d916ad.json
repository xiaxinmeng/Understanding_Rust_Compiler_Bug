{"sha": "bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYmY4Mzc1ZDdiMWE0ZjRmYjhhNWZlYjU0YWUxMzI4NDdkOTE2YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-26T15:23:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-26T15:23:50Z"}, "message": "Auto merge of #52488 - nikomatsakis:nll-issue-48071-universe-and-sub, r=pnkfelix\n\nintroduce universes to NLL type check\n\nThis branch aims to fix #48071 and also advance chalk integration a bit at the same time. It re-implements the subtyping/type-equating check so that NLL doesn't \"piggy back\" on the subtyping code of the old type checker.\n\nThis new code uses the \"universe-based\" approach to handling higher-ranked lifetimes, which sidesteps some of the limitations of the current \"leak-based\" scheme. This avoids the ICE in #48071.\n\nAt the same time, I aim for this to potentially be a kind of optimization. This NLL code is (currently) not cached, but it also generates constraints without doing as much instantiation, substitution, and folding. Right now, though, it still piggy backs on the `relate_tys` trait, which is a bit unfortunate -- it means we are doing more hashing and things than we have to. I want to measure the see the perf. Refactoring that trait is something I'd prefer to leave for follow-up work.\n\nr? @pnkfelix -- but I want to measure perf etc first", "tree": {"sha": "9afeb7f75e66a7fb1bee1572a1f01de27c5662a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9afeb7f75e66a7fb1bee1572a1f01de27c5662a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "html_url": "https://github.com/rust-lang/rust/commit/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fefe81605d6111faa8dbb3635ab2c51d59de740a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fefe81605d6111faa8dbb3635ab2c51d59de740a", "html_url": "https://github.com/rust-lang/rust/commit/fefe81605d6111faa8dbb3635ab2c51d59de740a"}, {"sha": "ce576ac259e98138f6e2f19e40a632c279c6a516", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce576ac259e98138f6e2f19e40a632c279c6a516", "html_url": "https://github.com/rust-lang/rust/commit/ce576ac259e98138f6e2f19e40a632c279c6a516"}], "stats": {"total": 2810, "additions": 2044, "deletions": 766}, "files": [{"sha": "09baaeadaee43b58d8d7ec7af1ed7e75b412aed0", "filename": "src/Cargo.lock", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -87,7 +87,7 @@ dependencies = [\n \n [[package]]\n name = \"atty\"\n-version = \"0.2.11\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.42 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -187,7 +187,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"cargo\"\n version = \"0.30.0\"\n dependencies = [\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"clap 2.32.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"core-foundation 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -303,7 +303,7 @@ version = \"2.32.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"textwrap 0.10.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -622,7 +622,7 @@ name = \"env_logger\"\n version = \"0.5.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1844,7 +1844,7 @@ name = \"rustc-ap-rustc_errors\"\n version = \"182.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-rustc_data_structures 182.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-serialize 182.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-ap-syntax_pos 182.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -2097,7 +2097,7 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n- \"atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -3056,7 +3056,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef\"\n \"checksum assert_cli 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"98589b0e465a6c510d95fceebd365bb79bedece7f6e18a480897f2015f85ec51\"\n-\"checksum atty 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9a7d5b8723950951411ee34d271d99dddcc2035a16ab25310ea2c8cfd4369652\"\n+\"checksum atty 0.2.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2fc4a1aa4c24c0718a250f0681885c1af91419d242f29eb8f2ab28502d80dbd1\"\n \"checksum backtrace 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"89a47830402e9981c5c41223151efcced65a0510c13097c769cede7efb34782a\"\n \"checksum backtrace-sys 0.1.23 (registry+https://github.com/rust-lang/crates.io-index)\" = \"bff67d0c06556c0b8e6b5f090f0eac52d950d9dfd1d35ba04e4ca3543eaf6a7e\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\""}, {"sha": "1721d1dd0e9c578e436b1ae6a621083c888df68e", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -39,7 +39,6 @@ pub struct DepGraph {\n     fingerprints: Lrc<Lock<IndexVec<DepNodeIndex, Fingerprint>>>\n }\n \n-\n newtype_index!(DepNodeIndex);\n \n impl DepNodeIndex {"}, {"sha": "cb4e1ab65e7590995546a5f711e0b365f7d0718e", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -617,6 +617,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"leak_check: skol_map={:?}\",\n                skol_map);\n \n+        // If the user gave `-Zno-leak-check`, then skip the leak\n+        // check completely. This is wildly unsound and also not\n+        // unlikely to cause an ICE or two. It is intended for use\n+        // only during a transition period, in which the MIR typeck\n+        // uses the \"universe-style\" check, and the rest of typeck\n+        // uses the more conservative leak check.  Since the leak\n+        // check is more conservative, we can't test the\n+        // universe-style check without disabling it.\n+        if self.tcx.sess.opts.debugging_opts.no_leak_check {\n+            return Ok(());\n+        }\n+\n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n         for (&skol_br, &skol) in skol_map {\n             // The inputs to a skolemized variable can only"}, {"sha": "0b84c6a0aa77abdee3a7fc4cf09290036d10e9c9", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -377,7 +377,23 @@ pub enum NLLRegionVariableOrigin {\n     // elsewhere. This origin indices we've got one of those.\n     FreeRegion,\n \n-    Inferred(::mir::visit::TyContext),\n+    BoundRegion(ty::UniverseIndex),\n+\n+    Existential,\n+}\n+\n+impl NLLRegionVariableOrigin {\n+    pub fn is_universal(self) -> bool {\n+        match self {\n+            NLLRegionVariableOrigin::FreeRegion => true,\n+            NLLRegionVariableOrigin::BoundRegion(..) => true,\n+            NLLRegionVariableOrigin::Existential => false,\n+        }\n+    }\n+\n+    pub fn is_existential(self) -> bool {\n+        !self.is_universal()\n+    }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -1381,6 +1397,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn universe(&self) -> ty::UniverseIndex {\n         self.universe.get()\n     }\n+\n+    /// Create and return a new subunivese of the current universe;\n+    /// update `self.universe` to that new subuniverse. At present,\n+    /// used only in the NLL subtyping code, which uses the new\n+    /// universe-based scheme instead of the more limited leak-check\n+    /// scheme.\n+    pub fn create_subuniverse(&self) -> ty::UniverseIndex {\n+        let u = self.universe.get().subuniverse();\n+        self.universe.set(u);\n+        u\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeTrace<'tcx> {"}, {"sha": "d709a4debd1d38bedc8d4e2f71a79a8faacfb6df", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -69,6 +69,7 @@\n #![feature(trusted_len)]\n #![feature(vec_remove_item)]\n #![feature(catch_expr)]\n+#![feature(step_trait)]\n #![feature(integer_atomics)]\n #![feature(test)]\n #![feature(in_band_lifetimes)]"}, {"sha": "87ba3420eecebbad605aed0e4d6bd5b79b35fa24", "filename": "src/librustc/mir/traversal.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fmir%2Ftraversal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fmir%2Ftraversal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftraversal.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n \n use super::*;\n \n@@ -33,7 +32,7 @@ use super::*;\n #[derive(Clone)]\n pub struct Preorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector,\n+    visited: BitVector<BasicBlock>,\n     worklist: Vec<BasicBlock>,\n }\n \n@@ -58,7 +57,7 @@ impl<'a, 'tcx> Iterator for Preorder<'a, 'tcx> {\n \n     fn next(&mut self) -> Option<(BasicBlock, &'a BasicBlockData<'tcx>)> {\n         while let Some(idx) = self.worklist.pop() {\n-            if !self.visited.insert(idx.index()) {\n+            if !self.visited.insert(idx) {\n                 continue;\n             }\n \n@@ -107,7 +106,7 @@ impl<'a, 'tcx> ExactSizeIterator for Preorder<'a, 'tcx> {}\n /// A Postorder traversal of this graph is `D B C A` or `D C B A`\n pub struct Postorder<'a, 'tcx: 'a> {\n     mir: &'a Mir<'tcx>,\n-    visited: BitVector,\n+    visited: BitVector<BasicBlock>,\n     visit_stack: Vec<(BasicBlock, Successors<'a>)>\n }\n \n@@ -123,7 +122,7 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n         let data = &po.mir[root];\n \n         if let Some(ref term) = data.terminator {\n-            po.visited.insert(root.index());\n+            po.visited.insert(root);\n             po.visit_stack.push((root, term.successors()));\n             po.traverse_successor();\n         }\n@@ -190,8 +189,8 @@ impl<'a, 'tcx> Postorder<'a, 'tcx> {\n                 break;\n             };\n \n-            if self.visited.insert(bb.index()) {\n-                if let Some(ref term) = self.mir[bb].terminator {\n+            if self.visited.insert(bb) {\n+                if let Some(term) = &self.mir[bb].terminator {\n                     self.visit_stack.push((bb, term.successors()));\n                 }\n             }"}, {"sha": "54d9e24bbc0e237134ff86936435643b41ab18a2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -1353,6 +1353,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"generate build artifacts that are compatible with linker-based LTO.\"),\n     no_parallel_llvm: bool = (false, parse_bool, [UNTRACKED],\n           \"don't run LLVM in parallel (while keeping codegen-units and ThinLTO)\"),\n+    no_leak_check: bool = (false, parse_bool, [UNTRACKED],\n+        \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "b0797c31461ee22493b2cfbb7842788e3cf43797", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -1481,14 +1481,27 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n /// type name in a non-zero universe is a skolemized type -- an\n /// idealized representative of \"types in general\" that we use for\n /// checking generic functions.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UniverseIndex(u32);\n \n impl UniverseIndex {\n     /// The root universe, where things that the user defined are\n     /// visible.\n     pub const ROOT: Self = UniverseIndex(0);\n \n+    /// The \"max universe\" -- this isn't really a valid universe, but\n+    /// it's useful sometimes as a \"starting value\" when you are\n+    /// taking the minimum of a (non-empty!) set of universes.\n+    pub const MAX: Self = UniverseIndex(::std::u32::MAX);\n+\n+    /// Creates a universe index from the given integer.  Not to be\n+    /// used lightly lest you pick a bad value. But sometimes we\n+    /// convert universe indicies into integers and back for various\n+    /// reasons.\n+    pub fn from_u32(index: u32) -> Self {\n+        UniverseIndex(index)\n+    }\n+\n     /// A \"subuniverse\" corresponds to being inside a `forall` quantifier.\n     /// So, for example, suppose we have this type in universe `U`:\n     ///\n@@ -1504,6 +1517,11 @@ impl UniverseIndex {\n         UniverseIndex(self.0.checked_add(1).unwrap())\n     }\n \n+    /// True if the names in this universe are a subset of the names in `other`.\n+    pub fn is_subset_of(self, other: UniverseIndex) -> bool {\n+        self.0 <= other.0\n+    }\n+\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n@@ -1513,6 +1531,12 @@ impl UniverseIndex {\n     }\n }\n \n+impl fmt::Debug for UniverseIndex {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"U{}\", self.as_u32())\n+    }\n+}\n+\n impl From<u32> for UniverseIndex {\n     fn from(index: u32) -> Self {\n         UniverseIndex(index)"}, {"sha": "fcde7f9bbc33d8c1cc3681aaf049f5256d4b373d", "filename": "src/librustc_codegen_llvm/debuginfo/create_scope_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fcreate_scope_map.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -65,7 +65,7 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n     let mut has_variables = BitVector::new(mir.source_scopes.len());\n     for var in mir.vars_iter() {\n         let decl = &mir.local_decls[var];\n-        has_variables.insert(decl.visibility_scope.index());\n+        has_variables.insert(decl.visibility_scope);\n     }\n \n     // Instantiate all scopes.\n@@ -79,7 +79,7 @@ pub fn create_mir_scopes(cx: &CodegenCx, mir: &Mir, debug_context: &FunctionDebu\n \n fn make_mir_scope(cx: &CodegenCx,\n                   mir: &Mir,\n-                  has_variables: &BitVector,\n+                  has_variables: &BitVector<SourceScope>,\n                   debug_context: &FunctionDebugContextData,\n                   scope: SourceScope,\n                   scopes: &mut IndexVec<SourceScope, MirDebugScope>) {\n@@ -102,7 +102,7 @@ fn make_mir_scope(cx: &CodegenCx,\n         return;\n     };\n \n-    if !has_variables.contains(scope.index()) {\n+    if !has_variables.contains(scope) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n "}, {"sha": "e105baba8aa2e56f441123600b506068d28dc519", "filename": "src/librustc_codegen_llvm/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fanalyze.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -22,7 +22,7 @@ use rustc::ty::layout::LayoutOf;\n use type_of::LayoutLlvmExt;\n use super::FunctionCx;\n \n-pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n+pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector<mir::Local> {\n     let mir = fx.mir;\n     let mut analyzer = LocalAnalyzer::new(fx);\n \n@@ -54,7 +54,7 @@ pub fn non_ssa_locals<'a, 'tcx>(fx: &FunctionCx<'a, 'tcx>) -> BitVector {\n struct LocalAnalyzer<'mir, 'a: 'mir, 'tcx: 'a> {\n     fx: &'mir FunctionCx<'a, 'tcx>,\n     dominators: Dominators<mir::BasicBlock>,\n-    non_ssa_locals: BitVector,\n+    non_ssa_locals: BitVector<mir::Local>,\n     // The location of the first visited direct assignment to each\n     // local, or an invalid location (out of bounds `block` index).\n     first_assignment: IndexVec<mir::Local, Location>\n@@ -90,7 +90,7 @@ impl<'mir, 'a, 'tcx> LocalAnalyzer<'mir, 'a, 'tcx> {\n \n     fn not_ssa(&mut self, local: mir::Local) {\n         debug!(\"marking {:?} as non-SSA\", local);\n-        self.non_ssa_locals.insert(local.index());\n+        self.non_ssa_locals.insert(local);\n     }\n \n     fn assign(&mut self, local: mir::Local, location: Location) {"}, {"sha": "312939408c62cf0f9badab6166f6570383802120", "filename": "src/librustc_codegen_llvm/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -268,7 +268,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n                 let debug_scope = fx.scopes[decl.visibility_scope];\n                 let dbg = debug_scope.is_valid() && bx.sess().opts.debuginfo == FullDebugInfo;\n \n-                if !memory_locals.contains(local.index()) && !dbg {\n+                if !memory_locals.contains(local) && !dbg {\n                     debug!(\"alloc: {:?} ({}) -> operand\", local, name);\n                     return LocalRef::new_operand(bx.cx, layout);\n                 }\n@@ -291,7 +291,7 @@ pub fn codegen_mir<'a, 'tcx: 'a>(\n                     debug!(\"alloc: {:?} (return place) -> place\", local);\n                     let llretptr = llvm::get_param(llfn, 0);\n                     LocalRef::Place(PlaceRef::new_sized(llretptr, layout, layout.align))\n-                } else if memory_locals.contains(local.index()) {\n+                } else if memory_locals.contains(local) {\n                     debug!(\"alloc: {:?} -> place\", local);\n                     LocalRef::Place(PlaceRef::alloca(&bx, layout, &format!(\"{:?}\", local)))\n                 } else {\n@@ -415,7 +415,7 @@ fn create_funclets<'a, 'tcx>(\n fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                             fx: &FunctionCx<'a, 'tcx>,\n                             scopes: &IndexVec<mir::SourceScope, debuginfo::MirDebugScope>,\n-                            memory_locals: &BitVector)\n+                            memory_locals: &BitVector<mir::Local>)\n                             -> Vec<LocalRef<'tcx>> {\n     let mir = fx.mir;\n     let tcx = bx.tcx();\n@@ -487,7 +487,7 @@ fn arg_local_refs<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n             llarg_idx += 1;\n         }\n \n-        if arg_scope.is_none() && !memory_locals.contains(local.index()) {\n+        if arg_scope.is_none() && !memory_locals.contains(local) {\n             // We don't have to cast or keep the argument in the alloca.\n             // FIXME(eddyb): We should figure out how to use llvm.dbg.value instead\n             // of putting everything in allocas just so we can use llvm.dbg.declare."}, {"sha": "04d6cb5e2a6d24ce87f57bdc0ac309fe42cd63e6", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 140, "deletions": 55, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -17,16 +17,18 @@ const WORD_BITS: usize = 128;\n \n /// A very simple BitVector type.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct BitVector {\n+pub struct BitVector<C: Idx> {\n     data: Vec<Word>,\n+    marker: PhantomData<C>,\n }\n \n-impl BitVector {\n+impl<C: Idx> BitVector<C> {\n     #[inline]\n-    pub fn new(num_bits: usize) -> BitVector {\n+    pub fn new(num_bits: usize) -> BitVector<C> {\n         let num_words = words(num_bits);\n         BitVector {\n             data: vec![0; num_words],\n+            marker: PhantomData,\n         }\n     }\n \n@@ -41,15 +43,30 @@ impl BitVector {\n         self.data.iter().map(|e| e.count_ones() as usize).sum()\n     }\n \n+    /// True if `self` contains the bit `bit`.\n     #[inline]\n-    pub fn contains(&self, bit: usize) -> bool {\n+    pub fn contains(&self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         (self.data[word] & mask) != 0\n     }\n \n+    /// True if `self` contains all the bits in `other`.\n+    ///\n+    /// The two vectors must have the same length.\n+    #[inline]\n+    pub fn contains_all(&self, other: &BitVector<C>) -> bool {\n+        assert_eq!(self.data.len(), other.data.len());\n+        self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n+    }\n+\n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.data.iter().all(|a| *a == 0)\n+    }\n+\n     /// Returns true if the bit has changed.\n     #[inline]\n-    pub fn insert(&mut self, bit: usize) -> bool {\n+    pub fn insert(&mut self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n@@ -58,9 +75,16 @@ impl BitVector {\n         new_value != value\n     }\n \n+    /// Sets all bits to true.\n+    pub fn insert_all(&mut self) {\n+        for data in &mut self.data {\n+            *data = u128::max_value();\n+        }\n+    }\n+\n     /// Returns true if the bit has changed.\n     #[inline]\n-    pub fn remove(&mut self, bit: usize) -> bool {\n+    pub fn remove(&mut self, bit: C) -> bool {\n         let (word, mask) = word_mask(bit);\n         let data = &mut self.data[word];\n         let value = *data;\n@@ -70,7 +94,7 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn merge(&mut self, all: &BitVector) -> bool {\n+    pub fn merge(&mut self, all: &BitVector<C>) -> bool {\n         assert!(self.data.len() == all.data.len());\n         let mut changed = false;\n         for (i, j) in self.data.iter_mut().zip(&all.data) {\n@@ -84,7 +108,7 @@ impl BitVector {\n     }\n \n     #[inline]\n-    pub fn grow(&mut self, num_bits: usize) {\n+    pub fn grow(&mut self, num_bits: C) {\n         let num_words = words(num_bits);\n         if self.data.len() < num_words {\n             self.data.resize(num_words, 0)\n@@ -93,24 +117,26 @@ impl BitVector {\n \n     /// Iterates over indexes of set bits in a sorted order\n     #[inline]\n-    pub fn iter<'a>(&'a self) -> BitVectorIter<'a> {\n+    pub fn iter<'a>(&'a self) -> BitVectorIter<'a, C> {\n         BitVectorIter {\n             iter: self.data.iter(),\n             current: 0,\n             idx: 0,\n+            marker: PhantomData,\n         }\n     }\n }\n \n-pub struct BitVectorIter<'a> {\n+pub struct BitVectorIter<'a, C: Idx> {\n     iter: ::std::slice::Iter<'a, Word>,\n     current: Word,\n     idx: usize,\n+    marker: PhantomData<C>\n }\n \n-impl<'a> Iterator for BitVectorIter<'a> {\n-    type Item = usize;\n-    fn next(&mut self) -> Option<usize> {\n+impl<'a, C: Idx> Iterator for BitVectorIter<'a, C> {\n+    type Item = C;\n+    fn next(&mut self) -> Option<C> {\n         while self.current == 0 {\n             self.current = if let Some(&i) = self.iter.next() {\n                 if i == 0 {\n@@ -128,7 +154,7 @@ impl<'a> Iterator for BitVectorIter<'a> {\n         self.current >>= offset;\n         self.current >>= 1; // shift otherwise overflows for 0b1000_0000_\u2026_0000\n         self.idx += offset + 1;\n-        return Some(self.idx - 1);\n+        return Some(C::new(self.idx - 1));\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -137,8 +163,8 @@ impl<'a> Iterator for BitVectorIter<'a> {\n     }\n }\n \n-impl FromIterator<bool> for BitVector {\n-    fn from_iter<I>(iter: I) -> BitVector\n+impl<C: Idx> FromIterator<bool> for BitVector<C> {\n+    fn from_iter<I>(iter: I) -> BitVector<C>\n     where\n         I: IntoIterator<Item = bool>,\n     {\n@@ -150,10 +176,10 @@ impl FromIterator<bool> for BitVector {\n         let mut bv = BitVector::new(len);\n         for (idx, val) in iter.enumerate() {\n             if idx > len {\n-                bv.grow(idx);\n+                bv.grow(C::new(idx));\n             }\n             if val {\n-                bv.insert(idx);\n+                bv.insert(C::new(idx));\n             }\n         }\n \n@@ -165,25 +191,28 @@ impl FromIterator<bool> for BitVector {\n /// one gigantic bitvector. In other words, it is as if you have\n /// `rows` bitvectors, each of length `columns`.\n #[derive(Clone, Debug)]\n-pub struct BitMatrix {\n+pub struct BitMatrix<R: Idx, C: Idx> {\n     columns: usize,\n     vector: Vec<Word>,\n+    phantom: PhantomData<(R, C)>,\n }\n \n-impl BitMatrix {\n+impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Create a new `rows x columns` matrix, initially empty.\n-    pub fn new(rows: usize, columns: usize) -> BitMatrix {\n+    pub fn new(rows: usize, columns: usize) -> BitMatrix<R, C> {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of words.\n         let words_per_row = words(columns);\n         BitMatrix {\n             columns,\n             vector: vec![0; rows * words_per_row],\n+            phantom: PhantomData,\n         }\n     }\n \n     /// The range of bits for a given row.\n-    fn range(&self, row: usize) -> (usize, usize) {\n+    fn range(&self, row: R) -> (usize, usize) {\n+        let row = row.index();\n         let words_per_row = words(self.columns);\n         let start = row * words_per_row;\n         (start, start + words_per_row)\n@@ -193,7 +222,7 @@ impl BitMatrix {\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n-    pub fn add(&mut self, row: usize, column: usize) -> bool {\n+    pub fn add(&mut self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n         let vector = &mut self.vector[..];\n@@ -207,7 +236,7 @@ impl BitMatrix {\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n-    pub fn contains(&self, row: usize, column: usize) -> bool {\n+    pub fn contains(&self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n         let (word, mask) = word_mask(column);\n         (self.vector[start + word] & mask) != 0\n@@ -217,7 +246,7 @@ impl BitMatrix {\n     /// is an O(n) operation where `n` is the number of elements\n     /// (somewhat independent from the actual size of the\n     /// intersection, in particular).\n-    pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n+    pub fn intersection(&self, a: R, b: R) -> Vec<C> {\n         let (a_start, a_end) = self.range(a);\n         let (b_start, b_end) = self.range(b);\n         let mut result = Vec::with_capacity(self.columns);\n@@ -228,7 +257,7 @@ impl BitMatrix {\n                     break;\n                 }\n                 if v & 0x1 != 0 {\n-                    result.push(base * WORD_BITS + bit);\n+                    result.push(C::new(base * WORD_BITS + bit));\n                 }\n                 v >>= 1;\n             }\n@@ -243,7 +272,7 @@ impl BitMatrix {\n     /// you have an edge `write -> read`, because in that case\n     /// `write` can reach everything that `read` can (and\n     /// potentially more).\n-    pub fn merge(&mut self, read: usize, write: usize) -> bool {\n+    pub fn merge(&mut self, read: R, write: R) -> bool {\n         let (read_start, read_end) = self.range(read);\n         let (write_start, write_end) = self.range(write);\n         let vector = &mut self.vector[..];\n@@ -259,12 +288,13 @@ impl BitMatrix {\n \n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n-    pub fn iter<'a>(&'a self, row: usize) -> BitVectorIter<'a> {\n+    pub fn iter<'a>(&'a self, row: R) -> BitVectorIter<'a, C> {\n         let (start, end) = self.range(row);\n         BitVectorIter {\n             iter: self.vector[start..end].iter(),\n             current: 0,\n             idx: 0,\n+            marker: PhantomData,\n         }\n     }\n }\n@@ -278,8 +308,7 @@ where\n     C: Idx,\n {\n     columns: usize,\n-    vector: IndexVec<R, BitVector>,\n-    marker: PhantomData<C>,\n+    vector: IndexVec<R, BitVector<C>>,\n }\n \n impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n@@ -288,27 +317,30 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         Self {\n             columns,\n             vector: IndexVec::new(),\n-            marker: PhantomData,\n         }\n     }\n \n+    fn ensure_row(&mut self, row: R) {\n+        let columns = self.columns;\n+        self.vector\n+            .ensure_contains_elem(row, || BitVector::new(columns));\n+    }\n+\n     /// Sets the cell at `(row, column)` to true. Put another way, insert\n     /// `column` to the bitset for `row`.\n     ///\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn add(&mut self, row: R, column: C) -> bool {\n-        let columns = self.columns;\n-        self.vector\n-            .ensure_contains_elem(row, || BitVector::new(columns));\n-        self.vector[row].insert(column.index())\n+        self.ensure_row(row);\n+        self.vector[row].insert(column)\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n     /// the matrix cell at `(row, column)` true?  Put yet another way,\n     /// if the matrix represents (transitive) reachability, can\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: C) -> bool {\n-        self.vector.get(row).map_or(false, |r| r.contains(column.index()))\n+        self.vector.get(row).map_or(false, |r| r.contains(column))\n     }\n \n     /// Add the bits from row `read` to the bits from row `write`,\n@@ -323,53 +355,64 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n             return false;\n         }\n \n-        let columns = self.columns;\n-        self.vector\n-            .ensure_contains_elem(write, || BitVector::new(columns));\n+        self.ensure_row(write);\n         let (bitvec_read, bitvec_write) = self.vector.pick2_mut(read, write);\n         bitvec_write.merge(bitvec_read)\n     }\n \n     /// Merge a row, `from`, into the `into` row.\n-    pub fn merge_into(&mut self, into: R, from: &BitVector) -> bool {\n-        let columns = self.columns;\n-        self.vector\n-            .ensure_contains_elem(into, || BitVector::new(columns));\n+    pub fn merge_into(&mut self, into: R, from: &BitVector<C>) -> bool {\n+        self.ensure_row(into);\n         self.vector[into].merge(from)\n     }\n \n+    /// Add all bits to the given row.\n+    pub fn add_all(&mut self, row: R) {\n+        self.ensure_row(row);\n+        self.vector[row].insert_all();\n+    }\n+\n     /// Number of elements in the matrix.\n     pub fn len(&self) -> usize {\n         self.vector.len()\n     }\n \n+    pub fn rows(&self) -> impl Iterator<Item = R> {\n+        self.vector.indices()\n+    }\n+\n     /// Iterates through all the columns set to true in a given row of\n     /// the matrix.\n     pub fn iter<'a>(&'a self, row: R) -> impl Iterator<Item = C> + 'a {\n-        self.vector.get(row).into_iter().flat_map(|r| r.iter().map(|n| C::new(n)))\n+        self.vector.get(row).into_iter().flat_map(|r| r.iter())\n     }\n \n     /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector)> + 'a {\n+    pub fn iter_enumerated<'a>(&'a self) -> impl Iterator<Item = (R, &'a BitVector<C>)> + 'a {\n         self.vector.iter_enumerated()\n     }\n+\n+    pub fn row(&self, row: R) -> Option<&BitVector<C>> {\n+        self.vector.get(row)\n+    }\n }\n \n #[inline]\n-fn words(elements: usize) -> usize {\n-    (elements + WORD_BITS - 1) / WORD_BITS\n+fn words<C: Idx>(elements: C) -> usize {\n+    (elements.index() + WORD_BITS - 1) / WORD_BITS\n }\n \n #[inline]\n-fn word_mask(index: usize) -> (usize, Word) {\n+fn word_mask<C: Idx>(index: C) -> (usize, Word) {\n+    let index = index.index();\n     let word = index / WORD_BITS;\n     let mask = 1 << (index % WORD_BITS);\n     (word, mask)\n }\n \n #[test]\n fn bitvec_iter_works() {\n-    let mut bitvec = BitVector::new(100);\n+    let mut bitvec: BitVector<usize> = BitVector::new(100);\n     bitvec.insert(1);\n     bitvec.insert(10);\n     bitvec.insert(19);\n@@ -387,7 +430,7 @@ fn bitvec_iter_works() {\n \n #[test]\n fn bitvec_iter_works_2() {\n-    let mut bitvec = BitVector::new(319);\n+    let mut bitvec: BitVector<usize> = BitVector::new(319);\n     bitvec.insert(0);\n     bitvec.insert(127);\n     bitvec.insert(191);\n@@ -398,8 +441,8 @@ fn bitvec_iter_works_2() {\n \n #[test]\n fn union_two_vecs() {\n-    let mut vec1 = BitVector::new(65);\n-    let mut vec2 = BitVector::new(65);\n+    let mut vec1: BitVector<usize> = BitVector::new(65);\n+    let mut vec2: BitVector<usize> = BitVector::new(65);\n     assert!(vec1.insert(3));\n     assert!(!vec1.insert(3));\n     assert!(vec2.insert(5));\n@@ -415,7 +458,7 @@ fn union_two_vecs() {\n \n #[test]\n fn grow() {\n-    let mut vec1 = BitVector::new(65);\n+    let mut vec1: BitVector<usize> = BitVector::new(65);\n     for index in 0..65 {\n         assert!(vec1.insert(index));\n         assert!(!vec1.insert(index));\n@@ -441,7 +484,7 @@ fn grow() {\n \n #[test]\n fn matrix_intersection() {\n-    let mut vec1 = BitMatrix::new(200, 200);\n+    let mut vec1: BitMatrix<usize, usize> = BitMatrix::new(200, 200);\n \n     // (*) Elements reachable from both 2 and 65.\n \n@@ -472,7 +515,49 @@ fn matrix_intersection() {\n \n #[test]\n fn matrix_iter() {\n-    let mut matrix = BitMatrix::new(64, 100);\n+    let mut matrix: BitMatrix<usize, usize> = BitMatrix::new(64, 100);\n+    matrix.add(3, 22);\n+    matrix.add(3, 75);\n+    matrix.add(2, 99);\n+    matrix.add(4, 0);\n+    matrix.merge(3, 5);\n+\n+    let expected = [99];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(2) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(3) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [0];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(4) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+\n+    let expected = [22, 75];\n+    let mut iter = expected.iter();\n+    for i in matrix.iter(5) {\n+        let j = *iter.next().unwrap();\n+        assert_eq!(i, j);\n+    }\n+    assert!(iter.next().is_none());\n+}\n+\n+#[test]\n+fn sparse_matrix_iter() {\n+    let mut matrix: SparseBitMatrix<usize, usize> = SparseBitMatrix::new(100);\n     matrix.add(3, 22);\n     matrix.add(3, 75);\n     matrix.add(2, 99);"}, {"sha": "dbfc09116bbaa281bbe5c076ecc21bdf7422c80f", "filename": "src/librustc_data_structures/graph/implementation/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fgraph%2Fimplementation%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -348,7 +348,7 @@ where\n {\n     graph: &'g Graph<N, E>,\n     stack: Vec<NodeIndex>,\n-    visited: BitVector,\n+    visited: BitVector<usize>,\n     direction: Direction,\n }\n "}, {"sha": "c358f2f852e18bb3e88e1a51caf6a69b5b30b975", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -25,7 +25,13 @@ use rustc_serialize as serialize;\n /// (purpose: avoid mixing indexes for different bitvector domains.)\n pub trait Idx: Copy + 'static + Ord + Debug + Hash {\n     fn new(idx: usize) -> Self;\n+\n     fn index(self) -> usize;\n+\n+    fn increment_by(&mut self, amount: usize) {\n+        let v = self.index() + amount;\n+        *self = Self::new(v);\n+    }\n }\n \n impl Idx for usize {\n@@ -89,6 +95,35 @@ macro_rules! newtype_index {\n             }\n         }\n \n+        impl ::std::iter::Step for $type {\n+            fn steps_between(start: &Self, end: &Self) -> Option<usize> {\n+                <usize as ::std::iter::Step>::steps_between(\n+                    &Idx::index(*start),\n+                    &Idx::index(*end),\n+                )\n+            }\n+\n+            fn replace_one(&mut self) -> Self {\n+                ::std::mem::replace(self, Self::new(1))\n+            }\n+\n+            fn replace_zero(&mut self) -> Self {\n+                ::std::mem::replace(self, Self::new(0))\n+            }\n+\n+            fn add_one(&self) -> Self {\n+                Self::new(Idx::index(*self) + 1)\n+            }\n+\n+            fn sub_one(&self) -> Self {\n+                Self::new(Idx::index(*self) - 1)\n+            }\n+\n+            fn add_usize(&self, u: usize) -> Option<Self> {\n+                Idx::index(*self).checked_add(u).map(Self::new)\n+            }\n+        }\n+\n         newtype_index!(\n             @handle_debug\n             @derives      [$($derives,)*]\n@@ -475,8 +510,8 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn swap(&mut self, a: usize, b: usize) {\n-        self.raw.swap(a, b)\n+    pub fn swap(&mut self, a: I, b: I) {\n+        self.raw.swap(a.index(), b.index())\n     }\n \n     #[inline]"}, {"sha": "a8124fb7c5b622bdbed52ca8f2434598f178fcbd", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -39,7 +39,7 @@ pub struct TransitiveRelation<T: Clone + Debug + Eq + Hash> {\n     // are added with new elements. Perhaps better would be to ask the\n     // user for a batch of edges to minimize this effect, but I\n     // already wrote the code this way. :P -nmatsakis\n-    closure: Lock<Option<BitMatrix>>,\n+    closure: Lock<Option<BitMatrix<usize, usize>>>,\n }\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, Debug)]\n@@ -354,7 +354,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n     }\n \n     fn with_closure<OP, R>(&self, op: OP) -> R\n-        where OP: FnOnce(&BitMatrix) -> R\n+        where OP: FnOnce(&BitMatrix<usize, usize>) -> R\n     {\n         let mut closure_cell = self.closure.borrow_mut();\n         let mut closure = closure_cell.take();\n@@ -366,7 +366,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n         result\n     }\n \n-    fn compute_closure(&self) -> BitMatrix {\n+    fn compute_closure(&self) -> BitMatrix<usize, usize> {\n         let mut matrix = BitMatrix::new(self.elements.len(),\n                                         self.elements.len());\n         let mut changed = true;\n@@ -396,7 +396,7 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n /// - Input: `[a, b, x]`. Output: `[a, x]`.\n /// - Input: `[b, a, x]`. Output: `[b, a, x]`.\n /// - Input: `[a, x, b, y]`. Output: `[a, x]`.\n-fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n+fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix<usize, usize>) {\n     let mut i = 0;\n     while i < candidates.len() {\n         let candidate_i = candidates[i];"}, {"sha": "457499ded565713dfea9bf9a08efed09b935f6bc", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -12,19 +12,19 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n-use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::region_infer::values::LivenessValues;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n use rustc::mir::{Local, Statement, Terminator};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts};\n+use rustc::ty::{self, CanonicalTy, ClosureSubsts, GeneratorSubsts, RegionVid};\n \n pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &mut RegionInferenceContext<'tcx>,\n+    liveness_constraints: &mut LivenessValues<RegionVid>,\n     all_facts: &mut Option<AllFacts>,\n     location_table: &LocationTable,\n     mir: &Mir<'tcx>,\n@@ -33,7 +33,7 @@ pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n     let mut cg = ConstraintGeneration {\n         borrow_set,\n         infcx,\n-        regioncx,\n+        liveness_constraints,\n         location_table,\n         all_facts,\n     };\n@@ -48,7 +48,7 @@ struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n     infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n     all_facts: &'cg mut Option<AllFacts>,\n     location_table: &'cg LocationTable,\n-    regioncx: &'cg mut RegionInferenceContext<'tcx>,\n+    liveness_constraints: &'cg mut LivenessValues<RegionVid>,\n     borrow_set: &'cg BorrowSet<'tcx>,\n }\n \n@@ -202,7 +202,7 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n             .tcx\n             .for_each_free_region(&live_ty, |live_region| {\n                 let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_element(vid, location);\n+                self.liveness_constraints.add_element(vid, location);\n             });\n     }\n }"}, {"sha": "0039958b6b14d3e724948fd7b6e2b77233e13fb9", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -54,7 +54,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             borrow_region_vid\n         );\n \n-        let region_sub = regioncx.find_constraint(borrow_region_vid, context.loc);\n+        let region_sub = regioncx.find_sub_region_live_at(borrow_region_vid, context.loc);\n \n         debug!(\n             \"explain_why_borrow_contains_point: region_sub={:?}\","}, {"sha": "63d5de4f2e525f0c8c956ba82d9368f2475adcaa", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -104,7 +104,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n         None\n     };\n \n-    let elements = &Rc::new(RegionValueElements::new(mir, universal_regions.len()));\n+    let elements = &Rc::new(RegionValueElements::new(mir));\n \n     // Run the MIR type-checker.\n     let liveness_map = NllLivenessMap::compute(&mir);\n@@ -136,10 +136,20 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // base constraints generated by the type-check.\n     let var_origins = infcx.take_region_var_origins();\n     let MirTypeckRegionConstraints {\n-        liveness_constraints,\n+        mut liveness_constraints,\n         outlives_constraints,\n         type_tests,\n     } = constraint_sets;\n+\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut liveness_constraints,\n+        &mut all_facts,\n+        location_table,\n+        &mir,\n+        borrow_set,\n+    );\n+\n     let mut regioncx = RegionInferenceContext::new(\n         var_origins,\n         universal_regions,\n@@ -151,14 +161,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     );\n \n     // Generate various additional constraints.\n-    constraint_generation::generate_constraints(\n-        infcx,\n-        &mut regioncx,\n-        &mut all_facts,\n-        location_table,\n-        &mir,\n-        borrow_set,\n-    );\n     invalidation::generate_invalidates(\n         infcx,\n         &mut all_facts,"}, {"sha": "88b34c767324c2d55b38ffb6fd344f5ea388b489", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -13,6 +13,7 @@\n //! state of region inference. This code handles emitting the region\n //! context internal state.\n \n+use rustc::infer::NLLRegionVariableOrigin;\n use std::io::{self, Write};\n use super::{OutlivesConstraint, RegionInferenceContext};\n \n@@ -27,8 +28,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         writeln!(out, \"| Free Region Mapping\")?;\n \n         for region in self.regions() {\n-            if self.definitions[region].is_universal {\n-                let classification = self.universal_regions.region_classification(region).unwrap();\n+            if let NLLRegionVariableOrigin::FreeRegion = self.definitions[region].origin {\n+                let classification = self\n+                    .universal_regions\n+                    .region_classification(region)\n+                    .unwrap();\n                 let outlived_by = self.universal_regions.regions_outlived_by(region);\n                 writeln!(\n                     out,\n@@ -47,9 +51,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for region in self.regions() {\n             writeln!(\n                 out,\n-                \"| {r:rw$} | {v}\",\n+                \"| {r:rw$} | {ui:4?} | {v}\",\n                 r = format!(\"{:?}\", region),\n                 rw = REGION_WIDTH,\n+                ui = self.region_universe(region),\n                 v = self.region_value_str(region),\n             )?;\n         }"}, {"sha": "1b540ef74be49e05830e28c9635e08e96cdba54b", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 246, "deletions": 188, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -8,17 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc::infer::InferCtxt;\n use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::Diagnostic;\n+use std::collections::VecDeque;\n use std::fmt;\n use syntax_pos::Span;\n \n@@ -28,7 +27,7 @@ mod var_name;\n /// Constraints that are considered interesting can be categorized to\n /// determine why they are interesting. Order of variants indicates\n /// sort order of the category, thereby influencing diagnostic output.\n-#[derive(Debug, Eq, PartialEq, PartialOrd, Ord)]\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]\n enum ConstraintCategory {\n     Cast,\n     Assignment,\n@@ -43,77 +42,178 @@ enum ConstraintCategory {\n impl fmt::Display for ConstraintCategory {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self {\n-            ConstraintCategory::Assignment |\n-            ConstraintCategory::AssignmentToUpvar => write!(f, \"assignment\"),\n+            ConstraintCategory::Assignment | ConstraintCategory::AssignmentToUpvar => {\n+                write!(f, \"assignment\")\n+            }\n             ConstraintCategory::Return => write!(f, \"return\"),\n             ConstraintCategory::Cast => write!(f, \"cast\"),\n-            ConstraintCategory::CallArgument |\n-            ConstraintCategory::CallArgumentToUpvar => write!(f, \"argument\"),\n+            ConstraintCategory::CallArgument | ConstraintCategory::CallArgumentToUpvar => {\n+                write!(f, \"argument\")\n+            }\n             _ => write!(f, \"free region\"),\n         }\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum Trace {\n+    StartRegion,\n+    FromConstraint(ConstraintIndex),\n+    NotVisited,\n+}\n+\n impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Tries to find the best constraint to blame for the fact that\n+    /// `R: from_region`, where `R` is some region that meets\n+    /// `target_test`. This works by following the constraint graph,\n+    /// creating a constraint path that forces `R` to outlive\n+    /// `from_region`, and then finding the best choices within that\n+    /// path to blame.\n+    fn best_blame_constraint(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        from_region: RegionVid,\n+        target_test: impl Fn(RegionVid) -> bool,\n+    ) -> (ConstraintCategory, Span, RegionVid) {\n+        debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n+\n+        // Find all paths\n+        let (path, target_region) = self\n+            .find_constraint_paths_between_regions(from_region, target_test)\n+            .unwrap();\n+        debug!(\n+            \"best_blame_constraint: path={:#?}\",\n+            path.iter()\n+                .map(|&ci| format!(\n+                    \"{:?}: {:?} ({:?}: {:?})\",\n+                    ci,\n+                    &self.constraints[ci],\n+                    self.constraint_sccs.scc(self.constraints[ci].sup),\n+                    self.constraint_sccs.scc(self.constraints[ci].sub),\n+                ))\n+                .collect::<Vec<_>>()\n+        );\n+\n+        // Classify each of the constraints along the path.\n+        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path\n+            .iter()\n+            .map(|&index| self.classify_constraint(index, mir))\n+            .collect();\n+        debug!(\n+            \"best_blame_constraint: categorized_path={:#?}\",\n+            categorized_path\n+        );\n+\n+        // To find the best span to cite, we first try to look for the\n+        // final constraint that is interesting and where the `sup` is\n+        // not unified with the ultimate target region. The reason\n+        // for this is that we have a chain of constraints that lead\n+        // from the source to the target region, something like:\n+        //\n+        //    '0: '1 ('0 is the source)\n+        //    '1: '2\n+        //    '2: '3\n+        //    '3: '4\n+        //    '4: '5\n+        //    '5: '6 ('6 is the target)\n+        //\n+        // Some of those regions are unified with `'6` (in the same\n+        // SCC).  We want to screen those out. After that point, the\n+        // \"closest\" constraint we have to the end is going to be the\n+        // most likely to be the point where the value escapes -- but\n+        // we still want to screen for an \"interesting\" point to\n+        // highlight (e.g., a call site or something).\n+        let target_scc = self.constraint_sccs.scc(target_region);\n+        let best_choice = (0..path.len()).rev().find(|&i| {\n+            let constraint = &self.constraints[path[i]];\n+\n+            let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n+            if constraint_sup_scc == target_scc {\n+                return false;\n+            }\n+\n+            match categorized_path[i].0 {\n+                ConstraintCategory::Boring => false,\n+                _ => true,\n+            }\n+        });\n+        if let Some(i) = best_choice {\n+            let (category, span) = categorized_path[i];\n+            return (category, span, target_region);\n+        }\n+\n+        // If that search fails, that is.. unusual. Maybe everything\n+        // is in the same SCC or something. In that case, find what\n+        // appears to be the most interesting point to report to the\n+        // user via an even more ad-hoc guess.\n+        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n+        debug!(\"best_blame_constraint: sorted_path={:#?}\", categorized_path);\n+\n+        let &(category, span) = categorized_path.first().unwrap();\n+\n+        (category, span, target_region)\n+    }\n+\n     /// Walks the graph of constraints (where `'a: 'b` is considered\n     /// an edge `'a -> 'b`) to find all paths from `from_region` to\n     /// `to_region`. The paths are accumulated into the vector\n     /// `results`. The paths are stored as a series of\n     /// `ConstraintIndex` values -- in other words, a list of *edges*.\n+    ///\n+    /// Returns: a series of constraints as well as the region `R`\n+    /// that passed the target test.\n     fn find_constraint_paths_between_regions(\n         &self,\n         from_region: RegionVid,\n         target_test: impl Fn(RegionVid) -> bool,\n-    ) -> Vec<Vec<ConstraintIndex>> {\n-        let mut results = vec![];\n-        self.find_constraint_paths_between_regions_helper(\n-            from_region,\n-            from_region,\n-            &target_test,\n-            &mut FxHashSet::default(),\n-            &mut vec![],\n-            &mut results,\n-        );\n-        results\n-    }\n+    ) -> Option<(Vec<ConstraintIndex>, RegionVid)> {\n+        let mut context = IndexVec::from_elem(Trace::NotVisited, &self.definitions);\n+        context[from_region] = Trace::StartRegion;\n+\n+        // Use a deque so that we do a breadth-first search. We will\n+        // stop at the first match, which ought to be the shortest\n+        // path (fewest constraints).\n+        let mut deque = VecDeque::new();\n+        deque.push_back(from_region);\n+\n+        while let Some(r) = deque.pop_front() {\n+            // Check if we reached the region we were looking for. If so,\n+            // we can reconstruct the path that led to it and return it.\n+            if target_test(r) {\n+                let mut result = vec![];\n+                let mut p = r;\n+                loop {\n+                    match context[p] {\n+                        Trace::NotVisited => {\n+                            bug!(\"found unvisited region {:?} on path to {:?}\", p, r)\n+                        }\n+                        Trace::FromConstraint(c) => {\n+                            result.push(c);\n+                            p = self.constraints[c].sup;\n+                        }\n \n-    /// Helper for `find_constraint_paths_between_regions`.\n-    fn find_constraint_paths_between_regions_helper(\n-        &self,\n-        from_region: RegionVid,\n-        current_region: RegionVid,\n-        target_test: &impl Fn(RegionVid) -> bool,\n-        visited: &mut FxHashSet<RegionVid>,\n-        stack: &mut Vec<ConstraintIndex>,\n-        results: &mut Vec<Vec<ConstraintIndex>>,\n-    ) {\n-        // Check if we already visited this region.\n-        if !visited.insert(current_region) {\n-            return;\n-        }\n+                        Trace::StartRegion => {\n+                            result.reverse();\n+                            return Some((result, r));\n+                        }\n+                    }\n+                }\n+            }\n \n-        // Check if we reached the region we were looking for.\n-        if target_test(current_region) {\n-            if !stack.is_empty() {\n-                assert_eq!(self.constraints[stack[0]].sup, from_region);\n-                results.push(stack.clone());\n+            // Otherwise, walk over the outgoing constraints and\n+            // enqueue any regions we find, keeping track of how we\n+            // reached them.\n+            for constraint in self.constraint_graph.outgoing_edges(r) {\n+                assert_eq!(self.constraints[constraint].sup, r);\n+                let sub_region = self.constraints[constraint].sub;\n+                if let Trace::NotVisited = context[sub_region] {\n+                    context[sub_region] = Trace::FromConstraint(constraint);\n+                    deque.push_back(sub_region);\n+                }\n             }\n-            return;\n         }\n \n-        for constraint in self.constraint_graph.outgoing_edges(current_region) {\n-            assert_eq!(self.constraints[constraint].sup, current_region);\n-            stack.push(constraint);\n-            self.find_constraint_paths_between_regions_helper(\n-                from_region,\n-                self.constraints[constraint].sub,\n-                target_test,\n-                visited,\n-                stack,\n-                results,\n-            );\n-            stack.pop();\n-        }\n+        None\n     }\n \n     /// This function will return true if a constraint is interesting and false if a constraint\n@@ -136,19 +236,24 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         index: ConstraintIndex,\n         mir: &Mir<'tcx>,\n-        _infcx: &InferCtxt<'_, '_, 'tcx>,\n     ) -> (ConstraintCategory, Span) {\n         let constraint = self.constraints[index];\n         debug!(\"classify_constraint: constraint={:?}\", constraint);\n         let span = constraint.locations.span(mir);\n-        let location = constraint.locations.from_location().unwrap_or(Location::START);\n+        let location = constraint\n+            .locations\n+            .from_location()\n+            .unwrap_or(Location::START);\n \n         if !self.constraint_is_interesting(index) {\n             return (ConstraintCategory::Boring, span);\n         }\n \n         let data = &mir[location.block];\n-        debug!(\"classify_constraint: location={:?} data={:?}\", location, data);\n+        debug!(\n+            \"classify_constraint: location={:?} data={:?}\",\n+            location, data\n+        );\n         let category = if location.statement_index == data.statements.len() {\n             if let Some(ref terminator) = data.terminator {\n                 debug!(\"classify_constraint: terminator.kind={:?}\", terminator.kind);\n@@ -171,8 +276,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     } else {\n                         match rvalue {\n                             Rvalue::Cast(..) => ConstraintCategory::Cast,\n-                            Rvalue::Use(..) |\n-                            Rvalue::Aggregate(..) => ConstraintCategory::Assignment,\n+                            Rvalue::Use(..) | Rvalue::Aggregate(..) => {\n+                                ConstraintCategory::Assignment\n+                            }\n                             _ => ConstraintCategory::Other,\n                         }\n                     }\n@@ -199,61 +305,56 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        blame_span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n+        let (category, span, _) = self.best_blame_constraint(mir, fr, |r| r == outlived_fr);\n+\n+        // Check if we can use one of the \"nice region errors\".\n         if let (Some(f), Some(o)) = (self.to_error_region(fr), self.to_error_region(outlived_fr)) {\n             let tables = infcx.tcx.typeck_tables_of(mir_def_id);\n-            let nice = NiceRegionError::new_from_span(infcx.tcx, blame_span, o, f, Some(tables));\n+            let nice = NiceRegionError::new_from_span(infcx.tcx, span, o, f, Some(tables));\n             if let Some(_error_reported) = nice.try_report() {\n                 return;\n             }\n         }\n \n-        // Find all paths\n-        let constraint_paths = self.find_constraint_paths_between_regions(fr, |r| r == outlived_fr);\n-        debug!(\"report_error: constraint_paths={:#?}\", constraint_paths);\n-\n-        // Find the shortest such path.\n-        let path = constraint_paths.iter().min_by_key(|p| p.len()).unwrap();\n-        debug!(\"report_error: shortest_path={:?}\", path);\n-\n-        // Classify each of the constraints along the path.\n-        let mut categorized_path: Vec<(ConstraintCategory, Span)> = path.iter()\n-            .map(|&index| self.classify_constraint(index, mir, infcx))\n-            .collect();\n-        debug!(\"report_error: categorized_path={:?}\", categorized_path);\n-\n-        // Find what appears to be the most interesting path to report to the user.\n-        categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n-        debug!(\"report_error: sorted_path={:?}\", categorized_path);\n-\n-        // Get a span\n-        let (category, span) = categorized_path.first().unwrap();\n-\n         let category = match (\n             category,\n             self.universal_regions.is_local_free_region(fr),\n             self.universal_regions.is_local_free_region(outlived_fr),\n         ) {\n-            (ConstraintCategory::Assignment, true, false) =>\n-                &ConstraintCategory::AssignmentToUpvar,\n-            (ConstraintCategory::CallArgument, true, false) =>\n-                &ConstraintCategory::CallArgumentToUpvar,\n+            (ConstraintCategory::Assignment, true, false) => ConstraintCategory::AssignmentToUpvar,\n+            (ConstraintCategory::CallArgument, true, false) => {\n+                ConstraintCategory::CallArgumentToUpvar\n+            }\n             (category, _, _) => category,\n         };\n \n         debug!(\"report_error: category={:?}\", category);\n         match category {\n-            ConstraintCategory::AssignmentToUpvar |\n-            ConstraintCategory::CallArgumentToUpvar =>\n-                self.report_closure_error(\n-                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n-            _ =>\n-                self.report_general_error(\n-                    mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer),\n+            ConstraintCategory::AssignmentToUpvar | ConstraintCategory::CallArgumentToUpvar => self\n+                .report_closure_error(\n+                    mir,\n+                    infcx,\n+                    mir_def_id,\n+                    fr,\n+                    outlived_fr,\n+                    category,\n+                    span,\n+                    errors_buffer,\n+                ),\n+            _ => self.report_general_error(\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            ),\n         }\n     }\n \n@@ -264,23 +365,31 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        category: &ConstraintCategory,\n-        span: &Span,\n+        category: ConstraintCategory,\n+        span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        let fr_name_and_span  = self.get_var_name_and_span_for_region(\n-            infcx.tcx, mir, fr);\n-        let outlived_fr_name_and_span = self.get_var_name_and_span_for_region(\n-            infcx.tcx, mir,outlived_fr);\n+        let fr_name_and_span = self.get_var_name_and_span_for_region(infcx.tcx, mir, fr);\n+        let outlived_fr_name_and_span =\n+            self.get_var_name_and_span_for_region(infcx.tcx, mir, outlived_fr);\n \n         if fr_name_and_span.is_none() && outlived_fr_name_and_span.is_none() {\n             return self.report_general_error(\n-                mir, infcx, mir_def_id, fr, outlived_fr, category, span, errors_buffer);\n+                mir,\n+                infcx,\n+                mir_def_id,\n+                fr,\n+                outlived_fr,\n+                category,\n+                span,\n+                errors_buffer,\n+            );\n         }\n \n-        let mut diag = infcx.tcx.sess.struct_span_err(\n-            *span, &format!(\"borrowed data escapes outside of closure\"),\n-        );\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"borrowed data escapes outside of closure\"));\n \n         if let Some((outlived_fr_name, outlived_fr_span)) = outlived_fr_name_and_span {\n             if let Some(name) = outlived_fr_name {\n@@ -295,10 +404,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             if let Some(name) = fr_name {\n                 diag.span_label(\n                     fr_span,\n-                    format!(\"`{}` is a reference that is only valid in the closure body\", name),\n+                    format!(\n+                        \"`{}` is a reference that is only valid in the closure body\",\n+                        name\n+                    ),\n                 );\n \n-                diag.span_label(*span, format!(\"`{}` escapes the closure body here\", name));\n+                diag.span_label(span, format!(\"`{}` escapes the closure body here\", name));\n             }\n         }\n \n@@ -312,104 +424,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mir_def_id: DefId,\n         fr: RegionVid,\n         outlived_fr: RegionVid,\n-        category: &ConstraintCategory,\n-        span: &Span,\n+        category: ConstraintCategory,\n+        span: Span,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n         let mut diag = infcx.tcx.sess.struct_span_err(\n-            *span, &format!(\"unsatisfied lifetime constraints\"), // FIXME\n+            span,\n+            &format!(\"unsatisfied lifetime constraints\"), // FIXME\n         );\n \n         let counter = &mut 1;\n-        let fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, fr, counter, &mut diag);\n-        let outlived_fr_name = self.give_region_a_name(\n-            infcx.tcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n-\n-        diag.span_label(*span, format!(\n-            \"{} requires that `{}` must outlive `{}`\",\n-            category, fr_name, outlived_fr_name,\n-        ));\n+        let fr_name = self.give_region_a_name(infcx.tcx, mir, mir_def_id, fr, counter, &mut diag);\n+        let outlived_fr_name =\n+            self.give_region_a_name(infcx.tcx, mir, mir_def_id, outlived_fr, counter, &mut diag);\n+\n+        diag.span_label(\n+            span,\n+            format!(\n+                \"{} requires that `{}` must outlive `{}`\",\n+                category, fr_name, outlived_fr_name,\n+            ),\n+        );\n \n         diag.buffer(errors_buffer);\n     }\n \n-    // Find some constraint `X: Y` where:\n-    // - `fr1: X` transitively\n-    // - and `Y` is live at `elem`\n-    crate fn find_constraint(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n-        let index = self.blame_constraint(fr1, elem);\n-        self.constraints[index].sub\n+    // Finds some region R such that `fr1: R` and `R` is live at\n+    // `elem`.\n+    crate fn find_sub_region_live_at(&self, fr1: RegionVid, elem: Location) -> RegionVid {\n+        // Find all paths\n+        let (_path, r) =\n+            self.find_constraint_paths_between_regions(fr1, |r| {\n+                self.liveness_constraints.contains(r, elem)\n+            }).unwrap();\n+        r\n     }\n \n-    /// Tries to finds a good span to blame for the fact that `fr1`\n-    /// contains `fr2`.\n-    pub(super) fn blame_constraint(\n+    // Finds a good span to blame for the fact that `fr1` outlives `fr2`.\n+    crate fn find_outlives_blame_span(\n         &self,\n+        mir: &Mir<'tcx>,\n         fr1: RegionVid,\n-        elem: impl ToElementIndex,\n-    ) -> ConstraintIndex {\n-        // Find everything that influenced final value of `fr`.\n-        let influenced_fr1 = self.dependencies(fr1);\n-\n-        // Try to find some outlives constraint `'X: fr2` where `'X`\n-        // influenced `fr1`. Blame that.\n-        //\n-        // NB, this is a pretty bad choice most of the time. In\n-        // particular, the connection between `'X` and `fr1` may not\n-        // be obvious to the user -- not to mention the naive notion\n-        // of dependencies, which doesn't account for the locations of\n-        // contraints at all. But it will do for now.\n-        let relevant_constraint = self.constraints\n-            .iter_enumerated()\n-            .filter_map(|(i, constraint)| {\n-                if !self.liveness_constraints.contains(constraint.sub, elem) {\n-                    None\n-                } else {\n-                    influenced_fr1[constraint.sup]\n-                        .map(|distance| (distance, i))\n-                }\n-            })\n-            .min() // constraining fr1 with fewer hops *ought* to be more obvious\n-            .map(|(_dist, i)| i);\n-\n-        relevant_constraint.unwrap_or_else(|| {\n-            bug!(\n-                \"could not find any constraint to blame for {:?}: {:?}\",\n-                fr1,\n-                elem,\n-            );\n-        })\n-    }\n-\n-    /// Finds all regions whose values `'a` may depend on in some way.\n-    /// For each region, returns either `None` (does not influence\n-    /// `'a`) or `Some(d)` which indicates that it influences `'a`\n-    /// with distinct `d` (minimum number of edges that must be\n-    /// traversed).\n-    ///\n-    /// Used during error reporting, extremely naive and inefficient.\n-    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, Option<usize>> {\n-        let mut result_set = IndexVec::from_elem(None, &self.definitions);\n-        let mut changed = true;\n-        result_set[r0] = Some(0); // distance 0 from `r0`\n-\n-        while changed {\n-            changed = false;\n-            for constraint in self.constraints.iter() {\n-                if let Some(n) = result_set[constraint.sup] {\n-                    let m = n + 1;\n-                    if result_set[constraint.sub]\n-                        .map(|distance| m < distance)\n-                        .unwrap_or(true)\n-                    {\n-                        result_set[constraint.sub] = Some(m);\n-                        changed = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        result_set\n+        fr2: RegionVid,\n+    ) -> Span {\n+        let (_, span, _) = self.best_blame_constraint(mir, fr1, |r| r == fr2);\n+        span\n     }\n }"}, {"sha": "2ab72f655352fd67d5d620397c26ad4994966d11", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 246, "deletions": 94, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -9,18 +9,16 @@\n // except according to those terms.\n \n use super::universal_regions::UniversalRegions;\n+use borrow_check::nll::constraints::graph::ConstraintGraph;\n use borrow_check::nll::constraints::{\n     ConstraintIndex, ConstraintSccIndex, ConstraintSet, OutlivesConstraint,\n };\n-use borrow_check::nll::constraints::graph::ConstraintGraph;\n-use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::region_infer::values::{RegionElement, ToElementIndex};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::region_constraints::{GenericKind, VarInfos};\n-use rustc::infer::InferCtxt;\n-use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc::mir::{\n     ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements, Local, Location,\n     Mir,\n@@ -39,7 +37,7 @@ mod dump_mir;\n mod error_reporting;\n mod graphviz;\n pub mod values;\n-use self::values::{RegionValueElements, RegionValues};\n+use self::values::{LivenessValues, RegionValueElements, RegionValues};\n \n use super::ToRegionVid;\n \n@@ -50,14 +48,11 @@ pub struct RegionInferenceContext<'tcx> {\n     /// from as well as its final inferred value.\n     definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n \n-    /// Maps from points/universal-regions to a `RegionElementIndex`.\n-    elements: Rc<RegionValueElements>,\n-\n     /// The liveness constraints added to each region. For most\n     /// regions, these start out empty and steadily grow, though for\n     /// each universally quantified region R they start out containing\n     /// the entire CFG and `end(R)`.\n-    liveness_constraints: RegionValues<RegionVid>,\n+    liveness_constraints: LivenessValues<RegionVid>,\n \n     /// The outlives constraints computed by the type-check.\n     constraints: Rc<ConstraintSet>,\n@@ -71,6 +66,11 @@ pub struct RegionInferenceContext<'tcx> {\n     /// of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n+    /// Contains the minimum universe of any variable within the same\n+    /// SCC. We will ensure that no SCC contains values that are not\n+    /// visible from this index.\n+    scc_universes: IndexVec<ConstraintSccIndex, ty::UniverseIndex>,\n+\n     /// The final inferred values of the region variables; we compute\n     /// one value per SCC. To get the value for any given *region*,\n     /// you first find which scc it is a part of.\n@@ -85,17 +85,16 @@ pub struct RegionInferenceContext<'tcx> {\n }\n \n struct RegionDefinition<'tcx> {\n-    /// Why we created this variable. Mostly these will be\n-    /// `RegionVariableOrigin::NLL`, but some variables get created\n-    /// elsewhere in the code with other causes (e.g., instantiation\n-    /// late-bound-regions).\n-    origin: RegionVariableOrigin,\n-\n-    /// True if this is a universally quantified region. This means a\n-    /// lifetime parameter that appears in the function signature (or,\n-    /// in the case of a closure, in the closure environment, which of\n-    /// course is also in the function signature).\n-    is_universal: bool,\n+    /// What kind of variable is this -- a free region? existential\n+    /// variable? etc. (See the `NLLRegionVariableOrigin` for more\n+    /// info.)\n+    origin: NLLRegionVariableOrigin,\n+\n+    /// Which universe is this region variable defined in? This is\n+    /// most often `ty::UniverseIndex::ROOT`, but when we encounter\n+    /// forall-quantifiers like `for<'a> { 'a = 'b }`, we would create\n+    /// the variable for `'a` in a subuniverse.\n+    universe: ty::UniverseIndex,\n \n     /// If this is 'static or an early-bound region, then this is\n     /// `Some(X)` where `X` is the name of the region.\n@@ -211,45 +210,79 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         _mir: &Mir<'tcx>,\n         outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n-        liveness_constraints: RegionValues<RegionVid>,\n+        liveness_constraints: LivenessValues<RegionVid>,\n         elements: &Rc<RegionValueElements>,\n     ) -> Self {\n         let universal_regions = Rc::new(universal_regions);\n \n         // Create a RegionDefinition for each inference variable.\n         let definitions: IndexVec<_, _> = var_infos\n             .into_iter()\n-            .map(|info| RegionDefinition::new(info.origin))\n+            .map(|info| RegionDefinition::new(info.universe, info.origin))\n             .collect();\n \n+        // Compute the max universe used anywhere amongst the regions.\n+        let max_universe = definitions\n+            .iter()\n+            .map(|d| d.universe)\n+            .max()\n+            .unwrap_or(ty::UniverseIndex::ROOT);\n+\n         let constraints = Rc::new(outlives_constraints); // freeze constraints\n         let constraint_graph = Rc::new(constraints.graph(definitions.len()));\n         let constraint_sccs = Rc::new(constraints.compute_sccs(&constraint_graph));\n \n-        let mut scc_values = RegionValues::new(elements);\n+        let mut scc_values = RegionValues::new(elements, universal_regions.len(), max_universe);\n \n-        for (region, location_set) in liveness_constraints.iter_enumerated() {\n+        for region in liveness_constraints.rows() {\n             let scc = constraint_sccs.scc(region);\n-            scc_values.merge_into(scc, location_set);\n+            scc_values.merge_liveness(scc, region, &liveness_constraints);\n         }\n \n+        let scc_universes = Self::compute_scc_universes(&constraint_sccs, &definitions);\n+\n         let mut result = Self {\n             definitions,\n-            elements: elements.clone(),\n             liveness_constraints,\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n+            scc_universes,\n             scc_values,\n             type_tests,\n             universal_regions,\n         };\n \n-        result.init_universal_regions();\n+        result.init_free_and_bound_regions();\n \n         result\n     }\n \n+    /// Each SCC is the combination of many region variables which\n+    /// have been equated. Therefore, we can associate a universe with\n+    /// each SCC which is minimum of all the universes of its\n+    /// constituent regions -- this is because whatever value the SCC\n+    /// takes on must be a value that each of the regions within the\n+    /// SCC could have as well. This implies that the SCC must have\n+    /// the minimum, or narrowest, universe.\n+    fn compute_scc_universes(\n+        constraints_scc: &Sccs<RegionVid, ConstraintSccIndex>,\n+        definitions: &IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+    ) -> IndexVec<ConstraintSccIndex, ty::UniverseIndex> {\n+        let num_sccs = constraints_scc.num_sccs();\n+        let mut scc_universes = IndexVec::from_elem_n(ty::UniverseIndex::MAX, num_sccs);\n+\n+        for (region_vid, region_definition) in definitions.iter_enumerated() {\n+            let scc = constraints_scc.scc(region_vid);\n+            let scc_universe = &mut scc_universes[scc];\n+            *scc_universe = ::std::cmp::min(*scc_universe, region_definition.universe);\n+        }\n+\n+        debug!(\"compute_scc_universes: scc_universe = {:#?}\", scc_universes);\n+\n+        scc_universes\n+    }\n+\n     /// Initializes the region variables for each universally\n     /// quantified region (lifetime parameter). The first N variables\n     /// always correspond to the regions appearing in the function\n@@ -270,7 +303,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// and (b) any universally quantified regions that it outlives,\n     /// which in this case is just itself. R1 (`'b`) in contrast also\n     /// outlives `'a` and hence contains R0 and R1.\n-    fn init_universal_regions(&mut self) {\n+    fn init_free_and_bound_regions(&mut self) {\n         // Update the names (if any)\n         for (external_name, variable) in self.universal_regions.named_universal_regions() {\n             debug!(\n@@ -281,25 +314,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.definitions[variable].external_name = Some(external_name);\n         }\n \n-        // For each universally quantified region X:\n-        let elements = self.elements.clone();\n-        let universal_regions = self.universal_regions.clone();\n-        for variable in universal_regions.universal_regions() {\n-            // These should be free-region variables.\n-            assert!(match self.definitions[variable].origin {\n-                RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n-                _ => false,\n-            });\n+        for variable in self.definitions.indices() {\n+            match self.definitions[variable].origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // For each free, universally quantified region X:\n \n-            self.definitions[variable].is_universal = true;\n+                    // Add all nodes in the CFG to liveness constraints\n+                    let variable_scc = self.constraint_sccs.scc(variable);\n+                    self.liveness_constraints.add_all_points(variable);\n+                    self.scc_values.add_all_points(variable_scc);\n \n-            // Add all nodes in the CFG to liveness constraints\n-            for point_index in elements.all_point_indices() {\n-                self.add_live_element(variable, point_index);\n-            }\n+                    // Add `end(X)` into the set for X.\n+                    self.add_element_to_scc_of(variable, variable);\n+                }\n+\n+                NLLRegionVariableOrigin::BoundRegion(ui) => {\n+                    // Each placeholder region X outlives its\n+                    // associated universe but nothing else.\n+                    self.add_element_to_scc_of(variable, ui);\n+                }\n \n-            // Add `end(X)` into the set for X.\n-            self.add_live_element(variable, variable);\n+                NLLRegionVariableOrigin::Existential => {\n+                    // For existential, regions, nothing to do.\n+                }\n+            }\n         }\n     }\n \n@@ -330,27 +368,17 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         self.scc_values.region_value_str(scc)\n     }\n \n-    /// Indicates that the region variable `v` is live at the point `point`.\n-    ///\n-    /// Returns `true` if this constraint is new and `false` is the\n-    /// constraint was already present.\n-    pub(super) fn add_live_element(\n-        &mut self,\n-        v: RegionVid,\n-        elem: impl ToElementIndex,\n-    ) -> bool {\n-        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n-\n-        // Add to the liveness values for `v`...\n-        if self.liveness_constraints.add_element(v, elem) {\n-            // ...but also add to the SCC in which `v` appears.\n-            let scc = self.constraint_sccs.scc(v);\n-            self.scc_values.add_element(scc, elem);\n+    /// Returns access to the value of `r` for debugging purposes.\n+    crate fn region_universe(&self, r: RegionVid) -> ty::UniverseIndex {\n+        let scc = self.constraint_sccs.scc(r.to_region_vid());\n+        self.scc_universes[scc]\n+    }\n \n-            true\n-        } else {\n-            false\n-        }\n+    /// Adds `elem` to the value of the SCC in which `v` appears.\n+    fn add_element_to_scc_of(&mut self, v: RegionVid, elem: impl ToElementIndex) {\n+        debug!(\"add_live_element({:?}, {:?})\", v, elem);\n+        let scc = self.constraint_sccs.scc(v);\n+        self.scc_values.add_element(scc, elem);\n     }\n \n     /// Perform region inference and report errors if we see any\n@@ -460,8 +488,32 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // ...compute the value of `B`...\n             self.propagate_constraint_sccs_if_new(scc_b, visited);\n \n-            // ...and add elements from `B` into `A`.\n-            self.scc_values.add_region(scc_a, scc_b);\n+            // ...and add elements from `B` into `A`. One complication\n+            // arises because of universes: If `B` contains something\n+            // that `A` cannot name, then `A` can only contain `B` if\n+            // it outlives static.\n+            if self.universe_compatible(scc_b, scc_a) {\n+                // `A` can name everything that is in `B`, so just\n+                // merge the bits.\n+                self.scc_values.add_region(scc_a, scc_b);\n+            } else {\n+                // Otherwise, the only way for `A` to outlive `B`\n+                // is for it to outlive static. This is actually stricter\n+                // than necessary: ideally, we'd support bounds like `for<'a: 'b`>`\n+                // that might then allow us to approximate `'a` with `'b` and not\n+                // `'static`. But it will have to do for now.\n+                //\n+                // The code here is a bit hacky: we grab the current\n+                // value of the SCC in which `'static` appears, but\n+                // this value may not be fully computed yet. That's ok\n+                // though: it will contain the base liveness values,\n+                // which include (a) the static free region element\n+                // and (b) all the points in the CFG, so it is \"good\n+                // enough\" to bring it in here for our purposes.\n+                let fr_static = self.universal_regions.fr_static;\n+                let scc_static = constraint_sccs.scc(fr_static);\n+                self.scc_values.add_region(scc_a, scc_static);\n+            }\n         }\n \n         debug!(\n@@ -471,6 +523,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         );\n     }\n \n+    /// True if all the elements in the value of `scc_b` are nameable\n+    /// in `scc_a`. Used during constraint propagation, and only once\n+    /// the value of `scc_b` has been computed.\n+    fn universe_compatible(&self, scc_b: ConstraintSccIndex, scc_a: ConstraintSccIndex) -> bool {\n+        let universe_a = self.scc_universes[scc_a];\n+\n+        // Quick check: if scc_b's declared universe is a subset of\n+        // scc_a's declared univese (typically, both are ROOT), then\n+        // it cannot contain any problematic universe elements.\n+        if self.scc_universes[scc_b].is_subset_of(universe_a) {\n+            return true;\n+        }\n+\n+        // Otherwise, we have to iterate over the universe elements in\n+        // B's value, and check whether all of them are nameable\n+        // from universe_a\n+        self.scc_values\n+            .subuniverses_contained_in(scc_b)\n+            .all(|u| u.is_subset_of(universe_a))\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:\n@@ -793,7 +866,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // now). Therefore, the sup-region outlives the sub-region if,\n         // for each universal region R1 in the sub-region, there\n         // exists some region R2 in the sup-region that outlives R1.\n-        let universal_outlives = self.scc_values\n+        let universal_outlives = self\n+            .scc_values\n             .universal_regions_outlived_by(sub_region_scc)\n             .all(|r1| {\n                 self.scc_values\n@@ -813,8 +887,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             return true;\n         }\n \n-        self.scc_values\n-            .contains_points(sup_region_scc, sub_region_scc)\n+        self.scc_values.contains_points(sup_region_scc, sub_region_scc)\n     }\n \n     /// Once regions have been propagated, this method is used to see\n@@ -842,24 +915,30 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n         errors_buffer: &mut Vec<Diagnostic>,\n     ) {\n-        // The universal regions are always found in a prefix of the\n-        // full list.\n-        let universal_definitions = self.definitions\n-            .iter_enumerated()\n-            .take_while(|(_, fr_definition)| fr_definition.is_universal);\n-\n-        // Go through each of the universal regions `fr` and check that\n-        // they did not grow too large, accumulating any requirements\n-        // for our caller into the `outlives_requirements` vector.\n-        for (fr, _) in universal_definitions {\n-            self.check_universal_region(\n-                infcx,\n-                mir,\n-                mir_def_id,\n-                fr,\n-                &mut propagated_outlives_requirements,\n-                errors_buffer,\n-            );\n+        for (fr, fr_definition) in self.definitions.iter_enumerated() {\n+            match fr_definition.origin {\n+                NLLRegionVariableOrigin::FreeRegion => {\n+                    // Go through each of the universal regions `fr` and check that\n+                    // they did not grow too large, accumulating any requirements\n+                    // for our caller into the `outlives_requirements` vector.\n+                    self.check_universal_region(\n+                        infcx,\n+                        mir,\n+                        mir_def_id,\n+                        fr,\n+                        &mut propagated_outlives_requirements,\n+                        errors_buffer,\n+                    );\n+                }\n+\n+                NLLRegionVariableOrigin::BoundRegion(universe) => {\n+                    self.check_bound_universal_region(infcx, mir, mir_def_id, fr, universe);\n+                }\n+\n+                NLLRegionVariableOrigin::Existential => {\n+                    // nothing to check here\n+                }\n+            }\n         }\n     }\n \n@@ -884,6 +963,16 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n \n+        // Because this free region must be in the ROOT universe, we\n+        // know it cannot contain any bound universes.\n+        assert!(self.scc_universes[longer_fr_scc] == ty::UniverseIndex::ROOT);\n+        debug_assert!(\n+            self.scc_values\n+                .subuniverses_contained_in(longer_fr_scc)\n+                .next()\n+                .is_none()\n+        );\n+\n         // Find every region `o` such that `fr: o`\n         // (because `fr` includes `end(o)`).\n         for shorter_fr in self.scc_values.universal_regions_outlived_by(longer_fr_scc) {\n@@ -897,8 +986,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 longer_fr, shorter_fr,\n             );\n \n-            let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints[blame_index].locations.span(mir);\n+            let blame_span = self.find_outlives_blame_span(mir, longer_fr, shorter_fr);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -934,19 +1022,83 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // to report the error. This gives better error messages\n             // in some cases.\n             self.report_error(\n-                mir, infcx, mir_def_id, longer_fr, shorter_fr, blame_span, errors_buffer);\n+                mir, infcx, mir_def_id, longer_fr, shorter_fr, errors_buffer);\n         }\n     }\n+\n+    fn check_bound_universal_region<'gcx>(\n+        &self,\n+        infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n+        _mir_def_id: DefId,\n+        longer_fr: RegionVid,\n+        universe: ty::UniverseIndex,\n+    ) {\n+        debug!(\"check_bound_universal_region(fr={:?})\", longer_fr);\n+\n+        let longer_fr_scc = self.constraint_sccs.scc(longer_fr);\n+\n+        // If we have some bound universal region `'a`, then the only\n+        // elements it can contain is itself -- we don't know anything\n+        // else about it!\n+        let error_element = match {\n+            self.scc_values\n+                .elements_contained_in(longer_fr_scc)\n+                .find(|element| match element {\n+                    RegionElement::Location(_) => true,\n+                    RegionElement::RootUniversalRegion(_) => true,\n+                    RegionElement::SubUniversalRegion(ui) => *ui != universe,\n+                })\n+        } {\n+            Some(v) => v,\n+            None => return,\n+        };\n+\n+        // Find the region that introduced this `error_element`.\n+        let error_region = match error_element {\n+            RegionElement::Location(l) => self.find_sub_region_live_at(longer_fr, l),\n+            RegionElement::RootUniversalRegion(r) => r,\n+            RegionElement::SubUniversalRegion(error_ui) => self\n+                .definitions\n+                .iter_enumerated()\n+                .filter_map(|(r, definition)| match definition.origin {\n+                    NLLRegionVariableOrigin::BoundRegion(ui) if error_ui == ui => Some(r),\n+                    _ => None,\n+                })\n+                .next()\n+                .unwrap(),\n+        };\n+\n+        // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n+        let span = self.find_outlives_blame_span(mir, longer_fr, error_region);\n+\n+        // Obviously, this error message is far from satisfactory.\n+        // At present, though, it only appears in unit tests --\n+        // the AST-based checker uses a more conservative check,\n+        // so to even see this error, one must pass in a special\n+        // flag.\n+        let mut diag = infcx\n+            .tcx\n+            .sess\n+            .struct_span_err(span, &format!(\"higher-ranked subtype error\"));\n+        diag.emit();\n+    }\n }\n \n impl<'tcx> RegionDefinition<'tcx> {\n-    fn new(origin: RegionVariableOrigin) -> Self {\n+    fn new(universe: ty::UniverseIndex, rv_origin: RegionVariableOrigin) -> Self {\n         // Create a new region definition. Note that, for free\n-        // regions, these fields get updated later in\n+        // regions, the `external_name` field gets updated later in\n         // `init_universal_regions`.\n+\n+        let origin = match rv_origin {\n+            RegionVariableOrigin::NLL(origin) => origin,\n+            _ => NLLRegionVariableOrigin::Existential,\n+        };\n+\n         Self {\n             origin,\n-            is_universal: false,\n+            universe,\n             external_name: None,\n         }\n     }"}, {"sha": "8db5809e53f5eea9f2376fe429f1989b7a7e6fae", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 301, "deletions": 197, "changes": 498, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -9,24 +9,22 @@\n // except according to those terms.\n \n use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::ty::RegionVid;\n-use rustc_data_structures::bitvec::{BitVector, SparseBitMatrix};\n+use rustc::ty::{self, RegionVid};\n+use rustc_data_structures::bitvec::SparseBitMatrix;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n use std::rc::Rc;\n \n-/// Maps between the various kinds of elements of a region value to\n-/// the internal indices that w use.\n+/// Maps between a `Location` and a `PointIndex` (and vice versa).\n crate struct RegionValueElements {\n     /// For each basic block, how many points are contained within?\n     statements_before_block: IndexVec<BasicBlock, usize>,\n     num_points: usize,\n-    num_universal_regions: usize,\n }\n \n impl RegionValueElements {\n-    crate fn new(mir: &Mir<'_>, num_universal_regions: usize) -> Self {\n+    crate fn new(mir: &Mir<'_>) -> Self {\n         let mut num_points = 0;\n         let statements_before_block = mir\n             .basic_blocks()\n@@ -37,11 +35,6 @@ impl RegionValueElements {\n                 v\n             })\n             .collect();\n-\n-        debug!(\n-            \"RegionValueElements(num_universal_regions={:?})\",\n-            num_universal_regions\n-        );\n         debug!(\n             \"RegionValueElements: statements_before_block={:#?}\",\n             statements_before_block\n@@ -50,90 +43,66 @@ impl RegionValueElements {\n \n         Self {\n             statements_before_block,\n-            num_universal_regions,\n             num_points,\n         }\n     }\n \n-    /// Total number of element indices that exist.\n-    crate fn num_elements(&self) -> usize {\n-        self.num_points + self.num_universal_regions\n-    }\n-\n-    /// Converts an element of a region value into a `RegionElementIndex`.\n-    crate fn index<T: ToElementIndex>(&self, elem: T) -> RegionElementIndex {\n-        elem.to_element_index(self)\n-    }\n-\n-    /// Iterates over the `RegionElementIndex` for all points in the CFG.\n-    crate fn all_point_indices<'a>(&'a self) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        (0..self.num_points).map(move |i| RegionElementIndex::new(i + self.num_universal_regions))\n-    }\n-\n-    /// Converts a particular `RegionElementIndex` to the `RegionElement` it represents.\n-    crate fn to_element(&self, i: RegionElementIndex) -> RegionElement {\n-        debug!(\"to_element(i={:?})\", i);\n-\n-        if let Some(r) = self.to_universal_region(i) {\n-            RegionElement::UniversalRegion(r)\n-        } else {\n-            let point_index = i.index() - self.num_universal_regions;\n-\n-            // Find the basic block. We have a vector with the\n-            // starting index of the statement in each block. Imagine\n-            // we have statement #22, and we have a vector like:\n-            //\n-            // [0, 10, 20]\n-            //\n-            // In that case, this represents point_index 2 of\n-            // basic block BB2. We know this because BB0 accounts for\n-            // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n-            // 20...\n-            //\n-            // To compute this, we could do a binary search, but\n-            // because I am lazy we instead iterate through to find\n-            // the last point where the \"first index\" (0, 10, or 20)\n-            // was less than the statement index (22). In our case, this will\n-            // be (BB2, 20).\n-            //\n-            // Nit: we could do a binary search here but I'm too lazy.\n-            let (block, &first_index) = self\n-                .statements_before_block\n-                .iter_enumerated()\n-                .filter(|(_, first_index)| **first_index <= point_index)\n-                .last()\n-                .unwrap();\n-\n-            RegionElement::Location(Location {\n-                block,\n-                statement_index: point_index - first_index,\n-            })\n-        }\n+    /// Converts a `Location` into a `PointIndex`. O(1).\n+    fn point_from_location(&self, location: Location) -> PointIndex {\n+        let Location {\n+            block,\n+            statement_index,\n+        } = location;\n+        let start_index = self.statements_before_block[block];\n+        PointIndex::new(start_index + statement_index)\n     }\n \n-    /// Converts a particular `RegionElementIndex` to a universal\n-    /// region, if that is what it represents. Returns `None`\n-    /// otherwise.\n-    crate fn to_universal_region(&self, i: RegionElementIndex) -> Option<RegionVid> {\n-        if i.index() < self.num_universal_regions {\n-            Some(RegionVid::new(i.index()))\n-        } else {\n-            None\n+    /// Converts a `PointIndex` back to a location. O(N) where N is\n+    /// the number of blocks; could be faster if we ever cared.\n+    crate fn to_location(&self, i: PointIndex) -> Location {\n+        let point_index = i.index();\n+\n+        // Find the basic block. We have a vector with the\n+        // starting index of the statement in each block. Imagine\n+        // we have statement #22, and we have a vector like:\n+        //\n+        // [0, 10, 20]\n+        //\n+        // In that case, this represents point_index 2 of\n+        // basic block BB2. We know this because BB0 accounts for\n+        // 0..10, BB1 accounts for 11..20, and BB2 accounts for\n+        // 20...\n+        //\n+        // To compute this, we could do a binary search, but\n+        // because I am lazy we instead iterate through to find\n+        // the last point where the \"first index\" (0, 10, or 20)\n+        // was less than the statement index (22). In our case, this will\n+        // be (BB2, 20).\n+        //\n+        // Nit: we could do a binary search here but I'm too lazy.\n+        let (block, &first_index) = self\n+            .statements_before_block\n+            .iter_enumerated()\n+            .filter(|(_, first_index)| **first_index <= point_index)\n+            .last()\n+            .unwrap();\n+\n+        Location {\n+            block,\n+            statement_index: point_index - first_index,\n         }\n     }\n }\n \n-/// A newtype for the integers that represent one of the possible\n-/// elements in a region. These are the rows in the `SparseBitMatrix` that\n-/// is used to store the values of all regions. They have the following\n-/// convention:\n-///\n-/// - The first N indices represent free regions (where N = universal_regions.len()).\n-/// - The remainder represent the points in the CFG (see `point_indices` map).\n-///\n-/// You can convert a `RegionElementIndex` into a `RegionElement`\n-/// using the `to_region_elem` method.\n-newtype_index!(RegionElementIndex { DEBUG_FORMAT = \"RegionElementIndex({})\" });\n+/// A single integer representing a `Location` in the MIR control-flow\n+/// graph. Constructed efficiently from `RegionValueElements`.\n+newtype_index!(PointIndex { DEBUG_FORMAT = \"PointIndex({})\" });\n+\n+/// A single integer representing a (non-zero) `UniverseIndex`.\n+/// Computed just by subtracting one from `UniverseIndex`; this is\n+/// because the `0` value for `UniverseIndex` represents the root\n+/// universe, and we don't need/want a bit for that one.\n+newtype_index!(PlaceholderIndex { DEBUG_FORMAT = \"PlaceholderIndex({})\" });\n \n /// An individual element in a region value -- the value of a\n /// particular region variable consists of a set of these elements.\n@@ -142,193 +111,328 @@ crate enum RegionElement {\n     /// A point in the control-flow graph.\n     Location(Location),\n \n-    /// An in-scope, universally quantified region (e.g., a lifetime parameter).\n-    UniversalRegion(RegionVid),\n+    /// A universally quantified region from the root universe (e.g.,\n+    /// a lifetime parameter).\n+    RootUniversalRegion(RegionVid),\n+\n+    /// A subuniverse from a subuniverse (e.g., instantiated from a\n+    /// `for<'a> fn(&'a u32)` type).\n+    SubUniversalRegion(ty::UniverseIndex),\n }\n \n-crate trait ToElementIndex: Debug + Copy {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex;\n+/// When we initially compute liveness, we use a bit matrix storing\n+/// points for each region-vid.\n+crate struct LivenessValues<N: Idx> {\n+    elements: Rc<RegionValueElements>,\n+    points: SparseBitMatrix<N, PointIndex>,\n }\n \n-impl ToElementIndex for Location {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        let Location {\n-            block,\n-            statement_index,\n-        } = self;\n-        let start_index = elements.statements_before_block[block];\n-        RegionElementIndex::new(elements.num_universal_regions + start_index + statement_index)\n+impl<N: Idx> LivenessValues<N> {\n+    /// Creates a new set of \"region values\" that tracks causal information.\n+    /// Each of the regions in num_region_variables will be initialized with an\n+    /// empty set of points and no causal information.\n+    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n+        Self {\n+            elements: elements.clone(),\n+            points: SparseBitMatrix::new(elements.num_points),\n+        }\n     }\n-}\n \n-impl ToElementIndex for RegionVid {\n-    fn to_element_index(self, elements: &RegionValueElements) -> RegionElementIndex {\n-        assert!(self.index() < elements.num_universal_regions);\n-        RegionElementIndex::new(self.index())\n+    /// Iterate through each region that has a value in this set.\n+    crate fn rows<'a>(&'a self) -> impl Iterator<Item = N> {\n+        self.points.rows()\n     }\n-}\n \n-impl ToElementIndex for RegionElementIndex {\n-    fn to_element_index(self, _elements: &RegionValueElements) -> RegionElementIndex {\n-        self\n+    /// Adds the given element to the value for the given region. Returns true if\n+    /// the element is newly added (i.e., was not already present).\n+    crate fn add_element(&mut self, row: N, location: Location) -> bool {\n+        debug!(\"LivenessValues::add(r={:?}, location={:?})\", row, location);\n+        let index = self.elements.point_from_location(location);\n+        self.points.add(row, index)\n+    }\n+\n+    /// Adds all the control-flow points to the values for `r`.\n+    crate fn add_all_points(&mut self, row: N) {\n+        self.points.add_all(row);\n+    }\n+\n+    /// True if the region `r` contains the given element.\n+    crate fn contains(&self, row: N, location: Location) -> bool {\n+        let index = self.elements.point_from_location(location);\n+        self.points.contains(row, index)\n+    }\n+\n+    /// Returns a \"pretty\" string value of the region. Meant for debugging.\n+    crate fn region_value_str(&self, r: N) -> String {\n+        region_value_str(\n+            self.points\n+                .row(r)\n+                .into_iter()\n+                .flat_map(|set| set.iter())\n+                .map(|p| self.elements.to_location(p))\n+                .map(RegionElement::Location),\n+        )\n     }\n }\n \n-/// Stores the values for a set of regions. These are stored in a\n-/// compact `SparseBitMatrix` representation, with one row per region\n-/// variable. The columns consist of either universal regions or\n-/// points in the CFG.\n+/// Stores the full values for a set of regions (in contrast to\n+/// `LivenessValues`, which only stores those points in the where a\n+/// region is live). The full value for a region may contain points in\n+/// the CFG, but also free regions as well as bound universe\n+/// placeholders.\n+///\n+/// Example:\n+///\n+/// ```text\n+/// fn foo(x: &'a u32) -> &'a u32 {\n+///    let y: &'0 u32 = x; // let's call this `'0`\n+///    y\n+/// }\n+/// ```\n+///\n+/// Here, the variable `'0` would contain the free region `'a`,\n+/// because (since it is returned) it must live for at least `'a`. But\n+/// it would also contain various points from within the function.\n #[derive(Clone)]\n crate struct RegionValues<N: Idx> {\n     elements: Rc<RegionValueElements>,\n-    matrix: SparseBitMatrix<N, RegionElementIndex>,\n+    points: SparseBitMatrix<N, PointIndex>,\n+    free_regions: SparseBitMatrix<N, RegionVid>,\n+\n+    /// Placeholders represent bound regions -- so something like `'a`\n+    /// in for<'a> fn(&'a u32)`.\n+    placeholders: SparseBitMatrix<N, PlaceholderIndex>,\n }\n \n impl<N: Idx> RegionValues<N> {\n     /// Creates a new set of \"region values\" that tracks causal information.\n     /// Each of the regions in num_region_variables will be initialized with an\n     /// empty set of points and no causal information.\n-    crate fn new(elements: &Rc<RegionValueElements>) -> Self {\n+    crate fn new(\n+        elements: &Rc<RegionValueElements>,\n+        num_universal_regions: usize,\n+        max_universe: ty::UniverseIndex,\n+    ) -> Self {\n+        let num_placeholders = max_universe.as_usize();\n         Self {\n             elements: elements.clone(),\n-            matrix: SparseBitMatrix::new(elements.num_elements()),\n+            points: SparseBitMatrix::new(elements.num_points),\n+            free_regions: SparseBitMatrix::new(num_universal_regions),\n+            placeholders: SparseBitMatrix::new(num_placeholders),\n         }\n     }\n \n     /// Adds the given element to the value for the given region. Returns true if\n     /// the element is newly added (i.e., was not already present).\n-    crate fn add_element(\n-        &mut self,\n-        r: N,\n-        elem: impl ToElementIndex,\n-    ) -> bool {\n-        let i = self.elements.index(elem);\n+    crate fn add_element(&mut self, r: N, elem: impl ToElementIndex) -> bool {\n         debug!(\"add(r={:?}, elem={:?})\", r, elem);\n-        self.matrix.add(r, i)\n+        elem.add_to_row(self, r)\n+    }\n+\n+    /// Adds all the control-flow points to the values for `r`.\n+    crate fn add_all_points(&mut self, r: N) {\n+        self.points.add_all(r);\n     }\n \n     /// Add all elements in `r_from` to `r_to` (because e.g. `r_to:\n     /// r_from`).\n     crate fn add_region(&mut self, r_to: N, r_from: N) -> bool {\n-        self.matrix.merge(r_from, r_to)\n+        self.points.merge(r_from, r_to)\n+            | self.free_regions.merge(r_from, r_to)\n+            | self.placeholders.merge(r_from, r_to)\n     }\n \n     /// True if the region `r` contains the given element.\n     crate fn contains(&self, r: N, elem: impl ToElementIndex) -> bool {\n-        let i = self.elements.index(elem);\n-        self.matrix.contains(r, i)\n+        elem.contained_in_row(self, r)\n     }\n \n-    /// Iterates through each row and the accompanying bit set.\n-    pub fn iter_enumerated<'a>(\n-        &'a self\n-    ) -> impl Iterator<Item = (N, &'a BitVector)> + 'a {\n-        self.matrix.iter_enumerated()\n-    }\n-\n-    /// Merge a row, `from`, originating in another `RegionValues` into the `into` row.\n-    pub fn merge_into(&mut self, into: N, from: &BitVector) -> bool {\n-        self.matrix.merge_into(into, from)\n+    /// `self[to] |= values[from]`, essentially: that is, take all the\n+    /// elements for the region `from` from `values` and add them to\n+    /// the region `to` in `self`.\n+    crate fn merge_liveness<M: Idx>(&mut self, to: N, from: M, values: &LivenessValues<M>) {\n+        if let Some(set) = values.points.row(from) {\n+            self.points.merge_into(to, set);\n+        }\n     }\n \n     /// True if `sup_region` contains all the CFG points that\n     /// `sub_region` contains. Ignores universal regions.\n     crate fn contains_points(&self, sup_region: N, sub_region: N) -> bool {\n-        // This could be done faster by comparing the bitsets. But I\n-        // am lazy.\n-        self.element_indices_contained_in(sub_region)\n-            .skip_while(|&i| self.elements.to_universal_region(i).is_some())\n-            .all(|e| self.contains(sup_region, e))\n+        if let Some(sub_row) = self.points.row(sub_region) {\n+            if let Some(sup_row) = self.points.row(sup_region) {\n+                sup_row.contains_all(sub_row)\n+            } else {\n+                // sup row is empty, so sub row must be empty\n+                sub_row.is_empty()\n+            }\n+        } else {\n+            // sub row is empty, always true\n+            true\n+        }\n     }\n \n-    /// Iterate over the value of the region `r`, yielding up element\n-    /// indices. You may prefer `universal_regions_outlived_by` or\n-    /// `elements_contained_in`.\n-    crate fn element_indices_contained_in<'a>(\n-        &'a self,\n-        r: N,\n-    ) -> impl Iterator<Item = RegionElementIndex> + 'a {\n-        self.matrix.iter(r).map(move |i| i)\n+    /// Returns the locations contained within a given region `r`.\n+    crate fn locations_outlived_by<'a>(&'a self, r: N) -> impl Iterator<Item = Location> + 'a {\n+        self.points\n+            .row(r)\n+            .into_iter()\n+            .flat_map(move |set| set.iter().map(move |p| self.elements.to_location(p)))\n     }\n \n     /// Returns just the universal regions that are contained in a given region's value.\n     crate fn universal_regions_outlived_by<'a>(\n         &'a self,\n         r: N,\n     ) -> impl Iterator<Item = RegionVid> + 'a {\n-        self.element_indices_contained_in(r)\n-            .map(move |i| self.elements.to_universal_region(i))\n-            .take_while(move |v| v.is_some()) // universal regions are a prefix\n-            .map(move |v| v.unwrap())\n+        self.free_regions\n+            .row(r)\n+            .into_iter()\n+            .flat_map(|set| set.iter())\n     }\n \n     /// Returns all the elements contained in a given region's value.\n-    crate fn elements_contained_in<'a>(\n+    crate fn subuniverses_contained_in<'a>(\n         &'a self,\n         r: N,\n-    ) -> impl Iterator<Item = RegionElement> + 'a {\n-        self.element_indices_contained_in(r)\n-            .map(move |r| self.elements.to_element(r))\n+    ) -> impl Iterator<Item = ty::UniverseIndex> + 'a {\n+        self.placeholders\n+            .row(r)\n+            .into_iter()\n+            .flat_map(|set| set.iter())\n+            .map(|p| ty::UniverseIndex::from_u32((p.index() + 1) as u32))\n+    }\n+\n+    /// Returns all the elements contained in a given region's value.\n+    crate fn elements_contained_in<'a>(&'a self, r: N) -> impl Iterator<Item = RegionElement> + 'a {\n+        let points_iter = self.locations_outlived_by(r).map(RegionElement::Location);\n+\n+        let free_regions_iter = self\n+            .universal_regions_outlived_by(r)\n+            .map(RegionElement::RootUniversalRegion);\n+\n+        let subuniverses_iter = self\n+            .subuniverses_contained_in(r)\n+            .map(RegionElement::SubUniversalRegion);\n+\n+        points_iter\n+            .chain(free_regions_iter)\n+            .chain(subuniverses_iter)\n     }\n \n     /// Returns a \"pretty\" string value of the region. Meant for debugging.\n     crate fn region_value_str(&self, r: N) -> String {\n-        let mut result = String::new();\n-        result.push_str(\"{\");\n-\n-        // Set to Some(l1, l2) when we have observed all the locations\n-        // from l1..=l2 (inclusive) but not yet printed them. This\n-        // gets extended if we then see l3 where l3 is the successor\n-        // to l2.\n-        let mut open_location: Option<(Location, Location)> = None;\n-\n-        let mut sep = \"\";\n-        let mut push_sep = |s: &mut String| {\n-            s.push_str(sep);\n-            sep = \", \";\n-        };\n-\n-        for element in self.elements_contained_in(r) {\n-            match element {\n-                RegionElement::Location(l) => {\n-                    if let Some((location1, location2)) = open_location {\n-                        if location2.block == l.block\n-                            && location2.statement_index == l.statement_index - 1\n-                        {\n-                            open_location = Some((location1, l));\n-                            continue;\n-                        }\n-\n-                        push_sep(&mut result);\n-                        Self::push_location_range(&mut result, location1, location2);\n+        region_value_str(self.elements_contained_in(r))\n+    }\n+}\n+\n+crate trait ToElementIndex: Debug + Copy {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool;\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool;\n+}\n+\n+impl ToElementIndex for Location {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n+        let index = values.elements.point_from_location(self);\n+        values.points.add(row, index)\n+    }\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n+        let index = values.elements.point_from_location(self);\n+        values.points.contains(row, index)\n+    }\n+}\n+\n+impl ToElementIndex for RegionVid {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n+        values.free_regions.add(row, self)\n+    }\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n+        values.free_regions.contains(row, self)\n+    }\n+}\n+\n+impl ToElementIndex for ty::UniverseIndex {\n+    fn add_to_row<N: Idx>(self, values: &mut RegionValues<N>, row: N) -> bool {\n+        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        values.placeholders.add(row, index)\n+    }\n+\n+    fn contained_in_row<N: Idx>(self, values: &RegionValues<N>, row: N) -> bool {\n+        let index = PlaceholderIndex::new(self.as_usize() - 1);\n+        values.placeholders.contains(row, index)\n+    }\n+}\n+\n+fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n+    let mut result = String::new();\n+    result.push_str(\"{\");\n+\n+    // Set to Some(l1, l2) when we have observed all the locations\n+    // from l1..=l2 (inclusive) but not yet printed them. This\n+    // gets extended if we then see l3 where l3 is the successor\n+    // to l2.\n+    let mut open_location: Option<(Location, Location)> = None;\n+\n+    let mut sep = \"\";\n+    let mut push_sep = |s: &mut String| {\n+        s.push_str(sep);\n+        sep = \", \";\n+    };\n+\n+    for element in elements {\n+        match element {\n+            RegionElement::Location(l) => {\n+                if let Some((location1, location2)) = open_location {\n+                    if location2.block == l.block\n+                        && location2.statement_index == l.statement_index - 1\n+                    {\n+                        open_location = Some((location1, l));\n+                        continue;\n                     }\n \n-                    open_location = Some((l, l));\n+                    push_sep(&mut result);\n+                    push_location_range(&mut result, location1, location2);\n                 }\n \n-                RegionElement::UniversalRegion(fr) => {\n-                    if let Some((location1, location2)) = open_location {\n-                        push_sep(&mut result);\n-                        Self::push_location_range(&mut result, location1, location2);\n-                        open_location = None;\n-                    }\n+                open_location = Some((l, l));\n+            }\n \n+            RegionElement::RootUniversalRegion(fr) => {\n+                if let Some((location1, location2)) = open_location {\n                     push_sep(&mut result);\n-                    result.push_str(&format!(\"{:?}\", fr));\n+                    push_location_range(&mut result, location1, location2);\n+                    open_location = None;\n                 }\n+\n+                push_sep(&mut result);\n+                result.push_str(&format!(\"{:?}\", fr));\n             }\n-        }\n \n-        if let Some((location1, location2)) = open_location {\n-            push_sep(&mut result);\n-            Self::push_location_range(&mut result, location1, location2);\n-        }\n+            RegionElement::SubUniversalRegion(ur) => {\n+                if let Some((location1, location2)) = open_location {\n+                    push_sep(&mut result);\n+                    push_location_range(&mut result, location1, location2);\n+                    open_location = None;\n+                }\n \n-        result.push_str(\"}\");\n+                push_sep(&mut result);\n+                result.push_str(&format!(\"{:?}\", ur));\n+            }\n+        }\n+    }\n \n-        result\n+    if let Some((location1, location2)) = open_location {\n+        push_sep(&mut result);\n+        push_location_range(&mut result, location1, location2);\n     }\n \n+    result.push_str(\"}\");\n+\n+    return result;\n+\n     fn push_location_range(str: &mut String, location1: Location, location2: Location) {\n         if location1 == location2 {\n             str.push_str(&format!(\"{:?}\", location1));"}, {"sha": "e1bd8530629d97c80bd432a11cfcb077326ad8c1", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -28,7 +28,6 @@ pub fn renumber_mir<'tcx>(infcx: &InferCtxt<'_, '_, 'tcx>, mir: &mut Mir<'tcx>)\n /// variables.\n pub fn renumber_regions<'tcx, T>(\n     infcx: &InferCtxt<'_, '_, 'tcx>,\n-    ty_context: TyContext,\n     value: &T,\n ) -> T\n where\n@@ -39,7 +38,7 @@ where\n     infcx\n         .tcx\n         .fold_regions(value, &mut false, |_region, _depth| {\n-            let origin = NLLRegionVariableOrigin::Inferred(ty_context);\n+            let origin = NLLRegionVariableOrigin::Existential;\n             infcx.next_nll_region_var(origin)\n         })\n }\n@@ -49,28 +48,27 @@ struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n-    fn renumber_regions<T>(&mut self, ty_context: TyContext, value: &T) -> T\n+    fn renumber_regions<T>(&mut self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        renumber_regions(self.infcx, ty_context, value)\n+        renumber_regions(self.infcx, value)\n     }\n }\n \n impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n     fn visit_ty(&mut self, ty: &mut Ty<'tcx>, ty_context: TyContext) {\n         debug!(\"visit_ty(ty={:?}, ty_context={:?})\", ty, ty_context);\n \n-        *ty = self.renumber_regions(ty_context, ty);\n+        *ty = self.renumber_regions(ty);\n \n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n     fn visit_substs(&mut self, substs: &mut &'tcx Substs<'tcx>, location: Location) {\n         debug!(\"visit_substs(substs={:?}, location={:?})\", substs, location);\n \n-        let ty_context = TyContext::Location(location);\n-        *substs = self.renumber_regions(ty_context, &{ *substs });\n+        *substs = self.renumber_regions(&{ *substs });\n \n         debug!(\"visit_substs: substs={:?}\", substs);\n     }\n@@ -79,15 +77,13 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_region(region={:?}, location={:?})\", region, location);\n \n         let old_region = *region;\n-        let ty_context = TyContext::Location(location);\n-        *region = self.renumber_regions(ty_context, &old_region);\n+        *region = self.renumber_regions(&old_region);\n \n         debug!(\"visit_region: region={:?}\", region);\n     }\n \n-    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, location: Location) {\n-        let ty_context = TyContext::Location(location);\n-        *constant = self.renumber_regions(ty_context, &*constant);\n+    fn visit_const(&mut self, constant: &mut &'tcx ty::Const<'tcx>, _location: Location) {\n+        *constant = self.renumber_regions(&*constant);\n     }\n \n     fn visit_generator_substs(&mut self,\n@@ -99,8 +95,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             location,\n         );\n \n-        let ty_context = TyContext::Location(location);\n-        *substs = self.renumber_regions(ty_context, substs);\n+        *substs = self.renumber_regions(substs);\n \n         debug!(\"visit_generator_substs: substs={:?}\", substs);\n     }\n@@ -112,8 +107,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n             location\n         );\n \n-        let ty_context = TyContext::Location(location);\n-        *substs = self.renumber_regions(ty_context, substs);\n+        *substs = self.renumber_regions(substs);\n \n         debug!(\"visit_closure_substs: substs={:?}\", substs);\n     }"}, {"sha": "3d831bce5ce176ddd8550003c9886c535e092c61", "filename": "src/librustc_mir/borrow_check/nll/type_check/input_output.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Finput_output.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -21,7 +21,6 @@ use borrow_check::nll::renumber;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferOk;\n-use rustc::mir::visit::TyContext;\n use rustc::mir::*;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n use rustc::traits::{ObligationCause, PredicateObligations};\n@@ -117,7 +116,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             let anon_defn_ty = anon_defn_ty.subst(tcx, anon_decl.substs);\n                             let anon_defn_ty = renumber::renumber_regions(\n                                 infcx,\n-                                TyContext::Location(Location::START),\n                                 &anon_defn_ty,\n                             );\n                             debug!("}, {"sha": "b67de34593f80b3607cdf8ce1dc9431825b90ddb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -15,8 +15,8 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n use borrow_check::nll::constraints::{ConstraintSet, OutlivesConstraint};\n use borrow_check::nll::facts::AllFacts;\n+use borrow_check::nll::region_infer::values::{RegionValueElements, LivenessValues};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n-use borrow_check::nll::region_infer::values::{RegionValues, RegionValueElements};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::LocalWithRegion;\n@@ -35,7 +35,7 @@ use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::{Fallible, NoSolution};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeVariants, RegionVid};\n+use rustc::ty::{self, CanonicalTy, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TypeVariants};\n use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -73,6 +73,7 @@ macro_rules! span_mirbug_and_err {\n mod constraint_conversion;\n mod input_output;\n mod liveness;\n+mod relate_tys;\n \n /// Type checks the given `mir` in the context of the inference\n /// context `infcx`. Returns any region constraints that have yet to\n@@ -121,7 +122,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n-        liveness_constraints: RegionValues::new(elements),\n+        liveness_constraints: LivenessValues::new(elements),\n         outlives_constraints: ConstraintSet::default(),\n         type_tests: Vec::default(),\n     };\n@@ -638,7 +639,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// not otherwise appear in the MIR -- in particular, the\n     /// late-bound regions that it instantiates at call-sites -- and\n     /// hence it must report on their liveness constraints.\n-    crate liveness_constraints: RegionValues<RegionVid>,\n+    crate liveness_constraints: LivenessValues<RegionVid>,\n \n     crate outlives_constraints: ConstraintSet,\n \n@@ -796,16 +797,38 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     }\n \n     fn sub_types(&mut self, sub: Ty<'tcx>, sup: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n-        let param_env = self.param_env;\n-        self.fully_perform_op(\n+        relate_tys::sub_types(\n+            self.infcx,\n+            sub,\n+            sup,\n             locations,\n-            param_env.and(type_op::subtype::Subtype::new(sub, sup)),\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n         )\n     }\n \n     fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> Fallible<()> {\n-        let param_env = self.param_env;\n-        self.fully_perform_op(locations, param_env.and(type_op::eq::Eq::new(b, a)))\n+        relate_tys::eq_types(\n+            self.infcx,\n+            a,\n+            b,\n+            locations,\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n+        )\n+    }\n+\n+    fn eq_canonical_type_and_type(\n+        &mut self,\n+        a: CanonicalTy<'tcx>,\n+        b: Ty<'tcx>,\n+        locations: Locations,\n+    ) -> Fallible<()> {\n+        relate_tys::eq_canonical_type_and_type(\n+            self.infcx,\n+            a,\n+            b,\n+            locations,\n+            self.borrowck_context.as_mut().map(|x| &mut **x),\n+        )\n     }\n \n     fn tcx(&self) -> TyCtxt<'a, 'gcx, 'tcx> {\n@@ -877,20 +900,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::UserAssertTy(ref c_ty, ref local) => {\n-                let local_ty = mir.local_decls()[*local].ty;\n-                let (ty, _) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(stmt.source_info.span, c_ty);\n-                debug!(\n-                    \"check_stmt: user_assert_ty ty={:?} local_ty={:?}\",\n-                    ty, local_ty\n-                );\n-                if let Err(terr) = self.eq_types(ty, local_ty, Locations::All) {\n+            StatementKind::UserAssertTy(c_ty, local) => {\n+                let local_ty = mir.local_decls()[local].ty;\n+                if let Err(terr) = self.eq_canonical_type_and_type(c_ty, local_ty, Locations::All) {\n                     span_mirbug!(\n                         self,\n                         stmt,\n                         \"bad type assert ({:?} = {:?}): {:?}\",\n-                        ty,\n+                        c_ty,\n                         local_ty,\n                         terr\n                     );"}, {"sha": "ac9bf65b61b0fb9b80dc43d1ba2ddac73226c9cc", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "added", "additions": 512, "deletions": 0, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,512 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::constraints::OutlivesConstraint;\n+use borrow_check::nll::type_check::{BorrowCheckContext, Locations};\n+use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::ToRegionVid;\n+use rustc::infer::canonical::{Canonical, CanonicalVarInfos};\n+use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n+use rustc::traits::query::Fallible;\n+use rustc::ty::fold::{TypeFoldable, TypeVisitor};\n+use rustc::ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use rustc::ty::subst::Kind;\n+use rustc::ty::{self, CanonicalTy, CanonicalVar, RegionVid, Ty, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::mem;\n+\n+pub(super) fn sub_types<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\"sub_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Covariant,\n+        locations,\n+        borrowck_context,\n+        ty::Slice::empty(),\n+    ).relate(&a, &b)?;\n+    Ok(())\n+}\n+\n+pub(super) fn eq_types<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: Ty<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\"eq_types(a={:?}, b={:?}, locations={:?})\", a, b, locations);\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Invariant,\n+        locations,\n+        borrowck_context,\n+        ty::Slice::empty(),\n+    ).relate(&a, &b)?;\n+    Ok(())\n+}\n+\n+pub(super) fn eq_canonical_type_and_type<'tcx>(\n+    infcx: &InferCtxt<'_, '_, 'tcx>,\n+    a: CanonicalTy<'tcx>,\n+    b: Ty<'tcx>,\n+    locations: Locations,\n+    borrowck_context: Option<&mut BorrowCheckContext<'_, 'tcx>>,\n+) -> Fallible<()> {\n+    debug!(\n+        \"eq_canonical_type_and_type(a={:?}, b={:?}, locations={:?})\",\n+        a, b, locations\n+    );\n+    let Canonical {\n+        variables: a_variables,\n+        value: a_value,\n+    } = a;\n+    TypeRelating::new(\n+        infcx,\n+        ty::Variance::Invariant,\n+        locations,\n+        borrowck_context,\n+        a_variables,\n+    ).relate(&a_value, &b)?;\n+    Ok(())\n+}\n+\n+struct TypeRelating<'cx, 'bccx: 'cx, 'gcx: 'tcx, 'tcx: 'bccx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+\n+    /// How are we relating `a` and `b`?\n+    ///\n+    /// - covariant means `a <: b`\n+    /// - contravariant means `b <: a`\n+    /// - invariant means `a == b\n+    /// - bivariant means that it doesn't matter\n+    ambient_variance: ty::Variance,\n+\n+    /// When we pass through a set of binders (e.g., when looking into\n+    /// a `fn` type), we push a new bound region scope onto here.  This\n+    /// will contain the instantiated region for each region in those\n+    /// binders. When we then encounter a `ReLateBound(d, br)`, we can\n+    /// use the debruijn index `d` to find the right scope, and then\n+    /// bound region name `br` to find the specific instantiation from\n+    /// within that scope. See `replace_bound_region`.\n+    ///\n+    /// This field stores the instantiations for late-bound regions in\n+    /// the `a` type.\n+    a_scopes: Vec<BoundRegionScope>,\n+\n+    /// Same as `a_scopes`, but for the `b` type.\n+    b_scopes: Vec<BoundRegionScope>,\n+\n+    /// Where (and why) is this relation taking place?\n+    locations: Locations,\n+\n+    /// This will be `Some` when we are running the type check as part\n+    /// of NLL, and `None` if we are running a \"sanity check\".\n+    borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+\n+    /// As we execute, the type on the LHS *may* come from a canonical\n+    /// source. In that case, we will sometimes find a constraint like\n+    /// `?0 = B`, where `B` is a type from the RHS. The first time we\n+    /// find that, we simply record `B` (and the list of scopes that\n+    /// tells us how to *interpret* `B`). The next time we encounter\n+    /// `?0`, then, we can read this value out and use it.\n+    ///\n+    /// One problem: these variables may be in some other universe,\n+    /// how can we enforce that? I guess I could add some kind of\n+    /// \"minimum universe constraint\" that we can feed to the NLL checker.\n+    /// --> also, we know this doesn't happen\n+    canonical_var_values: IndexVec<CanonicalVar, Option<ScopesAndKind<'tcx>>>,\n+}\n+\n+#[derive(Clone, Debug)]\n+struct ScopesAndKind<'tcx> {\n+    scopes: Vec<BoundRegionScope>,\n+    kind: Kind<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, Default)]\n+struct BoundRegionScope {\n+    map: FxHashMap<ty::BoundRegion, RegionVid>,\n+}\n+\n+#[derive(Copy, Clone)]\n+struct UniversallyQuantified(bool);\n+\n+impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelating<'cx, 'bccx, 'gcx, 'tcx> {\n+    fn new(\n+        infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+        ambient_variance: ty::Variance,\n+        locations: Locations,\n+        borrowck_context: Option<&'cx mut BorrowCheckContext<'bccx, 'tcx>>,\n+        canonical_var_infos: CanonicalVarInfos<'tcx>,\n+    ) -> Self {\n+        let canonical_var_values = IndexVec::from_elem_n(None, canonical_var_infos.len());\n+        Self {\n+            infcx,\n+            ambient_variance,\n+            borrowck_context,\n+            locations,\n+            canonical_var_values,\n+            a_scopes: vec![],\n+            b_scopes: vec![],\n+        }\n+    }\n+\n+    fn ambient_covariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Covariant | ty::Variance::Invariant => true,\n+            ty::Variance::Contravariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn ambient_contravariance(&self) -> bool {\n+        match self.ambient_variance {\n+            ty::Variance::Contravariant | ty::Variance::Invariant => true,\n+            ty::Variance::Covariant | ty::Variance::Bivariant => false,\n+        }\n+    }\n+\n+    fn create_scope(\n+        &mut self,\n+        value: &ty::Binder<impl TypeFoldable<'tcx>>,\n+        universally_quantified: UniversallyQuantified,\n+    ) -> BoundRegionScope {\n+        let mut scope = BoundRegionScope::default();\n+        value.skip_binder().visit_with(&mut ScopeInstantiator {\n+            infcx: self.infcx,\n+            target_index: ty::INNERMOST,\n+            universally_quantified,\n+            bound_region_scope: &mut scope,\n+        });\n+        scope\n+    }\n+\n+    fn replace_bound_region(\n+        &self,\n+        universal_regions: &UniversalRegions<'tcx>,\n+        r: ty::Region<'tcx>,\n+        scopes: &[BoundRegionScope],\n+    ) -> RegionVid {\n+        match r {\n+            ty::ReLateBound(debruijn, br) => {\n+                // The debruijn index is a \"reverse index\" into the\n+                // scopes listing. So when we have INNERMOST (0), we\n+                // want the *last* scope pushed, and so forth.\n+                let debruijn_index = debruijn.index() - ty::INNERMOST.index();\n+                let scope = &scopes[scopes.len() - debruijn_index - 1];\n+\n+                // Find this bound region in that scope to map to a\n+                // particular region.\n+                scope.map[br]\n+            }\n+\n+            ty::ReVar(v) => *v,\n+\n+            _ => universal_regions.to_region_vid(r),\n+        }\n+    }\n+\n+    fn push_outlives(&mut self, sup: RegionVid, sub: RegionVid) {\n+        debug!(\"push_outlives({:?}: {:?})\", sup, sub);\n+\n+        if let Some(borrowck_context) = &mut self.borrowck_context {\n+            borrowck_context\n+                .constraints\n+                .outlives_constraints\n+                .push(OutlivesConstraint {\n+                    sup,\n+                    sub,\n+                    locations: self.locations,\n+                });\n+\n+            // FIXME all facts!\n+        }\n+    }\n+\n+    fn equate_var(\n+        &mut self,\n+        var: CanonicalVar,\n+        b_kind: Kind<'tcx>,\n+    ) -> RelateResult<'tcx, Kind<'tcx>> {\n+        debug!(\"equate_var(var={:?}, b_kind={:?})\", var, b_kind);\n+\n+        // We only encounter canonical variables when equating.\n+        assert_eq!(self.ambient_variance, ty::Variance::Invariant);\n+\n+        // The canonical variable already had a value. Equate that\n+        // value with `b`.\n+        let old_value = self.canonical_var_values[var].clone();\n+        if let Some(ScopesAndKind { scopes, kind }) = old_value {\n+            debug!(\"equate_var: installing kind={:?} scopes={:?}\", kind, scopes);\n+            let old_a_scopes = mem::replace(&mut self.a_scopes, scopes);\n+            let result = self.relate(&kind, &b_kind);\n+            self.a_scopes = old_a_scopes;\n+            debug!(\"equate_var: complete, result = {:?}\", result);\n+            return result;\n+        }\n+\n+        // Not yet. Capture the value from the RHS and carry on.\n+        self.canonical_var_values[var] = Some(ScopesAndKind {\n+            scopes: self.b_scopes.clone(),\n+            kind: b_kind,\n+        });\n+        debug!(\n+            \"equate_var: capturing value {:?}\",\n+            self.canonical_var_values[var]\n+        );\n+\n+        // FIXME -- technically, we should add some sort of\n+        // assertion that this value can be named in the universe\n+        // of the canonical variable. But in practice these\n+        // canonical variables only arise presently in cases where\n+        // they are in the root universe and the main typeck has\n+        // ensured there are no universe errors. So we just kind\n+        // of over look this right now.\n+        Ok(b_kind)\n+    }\n+}\n+\n+impl<'cx, 'bccx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx>\n+    for TypeRelating<'cx, 'bccx, 'gcx, 'tcx>\n+{\n+    fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"nll::subtype\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        variance: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        debug!(\n+            \"relate_with_variance(variance={:?}, a={:?}, b={:?})\",\n+            variance, a, b\n+        );\n+\n+        let old_ambient_variance = self.ambient_variance;\n+        self.ambient_variance = self.ambient_variance.xform(variance);\n+\n+        debug!(\n+            \"relate_with_variance: ambient_variance = {:?}\",\n+            self.ambient_variance\n+        );\n+\n+        let r = self.relate(a, b)?;\n+\n+        self.ambient_variance = old_ambient_variance;\n+\n+        debug!(\"relate_with_variance: r={:?}\", r);\n+\n+        Ok(r)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        // Watch out for the case that we are matching a `?T` against the\n+        // right-hand side.\n+        if let ty::TyInfer(ty::CanonicalTy(var)) = a.sty {\n+            self.equate_var(var, b.into())?;\n+            Ok(a)\n+        } else {\n+            debug!(\n+                \"tys(a={:?}, b={:?}, variance={:?})\",\n+                a, b, self.ambient_variance\n+            );\n+\n+            relate::super_relate_tys(self, a, b)\n+        }\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        if let Some(&mut BorrowCheckContext {\n+            universal_regions, ..\n+        }) = self.borrowck_context\n+        {\n+            if let ty::ReCanonical(var) = a {\n+                self.equate_var(*var, b.into())?;\n+                return Ok(a);\n+            }\n+\n+            debug!(\n+                \"regions(a={:?}, b={:?}, variance={:?})\",\n+                a, b, self.ambient_variance\n+            );\n+\n+            let v_a = self.replace_bound_region(universal_regions, a, &self.a_scopes);\n+            let v_b = self.replace_bound_region(universal_regions, b, &self.b_scopes);\n+\n+            debug!(\"regions: v_a = {:?}\", v_a);\n+            debug!(\"regions: v_b = {:?}\", v_b);\n+\n+            if self.ambient_covariance() {\n+                // Covariance: a <= b. Hence, `b: a`.\n+                self.push_outlives(v_b, v_a);\n+            }\n+\n+            if self.ambient_contravariance() {\n+                // Contravariant: b <= a. Hence, `a: b`.\n+                self.push_outlives(v_a, v_b);\n+            }\n+        }\n+\n+        Ok(a)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        // We want that\n+        //\n+        // ```\n+        // for<'a> fn(&'a u32) -> &'a u32 <:\n+        //   fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // but not\n+        //\n+        // ```\n+        // fn(&'a u32) -> &'a u32 <:\n+        //   for<'b> fn(&'b u32) -> &'b u32\n+        // ```\n+        //\n+        // We therefore proceed as follows:\n+        //\n+        // - Instantiate binders on `b` universally, yielding a universe U1.\n+        // - Instantiate binders on `a` existentially in U1.\n+\n+        debug!(\n+            \"binders({:?}: {:?}, ambient_variance={:?})\",\n+            a, b, self.ambient_variance\n+        );\n+\n+        if self.ambient_covariance() {\n+            // Covariance, so we want `for<..> A <: for<..> B` --\n+            // therefore we compare any instantiation of A (i.e., A\n+            // instantiated with existentials) against every\n+            // instantiation of B (i.e., B instantiated with\n+            // universals).\n+\n+            let b_scope = self.create_scope(b, UniversallyQuantified(true));\n+            let a_scope = self.create_scope(a, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (existential)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (universal)\", b_scope);\n+\n+            self.b_scopes.push(b_scope);\n+            self.a_scopes.push(a_scope);\n+\n+            // FIXME -- to be fully correct, we would set the ambient\n+            // variance to Covariant here. As is, we will sometimes\n+            // propagate down an ambient variance of Equal -- this in\n+            // turn causes us to report errors in some cases where\n+            // types perhaps *ought* to be equal. See the\n+            // `hr-fn-aau-eq-abu.rs` test for an example. Fixing this\n+            // though is a bit nontrivial: in particular, it would\n+            // require a more involved handling of canonical\n+            // variables, since we would no longer be able to rely on\n+            // having an `==` relationship for canonical variables.\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        if self.ambient_contravariance() {\n+            // Contravariance, so we want `for<..> A :> for<..> B`\n+            // -- therefore we compare every instantiation of A (i.e.,\n+            // A instantiated with universals) against any\n+            // instantiation of B (i.e., B instantiated with\n+            // existentials). Opposite of above.\n+\n+            let a_scope = self.create_scope(a, UniversallyQuantified(true));\n+            let b_scope = self.create_scope(b, UniversallyQuantified(false));\n+\n+            debug!(\"binders: a_scope = {:?} (universal)\", a_scope);\n+            debug!(\"binders: b_scope = {:?} (existential)\", b_scope);\n+\n+            self.a_scopes.push(a_scope);\n+            self.b_scopes.push(b_scope);\n+\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+\n+            self.b_scopes.pop().unwrap();\n+            self.a_scopes.pop().unwrap();\n+        }\n+\n+        Ok(a.clone())\n+    }\n+}\n+\n+struct ScopeInstantiator<'cx, 'gcx: 'cx + 'tcx, 'tcx: 'cx> {\n+    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n+    // The debruijn index of the scope we are instantiating.\n+    target_index: ty::DebruijnIndex,\n+    universally_quantified: UniversallyQuantified,\n+    bound_region_scope: &'cx mut BoundRegionScope,\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'cx, 'gcx, 'tcx> {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.target_index.shift_in(1);\n+        t.super_visit_with(self);\n+        self.target_index.shift_out(1);\n+\n+        false\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        let ScopeInstantiator {\n+            infcx,\n+            universally_quantified,\n+            ..\n+        } = *self;\n+\n+        match r {\n+            ty::ReLateBound(debruijn, br) if *debruijn == self.target_index => {\n+                self.bound_region_scope.map.entry(*br).or_insert_with(|| {\n+                    let origin = if universally_quantified.0 {\n+                        NLLRegionVariableOrigin::BoundRegion(infcx.create_subuniverse())\n+                    } else {\n+                        NLLRegionVariableOrigin::Existential\n+                    };\n+                    infcx.next_nll_region_var(origin).to_region_vid()\n+                });\n+            }\n+\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+}"}, {"sha": "5de316a66403301ab18a43c21d08e479a17c005a", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -487,7 +487,7 @@ enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n         adt_def: &'tcx ty::AdtDef,\n-        variants: BitVector,\n+        variants: BitVector<usize>,\n     },\n \n     // test the branches of enum"}, {"sha": "3ff209c872fac72f04c6763e789fbe90efa76307", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub fn add_variants_to_switch<'pat>(&mut self,\n                                         test_place: &Place<'tcx>,\n                                         candidate: &Candidate<'pat, 'tcx>,\n-                                        variants: &mut BitVector)\n+                                        variants: &mut BitVector<usize>)\n                                         -> bool\n     {\n         let match_pair = match candidate.match_pairs.iter().find(|mp| mp.place == *test_place) {"}, {"sha": "382248c2d15dca3479c31234fabc94029dd15922", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -27,6 +27,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n #![feature(fs_read_write)]\n+#![feature(in_band_lifetimes)]\n #![feature(macro_vis_matcher)]\n #![feature(exhaustive_patterns)]\n #![feature(range_contains)]\n@@ -36,6 +37,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(specialization)]\n #![feature(try_trait)]\n #![feature(unicode_internals)]\n+#![feature(step_trait)]\n \n #![recursion_limit=\"256\"]\n "}, {"sha": "5f05783b15ccedca6a87c605a8e0facb095297f8", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -231,7 +231,7 @@ pub struct InliningMap<'tcx> {\n \n     // Contains one bit per mono item in the `targets` field. That bit\n     // is true if that mono item needs to be inlined into every CGU.\n-    inlines: BitVector,\n+    inlines: BitVector<usize>,\n }\n \n impl<'tcx> InliningMap<'tcx> {"}, {"sha": "6a9258fe2c918eb5d4ae9b1574fdb8420c819ac0", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -292,8 +292,10 @@ fn make_generator_state_argument_indirect<'a, 'tcx>(\n     DerefArgVisitor.visit_mir(mir);\n }\n \n-fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n-                            mir: &mut Mir<'tcx>) -> Local {\n+fn replace_result_variable<'tcx>(\n+    ret_ty: Ty<'tcx>,\n+    mir: &mut Mir<'tcx>,\n+) -> Local {\n     let source_info = source_info(mir);\n     let new_ret = LocalDecl {\n         mutability: Mutability::Mut,\n@@ -306,7 +308,7 @@ fn replace_result_variable<'tcx>(ret_ty: Ty<'tcx>,\n     };\n     let new_ret_local = Local::new(mir.local_decls.len());\n     mir.local_decls.push(new_ret);\n-    mir.local_decls.swap(0, new_ret_local.index());\n+    mir.local_decls.swap(RETURN_PLACE, new_ret_local);\n \n     RenameLocalVisitor {\n         from: RETURN_PLACE,"}, {"sha": "8a12a604ef2023156870e908ddcf9e3447019959", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -116,7 +116,7 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     param_env: ty::ParamEnv<'tcx>,\n     local_qualif: IndexVec<Local, Option<Qualif>>,\n     qualif: Qualif,\n-    const_fn_arg_vars: BitVector,\n+    const_fn_arg_vars: BitVector<Local>,\n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -344,7 +344,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                         // Make sure there are no extra unassigned variables.\n                         self.qualif = Qualif::NOT_CONST;\n                         for index in mir.vars_iter() {\n-                            if !self.const_fn_arg_vars.contains(index.index()) {\n+                            if !self.const_fn_arg_vars.contains(index) {\n                                 debug!(\"unassigned variable {:?}\", index);\n                                 self.assign(&Place::Local(index), Location {\n                                     block: bb,\n@@ -1021,7 +1021,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n         // Check the allowed const fn argument forms.\n         if let (Mode::ConstFn, &Place::Local(index)) = (self.mode, dest) {\n             if self.mir.local_kind(index) == LocalKind::Var &&\n-               self.const_fn_arg_vars.insert(index.index()) &&\n+               self.const_fn_arg_vars.insert(index) &&\n                !self.tcx.sess.features_untracked().const_let {\n \n                 // Direct use of an argument is permitted."}, {"sha": "a7ef93eaec6b97c6fd814b996b692c3af7bdecc0", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -11,7 +11,6 @@\n use rustc::ty::TyCtxt;\n use rustc::mir::*;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::indexed_vec::Idx;\n use transform::{MirPass, MirSource};\n use util::patch::MirPatch;\n \n@@ -42,9 +41,12 @@ impl MirPass for RemoveNoopLandingPads {\n }\n \n impl RemoveNoopLandingPads {\n-    fn is_nop_landing_pad(&self, bb: BasicBlock, mir: &Mir, nop_landing_pads: &BitVector)\n-                          -> bool\n-    {\n+    fn is_nop_landing_pad(\n+        &self,\n+        bb: BasicBlock,\n+        mir: &Mir,\n+        nop_landing_pads: &BitVector<BasicBlock>,\n+    ) -> bool {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n                 StatementKind::ReadForMatch(_) |\n@@ -79,8 +81,8 @@ impl RemoveNoopLandingPads {\n             TerminatorKind::SwitchInt { .. } |\n             TerminatorKind::FalseEdges { .. } |\n             TerminatorKind::FalseUnwind { .. } => {\n-                terminator.successors().all(|succ| {\n-                    nop_landing_pads.contains(succ.index())\n+                terminator.successors().all(|&succ| {\n+                    nop_landing_pads.contains(succ)\n                 })\n             },\n             TerminatorKind::GeneratorDrop |\n@@ -117,7 +119,7 @@ impl RemoveNoopLandingPads {\n         for bb in postorder {\n             debug!(\"  processing {:?}\", bb);\n             for target in mir[bb].terminator_mut().successors_mut() {\n-                if *target != resume_block && nop_landing_pads.contains(target.index()) {\n+                if *target != resume_block && nop_landing_pads.contains(*target) {\n                     debug!(\"    folding noop jump to {:?} to resume block\", target);\n                     *target = resume_block;\n                     jumps_folded += 1;\n@@ -138,7 +140,7 @@ impl RemoveNoopLandingPads {\n \n             let is_nop_landing_pad = self.is_nop_landing_pad(bb, mir, &nop_landing_pads);\n             if is_nop_landing_pad {\n-                nop_landing_pads.insert(bb.index());\n+                nop_landing_pads.insert(bb);\n             }\n             debug!(\"    is_nop_landing_pad({:?}) = {}\", bb, is_nop_landing_pad);\n         }"}, {"sha": "6b8d5a1489388403fa25a5f42d7f25cbc5d6590b", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -288,15 +288,15 @@ impl MirPass for SimplifyLocals {\n         let mut marker = DeclMarker { locals: BitVector::new(mir.local_decls.len()) };\n         marker.visit_mir(mir);\n         // Return pointer and arguments are always live\n-        marker.locals.insert(RETURN_PLACE.index());\n+        marker.locals.insert(RETURN_PLACE);\n         for arg in mir.args_iter() {\n-            marker.locals.insert(arg.index());\n+            marker.locals.insert(arg);\n         }\n \n         // We may need to keep dead user variables live for debuginfo.\n         if tcx.sess.opts.debuginfo == FullDebugInfo {\n             for local in mir.vars_iter() {\n-                marker.locals.insert(local.index());\n+                marker.locals.insert(local);\n             }\n         }\n \n@@ -308,35 +308,38 @@ impl MirPass for SimplifyLocals {\n }\n \n /// Construct the mapping while swapping out unused stuff out from the `vec`.\n-fn make_local_map<'tcx, I: Idx, V>(vec: &mut IndexVec<I, V>, mask: BitVector) -> Vec<usize> {\n-    let mut map: Vec<usize> = ::std::iter::repeat(!0).take(vec.len()).collect();\n-    let mut used = 0;\n+fn make_local_map<'tcx, V>(\n+    vec: &mut IndexVec<Local, V>,\n+    mask: BitVector<Local>,\n+) -> IndexVec<Local, Option<Local>> {\n+    let mut map: IndexVec<Local, Option<Local>> = IndexVec::from_elem(None, &*vec);\n+    let mut used = Local::new(0);\n     for alive_index in mask.iter() {\n-        map[alive_index] = used;\n+        map[alive_index] = Some(used);\n         if alive_index != used {\n             vec.swap(alive_index, used);\n         }\n-        used += 1;\n+        used.increment_by(1);\n     }\n-    vec.truncate(used);\n+    vec.truncate(used.index());\n     map\n }\n \n struct DeclMarker {\n-    pub locals: BitVector,\n+    pub locals: BitVector<Local>,\n }\n \n impl<'tcx> Visitor<'tcx> for DeclMarker {\n     fn visit_local(&mut self, local: &Local, ctx: PlaceContext<'tcx>, _: Location) {\n         // ignore these altogether, they get removed along with their otherwise unused decls.\n         if ctx != PlaceContext::StorageLive && ctx != PlaceContext::StorageDead {\n-            self.locals.insert(local.index());\n+            self.locals.insert(*local);\n         }\n     }\n }\n \n struct LocalUpdater {\n-    map: Vec<usize>,\n+    map: IndexVec<Local, Option<Local>>,\n }\n \n impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n@@ -345,14 +348,14 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater {\n         data.statements.retain(|stmt| {\n             match stmt.kind {\n                 StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => {\n-                    self.map[l.index()] != !0\n+                    self.map[l].is_some()\n                 }\n                 _ => true\n             }\n         });\n         self.super_basic_block_data(block, data);\n     }\n     fn visit_local(&mut self, l: &mut Local, _: PlaceContext<'tcx>, _: Location) {\n-        *l = Local::new(self.map[l.index()]);\n+        *l = self.map[*l].unwrap();\n     }\n }"}, {"sha": "adc0249a40cfcac3bb7e37e82a9b10c32dee8b9c", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -34,15 +34,15 @@ fn main() {\n // | '_#4r    | Local    | ['_#4r]\n // |\n // | Inferred Region Values\n-// | '_#0r    | {'_#0r, bb0[0..=1]}\n-// | '_#1r    | {'_#1r, bb0[0..=1]}\n-// | '_#2r    | {'_#2r, bb0[0..=1]}\n-// | '_#3r    | {'_#3r, bb0[0..=1]}\n-// | '_#4r    | {'_#4r, bb0[0..=1]}\n-// | '_#5r    | {'_#1r, bb0[0..=1]}\n-// | '_#6r    | {'_#2r, bb0[0..=1]}\n-// | '_#7r    | {'_#1r, bb0[0..=1]}\n-// | '_#8r    | {'_#3r, bb0[0..=1]}\n+// | '_#0r    | U0 | {bb0[0..=127], '_#0r}\n+// | '_#1r    | U0 | {bb0[0..=127], '_#1r}\n+// | '_#2r    | U0 | {bb0[0..=127], '_#2r}\n+// | '_#3r    | U0 | {bb0[0..=127], '_#3r}\n+// | '_#4r    | U0 | {bb0[0..=127], '_#4r}\n+// | '_#5r    | U0 | {bb0[0..=127], '_#1r}\n+// | '_#6r    | U0 | {bb0[0..=127], '_#2r}\n+// | '_#7r    | U0 | {bb0[0..=127], '_#1r}\n+// | '_#8r    | U0 | {bb0[0..=127], '_#3r}\n // |\n // ...\n // fn use_x(_1: &'_#5r mut i32, _2: &'_#6r u32, _3: &'_#7r u32, _4: &'_#8r u32) -> bool {"}, {"sha": "8a7ea8962fc5d6ba21f626d5fd7d08d058ec2cf9", "filename": "src/test/mir-opt/nll/reborrow-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Freborrow-basic.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -28,9 +28,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#7r    | {bb0[4], bb0[8..=17]}\n+// | '_#7r    | U0 | {bb0[4], bb0[8..=17]}\n // ...\n-// | '_#9r    | {bb0[10], bb0[14..=17]}\n+// | '_#9r    | U0 | {bb0[10], bb0[14..=17]}\n // ...\n // let _4: &'_#9r mut i32;\n // ..."}, {"sha": "e554024efef437488e1dd0c4795b1b073033ec1c", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -32,9 +32,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#2r    | {bb2[0..=3], bb3[0..=1]}\n-// | '_#3r    | {bb2[1..=3], bb3[0..=1]}\n-// | '_#4r    | {bb2[3], bb3[0..=1]}\n+// | '_#2r    | U0 | {bb2[0..=3], bb3[0..=1]}\n+// | '_#3r    | U0 | {bb2[1..=3], bb3[0..=1]}\n+// | '_#4r    | U0 | {bb2[3], bb3[0..=1]}\n // END rustc.main.nll.0.mir\n // START rustc.main.nll.0.mir\n // let _6: &'_#4r usize;"}, {"sha": "92225369c92711806bdc6a8bd65f132df1dcef5e", "filename": "src/test/ui/borrowck/mut-borrow-in-loop.nll.stderr", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-in-loop.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -2,28 +2,37 @@ error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:20:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:26:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error[E0499]: cannot borrow `*arg` as mutable more than once at a time\n   --> $DIR/mut-borrow-in-loop.rs:33:25\n    |\n LL |             (self.func)(arg) //~ ERROR cannot borrow\n-   |             ------------^^^-\n-   |             |           |\n-   |             |           mutable borrow starts here in previous iteration of loop\n-   |             borrow later used here\n+   |                         ^^^ mutable borrow starts here in previous iteration of loop\n+   |\n+note: borrowed value must be valid for the lifetime 'a as defined on the impl at 17:6...\n+  --> $DIR/mut-borrow-in-loop.rs:17:6\n+   |\n+LL | impl<'a, T : 'a> FuncWrapper<'a, T> {\n+   |      ^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "c6f8d2e519ca1c7909aca8cb49c3c354cb6c6bd7", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,19 +10,21 @@ warning: not reporting region error due to nll\n LL |         self.x.iter().map(|a| a.0)\n    |                ^^^^\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/static-return-lifetime-infered.rs:17:9\n    |\n LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n-   |                         - let's call the lifetime of this reference `'1`\n+   |                         ----- `self` is a reference that is only valid in the closure body\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^ cast requires that `'1` must outlive `'static`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` escapes the closure body here\n \n-error: unsatisfied lifetime constraints\n+error: borrowed data escapes outside of closure\n   --> $DIR/static-return-lifetime-infered.rs:21:9\n    |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+   |                        -------- `self` is a reference that is only valid in the closure body\n LL |         self.x.iter().map(|a| a.0)\n-   |         ^^^^^^ cast requires that `'a` must outlive `'static`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` escapes the closure body here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "1d2b26603426f2b134c345cfe67abd109b1a1550", "filename": "src/test/ui/issue-40288-2.nll.stderr", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fissue-40288-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fissue-40288-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-40288-2.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -35,20 +35,22 @@ LL |     let mut out = Struct { head: x, _tail: [()] };\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0621]: explicit lifetime required in the type of `y`\n-  --> $DIR/issue-40288-2.rs:14:9\n+  --> $DIR/issue-40288-2.rs:17:9\n    |\n LL | fn lifetime_transmute_slice<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n    |                                                      - consider changing the type of `y` to `&'a T`\n-LL |     let mut out = [x];\n-   |         ^^^^^^^ lifetime `'a` required\n+...\n+LL |         slice[0] = y;\n+   |         ^^^^^^^^^^^^ lifetime `'a` required\n \n error[E0621]: explicit lifetime required in the type of `y`\n-  --> $DIR/issue-40288-2.rs:29:9\n+  --> $DIR/issue-40288-2.rs:32:9\n    |\n LL | fn lifetime_transmute_struct<'a, T: ?Sized>(x: &'a T, y: &T) -> &'a T {\n    |                                                       - consider changing the type of `y` to `&'a T`\n-LL |     let mut out = Struct { head: x, _tail: [()] };\n-   |         ^^^^^^^ lifetime `'a` required\n+...\n+LL |         dst.head = y;\n+   |         ^^^^^^^^^^^^ lifetime `'a` required\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4d9517eca6032dfa5acd28382faae51a2620ba70", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-3.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-3.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,12 +5,12 @@ LL |     if x > y { x } else { y } //~ ERROR explicit lifetime\n    |                           ^\n \n error[E0621]: explicit lifetime required in parameter type\n-  --> $DIR/ex1-return-one-existing-name-if-else-3.rs:11:13\n+  --> $DIR/ex1-return-one-existing-name-if-else-3.rs:11:16\n    |\n LL | fn foo<'a>((x, y): (&'a i32, &i32)) -> &'a i32 {\n-   |            -^----\n-   |            ||\n-   |            |lifetime `'a` required\n+   |            ----^-\n+   |            |   |\n+   |            |   lifetime `'a` required\n    |            consider changing type to `(&'a i32, &'a i32)`\n \n error: aborting due to previous error"}, {"sha": "087c9eb389b55bad57f2fc2e9893a80886fd8c69", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name-2.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0621]: explicit lifetime required in the type of `x`\n LL | fn foo<'a>(x: Ref<i32>, y: &mut Vec<Ref<'a, i32>>) {\n    |            - consider changing the type of `x` to `Ref<'a, i32>`\n LL |     y.push(x); //~ ERROR explicit lifetime\n-   |     ^ lifetime `'a` required\n+   |     ^^^^^^^^^ lifetime `'a` required\n \n error: aborting due to previous error\n "}, {"sha": "80192af221755b8ca2ca6f07aedc7741c4c9d6c9", "filename": "src/test/ui/lifetime-errors/ex2a-push-one-existing-name.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2a-push-one-existing-name.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0621]: explicit lifetime required in the type of `y`\n LL | fn foo<'a>(x: &mut Vec<Ref<'a, i32>>, y: Ref<i32>) {\n    |                                       - consider changing the type of `y` to `Ref<'a, i32>`\n LL |     x.push(y); //~ ERROR explicit lifetime\n-   |     ^ lifetime `'a` required\n+   |     ^^^^^^^^^ lifetime `'a` required\n \n error: aborting due to previous error\n "}, {"sha": "4b4fdde940f7e26f1d226a7380407dd3fe1635a2", "filename": "src/test/ui/lifetime-errors/ex2b-push-no-existing-names.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2b-push-no-existing-names.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo(x: &mut Vec<Ref<i32>>, y: Ref<i32>) {\n    |                    --------      -------- these two types are declared with different lifetimes...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "f55fd291249c6aa9921ee4e390b7676ce16a7b22", "filename": "src/test/ui/lifetime-errors/ex2c-push-inference-variable.nll.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2c-push-inference-variable.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,12 +5,13 @@ LL |     let z = Ref { data: y.data };\n    |             ^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex2c-push-inference-variable.rs:16:9\n+  --> $DIR/ex2c-push-inference-variable.rs:17:5\n    |\n LL | fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n    |                                   ------------      ------------ these two types are declared with different lifetimes...\n LL |     let z = Ref { data: y.data };\n-   |         ^ ...but data from `y` flows into `x` here\n+LL |     x.push(z); //~ ERROR lifetime mismatch\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "85b5f3e890008554a9d802d335c61cf478ba8d44", "filename": "src/test/ui/lifetime-errors/ex2d-push-inference-variable-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2d-push-inference-variable-2.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,12 +5,13 @@ LL |     let b = Ref { data: y.data };\n    |             ^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex2d-push-inference-variable-2.rs:16:9\n+  --> $DIR/ex2d-push-inference-variable-2.rs:18:5\n    |\n LL | fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n    |                                   ------------      ------------ these two types are declared with different lifetimes...\n-LL |     let a: &mut Vec<Ref<i32>> = x; //~ ERROR lifetime mismatch\n-   |         ^ ...but data from `y` flows into `x` here\n+...\n+LL |     a.push(b);\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "7e5182a5d30c940b2f2363d950dafec273167d92", "filename": "src/test/ui/lifetime-errors/ex2e-push-inference-variable-3.nll.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex2e-push-inference-variable-3.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,12 +5,13 @@ LL |     let b = Ref { data: y.data };\n    |             ^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex2e-push-inference-variable-3.rs:16:9\n+  --> $DIR/ex2e-push-inference-variable-3.rs:18:5\n    |\n LL | fn foo<'a, 'b, 'c>(x: &'a mut Vec<Ref<'b, i32>>, y: Ref<'c, i32>) {\n    |                                   ------------      ------------ these two types are declared with different lifetimes...\n-LL |     let a: &mut Vec<Ref<i32>> = x; //~ ERROR lifetime mismatch\n-   |         ^ ...but data from `y` flows into `x` here\n+...\n+LL |     Vec::push(a, b);\n+   |     ^^^^^^^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "36317c4570b982fe73a104fc6fcfb02d2d1f15bd", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-2.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-2.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,12 +5,12 @@ LL |     *v = x; //~ ERROR lifetime mismatch\n    |          ^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-2.rs:11:14\n+  --> $DIR/ex3-both-anon-regions-2.rs:12:5\n    |\n LL | fn foo(&mut (ref mut v, w): &mut (&u8, &u8), x: &u8) {\n-   |              ^^^^^^^^^            ---           --- these two types are declared with different lifetimes...\n-   |              |\n-   |              ...but data from `x` flows here\n+   |                                   ---           --- these two types are declared with different lifetimes...\n+LL |     *v = x; //~ ERROR lifetime mismatch\n+   |     ^^^^^^ ...but data from `x` flows here\n \n error: aborting due to previous error\n "}, {"sha": "c43c4ce3a0c21fa5080eab79a0596133b418754c", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-3.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-3.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -11,20 +11,20 @@ LL |     z.push((x,y)); //~ ERROR lifetime mismatch\n    |               ^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-3.rs:11:33\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:5\n    |\n LL | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                     ---         ^       --- these two types are declared with different lifetimes...\n-   |                                 |\n-   |                                 ...but data flows into `z` here\n+   |                     ---                 --- these two types are declared with different lifetimes...\n+LL |     z.push((x,y)); //~ ERROR lifetime mismatch\n+   |     ^^^^^^^^^^^^^ ...but data flows into `z` here\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/ex3-both-anon-regions-3.rs:11:33\n+  --> $DIR/ex3-both-anon-regions-3.rs:12:5\n    |\n LL | fn foo(z: &mut Vec<(&u8,&u8)>, (x, y): (&u8, &u8)) {\n-   |                         ---     ^            --- these two types are declared with different lifetimes...\n-   |                                 |\n-   |                                 ...but data flows into `z` here\n+   |                         ---                  --- these two types are declared with different lifetimes...\n+LL |     z.push((x,y)); //~ ERROR lifetime mismatch\n+   |     ^^^^^^^^^^^^^ ...but data flows into `z` here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "2a5729952e33d3e691dd50017c730bb4bb3a9997", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-earlybound-regions.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-earlybound-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-earlybound-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-earlybound-regions.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -11,7 +11,7 @@ LL | fn foo<'a, 'b>(mut x: Vec<Ref<'a>>, y: Ref<'b>)\n    |                           -------      ------- these two types are declared with different lifetimes...\n ...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "6efc8d3da06776ad6cd66b96c24d1e98b6d1e066", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs-latebound-regions.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-latebound-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-latebound-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs-latebound-regions.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo<'a, 'b>(mut x: Vec<Ref<'a>>, y: Ref<'b>) {\n    |                           -------      ------- these two types are declared with different lifetimes...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "0f555020822cb42f4559e21eedc3de6336237aee", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-both-are-structs.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-both-are-structs.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo(mut x: Vec<Ref>, y: Ref) {\n    |                   ---      --- these two types are declared with different lifetimes...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "4400644e7fb65299d62adba5139f1cbb574021ad", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-latebound-regions.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-latebound-regions.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo<'a,'b>(x: &mut Vec<&'a u8>, y: &'b u8) {\n    |                           ------      ------ these two types are declared with different lifetimes...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "a0aa1e28d9bc03183b388e96df22287287417686", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-fn-items.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo(x:fn(&u8, &u8), y: Vec<&u8>, z: &u8) {\n    |                               ---      --- these two types are declared with different lifetimes...\n LL |   y.push(z); //~ ERROR lifetime mismatch\n-   |   ^ ...but data from `z` flows into `y` here\n+   |   ^^^^^^^^^ ...but data from `z` flows into `y` here\n \n error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-fn-items.rs:11:3"}, {"sha": "5d4492701beb33209beab494a81da78dd657c043", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-impl-items.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-impl-items.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL |     fn foo(x: &mut Vec<&u8>, y: &u8) {\n    |                        ---      --- these two types are declared with different lifetimes...\n LL |         x.push(y); //~ ERROR lifetime mismatch\n-   |         ^ ...but data from `y` flows into `x` here\n+   |         ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "37b79cee72f75bec1baf25a23ad67c05cb4542c1", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-trait-objects.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo(x:Box<Fn(&u8, &u8)> , y: Vec<&u8>, z: &u8) {\n    |                 ---  --- these two types are declared with different lifetimes...\n LL |   y.push(z); //~ ERROR lifetime mismatch\n-   |   ^ ...but data from `z` flows into `y` here\n+   |   ^^^^^^^^^ ...but data from `z` flows into `y` here\n \n error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-trait-objects.rs:11:3"}, {"sha": "c11d81a4c13daf9336e2cd9e861c7b4b9bc52eed", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -10,7 +10,7 @@ error[E0623]: lifetime mismatch\n LL | fn foo(x: &mut Vec<&u8>, y: &u8) {\n    |                    ---      --- these two types are declared with different lifetimes...\n LL |     x.push(y); //~ ERROR lifetime mismatch\n-   |     ^ ...but data from `y` flows into `x` here\n+   |     ^^^^^^^^^ ...but data from `y` flows into `x` here\n \n error: aborting due to previous error\n "}, {"sha": "b879f9a33986d0b8c184a73f28d9378f38fa3aaa", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -52,9 +52,9 @@ fn supply<'a, 'b, 'c>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>, cell_c: Cell\n         cell_c,\n         |_outlives1, _outlives2, _outlives3, x, y| {\n             // Only works if 'x: 'y:\n-            let p = x.get(); //~ ERROR\n+            let p = x.get();\n             //~^ WARN not reporting region error due to nll\n-            demand_y(x, y, p)\n+            demand_y(x, y, p) //~ ERROR\n         },\n     );\n }"}, {"sha": "a7a50a3a029817e099b4a2433a4ac47608c4f135", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -1,28 +1,28 @@\n warning: not reporting region error due to nll\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n    |\n-LL |             let p = x.get(); //~ ERROR\n+LL |             let p = x.get();\n    |                     ^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-approximated-fail-no-postdom.rs:55:21\n+  --> $DIR/propagate-approximated-fail-no-postdom.rs:57:13\n    |\n LL |         |_outlives1, _outlives2, _outlives3, x, y| {\n    |          ----------              ---------- lifetime `'2` appears in this argument\n    |          |\n    |          lifetime `'1` appears in this argument\n-LL |             // Only works if 'x: 'y:\n-LL |             let p = x.get(); //~ ERROR\n-   |                     ^^^^^^^ argument requires that `'1` must outlive `'2`\n+...\n+LL |             demand_y(x, y, p) //~ ERROR\n+   |             ^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-approximated-fail-no-postdom.rs:53:9\n    |\n LL | /         |_outlives1, _outlives2, _outlives3, x, y| {\n LL | |             // Only works if 'x: 'y:\n-LL | |             let p = x.get(); //~ ERROR\n+LL | |             let p = x.get();\n LL | |             //~^ WARN not reporting region error due to nll\n-LL | |             demand_y(x, y, p)\n+LL | |             demand_y(x, y, p) //~ ERROR\n LL | |         },\n    | |_________^\n    |"}, {"sha": "d713a37fa9f41e8e5a256af006adcae0c490442f", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -24,14 +24,19 @@ LL | |     });\n    = note: where '_#1r: '_#2r\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/propagate-approximated-ref.rs:53:29\n+  --> $DIR/propagate-approximated-ref.rs:53:5\n    |\n-LL | fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |                                -------                -------\n-   |                                |\n-   |                                these two types are declared with different lifetimes...\n-LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n-   |                             ^^^^^^^ ...but data from `cell_a` flows into `cell_b` here\n+LL |   fn supply<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                                  -------                -------\n+   |                                  |\n+   |                                  these two types are declared with different lifetimes...\n+LL | /     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n+LL | |         //~^ ERROR lifetime mismatch\n+LL | |\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(x, y, x.get()) //~ WARNING not reporting region error due to nll\n+LL | |     });\n+   | |______^ ...but data from `cell_a` flows into `cell_b` here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-ref.rs:52:1"}, {"sha": "b8e8fae14b005321a37e6e5985bca92dddb1606b", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,15 +5,15 @@ LL |     foo(cell, |cell_a, cell_x| {\n    |     ^^^\n \n error: borrowed data escapes outside of closure\n-  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:20\n+  --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:33:9\n    |\n LL |     foo(cell, |cell_a, cell_x| {\n    |                ------  ------ `cell_x` is a reference that is only valid in the closure body\n    |                |\n    |                `cell_a` is declared here, outside of the closure body\n LL |         //~^ WARNING not reporting region error due to nll\n LL |         cell_a.set(cell_x.get()); // forces 'x: 'a, error in closure\n-   |                    ^^^^^^^^^^^^ `cell_x` escapes the closure body here\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ `cell_x` escapes the closure body here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-shorter-to-static-comparing-against-free.rs:31:15"}, {"sha": "f6ad6e46c6299c82b7b38bf30f862916fb2283ca", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -24,14 +24,19 @@ LL | |     });\n    = note: where '_#1r: '_#2r\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/propagate-approximated-val.rs:46:29\n+  --> $DIR/propagate-approximated-val.rs:46:5\n    |\n-LL | fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n-   |                              -------                -------\n-   |                              |\n-   |                              these two types are declared with different lifetimes...\n-LL |     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n-   |                             ^^^^^^ ...but data from `cell_a` flows into `cell_b` here\n+LL |   fn test<'a, 'b>(cell_a: Cell<&'a u32>, cell_b: Cell<&'b u32>) {\n+   |                                -------                -------\n+   |                                |\n+   |                                these two types are declared with different lifetimes...\n+LL | /     establish_relationships(cell_a, cell_b, |outlives1, outlives2, x, y| {\n+LL | |         //~^ ERROR lifetime mismatch\n+LL | |\n+LL | |         // Only works if 'x: 'y:\n+LL | |         demand_y(outlives1, outlives2, x.get()) //~ WARNING not reporting region error due to nll\n+LL | |     });\n+   | |______^ ...but data from `cell_a` flows into `cell_b` here\n \n note: No external requirements\n   --> $DIR/propagate-approximated-val.rs:45:1"}, {"sha": "fb98c506c7d280a913b785441d731b06f4f7c1d7", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:24\n+  --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:47:9\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives, x, y| {\n    |                                                ---------  - lifetime `'1` appears in this argument\n    |                                                |\n    |                                                lifetime `'2` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-no-bounds.rs:45:47"}, {"sha": "73d39a8502b6438060cf366c70aad478c2dd4daa", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -5,15 +5,15 @@ LL |         demand_y(x, y, x.get())\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:24\n+  --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:51:9\n    |\n LL |     establish_relationships(&cell_a, &cell_b, |_outlives1, _outlives2, x, y| {\n    |                                                ----------  ---------- lifetime `'2` appears in this argument\n    |                                                |\n    |                                                lifetime `'1` appears in this argument\n LL |         // Only works if 'x: 'y:\n LL |         demand_y(x, y, x.get())\n-   |                        ^^^^^^^ argument requires that `'1` must outlive `'2`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ argument requires that `'1` must outlive `'2`\n \n note: No external requirements\n   --> $DIR/propagate-fail-to-approximate-longer-wrong-bounds.rs:49:47"}, {"sha": "2200c1569e5728c388c4d3c1c60b093ac3e7f846", "filename": "src/test/ui/nll/mir_check_cast_closure.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "previous_filename": "src/test/compile-fail/mir_check_cast_closure.rs"}, {"sha": "fc2a3c43f7589df2edd7aa3deea5207c7ed91e7c", "filename": "src/test/ui/nll/mir_check_cast_closure.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_closure.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,14 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/mir_check_cast_closure.rs:18:5\n+   |\n+LL |     g\n+   |     ^\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/mir_check_cast_closure.rs:16:28\n+   |\n+LL |     let g: fn(_, _) -> _ = |_x, y| y;\n+   |                            ^^^^^^^^^ cast requires that `'b` must outlive `'a`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a530c1e7473df4f19eac614bd36d5566662782e", "filename": "src/test/ui/nll/mir_check_cast_reify.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -45,8 +45,8 @@ fn bar<'a>(x: &'a u32) -> &'static u32 {\n     // as part of checking the `ReifyFnPointer`.\n     let f: fn(_) -> _ = foo;\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR unsatisfied lifetime constraints\n     f(x)\n+    //~^ ERROR\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/mir_check_cast_reify.rs"}, {"sha": "13f90e1f159d2091dc6da7692ff3983aa9853f39", "filename": "src/test/ui/nll/mir_check_cast_reify.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_reify.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,17 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/mir_check_cast_reify.rs:46:25\n+   |\n+LL |     let f: fn(_) -> _ = foo;\n+   |                         ^^^\n+\n+error: borrowed data escapes outside of closure\n+  --> $DIR/mir_check_cast_reify.rs:48:5\n+   |\n+LL | fn bar<'a>(x: &'a u32) -> &'static u32 {\n+   |            - `x` is a reference that is only valid in the closure body\n+...\n+LL |     f(x)\n+   |     ^^^^ `x` escapes the closure body here\n+\n+error: aborting due to previous error\n+"}, {"sha": "4a840da028d815b4896d15e12f4d5f27887fd51b", "filename": "src/test/ui/nll/mir_check_cast_unsafe_fn.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -17,8 +17,8 @@ fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n     // in `g`. These are related via the `UnsafeFnPointer` cast.\n     let g: unsafe fn(_) -> _ = f;\n     //~^ WARNING not reporting region error due to nll\n-    //~| ERROR unsatisfied lifetime constraints\n     unsafe { g(input) }\n+    //~^ ERROR\n }\n \n fn main() {}", "previous_filename": "src/test/compile-fail/mir_check_cast_unsafe_fn.rs"}, {"sha": "b08c6f32e6b43bc460bac69353f59900a80c52cd", "filename": "src/test/ui/nll/mir_check_cast_unsafe_fn.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsafe_fn.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,17 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/mir_check_cast_unsafe_fn.rs:18:32\n+   |\n+LL |     let g: unsafe fn(_) -> _ = f;\n+   |                                ^\n+\n+error: borrowed data escapes outside of closure\n+  --> $DIR/mir_check_cast_unsafe_fn.rs:20:14\n+   |\n+LL | fn bar<'a>(input: &'a u32, f: fn(&'a u32) -> &'a u32) -> &'static u32 {\n+   |            ----- `input` is a reference that is only valid in the closure body\n+...\n+LL |     unsafe { g(input) }\n+   |              ^^^^^^^^ `input` escapes the closure body here\n+\n+error: aborting due to previous error\n+"}, {"sha": "695dddbf7e9d553585baa1a208f5a4ffc40726c3", "filename": "src/test/ui/nll/mir_check_cast_unsize.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -15,7 +15,8 @@\n use std::fmt::Debug;\n \n fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n-    x //~ ERROR unsatisfied lifetime constraints\n+    //~^ ERROR unsatisfied lifetime constraints\n+    x\n     //~^ WARNING not reporting region error due to nll\n }\n ", "previous_filename": "src/test/compile-fail/mir_check_cast_unsize.rs"}, {"sha": "7bd0595f3b5ccdd3f7b47e82882348acba14ff9e", "filename": "src/test/ui/nll/mir_check_cast_unsize.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmir_check_cast_unsize.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,19 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/mir_check_cast_unsize.rs:19:5\n+   |\n+LL |     x\n+   |     ^\n+\n+error: unsatisfied lifetime constraints\n+  --> $DIR/mir_check_cast_unsize.rs:17:46\n+   |\n+LL |   fn bar<'a>(x: &'a u32) -> &'static dyn Debug {\n+   |  ______________________________________________^\n+LL | |     //~^ ERROR unsatisfied lifetime constraints\n+LL | |     x\n+LL | |     //~^ WARNING not reporting region error due to nll\n+LL | | }\n+   | |_^ return requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "84c305f5907d102a44064cb924a643ada33e39bb", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning either argument CANNOT be upcast to one\n+// that returns always its first argument.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> for<'a> fn(&'a u32, &'a u32) -> &'a u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+    //~^ ERROR higher-ranked subtype error\n+    drop(a);\n+}"}, {"sha": "e08d848b471407d8697a65afd9d50762b23e49ce", "filename": "src/test/ui/nll/relate_tys/hr-fn-aaa-as-aba.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aaa-as-aba.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aaa-as-aba.rs:24:58\n+   |\n+LL |     let a: for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 = make_it();\n+   |                                                          ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "9b8268d9736aad949fd3237dced69bd5624669f5", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test an interesting corner case that ought to be legal (though the\n+// current code actually gets it wrong, see below): a fn that takes\n+// two arguments that are references with the same lifetime is in fact\n+// equivalent to a fn that takes two references with distinct\n+// lifetimes. This is true because the two functions can call one\n+// another -- effectively, the single lifetime `'a` is just inferred\n+// to be the intersection of the two distinct lifetimes.\n+//\n+// FIXME: However, we currently reject this example with an error,\n+// because of how we handle binders and equality in `relate_tys`.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+use std::cell::Cell;\n+\n+fn make_cell_aa() -> Cell<for<'a> fn(&'a u32, &'a u32)> {\n+    panic!()\n+}\n+\n+fn aa_eq_ab() {\n+    let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n+    //~^ ERROR higher-ranked subtype error\n+    drop(a);\n+}\n+\n+fn main() { }"}, {"sha": "17e8a32cb2ad95d790206326dc529fa310a1d5b1", "filename": "src/test/ui/nll/relate_tys/hr-fn-aau-eq-abu.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aau-eq-abu.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/hr-fn-aau-eq-abu.rs:33:53\n+   |\n+LL |     let a: Cell<for<'a, 'b> fn(&'a u32, &'b u32)> = make_cell_aa();\n+   |                                                     ^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "4f73ca3a53921dbf25ed73b93ab89d9ea6226dae", "filename": "src/test/ui/nll/relate_tys/hr-fn-aba-as-aaa.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fhr-fn-aba-as-aaa.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the NLL `relate_tys` code correctly deduces that a\n+// function returning always its first argument can be upcast to one\n+// that returns either first or second argument.\n+//\n+// compile-pass\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn make_it() -> for<'a, 'b> fn(&'a u32, &'b u32) -> &'a u32 {\n+    panic!()\n+}\n+\n+fn main() {\n+    let a: for<'a> fn(&'a u32, &'a u32) -> &'a u32 = make_it();\n+    drop(a);\n+}"}, {"sha": "c2498cbe50f7e149e910180e6ee02a1b8babae98", "filename": "src/test/ui/nll/relate_tys/issue-48071.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fissue-48071.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fissue-48071.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Fissue-48071.rs?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #48071. This test used to ICE because -- in\n+// the leak-check -- it would pass since we knew that the return type\n+// was `'static`, and hence `'static: 'a` was legal even for a\n+// placeholder region, but in NLL land it would fail because we had\n+// rewritten `'static` to a region variable.\n+//\n+// compile-pass\n+\n+#![allow(warnings)]\n+#![feature(dyn_trait)]\n+#![feature(nll)]\n+\n+trait Foo {\n+    fn foo(&self) { }\n+}\n+\n+impl Foo for () {\n+}\n+\n+type MakeFooFn = for<'a> fn(&'a u8) -> Box<dyn Foo + 'a>;\n+\n+fn make_foo(x: &u8) -> Box<dyn Foo + 'static> {\n+    Box::new(())\n+}\n+\n+fn main() {\n+    let x: MakeFooFn = make_foo as MakeFooFn;\n+}"}, {"sha": "5b4c669c66ecd84112ad2939746ecdbdc73ef5b5", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.nll.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.nll.stderr?ref=bfbf8375d7b1a4f4fb8a5feb54ae132847d916ad", "patch": "@@ -23,13 +23,16 @@ LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n \n error: unsatisfied lifetime constraints\n-  --> $DIR/dyn-trait-underscore.rs:18:5\n+  --> $DIR/dyn-trait-underscore.rs:16:52\n    |\n-LL | fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n-   |                - let's call the lifetime of this reference `'1`\n-LL |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n-LL |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ cast requires that `'1` must outlive `'static`\n+LL |   fn a<T>(items: &[T]) -> Box<dyn Iterator<Item=&T>> {\n+   |  ________________-___________________________________^\n+   | |                |\n+   | |                let's call the lifetime of this reference `'1`\n+LL | |     //                      ^^^^^^^^^^^^^^^^^^^^^ bound *here* defaults to `'static`\n+LL | |     Box::new(items.iter()) //~ ERROR cannot infer an appropriate lifetime\n+LL | | }\n+   | |_^ return requires that `'1` must outlive `'static`\n \n error: aborting due to previous error\n "}]}