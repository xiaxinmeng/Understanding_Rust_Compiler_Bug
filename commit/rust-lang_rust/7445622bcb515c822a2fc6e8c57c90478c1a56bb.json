{"sha": "7445622bcb515c822a2fc6e8c57c90478c1a56bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NDU2MjJiY2I1MTVjODIyYTJmYzZlOGM1N2M5MDQ3OGMxYTU2YmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-29T11:20:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-29T11:20:45Z"}, "message": "Auto merge of #63998 - Centril:rollup-pfuwxz3, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #63867 (resolve: Block expansion of a derive container until all its derives are resolved)\n - #63880 (Validation: check raw wide pointer metadata)\n - #63914 (ty: use Align for ReprOptions pack and align.)\n - #63941 (rustbuild: allow disabling deny(warnings) for bootstrap)\n - #63949 (Fix build src/libtest)\n - #63984 (Update rust-installer to limit memory use)\n - #63992 (Small improvement for Ord implementation of integers)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3c3cd79e15fce31f7d5ef8792249a7de33646bce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c3cd79e15fce31f7d5ef8792249a7de33646bce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7445622bcb515c822a2fc6e8c57c90478c1a56bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7445622bcb515c822a2fc6e8c57c90478c1a56bb", "html_url": "https://github.com/rust-lang/rust/commit/7445622bcb515c822a2fc6e8c57c90478c1a56bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7445622bcb515c822a2fc6e8c57c90478c1a56bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85ed538d6988c6c82aea8750b306cb793e874294", "url": "https://api.github.com/repos/rust-lang/rust/commits/85ed538d6988c6c82aea8750b306cb793e874294", "html_url": "https://github.com/rust-lang/rust/commit/85ed538d6988c6c82aea8750b306cb793e874294"}, {"sha": "3f05cf6776fe9682200b1327b7131219710120b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f05cf6776fe9682200b1327b7131219710120b2", "html_url": "https://github.com/rust-lang/rust/commit/3f05cf6776fe9682200b1327b7131219710120b2"}], "stats": {"total": 755, "additions": 430, "deletions": 325}, "files": [{"sha": "138b7f4b261046bad584bd2acd730da9e5b1bcf0", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -5,9 +5,6 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n \n use bootstrap::{Config, Build};"}, {"sha": "8cb48df14bfefd334bc4ef712e9b516075d9b4e1", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -15,9 +15,6 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::ffi::OsString;\n use std::io;\n@@ -124,8 +121,9 @@ fn main() {\n \n     if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n        env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n-        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n-        // there as well, some code doesn't go through this `rustc` wrapper.\n+        // When extending this list, add the new lints to the RUSTFLAGS of the\n+        // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n+        // some code doesn't go through this `rustc` wrapper.\n         cmd.arg(\"-Dwarnings\");\n         cmd.arg(\"-Drust_2018_idioms\");\n         cmd.arg(\"-Dunused_lifetimes\");"}, {"sha": "766a3463ecd8b36f5132c3ee0128a68fc05ee720", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -2,9 +2,6 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::process::Command;\n use std::path::PathBuf;"}, {"sha": "3c56131396f29de1fc08ecef859783a81b6c4729", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -631,6 +631,8 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n+        if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n+            env[\"RUSTFLAGS\"] += \"-Dwarnings -Drust_2018_idioms -Dunused_lifetimes \"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]"}, {"sha": "205a80c3a3a9e5b2129bb7be7fcd2308197e8b40", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -34,7 +34,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "9d57a4f00d7807e97817bb69d60e52ceee41b9ec", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -39,7 +39,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "3d0a175e8206c612376a32b4ed387d52fc7d3a30", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -413,7 +413,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.all_krates(\"std\").default_condition(builder.config.docs)\n+        run.all_krates(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {"}, {"sha": "575844028d562a9c488a6232c22c735c84818b69", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -103,9 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n "}, {"sha": "f035a7119188a1aa3c415e09096e20b8e896104f", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,6 +1,3 @@\n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};"}, {"sha": "607427a85d67aef435677761bc085c2913eb14e0", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1015,8 +1015,8 @@ mod impls {\n                     // The order here is important to generate more optimal assembly.\n                     // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n                     if *self < *other { Less }\n-                    else if *self > *other { Greater }\n-                    else { Equal }\n+                    else if *self == *other { Equal }\n+                    else { Greater }\n                 }\n             }\n         )*)"}, {"sha": "5ec4754c4535bc54019426bea5cef721428e9c52", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -273,14 +273,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                              repr: &ReprOptions,\n                              kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n-        let packed = repr.packed();\n-        if packed && repr.align > 0 {\n+        let pack = repr.pack;\n+        if pack.is_some() && repr.align.is_some() {\n             bug!(\"struct cannot be packed and aligned\");\n         }\n \n-        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n-\n-        let mut align = if packed {\n+        let mut align = if pack.is_some() {\n             dl.i8_align\n         } else {\n             dl.aggregate_align\n@@ -303,7 +301,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             };\n             let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyLayout<'_>| {\n-                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+                if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n                 StructKind::AlwaysSized |\n@@ -334,7 +332,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align = if packed {\n+            let prefix_align = if let Some(pack) = pack {\n                 prefix_align.min(pack)\n             } else {\n                 prefix_align\n@@ -355,7 +353,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if packed {\n+            let field_align = if let Some(pack) = pack {\n                 field.align.min(AbiAndPrefAlign::new(pack))\n             } else {\n                 field.align\n@@ -379,10 +377,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n \n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n         debug!(\"univariant min_size: {:?}\", offset);\n@@ -730,23 +726,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    let packed = def.repr.packed();\n-                    if packed && def.repr.align > 0 {\n-                        bug!(\"Union cannot be packed and aligned\");\n+                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                        bug!(\"union cannot be packed and aligned\");\n                     }\n \n-                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n-\n-                    let mut align = if packed {\n+                    let mut align = if def.repr.pack.is_some() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    if def.repr.align > 0 {\n-                        let repr_align = def.repr.align as u64;\n-                        align = align.max(\n-                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+                    if let Some(repr_align) = def.repr.align {\n+                        align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -755,13 +746,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n-\n-                        let field_align = if packed {\n-                            field.align.min(AbiAndPrefAlign::new(pack))\n-                        } else {\n-                            field.align\n-                        };\n-                        align = align.max(field_align);\n+                        align = align.max(field.align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -796,6 +781,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n+                    if let Some(pack) = def.repr.pack {\n+                        align = align.min(AbiAndPrefAlign::new(pack));\n+                    }\n+\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n@@ -1637,7 +1626,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.packed();\n+        let adt_packed = adt_def.repr.pack.is_some();\n \n         let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],"}, {"sha": "eaaaf75f75dd5c0fc78e44c32fbb43e511892ddd", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -33,6 +33,7 @@ use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_target::abi::Align;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n@@ -2057,8 +2058,8 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n-    pub align: u32,\n-    pub pack: u32,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n@@ -2073,18 +2074,19 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-        let mut max_align = 0;\n-        let mut min_pack = 0;\n+        let mut max_align: Option<Align> = None;\n+        let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n-                        min_pack = if min_pack > 0 {\n-                            cmp::min(pack, min_pack)\n+                        let pack = Align::from_bytes(pack as u64).unwrap();\n+                        min_pack = Some(if let Some(min_pack) = min_pack {\n+                            min_pack.min(pack)\n                         } else {\n                             pack\n-                        };\n+                        });\n                         ReprFlags::empty()\n                     },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n@@ -2094,7 +2096,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     },\n                     attr::ReprAlign(align) => {\n-                        max_align = cmp::max(align, max_align);\n+                        max_align = max_align.max(Some(Align::from_bytes(align as u64).unwrap()));\n                         ReprFlags::empty()\n                     },\n                 });\n@@ -2113,7 +2115,7 @@ impl ReprOptions {\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.pack > 0 }\n+    pub fn packed(&self) -> bool { self.pack.is_some() }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -2133,8 +2135,12 @@ impl ReprOptions {\n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n-            self.int.is_some()\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations."}, {"sha": "cdee14d07fb4d42271e6752decf117a760c8265e", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -527,9 +527,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n                 (\n                     trait_name,\n-                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n-                        client, attrs: helper_attrs.clone()\n-                    })),\n+                    SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive { client })),\n                     helper_attrs,\n                 )\n             }"}, {"sha": "c2505547c5b4fe2103ccadd20db8588f25aff88e", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 54, "deletions": 35, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -11,7 +11,7 @@ use std::hash::Hash;\n \n use super::{\n     GlobalAlloc, InterpResult,\n-    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n+    Scalar, OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! throw_validation_failure {\n@@ -250,6 +250,47 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, 'tcx, M\n         self.path.truncate(path_len);\n         Ok(())\n     }\n+\n+    fn check_wide_ptr_meta(\n+        &mut self,\n+        meta: Option<Scalar<M::PointerTag>>,\n+        pointee: TyLayout<'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n+        match tail.sty {\n+            ty::Dynamic(..) => {\n+                let vtable = meta.unwrap();\n+                try_validation!(\n+                    self.ecx.memory.check_ptr_access(\n+                        vtable,\n+                        3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n+                        self.ecx.tcx.data_layout.pointer_align.abi,\n+                    ),\n+                    \"dangling or unaligned vtable pointer in wide pointer or too small vtable\",\n+                    self.path\n+                );\n+                try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n+                    \"invalid drop fn in vtable\", self.path);\n+                try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n+                    \"invalid size or align in vtable\", self.path);\n+                // FIXME: More checks for the vtable.\n+            }\n+            ty::Slice(..) | ty::Str => {\n+                let _len = try_validation!(meta.unwrap().to_usize(self.ecx),\n+                    \"non-integer slice length in wide pointer\", self.path);\n+                // We do not check that `len * elem_size <= isize::MAX`:\n+                // that is only required for references, and there it falls out of the\n+                // \"dereferencable\" check performed by Stacked Borrows.\n+            }\n+            ty::Foreign(..) => {\n+                // Unsized, but not wide.\n+            }\n+            _ =>\n+                bug!(\"Unexpected unsized type tail: {:?}\", tail),\n+        }\n+\n+        Ok(())\n+    }\n }\n \n impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n@@ -341,56 +382,34 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 }\n             }\n             ty::RawPtr(..) => {\n+                // Check pointer part.\n                 if self.ref_tracking_for_consts.is_some() {\n                     // Integers/floats in CTFE: For consistency with integers, we do not\n                     // accept undef.\n                     let _ptr = try_validation!(value.to_scalar_ptr(),\n                         \"undefined address in raw pointer\", self.path);\n-                    let _meta = try_validation!(value.to_meta(),\n-                        \"uninitialized data in raw fat pointer metadata\", self.path);\n                 } else {\n                     // Remain consistent with `usize`: Accept anything.\n                 }\n+\n+                // Check metadata.\n+                let meta = try_validation!(value.to_meta(),\n+                    \"uninitialized data in wide pointer metadata\", self.path);\n+                let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n+                if layout.is_unsized() {\n+                    self.check_wide_ptr_meta(meta, layout)?;\n+                }\n             }\n             _ if ty.is_box() || ty.is_region_ptr() => {\n-                // Handle fat pointers.\n+                // Handle wide pointers.\n                 // Check metadata early, for better diagnostics\n                 let ptr = try_validation!(value.to_scalar_ptr(),\n                     \"undefined address in pointer\", self.path);\n                 let meta = try_validation!(value.to_meta(),\n-                    \"uninitialized data in fat pointer metadata\", self.path);\n+                    \"uninitialized data in wide pointer metadata\", self.path);\n                 let layout = self.ecx.layout_of(value.layout.ty.builtin_deref(true).unwrap().ty)?;\n                 if layout.is_unsized() {\n-                    let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(layout.ty,\n-                                                                          self.ecx.param_env);\n-                    match tail.sty {\n-                        ty::Dynamic(..) => {\n-                            let vtable = meta.unwrap();\n-                            try_validation!(\n-                                self.ecx.memory.check_ptr_access(\n-                                    vtable,\n-                                    3*self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n-                                    self.ecx.tcx.data_layout.pointer_align.abi,\n-                                ),\n-                                \"dangling or unaligned vtable pointer or too small vtable\",\n-                                self.path\n-                            );\n-                            try_validation!(self.ecx.read_drop_type_from_vtable(vtable),\n-                                \"invalid drop fn in vtable\", self.path);\n-                            try_validation!(self.ecx.read_size_and_align_from_vtable(vtable),\n-                                \"invalid size or align in vtable\", self.path);\n-                            // FIXME: More checks for the vtable.\n-                        }\n-                        ty::Slice(..) | ty::Str => {\n-                            try_validation!(meta.unwrap().to_usize(self.ecx),\n-                                \"non-integer slice length in fat pointer\", self.path);\n-                        }\n-                        ty::Foreign(..) => {\n-                            // Unsized, but not fat.\n-                        }\n-                        _ =>\n-                            bug!(\"Unexpected unsized type tail: {:?}\", tail),\n-                    }\n+                    self.check_wide_ptr_meta(meta, layout)?;\n                 }\n                 // Make sure this is dereferencable and all.\n                 let (size, align) = self.ecx.size_and_align_of(meta, layout)?"}, {"sha": "7224bd74230b399c2619fd42986f6011164b53ca", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -13,7 +13,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n use syntax::attr::StabilityLevel;\n use syntax::edition::Edition;\n-use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n+use syntax::ext::base::{self, InvocationRes, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnData, ExpnKind};\n@@ -142,7 +142,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate> {\n+    ) -> Result<InvocationRes, Indeterminate> {\n         let invoc_id = invoc.expansion_data.id;\n         let parent_scope = match self.invocation_parent_scopes.get(&invoc_id) {\n             Some(parent_scope) => *parent_scope,\n@@ -165,25 +165,24 @@ impl<'a> base::Resolver for Resolver<'a> {\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, &[][..], false),\n             InvocationKind::DeriveContainer { ref derives, .. } => {\n-                // Block expansion of derives in the container until we know whether one of them\n-                // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n-                // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n-                // will automatically knows about itself.\n-                let mut result = Ok(None);\n-                if derives.len() > 1 {\n-                    for path in derives {\n-                        match self.resolve_macro_path(path, Some(MacroKind::Derive),\n-                                                      &parent_scope, true, force) {\n-                            Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n-                                self.add_derives(invoc_id, SpecialDerives::COPY);\n-                                return Ok(None);\n-                            }\n-                            Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n-                            _ => {}\n-                        }\n-                    }\n+                // Block expansion of the container until we resolve all derives in it.\n+                // This is required for two reasons:\n+                // - Derive helper attributes are in scope for the item to which the `#[derive]`\n+                //   is applied, so they have to be produced by the container's expansion rather\n+                //   than by individual derives.\n+                // - Derives in the container need to know whether one of them is a built-in `Copy`.\n+                // FIXME: Try to avoid repeated resolutions for derives here and in expansion.\n+                let mut exts = Vec::new();\n+                for path in derives {\n+                    exts.push(match self.resolve_macro_path(\n+                        path, Some(MacroKind::Derive), &parent_scope, true, force\n+                    ) {\n+                        Ok((Some(ext), _)) => ext,\n+                        Ok(_) | Err(Determinacy::Determined) => self.dummy_ext(MacroKind::Derive),\n+                        Err(Determinacy::Undetermined) => return Err(Indeterminate),\n+                    })\n                 }\n-                return result;\n+                return Ok(InvocationRes::DeriveContainer(exts));\n             }\n         };\n \n@@ -203,7 +202,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             self.definitions.add_parent_module_of_macro_def(invoc_id, normal_module_def_id);\n         }\n \n-        Ok(Some(ext))\n+        Ok(InvocationRes::Single(ext))\n     }\n \n     fn check_unused_macros(&self) {"}, {"sha": "a80550486d627707c735af1f02f7a66014806e94", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1859,14 +1859,18 @@ fn check_packed(tcx: TyCtxt<'_>, sp: Span, def_id: DefId) {\n         for attr in tcx.get_attrs(def_id).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 if let attr::ReprPacked(pack) = r {\n-                    if pack != repr.pack {\n-                        struct_span_err!(tcx.sess, sp, E0634,\n-                                         \"type has conflicting packed representation hints\").emit();\n+                    if let Some(repr_pack) = repr.pack {\n+                        if pack as u64 != repr_pack.bytes() {\n+                            struct_span_err!(\n+                                tcx.sess, sp, E0634,\n+                                \"type has conflicting packed representation hints\"\n+                            ).emit();\n+                        }\n                     }\n                 }\n             }\n         }\n-        if repr.align > 0 {\n+        if repr.align.is_some() {\n             struct_span_err!(tcx.sess, sp, E0587,\n                              \"type has conflicting packed and align representation hints\").emit();\n         }\n@@ -1885,7 +1889,7 @@ fn check_packed_inner(tcx: TyCtxt<'_>, def_id: DefId, stack: &mut Vec<DefId>) ->\n     }\n     if let ty::Adt(def, substs) = t.sty {\n         if def.is_struct() || def.is_union() {\n-            if tcx.adt_def(def.did).repr.align > 0 {\n+            if tcx.adt_def(def.did).repr.align.is_some() {\n                 return true;\n             }\n             // push struct def_id before checking fields"}, {"sha": "5d68983d7cb66647515c195cda7b9cb3a50d0b4e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -11,6 +11,7 @@ use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream, TokenTree};\n+use crate::visit::Visitor;\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n@@ -72,6 +73,17 @@ impl Annotatable {\n         }\n     }\n \n+    pub fn visit_with<'a, V: Visitor<'a>>(&'a self, visitor: &mut V) {\n+        match self {\n+            Annotatable::Item(item) => visitor.visit_item(item),\n+            Annotatable::TraitItem(trait_item) => visitor.visit_trait_item(trait_item),\n+            Annotatable::ImplItem(impl_item) => visitor.visit_impl_item(impl_item),\n+            Annotatable::ForeignItem(foreign_item) => visitor.visit_foreign_item(foreign_item),\n+            Annotatable::Stmt(stmt) => visitor.visit_stmt(stmt),\n+            Annotatable::Expr(expr) => visitor.visit_expr(expr),\n+        }\n+    }\n+\n     pub fn expect_item(self) -> P<ast::Item> {\n         match self {\n             Annotatable::Item(i) => i,\n@@ -700,6 +712,12 @@ impl SyntaxExtension {\n \n pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n \n+/// Result of resolving a macro invocation.\n+pub enum InvocationRes {\n+    Single(Lrc<SyntaxExtension>),\n+    DeriveContainer(Vec<Lrc<SyntaxExtension>>),\n+}\n+\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n@@ -727,7 +745,7 @@ pub trait Resolver {\n \n     fn resolve_macro_invocation(\n         &mut self, invoc: &Invocation, eager_expansion_root: ExpnId, force: bool\n-    ) -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n+    ) -> Result<InvocationRes, Indeterminate>;\n \n     fn check_unused_macros(&self);\n "}, {"sha": "7b4a516744642075301dec2c73e4cb21aacb85e6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::respan;\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::proc_macro::collect_derives;\n+use crate::ext::proc_macro::{collect_derives, MarkAttrs};\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnData, ExpnKind};\n use crate::ext::tt::macro_rules::annotate_err_with_kind;\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -307,10 +307,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let eager_expansion_root =\n                 if self.monotonic { invoc.expansion_data.id } else { orig_expansion_data.id };\n-            let ext = match self.cx.resolver.resolve_macro_invocation(\n+            let res = match self.cx.resolver.resolve_macro_invocation(\n                 &invoc, eager_expansion_root, force\n             ) {\n-                Ok(ext) => ext,\n+                Ok(res) => res,\n                 Err(Indeterminate) => {\n                     undetermined_invocations.push(invoc);\n                     continue\n@@ -322,54 +322,72 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             self.cx.current_expansion = invoc.expansion_data.clone();\n \n             // FIXME(jseyfried): Refactor out the following logic\n-            let (expanded_fragment, new_invocations) = if let Some(ext) = ext {\n-                let fragment = self.expand_invoc(invoc, &ext.kind);\n-                self.collect_invocations(fragment, &[])\n-            } else if let InvocationKind::DeriveContainer { derives: traits, item } = invoc.kind {\n-                if !item.derive_allowed() {\n-                    let attr = attr::find_by_name(item.attrs(), sym::derive)\n-                        .expect(\"`derive` attribute should exist\");\n-                    let span = attr.span;\n-                    let mut err = self.cx.mut_span_err(span,\n-                                                        \"`derive` may only be applied to \\\n-                                                        structs, enums and unions\");\n-                    if let ast::AttrStyle::Inner = attr.style {\n-                        let trait_list = traits.iter()\n-                            .map(|t| t.to_string()).collect::<Vec<_>>();\n-                        let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n-                        err.span_suggestion(\n-                            span, \"try an outer attribute\", suggestion,\n-                            // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n-                            Applicability::MaybeIncorrect\n-                        );\n-                    }\n-                    err.emit();\n+            let (expanded_fragment, new_invocations) = match res {\n+                InvocationRes::Single(ext) => {\n+                    let fragment = self.expand_invoc(invoc, &ext.kind);\n+                    self.collect_invocations(fragment, &[])\n                 }\n+                InvocationRes::DeriveContainer(exts) => {\n+                    let (derives, item) = match invoc.kind {\n+                        InvocationKind::DeriveContainer { derives, item } => (derives, item),\n+                        _ => unreachable!(),\n+                    };\n+                    if !item.derive_allowed() {\n+                        let attr = attr::find_by_name(item.attrs(), sym::derive)\n+                            .expect(\"`derive` attribute should exist\");\n+                        let span = attr.span;\n+                        let mut err = self.cx.mut_span_err(span,\n+                            \"`derive` may only be applied to structs, enums and unions\");\n+                        if let ast::AttrStyle::Inner = attr.style {\n+                            let trait_list = derives.iter()\n+                                .map(|t| t.to_string()).collect::<Vec<_>>();\n+                            let suggestion = format!(\"#[derive({})]\", trait_list.join(\", \"));\n+                            err.span_suggestion(\n+                                span, \"try an outer attribute\", suggestion,\n+                                // We don't \ud835\udc58\ud835\udc5b\ud835\udc5c\ud835\udc64 that the following item is an ADT\n+                                Applicability::MaybeIncorrect\n+                            );\n+                        }\n+                        err.emit();\n+                    }\n \n-                let mut item = self.fully_configure(item);\n-                item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let derive_placeholders =\n-                    all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n-\n-                derive_placeholders.reserve(traits.len());\n-                invocations.reserve(traits.len());\n-                for path in traits {\n-                    let expn_id = ExpnId::fresh(None);\n-                    derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n-                    invocations.push(Invocation {\n-                        kind: InvocationKind::Derive { path, item: item.clone() },\n-                        fragment_kind: invoc.fragment_kind,\n-                        expansion_data: ExpansionData {\n-                            id: expn_id,\n-                            ..invoc.expansion_data.clone()\n-                        },\n-                    });\n+                    let mut item = self.fully_configure(item);\n+                    item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n+                    let mut helper_attrs = Vec::new();\n+                    let mut has_copy = false;\n+                    for ext in exts {\n+                        helper_attrs.extend(&ext.helper_attrs);\n+                        has_copy |= ext.is_derive_copy;\n+                    }\n+                    // Mark derive helpers inside this item as known and used.\n+                    // FIXME: This is a hack, derive helpers should be integrated with regular name\n+                    // resolution instead. For example, helpers introduced by a derive container\n+                    // can be in scope for all code produced by that container's expansion.\n+                    item.visit_with(&mut MarkAttrs(&helper_attrs));\n+                    if has_copy {\n+                        self.cx.resolver.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                    }\n+\n+                    let derive_placeholders =\n+                        all_derive_placeholders.entry(invoc.expansion_data.id).or_default();\n+                    derive_placeholders.reserve(derives.len());\n+                    invocations.reserve(derives.len());\n+                    for path in derives {\n+                        let expn_id = ExpnId::fresh(None);\n+                        derive_placeholders.push(NodeId::placeholder_from_expn_id(expn_id));\n+                        invocations.push(Invocation {\n+                            kind: InvocationKind::Derive { path, item: item.clone() },\n+                            fragment_kind: invoc.fragment_kind,\n+                            expansion_data: ExpansionData {\n+                                id: expn_id,\n+                                ..invoc.expansion_data.clone()\n+                            },\n+                        });\n+                    }\n+                    let fragment = invoc.fragment_kind\n+                        .expect_from_annotatables(::std::iter::once(item));\n+                    self.collect_invocations(fragment, derive_placeholders)\n                 }\n-                let fragment = invoc.fragment_kind\n-                    .expect_from_annotatables(::std::iter::once(item));\n-                self.collect_invocations(fragment, derive_placeholders)\n-            } else {\n-                unreachable!()\n             };\n \n             if expanded_fragments.len() < depth {"}, {"sha": "4a44c9a9f1f312d7e690a37780dfea2ebb76a02e", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -78,7 +78,6 @@ pub struct ProcMacroDerive {\n     pub client: proc_macro::bridge::client::Client<\n         fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n-    pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n@@ -111,9 +110,6 @@ impl MultiItemModifier for ProcMacroDerive {\n             }\n         }\n \n-        // Mark attributes as known, and used.\n-        MarkAttrs(&self.attrs).visit_item(&item);\n-\n         let token = token::Interpolated(Lrc::new(token::NtItem(item)));\n         let input = tokenstream::TokenTree::token(token, DUMMY_SP).into();\n \n@@ -164,7 +160,7 @@ impl MultiItemModifier for ProcMacroDerive {\n     }\n }\n \n-struct MarkAttrs<'a>(&'a [ast::Name]);\n+crate struct MarkAttrs<'a>(crate &'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n     fn visit_attribute(&mut self, attr: &Attribute) {"}, {"sha": "8ada3cf09d0739e00a4085063b3be11e709d3749", "filename": "src/test/codegen/integer-cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fcodegen%2Finteger-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fcodegen%2Finteger-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finteger-cmp.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -11,7 +11,7 @@ use std::cmp::Ordering;\n #[no_mangle]\n pub fn cmp_signed(a: i64, b: i64) -> Ordering {\n // CHECK: icmp slt\n-// CHECK: icmp sgt\n+// CHECK: icmp ne\n // CHECK: zext i1\n // CHECK: select i1\n     a.cmp(&b)\n@@ -21,7 +21,7 @@ pub fn cmp_signed(a: i64, b: i64) -> Ordering {\n #[no_mangle]\n pub fn cmp_unsigned(a: u32, b: u32) -> Ordering {\n // CHECK: icmp ult\n-// CHECK: icmp ugt\n+// CHECK: icmp ne\n // CHECK: zext i1\n // CHECK: select i1\n     a.cmp(&b)"}, {"sha": "765ed60ee9742a10965730de39e64293a3ca394c", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.rs", "status": "renamed", "additions": 49, "deletions": 24, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-linelength\n #![allow(unused)]\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n@@ -28,7 +29,9 @@ struct BadSliceRepr {\n union SliceTransmute {\n     repr: SliceRepr,\n     bad: BadSliceRepr,\n+    addr: usize,\n     slice: &'static [u8],\n+    raw_slice: *const [u8],\n     str: &'static str,\n     my_str: &'static MyStr,\n     my_slice: &'static MySliceBool,\n@@ -59,7 +62,9 @@ union DynTransmute {\n     repr: DynRepr,\n     repr2: DynRepr2,\n     bad: BadDynRepr,\n+    addr: usize,\n     rust: &'static dyn Trait,\n+    raw_rust: *const dyn Trait,\n }\n \n trait Trait {}\n@@ -72,39 +77,37 @@ struct MyStr(str);\n struct MySlice<T: ?Sized>(bool, T);\n type MySliceBool = MySlice<[bool]>;\n \n+// # str\n // OK\n-const A: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n+const STR_VALID: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.str};\n // bad str\n-const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n //~^ ERROR it is undefined behavior to use this value\n // bad str\n-const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n+const STR_LENGTH_PTR: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n //~^ ERROR it is undefined behavior to use this value\n // bad str in user-defined unsized type\n-const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+const MY_STR_LENGTH_PTR: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n //~^ ERROR it is undefined behavior to use this value\n \n-// OK\n-const A2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n-// bad slice\n-const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+// invalid UTF-8\n+const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n //~^ ERROR it is undefined behavior to use this value\n-// bad slice\n-const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+// invalid UTF-8 in user-defined str-like\n+const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n //~^ ERROR it is undefined behavior to use this value\n \n-// bad trait object\n-const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-//~^ ERROR it is undefined behavior to use this value\n-// bad trait object\n-const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n+// # slice\n+// OK\n+const SLICE_VALID: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.slice};\n+// bad slice: length uninit\n+const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n //~^ ERROR it is undefined behavior to use this value\n-// bad trait object\n-const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n+// bad slice: length too big\n+const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n //~^ ERROR it is undefined behavior to use this value\n-\n-// bad data *inside* the trait object\n-const G: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+// bad slice: length not an int\n+const SLICE_LENGTH_PTR: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n //~^ ERROR it is undefined behavior to use this value\n \n // bad data *inside* the slice\n@@ -120,12 +123,34 @@ const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false\n const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n //~^ ERROR it is undefined behavior to use this value\n \n-// invalid UTF-8\n-const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+// # raw slice\n+const RAW_SLICE_VALID: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 1 } }.raw_slice}; // ok\n+const RAW_SLICE_TOO_LONG: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.raw_slice}; // ok because raw\n+const RAW_SLICE_MUCH_TOO_LONG: *const [u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: usize::max_value() } }.raw_slice}; // ok because raw\n+const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n //~^ ERROR it is undefined behavior to use this value\n-// invalid UTF-8 in user-defined str-like\n-const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+\n+// # trait object\n+// bad trait object\n+const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n+//~^ ERROR it is undefined behavior to use this value\n+// bad trait object\n+const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n+//~^ ERROR it is undefined behavior to use this value\n+// bad trait object\n+const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// bad data *inside* the trait object\n+const G: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+//~^ ERROR it is undefined behavior to use this value\n+\n+// # raw trait object\n+const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust};\n+//~^ ERROR it is undefined behavior to use this value\n+const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n //~^ ERROR it is undefined behavior to use this value\n+const RAW_TRAIT_OBJ_CONTENT_INVALID: *const dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl } as *const _; // ok because raw\n \n fn main() {\n }", "previous_filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.rs"}, {"sha": "88d8af802619306667f00e503ddf72a0295dda92", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.stderr", "status": "renamed", "additions": 74, "deletions": 42, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,115 +1,147 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:78:1\n+  --> $DIR/ub-wide-ptr.rs:84:1\n    |\n-LL | const B: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n+LL | const STR_TOO_LONG: &str = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:81:1\n+  --> $DIR/ub-wide-ptr.rs:87:1\n    |\n-LL | const C: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n+LL | const STR_LENGTH_PTR: &str = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:84:1\n+  --> $DIR/ub-wide-ptr.rs:90:1\n    |\n-LL | const C2: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n+LL | const MY_STR_LENGTH_PTR: &MyStr = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.my_str};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:90:1\n+  --> $DIR/ub-wide-ptr.rs:94:1\n    |\n-LL | const B2: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:93:1\n-   |\n-LL | const C3: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in fat pointer\n+LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:97:1\n+  --> $DIR/ub-wide-ptr.rs:97:1\n    |\n-LL | const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n+LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:100:1\n+  --> $DIR/ub-wide-ptr.rs:104:1\n    |\n-LL | const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n+LL | const SLICE_LENGTH_UNINIT: &[u8] = unsafe { SliceTransmute { addr: 42 }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:103:1\n+  --> $DIR/ub-wide-ptr.rs:107:1\n    |\n-LL | const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer or too small vtable\n+LL | const SLICE_TOO_LONG: &[u8] = unsafe { SliceTransmute { repr: SliceRepr { ptr: &42, len: 999 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (not entirely in bounds)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:107:1\n+  --> $DIR/ub-wide-ptr.rs:110:1\n    |\n-LL | const G: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something less or equal to 1\n+LL | const SLICE_LENGTH_PTR: &[u8] = unsafe { SliceTransmute { bad: BadSliceRepr { ptr: &42, len: &3 } }.slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered non-integer slice length in wide pointer\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:111:1\n+  --> $DIR/ub-wide-ptr.rs:114:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:117:1\n+  --> $DIR/ub-wide-ptr.rs:120:1\n    |\n LL | const I2: &MySliceBool = &MySlice(unsafe { BoolTransmute { val: 3 }.bl }, [false]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.0, but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:120:1\n+  --> $DIR/ub-wide-ptr.rs:123:1\n    |\n LL | const I3: &MySliceBool = &MySlice(true, [unsafe { BoolTransmute { val: 3 }.bl }]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.1[0], but expected something less or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:124:1\n+  --> $DIR/ub-wide-ptr.rs:130:1\n    |\n-LL | const J1: &str = unsafe { SliceTransmute { slice: &[0xFF] }.str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>\n+LL | const RAW_SLICE_LENGTH_UNINIT: *const [u8] = unsafe { SliceTransmute { addr: 42 }.raw_slice};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized data in wide pointer metadata\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/union-ub-fat-ptr.rs:127:1\n+  --> $DIR/ub-wide-ptr.rs:135:1\n    |\n-LL | const J2: &MyStr = unsafe { SliceTransmute { slice: &[0xFF] }.my_str };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized or non-UTF-8 data in str at .<deref>.0\n+LL | const D: &dyn Trait = unsafe { DynTransmute { repr: DynRepr { ptr: &92, vtable: &3 } }.rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:138:1\n+   |\n+LL | const E: &dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:141:1\n+   |\n+LL | const F: &dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 3 } }.rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:145:1\n+   |\n+LL | const G: &dyn Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>.<dyn-downcast>, but expected something less or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:149:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_NULL: *const dyn Trait = unsafe { DynTransmute { bad: BadDynRepr { ptr: &92, vtable: 0 } }.rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-wide-ptr.rs:151:1\n+   |\n+LL | const RAW_TRAIT_OBJ_VTABLE_INVALID: *const dyn Trait = unsafe { DynTransmute { repr2: DynRepr2 { ptr: &92, vtable: &3 } }.raw_rust};\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling or unaligned vtable pointer in wide pointer or too small vtable\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 18 previous errors\n \n For more information about this error, try `rustc --explain E0080`.", "previous_filename": "src/test/ui/consts/const-eval/union-ub-fat-ptr.stderr"}, {"sha": "b18df3511817db7400d45c8e70fd84eb7546880b", "filename": "src/test/ui/derives/deriving-bounds.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderiving-bounds.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,15 +1,3 @@\n-error: cannot find derive macro `Send` in this scope\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-   |\n-note: unsafe traits like `Send` should be implemented explicitly\n-  --> $DIR/deriving-bounds.rs:1:10\n-   |\n-LL | #[derive(Send)]\n-   |          ^^^^\n-\n error: cannot find derive macro `Sync` in this scope\n   --> $DIR/deriving-bounds.rs:5:10\n    |\n@@ -22,5 +10,17 @@ note: unsafe traits like `Sync` should be implemented explicitly\n LL | #[derive(Sync)]\n    |          ^^^^\n \n+error: cannot find derive macro `Send` in this scope\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+   |\n+note: unsafe traits like `Send` should be implemented explicitly\n+  --> $DIR/deriving-bounds.rs:1:10\n+   |\n+LL | #[derive(Send)]\n+   |          ^^^^\n+\n error: aborting due to 2 previous errors\n "}, {"sha": "f14591c85e62e3a16bbf2ed6e4af74ab02bec521", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive-2.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,5 +1,5 @@\n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^\n@@ -11,7 +11,7 @@ LL |     #[derive(x3300)]\n    |              ^^^^^\n \n error: cannot find derive macro `x3300` in this scope\n-  --> $DIR/issue-43106-gating-of-derive-2.rs:12:14\n+  --> $DIR/issue-43106-gating-of-derive-2.rs:4:14\n    |\n LL |     #[derive(x3300)]\n    |              ^^^^^"}, {"sha": "c5d9e0db4d389a7acae0dc43eb38e2018ed33662", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,9 +1,6 @@\n // `#![derive]` raises errors when it occurs at contexts other than ADT\n // definitions.\n \n-#![derive(Debug)]\n-//~^ ERROR `derive` may only be applied to structs, enums and unions\n-\n #[derive(Debug)]\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n mod derive {"}, {"sha": "db29a2bddd35c5b7a62c0d2a1962f5fb6eaa4064", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-derive.stderr", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-derive.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,38 +1,32 @@\n error: `derive` may only be applied to structs, enums and unions\n   --> $DIR/issue-43106-gating-of-derive.rs:4:1\n    |\n-LL | #![derive(Debug)]\n-   | ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n-\n-error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:7:1\n-   |\n LL | #[derive(Debug)]\n    | ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:10:17\n+  --> $DIR/issue-43106-gating-of-derive.rs:7:17\n    |\n LL |     mod inner { #![derive(Debug)] }\n    |                 ^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug)]`\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:13:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:10:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:26:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:23:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n error: `derive` may only be applied to structs, enums and unions\n-  --> $DIR/issue-43106-gating-of-derive.rs:30:5\n+  --> $DIR/issue-43106-gating-of-derive.rs:27:5\n    |\n LL |     #[derive(Debug)]\n    |     ^^^^^^^^^^^^^^^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "1102f3c4640a188a3b0adb5785b4a11cc25cdb60", "filename": "src/test/ui/issues/issue-36617.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,3 +1,4 @@\n #![derive(Copy)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+                 //~| ERROR cannot determine resolution for the derive macro `Copy`\n \n fn main() {}"}, {"sha": "b5db98f306bd32e10e3e6dc6a04a80e1dd92a14b", "filename": "src/test/ui/issues/issue-36617.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-36617.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -4,5 +4,13 @@ error: `derive` may only be applied to structs, enums and unions\n LL | #![derive(Copy)]\n    | ^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Copy)]`\n \n-error: aborting due to previous error\n+error: cannot determine resolution for the derive macro `Copy`\n+  --> $DIR/issue-36617.rs:1:11\n+   |\n+LL | #![derive(Copy)]\n+   |           ^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "243cf685e8145649517c8ec07247a751f956867a", "filename": "src/test/ui/proc-macro/derive-helper-configured.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-configured.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -0,0 +1,18 @@\n+// Derive helpers are resolved successfully inside `cfg_attr`.\n+\n+// check-pass\n+// compile-flats:--cfg TRUE\n+// aux-build:test-macros.rs\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+#[cfg_attr(TRUE, empty_helper)]\n+#[derive(Empty)]\n+#[cfg_attr(TRUE, empty_helper)]\n+struct S {\n+    #[cfg_attr(TRUE, empty_helper)]\n+    field: u8,\n+}\n+\n+fn main() {}"}, {"sha": "21af4093a037de46f187556cfdd07ff63ad53d33", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.rs?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -19,7 +19,8 @@ struct S {\n         struct U;\n \n         mod inner {\n-            #[empty_helper] //~ ERROR cannot find attribute macro `empty_helper` in this scope\n+            // FIXME No ambiguity, attributes in non-macro positions are not resolved properly\n+            #[empty_helper]\n             struct V;\n         }\n "}, {"sha": "2ba517ce29ee743520506c0507dcbb58bfa6dd12", "filename": "src/test/ui/proc-macro/derive-helper-shadowing.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fderive-helper-shadowing.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,9 +1,3 @@\n-error: cannot find attribute macro `empty_helper` in this scope\n-  --> $DIR/derive-helper-shadowing.rs:22:15\n-   |\n-LL |             #[empty_helper]\n-   |               ^^^^^^^^^^^^\n-\n error[E0659]: `empty_helper` is ambiguous (derive helper attribute vs any other name)\n   --> $DIR/derive-helper-shadowing.rs:8:3\n    |\n@@ -22,6 +16,6 @@ LL | use test_macros::empty_attr as empty_helper;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `crate::empty_helper` to refer to this attribute macro unambiguously\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0659`."}, {"sha": "2a5f2b883813d48f71777fb6798be15ce5d0001a", "filename": "src/test/ui/proc-macro/resolve-error.stderr", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7445622bcb515c822a2fc6e8c57c90478c1a56bb/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fresolve-error.stderr?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1,62 +1,62 @@\n-error: cannot find derive macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:22:10\n-   |\n-LL | #[derive(FooWithLongNan)]\n-   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n-\n-error: cannot find attribute macro `attr_proc_macra` in this scope\n-  --> $DIR/resolve-error.rs:27:3\n+error: cannot find macro `bang_proc_macrp!` in this scope\n+  --> $DIR/resolve-error.rs:56:5\n    |\n-LL | #[attr_proc_macra]\n-   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+LL |     bang_proc_macrp!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n \n-error: cannot find attribute macro `FooWithLongNan` in this scope\n-  --> $DIR/resolve-error.rs:31:3\n+error: cannot find macro `Dlona!` in this scope\n+  --> $DIR/resolve-error.rs:53:5\n    |\n-LL | #[FooWithLongNan]\n-   |   ^^^^^^^^^^^^^^\n+LL |     Dlona!();\n+   |     ^^^^^\n \n-error: cannot find derive macro `Dlone` in this scope\n-  --> $DIR/resolve-error.rs:34:10\n+error: cannot find macro `attr_proc_macra!` in this scope\n+  --> $DIR/resolve-error.rs:50:5\n    |\n-LL | #[derive(Dlone)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n+LL |     attr_proc_macra!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n \n-error: cannot find derive macro `Dlona` in this scope\n-  --> $DIR/resolve-error.rs:38:10\n+error: cannot find macro `FooWithLongNama!` in this scope\n+  --> $DIR/resolve-error.rs:47:5\n    |\n-LL | #[derive(Dlona)]\n-   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n+LL |     FooWithLongNama!();\n+   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n \n error: cannot find derive macro `attr_proc_macra` in this scope\n   --> $DIR/resolve-error.rs:42:10\n    |\n LL | #[derive(attr_proc_macra)]\n    |          ^^^^^^^^^^^^^^^\n \n-error: cannot find macro `FooWithLongNama!` in this scope\n-  --> $DIR/resolve-error.rs:47:5\n+error: cannot find derive macro `Dlona` in this scope\n+  --> $DIR/resolve-error.rs:38:10\n    |\n-LL |     FooWithLongNama!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `FooWithLongNam`\n+LL | #[derive(Dlona)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clona`\n \n-error: cannot find macro `attr_proc_macra!` in this scope\n-  --> $DIR/resolve-error.rs:50:5\n+error: cannot find derive macro `Dlone` in this scope\n+  --> $DIR/resolve-error.rs:34:10\n    |\n-LL |     attr_proc_macra!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `attr_proc_mac`\n+LL | #[derive(Dlone)]\n+   |          ^^^^^ help: a derive macro with a similar name exists: `Clone`\n \n-error: cannot find macro `Dlona!` in this scope\n-  --> $DIR/resolve-error.rs:53:5\n+error: cannot find attribute macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:31:3\n    |\n-LL |     Dlona!();\n-   |     ^^^^^\n+LL | #[FooWithLongNan]\n+   |   ^^^^^^^^^^^^^^\n \n-error: cannot find macro `bang_proc_macrp!` in this scope\n-  --> $DIR/resolve-error.rs:56:5\n+error: cannot find attribute macro `attr_proc_macra` in this scope\n+  --> $DIR/resolve-error.rs:27:3\n    |\n-LL |     bang_proc_macrp!();\n-   |     ^^^^^^^^^^^^^^^ help: a macro with a similar name exists: `bang_proc_macro`\n+LL | #[attr_proc_macra]\n+   |   ^^^^^^^^^^^^^^^ help: an attribute macro with a similar name exists: `attr_proc_macro`\n+\n+error: cannot find derive macro `FooWithLongNan` in this scope\n+  --> $DIR/resolve-error.rs:22:10\n+   |\n+LL | #[derive(FooWithLongNan)]\n+   |          ^^^^^^^^^^^^^^ help: a derive macro with a similar name exists: `FooWithLongName`\n \n error: aborting due to 10 previous errors\n "}, {"sha": "9f66c14c3f91a48a118c7817f434167b311c3515", "filename": "src/tools/rust-installer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-installer?ref=7445622bcb515c822a2fc6e8c57c90478c1a56bb", "patch": "@@ -1 +1 @@\n-Subproject commit 85958b001dbff8523396809bfa844fc34a7869a8\n+Subproject commit 9f66c14c3f91a48a118c7817f434167b311c3515"}]}