{"sha": "6a8169db0a201b9fc2fbf581f507e143f0482aae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhODE2OWRiMGEyMDFiOWZjMmZiZjU4MWY1MDdlMTQzZjA0ODJhYWU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-30T19:21:45Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-09-24T01:23:20Z"}, "message": "libsyntax: Remove some more `@fn` uses", "tree": {"sha": "5be68af11da6d2112a600d4021a1b7cbcc15ce18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5be68af11da6d2112a600d4021a1b7cbcc15ce18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a8169db0a201b9fc2fbf581f507e143f0482aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a8169db0a201b9fc2fbf581f507e143f0482aae", "html_url": "https://github.com/rust-lang/rust/commit/6a8169db0a201b9fc2fbf581f507e143f0482aae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a8169db0a201b9fc2fbf581f507e143f0482aae/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d126be068b0daab3b5abd9b1f365a4c98f2121b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/d126be068b0daab3b5abd9b1f365a4c98f2121b7", "html_url": "https://github.com/rust-lang/rust/commit/d126be068b0daab3b5abd9b1f365a4c98f2121b7"}], "stats": {"total": 98, "additions": 61, "deletions": 37}, "files": [{"sha": "ac11744f16a170022881ac8022853d510b1ab109", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/6a8169db0a201b9fc2fbf581f507e143f0482aae/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8169db0a201b9fc2fbf581f507e143f0482aae/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=6a8169db0a201b9fc2fbf581f507e143f0482aae", "patch": "@@ -16,9 +16,10 @@ use extra::getopts::groups::getopts;\n use syntax::ast_util::*;\n use syntax::codemap::{dummy_sp, Spanned};\n use syntax::ext::base::ExtCtxt;\n-use syntax::{ast, attr, codemap, diagnostic, fold};\n+use syntax::{ast, attr, codemap, diagnostic, fold, visit};\n use syntax::attr::AttrMetaMethods;\n use syntax::fold::ast_fold;\n+use syntax::visit::Visitor;\n use rustc::back::link::output_type_exe;\n use rustc::back::link;\n use rustc::driver::session::{lib_crate, bin_crate};\n@@ -28,6 +29,7 @@ use package_source::PkgSrc;\n use workspace::pkg_parent_workspaces;\n use path_util::{installed_library_in_workspace, U_RWX, rust_path, system_library, target_build_dir};\n use messages::error;\n+use conditions::nonexistent_package::cond;\n \n pub use target::{OutputType, Main, Lib, Bench, Test, JustOne, lib_name_of, lib_crate_filename};\n use workcache_support::{digest_file_with_date, digest_only_date};\n@@ -395,31 +397,28 @@ pub fn compile_crate(ctxt: &BuildContext,\n     compile_input(ctxt, exec, pkg_id, crate, workspace, flags, cfgs, opt, what)\n }\n \n+struct ViewItemVisitor<'self> {\n+    context: &'self BuildContext,\n+    parent: &'self PkgId,\n+    sess: session::Session,\n+    exec: &'self mut workcache::Exec,\n+    c: &'self ast::Crate,\n+    save: @fn(Path),\n+}\n \n-/// Collect all `extern mod` directives in `c`, then\n-/// try to install their targets, failing if any target\n-/// can't be found.\n-pub fn find_and_install_dependencies(context: &BuildContext,\n-                                     parent: &PkgId,\n-                                     sess: session::Session,\n-                                     exec: &mut workcache::Exec,\n-                                     c: &ast::Crate,\n-                                     save: @fn(Path)\n-                                     ) {\n-    use conditions::nonexistent_package::cond;\n-\n-    do c.each_view_item() |vi: &ast::view_item| {\n+impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n+    fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n         debug!(\"A view item!\");\n         match vi.node {\n             // ignore metadata, I guess\n             ast::view_item_extern_mod(lib_ident, path_opt, _, _) => {\n                 let lib_name = match path_opt {\n                     Some(p) => p,\n-                    None => sess.str_of(lib_ident)\n+                    None => self.sess.str_of(lib_ident)\n                 };\n                 debug!(\"Finding and installing... %s\", lib_name);\n                 // Check standard Rust library path first\n-                match system_library(&context.sysroot(), lib_name) {\n+                match system_library(&self.context.sysroot(), lib_name) {\n                     Some(ref installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                         // Say that [path for c] has a discovered dependency on\n@@ -428,44 +427,54 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                         // I'm not sure what the right thing is.\n                         // Now we know that this crate has a discovered dependency on\n                         // installed_path\n-                        exec.discover_input(\"binary\", installed_path.to_str(),\n-                                                      digest_only_date(installed_path));\n+                        self.exec.discover_input(\"binary\",\n+                                                 installed_path.to_str(),\n+                                                 digest_only_date(installed_path));\n                     }\n                     None => {\n                         // FIXME #8711: need to parse version out of path_opt\n                         debug!(\"Trying to install library %s, rebuilding it\",\n                                lib_name.to_str());\n                         // Try to install it\n                         let pkg_id = PkgId::new(lib_name);\n-                        let workspaces = pkg_parent_workspaces(&context.context, &pkg_id);\n+                        let workspaces = pkg_parent_workspaces(&self.context.context,\n+                                                               &pkg_id);\n                         let dep_workspace = if workspaces.is_empty() {\n                             error(fmt!(\"Couldn't find package %s, which is needed by %s, \\\n                                             in any of the workspaces in the RUST_PATH (%?)\",\n-                                            lib_name, parent.to_str(), rust_path()));\n+                                            lib_name,\n+                                            self.parent.to_str(),\n+                                            rust_path()));\n                             cond.raise((pkg_id.clone(), ~\"Dependency not found\"))\n                         }\n                         else {\n                             workspaces[0]\n                         };\n                         let (outputs_disc, inputs_disc) =\n-                            context.install(PkgSrc::new(dep_workspace.clone(),\n-                                false, pkg_id), &JustOne(Path(lib_crate_filename)));\n+                            self.context.install(PkgSrc::new(dep_workspace.clone(),\n+                                                             false,\n+                                                             pkg_id),\n+                                                 &JustOne(Path(\n+                                                    lib_crate_filename)));\n                         debug!(\"Installed %s, returned %? dependencies and \\\n                                %? transitive dependencies\",\n                                lib_name, outputs_disc.len(), inputs_disc.len());\n                         for dep in outputs_disc.iter() {\n                             debug!(\"Discovering a binary input: %s\", dep.to_str());\n-                            exec.discover_input(\"binary\", dep.to_str(),\n-                                                digest_only_date(dep));\n+                            self.exec.discover_input(\"binary\",\n+                                                     dep.to_str(),\n+                                                     digest_only_date(dep));\n                         }\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n-                                exec.discover_input(*what, *dep,\n-                                                    digest_file_with_date(&Path(*dep)));\n+                                self.exec.discover_input(*what,\n+                                                         *dep,\n+                                                         digest_file_with_date(&Path(*dep)));\n                             }\n                             else if *what == ~\"binary\" {\n-                                exec.discover_input(*what, *dep,\n-                                                    digest_only_date(&Path(*dep)));\n+                                self.exec.discover_input(*what,\n+                                                         *dep,\n+                                                         digest_only_date(&Path(*dep)));\n                             }\n                             else {\n                                 fail!(\"Bad kind: %s\", *what);\n@@ -480,14 +489,36 @@ pub fn find_and_install_dependencies(context: &BuildContext,\n                         let install_dir = installed_library.pop();\n                         debug!(\"Installed %s into %s [%?]\", lib_name, install_dir.to_str(),\n                                datestamp(&installed_library));\n-                        save(install_dir);\n+                        (self.save)(install_dir);\n                     }\n                 }}\n             // Ignore `use`s\n             _ => ()\n         }\n-        true\n+\n+        visit::walk_view_item(self, vi, env)\n+    }\n+}\n+\n+/// Collect all `extern mod` directives in `c`, then\n+/// try to install their targets, failing if any target\n+/// can't be found.\n+pub fn find_and_install_dependencies(context: &BuildContext,\n+                                     parent: &PkgId,\n+                                     sess: session::Session,\n+                                     exec: &mut workcache::Exec,\n+                                     c: &ast::Crate,\n+                                     save: @fn(Path)) {\n+    debug!(\"In find_and_install_dependencies...\");\n+    let mut visitor = ViewItemVisitor {\n+        context: context,\n+        parent: parent,\n+        sess: sess,\n+        exec: exec,\n+        c: c,\n+        save: save,\n     };\n+    visit::walk_crate(&mut visitor, c, ())\n }\n \n pub fn mk_string_lit(s: @str) -> ast::lit {"}, {"sha": "aa06e1bee4141371406c19bf6eab5d9ae61f4aec", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a8169db0a201b9fc2fbf581f507e143f0482aae/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a8169db0a201b9fc2fbf581f507e143f0482aae/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=6a8169db0a201b9fc2fbf581f507e143f0482aae", "patch": "@@ -236,13 +236,6 @@ fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n     print_maybe_styled(fmt!(\"%s\\n\", msg), term::attr::Bold);\n }\n \n-pub fn collect(messages: @mut ~[~str])\n-            -> @fn(Option<(@codemap::CodeMap, Span)>, &str, level) {\n-    let f: @fn(Option<(@codemap::CodeMap, Span)>, &str, level) =\n-        |_o, msg: &str, _l| { messages.push(msg.to_str()); };\n-    f\n-}\n-\n pub struct DefaultEmitter;\n \n impl Emitter for DefaultEmitter {"}]}