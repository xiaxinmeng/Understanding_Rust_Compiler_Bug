{"sha": "0c0b403f19fc6febcd1e36a83fc307ecc11de943", "node_id": "C_kwDOAAsO6NoAKDBjMGI0MDNmMTlmYzZmZWJjZDFlMzZhODNmYzMwN2VjYzExZGU5NDM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-29T11:20:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-29T11:20:50Z"}, "message": "Auto merge of #106195 - Nilstrieb:no-more-being-clueless-whether-it-really-is-a-literal, r=compiler-errors\n\nImprove heuristics whether `format_args` string is a source literal\n\nPreviously, it only checked whether there was _a_ literal at the span of the first argument, not whether the literal actually matched up. This caused issues when a proc macro was generating a different literal with the same span.\n\nThis requires an annoying special case for literals ending in `\\n` because otherwise `println` wouldn't give detailed diagnostics anymore which would be bad.\n\nFixes #106191", "tree": {"sha": "461a78f80026dd6bec5e42bfca94331c1ccaf9fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/461a78f80026dd6bec5e42bfca94331c1ccaf9fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c0b403f19fc6febcd1e36a83fc307ecc11de943", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c0b403f19fc6febcd1e36a83fc307ecc11de943", "html_url": "https://github.com/rust-lang/rust/commit/0c0b403f19fc6febcd1e36a83fc307ecc11de943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c0b403f19fc6febcd1e36a83fc307ecc11de943/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11a338ab6644cf454c45d2b41651900610a55b07", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a338ab6644cf454c45d2b41651900610a55b07", "html_url": "https://github.com/rust-lang/rust/commit/11a338ab6644cf454c45d2b41651900610a55b07"}, {"sha": "31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "url": "https://api.github.com/repos/rust-lang/rust/commits/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f", "html_url": "https://github.com/rust-lang/rust/commit/31b490d8ba8ff60b9d9ee3ccca522629429d9a3f"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "9f2aaca0acffeb51918141703183caf02e4f6e77", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -20,6 +20,7 @@ pub use Flag::*;\n pub use Piece::*;\n pub use Position::*;\n \n+use rustc_lexer::unescape;\n use std::iter;\n use std::str;\n use std::string;\n@@ -56,6 +57,13 @@ impl InnerWidthMapping {\n     }\n }\n \n+/// Whether the input string is a literal. If yes, it contains the inner width mappings.\n+#[derive(Clone, PartialEq, Eq)]\n+enum InputStringKind {\n+    NotALiteral,\n+    Literal { width_mappings: Vec<InnerWidthMapping> },\n+}\n+\n /// The type of format string that we are parsing.\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum ParseMode {\n@@ -306,7 +314,11 @@ impl<'a> Parser<'a> {\n         append_newline: bool,\n         mode: ParseMode,\n     ) -> Parser<'a> {\n-        let (width_map, is_literal) = find_width_map_from_snippet(snippet, style);\n+        let input_string_kind = find_width_map_from_snippet(s, snippet, style);\n+        let (width_map, is_literal) = match input_string_kind {\n+            InputStringKind::Literal { width_mappings } => (width_mappings, true),\n+            InputStringKind::NotALiteral => (Vec::new(), false),\n+        };\n         Parser {\n             mode,\n             input: s,\n@@ -844,20 +856,40 @@ impl<'a> Parser<'a> {\n /// written code (code snippet) and the `InternedString` that gets processed in the `Parser`\n /// in order to properly synthesise the intra-string `Span`s for error diagnostics.\n fn find_width_map_from_snippet(\n+    input: &str,\n     snippet: Option<string::String>,\n     str_style: Option<usize>,\n-) -> (Vec<InnerWidthMapping>, bool) {\n+) -> InputStringKind {\n     let snippet = match snippet {\n         Some(ref s) if s.starts_with('\"') || s.starts_with(\"r\\\"\") || s.starts_with(\"r#\") => s,\n-        _ => return (vec![], false),\n+        _ => return InputStringKind::NotALiteral,\n     };\n \n     if str_style.is_some() {\n-        return (vec![], true);\n+        return InputStringKind::Literal { width_mappings: Vec::new() };\n     }\n \n+    // Strip quotes.\n     let snippet = &snippet[1..snippet.len() - 1];\n \n+    // Macros like `println` add a newline at the end. That technically doens't make them \"literals\" anymore, but it's fine\n+    // since we will never need to point our spans there, so we lie about it here by ignoring it.\n+    // Since there might actually be newlines in the source code, we need to normalize away all trailing newlines.\n+    // If we only trimmed it off the input, `format!(\"\\n\")` would cause a mismatch as here we they actually match up.\n+    // Alternatively, we could just count the trailing newlines and only trim one from the input if they don't match up.\n+    let input_no_nl = input.trim_end_matches('\\n');\n+    let Ok(unescaped) = unescape_string(snippet) else {\n+        return InputStringKind::NotALiteral;\n+    };\n+\n+    let unescaped_no_nl = unescaped.trim_end_matches('\\n');\n+\n+    if unescaped_no_nl != input_no_nl {\n+        // The source string that we're pointing at isn't our input, so spans pointing at it will be incorrect.\n+        // This can for example happen with proc macros that respan generated literals.\n+        return InputStringKind::NotALiteral;\n+    }\n+\n     let mut s = snippet.char_indices();\n     let mut width_mappings = vec![];\n     while let Some((pos, c)) = s.next() {\n@@ -936,7 +968,21 @@ fn find_width_map_from_snippet(\n             _ => {}\n         }\n     }\n-    (width_mappings, true)\n+\n+    InputStringKind::Literal { width_mappings }\n+}\n+\n+fn unescape_string(string: &str) -> Result<string::String, unescape::EscapeError> {\n+    let mut buf = string::String::new();\n+    let mut error = Ok(());\n+    unescape::unescape_literal(string, unescape::Mode::Str, &mut |_, unescaped_char| {\n+        match unescaped_char {\n+            Ok(c) => buf.push(c),\n+            Err(err) => error = Err(err),\n+        }\n+    });\n+\n+    error.map(|_| buf)\n }\n \n // Assert a reasonable size for `Piece`"}, {"sha": "fa09b4faa441f3b83d50809c92b426e708784b89", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -964,45 +964,40 @@ impl SourceMap {\n \n     /// Finds the width of the character, either before or after the end of provided span,\n     /// depending on the `forwards` parameter.\n+    #[instrument(skip(self, sp))]\n     fn find_width_of_character_at_span(&self, sp: Span, forwards: bool) -> u32 {\n         let sp = sp.data();\n \n         if sp.lo == sp.hi && !forwards {\n-            debug!(\"find_width_of_character_at_span: early return empty span\");\n+            debug!(\"early return empty span\");\n             return 1;\n         }\n \n         let local_begin = self.lookup_byte_offset(sp.lo);\n         let local_end = self.lookup_byte_offset(sp.hi);\n-        debug!(\n-            \"find_width_of_character_at_span: local_begin=`{:?}`, local_end=`{:?}`\",\n-            local_begin, local_end\n-        );\n+        debug!(\"local_begin=`{:?}`, local_end=`{:?}`\", local_begin, local_end);\n \n         if local_begin.sf.start_pos != local_end.sf.start_pos {\n-            debug!(\"find_width_of_character_at_span: begin and end are in different files\");\n+            debug!(\"begin and end are in different files\");\n             return 1;\n         }\n \n         let start_index = local_begin.pos.to_usize();\n         let end_index = local_end.pos.to_usize();\n-        debug!(\n-            \"find_width_of_character_at_span: start_index=`{:?}`, end_index=`{:?}`\",\n-            start_index, end_index\n-        );\n+        debug!(\"start_index=`{:?}`, end_index=`{:?}`\", start_index, end_index);\n \n         // Disregard indexes that are at the start or end of their spans, they can't fit bigger\n         // characters.\n         if (!forwards && end_index == usize::MIN) || (forwards && start_index == usize::MAX) {\n-            debug!(\"find_width_of_character_at_span: start or end of span, cannot be multibyte\");\n+            debug!(\"start or end of span, cannot be multibyte\");\n             return 1;\n         }\n \n         let source_len = (local_begin.sf.end_pos - local_begin.sf.start_pos).to_usize();\n-        debug!(\"find_width_of_character_at_span: source_len=`{:?}`\", source_len);\n+        debug!(\"source_len=`{:?}`\", source_len);\n         // Ensure indexes are also not malformed.\n         if start_index > end_index || end_index > source_len - 1 {\n-            debug!(\"find_width_of_character_at_span: source indexes are malformed\");\n+            debug!(\"source indexes are malformed\");\n             return 1;\n         }\n \n@@ -1017,10 +1012,10 @@ impl SourceMap {\n         } else {\n             return 1;\n         };\n-        debug!(\"find_width_of_character_at_span: snippet=`{:?}`\", snippet);\n+        debug!(\"snippet=`{:?}`\", snippet);\n \n         let mut target = if forwards { end_index + 1 } else { end_index - 1 };\n-        debug!(\"find_width_of_character_at_span: initial target=`{:?}`\", target);\n+        debug!(\"initial target=`{:?}`\", target);\n \n         while !snippet.is_char_boundary(target - start_index) && target < source_len {\n             target = if forwards {\n@@ -1033,9 +1028,9 @@ impl SourceMap {\n                     }\n                 }\n             };\n-            debug!(\"find_width_of_character_at_span: target=`{:?}`\", target);\n+            debug!(\"target=`{:?}`\", target);\n         }\n-        debug!(\"find_width_of_character_at_span: final target=`{:?}`\", target);\n+        debug!(\"final target=`{:?}`\", target);\n \n         if forwards { (target - end_index) as u32 } else { (end_index - target) as u32 }\n     }"}, {"sha": "539c8fb27b3b0a5b5909b4e791da7d7f3d68bc03", "filename": "src/test/ui/fmt/auxiliary/format-string-proc-macro.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fauxiliary%2Fformat-string-proc-macro.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -5,7 +5,8 @@\n \n extern crate proc_macro;\n \n-use proc_macro::{Literal, Span, TokenStream, TokenTree};\n+use proc_macro::{Delimiter, Group, Ident, Literal, Punct, Spacing, Span, TokenStream, TokenTree};\n+use std::iter::FromIterator;\n \n #[proc_macro]\n pub fn foo_with_input_span(input: TokenStream) -> TokenStream {\n@@ -26,3 +27,14 @@ pub fn err_with_input_span(input: TokenStream) -> TokenStream {\n \n     TokenStream::from(TokenTree::Literal(lit))\n }\n+\n+#[proc_macro]\n+pub fn respan_to_invalid_format_literal(input: TokenStream) -> TokenStream {\n+    let mut s = Literal::string(\"{\");\n+    s.set_span(input.into_iter().next().unwrap().span());\n+    TokenStream::from_iter([\n+        TokenTree::from(Ident::new(\"format\", Span::call_site())),\n+        TokenTree::from(Punct::new('!', Spacing::Alone)),\n+        TokenTree::from(Group::new(Delimiter::Parenthesis, TokenTree::from(s).into())),\n+    ])\n+}"}, {"sha": "44642a10fc076d3c0dfd2bbee21ad09942ebb5b7", "filename": "src/test/ui/fmt/respanned-literal-issue-106191.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.rs?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:format-string-proc-macro.rs\n+\n+extern crate format_string_proc_macro;\n+\n+fn main() {\n+    format_string_proc_macro::respan_to_invalid_format_literal!(\"\u00a1\");\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n+    format_args!(r#concat!(\"\u00a1        {\"));\n+    //~^ ERROR invalid format string: expected `'}'` but string was terminated\n+}"}, {"sha": "73a3af65a3849dbce8754f03987a89fc49bb0343", "filename": "src/test/ui/fmt/respanned-literal-issue-106191.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0c0b403f19fc6febcd1e36a83fc307ecc11de943/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Frespanned-literal-issue-106191.stderr?ref=0c0b403f19fc6febcd1e36a83fc307ecc11de943", "patch": "@@ -0,0 +1,19 @@\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/respanned-literal-issue-106191.rs:6:65\n+   |\n+LL |     format_string_proc_macro::respan_to_invalid_format_literal!(\"\u00a1\");\n+   |                                                                 ^^^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+\n+error: invalid format string: expected `'}'` but string was terminated\n+  --> $DIR/respanned-literal-issue-106191.rs:8:18\n+   |\n+LL |     format_args!(r#concat!(\"\u00a1        {\"));\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `'}'` in format string\n+   |\n+   = note: if you intended to print `{`, you can escape it using `{{`\n+   = note: this error originates in the macro `concat` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}]}