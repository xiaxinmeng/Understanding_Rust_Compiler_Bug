{"sha": "70076ec8b22cba7689c76afef7085cb6917793ef", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMDc2ZWM4YjIyY2JhNzY4OWM3NmFmZWY3MDg1Y2I2OTE3NzkzZWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-02T09:11:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-10-02T09:11:34Z"}, "message": "Auto merge of #28807 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #28554, #28686, #28786, #28788, #28791, #28797\n- Failed merges:", "tree": {"sha": "beb4dc6391a90dfbe6ad45b033d364fca311e40f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/beb4dc6391a90dfbe6ad45b033d364fca311e40f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70076ec8b22cba7689c76afef7085cb6917793ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70076ec8b22cba7689c76afef7085cb6917793ef", "html_url": "https://github.com/rust-lang/rust/commit/70076ec8b22cba7689c76afef7085cb6917793ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70076ec8b22cba7689c76afef7085cb6917793ef/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a004ff5cafb6111bcb3a00d67133a84ff727bad1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a004ff5cafb6111bcb3a00d67133a84ff727bad1", "html_url": "https://github.com/rust-lang/rust/commit/a004ff5cafb6111bcb3a00d67133a84ff727bad1"}, {"sha": "e4797fa22185f9ca52734ab4092754dd5963b3da", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4797fa22185f9ca52734ab4092754dd5963b3da", "html_url": "https://github.com/rust-lang/rust/commit/e4797fa22185f9ca52734ab4092754dd5963b3da"}], "stats": {"total": 164, "additions": 155, "deletions": 9}, "files": [{"sha": "b3c75df550f7f2180727a58dbb127424a2e8776e", "filename": "src/doc/trpl/bibliography.md", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Fdoc%2Ftrpl%2Fbibliography.md", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Fdoc%2Ftrpl%2Fbibliography.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fbibliography.md?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -61,8 +61,9 @@ Language](http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf). Early GPU work\n   Rust](http://scialex.github.io/reenix.pdf). Undergrad paper by Alex\n   Light.\n * [Evaluation of performance and productivity metrics of potential\n-  programming languages in the HPC environment](). Bachelor's thesis by\n-  Florian Wilkens. Compares C, Go and Rust.\n+  programming languages in the HPC environment]\n+  (http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf).\n+  Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.\n * [Nom, a byte oriented, streaming, zero copy, parser combinators library\n   in Rust](http://spw15.langsec.org/papers/couprie-nom.pdf). By\n   Geoffroy Couprie, research for VLC.\n@@ -77,4 +78,4 @@ Language](http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf). Early GPU work\n   Farnstrand's master's thesis.\n * [Session Types for\n   Rust](http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf). Philip\n-  Munksgaard's master's thesis. Research for Servo.\n\\ No newline at end of file\n+  Munksgaard's master's thesis. Research for Servo."}, {"sha": "bcde523307c835d83dee31bcf64608c2a416eac7", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -148,6 +148,81 @@ use super::range::RangeArgument;\n /// if the vector's length is increased to 11, it will have to reallocate, which\n /// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n /// whenever possible to specify how big the vector is expected to get.\n+///\n+/// # Guarantees\n+///\n+/// Due to its incredibly fundamental nature, Vec makes a lot of guarantees\n+/// about its design. This ensures that it's as low-overhead as possible in\n+/// the general case, and can be correctly manipulated in primitive ways\n+/// by unsafe code. Note that these guarantees refer to an unqualified `Vec<T>`.\n+/// If additional type parameters are added (e.g. to support custom allocators),\n+/// overriding their defaults may change the behavior.\n+///\n+/// Most fundamentally, Vec is and always will be a (pointer, capacity, length)\n+/// triplet. No more, no less. The order of these fields is completely\n+/// unspecified, and you should use the appropriate methods to modify these.\n+/// The pointer will never be null, so this type is null-pointer-optimized.\n+///\n+/// However, the pointer may not actually point to allocated memory. In particular,\n+/// if you construct a Vec with capacity 0 via `Vec::new()`, `vec![]`,\n+/// `Vec::with_capacity(0)`, or by calling `shrink_to_fit()` on an empty Vec, it\n+/// will not allocate memory. Similarly, if you store zero-sized types inside\n+/// a Vec, it will not allocate space for them. *Note that in this case the\n+/// Vec may not report a `capacity()` of 0*. Vec will allocate if and only\n+/// if `mem::size_of::<T>() * capacity() > 0`. In general, Vec's allocation\n+/// details are subtle enough that it is strongly recommended that you only\n+/// free memory allocated by a Vec by creating a new Vec and dropping it.\n+///\n+/// If a Vec *has* allocated memory, then the memory it points to is on the heap\n+/// (as defined by the allocator Rust is configured to use by default), and its\n+/// pointer points to `len()` initialized elements in order (what you would see\n+/// if you coerced it to a slice), followed by `capacity() - len()` logically\n+/// uninitialized elements.\n+///\n+/// Vec will never perform a \"small optimization\" where elements are actually\n+/// stored on the stack for two reasons:\n+///\n+/// * It would make it more difficult for unsafe code to correctly manipulate\n+///   a Vec. The contents of a Vec wouldn't have a stable address if it were\n+///   only moved, and it would be more difficult to determine if a Vec had\n+///   actually allocated memory.\n+///\n+/// * It would penalize the general case, incurring an additional branch\n+///   on every access.\n+///\n+/// Vec will never automatically shrink itself, even if completely empty. This\n+/// ensures no unnecessary allocations or deallocations occur. Emptying a Vec\n+/// and then filling it back up to the same `len()` should incur no calls to\n+/// the allocator. If you wish to free up unused memory, use `shrink_to_fit`.\n+///\n+/// `push` and `insert` will never (re)allocate if the reported capacity is\n+/// sufficient. `push` and `insert` *will* (re)allocate if `len() == capacity()`.\n+/// That is, the reported capacity is completely accurate, and can be relied on.\n+/// It can even be used to manually free the memory allocated by a Vec if\n+/// desired. Bulk insertion methods *may* reallocate, even when not necessary.\n+///\n+/// Vec does not guarantee any particular growth strategy when reallocating\n+/// when full, nor when `reserve` is called. The current strategy is basic\n+/// and it may prove desirable to use a non-constant growth factor. Whatever\n+/// strategy is used will of course guarantee `O(1)` amortized `push`.\n+///\n+/// `vec![x; n]`, `vec![a, b, c, d]`, and `Vec::with_capacity(n)`, will all\n+/// produce a Vec with exactly the requested capacity. If `len() == capacity()`,\n+/// (as is the case for the `vec!` macro), then a `Vec<T>` can be converted\n+/// to and from a `Box<[T]>` without reallocating or moving the elements.\n+///\n+/// Vec will not specifically overwrite any data that is removed from it,\n+/// but also won't specifically preserve it. Its uninitialized memory is\n+/// scratch space that it may use however it wants. It will generally just do\n+/// whatever is most efficient or otherwise easy to implement. Do not rely on\n+/// removed data to be erased for security purposes. Even if you drop a Vec, its\n+/// buffer may simply be reused by another Vec. Even if you zero a Vec's memory\n+/// first, that may not actually happen because the optimizer does not consider\n+/// this a side-effect that must be preserved.\n+///\n+/// Vec does not currently guarantee the order in which elements are dropped\n+/// (the order has changed in the past, and may change again).\n+///\n #[unsafe_no_drop_flag]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {"}, {"sha": "d3f427e770cf39e6752387aa85a85001ff16003a", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -367,6 +367,7 @@ pub enum ErrKind {\n     ShiftRightWithOverflow,\n     MissingStructField,\n     NonConstPath,\n+    UnresolvedPath,\n     ExpectedConstTuple,\n     ExpectedConstStruct,\n     TupleIndexOutOfBounds,\n@@ -403,7 +404,8 @@ impl ConstEvalErr {\n             ShiftLeftWithOverflow => \"attempted left shift with overflow\".into_cow(),\n             ShiftRightWithOverflow => \"attempted right shift with overflow\".into_cow(),\n             MissingStructField  => \"nonexistent struct field\".into_cow(),\n-            NonConstPath        => \"non-constant path in constant expr\".into_cow(),\n+            NonConstPath        => \"non-constant path in constant expression\".into_cow(),\n+            UnresolvedPath => \"unresolved path in constant expression\".into_cow(),\n             ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n             ExpectedConstStruct => \"expected constant struct\".into_cow(),\n             TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n@@ -895,7 +897,20 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n       }\n       hir::ExprPath(..) => {\n-          let opt_def = tcx.def_map.borrow().get(&e.id).map(|d| d.full_def());\n+          let opt_def = if let Some(def) = tcx.def_map.borrow().get(&e.id) {\n+              // After type-checking, def_map contains definition of the\n+              // item referred to by the path. During type-checking, it\n+              // can contain the raw output of path resolution, which\n+              // might be a partially resolved path.\n+              // FIXME: There's probably a better way to make sure we don't\n+              // panic here.\n+              if def.depth != 0 {\n+                  signal!(e, UnresolvedPath);\n+              }\n+              Some(def.full_def())\n+          } else {\n+              None\n+          };\n           let (const_expr, const_ty) = match opt_def {\n               Some(def::DefConst(def_id)) => {\n                   if let Some(node_id) = tcx.map.as_local_node_id(def_id) {"}, {"sha": "4147f2bea48509c6eacbb2cfbf24307034a203f9", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -609,6 +609,29 @@ match Something::NotFoo {\n ```\n \"##,\n \n+E0422: r##\"\n+You are trying to use an identifier that is either undefined or not a\n+struct. For instance:\n+```\n+fn main () {\n+    let x = Foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `Foo` is undefined, so it inherently isn't anything, and\n+definitely not a struct.\n+\n+```\n+fn main () {\n+    let foo = 1;\n+    let x = foo { x: 1, y: 2 };\n+}\n+```\n+\n+In this case, `foo` is defined, but is not a struct, so Rust can't use\n+it as one.\n+\"##,\n+\n E0423: r##\"\n A `struct` variant name was used like a function name. Example of\n erroneous code:\n@@ -888,7 +911,6 @@ register_diagnostics! {\n     E0418, // is not an enum variant, struct or const\n     E0420, // is not an associated const\n     E0421, // unresolved associated const\n-    E0422, // does not name a structure\n     E0427, // cannot use `ref` binding mode with ...\n     E0429, // `self` imports are only allowed within a { } list\n     E0434, // can't capture dynamic environment in a fn item"}, {"sha": "6b7ecaa77d10fb004cf90c7abed032ae51b31e0d", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -206,7 +206,7 @@ impl CString {\n     /// Retakes ownership of a CString that was transferred to C.\n     ///\n     /// The only appropriate argument is a pointer obtained by calling\n-    /// `into_ptr`. The length of the string will be recalculated\n+    /// `into_raw`. The length of the string will be recalculated\n     /// using the pointer.\n     #[unstable(feature = \"cstr_memory2\", reason = \"recently added\",\n                issue = \"27769\")]\n@@ -245,11 +245,11 @@ impl CString {\n     /// Transfers ownership of the string to a C caller.\n     ///\n     /// The pointer must be returned to Rust and reconstituted using\n-    /// `from_ptr` to be properly deallocated. Specifically, one\n+    /// `from_raw` to be properly deallocated. Specifically, one\n     /// should *not* use the standard C `free` function to deallocate\n     /// this string.\n     ///\n-    /// Failure to call `from_ptr` will lead to a memory leak.\n+    /// Failure to call `from_raw` will lead to a memory leak.\n     #[stable(feature = \"cstr_memory\", since = \"1.4.0\")]\n     pub fn into_raw(self) -> *mut libc::c_char {\n         Box::into_raw(self.inner) as *mut libc::c_char"}, {"sha": "3c4ad5a56ec362ba221e64cf879cd5ea3acf2616", "filename": "src/test/compile-fail/invalid-path-in-const.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    fn f(a: [u8; u32::DOESNOTEXIST]) {}\n+    //~^ ERROR unresolved path in constant expression\n+}"}, {"sha": "88c48f42c513ccba2b71be4515f8dbc0d06604bb", "filename": "src/test/run-pass/issue-25439.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Ftest%2Frun-pass%2Fissue-25439.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70076ec8b22cba7689c76afef7085cb6917793ef/src%2Ftest%2Frun-pass%2Fissue-25439.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25439.rs?ref=70076ec8b22cba7689c76afef7085cb6917793ef", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Helper<'a, F: 'a>(&'a F);\n+\n+fn fix<F>(f: F) -> i32 where F: Fn(Helper<F>, i32) -> i32 {\n+    f(Helper(&f), 8)\n+}\n+\n+fn main() {\n+    fix(|_, x| x);\n+}"}]}