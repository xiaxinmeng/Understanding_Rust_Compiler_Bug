{"sha": "0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkNmI1MmMyZjNkNDQyZDNlZGZlYTMxYmNjNDM5MTI3YTQ3NTdlNWU=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-10-09T00:14:00Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-07T19:13:19Z"}, "message": "Saturating casts between integers and floats (both directions).\n\nThis affects regular code generation as well as constant evaluation in trans,\nbut not the HIR constant evaluator because that one returns an error for\noverflowing casts and NaN-to-int casts. That error is conservatively\ncorrect and we should be careful to not accept more code in constant\nexpressions.\nThe changes to code generation are guarded by a new -Z flag, to be able\nto evaluate the performance impact. The trans constant evaluation changes\nare unconditional because they have no run time impact and don't affect\ntype checking either.", "tree": {"sha": "340f0188cb0c4953d2f1bfa10e5a2ad46cf4a039", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/340f0188cb0c4953d2f1bfa10e5a2ad46cf4a039"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "html_url": "https://github.com/rust-lang/rust/commit/0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/comments", "author": null, "committer": null, "parents": [{"sha": "7ade24f67201531778e7674b4b63ebf1a23c9643", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ade24f67201531778e7674b4b63ebf1a23c9643", "html_url": "https://github.com/rust-lang/rust/commit/7ade24f67201531778e7674b4b63ebf1a23c9643"}], "stats": {"total": 466, "additions": 453, "deletions": 13}, "files": [{"sha": "0263c74595f261c6b71ad7608944bbb93e0ed384", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -1869,6 +1869,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc-demangle 0.1.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_allocator 0.0.0\",\n+ \"rustc_apfloat 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\","}, {"sha": "4f0e3e8c58a174b4031b8d2883c626f525621ef2", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -1107,6 +1107,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"control whether #[inline] functions are in all cgus\"),\n     tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the TLS model to use (rustc --print tls-models for details)\"),\n+    saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n+        \"make casts between integers and floats safe: clip out-of-range inputs to the min/max \\\n+         integer or to infinity respectively, and turn `NAN` into 0 when casting to integers\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "6f640e580c9d5cdbb99b231725a9b7146ccd0253", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -628,6 +628,8 @@ extern \"C\" {\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n     pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n                                   high: *mut u64, low: *mut u64) -> bool;\n+    pub fn LLVMRustIsConstantFP(ConstantVal: ValueRef) -> bool;\n+    pub fn LLVMRustConstFloatGetBits(ConstantVal: ValueRef) -> u64;\n \n \n     // Operations on composite constants"}, {"sha": "f797464c1f8f13f8ffd4d89397a6e5c55c27ed5b", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -19,6 +19,7 @@ owning_ref = \"0.3.3\"\n rustc-demangle = \"0.1.4\"\n rustc = { path = \"../librustc\" }\n rustc_allocator = { path = \"../librustc_allocator\" }\n+rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }"}, {"sha": "29394af33969faf984129c62405220a621739088", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -24,6 +24,7 @@\n #![feature(custom_attribute)]\n #![allow(unused_attributes)]\n #![feature(i128_type)]\n+#![feature(i128)]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n@@ -43,6 +44,7 @@ extern crate libc;\n extern crate owning_ref;\n #[macro_use] extern crate rustc;\n extern crate rustc_allocator;\n+extern crate rustc_apfloat;\n extern crate rustc_back;\n extern crate rustc_data_structures;\n extern crate rustc_incremental;"}, {"sha": "7fff68abbbedb01b7c4dedc23a40fd45d67d3e7d", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 49, "deletions": 7, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -21,6 +21,7 @@ use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n+use rustc_apfloat::{ieee, Float};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {adt, base, machine};\n use abi::{self, Abi};\n@@ -689,20 +690,16 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                                     llvm::LLVMConstIntCast(llval, ll_t_out.to_ref(), s)\n                                 }\n                                 (CastTy::Int(_), CastTy::Float) => {\n-                                    if signed {\n-                                        llvm::LLVMConstSIToFP(llval, ll_t_out.to_ref())\n-                                    } else {\n-                                        llvm::LLVMConstUIToFP(llval, ll_t_out.to_ref())\n-                                    }\n+                                    const_cast_int_to_float(self.ccx, llval, signed, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Float) => {\n                                     llvm::LLVMConstFPCast(llval, ll_t_out.to_ref())\n                                 }\n                                 (CastTy::Float, CastTy::Int(IntTy::I)) => {\n-                                    llvm::LLVMConstFPToSI(llval, ll_t_out.to_ref())\n+                                    const_cast_from_float(&operand, true, ll_t_out)\n                                 }\n                                 (CastTy::Float, CastTy::Int(_)) => {\n-                                    llvm::LLVMConstFPToUI(llval, ll_t_out.to_ref())\n+                                    const_cast_from_float(&operand, false, ll_t_out)\n                                 }\n                                 (CastTy::Ptr(_), CastTy::Ptr(_)) |\n                                 (CastTy::FnPtr, CastTy::Ptr(_)) |\n@@ -955,6 +952,51 @@ pub fn const_scalar_checked_binop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+unsafe fn const_cast_from_float(operand: &Const, signed: bool, int_ty: Type) -> ValueRef {\n+    let llval = operand.llval;\n+    // Note: this breaks if addresses can be turned into integers (is that possible?)\n+    // But at least an ICE is better than producing undef.\n+    assert!(llvm::LLVMRustIsConstantFP(llval),\n+            \"const_cast_from_float: invalid llval {:?}\", Value(llval));\n+    let bits = llvm::LLVMRustConstFloatGetBits(llval) as u128;\n+    let int_width = int_ty.int_width() as usize;\n+    let float_bits = match operand.ty.sty {\n+        ty::TyFloat(fty) => fty.bit_width(),\n+        _ => bug!(\"const_cast_from_float: operand not a float\"),\n+    };\n+    // Ignore the Status, to_i128 does the Right Thing(tm) on overflow and NaN even though it\n+    // sets INVALID_OP.\n+    let cast_result = match float_bits {\n+        32 if signed => ieee::Single::from_bits(bits).to_i128(int_width).value as u128,\n+        64 if signed => ieee::Double::from_bits(bits).to_i128(int_width).value as u128,\n+        32 => ieee::Single::from_bits(bits).to_u128(int_width).value,\n+        64 => ieee::Double::from_bits(bits).to_u128(int_width).value,\n+        n => bug!(\"unsupported float width {}\", n),\n+    };\n+    C_big_integral(int_ty, cast_result)\n+}\n+\n+unsafe fn const_cast_int_to_float(ccx: &CrateContext,\n+                           llval: ValueRef,\n+                           signed: bool,\n+                           float_ty: Type) -> ValueRef {\n+    // Note: this breaks if addresses can be turned into integers (is that possible?)\n+    // But at least an ICE is better than producing undef.\n+    let value = const_to_opt_u128(llval, signed).unwrap_or_else(|| {\n+        panic!(\"could not get z128 value of constant integer {:?}\",\n+               Value(llval));\n+    });\n+    // If this is an u128 cast and the value is > f32::MAX + 0.5 ULP, round up to infinity.\n+    if signed {\n+        llvm::LLVMConstSIToFP(llval, float_ty.to_ref())\n+    } else if value >= 0xffffff80000000000000000000000000_u128 && float_ty.float_width() == 32 {\n+        let infinity_bits = C_u32(ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        consts::bitcast(infinity_bits, float_ty)\n+    } else {\n+        llvm::LLVMConstUIToFP(llval, float_ty.to_ref())\n+    }\n+}\n+\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn trans_constant(&mut self,\n                           bcx: &Builder<'a, 'tcx>,"}, {"sha": "1986689c77b04a6deea4e6fc93ef18361aede1ef", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 176, "deletions": 6, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -15,11 +15,14 @@ use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n+use rustc_apfloat::{ieee, Float, Status, Round};\n+use std::{u128, i128};\n \n use base;\n use builder::Builder;\n use callee;\n-use common::{self, val_ty, C_bool, C_i32, C_null, C_usize, C_uint};\n+use common::{self, val_ty, C_bool, C_i32, C_u32, C_u64, C_null, C_usize, C_uint, C_big_integral};\n+use consts;\n use adt;\n use machine;\n use monomorphize;\n@@ -333,14 +336,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx.ptrtoint(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Ptr(_)) =>\n                                 bcx.inttoptr(llval, ll_t_out),\n-                            (CastTy::Int(_), CastTy::Float) if signed =>\n-                                bcx.sitofp(llval, ll_t_out),\n                             (CastTy::Int(_), CastTy::Float) =>\n-                                bcx.uitofp(llval, ll_t_out),\n+                                cast_int_to_float(&bcx, signed, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(IntTy::I)) =>\n-                                bcx.fptosi(llval, ll_t_out),\n+                                cast_float_to_int(&bcx, true, llval, ll_t_in, ll_t_out),\n                             (CastTy::Float, CastTy::Int(_)) =>\n-                                bcx.fptoui(llval, ll_t_out),\n+                                cast_float_to_int(&bcx, false, llval, ll_t_in, ll_t_out),\n                             _ => bug!(\"unsupported cast: {:?} to {:?}\", operand.ty, cast_ty)\n                         };\n                         OperandValue::Immediate(newval)\n@@ -815,3 +816,172 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &Builder, ty: Ty) -> ValueRef {\n \n     bcx.ccx.get_intrinsic(&name)\n }\n+\n+fn cast_int_to_float(bcx: &Builder,\n+                     signed: bool,\n+                     x: ValueRef,\n+                     int_ty: Type,\n+                     float_ty: Type) -> ValueRef {\n+    // Most integer types, even i128, fit into [-f32::MAX, f32::MAX] after rounding.\n+    // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n+    // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n+    let is_u128_to_f32 = !signed && int_ty.int_width() == 128 && float_ty.float_width() == 32;\n+    if is_u128_to_f32 && bcx.sess().opts.debugging_opts.saturating_float_casts {\n+        // f32::MAX + 0.5 ULP as u128. All inputs greater or equal to this should be\n+        // rounded to infinity, for everything else LLVM's uitofp works just fine.\n+        let max = C_big_integral(int_ty, 0xffffff80000000000000000000000000_u128);\n+        let overflow = bcx.icmp(llvm::IntUGE, x, max);\n+        let infinity_bits = C_u32(bcx.ccx, ieee::Single::INFINITY.to_bits() as u32);\n+        let infinity = consts::bitcast(infinity_bits, float_ty);\n+        bcx.select(overflow, infinity, bcx.uitofp(x, float_ty))\n+    } else {\n+        if signed {\n+            bcx.sitofp(x, float_ty)\n+        } else {\n+            bcx.uitofp(x, float_ty)\n+        }\n+    }\n+}\n+\n+fn cast_float_to_int(bcx: &Builder,\n+                     signed: bool,\n+                     x: ValueRef,\n+                     float_ty: Type,\n+                     int_ty: Type) -> ValueRef {\n+    if !bcx.sess().opts.debugging_opts.saturating_float_casts {\n+        if signed {\n+            return bcx.fptosi(x, int_ty);\n+        } else {\n+            return bcx.fptoui(x, int_ty);\n+        }\n+    }\n+    // LLVM's fpto[su]i returns undef when the input x is infinite, NaN, or does not fit into the\n+    // destination integer type after rounding towards zero. This `undef` value can cause UB in\n+    // safe code (see issue #10184), so we implement a saturating conversion on top of it:\n+    // Semantically, the mathematical value of the input is rounded towards zero to the next\n+    // mathematical integer, and then the result is clamped into the range of the destination\n+    // integer type. Positive and negative infinity are mapped to the maximum and minimum value of\n+    // the destination integer type. NaN is mapped to 0.\n+    //\n+    // Define f_min and f_max as the largest and smallest (finite) floats that are exactly equal to\n+    // a value representable in int_ty.\n+    // They are exactly equal to int_ty::{MIN,MAX} if float_ty has enough significand bits.\n+    // Otherwise, int_ty::MAX must be rounded towards zero, as it is one less than a power of two.\n+    // int_ty::MIN, however, is either zero or a negative power of two and is thus exactly\n+    // representable. Note that this only works if float_ty's exponent range is sufficently large.\n+    // f16 or 256 bit integers would break this property. Right now the smallest float type is f32\n+    // with exponents ranging up to 127, which is barely enough for i128::MIN = -2^127.\n+    // On the other hand, f_max works even if int_ty::MAX is greater than float_ty::MAX. Because\n+    // we're rounding towards zero, we just get float_ty::MAX (which is always an integer).\n+    // This already happens today with u128::MAX = 2^128 - 1 > f32::MAX.\n+    fn compute_clamp_bounds<F: Float>(signed: bool, int_ty: Type) -> (u128, u128, Status) {\n+        let f_min = if signed {\n+            let int_min = i128::MIN >> (128 - int_ty.int_width());\n+            let rounded_min = F::from_i128_r(int_min, Round::TowardZero);\n+            assert_eq!(rounded_min.status, Status::OK);\n+            rounded_min.value\n+        } else {\n+            F::ZERO\n+        };\n+\n+        let rounded_max = F::from_u128_r(int_max(signed, int_ty), Round::TowardZero);\n+        assert!(rounded_max.value.is_finite());\n+\n+        (f_min.to_bits(), rounded_max.value.to_bits(), rounded_max.status)\n+    }\n+    fn int_max(signed: bool, int_ty: Type) -> u128 {\n+        let shift_amount = 128 - int_ty.int_width();\n+        if signed {\n+            i128::MAX as u128 >> shift_amount\n+        } else {\n+            u128::MAX >> shift_amount\n+        }\n+    }\n+    let (f_min, f_max, f_max_status) = match float_ty.float_width() {\n+        32 => compute_clamp_bounds::<ieee::Single>(signed, int_ty),\n+        64 => compute_clamp_bounds::<ieee::Double>(signed, int_ty),\n+        n => bug!(\"unsupported float width {}\", n),\n+    };\n+    let float_bits_to_llval = |bits| {\n+        let bits_llval = match float_ty.float_width() {\n+            32 => C_u32(bcx.ccx, bits as u32),\n+            64 => C_u64(bcx.ccx, bits as u64),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        consts::bitcast(bits_llval, float_ty)\n+    };\n+    let f_min = float_bits_to_llval(f_min);\n+    let f_max = float_bits_to_llval(f_max);\n+    // To implement saturation, we perform the following steps (not all steps are necessary for\n+    // all combinations of int_ty and float_ty, but we'll deal with that below):\n+    //\n+    // 1. Clamp x into the range [f_min, f_max] in such a way that NaN becomes f_min.\n+    // 2. If x is NaN, replace the result of the clamping with 0.0, otherwise\n+    //    keep the clamping result.\n+    // 3. Now cast the result of step 2 with fpto[su]i.\n+    // 4. If x > f_max, return int_ty::MAX, otherwise return the result of step 3.\n+    //\n+    // This avoids undef because values in range [f_min, f_max] by definition fit into the\n+    // destination type. More importantly, it correctly implements saturating conversion.\n+    // Proof (sketch):\n+    // If x is NaN, step 2 yields 0.0, which is converted to 0 in step 3, and NaN > f_max does\n+    // not hold in step 4, therefore 0 is returned, as desired.\n+    // Otherwise, x is finite or infinite and thus can be compared with f_min and f_max.\n+    // This yields three cases to consider:\n+    // (1) if x in [f_min, f_max], steps 1, 2, and 4 do nothing and the result of fpto[su]i\n+    //     is returned, which agrees with saturating conversion for inputs in that range.\n+    // (2) if x > f_max, then x is larger than int_ty::MAX and step 4 correctly returns\n+    //     int_ty::MAX. This holds even if f_max is rounded (i.e., if f_max < int_ty::MAX)\n+    //     because in those cases, nextUp(f_max) is already larger than int_ty::MAX.\n+    // (3) if x < f_min, then x is smaller than int_ty::MIN and is clamped to f_min. As shown\n+    //     earlier, f_min exactly equals int_ty::MIN and therefore no fixup analogous to step 4\n+    //     is needed. Instead, step 3 casts f_min to int_ty::MIN and step 4 returns this cast\n+    //     result, as desired.\n+    // QED.\n+\n+    // Step 1: Clamping. Computed as:\n+    //    clamped_to_min = if f_min < x { x } else { f_min };\n+    //    clamped_x = if f_max < clamped_to_min { f_max } else { clamped_to_min };\n+    // Note that for x = NaN, both of the above variables become f_min.\n+    let clamped_to_min = bcx.select(bcx.fcmp(llvm::RealOLT, f_min, x), x, f_min);\n+    let clamped_x = bcx.select(\n+                                bcx.fcmp(llvm::RealOLT, f_max, clamped_to_min),\n+                                f_max,\n+                                clamped_to_min\n+                            );\n+\n+    // Step 2: NaN replacement.\n+    // For unsigned types, f_min == 0.0 and therefore clamped_x is already zero.\n+    // Therefore we only need to execute this step for signed integer types.\n+    let clamped_x = if signed {\n+        let zero = match float_ty.float_width() {\n+            32 => float_bits_to_llval(ieee::Single::ZERO.to_bits()),\n+            64 => float_bits_to_llval(ieee::Double::ZERO.to_bits()),\n+            n => bug!(\"unsupported float width {}\", n),\n+        };\n+        // LLVM has no isNaN predicate, so we use (x == x) instead\n+        bcx.select(bcx.fcmp(llvm::RealOEQ, x, x), clamped_x, zero)\n+    } else {\n+        clamped_x\n+    };\n+\n+    // Step 3: fpto[su]i cast\n+    let cast_result = if signed {\n+        bcx.fptosi(clamped_x, int_ty)\n+    } else {\n+        bcx.fptoui(clamped_x, int_ty)\n+    };\n+\n+    // Step 4: f_max fixup.\n+    // Note that x > f_max implies that x was clamped to f_max in step 1, and therefore the\n+    // cast result is the integer equal to f_max. If the conversion from int_ty::MAX to f_max\n+    // was exact, then the result of casting f_max is again int_ty::MAX, so we'd return the same\n+    // value whether or not x > f_max holds. Therefore, we only need to execute this step\n+    // if f_max is inexact.\n+    if f_max_status.contains(Status::INEXACT) {\n+        let int_max = C_big_integral(int_ty, int_max(signed, int_ty));\n+        bcx.select(bcx.fcmp(llvm::RealOGT, x, f_max), int_max, cast_result)\n+    } else {\n+        cast_result\n+    }\n+}"}, {"sha": "db6802320b3c7980bb4aa6d722216e6b93c4c1f0", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -1373,6 +1373,19 @@ extern \"C\" bool LLVMRustConstInt128Get(LLVMValueRef CV, bool sext, uint64_t *hig\n     return true;\n }\n \n+extern \"C\" uint64_t LLVMRustConstFloatGetBits(LLVMValueRef CV) {\n+    auto C = unwrap<llvm::ConstantFP>(CV);\n+    APInt Bits = C->getValueAPF().bitcastToAPInt();\n+    if (!Bits.isIntN(64)) {\n+      report_fatal_error(\"Float bit pattern >64 bits\");\n+    }\n+    return Bits.getLimitedValue();\n+}\n+\n+extern \"C\" bool LLVMRustIsConstantFP(LLVMValueRef CV) {\n+  return isa<llvm::ConstantFP>(unwrap<llvm::Value>(CV));\n+}\n+\n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n   return wrap(&unwrap(V)->getContext());\n }"}, {"sha": "64ab19cceee2d2399eb2b1f6ca02d49265acbe60", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -0,0 +1,65 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// This file tests that we don't generate any code for saturation if\n+// -Z saturating-float-casts is not enabled.\n+\n+#![crate_type = \"lib\"]\n+#![feature(i128_type)]\n+\n+// CHECK-LABEL: @f32_to_u32\n+#[no_mangle]\n+pub fn f32_to_u32(x: f32) -> u32 {\n+    // CHECK: fptoui\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as u32\n+}\n+\n+// CHECK-LABEL: @f32_to_i32\n+#[no_mangle]\n+pub fn f32_to_i32(x: f32) -> i32 {\n+    // CHECK: fptosi\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as i32\n+}\n+\n+#[no_mangle]\n+pub fn f64_to_u8(x: f32) -> u16 {\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as u16\n+}\n+\n+// CHECK-LABEL: @i32_to_f64\n+#[no_mangle]\n+pub fn i32_to_f64(x: i32) -> f64 {\n+    // CHECK: sitofp\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as f64\n+}\n+\n+// CHECK-LABEL: @u128_to_f32\n+#[no_mangle]\n+pub fn u128_to_f32(x: u128) -> f32 {\n+    // CHECK: uitofp\n+    // CHECK-NOT: fcmp\n+    // CHECK-NOT: icmp\n+    // CHECK-NOT: select\n+    x as f32\n+}"}, {"sha": "53e0cea64e9858098816752d7a45a18c3a00b24c", "filename": "src/test/run-pass/saturating-float-casts.rs", "status": "added", "additions": 141, "deletions": 0, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0d6b52c2f3d442d3edfea31bcc439127a4757e5e/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs?ref=0d6b52c2f3d442d3edfea31bcc439127a4757e5e", "patch": "@@ -0,0 +1,141 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z saturating-float-casts\n+\n+#![feature(test, i128, i128_type, stmt_expr_attributes)]\n+#![deny(overflowing_literals)]\n+extern crate test;\n+\n+use std::{f32, f64};\n+use std::{u8, i8, u16, i16, u32, i32, u64, i64, u128, i128};\n+use test::black_box;\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => (\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        // ... whereas this variant triggers constant evaluation:\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+    );\n+\n+    ($fval:expr, f* -> $ity:ident, $ival:expr) => (\n+        test!($fval, f32 -> $ity, $ival);\n+        test!($fval, f64 -> $ity, $ival);\n+    )\n+}\n+\n+macro_rules! common_fptoi_tests {\n+    ($fty:ident -> $($ity:ident)+) => ({ $(\n+        test!($fty::NAN, $fty -> $ity, 0);\n+        test!($fty::INFINITY, $fty -> $ity, $ity::MAX);\n+        test!($fty::NEG_INFINITY, $fty -> $ity, $ity::MIN);\n+        // These two tests are not solely float->int tests, in particular the latter relies on\n+        // `u128::MAX as f32` not being UB. But that's okay, since this file tests int->float\n+        // as well, the test is just slightly misplaced.\n+        test!($ity::MIN as $fty, $fty -> $ity, $ity::MIN);\n+        test!($ity::MAX as $fty, $fty -> $ity, $ity::MAX);\n+        test!(0., $fty -> $ity, 0);\n+        test!($fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.9, $fty -> $ity, 0);\n+        test!(1., $fty -> $ity, 1);\n+        test!(42., $fty -> $ity, 42);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        common_fptoi_tests!(f32 -> $($ity)+);\n+        common_fptoi_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+macro_rules! fptoui_tests {\n+    ($fty: ident -> $($ity: ident)+) => ({ $(\n+        test!(-0., $fty -> $ity, 0);\n+        test!(-$fty::MIN_POSITIVE, $fty -> $ity, 0);\n+        test!(-0.99999994, $fty -> $ity, 0);\n+        test!(-1., $fty -> $ity, 0);\n+        test!(-100., $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e50, $fty -> $ity, 0);\n+        test!(#[allow(overflowing_literals)] -1e130, $fty -> $ity, 0);\n+    )+ });\n+\n+    (f* -> $($ity:ident)+) => ({\n+        fptoui_tests!(f32 -> $($ity)+);\n+        fptoui_tests!(f64 -> $($ity)+);\n+    })\n+}\n+\n+pub fn main() {\n+    common_fptoi_tests!(f* -> i8 i16 i32 i64 i128 u8 u16 u32 u64 u128);\n+    fptoui_tests!(f* -> u8 u16 u32 u64 u128);\n+\n+    // The following tests cover edge cases for some integer types.\n+\n+    // u8\n+    test!(254., f* -> u8, 254);\n+    test!(256., f* -> u8, 255);\n+\n+    // i8\n+    test!(-127., f* -> i8, -127);\n+    test!(-129., f* -> i8, -128);\n+    test!(126., f* -> i8, 126);\n+    test!(128., f* -> i8, 127);\n+\n+    // i32\n+    // -2147483648. is i32::MIN (exactly)\n+    test!(-2147483648., f* -> i32, i32::MIN);\n+    // 2147483648. is i32::MAX rounded up\n+    test!(2147483648., f32 -> i32, 2147483647);\n+    // With 24 significand bits, floats with magnitude in [2^30 + 1, 2^31] are rounded to\n+    // multiples of 2^7. Therefore, nextDown(round(i32::MAX)) is 2^31 - 128:\n+    test!(2147483520., f32 -> i32, 2147483520);\n+    // Similarly, nextUp(i32::MIN) is i32::MIN + 2^8 and nextDown(i32::MIN) is i32::MIN - 2^7\n+    test!(-2147483904., f* -> i32, i32::MIN);\n+    test!(-2147483520., f* -> i32, -2147483520);\n+\n+    // u32 -- round(MAX) and nextUp(round(MAX))\n+    test!(4294967040., f* -> u32, 4294967040);\n+    test!(4294967296., f* -> u32, 4294967295);\n+\n+    // u128\n+    // # float->int\n+    test!(f32::MAX, f32 -> u128, 0xffffff00000000000000000000000000);\n+    // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+    const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+    test!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n+    // # int->float\n+    // f32::MAX - 0.5 ULP and smaller should be rounded down\n+    test!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    test!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n+    test!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    // numbers within < 0.5 ULP of f32::MAX it should be rounded to f32::MAX\n+    test!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n+    test!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    test!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n+    test!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n+    test!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    // f32::MAX + 0.5 ULP and greater should be rounded to infinity\n+    test!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n+    test!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n+    test!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n+\n+    test!(!0, u128 -> f32, f32::INFINITY);\n+\n+    // u128->f64 should not be affected by the u128->f32 checks\n+    test!(0xffffff80000000000000000000000000, u128 -> f64,\n+          340282356779733661637539395458142568448.0);\n+    test!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n+}"}]}