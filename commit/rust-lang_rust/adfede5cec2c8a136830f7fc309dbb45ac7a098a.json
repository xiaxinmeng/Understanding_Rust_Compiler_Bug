{"sha": "adfede5cec2c8a136830f7fc309dbb45ac7a098a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkZmVkZTVjZWMyYzhhMTM2ODMwZjdmYzMwOWRiYjQ1YWM3YTA5OGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-11-20T09:16:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-20T09:16:58Z"}, "message": "Merge pull request #526 from RalfJung/mut-visitor\n\nRetagging: Recurse into compound values", "tree": {"sha": "b390119aa2f8930335d44d92ac9d220819942d23", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b390119aa2f8930335d44d92ac9d220819942d23"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/adfede5cec2c8a136830f7fc309dbb45ac7a098a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb89EKCRBK7hj4Ov3rIwAAdHIIAKyZdvsY/riAl+OT+iMNePc7\neFpkORYUxIJKjRqH2MqBzjCv9LNm1BoN5DmcT6sEERNKZYMowpi9FbTmiy4r8D78\nDhYgkcmBlcbMhNkdDqw21c1LIOi/mmvLGCrvg8QUTZd12a/JBD2nAAZlQDUP2ghY\nLl5PDeaRsf2Y/3JX0COEDC51cNb4fTz/lMjSDEzJjns1FMmk0/goRIJhugkMEev/\nIf8NFnWY7PdhD+LTnKaX4B9viny8pNhHl/GsN16cg9yaXsq9MArnqkDE09urwyYI\n2ndpP93NFXs113TZbZnqwu9u3MuKQE3PJAeadesfjVb3HfD3Kep9Kp6gdsNddMQ=\n=g1A/\n-----END PGP SIGNATURE-----\n", "payload": "tree b390119aa2f8930335d44d92ac9d220819942d23\nparent dc2d15d883bcd2f7845e4c819576a9c8b676a10f\nparent 5b095e16520e28ed2333879798f666c2a3d6c8f9\nauthor Ralf Jung <post@ralfj.de> 1542705418 +0100\ncommitter GitHub <noreply@github.com> 1542705418 +0100\n\nMerge pull request #526 from RalfJung/mut-visitor\n\nRetagging: Recurse into compound values"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/adfede5cec2c8a136830f7fc309dbb45ac7a098a", "html_url": "https://github.com/rust-lang/rust/commit/adfede5cec2c8a136830f7fc309dbb45ac7a098a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/adfede5cec2c8a136830f7fc309dbb45ac7a098a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc2d15d883bcd2f7845e4c819576a9c8b676a10f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc2d15d883bcd2f7845e4c819576a9c8b676a10f", "html_url": "https://github.com/rust-lang/rust/commit/dc2d15d883bcd2f7845e4c819576a9c8b676a10f"}, {"sha": "5b095e16520e28ed2333879798f666c2a3d6c8f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b095e16520e28ed2333879798f666c2a3d6c8f9", "html_url": "https://github.com/rust-lang/rust/commit/5b095e16520e28ed2333879798f666c2a3d6c8f9"}], "stats": {"total": 413, "additions": 293, "deletions": 120}, "files": [{"sha": "3dc47f1c67b6aef0e1e3b16145f20ee02e68c908", "filename": "appveyor.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -37,7 +37,7 @@ build: false\n test_script:\n     - set RUSTFLAGS=-g\n     - set RUST_BACKTRACE=1\n-    - cargo build --release --all-targets --all-features\n+    - cargo build --release --all-features --all-targets\n     - cargo test --release --all-features\n     - set MIRI_SYSROOT=%USERPROFILE%\\.xargo\\HOST\n     - cargo test --release --all-features"}, {"sha": "dcd90feeda812664c3894a46f2b7fa43d49d5a9e", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -1 +1 @@\n-nightly-2018-11-16\n+nightly-2018-11-20"}, {"sha": "509db0355e2ba3bc14399a74b4f76905a567d075", "filename": "src/fn_call.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -131,10 +131,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"free\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 if !ptr.is_null_ptr(self) {\n                     self.memory_mut().deallocate(\n-                        ptr.to_ptr()?.with_default_tag(),\n+                        ptr.to_ptr()?,\n                         None,\n                         MiriMemoryKind::C.into(),\n                     )?;\n@@ -179,7 +179,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n                 let old_size = self.read_scalar(args[1])?.to_usize(self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(self)?;\n                 if old_size == 0 {\n@@ -189,13 +189,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 self.memory_mut().deallocate(\n-                    ptr.with_default_tag(),\n+                    ptr,\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n             }\n             \"__rust_realloc\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation, no tag\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n                 let old_size = self.read_scalar(args[1])?.to_usize(self)?;\n                 let align = self.read_scalar(args[2])?.to_usize(self)?;\n                 let new_size = self.read_scalar(args[3])?.to_usize(self)?;\n@@ -206,7 +206,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n                 let new_ptr = self.memory_mut().reallocate(\n-                    ptr.with_default_tag(),\n+                    ptr,\n                     Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     Size::from_bytes(new_size),\n@@ -238,8 +238,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n-                let symbol = self.read_scalar(args[1])?.to_ptr()?.erase_tag();\n-                let symbol_name = self.memory().read_c_str(symbol.with_default_tag())?;\n+                let symbol = self.read_scalar(args[1])?.to_ptr()?;\n+                let symbol_name = self.memory().read_c_str(symbol)?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -292,13 +292,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 return err!(MachineError(\"the evaluated program panicked\".to_string())),\n \n             \"memcmp\" => {\n-                let left = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n-                let right = self.read_scalar(args[1])?.not_undef()?.erase_tag(); // raw ptr operation\n+                let left = self.read_scalar(args[0])?.not_undef()?;\n+                let right = self.read_scalar(args[1])?.not_undef()?;\n                 let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(self)?);\n \n                 let result = {\n-                    let left_bytes = self.memory().read_bytes(left.with_default_tag(), n)?;\n-                    let right_bytes = self.memory().read_bytes(right.with_default_tag(), n)?;\n+                    let left_bytes = self.memory().read_bytes(left, n)?;\n+                    let right_bytes = self.memory().read_bytes(right, n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -315,8 +315,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"memrchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n-                let ptr = ptr.with_default_tag();\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?\n@@ -330,8 +329,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"memchr\" => {\n-                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n-                let ptr = ptr.with_default_tag();\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(self)?;\n                 if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n@@ -347,8 +345,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"getenv\" => {\n                 let result = {\n-                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let name = self.memory().read_c_str(name_ptr.with_default_tag())?;\n+                    let name_ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                    let name = self.memory().read_c_str(name_ptr)?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(&*self.tcx),\n@@ -360,10 +358,10 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"unsetenv\" => {\n                 let mut success = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n                     if !name_ptr.is_null_ptr(self) {\n                         let name = self.memory().read_c_str(name_ptr.to_ptr()?\n-                            .with_default_tag())?.to_owned();\n+                            )?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             success = Some(self.machine.env_vars.remove(&name));\n                         }\n@@ -382,11 +380,11 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"setenv\" => {\n                 let mut new = None;\n                 {\n-                    let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n-                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let value = self.memory().read_c_str(value_ptr.with_default_tag())?;\n+                    let name_ptr = self.read_scalar(args[0])?.not_undef()?;\n+                    let value_ptr = self.read_scalar(args[1])?.to_ptr()?;\n+                    let value = self.memory().read_c_str(value_ptr)?;\n                     if !name_ptr.is_null_ptr(self) {\n-                        let name = self.memory().read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n+                        let name = self.memory().read_c_str(name_ptr.to_ptr()?)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n@@ -417,14 +415,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"write\" => {\n                 let fd = self.read_scalar(args[0])?.to_bytes()?;\n-                let buf = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n+                let buf = self.read_scalar(args[1])?.not_undef()?;\n                 let n = self.read_scalar(args[2])?.to_bytes()? as u64;\n                 trace!(\"Called write({:?}, {:?}, {:?})\", fd, buf, n);\n                 let result = if fd == 1 || fd == 2 {\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory().read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n+                    let buf_cont = self.memory().read_bytes(buf, Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -445,8 +443,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             }\n \n             \"strlen\" => {\n-                let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag();\n-                let n = self.memory().read_c_str(ptr.with_default_tag())?.len();\n+                let ptr = self.read_scalar(args[0])?.to_ptr()?;\n+                let n = self.memory().read_c_str(ptr)?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -492,7 +490,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             // Hook pthread calls that go to the thread-local storage memory subsystem\n             \"pthread_key_create\" => {\n-                let key_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n+                let key_ptr = self.read_scalar(args[0])?.to_ptr()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n@@ -515,7 +513,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     return err!(OutOfTls);\n                 }\n                 self.memory_mut().write_scalar(\n-                    key_ptr.with_default_tag(),\n+                    key_ptr,\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),\n                     key_layout.size,"}, {"sha": "85329ddcf17f50a16d6cbe25d8cbca2c7911700b", "filename": "src/helpers.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -158,8 +158,10 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             unsafe_cell_action: F,\n         }\n \n-        impl<'ecx, 'a, 'mir, 'tcx, F> ValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n-        for UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n+        impl<'ecx, 'a, 'mir, 'tcx, F>\n+            ValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n+        for\n+            UnsafeCellVisitor<'ecx, 'a, 'mir, 'tcx, F>\n         where\n             F: FnMut(MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n         {\n@@ -230,7 +232,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'mir, 'tcx, super:\n             }\n \n             // We should never get to a primitive, but always short-circuit somewhere above\n-            fn visit_primitive(&mut self, _val: ImmTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            fn visit_primitive(&mut self, _v: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n             {\n                 bug!(\"We should always short-circit before coming to a primitive\")\n             }"}, {"sha": "6d5ac8d88bae293693babc778aae55f0bb77e069", "filename": "src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -154,12 +154,12 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let count = self.read_scalar(args[2])?.to_usize(self)?;\n                 let elem_align = elem_layout.align;\n                 // erase tags: this is a raw ptr operation\n-                let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n-                let dest = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n+                let src = self.read_scalar(args[0])?.not_undef()?;\n+                let dest = self.read_scalar(args[1])?.not_undef()?;\n                 self.memory_mut().copy(\n-                    src.with_default_tag(),\n+                    src,\n                     elem_align,\n-                    dest.with_default_tag(),\n+                    dest,\n                     elem_align,\n                     Size::from_bytes(count * elem_size),\n                     intrinsic_name.ends_with(\"_nonoverlapping\"),\n@@ -436,7 +436,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let ty = substs.type_at(0);\n                 let ty_layout = self.layout_of(ty)?;\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n-                let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n                 let count = self.read_scalar(args[2])?.to_usize(self)?;\n                 self.memory().check_align(ptr, ty_layout.align)?;\n                 self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;"}, {"sha": "418f8f60cecd9df14c186b0b14aa3d5ed4c2b2f3", "filename": "src/lib.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n \n use syntax::attr;\n-\n+use syntax::source_map::DUMMY_SP;\n \n pub use rustc_mir::interpret::*;\n pub use rustc_mir::interpret::{self, AllocMap, PlaceTy}; // resolve ambiguity\n@@ -113,7 +113,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // Push our stack frame\n         ecx.push_stack_frame(\n             start_instance,\n-            start_mir.span,\n+            DUMMY_SP, // there is no call site, we want no span\n             start_mir,\n             Some(ret_ptr.into()),\n             StackPopCleanup::None { cleanup: true },\n@@ -146,7 +146,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let ret_place = MPlaceTy::dangling(ecx.layout_of(tcx.mk_unit())?, &ecx).into();\n         ecx.push_stack_frame(\n             main_instance,\n-            main_mir.span,\n+            DUMMY_SP, // there is no call site, we want no span\n             main_mir,\n             Some(ret_place),\n             StackPopCleanup::None { cleanup: true },\n@@ -185,7 +185,7 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     match res {\n         Ok(()) => {\n             let leaks = ecx.memory().leak_report();\n-            // Disable the leak test on some platforms where we likely do not\n+            // Disable the leak test on some platforms where we do not\n             // correctly implement TLS destructors.\n             let target_os = ecx.tcx.tcx.sess.target.target.target_os.to_lowercase();\n             let ignore_leaks = target_os == \"windows\" || target_os == \"macos\";\n@@ -208,8 +208,16 @@ pub fn eval_main<'a, 'tcx: 'a>(\n                 let mut err = struct_error(ecx.tcx.tcx.at(span), msg.as_str());\n                 let frames = ecx.generate_stacktrace(None);\n                 err.span_label(span, e);\n-                for FrameInfo { span, location, .. } in frames {\n-                    err.span_note(span, &format!(\"inside call to `{}`\", location));\n+                // we iterate with indices because we need to look at the next frame (the caller)\n+                for idx in 0..frames.len() {\n+                    let frame_info = &frames[idx];\n+                    let call_site_is_local = frames.get(idx+1).map_or(false,\n+                        |caller_info| caller_info.instance.def_id().is_local());\n+                    if call_site_is_local {\n+                        err.span_note(frame_info.call_site, &frame_info.to_string());\n+                    } else {\n+                        err.note(&frame_info.to_string());\n+                    }\n                 }\n                 err.emit();\n             } else {\n@@ -312,8 +320,6 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             // Uses mem::uninitialized\n             (\"std::ptr::read\", \"\"),\n             (\"std::sys::windows::mutex::Mutex::\", \"\"),\n-            // Should directly take a raw reference\n-            (\"<std::cell::UnsafeCell<T>>\", \"::get\"),\n         ];\n         for frame in ecx.stack().iter()\n             .rev().take(3)\n@@ -461,9 +467,9 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n             // No tracking\n             Ok(place.ptr)\n         } else {\n-            let ptr = place.ptr.to_ptr()?; // assert this is not a scalar\n-            let tag = ecx.tag_dereference(place, size, mutability.into())?;\n-            Ok(Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag)))\n+            ecx.ptr_dereference(place, size, mutability.into())?;\n+            // We never change the pointer\n+            Ok(place.ptr)\n         }\n     }\n "}, {"sha": "be05c2259957e5e8e878ce406484ba7f2593325b", "filename": "src/operator.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -142,8 +142,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // allocations sit right next to each other.  The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n-                    self.memory().check_bounds_ptr(left, false)?;\n-                    self.memory().check_bounds_ptr(right, false)?;\n+                    // We require liveness, as dead allocations can of course overlap.\n+                    self.memory().check_bounds_ptr(left, InboundsCheck::Live)?;\n+                    self.memory().check_bounds_ptr(right, InboundsCheck::Live)?;\n                     // Two live in-bounds pointers, we can compare across allocations\n                     left == right\n                 }\n@@ -153,15 +154,17 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n                 let bits = bits as u64;\n-                let (alloc_size, alloc_align) = self.memory().get_size_and_align(ptr.alloc_id);\n \n                 // Case I: Comparing with NULL\n                 if bits == 0 {\n                     // Test if the ptr is in-bounds. Then it cannot be NULL.\n-                    if ptr.offset <= alloc_size {\n+                    if self.memory().check_bounds_ptr(ptr, InboundsCheck::MaybeDead).is_ok() {\n                         return Ok(false);\n                     }\n                 }\n+\n+                let (alloc_size, alloc_align) = self.memory().get_size_and_align(ptr.alloc_id);\n+\n                 // Case II: Alignment gives it away\n                 if ptr.offset.bytes() % alloc_align.abi() == 0 {\n                     // The offset maintains the allocation alignment, so we know `base+offset`\n@@ -293,11 +296,11 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         let offset = offset.checked_mul(pointee_size).ok_or_else(|| EvalErrorKind::Overflow(mir::BinOp::Mul))?;\n         // Now let's see what kind of pointer this is\n         if let Scalar::Ptr(ptr) = ptr {\n-            // Both old and new pointer must be in-bounds.\n+            // Both old and new pointer must be in-bounds of a *live* allocation.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory().check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory().check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, InboundsCheck::Live)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "063a544baa655092934be8ef9601822507772318", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 114, "deletions": 53, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -4,8 +4,8 @@ use rustc::ty::{self, layout::Size};\n use rustc::hir::{Mutability, MutMutable, MutImmutable};\n \n use crate::{\n-    EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt,\n-    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra,\n+    EvalResult, EvalErrorKind, MiriEvalContext, HelpersEvalContextExt, Evaluator, MutValueVisitor,\n+    MemoryKind, MiriMemoryKind, RangeMap, AllocId, Allocation, AllocationExtra, InboundsCheck,\n     Pointer, MemPlace, Scalar, Immediate, ImmTy, PlaceTy, MPlaceTy,\n };\n \n@@ -303,6 +303,9 @@ impl<'tcx> Stacks {\n         trace!(\"{} access of tag {:?}: {:?}, size {}\",\n             if is_write { \"read\" } else { \"write\" },\n             ptr.tag, ptr, size.bytes());\n+        // Even reads can have a side-effect, by invalidating other references.\n+        // This is fundamentally necessary since `&mut` asserts that there\n+        // are no accesses through other references, not even reads.\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n             stack.access(ptr.tag, is_write)?;\n@@ -311,6 +314,7 @@ impl<'tcx> Stacks {\n     }\n \n     /// Reborrow the given pointer to the new tag for the given kind of reference.\n+    /// This works on `&self` because we might encounter references to constant memory.\n     fn reborrow(\n         &self,\n         ptr: Pointer<Borrow>,\n@@ -401,21 +405,29 @@ impl<'tcx> Stacks {\n \n \n pub trait EvalContextExt<'tcx> {\n-    fn tag_dereference(\n+    fn ptr_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         mutability: Option<Mutability>,\n-    ) -> EvalResult<'tcx, Borrow>;\n+    ) -> EvalResult<'tcx>;\n \n     fn tag_new_allocation(\n         &mut self,\n         id: AllocId,\n         kind: MemoryKind<MiriMemoryKind>,\n     ) -> Borrow;\n \n-    /// Retag an indidual pointer, returning the retagged version.\n+    /// Reborrow the given place, returning the newly tagged ptr to it.\n     fn reborrow(\n+        &mut self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+        new_bor: Borrow\n+    ) -> EvalResult<'tcx, Pointer<Borrow>>;\n+\n+    /// Retag an indidual pointer, returning the retagged version.\n+    fn retag_reference(\n         &mut self,\n         ptr: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n@@ -468,13 +480,13 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n     ///\n     /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n     /// We could be in the middle of `&(*var).1`.\n-    fn tag_dereference(\n+    fn ptr_dereference(\n         &self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n         mutability: Option<Mutability>,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        trace!(\"tag_dereference: Accessing {} reference for {:?} (pointee {})\",\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"ptr_dereference: Accessing {} reference for {:?} (pointee {})\",\n             if let Some(mutability) = mutability { format!(\"{:?}\", mutability) } else { format!(\"raw\") },\n             place.ptr, place.layout.ty);\n         let ptr = place.ptr.to_ptr()?;\n@@ -485,12 +497,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n         match (mutability, ptr.tag) {\n             (None, _) => {\n-                // Don't use the tag, this is a raw access!  They should happen tagless.\n-                // This is needed for `*mut` to make any sense: Writes *do* enforce the\n-                // `Uniq` tag to be up top, but we must make sure raw writes do not do that.\n-                // This does mean, however, that `&*foo` is *not* a NOP *if* `foo` is a raw ptr.\n-                // Also don't do any further validation, this is raw after all.\n-                return Ok(Borrow::default());\n+                // No further validation on raw accesses.\n+                return Ok(());\n             }\n             (Some(MutMutable), Borrow::Uniq(_)) |\n             (Some(MutImmutable), Borrow::Shr(_)) => {\n@@ -515,7 +523,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         }\n \n         // Get the allocation\n-        self.memory().check_bounds(ptr, size, false)?;\n+        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n         // If we got here, we do some checking, *but* we leave the tag unchanged.\n         if let Borrow::Shr(Some(_)) = ptr.tag {\n@@ -531,27 +539,51 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             alloc.extra.deref(ptr, size, kind)?;\n         }\n \n-        // All is good, and do not change the tag\n-        Ok(ptr.tag)\n+        // All is good\n+        Ok(())\n     }\n \n     /// The given place may henceforth be accessed through raw pointers.\n+    #[inline(always)]\n     fn escape_to_raw(\n         &mut self,\n         place: MPlaceTy<'tcx, Borrow>,\n         size: Size,\n     ) -> EvalResult<'tcx> {\n-        trace!(\"escape_to_raw: {:?} is now accessible by raw pointers\", *place);\n-        // Get the allocation\n+        self.reborrow(place, size, Borrow::default())?;\n+        Ok(())\n+    }\n+\n+    fn reborrow(\n+        &mut self,\n+        place: MPlaceTy<'tcx, Borrow>,\n+        size: Size,\n+        new_bor: Borrow\n+    ) -> EvalResult<'tcx, Pointer<Borrow>> {\n         let ptr = place.ptr.to_ptr()?;\n-        self.memory().check_bounds(ptr, size, false)?; // `ptr_dereference` wouldn't do any checks if this is a raw ptr\n+        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n+        trace!(\"reborrow: Creating new reference for {:?} (pointee {}): {:?}\",\n+            ptr, place.layout.ty, new_bor);\n+\n+        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n+        self.memory().check_bounds(ptr, size, InboundsCheck::Live)?;\n         let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        // Re-borrow to raw.  This is a NOP for shared borrows, but we do not know the borrow\n-        // type here and that's also okay.  Freezing does not matter here.\n-        alloc.extra.reborrow(ptr, size, Borrow::default(), RefKind::Raw)\n+        // Update the stacks.\n+        if let Borrow::Shr(Some(_)) = new_bor {\n+            // Reference that cares about freezing. We need a frozen-sensitive reborrow.\n+            self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n+                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n+                alloc.extra.reborrow(cur_ptr, size, new_bor, kind)\n+            })?;\n+        } else {\n+            // Just treat this as one big chunk.\n+            let kind = if new_bor.is_unique() { RefKind::Unique } else { RefKind::Raw };\n+            alloc.extra.reborrow(ptr, size, new_bor, kind)?;\n+        }\n+        Ok(new_ptr)\n     }\n \n-    fn reborrow(\n+    fn retag_reference(\n         &mut self,\n         val: ImmTy<'tcx, Borrow>,\n         mutbl: Mutability,\n@@ -566,33 +598,17 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n             return Ok(*val);\n         }\n \n-        // Prepare to re-borrow this place.\n-        let ptr = place.ptr.to_ptr()?;\n+        // Compute new borrow.\n         let time = self.machine.stacked_borrows.increment_clock();\n         let new_bor = match mutbl {\n             MutMutable => Borrow::Uniq(time),\n             MutImmutable => Borrow::Shr(Some(time)),\n         };\n-        trace!(\"reborrow: Creating new {:?} reference for {:?} (pointee {}): {:?}\",\n-            mutbl, ptr, place.layout.ty, new_bor);\n \n-        // Get the allocation.  It might not be mutable, so we cannot use `get_mut`.\n-        self.memory().check_bounds(ptr, size, false)?;\n-        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        // Update the stacks.\n-        if mutbl == MutImmutable {\n-            // Shared reference. We need a frozen-sensitive reborrow.\n-            self.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n-                let kind = if frozen { RefKind::Frozen } else { RefKind::Raw };\n-                alloc.extra.reborrow(cur_ptr, size, new_bor, kind)\n-            })?;\n-        } else {\n-            // Mutable reference. Just treat this as one big chunk.\n-            alloc.extra.reborrow(ptr, size, new_bor, RefKind::Unique)?;\n-        }\n+        // Reborrow.\n+        let new_ptr = self.reborrow(place, size, new_bor)?;\n \n         // Return new ptr\n-        let new_ptr = Pointer::new_with_tag(ptr.alloc_id, ptr.offset, new_bor);\n         let new_place = MemPlace { ptr: Scalar::Ptr(new_ptr), ..*place };\n         Ok(new_place.to_ref())\n     }\n@@ -602,17 +618,62 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for MiriEvalContext<'a, 'mir, 'tcx> {\n         _fn_entry: bool,\n         place: PlaceTy<'tcx, Borrow>\n     ) -> EvalResult<'tcx> {\n-        // For now, we only retag if the toplevel type is a reference.\n-        // TODO: Recurse into structs and enums, sharing code with validation.\n         // TODO: Honor `fn_entry`.\n-        let mutbl = match place.layout.ty.sty {\n-            ty::Ref(_, _, mutbl) => mutbl, // go ahead\n-            _ => return Ok(()), // do nothing, for now\n-        };\n-        // Retag the pointer and write it back.\n-        let val = self.read_immediate(self.place_to_op(place)?)?;\n-        let val = self.reborrow(val, mutbl)?;\n-        self.write_immediate(val, place)?;\n+\n+        // We need a visitor to visit all references.  However, that requires\n+        // a `MemPlace`, so we have a fast path for reference types that\n+        // avoids allocating.\n+        // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n+        // making it useless.\n+        if let Some(mutbl) = match place.layout.ty.sty {\n+            ty::Ref(_, _, mutbl) => Some(mutbl),\n+            ty::Adt(..) if place.layout.ty.is_box() => Some(MutMutable),\n+            _ => None, // handled with the general case below\n+        } {\n+            // fast path\n+            let val = self.read_immediate(self.place_to_op(place)?)?;\n+            let val = self.retag_reference(val, mutbl)?;\n+            self.write_immediate(val, place)?;\n+            return Ok(());\n+        }\n+        let place = self.force_allocation(place)?;\n+\n+        let mut visitor = RetagVisitor { ecx: self };\n+        visitor.visit_value(place)?;\n+\n+        // The actual visitor\n+        struct RetagVisitor<'ecx, 'a, 'mir, 'tcx> {\n+            ecx: &'ecx mut MiriEvalContext<'a, 'mir, 'tcx>,\n+        }\n+        impl<'ecx, 'a, 'mir, 'tcx>\n+            MutValueVisitor<'a, 'mir, 'tcx, Evaluator<'tcx>>\n+        for\n+            RetagVisitor<'ecx, 'a, 'mir, 'tcx>\n+        {\n+            type V = MPlaceTy<'tcx, Borrow>;\n+\n+            #[inline(always)]\n+            fn ecx(&mut self) -> &mut MiriEvalContext<'a, 'mir, 'tcx> {\n+                &mut self.ecx\n+            }\n+\n+            // Primitives of reference type, that is the one thing we are interested in.\n+            fn visit_primitive(&mut self, place: MPlaceTy<'tcx, Borrow>) -> EvalResult<'tcx>\n+            {\n+                // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n+                // making it useless.\n+                let mutbl = match place.layout.ty.sty {\n+                    ty::Ref(_, _, mutbl) => mutbl,\n+                    ty::Adt(..) if place.layout.ty.is_box() => MutMutable,\n+                    _ => return Ok(()), // nothing to do\n+                };\n+                let val = self.ecx.read_immediate(place.into())?;\n+                let val = self.ecx.retag_reference(val, mutbl)?;\n+                self.ecx.write_immediate(val, place.into())?;\n+                Ok(())\n+            }\n+        }\n+\n         Ok(())\n     }\n }"}, {"sha": "ce1c89a2a008181bb63c96a5cfaf46efe9291fca", "filename": "tests/compile-fail-fullmir/out_of_bounds_ptr_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fout_of_bounds_ptr_1.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: pointer computed at offset 5, outside bounds of allocation\n+// error-pattern: must be in-bounds and live at offset 5, but is outside bounds of allocation\n fn main() {\n     let v = [0i8; 4];\n     let x = &v as *const i8;"}, {"sha": "73631173b932a5e5cd747757d0bc18a82c32b551", "filename": "tests/compile-fail-fullmir/stacked_borrows/box_exclusive_violation1.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbox_exclusive_violation1.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,29 @@\n+fn demo_mut_advanced_unique(mut our: Box<i32>) -> i32 {\n+  unknown_code_1(&*our);\n+\n+  // This \"re-asserts\" uniqueness of the reference: After writing, we know\n+  // our tag is at the top of the stack.\n+  *our = 5;\n+\n+  unknown_code_2();\n+\n+  // We know this will return 5\n+  *our //~ ERROR does not exist on the stack\n+}\n+\n+// Now comes the evil context\n+use std::ptr;\n+\n+static mut LEAK: *mut i32 = ptr::null_mut();\n+\n+fn unknown_code_1(x: &i32) { unsafe {\n+    LEAK = x as *const _ as *mut _;\n+} }\n+\n+fn unknown_code_2() { unsafe {\n+    *LEAK = 7;\n+} }\n+\n+fn main() {\n+    assert_eq!(demo_mut_advanced_unique(Box::new(0)), 5);\n+}"}, {"sha": "e08e3bba6840de4de73cd2787d42fd9ed7567206", "filename": "tests/compile-fail-fullmir/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -1,5 +1,3 @@\n-// error-pattern: mutable reference with frozen tag\n-\n mod safe {\n     use std::slice::from_raw_parts_mut;\n \n@@ -12,10 +10,8 @@ mod safe {\n \n fn main() {\n     let v = vec![0,1,2];\n-    let _v1 = safe::as_mut_slice(&v);\n-/*\n-    let v2 = safe::as_mut_slice(&v);\n+    let v1 = safe::as_mut_slice(&v);\n+    let _v2 = safe::as_mut_slice(&v);\n     v1[1] = 5;\n-    v1[1] = 6;\n-*/\n+    //~^ ERROR does not exist on the stack\n }"}, {"sha": "a6daa5d93d772ddb6dafedfc14539c7480db1ddd", "filename": "tests/compile-fail-fullmir/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -11,6 +11,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+            //~^ ERROR does not exist on the stack\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -19,7 +20,6 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n-    //~^ ERROR does not exist on the stack\n     a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "28a1f74c6ac20e5edd698a2ac70508962806f5a5", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_mut_option.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_option.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&mut` that got already invalidated, not even in an `Option`.\n+fn foo(x: &mut (i32, i32)) -> Option<&mut i32> {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = Some(unsafe { &mut (*xraw).1 });\n+    let _val = unsafe { *xraw }; // invalidate xref\n+    ret //~ ERROR does not exist on the stack\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "3357af68a8411c1591eeaeddb6016ed072e28ef6", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_mut_tuple.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_mut_tuple.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&mut` that got already invalidated, not even in a tuple.\n+fn foo(x: &mut (i32, i32)) -> (&mut i32,) {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = (unsafe { &mut (*xraw).1 },);\n+    let _val = unsafe { *xraw }; // invalidate xref\n+    ret //~ ERROR does not exist on the stack\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "9d220991c330210cdeb66174c1217e782f7002d9", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_shr_option.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_option.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_option.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&` that got already invalidated, not even in an `Option`.\n+fn foo(x: &mut (i32, i32)) -> Option<&i32> {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = Some(unsafe { &(*xraw).1 });\n+    unsafe { *xraw = (42, 23) }; // unfreeze\n+    ret //~ ERROR is not frozen\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "060fa25c2307e9f6e468a99fd20714f83a943ec2", "filename": "tests/compile-fail-fullmir/stacked_borrows/return_invalid_shr_tuple.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Freturn_invalid_shr_tuple.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&` that got already invalidated, not even in a tuple.\n+fn foo(x: &mut (i32, i32)) -> (&i32,) {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = (unsafe { &(*xraw).1 },);\n+    unsafe { *xraw = (42, 23) }; // unfreeze\n+    ret //~ ERROR is not frozen\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "75abce3111f884bbb5a9c05c12fd5952c19102df", "filename": "tests/compile-fail-fullmir/stacked_borrows/transmute-is-no-escape.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstacked_borrows%2Ftransmute-is-no-escape.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -8,5 +8,6 @@ use std::mem;\n fn main() {\n     let mut x: i32 = 42;\n     let raw: *mut i32 = unsafe { mem::transmute(&mut x) };\n+    let raw = raw as usize as *mut i32; // make sure we killed the tag\n     unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n }"}, {"sha": "3b829d0f1294fb878abba664f40e61d674be5a37", "filename": "tests/run-pass-fullmir/box-pair-to-vec.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.rs?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,30 @@\n+//ignore-msvc: Stdout not implemented on Windows\n+\n+#[repr(C)]\n+#[derive(Debug)]\n+struct PairFoo {\n+    fst: Foo,\n+    snd: Foo,\n+}\n+\n+#[derive(Debug)]\n+struct Foo(u64);\n+fn reinterstruct(box_pair: Box<PairFoo>) -> Vec<Foo> {\n+    let ref_pair = Box::leak(box_pair) as *mut PairFoo;\n+    let ptr_foo = unsafe { &mut (*ref_pair).fst as *mut Foo };\n+    unsafe {\n+        Vec::from_raw_parts(ptr_foo, 2, 2)\n+    }\n+}\n+\n+fn main() {\n+    let pair_foo = Box::new(PairFoo {\n+        fst: Foo(42),\n+        snd: Foo(1337),\n+    });\n+    println!(\"pair_foo = {:?}\", pair_foo);\n+    for (n, foo) in reinterstruct(pair_foo).into_iter().enumerate() {\n+        println!(\"foo #{} = {:?}\", n, foo);\n+    }\n+}\n+"}, {"sha": "230ef368da64494e27dc048cf97e96fa24b00da9", "filename": "tests/run-pass-fullmir/box-pair-to-vec.stdout", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/adfede5cec2c8a136830f7fc309dbb45ac7a098a/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fbox-pair-to-vec.stdout?ref=adfede5cec2c8a136830f7fc309dbb45ac7a098a", "patch": "@@ -0,0 +1,3 @@\n+pair_foo = PairFoo { fst: Foo(42), snd: Foo(1337) }\n+foo #0 = Foo(42)\n+foo #1 = Foo(1337)"}]}