{"sha": "179637304a5d913a7ea2dc13cffed6e53f342377", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3OTYzNzMwNGE1ZDkxM2E3ZWEyZGMxM2NmZmVkNmU1M2YzNDIzNzc=", "commit": {"author": {"name": "Gary Linscott", "email": "glinscott@gmail.com", "date": "2013-07-10T18:32:59Z"}, "committer": {"name": "Gary Linscott", "email": "glinscott@gmail.com", "date": "2013-07-11T18:23:14Z"}, "message": "char_range_at perf work\n\nMoves multibyte code to it's own function to make char_range_at\neasier to inline, and faster for single and multibyte chars.\n\nBenchmarked reading example.json 100 times, 1.18s before, 1.08s\nafter.", "tree": {"sha": "3276cc93ac27eafc2d9ae4db41df3c2ed6fd5355", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3276cc93ac27eafc2d9ae4db41df3c2ed6fd5355"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/179637304a5d913a7ea2dc13cffed6e53f342377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/179637304a5d913a7ea2dc13cffed6e53f342377", "html_url": "https://github.com/rust-lang/rust/commit/179637304a5d913a7ea2dc13cffed6e53f342377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/179637304a5d913a7ea2dc13cffed6e53f342377/comments", "author": {"login": "glinscott", "id": 554932, "node_id": "MDQ6VXNlcjU1NDkzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/554932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glinscott", "html_url": "https://github.com/glinscott", "followers_url": "https://api.github.com/users/glinscott/followers", "following_url": "https://api.github.com/users/glinscott/following{/other_user}", "gists_url": "https://api.github.com/users/glinscott/gists{/gist_id}", "starred_url": "https://api.github.com/users/glinscott/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glinscott/subscriptions", "organizations_url": "https://api.github.com/users/glinscott/orgs", "repos_url": "https://api.github.com/users/glinscott/repos", "events_url": "https://api.github.com/users/glinscott/events{/privacy}", "received_events_url": "https://api.github.com/users/glinscott/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glinscott", "id": 554932, "node_id": "MDQ6VXNlcjU1NDkzMg==", "avatar_url": "https://avatars.githubusercontent.com/u/554932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glinscott", "html_url": "https://github.com/glinscott", "followers_url": "https://api.github.com/users/glinscott/followers", "following_url": "https://api.github.com/users/glinscott/following{/other_user}", "gists_url": "https://api.github.com/users/glinscott/gists{/gist_id}", "starred_url": "https://api.github.com/users/glinscott/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glinscott/subscriptions", "organizations_url": "https://api.github.com/users/glinscott/orgs", "repos_url": "https://api.github.com/users/glinscott/repos", "events_url": "https://api.github.com/users/glinscott/events{/privacy}", "received_events_url": "https://api.github.com/users/glinscott/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b", "html_url": "https://github.com/rust-lang/rust/commit/e95fcfafc7a2349217096bc1ed8b8c273b6a0e2b"}], "stats": {"total": 88, "additions": 60, "deletions": 28}, "files": [{"sha": "bc59164637ece49a3dffcd0fe6cdb4c9239e3942", "filename": "src/libstd/str.rs", "status": "modified", "additions": 60, "deletions": 28, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/179637304a5d913a7ea2dc13cffed6e53f342377/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/179637304a5d913a7ea2dc13cffed6e53f342377/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=179637304a5d913a7ea2dc13cffed6e53f342377", "patch": "@@ -722,17 +722,29 @@ pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n     end - start\n }\n \n+// https://tools.ietf.org/html/rfc3629\n+static UTF8_CHAR_WIDTH: [u8, ..256] = [\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x1F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x3F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x5F\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n+1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 0x7F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0x9F\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 0xBF\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,\n+2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // 0xDF\n+3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3, // 0xEF\n+4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0, // 0xFF\n+];\n+\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pub fn utf8_char_width(b: u8) -> uint {\n-    let byte: uint = b as uint;\n-    if byte < 128u { return 1u; }\n-    // Not a valid start byte\n-    if byte < 192u { return 0u; }\n-    if byte < 224u { return 2u; }\n-    if byte < 240u { return 3u; }\n-    if byte < 248u { return 4u; }\n-    if byte < 252u { return 5u; }\n-    return 6u;\n+    return UTF8_CHAR_WIDTH[b] as uint;\n }\n \n #[allow(missing_doc)]\n@@ -1714,26 +1726,29 @@ impl<'self> StrSlice<'self> for &'self str {\n      * If `i` is greater than or equal to the length of the string.\n      * If `i` is not the index of the beginning of a valid UTF-8 character.\n      */\n+    #[inline]\n     fn char_range_at(&self, i: uint) -> CharRange {\n-        let b0 = self[i];\n-        let w = utf8_char_width(b0);\n-        assert!((w != 0u));\n-        if w == 1u { return CharRange {ch: b0 as char, next: i + 1u}; }\n-        let mut val = 0u;\n-        let end = i + w;\n-        let mut i = i + 1u;\n-        while i < end {\n-            let byte = self[i];\n-            assert_eq!(byte & 192u8, TAG_CONT_U8);\n-            val <<= 6u;\n-            val += (byte & 63u8) as uint;\n-            i += 1u;\n+        if (self[i] < 128u8) {\n+            return CharRange {ch: self[i] as char, next: i + 1 };\n         }\n-        // Clunky way to get the right bits from the first byte. Uses two shifts,\n-        // the first to clip off the marker bits at the left of the byte, and then\n-        // a second (as uint) to get it to the right position.\n-        val += ((b0 << ((w + 1u) as u8)) as uint) << ((w - 1u) * 6u - w - 1u);\n-        return CharRange {ch: val as char, next: i};\n+\n+        // Multibyte case is a fn to allow char_range_at to inline cleanly\n+        fn multibyte_char_range_at(s: &str, i: uint) -> CharRange {\n+            let mut val = s[i] as uint;\n+            let w = UTF8_CHAR_WIDTH[val] as uint;\n+            assert!((w != 0));\n+\n+            // First byte is special, only want bottom 5 bits for width 2, 4 bits\n+            // for width 3, and 3 bits for width 4\n+            val &= 0x7Fu >> w;\n+            val = (val << 6) | (s[i + 1] & 63u8) as uint;\n+            if w > 2 { val = (val << 6) | (s[i + 2] & 63u8) as uint; }\n+            if w > 3 { val = (val << 6) | (s[i + 3] & 63u8) as uint; }\n+\n+            return CharRange {ch: val as char, next: i + w};\n+        }\n+\n+        return multibyte_char_range_at(*self, i);\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string\n@@ -2430,7 +2445,11 @@ mod tests {\n     fn test_push_char() {\n         let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n         data.push_char('\u534e');\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\", data);\n+        data.push_char('b'); // 1 byte\n+        data.push_char('\u00a2'); // 2 byte\n+        data.push_char('\u20ac'); // 3 byte\n+        data.push_char('\ud852\udf62'); // 4 byte\n+        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\", data);\n     }\n \n     #[test]\n@@ -3240,6 +3259,19 @@ mod tests {\n         \"22\".cmp(& &\"1234\") == Greater;\n     }\n \n+    #[test]\n+    fn test_char_range_at() {\n+        let data = ~\"b\u00a2\u20ac\ud852\udf62\ud852\udf62\u20ac\u00a2b\";\n+        assert_eq!('b', data.char_range_at(0).ch);\n+        assert_eq!('\u00a2', data.char_range_at(1).ch);\n+        assert_eq!('\u20ac', data.char_range_at(3).ch);\n+        assert_eq!('\ud852\udf62', data.char_range_at(6).ch);\n+        assert_eq!('\ud852\udf62', data.char_range_at(10).ch);\n+        assert_eq!('\u20ac', data.char_range_at(14).ch);\n+        assert_eq!('\u00a2', data.char_range_at(17).ch);\n+        assert_eq!('b', data.char_range_at(19).ch);\n+    }\n+\n     #[test]\n     fn test_char_range_at_reverse_underflow() {\n         assert_eq!(\"abc\".char_range_at_reverse(0).next, 0);"}]}