{"sha": "3882231f3231db03144107f72c6052f773fe2375", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ODIyMzFmMzIzMWRiMDMxNDQxMDdmNzJjNjA1MmY3NzNmZTIzNzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-09-26T12:30:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-26T12:30:44Z"}, "message": "Merge #1918\n\n1918: keep ast creation API simple r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6f318218b3a97c9a2dba3e8311de4fddbce23b27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f318218b3a97c9a2dba3e8311de4fddbce23b27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3882231f3231db03144107f72c6052f773fe2375", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdjK90CRBK7hj4Ov3rIwAAdHIIAAvZZXniPeIqbMes8VdisPgO\nz641w5w8qVoGCnhMbiIKqvoUBpVytkoiflirZt6XEQrHwvHjBSDOGadwV5B+z5dw\n5qQhtVmYsZmVYkaXzfXP8ukyO96vFdLcphz/KHHnPJAEZ+N0QrDJyxgmWa4pYiCA\n/gvo5VTBC0wHTTwWz+cJ74vvOmAo2a/seMnCXnhc2TfeILVMM9Yn12317Dcvwj6W\nbupm/tmiT7d/Z8/66dSoiSWvgbu4nukuBDqDmoZwYYnQsIITfJB12QysCAY7afZF\nqqf7g4X9ZL6Vpow0BmzG2g9iVyWreRaTjD+dAWvwr4w0PkbCuKKQVZKcWAZrubQ=\n=ABkK\n-----END PGP SIGNATURE-----\n", "payload": "tree 6f318218b3a97c9a2dba3e8311de4fddbce23b27\nparent d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f\nparent 183a38fb50f284de1ca02c05ed945e240f3c0274\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1569501044 +0000\ncommitter GitHub <noreply@github.com> 1569501044 +0000\n\nMerge #1918\n\n1918: keep ast creation API simple r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3882231f3231db03144107f72c6052f773fe2375", "html_url": "https://github.com/rust-lang/rust/commit/3882231f3231db03144107f72c6052f773fe2375", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3882231f3231db03144107f72c6052f773fe2375/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f", "html_url": "https://github.com/rust-lang/rust/commit/d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f"}, {"sha": "183a38fb50f284de1ca02c05ed945e240f3c0274", "url": "https://api.github.com/repos/rust-lang/rust/commits/183a38fb50f284de1ca02c05ed945e240f3c0274", "html_url": "https://github.com/rust-lang/rust/commit/183a38fb50f284de1ca02c05ed945e240f3c0274"}], "stats": {"total": 463, "additions": 213, "deletions": 250}, "files": [{"sha": "23da1e65fc9d4e35f07c99f57a2b429eaf031cbe", "filename": "crates/ra_assists/src/assists/add_missing_impl_members.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_missing_impl_members.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -1,10 +1,10 @@\n use hir::{db::HirDatabase, HasSource};\n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner},\n+    ast::{self, make, AstNode, NameOwner},\n     SmolStr,\n };\n \n-use crate::{ast_builder::Make, ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n+use crate::{ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n \n #[derive(PartialEq)]\n enum AddMissingImplMembersMode {\n@@ -102,7 +102,8 @@ fn strip_docstring(item: ast::ImplItem) -> ast::ImplItem {\n fn add_body(fn_def: ast::FnDef) -> ast::FnDef {\n     let mut ast_editor = AstEditor::new(fn_def.clone());\n     if fn_def.body().is_none() {\n-        ast_editor.set_body(&Make::<ast::Block>::single_expr(Make::<ast::Expr>::unimplemented()));\n+        let body = make::block_from_expr(make::expr_unimplemented());\n+        ast_editor.set_body(&body);\n     }\n     ast_editor.ast().to_owned()\n }"}, {"sha": "db82db89ab801ac2d528ca69ecd0ef6b6f8ee60d", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -1,9 +1,9 @@\n use std::iter;\n \n use hir::{db::HirDatabase, Adt, HasSource};\n-use ra_syntax::ast::{self, AstNode, NameOwner};\n+use ra_syntax::ast::{self, make, AstNode, NameOwner};\n \n-use crate::{ast_builder::Make, Assist, AssistCtx, AssistId};\n+use crate::{Assist, AssistCtx, AssistId};\n \n pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let match_expr = ctx.node_at_offset::<ast::MatchExpr>()?;\n@@ -31,8 +31,8 @@ pub(crate) fn fill_match_arms(mut ctx: AssistCtx<impl HirDatabase>) -> Option<As\n         let variants = variant_list.variants();\n         let arms = variants\n             .filter_map(build_pat)\n-            .map(|pat| Make::<ast::MatchArm>::from(iter::once(pat), Make::<ast::Expr>::unit()));\n-        let new_arm_list = Make::<ast::MatchArmList>::from_arms(arms);\n+            .map(|pat| make::match_arm(iter::once(pat), make::expr_unit()));\n+        let new_arm_list = make::match_arm_list(arms);\n \n         edit.target(match_expr.syntax().text_range());\n         edit.set_cursor(expr.syntax().text_range().start());\n@@ -63,21 +63,22 @@ fn resolve_enum_def(\n }\n \n fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {\n-    let path = Make::<ast::Path>::from(var.parent_enum().name()?, var.name()?);\n+    let path = make::path_qualified(\n+        make::path_from_name_ref(make::name_ref(&var.parent_enum().name()?.syntax().to_string())),\n+        make::name_ref(&var.name()?.syntax().to_string()),\n+    );\n \n     let pat: ast::Pat = match var.kind() {\n         ast::StructKind::Tuple(field_list) => {\n-            let pats = iter::repeat(Make::<ast::PlaceholderPat>::placeholder().into())\n-                .take(field_list.fields().count());\n-            Make::<ast::TupleStructPat>::from(path, pats).into()\n+            let pats =\n+                iter::repeat(make::placeholder_pat().into()).take(field_list.fields().count());\n+            make::tuple_struct_pat(path, pats).into()\n         }\n         ast::StructKind::Named(field_list) => {\n-            let pats = field_list\n-                .fields()\n-                .map(|f| Make::<ast::BindPat>::from_name(f.name().unwrap()).into());\n-            Make::<ast::RecordPat>::from(path, pats).into()\n+            let pats = field_list.fields().map(|f| make::bind_pat(f.name().unwrap()).into());\n+            make::record_pat(path, pats).into()\n         }\n-        ast::StructKind::Unit => Make::<ast::PathPat>::from_path(path).into(),\n+        ast::StructKind::Unit => make::path_pat(path).into(),\n     };\n \n     Some(pat)"}, {"sha": "fd4bdc55cda0763b7f01955f99680b24a7ea8e28", "filename": "crates/ra_assists/src/assists/move_bounds.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fmove_bounds.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -1,11 +1,11 @@\n use hir::db::HirDatabase;\n use ra_syntax::{\n-    ast::{self, AstNode, NameOwner, TypeBoundsOwner},\n+    ast::{self, make, AstNode, NameOwner, TypeBoundsOwner},\n     SyntaxElement,\n     SyntaxKind::*,\n };\n \n-use crate::{ast_builder::Make, ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n+use crate::{ast_editor::AstEditor, Assist, AssistCtx, AssistId};\n \n pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let type_param_list = ctx.node_at_offset::<ast::TypeParamList>()?;\n@@ -50,7 +50,7 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n \n             let where_clause = {\n                 let predicates = type_param_list.type_params().filter_map(build_predicate);\n-                Make::<ast::WhereClause>::from_predicates(predicates)\n+                make::where_clause(predicates)\n             };\n \n             let to_insert = match anchor.prev_sibling_or_token() {\n@@ -68,8 +68,8 @@ pub(crate) fn move_bounds_to_where_clause(mut ctx: AssistCtx<impl HirDatabase>)\n }\n \n fn build_predicate(param: ast::TypeParam) -> Option<ast::WherePred> {\n-    let path = Make::<ast::Path>::from_name(param.name()?);\n-    let predicate = Make::<ast::WherePred>::from(path, param.type_bound_list()?.bounds());\n+    let path = make::path_from_name_ref(make::name_ref(&param.name()?.syntax().to_string()));\n+    let predicate = make::where_pred(path, param.type_bound_list()?.bounds());\n     Some(predicate)\n }\n "}, {"sha": "9a62b96b3cc4191f03e8387f3fa744990aab0da3", "filename": "crates/ra_assists/src/ast_builder.rs", "status": "removed", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f/crates%2Fra_assists%2Fsrc%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_builder.rs?ref=d6bbdfefa7ed4b2b567558e76d5adadda9d9b83f", "patch": "@@ -1,218 +0,0 @@\n-use itertools::Itertools;\n-\n-use ra_syntax::{ast, AstNode, SourceFile};\n-\n-pub struct Make<N: AstNode> {\n-    _phantom: std::marker::PhantomData<N>,\n-}\n-\n-impl Make<ast::RecordField> {\n-    pub fn from(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordField {\n-        match expr {\n-            Some(expr) => Self::from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n-            None => Self::from_text(&name.syntax().to_string()),\n-        }\n-    }\n-\n-    fn from_text(text: &str) -> ast::RecordField {\n-        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n-    }\n-}\n-\n-impl Make<ast::Block> {\n-    pub fn single_expr(e: ast::Expr) -> ast::Block {\n-        Self::from_text(&format!(\"{{ {} }}\", e.syntax()))\n-    }\n-\n-    fn from_text(text: &str) -> ast::Block {\n-        ast_node_from_file_text(&format!(\"fn f() {}\", text))\n-    }\n-}\n-\n-impl Make<ast::Expr> {\n-    pub fn unit() -> ast::Expr {\n-        Self::from_text(\"()\")\n-    }\n-\n-    pub fn unimplemented() -> ast::Expr {\n-        Self::from_text(\"unimplemented!()\")\n-    }\n-\n-    fn from_text(text: &str) -> ast::Expr {\n-        ast_node_from_file_text(&format!(\"const C: () = {};\", text))\n-    }\n-}\n-\n-impl Make<ast::NameRef> {\n-    pub fn from(text: &str) -> ast::NameRef {\n-        ast_node_from_file_text(&format!(\"fn f() {{ {}; }}\", text))\n-    }\n-}\n-\n-impl Make<ast::Path> {\n-    pub fn from_name(name: ast::Name) -> ast::Path {\n-        let name = name.syntax().to_string();\n-        Self::from_text(name.as_str())\n-    }\n-\n-    pub fn from(enum_name: ast::Name, var_name: ast::Name) -> ast::Path {\n-        Self::from_text(&format!(\"{}::{}\", enum_name.syntax(), var_name.syntax()))\n-    }\n-\n-    fn from_text(text: &str) -> ast::Path {\n-        ast_node_from_file_text(text)\n-    }\n-}\n-\n-impl Make<ast::BindPat> {\n-    pub fn from_name(name: ast::Name) -> ast::BindPat {\n-        Self::from_text(name.text())\n-    }\n-\n-    fn from_text(text: &str) -> ast::BindPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-}\n-\n-impl Make<ast::PlaceholderPat> {\n-    pub fn placeholder() -> ast::PlaceholderPat {\n-        Self::from_text(\"_\")\n-    }\n-\n-    fn from_text(text: &str) -> ast::PlaceholderPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-}\n-\n-impl Make<ast::TupleStructPat> {\n-    pub fn from(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::TupleStructPat {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(&format!(\"{}({})\", path.syntax(), pats_str))\n-    }\n-\n-    fn from_text(text: &str) -> ast::TupleStructPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-}\n-\n-impl Make<ast::RecordPat> {\n-    pub fn from(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str))\n-    }\n-\n-    fn from_text(text: &str) -> ast::RecordPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-}\n-\n-impl Make<ast::PathPat> {\n-    pub fn from_path(path: ast::Path) -> ast::PathPat {\n-        let path_str = path.syntax().text().to_string();\n-        Self::from_text(path_str.as_str())\n-    }\n-\n-    fn from_text(text: &str) -> ast::PathPat {\n-        ast_node_from_file_text(&format!(\"fn f({}: ())\", text))\n-    }\n-}\n-\n-impl Make<ast::MatchArm> {\n-    pub fn from(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n-        let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n-        Self::from_text(&format!(\"{} => {}\", pats_str, expr.syntax()))\n-    }\n-\n-    fn from_text(text: &str) -> ast::MatchArm {\n-        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n-    }\n-}\n-\n-impl Make<ast::MatchArmList> {\n-    pub fn from_arms(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n-        let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n-        Self::from_text(&format!(\"{},\\n\", arms_str))\n-    }\n-\n-    fn from_text(text: &str) -> ast::MatchArmList {\n-        ast_node_from_file_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n-    }\n-}\n-\n-impl Make<ast::WherePred> {\n-    pub fn from(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n-        let bounds = bounds.map(|b| b.syntax().to_string()).collect::<Vec<_>>().join(\" + \");\n-        Self::from_text(&format!(\"{}: {}\", path.syntax(), bounds))\n-    }\n-\n-    fn from_text(text: &str) -> ast::WherePred {\n-        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n-    }\n-}\n-\n-impl Make<ast::WhereClause> {\n-    pub fn from_predicates(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n-        let preds = preds.map(|p| p.syntax().to_string()).collect::<Vec<_>>().join(\", \");\n-        Self::from_text(preds.as_str())\n-    }\n-\n-    fn from_text(text: &str) -> ast::WhereClause {\n-        ast_node_from_file_text(&format!(\"fn f() where {} {{ }}\", text))\n-    }\n-}\n-\n-fn ast_node_from_file_text<N: AstNode>(text: &str) -> N {\n-    let parse = SourceFile::parse(text);\n-    let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();\n-    res\n-}\n-\n-pub(crate) mod tokens {\n-    use once_cell::sync::Lazy;\n-    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n-\n-    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n-\n-    pub(crate) fn comma() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == T![,])\n-            .unwrap()\n-    }\n-\n-    pub(crate) fn single_space() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n-            .unwrap()\n-    }\n-\n-    #[allow(unused)]\n-    pub(crate) fn single_newline() -> SyntaxToken {\n-        SOURCE_FILE\n-            .tree()\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter_map(|it| it.into_token())\n-            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n-            .unwrap()\n-    }\n-\n-    pub(crate) struct WsBuilder(SourceFile);\n-\n-    impl WsBuilder {\n-        pub(crate) fn new(text: &str) -> WsBuilder {\n-            WsBuilder(SourceFile::parse(text).ok().unwrap())\n-        }\n-        pub(crate) fn ws(&self) -> SyntaxToken {\n-            self.0.syntax().first_child_or_token().unwrap().into_token().unwrap()\n-        }\n-    }\n-\n-}"}, {"sha": "2936c094b9847c16d5ffaeb24ff32857d13392f6", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 50, "deletions": 2, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -13,8 +13,6 @@ use ra_syntax::{\n };\n use ra_text_edit::TextEditBuilder;\n \n-use crate::ast_builder::tokens;\n-\n pub struct AstEditor<N: AstNode> {\n     original_ast: N,\n     ast: N,\n@@ -286,3 +284,53 @@ impl AstEditor<ast::TypeParam> {\n         self\n     }\n }\n+\n+mod tokens {\n+    use once_cell::sync::Lazy;\n+    use ra_syntax::{AstNode, Parse, SourceFile, SyntaxKind::*, SyntaxToken, T};\n+\n+    static SOURCE_FILE: Lazy<Parse<SourceFile>> = Lazy::new(|| SourceFile::parse(\",\\n; ;\"));\n+\n+    pub(crate) fn comma() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == T![,])\n+            .unwrap()\n+    }\n+\n+    pub(crate) fn single_space() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \" \")\n+            .unwrap()\n+    }\n+\n+    #[allow(unused)]\n+    pub(crate) fn single_newline() -> SyntaxToken {\n+        SOURCE_FILE\n+            .tree()\n+            .syntax()\n+            .descendants_with_tokens()\n+            .filter_map(|it| it.into_token())\n+            .find(|it| it.kind() == WHITESPACE && it.text().as_str() == \"\\n\")\n+            .unwrap()\n+    }\n+\n+    pub(crate) struct WsBuilder(SourceFile);\n+\n+    impl WsBuilder {\n+        pub(crate) fn new(text: &str) -> WsBuilder {\n+            WsBuilder(SourceFile::parse(text).ok().unwrap())\n+        }\n+        pub(crate) fn ws(&self) -> SyntaxToken {\n+            self.0.syntax().first_child_or_token().unwrap().into_token().unwrap()\n+        }\n+    }\n+\n+}"}, {"sha": "897af2b020b83093b54fd62fe353747aec782116", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -8,11 +8,9 @@\n mod assist_ctx;\n mod marks;\n pub mod ast_editor;\n-pub mod ast_builder;\n-\n-use itertools::Itertools;\n \n use hir::db::HirDatabase;\n+use itertools::Itertools;\n use ra_db::FileRange;\n use ra_syntax::{TextRange, TextUnit};\n use ra_text_edit::TextEdit;"}, {"sha": "144bc0a701f0f14aca6d889c00c525708302581a", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -2,11 +2,11 @@ use std::cell::RefCell;\n \n use hir::diagnostics::{AstDiagnostic, Diagnostic as _, DiagnosticSink};\n use itertools::Itertools;\n-use ra_assists::{ast_builder::Make, ast_editor::AstEditor};\n+use ra_assists::ast_editor::AstEditor;\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, make, AstNode},\n     Location, SyntaxNode, TextRange, T,\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n@@ -59,10 +59,7 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n         let node = d.ast(db);\n         let mut ast_editor = AstEditor::new(node);\n         for f in d.missed_fields.iter() {\n-            let field = Make::<ast::RecordField>::from(\n-                Make::<ast::NameRef>::from(&f.to_string()),\n-                Some(Make::<ast::Expr>::unit()),\n-            );\n+            let field = make::record_field(make::name_ref(&f.to_string()), Some(make::expr_unit()));\n             ast_editor.append_field(&field);\n         }\n "}, {"sha": "f464d65342999b9c9202b86cc3a4387cfe76cdb2", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -5,6 +5,7 @@ mod traits;\n mod tokens;\n mod extensions;\n mod expr_extensions;\n+pub mod make;\n \n use std::marker::PhantomData;\n "}, {"sha": "c06c62b3bff8d64885e9cd12d09cdf4b6661dea5", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3882231f3231db03144107f72c6052f773fe2375/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=3882231f3231db03144107f72c6052f773fe2375", "patch": "@@ -0,0 +1,135 @@\n+//! This module contains free-standing functions for creating AST fragments out\n+//! of smaller pieces.\n+use itertools::Itertools;\n+\n+use crate::{ast, AstNode, SourceFile};\n+\n+pub fn name_ref(text: &str) -> ast::NameRef {\n+    ast_from_text(&format!(\"fn f() {{ {}; }}\", text))\n+}\n+\n+pub fn path_from_name_ref(name_ref: ast::NameRef) -> ast::Path {\n+    path_from_text(&name_ref.syntax().to_string())\n+}\n+pub fn path_qualified(qual: ast::Path, name_ref: ast::NameRef) -> ast::Path {\n+    path_from_text(&format!(\"{}::{}\", qual.syntax(), name_ref.syntax()))\n+}\n+fn path_from_text(text: &str) -> ast::Path {\n+    ast_from_text(text)\n+}\n+\n+pub fn record_field(name: ast::NameRef, expr: Option<ast::Expr>) -> ast::RecordField {\n+    return match expr {\n+        Some(expr) => from_text(&format!(\"{}: {}\", name.syntax(), expr.syntax())),\n+        None => from_text(&name.syntax().to_string()),\n+    };\n+\n+    fn from_text(text: &str) -> ast::RecordField {\n+        ast_from_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n+    }\n+}\n+\n+pub fn block_from_expr(e: ast::Expr) -> ast::Block {\n+    return from_text(&format!(\"{{ {} }}\", e.syntax()));\n+\n+    fn from_text(text: &str) -> ast::Block {\n+        ast_from_text(&format!(\"fn f() {}\", text))\n+    }\n+}\n+\n+pub fn expr_unit() -> ast::Expr {\n+    expr_from_text(\"()\")\n+}\n+pub fn expr_unimplemented() -> ast::Expr {\n+    expr_from_text(\"unimplemented!()\")\n+}\n+fn expr_from_text(text: &str) -> ast::Expr {\n+    ast_from_text(&format!(\"const C: () = {};\", text))\n+}\n+\n+pub fn bind_pat(name: ast::Name) -> ast::BindPat {\n+    return from_text(name.text());\n+\n+    fn from_text(text: &str) -> ast::BindPat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n+pub fn placeholder_pat() -> ast::PlaceholderPat {\n+    return from_text(\"_\");\n+\n+    fn from_text(text: &str) -> ast::PlaceholderPat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n+pub fn tuple_struct_pat(\n+    path: ast::Path,\n+    pats: impl Iterator<Item = ast::Pat>,\n+) -> ast::TupleStructPat {\n+    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+    return from_text(&format!(\"{}({})\", path.syntax(), pats_str));\n+\n+    fn from_text(text: &str) -> ast::TupleStructPat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n+pub fn record_pat(path: ast::Path, pats: impl Iterator<Item = ast::Pat>) -> ast::RecordPat {\n+    let pats_str = pats.map(|p| p.syntax().to_string()).join(\", \");\n+    return from_text(&format!(\"{}{{ {} }}\", path.syntax(), pats_str));\n+\n+    fn from_text(text: &str) -> ast::RecordPat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n+pub fn path_pat(path: ast::Path) -> ast::PathPat {\n+    let path_str = path.syntax().text().to_string();\n+    return from_text(path_str.as_str());\n+    fn from_text(text: &str) -> ast::PathPat {\n+        ast_from_text(&format!(\"fn f({}: ())\", text))\n+    }\n+}\n+\n+pub fn match_arm(pats: impl Iterator<Item = ast::Pat>, expr: ast::Expr) -> ast::MatchArm {\n+    let pats_str = pats.map(|p| p.syntax().to_string()).join(\" | \");\n+    return from_text(&format!(\"{} => {}\", pats_str, expr.syntax()));\n+\n+    fn from_text(text: &str) -> ast::MatchArm {\n+        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+}\n+\n+pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchArmList {\n+    let arms_str = arms.map(|arm| format!(\"\\n    {}\", arm.syntax())).join(\",\");\n+    return from_text(&format!(\"{},\\n\", arms_str));\n+\n+    fn from_text(text: &str) -> ast::MatchArmList {\n+        ast_from_text(&format!(\"fn f() {{ match () {{{}}} }}\", text))\n+    }\n+}\n+\n+pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n+    let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n+    return from_text(&format!(\"{}: {}\", path.syntax(), bounds));\n+\n+    fn from_text(text: &str) -> ast::WherePred {\n+        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+    }\n+}\n+\n+pub fn where_clause(preds: impl Iterator<Item = ast::WherePred>) -> ast::WhereClause {\n+    let preds = preds.map(|p| p.syntax().to_string()).join(\", \");\n+    return from_text(preds.as_str());\n+\n+    fn from_text(text: &str) -> ast::WhereClause {\n+        ast_from_text(&format!(\"fn f() where {} {{ }}\", text))\n+    }\n+}\n+\n+fn ast_from_text<N: AstNode>(text: &str) -> N {\n+    let parse = SourceFile::parse(text);\n+    let res = parse.tree().syntax().descendants().find_map(N::cast).unwrap();\n+    res\n+}"}]}