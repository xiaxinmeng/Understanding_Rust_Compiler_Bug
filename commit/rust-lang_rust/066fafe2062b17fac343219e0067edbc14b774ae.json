{"sha": "066fafe2062b17fac343219e0067edbc14b774ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2NmZhZmUyMDYyYjE3ZmFjMzQzMjE5ZTAwNjdlZGJjMTRiNzc0YWU=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-05-23T12:47:09Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-06-15T21:48:12Z"}, "message": "Add API for `Alloc` trait.\n\nIncludes `alloc_zeroed` method that `RawVec` has come to depend on.\n\nExposed private `Layout::from_size_align` ctor to be `pub`, and added\nexplicit conditions for when it will panic (namely, when `align` is\nnot power-of-two, or if rounding up `size` to a multiple of `align`\noverflows). Normalized all `Layout` construction to go through\n`Layout::from_size_align`.\n\nAddressed review feedback regarding `struct Layout` and zero-sized\nlayouts.\n\nRestrict specification for `dealloc`, adding additional constraint\nthat the given alignment has to match that used to allocate the block.\n(This is a maximally conservative constraint on the alignment. An open\nquestion to resolve (before stabilization) is whether we can return to\na looser constraint such as the one previously specified.)\n\nSplit `fn realloc_in_place` into separate `fn grow_in_place` and `fn\nshrink_in_place` methods, which have default impls that check against\nusable_size for reuse. Make `realloc` default impl try `grow_in_place`\nor `shrink_in_place` as appropriate before fallback on\nalloc+copy+dealloc.\n\nDrive-by: When reviewing calls to `padding_needed_for`, discovered\nwhat I think was an over-conservative choice for its argument\nalignment.  Namely, in `fn extend`, we automatically realign the whole\nresulting layout to satisfy both old (self) and new alignments. When\nthe old alignment exceeds the new, this means we would insert\nunnecessary padding. So I changed the code to pass in `next.align`\ninstead of `new_align` to `padding_needed_for`.\n\nReplaced ref to `realloc_in_place` with `grow_in_place`/`shrink_in_place`.\n\nRevised docs replacing my idiosyncratic style of `fn foo` with just\n`foo` when referring to the function or method `foo`.\n\n(Alpha-renamed `Allocator` to `Alloc`.)\n\nPost-rebased, added `Debug` derive for `allocator::Excess` to satisfy\n`missing_debug_implementations`.", "tree": {"sha": "384cc9b918862ba5424dc5a4aa1ac5e1bd5a0437", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/384cc9b918862ba5424dc5a4aa1ac5e1bd5a0437"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/066fafe2062b17fac343219e0067edbc14b774ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/066fafe2062b17fac343219e0067edbc14b774ae", "html_url": "https://github.com/rust-lang/rust/commit/066fafe2062b17fac343219e0067edbc14b774ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/066fafe2062b17fac343219e0067edbc14b774ae/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "url": "https://api.github.com/repos/rust-lang/rust/commits/258ae6dd9b1a8ac97986852fc9f00f7687004ccb", "html_url": "https://github.com/rust-lang/rust/commit/258ae6dd9b1a8ac97986852fc9f00f7687004ccb"}], "stats": {"total": 990, "additions": 990, "deletions": 0}, "files": [{"sha": "89324cf86f6657aa055f80ca3fefb1d72cd92275", "filename": "src/liballoc/allocator.rs", "status": "added", "additions": 986, "deletions": 0, "changes": 986, "blob_url": "https://github.com/rust-lang/rust/blob/066fafe2062b17fac343219e0067edbc14b774ae/src%2Fliballoc%2Fallocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066fafe2062b17fac343219e0067edbc14b774ae/src%2Fliballoc%2Fallocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fallocator.rs?ref=066fafe2062b17fac343219e0067edbc14b774ae", "patch": "@@ -0,0 +1,986 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"allocator_api\",\n+            reason = \"the precise API and guarantees it provides may be tweaked \\\n+                      slightly, especially to possibly take into account the \\\n+                      types being stored to make room for a future \\\n+                      tracing garbage collector\",\n+            issue = \"27700\")]\n+\n+use core::cmp;\n+use core::mem;\n+use core::usize;\n+use core::ptr::{self, Unique};\n+\n+/// Represents the combination of a starting address and\n+/// a total capacity of the returned block.\n+#[derive(Debug)]\n+pub struct Excess(pub *mut u8, pub usize);\n+\n+fn size_align<T>() -> (usize, usize) {\n+    (mem::size_of::<T>(), mem::align_of::<T>())\n+}\n+\n+/// Layout of a block of memory.\n+///\n+/// An instance of `Layout` describes a particular layout of memory.\n+/// You build a `Layout` up as an input to give to an allocator.\n+///\n+/// All layouts have an associated non-negative size and a\n+/// power-of-two alignment.\n+///\n+/// (Note however that layouts are *not* required to have positive\n+/// size, even though many allocators require that all memory\n+/// requeusts have positive size. A caller to the `Alloc::alloc`\n+/// method must either ensure that conditions like this are met, or\n+/// use specific allocators with looser requirements.)\n+#[derive(Clone, Debug, PartialEq, Eq)]\n+pub struct Layout {\n+    // size of the requested block of memory, measured in bytes.\n+    size: usize,\n+\n+    // alignment of the requested block of memory, measured in bytes.\n+    // we ensure that this is always a power-of-two, because API's\n+    // like `posix_memalign` require it and it is a reasonable\n+    // constraint to impose on Layout constructors.\n+    //\n+    // (However, we do not analogously require `align >= sizeof(void*)`,\n+    //  even though that is *also* a requirement of `posix_memalign`.)\n+    align: usize,\n+}\n+\n+\n+// FIXME: audit default implementations for overflow errors,\n+// (potentially switching to overflowing_add and\n+//  overflowing_mul as necessary).\n+\n+impl Layout {\n+    /// Constructs a `Layout` from a given `size` and `align`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if any of the following conditions are not met:\n+    ///\n+    /// * `align` must be a power of two,\n+    ///\n+    /// * `size`, when rounded up to the nearest multiple of `align`,\n+    ///    must not overflow (i.e. the rounded value must be less than\n+    ///    `usize::MAX`).\n+    pub fn from_size_align(size: usize, align: usize) -> Layout {\n+        assert!(align.is_power_of_two()); // (this implies align != 0.)\n+\n+        // Rounded up size is:\n+        //   size_rounded_up = (size + align - 1) & !(align - 1);\n+        //\n+        // We know from above that align != 0. If adding (align - 1)\n+        // does not overflow, then rounding up will be fine.\n+        //\n+        // Conversely, &-masking with !(align - 1) will subtract off\n+        // only low-order-bits. Thus if overflow occurs with the sum,\n+        // the &-mask cannot subtract enough to undo that overflow.\n+        //\n+        // Above implies that checking for summation overflow is both\n+        // necessary and sufficient.\n+        assert!(size <= usize::MAX - (align - 1));\n+\n+        Layout { size: size, align: align }\n+    }\n+\n+    /// The minimum size in bytes for a memory block of this layout.\n+    pub fn size(&self) -> usize { self.size }\n+\n+    /// The minimum byte alignment for a memory block of this layout.\n+    pub fn align(&self) -> usize { self.align }\n+\n+    /// Constructs a `Layout` suitable for holding a value of type `T`.\n+    pub fn new<T>() -> Self {\n+        let (size, align) = size_align::<T>();\n+        Layout::from_size_align(size, align)\n+    }\n+\n+    /// Produces layout describing a record that could be used to\n+    /// allocate backing structure for `T` (which could be a trait\n+    /// or other unsized type like a slice).\n+    pub fn for_value<T: ?Sized>(t: &T) -> Self {\n+        let (size, align) = (mem::size_of_val(t), mem::align_of_val(t));\n+        Layout::from_size_align(size, align)\n+    }\n+\n+    /// Creates a layout describing the record that can hold a value\n+    /// of the same layout as `self`, but that also is aligned to\n+    /// alignment `align` (measured in bytes).\n+    ///\n+    /// If `self` already meets the prescribed alignment, then returns\n+    /// `self`.\n+    ///\n+    /// Note that this method does not add any padding to the overall\n+    /// size, regardless of whether the returned layout has a different\n+    /// alignment. In other words, if `K` has size 16, `K.align_to(32)`\n+    /// will *still* have size 16.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `align` is not a power of two.\n+    pub fn align_to(&self, align: usize) -> Self {\n+        assert!(align.is_power_of_two());\n+        Layout::from_size_align(self.size, cmp::max(self.align, align))\n+    }\n+\n+    /// Returns the amount of padding we must insert after `self`\n+    /// to ensure that the following address will satisfy `align`\n+    /// (measured in bytes).\n+    ///\n+    /// E.g. if `self.size` is 9, then `self.padding_needed_for(4)`\n+    /// returns 3, because that is the minimum number of bytes of\n+    /// padding required to get a 4-aligned address (assuming that the\n+    /// corresponding memory block starts at a 4-aligned address).\n+    ///\n+    /// The return value of this function has no meaning if `align` is\n+    /// not a power-of-two.\n+    ///\n+    /// Note that the utility of the returned value requires `align`\n+    /// to be less than or equal to the alignment of the starting\n+    /// address for the whole allocated block of memory. One way to\n+    /// satisfy this constraint is to ensure `align <= self.align`.\n+    pub fn padding_needed_for(&self, align: usize) -> usize {\n+        let len = self.size();\n+\n+        // Rounded up value is:\n+        //   len_rounded_up = (len + align - 1) & !(align - 1);\n+        // and then we return the padding difference: `len_rounded_up - len`.\n+        //\n+        // We use modular arithmetic throughout:\n+        //\n+        // 1. align is guaranteed to be > 0, so align - 1 is always\n+        //    valid.\n+        //\n+        // 2. `len + align - 1` can overflow by at most `align - 1`,\n+        //    so the &-mask wth `!(align - 1)` will ensure that in the\n+        //    case of overflow, `len_rounded_up` will itself be 0.\n+        //    Thus the returned padding, when added to `len`, yields 0,\n+        //    which trivially satisfies the alignment `align`.\n+        //\n+        // (Of course, attempts to allocate blocks of memory whose\n+        // size and padding overflow in the above manner should cause\n+        // the allocator to yield an error anyway.)\n+\n+        let len_rounded_up = len.wrapping_add(align).wrapping_sub(1) & !align.wrapping_sub(1);\n+        return len_rounded_up.wrapping_sub(len);\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with a suitable amount of padding between each to\n+    /// ensure that each instance is given its requested size and\n+    /// alignment. On success, returns `(k, offs)` where `k` is the\n+    /// layout of the array and `offs` is the distance between the start\n+    /// of each element in the array.\n+    ///\n+    /// On arithmetic overflow, returns `None`.\n+    pub fn repeat(&self, n: usize) -> Option<(Self, usize)> {\n+        let padded_size = match self.size.checked_add(self.padding_needed_for(self.align)) {\n+            None => return None,\n+            Some(padded_size) => padded_size,\n+        };\n+        let alloc_size = match padded_size.checked_mul(n) {\n+            None => return None,\n+            Some(alloc_size) => alloc_size,\n+        };\n+        Some((Layout::from_size_align(alloc_size, self.align), padded_size))\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next`, including any necessary padding to ensure that `next`\n+    /// will be properly aligned. Note that the result layout will\n+    /// satisfy the alignment properties of both `self` and `next`.\n+    ///\n+    /// Returns `Some((k, offset))`, where `k` is layout of the concatenated\n+    /// record and `offset` is the relative location, in bytes, of the\n+    /// start of the `next` embedded witnin the concatenated record\n+    /// (assuming that the record itself starts at offset 0).\n+    ///\n+    /// On arithmetic overflow, returns `None`.\n+    pub fn extend(&self, next: Self) -> Option<(Self, usize)> {\n+        let new_align = cmp::max(self.align, next.align);\n+        let realigned = Layout::from_size_align(self.size, new_align);\n+        let pad = realigned.padding_needed_for(next.align);\n+        let offset = match self.size.checked_add(pad) {\n+            None => return None,\n+            Some(offset) => offset,\n+        };\n+        let new_size = match offset.checked_add(next.size) {\n+            None => return None,\n+            Some(new_size) => new_size,\n+        };\n+        Some((Layout::from_size_align(new_size, new_align), offset))\n+    }\n+\n+    /// Creates a layout describing the record for `n` instances of\n+    /// `self`, with no padding between each instance.\n+    ///\n+    /// Note that, unlike `repeat`, `repeat_packed` does not guarantee\n+    /// that the repeated instances of `self` will be properly\n+    /// aligned, even if a given instance of `self` is properly\n+    /// aligned. In other words, if the layout returned by\n+    /// `repeat_packed` is used to allocate an array, it is not\n+    /// guaranteed that all elements in the array will be properly\n+    /// aligned.\n+    ///\n+    /// On arithmetic overflow, returns `None`.\n+    pub fn repeat_packed(&self, n: usize) -> Option<Self> {\n+        let size = match self.size().checked_mul(n) {\n+            None => return None,\n+            Some(scaled) => scaled,\n+        };\n+        Some(Layout::from_size_align(size, self.align))\n+    }\n+\n+    /// Creates a layout describing the record for `self` followed by\n+    /// `next` with no additional padding between the two. Since no\n+    /// padding is inserted, the alignment of `next` is irrelevant,\n+    /// and is not incoporated *at all* into the resulting layout.\n+    ///\n+    /// Returns `(k, offset)`, where `k` is layout of the concatenated\n+    /// record and `offset` is the relative location, in bytes, of the\n+    /// start of the `next` embedded witnin the concatenated record\n+    /// (assuming that the record itself starts at offset 0).\n+    ///\n+    /// (The `offset` is always the same as `self.size()`; we use this\n+    ///  signature out of convenience in matching the signature of\n+    ///  `extend`.)\n+    ///\n+    /// On arithmetic overflow, returns `None`.\n+    pub fn extend_packed(&self, next: Self) -> Option<(Self, usize)> {\n+        let new_size = match self.size().checked_add(next.size()) {\n+            None => return None,\n+            Some(new_size) => new_size,\n+        };\n+        Some((Layout::from_size_align(new_size, self.align), self.size()))\n+    }\n+\n+    /// Creates a layout describing the record for a `[T; n]`.\n+    ///\n+    /// On arithmetic overflow, returns `None`.\n+    pub fn array<T>(n: usize) -> Option<Self> {\n+        Layout::new::<T>()\n+            .repeat(n)\n+            .map(|(k, offs)| {\n+                debug_assert!(offs == mem::size_of::<T>());\n+                k\n+            })\n+    }\n+}\n+\n+/// The `AllocErr` error specifies whether an allocation failure is\n+/// specifically due to resource exhaustion or if it is due to\n+/// something wrong when combining the given input arguments with this\n+/// allocator.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub enum AllocErr {\n+    /// Error due to hitting some resource limit or otherwise running\n+    /// out of memory. This condition strongly implies that *some*\n+    /// series of deallocations would allow a subsequent reissuing of\n+    /// the original allocation request to succeed.\n+    Exhausted { request: Layout },\n+\n+    /// Error due to allocator being fundamentally incapable of\n+    /// satisfying the original request. This condition implies that\n+    /// such an allocation request will never succeed on the given\n+    /// allocator, regardless of environment, memory pressure, or\n+    /// other contextual conditions.\n+    ///\n+    /// For example, an allocator that does not support requests for\n+    /// large memory blocks might return this error variant.\n+    Unsupported { details: &'static str },\n+}\n+\n+impl AllocErr {\n+    pub fn invalid_input(details: &'static str) -> Self {\n+        AllocErr::Unsupported { details: details }\n+    }\n+    pub fn is_memory_exhausted(&self) -> bool {\n+        if let AllocErr::Exhausted { .. } = *self { true } else { false }\n+    }\n+    pub fn is_request_unsupported(&self) -> bool {\n+        if let AllocErr::Unsupported { .. } = *self { true } else { false }\n+    }\n+}\n+\n+/// The `CannotReallocInPlace` error is used when `grow_in_place` or\n+/// `shrink_in_place` were unable to reuse the given memory block for\n+/// a requested layout.\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct CannotReallocInPlace;\n+\n+/// An implementation of `Alloc` can allocate, reallocate, and\n+/// deallocate arbitrary blocks of data described via `Layout`.\n+///\n+/// Some of the methods require that a memory block be *currently\n+/// allocated* via an allocator. This means that:\n+///\n+/// * the starting address for that memory block was previously\n+///   returned by a previous call to an allocation method (`alloc`,\n+///   `alloc_zeroed`, `alloc_excess`, `alloc_one`, `alloc_array`) or\n+///   reallocation method (`realloc`, `realloc_excess`, or\n+///   `realloc_array`), and\n+///\n+/// * the memory block has not been subsequently deallocated, where\n+///   blocks are deallocated either by being passed to a deallocation\n+///   method (`dealloc`, `dealloc_one`, `dealloc_array`) or by being\n+///   passed to a reallocation method (see above) that returns `Ok`.\n+///\n+/// A note regarding zero-sized types and zero-sized layouts: many\n+/// methods in the `Alloc` trait state that allocation requests\n+/// must be non-zero size, or else undefined behavior can result.\n+///\n+/// * However, some higher-level allocation methods (`alloc_one`,\n+///   `alloc_array`) are well-defined on zero-sized types and can\n+///   optionally support them: it is left up to the implementor\n+///   whether to return `Err`, or to return `Ok` with some pointer.\n+///\n+/// * If an `Alloc` implementation chooses to return `Ok` in this\n+///   case (i.e. the pointer denotes a zero-sized inaccessible block)\n+///   then that returned pointer must be considered \"currently\n+///   allocated\". On such an allocator, *all* methods that take\n+///   currently-allocated pointers as inputs must accept these\n+///   zero-sized pointers, *without* causing undefined behavior.\n+///\n+/// * In other words, if a zero-sized pointer can flow out of an\n+///   allocator, then that allocator must likewise accept that pointer\n+///   flowing back into its deallocation and reallocation methods.\n+///\n+/// Some of the methods require that a layout *fit* a memory block.\n+/// What it means for a layout to \"fit\" a memory block means (or\n+/// equivalently, for a memory block to \"fit\" a layout) is that the\n+/// following two conditions must hold:\n+///\n+/// 1. The block's starting address must be aligned to `layout.align()`.\n+///\n+/// 2. The block's size must fall in the range `[use_min, use_max]`, where:\n+///\n+///    * `use_min` is `self.usable_size(layout).0`, and\n+///\n+///    * `use_max` is the capacity that was (or would have been)\n+///      returned when (if) the block was allocated via a call to\n+///      `alloc_excess` or `realloc_excess`.\n+///\n+/// Note that:\n+///\n+///  * the size of the layout most recently used to allocate the block\n+///    is guaranteed to be in the range `[use_min, use_max]`, and\n+///\n+///  * a lower-bound on `use_max` can be safely approximated by a call to\n+///    `usable_size`.\n+///\n+///  * if a layout `k` fits a memory block (denoted by `ptr`)\n+///    currently allocated via an allocator `a`, then it is legal to\n+///    use that layout to deallocate it, i.e. `a.dealloc(ptr, k);`.\n+pub unsafe trait Alloc {\n+\n+    // (Note: existing allocators have unspecified but well-defined\n+    // behavior in response to a zero size allocation request ;\n+    // e.g. in C, `malloc` of 0 will either return a null pointer or a\n+    // unique pointer, but will not have arbitrary undefined\n+    // behavior. Rust should consider revising the alloc::heap crate\n+    // to reflect this reality.)\n+\n+    /// Returns a pointer meeting the size and alignment guarantees of\n+    /// `layout`.\n+    ///\n+    /// If this method returns an `Ok(addr)`, then the `addr` returned\n+    /// will be non-null address pointing to a block of storage\n+    /// suitable for holding an instance of `layout`.\n+    ///\n+    /// The returned block of storage may or may not have its contents\n+    /// initialized. (Extension subtraits might restrict this\n+    /// behavior, e.g. to ensure initialization to particular sets of\n+    /// bit patterns.)\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure that `layout` has non-zero size.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints.\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n+\n+    /// Deallocate the memory referenced by `ptr`.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via\n+    ///   this allocator,\n+    ///\n+    /// * `layout` must *fit* that block of memory,\n+    ///\n+    /// * In addition to fitting the block of memory `layout`, the\n+    ///   alignment of the `layout` must match the alignment used\n+    ///   to allocate that block of memory.\n+    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n+\n+    /// Allocator-specific method for signalling an out-of-memory\n+    /// condition.\n+    ///\n+    /// `oom` aborts the thread or process, optionally performing\n+    /// cleanup or logging diagnostic information before panicking or\n+    /// aborting.\n+    ///\n+    /// `oom` is meant to be used by clients unable to cope with an\n+    /// unsatisfied allocation request (signaled by an error such as\n+    /// `AllocErr::Exhausted`), and wish to abandon computation rather\n+    /// than attempt to recover locally. Such clients should pass the\n+    /// signalling error value back into `oom`, where the allocator\n+    /// may incorporate that error value into its diagnostic report\n+    /// before aborting.\n+    ///\n+    /// Implementations of the `oom` method are discouraged from\n+    /// infinitely regressing in nested calls to `oom`. In\n+    /// practice this means implementors should eschew allocating,\n+    /// especially from `self` (directly or indirectly).\n+    ///\n+    /// Implementions of the allocation and reallocation methods\n+    /// (e.g. `alloc`, `alloc_one`, `realloc`) are discouraged from\n+    /// panicking (or aborting) in the event of memory exhaustion;\n+    /// instead they should return an appropriate error from the\n+    /// invoked method, and let the client decide whether to invoke\n+    /// this `oom` method in response.\n+    fn oom(&mut self, _: AllocErr) -> ! {\n+        unsafe { ::core::intrinsics::abort() }\n+    }\n+\n+    // == ALLOCATOR-SPECIFIC QUANTITIES AND LIMITS ==\n+    // usable_size\n+\n+    /// Returns bounds on the guaranteed usable size of a successful\n+    /// allocation created with the specified `layout`.\n+    ///\n+    /// In particular, if one has a memory block allocated via a given\n+    /// allocator `a` and layout `k` where `a.usable_size(k)` returns\n+    /// `(l, u)`, then one can pass that block to `a.dealloc()` with a\n+    /// layout in the size range [l, u].\n+    ///\n+    /// (All implementors of `usable_size` must ensure that\n+    /// `l <= k.size() <= u`)\n+    ///\n+    /// Both the lower- and upper-bounds (`l` and `u` respectively)\n+    /// are provided, because an allocator based on size classes could\n+    /// misbehave if one attempts to deallocate a block without\n+    /// providing a correct value for its size (i.e., one within the\n+    /// range `[l, u]`).\n+    ///\n+    /// Clients who wish to make use of excess capacity are encouraged\n+    /// to use the `alloc_excess` and `realloc_excess` instead, as\n+    /// this method is constrained to report conservative values that\n+    /// serve as valid bounds for *all possible* allocation method\n+    /// calls.\n+    ///\n+    /// However, for clients that do not wish to track the capacity\n+    /// returned by `alloc_excess` locally, this method is likely to\n+    /// produce useful results.\n+    fn usable_size(&self, layout: &Layout) -> (usize, usize) {\n+        (layout.size(), layout.size())\n+    }\n+\n+    // == METHODS FOR MEMORY REUSE ==\n+    // realloc. alloc_excess, realloc_excess\n+\n+    /// Returns a pointer suitable for holding data described by\n+    /// `new_layout`, meeting its size and alignment guarantees. To\n+    /// accomplish this, this may extend or shrink the allocation\n+    /// referenced by `ptr` to fit `new_layout`.\n+    ///\n+    /// If this returns `Ok`, then ownership of the memory block\n+    /// referenced by `ptr` has been transferred to this\n+    /// allocator. The memory may or may not have been freed, and\n+    /// should be considered unusable (unless of course it was\n+    /// transferred back to the caller again via the return value of\n+    /// this method).\n+    ///\n+    /// If this method returns `Err`, then ownership of the memory\n+    /// block has not been transferred to this allocator, and the\n+    /// contents of the memory block are unaltered.\n+    ///\n+    /// For best results, `new_layout` should not impose a different\n+    /// alignment constraint than `layout`. (In other words,\n+    /// `new_layout.align()` should equal `layout.align()`.) However,\n+    /// behavior is well-defined (though underspecified) when this\n+    /// constraint is violated; further discussion below.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must *fit* the `ptr` (see above). (The `new_layout`\n+    ///   argument need not fit it.)\n+    ///\n+    /// * `new_layout` must have size greater than zero.\n+    ///\n+    /// * the alignment of `new_layout` is non-zero.\n+    ///\n+    /// (Extension subtraits might provide more specific bounds on\n+    /// behavior, e.g. guarantee a sentinel address or a null pointer\n+    /// in response to a zero-size allocation request.)\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err` only if `new_layout` does not match the\n+    /// alignment of `layout`, or does not meet the allocator's size\n+    /// and alignment constraints of the allocator, or if reallocation\n+    /// otherwise fails.\n+    ///\n+    /// (Note the previous sentence did not say \"if and only if\" -- in\n+    /// particular, an implementation of this method *can* return `Ok`\n+    /// if `new_layout.align() != old_layout.align()`; or it can\n+    /// return `Err` in that scenario, depending on whether this\n+    /// allocator can dynamically adjust the alignment constraint for\n+    /// the block.)\n+    ///\n+    /// Implementations are encouraged to return `Err` on memory\n+    /// exhaustion rather than panicking or aborting, but this is not\n+    /// a strict requirement. (Specifically: it is *legal* to\n+    /// implement this trait atop an underlying native allocation\n+    /// library that aborts on memory exhaustion.)\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// reallocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn realloc(&mut self,\n+                      ptr: *mut u8,\n+                      layout: Layout,\n+                      new_layout: Layout) -> Result<*mut u8, AllocErr> {\n+        let new_size = new_layout.size();\n+        let old_size = layout.size();\n+        let aligns_match = layout.align == new_layout.align;\n+\n+        if new_size >= old_size && aligns_match {\n+            if let Ok(()) = self.grow_in_place(ptr, layout.clone(), new_layout.clone()) {\n+                return Ok(ptr);\n+            }\n+        } else if new_size < old_size && aligns_match {\n+            if let Ok(()) = self.shrink_in_place(ptr, layout.clone(), new_layout.clone()) {\n+                return Ok(ptr);\n+            }\n+        }\n+\n+        // otherwise, fall back on alloc + copy + dealloc.\n+        let result = self.alloc(new_layout);\n+        if let Ok(new_ptr) = result {\n+            ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n+            self.dealloc(ptr, layout);\n+        }\n+        result\n+    }\n+\n+    /// Behaves like `alloc`, but also ensures that the contents\n+    /// are set to zero before being returned.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+        let size = layout.size();\n+        let p = self.alloc(layout);\n+        if let Ok(p) = p {\n+            ptr::write_bytes(p, 0, size);\n+        }\n+        p\n+    }\n+\n+    /// Behaves like `alloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe for the same reasons that `alloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `alloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&layout);\n+        self.alloc(layout).map(|p| Excess(p, usable_size.1))\n+    }\n+\n+    /// Behaves like `realloc`, but also returns the whole size of\n+    /// the returned block. For some `layout` inputs, like arrays, this\n+    /// may include extra storage usable for additional data.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe for the same reasons that `realloc` is.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `layout` does not meet allocator's size or alignment\n+    /// constraints, just as in `realloc`.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// reallocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn realloc_excess(&mut self,\n+                             ptr: *mut u8,\n+                             layout: Layout,\n+                             new_layout: Layout) -> Result<Excess, AllocErr> {\n+        let usable_size = self.usable_size(&new_layout);\n+        self.realloc(ptr, layout, new_layout)\n+            .map(|p| Excess(p, usable_size.1))\n+    }\n+\n+    /// Attempts to extend the allocation referenced by `ptr` to fit `new_layout`.\n+    ///\n+    /// If this returns `Ok`, then the allocator has asserted that the\n+    /// memory block referenced by `ptr` now fits `new_layout`, and thus can\n+    /// be used to carry data of that layout. (The allocator is allowed to\n+    /// expend effort to accomplish this, such as extending the memory block to\n+    /// include successor blocks, or virtual memory tricks.)\n+    ///\n+    /// Regardless of what this method returns, ownership of the\n+    /// memory block referenced by `ptr` has not been transferred, and\n+    /// the contents of the memory block are unaltered.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must *fit* the `ptr` (see above); note the\n+    ///   `new_layout` argument need not fit it,\n+    ///\n+    /// * `new_layout.size()` must not be less than `layout.size()`,\n+    ///\n+    /// * `new_layout.align()` must equal `layout.align()`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n+    /// method; clients are expected either to be able to recover from\n+    /// `grow_in_place` failures without aborting, or to fall back on\n+    /// another reallocation method before resorting to an abort.\n+    unsafe fn grow_in_place(&mut self,\n+                            ptr: *mut u8,\n+                            layout: Layout,\n+                            new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        let _ = ptr; // this default implementation doesn't care about the actual address.\n+        debug_assert!(new_layout.size >= layout.size);\n+        debug_assert!(new_layout.align == layout.align);\n+        let (_l, u) = self.usable_size(&layout);\n+        // _l <= layout.size()                       [guaranteed by usable_size()]\n+        //       layout.size() <= new_layout.size()  [required by this method]\n+        if new_layout.size <= u {\n+            return Ok(());\n+        } else {\n+            return Err(CannotReallocInPlace);\n+        }\n+    }\n+\n+    /// Attempts to shrink the allocation referenced by `ptr` to fit `new_layout`.\n+    ///\n+    /// If this returns `Ok`, then the allocator has asserted that the\n+    /// memory block referenced by `ptr` now fits `new_layout`, and\n+    /// thus can only be used to carry data of that smaller\n+    /// layout. (The allocator is allowed to take advantage of this,\n+    /// carving off portions of the block for reuse elsewhere.) The\n+    /// truncated contents of the block within the smaller layout are\n+    /// unaltered, and ownership of block has not been transferred.\n+    ///\n+    /// If this returns `Err`, then the memory block is considered to\n+    /// still represent the original (larger) `layout`. None of the\n+    /// block has been carved off for reuse elsewhere, ownership of\n+    /// the memory block has not been transferred, and the contents of\n+    /// the memory block are unaltered.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * `layout` must *fit* the `ptr` (see above); note the\n+    ///   `new_layout` argument need not fit it,\n+    ///\n+    /// * `new_layout.size()` must not be greater than `layout.size()`\n+    ///   (and must be greater than zero),\n+    ///\n+    /// * `new_layout.align()` must equal `layout.align()`.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returns `Err(CannotReallocInPlace)` when the allocator is\n+    /// unable to assert that the memory block referenced by `ptr`\n+    /// could fit `layout`.\n+    ///\n+    /// Note that one cannot pass `CannotReallocInPlace` to the `oom`\n+    /// method; clients are expected either to be able to recover from\n+    /// `shrink_in_place` failures without aborting, or to fall back\n+    /// on another reallocation method before resorting to an abort.\n+    unsafe fn shrink_in_place(&mut self,\n+                              ptr: *mut u8,\n+                              layout: Layout,\n+                              new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        let _ = ptr; // this default implementation doesn't care about the actual address.\n+        debug_assert!(new_layout.size <= layout.size);\n+        debug_assert!(new_layout.align == layout.align);\n+        let (l, _u) = self.usable_size(&layout);\n+        //                      layout.size() <= _u  [guaranteed by usable_size()]\n+        // new_layout.size() <= layout.size()        [required by this method]\n+        if l <= new_layout.size {\n+            return Ok(());\n+        } else {\n+            return Err(CannotReallocInPlace);\n+        }\n+    }\n+\n+\n+    // == COMMON USAGE PATTERNS ==\n+    // alloc_one, dealloc_one, alloc_array, realloc_array. dealloc_array\n+\n+    /// Allocates a block suitable for holding an instance of `T`.\n+    ///\n+    /// Captures a common usage pattern for allocators.\n+    ///\n+    /// The returned block is suitable for passing to the\n+    /// `alloc`/`realloc` methods of this allocator.\n+    ///\n+    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n+    /// must be considered \"currently allocated\" and must be\n+    /// acceptable input to methods such as `realloc` or `dealloc`,\n+    /// *even if* `T` is a zero-sized type. In other words, if your\n+    /// `Alloc` implementation overrides this method in a manner\n+    /// that can return a zero-sized `ptr`, then all reallocation and\n+    /// deallocation methods need to be similarly overridden to accept\n+    /// such values as input.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `T` does not meet allocator's size or alignment constraints.\n+    ///\n+    /// For zero-sized `T`, may return either of `Ok` or `Err`, but\n+    /// will *not* yield undefined behavior.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    fn alloc_one<T>(&mut self) -> Result<Unique<T>, AllocErr>\n+        where Self: Sized\n+    {\n+        let k = Layout::new::<T>();\n+        if k.size() > 0 {\n+            unsafe { self.alloc(k).map(|p|Unique::new(*p as *mut T)) }\n+        } else {\n+            Err(AllocErr::invalid_input(\"zero-sized type invalid for alloc_one\"))\n+        }\n+    }\n+\n+    /// Deallocates a block suitable for holding an instance of `T`.\n+    ///\n+    /// The given block must have been produced by this allocator,\n+    /// and must be suitable for storing a `T` (in terms of alignment\n+    /// as well as minimum and maximum size); otherwise yields\n+    /// undefined behavior.\n+    ///\n+    /// Captures a common usage pattern for allocators.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure both:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via this allocator\n+    ///\n+    /// * the layout of `T` must *fit* that block of memory.\n+    unsafe fn dealloc_one<T>(&mut self, ptr: Unique<T>)\n+        where Self: Sized\n+    {\n+        let raw_ptr = ptr.as_ptr() as *mut u8;\n+        let k = Layout::new::<T>();\n+        if k.size() > 0 {\n+            self.dealloc(raw_ptr, k);\n+        }\n+    }\n+\n+    /// Allocates a block suitable for holding `n` instances of `T`.\n+    ///\n+    /// Captures a common usage pattern for allocators.\n+    ///\n+    /// The returned block is suitable for passing to the\n+    /// `alloc`/`realloc` methods of this allocator.\n+    ///\n+    /// Note to implementors: If this returns `Ok(ptr)`, then `ptr`\n+    /// must be considered \"currently allocated\" and must be\n+    /// acceptable input to methods such as `realloc` or `dealloc`,\n+    /// *even if* `T` is a zero-sized type. In other words, if your\n+    /// `Alloc` implementation overrides this method in a manner\n+    /// that can return a zero-sized `ptr`, then all reallocation and\n+    /// deallocation methods need to be similarly overridden to accept\n+    /// such values as input.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `[T; n]` does not meet allocator's size or alignment\n+    /// constraints.\n+    ///\n+    /// For zero-sized `T` or `n == 0`, may return either of `Ok` or\n+    /// `Err`, but will *not* yield undefined behavior.\n+    ///\n+    /// Always returns `Err` on arithmetic overflow.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// allocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    fn alloc_array<T>(&mut self, n: usize) -> Result<Unique<T>, AllocErr>\n+        where Self: Sized\n+    {\n+        match Layout::array::<T>(n) {\n+            Some(ref layout) if layout.size() > 0 => {\n+                unsafe {\n+                    self.alloc(layout.clone())\n+                        .map(|p| {\n+                            Unique::new(p as *mut T)\n+                        })\n+                }\n+            }\n+            _ => Err(AllocErr::invalid_input(\"invalid layout for alloc_array\")),\n+        }\n+    }\n+\n+    /// Reallocates a block previously suitable for holding `n_old`\n+    /// instances of `T`, returning a block suitable for holding\n+    /// `n_new` instances of `T`.\n+    ///\n+    /// Captures a common usage pattern for allocators.\n+    ///\n+    /// The returned block is suitable for passing to the\n+    /// `alloc`/`realloc` methods of this allocator.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure all of the following:\n+    ///\n+    /// * `ptr` must be currently allocated via this allocator,\n+    ///\n+    /// * the layout of `[T; n_old]` must *fit* that block of memory.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either memory is exhausted or\n+    /// `[T; n_new]` does not meet allocator's size or alignment\n+    /// constraints.\n+    ///\n+    /// For zero-sized `T` or `n_new == 0`, may return either of `Ok` or\n+    /// `Err`, but will *not* yield undefined behavior.\n+    ///\n+    /// Always returns `Err` on arithmetic overflow.\n+    ///\n+    /// Clients wishing to abort computation in response to an\n+    /// reallocation error are encouraged to call the allocator's `oom`\n+    /// method, rather than directly invoking `panic!` or similar.\n+    unsafe fn realloc_array<T>(&mut self,\n+                               ptr: Unique<T>,\n+                               n_old: usize,\n+                               n_new: usize) -> Result<Unique<T>, AllocErr>\n+        where Self: Sized\n+    {\n+        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n+            (Some(ref k_old), Some(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n+                self.realloc(ptr as *mut u8, k_old.clone(), k_new.clone())\n+                    .map(|p|Unique::new(p as *mut T))\n+            }\n+            _ => {\n+                Err(AllocErr::invalid_input(\"invalid layout for realloc_array\"))\n+            }\n+        }\n+    }\n+\n+    /// Deallocates a block suitable for holding `n` instances of `T`.\n+    ///\n+    /// Captures a common usage pattern for allocators.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because undefined behavior can result\n+    /// if the caller does not ensure both:\n+    ///\n+    /// * `ptr` must denote a block of memory currently allocated via this allocator\n+    ///\n+    /// * the layout of `[T; n]` must *fit* that block of memory.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Returning `Err` indicates that either `[T; n]` or the given\n+    /// memory block does not meet allocator's size or alignment\n+    /// constraints.\n+    ///\n+    /// Always returns `Err` on arithmetic overflow.\n+    unsafe fn dealloc_array<T>(&mut self, ptr: Unique<T>, n: usize) -> Result<(), AllocErr>\n+        where Self: Sized\n+    {\n+        let raw_ptr = ptr.as_ptr() as *mut u8;\n+        match Layout::array::<T>(n) {\n+            Some(ref k) if k.size() > 0 => {\n+                Ok(self.dealloc(raw_ptr, k.clone()))\n+            }\n+            _ => {\n+                Err(AllocErr::invalid_input(\"invalid layout for dealloc_array\"))\n+            }\n+        }\n+    }\n+}"}, {"sha": "ca52943ea97e32b57a7279fc5b8fb57e2ba0aeee", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/066fafe2062b17fac343219e0067edbc14b774ae/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/066fafe2062b17fac343219e0067edbc14b774ae/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=066fafe2062b17fac343219e0067edbc14b774ae", "patch": "@@ -143,6 +143,10 @@ extern crate std_unicode;\n #[macro_use]\n mod macros;\n \n+// Allocator trait and helper struct definitions\n+\n+pub mod allocator;\n+\n // Heaps provided for low-level allocation strategies\n \n pub mod heap;"}]}