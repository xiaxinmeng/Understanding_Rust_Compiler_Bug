{"sha": "f1776fe244d8603006536dceb7a21967e1c21f9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNzc2ZmUyNDRkODYwMzAwNjUzNmRjZWI3YTIxOTY3ZTFjMjFmOWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-28T14:22:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-05-28T14:22:51Z"}, "message": "Auto merge of #33927 - Manishearth:rollup, r=Manishearth\n\nRollup of 15 pull requests\n\n- Successful merges: #33820, #33821, #33822, #33824, #33825, #33831, #33832, #33848, #33849, #33852, #33854, #33856, #33859, #33860, #33861\n- Failed merges:", "tree": {"sha": "c1cf8fde1eef116c1deb34ede7b1211e79115712", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1cf8fde1eef116c1deb34ede7b1211e79115712"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1776fe244d8603006536dceb7a21967e1c21f9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1776fe244d8603006536dceb7a21967e1c21f9c", "html_url": "https://github.com/rust-lang/rust/commit/f1776fe244d8603006536dceb7a21967e1c21f9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1776fe244d8603006536dceb7a21967e1c21f9c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d68b3d106b293e29502d1c9dc1018ff59b90603", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d68b3d106b293e29502d1c9dc1018ff59b90603", "html_url": "https://github.com/rust-lang/rust/commit/7d68b3d106b293e29502d1c9dc1018ff59b90603"}, {"sha": "fe9a91589ec5eb9e1a2cb1edc50be1f18c65fae5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe9a91589ec5eb9e1a2cb1edc50be1f18c65fae5", "html_url": "https://github.com/rust-lang/rust/commit/fe9a91589ec5eb9e1a2cb1edc50be1f18c65fae5"}], "stats": {"total": 1399, "additions": 787, "deletions": 612}, "files": [{"sha": "9eade937bfb4cffd60a4f3c207d312fccb8c54f5", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -80,13 +80,40 @@ mod imp {\n         if align <= MIN_ALIGN {\n             libc::malloc(size as libc::size_t) as *mut u8\n         } else {\n-            let mut out = ptr::null_mut();\n-            let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n-            if ret != 0 {\n-                ptr::null_mut()\n-            } else {\n-                out as *mut u8\n-            }\n+            aligned_malloc(size, align)\n+        }\n+    }\n+\n+    #[cfg(target_os = \"android\")]\n+    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+        // On android we currently target API level 9 which unfortunately\n+        // doesn't have the `posix_memalign` API used below. Instead we use\n+        // `memalign`, but this unfortunately has the property on some systems\n+        // where the memory returned cannot be deallocated by `free`!\n+        //\n+        // Upon closer inspection, however, this appears to work just fine with\n+        // Android, so for this platform we should be fine to call `memalign`\n+        // (which is present in API level 9). Some helpful references could\n+        // possibly be chromium using memalign [1], attempts at documenting that\n+        // memalign + free is ok [2] [3], or the current source of chromium\n+        // which still uses memalign on android [4].\n+        //\n+        // [1]: https://codereview.chromium.org/10796020/\n+        // [2]: https://code.google.com/p/android/issues/detail?id=35391\n+        // [3]: https://bugs.chromium.org/p/chromium/issues/detail?id=138579\n+        // [4]: https://chromium.googlesource.com/chromium/src/base/+/master/\n+        //                                       /memory/aligned_memory.cc\n+        libc::memalign(align as libc::size_t, size as libc::size_t) as *mut u8\n+    }\n+\n+    #[cfg(not(target_os = \"android\"))]\n+    unsafe fn aligned_malloc(size: usize, align: usize) -> *mut u8 {\n+        let mut out = ptr::null_mut();\n+        let ret = libc::posix_memalign(&mut out, align as libc::size_t, size as libc::size_t);\n+        if ret != 0 {\n+            ptr::null_mut()\n+        } else {\n+            out as *mut u8\n         }\n     }\n "}, {"sha": "d80b456181ae475d8e53651b30b2aefab89a38a5", "filename": "src/libcore/char.rs", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -411,14 +411,17 @@ pub struct EscapeUnicode {\n     hex_digit_idx: usize,\n }\n \n+// The enum values are ordered so that their representation is the\n+// same as the remaining length (besides the hexadecimal digits). This\n+// likely makes `len()` a single load from memory) and inline-worth.\n #[derive(Clone, Debug)]\n enum EscapeUnicodeState {\n-    Backslash,\n-    Type,\n-    LeftBrace,\n-    Value,\n-    RightBrace,\n     Done,\n+    RightBrace,\n+    Value,\n+    LeftBrace,\n+    Type,\n+    Backslash,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -457,19 +460,17 @@ impl Iterator for EscapeUnicode {\n         }\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = match self.state {\n-            EscapeUnicodeState::Backslash => 5,\n-            EscapeUnicodeState::Type => 4,\n-            EscapeUnicodeState::LeftBrace => 3,\n-            EscapeUnicodeState::Value => 2,\n-            EscapeUnicodeState::RightBrace => 1,\n-            EscapeUnicodeState::Done => 0,\n-        };\n-        let n = n + self.hex_digit_idx;\n+        let n = self.len();\n         (n, Some(n))\n     }\n \n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n     fn last(self) -> Option<char> {\n         match self.state {\n             EscapeUnicodeState::Done => None,\n@@ -483,6 +484,22 @@ impl Iterator for EscapeUnicode {\n     }\n }\n \n+#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n+impl ExactSizeIterator for EscapeUnicode {\n+    #[inline]\n+    fn len(&self) -> usize {\n+        // The match is a single memory access with no branching\n+        self.hex_digit_idx + match self.state {\n+            EscapeUnicodeState::Done => 0,\n+            EscapeUnicodeState::RightBrace => 1,\n+            EscapeUnicodeState::Value => 2,\n+            EscapeUnicodeState::LeftBrace => 3,\n+            EscapeUnicodeState::Type => 4,\n+            EscapeUnicodeState::Backslash => 5,\n+        }\n+    }\n+}\n+\n /// An iterator that yields the literal escape code of a `char`.\n ///\n /// This `struct` is created by the [`escape_default()`] method on [`char`]. See\n@@ -498,9 +515,9 @@ pub struct EscapeDefault {\n \n #[derive(Clone, Debug)]\n enum EscapeDefaultState {\n-    Backslash(char),\n-    Char(char),\n     Done,\n+    Char(char),\n+    Backslash(char),\n     Unicode(EscapeUnicode),\n }\n \n@@ -523,22 +540,15 @@ impl Iterator for EscapeDefault {\n         }\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.state {\n-            EscapeDefaultState::Char(_) => (1, Some(1)),\n-            EscapeDefaultState::Backslash(_) => (2, Some(2)),\n-            EscapeDefaultState::Unicode(ref iter) => iter.size_hint(),\n-            EscapeDefaultState::Done => (0, Some(0)),\n-        }\n+        let n = self.len();\n+        (n, Some(n))\n     }\n \n+    #[inline]\n     fn count(self) -> usize {\n-        match self.state {\n-            EscapeDefaultState::Char(_) => 1,\n-            EscapeDefaultState::Unicode(iter) => iter.count(),\n-            EscapeDefaultState::Done => 0,\n-            EscapeDefaultState::Backslash(_) => 2,\n-        }\n+        self.len()\n     }\n \n     fn nth(&mut self, n: usize) -> Option<char> {\n@@ -578,6 +588,18 @@ impl Iterator for EscapeDefault {\n     }\n }\n \n+#[stable(feature = \"exact_size_escape\", since = \"1.11.0\")]\n+impl ExactSizeIterator for EscapeDefault {\n+    fn len(&self) -> usize {\n+        match self.state {\n+            EscapeDefaultState::Done => 0,\n+            EscapeDefaultState::Char(_) => 1,\n+            EscapeDefaultState::Backslash(_) => 2,\n+            EscapeDefaultState::Unicode(ref iter) => iter.len(),\n+        }\n+    }\n+}\n+\n /// An iterator over `u8` entries represending the UTF-8 encoding of a `char`\n /// value.\n ///"}, {"sha": "7da876b945947c646138727c1f8d358dd84956c7", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -276,6 +276,12 @@ fn eu_iterator_specializations() {\n             // Check last\n             assert_eq!(iter.clone().last(), Some('}'));\n \n+            // Check len\n+            assert_eq!(iter.len(), len - offset);\n+\n+            // Check size_hint (= len in ExactSizeIterator)\n+            assert_eq!(iter.size_hint(), (iter.len(), Some(iter.len())));\n+\n             // Check counting\n             assert_eq!(iter.clone().count(), len - offset);\n "}, {"sha": "80918ce68e26fc6c4dabc55d3c5392c25f59bf06", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -280,12 +280,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathList(ref prefix, ref list) => {\n-                    if !list.is_empty() {\n-                        for item in list {\n-                            visitor.visit_path_list_item(prefix, item)\n-                        }\n-                    } else {\n-                        visitor.visit_path(prefix, item.id);\n+                    visitor.visit_path(prefix, item.id);\n+                    for item in list {\n+                        visitor.visit_path_list_item(prefix, item)\n                     }\n                 }\n             }\n@@ -419,12 +416,8 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n }\n \n pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                               prefix: &'v Path,\n+                                               _prefix: &'v Path,\n                                                item: &'v PathListItem) {\n-    for segment in &prefix.segments {\n-        visitor.visit_path_segment(prefix.span, segment);\n-    }\n-\n     walk_opt_name(visitor, item.span, item.node.name());\n     walk_opt_name(visitor, item.span, item.node.rename());\n }"}, {"sha": "7c9c52baa63e44965632e0ebb8fe34b87af3e22b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -163,6 +163,11 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // If the number of errors increases, that's also a sign (line\n     // `tained_by_errors`) to avoid reporting certain kinds of errors.\n     err_count_on_creation: usize,\n+\n+    // This flag is used for debugging, and is set to true if there are\n+    // any obligations set during the current snapshot. In that case, the\n+    // snapshot can't be rolled back.\n+    pub obligations_in_snapshot: Cell<bool>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized\n@@ -476,7 +481,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             normalize: false,\n             projection_mode: ProjectionMode::AnyFinal,\n             tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: self.sess.err_count()\n+            err_count_on_creation: self.sess.err_count(),\n+            obligations_in_snapshot: Cell::new(false),\n         }\n     }\n }\n@@ -515,7 +521,8 @@ impl<'a, 'gcx, 'tcx> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n             normalize: normalize,\n             projection_mode: projection_mode,\n             tainted_by_errors_flag: Cell::new(false),\n-            err_count_on_creation: tcx.sess.err_count()\n+            err_count_on_creation: tcx.sess.err_count(),\n+            obligations_in_snapshot: Cell::new(false),\n         }))\n     }\n }\n@@ -542,6 +549,7 @@ pub struct CombinedSnapshot {\n     int_snapshot: unify::Snapshot<ty::IntVid>,\n     float_snapshot: unify::Snapshot<ty::FloatVid>,\n     region_vars_snapshot: RegionSnapshot,\n+    obligations_in_snapshot: bool,\n }\n \n /// Helper trait for shortening the lifetimes inside a\n@@ -809,11 +817,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn start_snapshot(&self) -> CombinedSnapshot {\n+        let obligations_in_snapshot = self.obligations_in_snapshot.get();\n+        self.obligations_in_snapshot.set(false);\n+\n         CombinedSnapshot {\n             type_snapshot: self.type_variables.borrow_mut().snapshot(),\n             int_snapshot: self.int_unification_table.borrow_mut().snapshot(),\n             float_snapshot: self.float_unification_table.borrow_mut().snapshot(),\n             region_vars_snapshot: self.region_vars.start_snapshot(),\n+            obligations_in_snapshot: obligations_in_snapshot,\n         }\n     }\n \n@@ -822,7 +834,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = snapshot;\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = snapshot;\n+\n+        assert!(!self.obligations_in_snapshot.get());\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n         self.type_variables\n             .borrow_mut()\n@@ -842,7 +858,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = snapshot;\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = snapshot;\n+\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n \n         self.type_variables\n             .borrow_mut()\n@@ -904,12 +923,16 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let CombinedSnapshot { type_snapshot,\n                                int_snapshot,\n                                float_snapshot,\n-                               region_vars_snapshot } = self.start_snapshot();\n+                               region_vars_snapshot,\n+                               obligations_in_snapshot } = self.start_snapshot();\n \n         let r = self.commit_if_ok(|_| f());\n \n         debug!(\"commit_regions_if_ok: rolling back everything but regions\");\n \n+        assert!(!self.obligations_in_snapshot.get());\n+        self.obligations_in_snapshot.set(obligations_in_snapshot);\n+\n         // Roll back any non-region bindings - they should be resolved\n         // inside `f`, with, e.g. `resolve_type_vars_if_possible`.\n         self.type_variables"}, {"sha": "0d7d7afd120d28d9e7080d7cd8830fb5a78e06ad", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -171,6 +171,8 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n+        infcx.obligations_in_snapshot.set(true);\n+\n         if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate)\n         {\n             return"}, {"sha": "c177ec4dbede7bcfc81ec845d5cff766d41b01b6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -31,7 +31,7 @@ pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n pub use self::project::{MismatchedProjectionTypes, ProjectionMode};\n-pub use self::project::{normalize, Normalized};\n+pub use self::project::{normalize, normalize_projection_type, Normalized};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};"}, {"sha": "44ec42de8cbd68101b7f6af5f3d24b4c374dd949", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -207,7 +207,7 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     debug!(\"project_and_unify_type(obligation={:?})\",\n            obligation);\n \n-    let Normalized { value: normalized_ty, obligations } =\n+    let Normalized { value: normalized_ty, mut obligations } =\n         match opt_normalize_projection_type(selcx,\n                                             obligation.predicate.projection_ty.clone(),\n                                             obligation.cause.clone(),\n@@ -224,8 +224,9 @@ fn project_and_unify_type<'cx, 'gcx, 'tcx>(\n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n     match infcx.eq_types(true, origin, normalized_ty, obligation.predicate.ty) {\n         Ok(InferOk { obligations: inferred_obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n+            // FIXME(#32730) once obligations are generated in inference, drop this assertion\n             assert!(inferred_obligations.is_empty());\n+            obligations.extend(inferred_obligations);\n             Ok(Some(obligations))\n         },\n         Err(err) => Err(MismatchedProjectionTypes { err: err }),\n@@ -710,7 +711,8 @@ fn assemble_candidates_from_predicates<'cx, 'gcx, 'tcx, I>(\n                                               origin,\n                                               data_poly_trait_ref,\n                                               obligation_poly_trait_ref)\n-                        // FIXME(#32730) propagate obligations\n+                        // FIXME(#32730) once obligations are propagated from unification in\n+                        // inference, drop this assertion\n                         .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n                         .is_ok()\n                 });\n@@ -1047,8 +1049,8 @@ fn confirm_fn_pointer_candidate<'cx, 'gcx, 'tcx>(\n     fn_pointer_vtable: VtableFnPointerData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n-    // FIXME(#32730) propagate obligations (fn pointer vtable nested obligations ONLY come from\n-    // unification in inference)\n+    // FIXME(#32730) drop this assertion once obligations are propagated from inference (fn pointer\n+    // vtable nested obligations ONLY come from unification in inference)\n     assert!(fn_pointer_vtable.nested.is_empty());\n     let fn_type = selcx.infcx().shallow_resolve(fn_pointer_vtable.fn_ty);\n     let sig = fn_type.fn_sig();\n@@ -1130,13 +1132,14 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n                obligation.predicate.item_name);\n \n     let origin = TypeOrigin::RelateOutputImplTypes(obligation.cause.span);\n-    match infcx.eq_trait_refs(false,\n-                              origin,\n-                              obligation.predicate.trait_ref.clone(),\n-                              projection.projection_ty.trait_ref.clone()) {\n+    let obligations = match infcx.eq_trait_refs(false,\n+                                                origin,\n+                                                obligation.predicate.trait_ref.clone(),\n+                                                projection.projection_ty.trait_ref.clone()) {\n         Ok(InferOk { obligations, .. }) => {\n-            // FIXME(#32730) propagate obligations\n+            // FIXME(#32730) once obligations are generated in inference, remove this assertion\n             assert!(obligations.is_empty());\n+            obligations\n         }\n         Err(e) => {\n             span_bug!(\n@@ -1146,9 +1149,9 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n                 projection,\n                 e);\n         }\n-    }\n+    };\n \n-    (projection.ty, vec!())\n+    (projection.ty, obligations)\n }\n \n fn confirm_impl_candidate<'cx, 'gcx, 'tcx>("}, {"sha": "c7a3637557602d8d2a8c30cad79ef3fff70a7411", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 40, "deletions": 42, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -187,51 +187,49 @@ fn fulfill_implication<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                        source_trait_ref: ty::TraitRef<'tcx>,\n                                        target_impl: DefId)\n                                        -> Result<&'tcx Substs<'tcx>, ()> {\n-    infcx.commit_if_ok(|_| {\n-        let selcx = &mut SelectionContext::new(&infcx);\n-        let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n-        let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n-                                                                       target_impl,\n-                                                                       &target_substs);\n-\n-        // do the impls unify? If not, no specialization.\n-        if let Err(_) = infcx.eq_trait_refs(true,\n-                                            TypeOrigin::Misc(DUMMY_SP),\n-                                            source_trait_ref,\n-                                            target_trait_ref) {\n-            debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n-            return Err(());\n-        }\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    let target_substs = fresh_type_vars_for_impl(&infcx, DUMMY_SP, target_impl);\n+    let (target_trait_ref, obligations) = impl_trait_ref_and_oblig(selcx,\n+                                                                   target_impl,\n+                                                                   &target_substs);\n+\n+    // do the impls unify? If not, no specialization.\n+    if let Err(_) = infcx.eq_trait_refs(true,\n+                                        TypeOrigin::Misc(DUMMY_SP),\n+                                        source_trait_ref,\n+                                        target_trait_ref) {\n+        debug!(\"fulfill_implication: {:?} does not unify with {:?}\",\n+               source_trait_ref,\n+               target_trait_ref);\n+        return Err(());\n+    }\n \n-        // attempt to prove all of the predicates for impl2 given those for impl1\n-        // (which are packed up in penv)\n+    // attempt to prove all of the predicates for impl2 given those for impl1\n+    // (which are packed up in penv)\n \n-        let mut fulfill_cx = FulfillmentContext::new();\n-        for oblig in obligations.into_iter() {\n-            fulfill_cx.register_predicate_obligation(&infcx, oblig);\n-        }\n+    let mut fulfill_cx = FulfillmentContext::new();\n+    for oblig in obligations.into_iter() {\n+        fulfill_cx.register_predicate_obligation(&infcx, oblig);\n+    }\n \n-        if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n-            // no dice!\n-            debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n-                    {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref,\n-                   errors,\n-                   infcx.parameter_environment.caller_bounds);\n-            Err(())\n-        } else {\n-            debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n-                   source_trait_ref,\n-                   target_trait_ref);\n-\n-            // Now resolve the *substitution* we built for the target earlier, replacing\n-            // the inference variables inside with whatever we got from fulfillment.\n-            Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n-        }\n-    })\n+    if let Err(errors) = infcx.drain_fulfillment_cx(&mut fulfill_cx, &()) {\n+        // no dice!\n+        debug!(\"fulfill_implication: for impls on {:?} and {:?}, could not fulfill: {:?} given \\\n+                {:?}\",\n+               source_trait_ref,\n+               target_trait_ref,\n+               errors,\n+               infcx.parameter_environment.caller_bounds);\n+        Err(())\n+    } else {\n+        debug!(\"fulfill_implication: an impl for {:?} specializes {:?}\",\n+               source_trait_ref,\n+               target_trait_ref);\n+\n+        // Now resolve the *substitution* we built for the target earlier, replacing\n+        // the inference variables inside with whatever we got from fulfillment.\n+        Ok(infcx.resolve_type_vars_if_possible(&target_substs))\n+    }\n }\n \n pub struct SpecializesCache {"}, {"sha": "60f2ca6f4d9b61abe08bf6e97902472635ea207c", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -235,8 +235,9 @@ impl<'a, 'gcx, 'tcx> ty::TyS<'tcx> {\n             None => {\n                 span_bug!(\n                     expr_span,\n-                    \"the {}th autoderef failed: {}\",\n+                    \"the {}th autoderef for {} failed: {}\",\n                     autoderef,\n+                    expr_id,\n                     adjusted_ty);\n             }\n         }"}, {"sha": "819717628d62dbfb66f74aac3e86b867fea03678", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -977,7 +977,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         if let Categorization::Local(local_id) = err.cmt.cat {\n                             let span = self.tcx.map.span(local_id);\n                             if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                                if snippet != \"self\" {\n+                                if snippet.starts_with(\"ref \") {\n+                                    db.span_label(span,\n+                                        &format!(\"use `{}` here to make mutable\",\n+                                            snippet.replace(\"ref \", \"ref mut \")));\n+                                } else if snippet != \"self\" {\n                                     db.span_label(span,\n                                         &format!(\"use `mut {}` here to make mutable\", snippet));\n                                 }"}, {"sha": "a039467c8afc05a18c112b044a837af48c3a588d", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -401,10 +401,6 @@ mod svh_visitor {\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n-        fn visit_path_list_item(&mut self, prefix: &'a Path, item: &'a PathListItem) {\n-            SawPath.hash(self.st); visit::walk_path_list_item(self, prefix, item)\n-        }\n-\n         fn visit_block(&mut self, b: &'a Block) {\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }"}, {"sha": "9e2b7cd034652f28d77264a1b41bef494bf2dfcd", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -0,0 +1,210 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use astconv::AstConv;\n+\n+use super::FnCtxt;\n+\n+use rustc::traits;\n+use rustc::ty::{self, Ty, TraitRef};\n+use rustc::ty::{ToPredicate, TypeFoldable};\n+use rustc::ty::{MethodCall, MethodCallee};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n+use rustc::hir;\n+\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+\n+#[derive(Copy, Clone, Debug)]\n+enum AutoderefKind {\n+    Builtin,\n+    Overloaded\n+}\n+\n+pub struct Autoderef<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n+    steps: Vec<(Ty<'tcx>, AutoderefKind)>,\n+    cur_ty: Ty<'tcx>,\n+    obligations: Vec<traits::PredicateObligation<'tcx>>,\n+    at_start: bool,\n+    span: Span\n+}\n+\n+impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n+    type Item = (Ty<'tcx>, usize);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let tcx = self.fcx.tcx;\n+\n+        debug!(\"autoderef: steps={:?}, cur_ty={:?}\",\n+               self.steps, self.cur_ty);\n+        if self.at_start {\n+            self.at_start = false;\n+            debug!(\"autoderef stage #0 is {:?}\", self.cur_ty);\n+            return Some((self.cur_ty, 0));\n+        }\n+\n+        if self.steps.len() == tcx.sess.recursion_limit.get() {\n+            // We've reached the recursion limit, error gracefully.\n+            span_err!(tcx.sess, self.span, E0055,\n+                      \"reached the recursion limit while auto-dereferencing {:?}\",\n+                      self.cur_ty);\n+            return None;\n+        }\n+\n+        if self.cur_ty.is_ty_var() {\n+            return None;\n+        }\n+\n+        // Otherwise, deref if type is derefable:\n+        let (kind, new_ty) = if let Some(mt) = self.cur_ty.builtin_deref(false, NoPreference) {\n+            (AutoderefKind::Builtin, mt.ty)\n+        } else {\n+            match self.overloaded_deref_ty(self.cur_ty) {\n+                Some(ty) => (AutoderefKind::Overloaded, ty),\n+                _ => return None\n+            }\n+        };\n+\n+        if new_ty.references_error() {\n+            return None;\n+        }\n+\n+        self.steps.push((self.cur_ty, kind));\n+        debug!(\"autoderef stage #{:?} is {:?} from {:?}\", self.steps.len(),\n+               new_ty, (self.cur_ty, kind));\n+        self.cur_ty = new_ty;\n+\n+        Some((self.cur_ty, self.steps.len()))\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n+    fn overloaded_deref_ty(&mut self, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n+        debug!(\"overloaded_deref_ty({:?})\", ty);\n+\n+        let tcx = self.fcx.tcx();\n+\n+        // <cur_ty as Deref>\n+        let trait_ref = TraitRef {\n+            def_id: match tcx.lang_items.deref_trait() {\n+                Some(f) => f,\n+                None => return None\n+            },\n+            substs: tcx.mk_substs(Substs::new_trait(vec![], vec![], self.cur_ty))\n+        };\n+\n+        let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+\n+        let mut selcx = traits::SelectionContext::new(self.fcx);\n+        let obligation = traits::Obligation::new(cause.clone(), trait_ref.to_predicate());\n+        if !selcx.evaluate_obligation(&obligation) {\n+            debug!(\"overloaded_deref_ty: cannot match obligation\");\n+            return None;\n+        }\n+\n+        let normalized = traits::normalize_projection_type(\n+            &mut selcx,\n+            ty::ProjectionTy {\n+                trait_ref: trait_ref,\n+                item_name: token::intern(\"Target\")\n+            },\n+            cause,\n+            0\n+        );\n+\n+        debug!(\"overloaded_deref_ty({:?}) = {:?}\", ty, normalized);\n+        self.obligations.extend(normalized.obligations);\n+\n+        Some(self.fcx.resolve_type_vars_if_possible(&normalized.value))\n+    }\n+\n+    pub fn unambiguous_final_ty(&self) -> Ty<'tcx> {\n+        self.fcx.structurally_resolved_type(self.span, self.cur_ty)\n+    }\n+\n+    pub fn finalize<'b, I>(self, pref: LvaluePreference, exprs: I)\n+        where I: IntoIterator<Item=&'b hir::Expr>\n+    {\n+        let methods : Vec<_> = self.steps.iter().map(|&(ty, kind)| {\n+            if let AutoderefKind::Overloaded = kind {\n+                self.fcx.try_overloaded_deref(self.span, None, ty, pref)\n+            } else {\n+                None\n+            }\n+        }).collect();\n+\n+        debug!(\"finalize({:?}) - {:?},{:?}\", pref, methods, self.obligations);\n+\n+        for expr in exprs {\n+            debug!(\"finalize - finalizing #{} - {:?}\", expr.id, expr);\n+            for (n, method) in methods.iter().enumerate() {\n+                if let &Some(method) = method {\n+                    let method_call = MethodCall::autoderef(expr.id, n as u32);\n+                    self.fcx.tables.borrow_mut().method_map.insert(method_call, method);\n+                }\n+            }\n+        }\n+\n+        for obligation in self.obligations {\n+            self.fcx.register_predicate(obligation);\n+        }\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n+    pub fn autoderef(&'a self,\n+                     span: Span,\n+                     base_ty: Ty<'tcx>)\n+                     -> Autoderef<'a, 'gcx, 'tcx>\n+    {\n+        Autoderef {\n+            fcx: self,\n+            steps: vec![],\n+            cur_ty: self.resolve_type_vars_if_possible(&base_ty),\n+            obligations: vec![],\n+            at_start: true,\n+            span: span\n+        }\n+    }\n+\n+    pub fn try_overloaded_deref(&self,\n+                                span: Span,\n+                                base_expr: Option<&hir::Expr>,\n+                                base_ty: Ty<'tcx>,\n+                                lvalue_pref: LvaluePreference)\n+                                -> Option<MethodCallee<'tcx>>\n+    {\n+        debug!(\"try_overloaded_deref({:?},{:?},{:?},{:?})\",\n+               span, base_expr, base_ty, lvalue_pref);\n+        // Try DerefMut first, if preferred.\n+        let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n+            (PreferMutLvalue, Some(trait_did)) => {\n+                self.lookup_method_in_trait(span, base_expr,\n+                                            token::intern(\"deref_mut\"), trait_did,\n+                                            base_ty, None)\n+            }\n+            _ => None\n+        };\n+\n+        // Otherwise, fall back to Deref.\n+        let method = match (method, self.tcx.lang_items.deref_trait()) {\n+            (None, Some(trait_did)) => {\n+                self.lookup_method_in_trait(span, base_expr,\n+                                            token::intern(\"deref\"), trait_did,\n+                                            base_ty, None)\n+            }\n+            (method, _) => method\n+        };\n+\n+        method\n+    }\n+}"}, {"sha": "417b2fafecfd3e39fc353a152f26569021a5e72d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use super::{DeferredCallResolution, Expectation, FnCtxt,\n-            TupleArgumentsFlag, UnresolvedTypeAction};\n+            TupleArgumentsFlag};\n \n use CrateCtxt;\n use middle::cstore::LOCAL_CRATE;\n@@ -72,15 +72,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     {\n         self.check_expr(callee_expr);\n         let original_callee_ty = self.expr_ty(callee_expr);\n-        let (callee_ty, _, result) =\n-            self.autoderef(callee_expr.span,\n-                           original_callee_ty,\n-                           || Some(callee_expr),\n-                           UnresolvedTypeAction::Error,\n-                           LvaluePreference::NoPreference,\n-                           |adj_ty, idx| {\n-                self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n-        });\n+\n+        let mut autoderef = self.autoderef(callee_expr.span, original_callee_ty);\n+        let result = autoderef.by_ref().flat_map(|(adj_ty, idx)| {\n+            self.try_overloaded_call_step(call_expr, callee_expr, adj_ty, idx)\n+        }).next();\n+        let callee_ty = autoderef.unambiguous_final_ty();\n+        autoderef.finalize(LvaluePreference::NoPreference, Some(callee_expr));\n \n         match result {\n             None => {"}, {"sha": "9dd737f3a6168af9ae99a35b6e081089f7a8aaba", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n \n use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n@@ -220,7 +220,8 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                                          -> CoerceResult<'tcx>\n         // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n         where E: Fn() -> I,\n-              I: IntoIterator<Item=&'a hir::Expr> {\n+              I: IntoIterator<Item=&'a hir::Expr>\n+    {\n \n         debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n@@ -240,18 +241,16 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n \n         let span = self.origin.span();\n \n-        let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n         let mut r_borrow_var = None;\n-        let (_, autoderefs, success) = self.autoderef(span, a, exprs,\n-                                                      UnresolvedTypeAction::Ignore,\n-                                                      lvalue_pref,\n-                                                      |referent_ty, autoderef|\n-        {\n-            if autoderef == 0 {\n+        let mut autoderef = self.autoderef(span, a);\n+        let mut success = None;\n+\n+        for (referent_ty, autoderefs) in autoderef.by_ref() {\n+            if autoderefs == 0 {\n                 // Don't let this pass, otherwise it would cause\n                 // &T to autoref to &&T.\n-                return None;\n+                continue\n             }\n \n             // At this point, we have deref'd `a` to `referent_ty`.  So\n@@ -326,7 +325,7 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             //     and let regionck figure it out.\n             let r = if !self.use_lub {\n                 r_b // [2] above\n-            } else if autoderef == 1 {\n+            } else if autoderefs == 1 {\n                 r_a // [3] above\n             } else {\n                 if r_borrow_var.is_none() { // create var lazilly, at most once\n@@ -341,30 +340,33 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n                 mutbl: mt_b.mutbl // [1] above\n             });\n             match self.unify(derefd_ty_a, b) {\n-                Ok(ty) => Some(ty),\n+                Ok(ty) => { success = Some((ty, autoderefs)); break },\n                 Err(err) => {\n                     if first_error.is_none() {\n                         first_error = Some(err);\n                     }\n-                    None\n                 }\n             }\n-        });\n+        }\n \n         // Extract type or return an error. We return the first error\n         // we got, which should be from relating the \"base\" type\n         // (e.g., in example above, the failure from relating `Vec<T>`\n         // to the target type), since that should be the least\n         // confusing.\n-        let ty = match success {\n-            Some(ty) => ty,\n+        let (ty, autoderefs) = match success {\n+            Some(d) => d,\n             None => {\n                 let err = first_error.expect(\"coerce_borrowed_pointer had no error\");\n                 debug!(\"coerce_borrowed_pointer: failed with err = {:?}\", err);\n                 return Err(err);\n             }\n         };\n \n+        // This commits the obligations to the fulfillcx. After this succeeds,\n+        // this snapshot can't be rolled back.\n+        autoderef.finalize(LvaluePreference::from_mutbl(mt_b.mutbl), exprs());\n+\n         // Now apply the autoref. We have to extract the region out of\n         // the final ref type we got.\n         if ty == a && mt_a.mutbl == hir::MutImmutable && autoderefs == 1 {"}, {"sha": "20f82271b9cd6f60e78ff313e0903a1143caa520", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 52, "deletions": 67, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -279,78 +279,63 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // type.\n \n         // Compute skolemized form of impl and trait method tys.\n-        let impl_fty = tcx.mk_fn_ptr(impl_m.fty);\n-        let impl_fty = impl_fty.subst(tcx, impl_to_skol_substs);\n-        let trait_fty = tcx.mk_fn_ptr(trait_m.fty);\n-        let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n-\n-        let err = infcx.commit_if_ok(|snapshot| {\n-            let tcx = infcx.tcx;\n-            let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n-\n-            let (impl_sig, _) =\n-                infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n-                                                                infer::HigherRankedType,\n-                                                                &impl_m.fty.sig);\n-            let impl_sig =\n-                impl_sig.subst(tcx, impl_to_skol_substs);\n-            let impl_sig =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_m_span,\n-                                                     impl_m_body_id,\n-                                                     &impl_sig);\n-            let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: impl_m.fty.unsafety,\n-                abi: impl_m.fty.abi,\n-                sig: ty::Binder(impl_sig)\n-            }));\n-            debug!(\"compare_impl_method: impl_fty={:?}\",\n-                   impl_fty);\n-\n-            let (trait_sig, skol_map) =\n-                infcx.skolemize_late_bound_regions(&trait_m.fty.sig, snapshot);\n-            let trait_sig =\n-                trait_sig.subst(tcx, &trait_to_skol_substs);\n-            let trait_sig =\n-                assoc::normalize_associated_types_in(&infcx,\n-                                                     &mut fulfillment_cx,\n-                                                     impl_m_span,\n-                                                     impl_m_body_id,\n-                                                     &trait_sig);\n-            let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n-                unsafety: trait_m.fty.unsafety,\n-                abi: trait_m.fty.abi,\n-                sig: ty::Binder(trait_sig)\n-            }));\n-\n-            debug!(\"compare_impl_method: trait_fty={:?}\",\n+        let tcx = infcx.tcx;\n+        let origin = TypeOrigin::MethodCompatCheck(impl_m_span);\n+\n+        let (impl_sig, _) =\n+            infcx.replace_late_bound_regions_with_fresh_var(impl_m_span,\n+                                                            infer::HigherRankedType,\n+                                                            &impl_m.fty.sig);\n+        let impl_sig =\n+            impl_sig.subst(tcx, impl_to_skol_substs);\n+        let impl_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &impl_sig);\n+        let impl_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: impl_m.fty.unsafety,\n+            abi: impl_m.fty.abi,\n+            sig: ty::Binder(impl_sig)\n+        }));\n+        debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n+\n+        let trait_sig = tcx.liberate_late_bound_regions(\n+            infcx.parameter_environment.free_id_outlive,\n+            &trait_m.fty.sig);\n+        let trait_sig =\n+            trait_sig.subst(tcx, &trait_to_skol_substs);\n+        let trait_sig =\n+            assoc::normalize_associated_types_in(&infcx,\n+                                                 &mut fulfillment_cx,\n+                                                 impl_m_span,\n+                                                 impl_m_body_id,\n+                                                 &trait_sig);\n+        let trait_fty = tcx.mk_fn_ptr(tcx.mk_bare_fn(ty::BareFnTy {\n+            unsafety: trait_m.fty.unsafety,\n+            abi: trait_m.fty.abi,\n+            sig: ty::Binder(trait_sig)\n+        }));\n+\n+        debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n+\n+        if let Err(terr) = infcx.sub_types(false, origin, impl_fty, trait_fty) {\n+            debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\",\n+                   impl_fty,\n                    trait_fty);\n-\n-            infcx.sub_types(false, origin, impl_fty, trait_fty)?;\n-\n-            infcx.leak_check(false, &skol_map, snapshot)\n-        });\n-\n-        match err {\n-            Ok(()) => { }\n-            Err(terr) => {\n-                debug!(\"checking trait method for compatibility: impl ty {:?}, trait ty {:?}\",\n-                       impl_fty,\n-                       trait_fty);\n-                span_err!(tcx.sess, impl_m_span, E0053,\n-                          \"method `{}` has an incompatible type for trait: {}\",\n-                          trait_m.name,\n-                          terr);\n-                return;\n-            }\n+            span_err!(tcx.sess, impl_m_span, E0053,\n+                      \"method `{}` has an incompatible type for trait: {}\",\n+                      trait_m.name,\n+                      terr);\n+            return\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n-        match fulfillment_cx.select_all_or_error(&infcx) {\n-            Err(ref errors) => { infcx.report_fulfillment_errors(errors) }\n-            Ok(_) => {}\n+        if let Err(ref errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(errors);\n+            return\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of"}, {"sha": "683a67ff07cf9fe9da436290d6067c3aaa70cdb3", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -11,11 +11,10 @@\n use super::probe;\n \n use check::{FnCtxt, callee};\n-use check::UnresolvedTypeAction;\n use hir::def_id::DefId;\n use rustc::ty::subst::{self};\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, PreferMutLvalue, Ty};\n+use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::ty::fold::TypeFoldable;\n use rustc::infer::{self, InferOk, TypeOrigin};\n@@ -133,10 +132,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             ty: fty,\n             substs: all_substs\n         };\n-        // If this is an `&mut self` method, bias the receiver\n-        // expression towards mutability (this will switch\n-        // e.g. `Deref` to `DerefMut` in overloaded derefs and so on).\n-        self.fixup_derefs_on_method_receiver_if_necessary(&callee);\n+\n+        if let Some(hir::MutMutable) = pick.autoref {\n+            self.convert_lvalue_derefs_to_mutable();\n+        }\n \n         callee\n     }\n@@ -164,22 +163,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             (None, None)\n         };\n \n-        // Commit the autoderefs by calling `autoderef again, but this\n+        // Commit the autoderefs by calling `autoderef` again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) = self.autoderef(self.span,\n-                                                        unadjusted_self_ty,\n-                                                        || Some(self.self_expr),\n-                                                        UnresolvedTypeAction::Error,\n-                                                        NoPreference,\n-                                                        |_, n| {\n-            if n == pick.autoderefs {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        });\n+        let mut autoderef = self.autoderef(self.span, unadjusted_self_ty);\n+        let (autoderefd_ty, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n-        assert_eq!(result, Some(()));\n+\n+        autoderef.unambiguous_final_ty();\n+        autoderef.finalize(LvaluePreference::NoPreference, Some(self.self_expr));\n \n         // Write out the final adjustment.\n         self.write_adjustment(self.self_expr.id, AdjustDerefRef(AutoDerefRef {\n@@ -293,27 +284,21 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n-        let (_, _, result) = self.fcx.autoderef(self.span,\n-                                                self_ty,\n-                                                || None,\n-                                                UnresolvedTypeAction::Error,\n-                                                NoPreference,\n-                                                |ty, _| {\n-            match ty.sty {\n-                ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n-                _ => None,\n-            }\n-        });\n-\n-        match result {\n-            Some(r) => r,\n-            None => {\n+        // FIXME: this feels, like, super dubious\n+        self.fcx.autoderef(self.span, self_ty)\n+            .filter_map(|(ty, _)| {\n+                match ty.sty {\n+                    ty::TyTrait(ref data) => Some(closure(self, ty, &data)),\n+                    _ => None,\n+                }\n+            })\n+            .next()\n+            .unwrap_or_else(|| {\n                 span_bug!(\n                     self.span,\n                     \"self-type `{}` for ObjectPick never dereferenced to an object\",\n                     self_ty)\n-            }\n-        }\n+            })\n     }\n \n     fn instantiate_method_substs(&mut self,\n@@ -463,24 +448,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // RECONCILIATION\n \n-    /// When we select a method with an `&mut self` receiver, we have to go convert any\n+    /// When we select a method with a mutable autoref, we have to go convert any\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n-    fn fixup_derefs_on_method_receiver_if_necessary(&self,\n-                                                    method_callee: &ty::MethodCallee) {\n-        let sig = match method_callee.ty.sty {\n-            ty::TyFnDef(_, _, ref f) => f.sig.clone(),\n-            _ => return,\n-        };\n-\n-        match sig.0.inputs[0].sty {\n-            ty::TyRef(_, ty::TypeAndMut {\n-                ty: _,\n-                mutbl: hir::MutMutable,\n-            }) => {}\n-            _ => return,\n-        }\n-\n+    fn convert_lvalue_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n         let mut exprs = Vec::new();\n         exprs.push(self.self_expr);\n@@ -495,8 +466,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"fixup_derefs_on_method_receiver_if_necessary: exprs={:?}\",\n-               exprs);\n+        debug!(\"convert_lvalue_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n@@ -509,23 +479,17 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                 Some(_) | None => 0,\n             };\n \n-            debug!(\"fixup_derefs_on_method_receiver_if_necessary: i={} expr={:?} \\\n-                                                                  autoderef_count={}\",\n+            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?} \\\n+                                                      autoderef_count={}\",\n                    i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n-                self.autoderef(expr.span,\n-                               self.expr_ty(expr),\n-                               || Some(expr),\n-                               UnresolvedTypeAction::Error,\n-                               PreferMutLvalue,\n-                               |_, autoderefs| {\n-                    if autoderefs == autoderef_count + 1 {\n-                        Some(())\n-                    } else {\n-                        None\n-                    }\n+                let mut autoderef = self.autoderef(expr.span, self.expr_ty(expr));\n+                autoderef.nth(autoderef_count).unwrap_or_else(|| {\n+                    span_bug!(expr.span, \"expr was deref-able {} times but now isn't?\",\n+                              autoderef_count);\n                 });\n+                autoderef.finalize(PreferMutLvalue, Some(expr));\n             }\n \n             // Don't retry the first one or we might infinite loop!"}, {"sha": "0bb078dfbcba2d5304f81b3f20df9c1d6db0d727", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -13,13 +13,13 @@ use super::NoMatchData;\n use super::{CandidateSource, ImplSource, TraitSource};\n use super::suggest;\n \n-use check::{FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n use hir::def_id::DefId;\n use hir::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::ty::{self, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n use rustc::infer::{InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -208,25 +208,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn create_steps(&self,\n                     span: Span,\n                     self_ty: Ty<'tcx>)\n-                    -> Option<Vec<CandidateStep<'tcx>>> {\n-        let mut steps = Vec::new();\n-\n-        let (final_ty, dereferences, _) = self.autoderef(span,\n-                                                         self_ty,\n-                                                         || None,\n-                                                         UnresolvedTypeAction::Error,\n-                                                         NoPreference,\n-                                                         |t, d| {\n-            steps.push(CandidateStep {\n-                self_ty: t,\n-                autoderefs: d,\n-                unsize: false\n-            });\n-            None::<()> // keep iterating until we can't anymore\n-        });\n+                    -> Option<Vec<CandidateStep<'tcx>>>\n+    {\n+        // FIXME: we don't need to create the entire steps in one pass\n \n+        let mut autoderef = self.autoderef(span, self_ty);\n+        let mut steps: Vec<_> = autoderef.by_ref().map(|(ty, d)| CandidateStep {\n+            self_ty: ty,\n+            autoderefs: d,\n+            unsize: false\n+        }).collect();\n+\n+        let final_ty = autoderef.unambiguous_final_ty();\n         match final_ty.sty {\n             ty::TyArray(elem_ty, _) => {\n+                let dereferences = steps.len() - 1;\n+\n                 steps.push(CandidateStep {\n                     self_ty: self.tcx.mk_slice(elem_ty),\n                     autoderefs: dereferences,\n@@ -237,6 +234,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => (),\n         }\n \n+        debug!(\"create_steps: steps={:?}\", steps);\n+\n         Some(steps)\n     }\n }"}, {"sha": "6f0d2bc0ca5e64a52bb1bd2d07a2723322d6cf06", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 20, "deletions": 43, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -13,15 +13,14 @@\n \n use CrateCtxt;\n \n-use check::{self, FnCtxt, UnresolvedTypeAction};\n+use check::{FnCtxt};\n use rustc::hir::map as hir_map;\n use rustc::ty::{self, Ty, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use middle::cstore;\n use hir::def::Def;\n use hir::def_id::DefId;\n use middle::lang_items::FnOnceTraitLangItem;\n use rustc::ty::subst::Substs;\n-use rustc::ty::LvaluePreference;\n use rustc::traits::{Obligation, SelectionContext};\n use util::nodemap::{FnvHashSet};\n \n@@ -48,42 +47,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             ty::TyClosure(..) | ty::TyFnDef(..) | ty::TyFnPtr(_) => true,\n             // If it's not a simple function, look for things which implement FnOnce\n             _ => {\n-                if let Ok(fn_once_trait_did) =\n-                        tcx.lang_items.require(FnOnceTraitLangItem) {\n-                    let (_, _, opt_is_fn) = self.autoderef(span,\n-                                                           ty,\n-                                                           || None,\n-                                                           UnresolvedTypeAction::Ignore,\n-                                                           LvaluePreference::NoPreference,\n-                                                           |ty, _| {\n-                        self.probe(|_| {\n-                            let fn_once_substs =\n-                                Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n-                            let trait_ref =\n-                                ty::TraitRef::new(fn_once_trait_did,\n-                                                  tcx.mk_substs(fn_once_substs));\n-                            let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                            let obligation = Obligation::misc(span,\n-                                                              self.body_id,\n-                                                              poly_trait_ref\n-                                                                 .to_predicate());\n-                            let mut selcx = SelectionContext::new(self);\n-\n-                            if selcx.evaluate_obligation(&obligation) {\n-                                Some(())\n-                            } else {\n-                                None\n-                            }\n-                        })\n-                    });\n+                let fn_once = match tcx.lang_items.require(FnOnceTraitLangItem) {\n+                    Ok(fn_once) => fn_once,\n+                    Err(..) => return false\n+                };\n \n-                    opt_is_fn.is_some()\n-                } else {\n-                    false\n-                }\n+                self.autoderef(span, ty).any(|(ty, _)| self.probe(|_| {\n+                    let fn_once_substs =\n+                        Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n+                    let trait_ref =\n+                        ty::TraitRef::new(fn_once,\n+                                          tcx.mk_substs(fn_once_substs));\n+                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                    let obligation = Obligation::misc(span,\n+                                                      self.body_id,\n+                                                      poly_trait_ref\n+                                                      .to_predicate());\n+                    SelectionContext::new(self).evaluate_obligation(&obligation)\n+                }))\n             }\n         }\n     }\n+\n     pub fn report_method_error(&self,\n                                span: Span,\n                                rcvr_ty: Ty<'tcx>,\n@@ -384,15 +369,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n         }\n \n-        self.autoderef(span, rcvr_ty, || None,\n-                       check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n-                       |ty, _| {\n-            if is_local(ty) {\n-                Some(())\n-            } else {\n-                None\n-            }\n-        }).2.is_some()\n+        self.autoderef(span, rcvr_ty).any(|(ty, _)| is_local(ty))\n     }\n }\n "}, {"sha": "5dd00cf3666ade3fcc692af31e728ce74bb2e65f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 197, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -129,6 +129,7 @@ use rustc_back::slice;\n use rustc_const_eval::eval_repeat_count;\n \n mod assoc;\n+mod autoderef;\n pub mod dropck;\n pub mod _match;\n pub mod writeback;\n@@ -1412,17 +1413,6 @@ impl<'a, 'gcx, 'tcx> RegionScope for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-/// Whether `autoderef` requires types to resolve.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum UnresolvedTypeAction {\n-    /// Produce an error and return `TyError` whenever a type cannot\n-    /// be resolved (i.e. it is `TyInfer`).\n-    Error,\n-    /// Go on without emitting any errors, and return the unresolved\n-    /// type. Useful for probing, e.g. in coercions.\n-    Ignore\n-}\n-\n /// Controls whether the arguments are tupled. This is used for the call\n /// operator.\n ///\n@@ -2228,120 +2218,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Executes an autoderef loop for the type `t`. At each step, invokes `should_stop`\n-    /// to decide whether to terminate the loop. Returns the final type and number of\n-    /// derefs that it performed.\n-    ///\n-    /// Note: this method does not modify the adjustments table. The caller is responsible for\n-    /// inserting an AutoAdjustment record into the `self` using one of the suitable methods.\n-    pub fn autoderef<'b, E, I, T, F>(&self,\n-                                     sp: Span,\n-                                     base_ty: Ty<'tcx>,\n-                                     maybe_exprs: E,\n-                                     unresolved_type_action: UnresolvedTypeAction,\n-                                     mut lvalue_pref: LvaluePreference,\n-                                     mut should_stop: F)\n-                                     -> (Ty<'tcx>, usize, Option<T>)\n-        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n-        where E: Fn() -> I,\n-              I: IntoIterator<Item=&'b hir::Expr>,\n-              F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n-    {\n-        debug!(\"autoderef(base_ty={:?}, lvalue_pref={:?})\",\n-               base_ty, lvalue_pref);\n-\n-        let mut t = base_ty;\n-        for autoderefs in 0..self.tcx.sess.recursion_limit.get() {\n-            let resolved_t = match unresolved_type_action {\n-                UnresolvedTypeAction::Error => {\n-                    self.structurally_resolved_type(sp, t)\n-                }\n-                UnresolvedTypeAction::Ignore => {\n-                    // We can continue even when the type cannot be resolved\n-                    // (i.e. it is an inference variable) because `Ty::builtin_deref`\n-                    // and `try_overloaded_deref` both simply return `None`\n-                    // in such a case without producing spurious errors.\n-                    self.resolve_type_vars_if_possible(&t)\n-                }\n-            };\n-            if resolved_t.references_error() {\n-                return (resolved_t, autoderefs, None);\n-            }\n-\n-            match should_stop(resolved_t, autoderefs) {\n-                Some(x) => return (resolved_t, autoderefs, Some(x)),\n-                None => {}\n-            }\n-\n-            // Otherwise, deref if type is derefable:\n-\n-            // Super subtle: it might seem as though we should\n-            // pass `opt_expr` to `try_overloaded_deref`, so that\n-            // the (implicit) autoref of using an overloaded deref\n-            // would get added to the adjustment table. However we\n-            // do not do that, because it's kind of a\n-            // \"meta-adjustment\" -- instead, we just leave it\n-            // unrecorded and know that there \"will be\" an\n-            // autoref. regionck and other bits of the code base,\n-            // when they encounter an overloaded autoderef, have\n-            // to do some reconstructive surgery. This is a pretty\n-            // complex mess that is begging for a proper MIR.\n-            let mt = if let Some(mt) = resolved_t.builtin_deref(false, lvalue_pref) {\n-                mt\n-            } else if let Some(method) = self.try_overloaded_deref(sp, None,\n-                                                                   resolved_t, lvalue_pref) {\n-                for expr in maybe_exprs() {\n-                    let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n-                    self.tables.borrow_mut().method_map.insert(method_call, method);\n-                }\n-                self.make_overloaded_lvalue_return_type(method)\n-            } else {\n-                return (resolved_t, autoderefs, None);\n-            };\n-\n-            t = mt.ty;\n-            if mt.mutbl == hir::MutImmutable {\n-                lvalue_pref = NoPreference;\n-            }\n-        }\n-\n-        // We've reached the recursion limit, error gracefully.\n-        span_err!(self.tcx.sess, sp, E0055,\n-            \"reached the recursion limit while auto-dereferencing {:?}\",\n-            base_ty);\n-        (self.tcx.types.err, 0, None)\n-    }\n-\n-    fn try_overloaded_deref(&self,\n-                            span: Span,\n-                            base_expr: Option<&hir::Expr>,\n-                            base_ty: Ty<'tcx>,\n-                            lvalue_pref: LvaluePreference)\n-                            -> Option<MethodCallee<'tcx>>\n-    {\n-        // Try DerefMut first, if preferred.\n-        let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n-            (PreferMutLvalue, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref_mut\"), trait_did,\n-                                            base_ty, None)\n-            }\n-            _ => None\n-        };\n-\n-        // Otherwise, fall back to Deref.\n-        let method = match (method, self.tcx.lang_items.deref_trait()) {\n-            (None, Some(trait_did)) => {\n-                self.lookup_method_in_trait(span, base_expr,\n-                                            token::intern(\"deref\"), trait_did,\n-                                            base_ty, None)\n-            }\n-            (method, _) => method\n-        };\n-\n-        method\n-    }\n-\n     /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n@@ -2371,29 +2247,28 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // autoderef that normal method probing does. They could likely be\n         // consolidated.\n \n-        let (ty, autoderefs, final_mt) = self.autoderef(base_expr.span,\n-                                                        base_ty,\n-                                                        || Some(base_expr),\n-                                                        UnresolvedTypeAction::Error,\n-                                                        lvalue_pref,\n-                                                        |adj_ty, idx| {\n-            self.try_index_step(MethodCall::expr(expr.id), expr, base_expr,\n-                                adj_ty, idx, false, lvalue_pref, idx_ty)\n-        });\n+        let mut autoderef = self.autoderef(base_expr.span, base_ty);\n \n-        if final_mt.is_some() {\n-            return final_mt;\n-        }\n+        while let Some((adj_ty, autoderefs)) = autoderef.next() {\n+            if let Some(final_mt) = self.try_index_step(\n+                MethodCall::expr(expr.id),\n+                expr, base_expr, adj_ty, autoderefs,\n+                false, lvalue_pref, idx_ty)\n+            {\n+                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                return Some(final_mt);\n+            }\n \n-        // After we have fully autoderef'd, if the resulting type is [T; n], then\n-        // do a final unsized coercion to yield [T].\n-        if let ty::TyArray(element_ty, _) = ty.sty {\n-            let adjusted_ty = self.tcx.mk_slice(element_ty);\n-            self.try_index_step(MethodCall::expr(expr.id), expr, base_expr,\n-                                adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n-        } else {\n-            None\n+            if let ty::TyArray(element_ty, _) = adj_ty.sty {\n+                autoderef.finalize(lvalue_pref, Some(base_expr));\n+                let adjusted_ty = self.tcx.mk_slice(element_ty);\n+                return self.try_index_step(\n+                    MethodCall::expr(expr.id), expr, base_expr,\n+                    adjusted_ty, autoderefs, true, lvalue_pref, idx_ty);\n+            }\n         }\n+        autoderef.unambiguous_final_ty();\n+        None\n     }\n \n     /// To type-check `base_expr[index_expr]`, we progressively autoderef\n@@ -3034,32 +2909,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      self.expr_ty(base));\n         let mut private_candidate = None;\n-        let (_, autoderefs, field_ty) = self.autoderef(expr.span,\n-                                                       expr_t,\n-                                                       || Some(base),\n-                                                       UnresolvedTypeAction::Error,\n-                                                       lvalue_pref,\n-                                                       |base_t, _| {\n-                if let ty::TyStruct(base_def, substs) = base_t.sty {\n-                    debug!(\"struct named {:?}\",  base_t);\n-                    if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n-                        let field_ty = self.field_ty(expr.span, field, substs);\n-                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n-                            return Some(field_ty);\n-                        }\n-                        private_candidate = Some((base_def.did, field_ty));\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, autoderefs)) = autoderef.next() {\n+            if let ty::TyStruct(base_def, substs) = base_t.sty {\n+                debug!(\"struct named {:?}\",  base_t);\n+                if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n+                    let field_ty = self.field_ty(expr.span, field, substs);\n+                    if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                        autoderef.finalize(lvalue_pref, Some(base));\n+                        self.write_ty(expr.id, field_ty);\n+                        self.write_autoderef_adjustment(base.id, autoderefs);\n+                        return;\n                     }\n+                    private_candidate = Some((base_def.did, field_ty));\n                 }\n-                None\n-            });\n-        match field_ty {\n-            Some(field_ty) => {\n-                self.write_ty(expr.id, field_ty);\n-                self.write_autoderef_adjustment(base.id, autoderefs);\n-                return;\n             }\n-            None => {}\n         }\n+        autoderef.unambiguous_final_ty();\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n@@ -3132,42 +2998,39 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                      self.expr_ty(base));\n         let mut private_candidate = None;\n         let mut tuple_like = false;\n-        let (_, autoderefs, field_ty) = self.autoderef(expr.span,\n-                                                       expr_t,\n-                                                       || Some(base),\n-                                                       UnresolvedTypeAction::Error,\n-                                                       lvalue_pref,\n-                                                       |base_t, _| {\n-                let (base_def, substs) = match base_t.sty {\n-                    ty::TyStruct(base_def, substs) => (base_def, substs),\n-                    ty::TyTuple(ref v) => {\n-                        tuple_like = true;\n-                        return if idx.node < v.len() { Some(v[idx.node]) } else { None }\n-                    }\n-                    _ => return None,\n-                };\n-\n-                tuple_like = base_def.struct_variant().is_tuple_struct();\n-                if !tuple_like { return None }\n-\n-                debug!(\"tuple struct named {:?}\",  base_t);\n-                if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n-                    let field_ty = self.field_ty(expr.span, field, substs);\n-                    if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n-                        return Some(field_ty);\n-                    }\n-                    private_candidate = Some((base_def.did, field_ty));\n+        let mut autoderef = self.autoderef(expr.span, expr_t);\n+        while let Some((base_t, autoderefs)) = autoderef.next() {\n+            let field = match base_t.sty {\n+                ty::TyStruct(base_def, substs) => {\n+                    tuple_like = base_def.struct_variant().is_tuple_struct();\n+                    if !tuple_like { continue }\n+\n+                    debug!(\"tuple struct named {:?}\",  base_t);\n+                    base_def.struct_variant().fields.get(idx.node).and_then(|field| {\n+                        let field_ty = self.field_ty(expr.span, field, substs);\n+                        private_candidate = Some((base_def.did, field_ty));\n+                        if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n+                            Some(field_ty)\n+                        } else {\n+                            None\n+                        }\n+                    })\n                 }\n-                None\n-            });\n-        match field_ty {\n-            Some(field_ty) => {\n+                ty::TyTuple(ref v) => {\n+                    tuple_like = true;\n+                    v.get(idx.node).cloned()\n+                }\n+                _ => continue\n+            };\n+\n+            if let Some(field_ty) = field {\n+                autoderef.finalize(lvalue_pref, Some(base));\n                 self.write_ty(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n                 return;\n             }\n-            None => {}\n         }\n+        autoderef.unambiguous_final_ty();\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);"}, {"sha": "2a2d41112ffae17fb0e156c3d9e4111ccc621181", "filename": "src/libstd/error.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -212,6 +212,13 @@ impl<T: Error> Error for Box<T> {\n     }\n }\n \n+#[stable(feature = \"fmt_error\", since = \"1.11.0\")]\n+impl Error for fmt::Error {\n+    fn description(&self) -> &str {\n+        \"an error occurred when formatting an argument\"\n+    }\n+}\n+\n // copied from any.rs\n impl Error + 'static {\n     /// Returns true if the boxed type is the same as `T`"}, {"sha": "016130e99989e3630c00c986495a731459349aed", "filename": "src/libstd/panic.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibstd%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibstd%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanic.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -39,14 +39,14 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n     take_hook()\n }\n \n-/// A marker trait which represents \"panic safe\" types in Rust.\n+/// A marker trait which represents \"unwind safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in\n /// terms of inference of implementation to the `Send` and `Sync` traits. The\n-/// purpose of this trait is to encode what types are safe to cross a `recover`\n-/// boundary with no fear of panic safety.\n+/// purpose of this trait is to encode what types are safe to cross a `catch_unwind`\n+/// boundary with no fear of unwind safety.\n ///\n-/// ## What is panic safety?\n+/// ## What is unwind safety?\n ///\n /// In Rust a function can \"return\" early if it either panics or calls a\n /// function which transitively panics. This sort of control flow is not always\n@@ -59,62 +59,62 @@ pub fn take_handler() -> Box<Fn(&PanicInfo) + 'static + Sync + Send> {\n ///\n /// Typically in Rust, it is difficult to perform step (2) because catching a\n /// panic involves either spawning a thread (which in turns makes it difficult\n-/// to later witness broken invariants) or using the `recover` function in this\n+/// to later witness broken invariants) or using the `catch_unwind` function in this\n /// module. Additionally, even if an invariant is witnessed, it typically isn't a\n-/// problem in Rust because there's no uninitialized values (like in C or C++).\n+/// problem in Rust because there are no uninitialized values (like in C or C++).\n ///\n /// It is possible, however, for **logical** invariants to be broken in Rust,\n-/// which can end up causing behavioral bugs. Another key aspect of panic safety\n+/// which can end up causing behavioral bugs. Another key aspect of unwind safety\n /// in Rust is that, in the absence of `unsafe` code, a panic cannot lead to\n /// memory unsafety.\n ///\n-/// That was a bit of a whirlwind tour of panic safety, but for more information\n-/// about panic safety and how it applies to Rust, see an [associated RFC][rfc].\n+/// That was a bit of a whirlwind tour of unwind safety, but for more information\n+/// about unwind safety and how it applies to Rust, see an [associated RFC][rfc].\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md\n ///\n /// ## What is `UnwindSafe`?\n ///\n-/// Now that we've got an idea of what panic safety is in Rust, it's also\n+/// Now that we've got an idea of what unwind safety is in Rust, it's also\n /// important to understand what this trait represents. As mentioned above, one\n-/// way to witness broken invariants is through the `recover` function in this\n+/// way to witness broken invariants is through the `catch_unwind` function in this\n /// module as it allows catching a panic and then re-using the environment of\n /// the closure.\n ///\n /// Simply put, a type `T` implements `UnwindSafe` if it cannot easily allow\n-/// witnessing a broken invariant through the use of `recover` (catching a\n+/// witnessing a broken invariant through the use of `catch_unwind` (catching a\n /// panic). This trait is a marker trait, so it is automatically implemented for\n-/// many types, and it is also structurally composed (e.g. a struct is recover\n-/// safe if all of its components are recover safe).\n+/// many types, and it is also structurally composed (e.g. a struct is unwind\n+/// safe if all of its components are unwind safe).\n ///\n /// Note, however, that this is not an unsafe trait, so there is not a succinct\n /// contract that this trait is providing. Instead it is intended as more of a\n-/// \"speed bump\" to alert users of `recover` that broken invariants may be\n+/// \"speed bump\" to alert users of `catch_unwind` that broken invariants may be\n /// witnessed and may need to be accounted for.\n ///\n /// ## Who implements `UnwindSafe`?\n ///\n /// Types such as `&mut T` and `&RefCell<T>` are examples which are **not**\n-/// recover safe. The general idea is that any mutable state which can be shared\n-/// across `recover` is not recover safe by default. This is because it is very\n-/// easy to witness a broken invariant outside of `recover` as the data is\n+/// unwind safe. The general idea is that any mutable state which can be shared\n+/// across `catch_unwind` is not unwind safe by default. This is because it is very\n+/// easy to witness a broken invariant outside of `catch_unwind` as the data is\n /// simply accessed as usual.\n ///\n-/// Types like `&Mutex<T>`, however, are recover safe because they implement\n+/// Types like `&Mutex<T>`, however, are unwind safe because they implement\n /// poisoning by default. They still allow witnessing a broken invariant, but\n /// they already provide their own \"speed bumps\" to do so.\n ///\n /// ## When should `UnwindSafe` be used?\n ///\n /// Is not intended that most types or functions need to worry about this trait.\n-/// It is only used as a bound on the `recover` function and as mentioned above,\n+/// It is only used as a bound on the `catch_unwind` function and as mentioned above,\n /// the lack of `unsafe` means it is mostly an advisory. The `AssertUnwindSafe`\n /// wrapper struct in this module can be used to force this trait to be\n-/// implemented for any closed over variables passed to the `recover` function\n+/// implemented for any closed over variables passed to the `catch_unwind` function\n /// (more on this below).\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} may not be safely transferred \\\n-                            across a recover boundary\"]\n+                            across an unwind boundary\"]\n pub trait UnwindSafe {}\n \n /// Deprecated, renamed to UnwindSafe\n@@ -126,7 +126,7 @@ pub trait RecoverSafe {}\n impl<T: UnwindSafe> RecoverSafe for T {}\n \n /// A marker trait representing types where a shared reference is considered\n-/// recover safe.\n+/// unwind safe.\n ///\n /// This trait is namely not implemented by `UnsafeCell`, the root of all\n /// interior mutability.\n@@ -136,31 +136,31 @@ impl<T: UnwindSafe> RecoverSafe for T {}\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n #[rustc_on_unimplemented = \"the type {Self} contains interior mutability \\\n                             and a reference may not be safely transferrable \\\n-                            across a recover boundary\"]\n+                            across a catch_unwind boundary\"]\n pub trait RefUnwindSafe {}\n \n-/// A simple wrapper around a type to assert that it is panic safe.\n+/// A simple wrapper around a type to assert that it is unwind safe.\n ///\n-/// When using `recover` it may be the case that some of the closed over\n-/// variables are not panic safe. For example if `&mut T` is captured the\n-/// compiler will generate a warning indicating that it is not panic safe. It\n+/// When using `catch_unwind` it may be the case that some of the closed over\n+/// variables are not unwind safe. For example if `&mut T` is captured the\n+/// compiler will generate a warning indicating that it is not unwind safe. It\n /// may not be the case, however, that this is actually a problem due to the\n-/// specific usage of `recover` if panic safety is specifically taken into\n+/// specific usage of `catch_unwind` if unwind safety is specifically taken into\n /// account. This wrapper struct is useful for a quick and lightweight\n-/// annotation that a variable is indeed panic safe.\n+/// annotation that a variable is indeed unwind safe.\n ///\n /// # Examples\n ///\n /// One way to use `AssertUnwindSafe` is to assert that the entire closure\n-/// itself is recover safe, bypassing all checks for all variables:\n+/// itself is unwind safe, bypassing all checks for all variables:\n ///\n /// ```\n /// use std::panic::{self, AssertUnwindSafe};\n ///\n /// let mut variable = 4;\n ///\n /// // This code will not compile because the closure captures `&mut variable`\n-/// // which is not considered panic safe by default.\n+/// // which is not considered unwind safe by default.\n ///\n /// // panic::catch_unwind(|| {\n /// //     variable += 3;\n@@ -239,7 +239,7 @@ impl<T> UnwindSafe for AssertUnwindSafe<T> {}\n impl<T> UnwindSafe for AssertRecoverSafe<T> {}\n \n // not covered via the Shared impl above b/c the inner contents use\n-// Cell/AtomicUsize, but the usage here is recover safe so we can lift the\n+// Cell/AtomicUsize, but the usage here is unwind safe so we can lift the\n // impl up one level to Arc/Rc itself\n #[stable(feature = \"catch_unwind\", since = \"1.9.0\")]\n impl<T: RefUnwindSafe + ?Sized> UnwindSafe for Rc<T> {}\n@@ -352,9 +352,9 @@ impl<R, F: FnOnce() -> R> FnOnce<()> for AssertRecoverSafe<F> {\n /// that all captured variables are safe to cross this boundary. The purpose of\n /// this bound is to encode the concept of [exception safety][rfc] in the type\n /// system. Most usage of this function should not need to worry about this\n-/// bound as programs are naturally panic safe without `unsafe` code. If it\n+/// bound as programs are naturally unwind safe without `unsafe` code. If it\n /// becomes a problem the associated `AssertUnwindSafe` wrapper type in this\n-/// module can be used to quickly assert that the usage here is indeed exception\n+/// module can be used to quickly assert that the usage here is indeed unwind\n /// safe.\n ///\n /// [rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1236-stabilize-catch-panic.md"}, {"sha": "6b15aa4f92c573dcf527dca2a7f7d5147226003e", "filename": "src/libsyntax/errors/emitter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Femitter.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -682,6 +682,7 @@ mod test {\n         println!(\"r#\\\"\\n{}\\\"#\", str);\n         assert_eq!(str, &r#\"\n   --> dummy.txt:11:1\n+   |>\n 11 |>         e-l\u00e4-v\u00e4n\n    |> ^\n \"#[1..]);\n@@ -746,6 +747,7 @@ mod test {\n \n         let expect_start = &r#\"\n  --> dummy.txt:1:6\n+  |>\n 1 |> _____aaaaaa____bbbbbb__cccccdd_\n   |>      ^^^^^^    ^^^^^^  ^^^^^^^\n \"#[1..];\n@@ -818,6 +820,7 @@ mod test {\n \n         let expect0 = &r#\"\n    --> dummy.txt:5:1\n+    |>\n 5   |> ccccc\n     |> ^\n ...\n@@ -830,6 +833,7 @@ mod test {\n \n         let expect = &r#\"\n    --> dummy.txt:1:1\n+    |>\n 1   |> aaaaa\n     |> ^\n ..."}, {"sha": "2a43a14ddf873bebdb6fa53da50e57dc78502b77", "filename": "src/libsyntax/errors/snippet/mod.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Fmod.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -478,6 +478,13 @@ impl FileInfo {\n                         }],\n                         kind: RenderedLineKind::PrimaryFileName,\n                     });\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: \"\".to_string(),\n+                            style: Style::FileNameStyle,\n+                        }],\n+                        kind: RenderedLineKind::Annotations,\n+                    });\n                 }\n                 None => {\n                     output.push(RenderedLine {\n@@ -487,6 +494,13 @@ impl FileInfo {\n                         }],\n                         kind: RenderedLineKind::OtherFileName,\n                     });\n+                    output.push(RenderedLine {\n+                        text: vec![StyledString {\n+                            text: \"\".to_string(),\n+                            style: Style::FileNameStyle,\n+                        }],\n+                        kind: RenderedLineKind::Annotations,\n+                    });\n                 }\n             }\n         }"}, {"sha": "51fe4572dbc633818459549e6add6167e8b656c4", "filename": "src/libsyntax/errors/snippet/test.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fsnippet%2Ftest.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -98,6 +98,7 @@ fn foo() {\n     let text = make_string(&lines);\n     assert_eq!(&text[..], &\"\n  --> foo.rs:3:2\n+  |>\n 3 |> \\tbar;\n   |> \\t^^^\n \"[1..]);\n@@ -130,6 +131,7 @@ fn foo() {\n     println!(\"text=\\n{}\", text);\n     assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n+  |>\n 3 |>     vec.push(vec.pop().unwrap());\n   |>     ---      ---                - previous borrow ends here\n   |>     |        |\n@@ -199,12 +201,14 @@ fn bar() {\n     // Note that the `|>` remain aligned across both files:\n     assert_eq!(&text[..], &r#\"\n    --> foo.rs:3:14\n+    |>\n 3   |>     vec.push(vec.pop().unwrap());\n     |>     ---      ^^^                - c\n     |>     |        |\n     |>     |        b\n     |>     a\n    ::: bar.rs\n+    |>\n 17  |>     vec.push();\n     |>     ---       - f\n     |>     |\n@@ -249,6 +253,7 @@ fn foo() {\n     println!(\"text=\\n{}\", text);\n     assert_eq!(&text[..], &r#\"\n    ::: foo.rs\n+    |>\n 3   |>     let name = find_id(&data, 22).unwrap();\n     |>                         ---- immutable borrow begins here\n ...\n@@ -288,6 +293,7 @@ fn foo() {\n     println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n     assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n+  |>\n 3 |>     vec.push(vec.pop().unwrap());\n   |>     --------           ------ D\n   |>     ||\n@@ -324,6 +330,7 @@ fn foo() {\n     println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n     assert_eq!(&text[..], &r#\"\n  ::: foo.rs\n+  |>\n 3 |>     vec.push(vec.pop().unwrap());\n   |>     ---      ---                - previous borrow ends here\n   |>     |        |\n@@ -362,6 +369,7 @@ fn foo() {\n     println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n     assert_eq!(&text[..], &r#\"\n    ::: foo.rs\n+    |>\n 4   |>     let mut vec2 = vec;\n     |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n ...\n@@ -398,6 +406,7 @@ fn foo() {\n     println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n     assert_eq!(text, &r#\"\n  ::: foo.rs\n+  |>\n 3 |>     let mut vec = vec![0, 1, 2];\n   |>             ---   ---\n 4 |>     let mut vec2 = vec;\n@@ -429,6 +438,7 @@ impl SomeTrait for () {\n     println!(\"r#\\\"\\n{}\\\"\", text);\n     assert_eq!(text, &r#\"\n  ::: foo.rs\n+  |>\n 3 |>     fn foo(x: u32) {\n   |>     -\n \"#[1..]);\n@@ -458,6 +468,7 @@ fn span_overlap_label() {\n     println!(\"r#\\\"\\n{}\\\"\", text);\n     assert_eq!(text, &r#\"\n  ::: foo.rs\n+  |>\n 2 |>     fn foo(x: u32) {\n   |>     --------------\n   |>     |      |\n@@ -492,6 +503,7 @@ fn span_overlap_label2() {\n     println!(\"r#\\\"\\n{}\\\"\", text);\n     assert_eq!(text, &r#\"\n  ::: foo.rs\n+  |>\n 2 |>     fn foo(x: u32) {\n   |>     --------------\n   |>     |      |\n@@ -537,6 +549,7 @@ fn span_overlap_label3() {\n     println!(\"r#\\\"\\n{}\\\"\", text);\n     assert_eq!(text, &r#\"\n  ::: foo.rs\n+  |>\n 3 |>        let closure = || {\n   |>                      - foo\n 4 |>            inner\n@@ -577,6 +590,7 @@ fn main() {\n     println!(\"r#\\\"\\n{}\\\"\", text);\n     assert_eq!(text, &r#\"\n   --> foo.rs:11:2\n+   |>\n 11 |> }\n    |>  -\n \"#[1..]);"}, {"sha": "a1d8e056b0257d3a1a0fc80c9694e196b77e487a", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -233,12 +233,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                     visitor.visit_path(path, item.id);\n                 }\n                 ViewPathList(ref prefix, ref list) => {\n-                    if !list.is_empty() {\n-                        for item in list {\n-                            visitor.visit_path_list_item(prefix, item)\n-                        }\n-                    } else {\n-                        visitor.visit_path(prefix, item.id);\n+                    visitor.visit_path(prefix, item.id);\n+                    for item in list {\n+                        visitor.visit_path_list_item(prefix, item)\n                     }\n                 }\n             }\n@@ -368,12 +365,8 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     }\n }\n \n-pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, prefix: &'v Path,\n+pub fn walk_path_list_item<'v, V: Visitor<'v>>(visitor: &mut V, _prefix: &'v Path,\n                                                item: &'v PathListItem) {\n-    for segment in &prefix.segments {\n-        visitor.visit_path_segment(prefix.span, segment);\n-    }\n-\n     walk_opt_ident(visitor, item.span, item.node.name());\n     walk_opt_ident(visitor, item.span, item.node.rename());\n }"}, {"sha": "f86d7ec114b938132fd532a8bc61a08b538b7872", "filename": "src/test/compile-fail/E0055.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2FE0055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2FE0055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0055.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -19,5 +19,4 @@ fn main() {\n     let foo = Foo;\n     let ref_foo = &&Foo;\n     ref_foo.foo(); //~ ERROR E0055\n-                   //~^ ERROR E0275\n }"}, {"sha": "764d05be879b8be674f3e9c3adba83e924c051a8", "filename": "src/test/compile-fail/borrowck/borrowck-borrow-overloaded-auto-deref-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-borrow-overloaded-auto-deref-mut.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -99,7 +99,7 @@ fn assign_field1<'a>(x: Own<Point>) {\n }\n \n fn assign_field2<'a>(x: &'a Own<Point>) {\n-    x.y = 3; //~ ERROR cannot assign\n+    x.y = 3; //~ ERROR cannot borrow\n }\n \n fn assign_field3<'a>(x: &'a mut Own<Point>) {"}, {"sha": "52f5f1cd079ebe52fddc17ffe5664f0841719859", "filename": "src/test/compile-fail/issue-24819.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24819.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::collections::HashSet;\n+\n+fn main() {\n+    let mut v = Vec::new();\n+    foo(&mut v);\n+    //~^ ERROR mismatched types\n+    //~| expected struct `std::collections::HashSet`, found struct `std::vec::Vec`\n+}\n+\n+fn foo(h: &mut HashSet<u32>) {\n+}"}, {"sha": "9c9677c1e98638d996bf7fc4ee3e9eda1538725e", "filename": "src/test/compile-fail/issue-33819.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-33819.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn main() {\n+    let mut op = Some(2);\n+    match op {\n+        Some(ref v) => { let a = &mut v; },\n+        //~^ ERROR:cannot borrow immutable\n+        //~| use `ref mut v` here to make mutable\n+        None => {},\n+    }\n+}"}, {"sha": "6e60a373d9b0cecb02fb8bebea804d577a72bac5", "filename": "src/test/compile-fail/regions-bound-missing-bound-in-impl.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bound-missing-bound-in-impl.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -34,7 +34,8 @@ impl<'a, 't> Foo<'a, 't> for &'a isize {\n     }\n \n     fn wrong_bound1<'b,'c,'d:'a+'c>(self, b: Inv<'b>, c: Inv<'c>, d: Inv<'d>) {\n-        //~^ ERROR method `wrong_bound1` has an incompatible type for trait\n+        //~^ ERROR method not compatible with trait\n+        //~^^ ERROR method not compatible with trait\n         //\n         // Note: This is a terrible error message. It is caused\n         // because, in the trait, 'b is early bound, and in the impl,"}, {"sha": "9cd08656b62c5a71afcdb1cf286f8feb5330ec65", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -23,7 +23,7 @@ impl<'a> get_ctxt for has_ctxt<'a> {\n \n     // Here an error occurs because we used `&self` but\n     // the definition used `&`:\n-    fn get_ctxt(&self) -> &'a ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n+    fn get_ctxt(&self) -> &'a ctxt { //~ ERROR method not compatible with trait\n         self.c\n     }\n "}, {"sha": "da8769e616c3f0ae545554aebb55edcc0eb6e964", "filename": "src/test/run-make/unicode-input/span_length.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Funicode-input%2Fspan_length.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rand, core)]\n+#![feature(rand)]\n \n use std::fs::File;\n use std::io::prelude::*;\n@@ -18,6 +18,11 @@ use std::process::Command;\n use std::__rand::{thread_rng, Rng};\n use std::{char, env};\n \n+pub fn check_old_skool() -> bool {\n+    use std::env;\n+    env::var(\"RUST_NEW_ERROR_FORMAT\").is_err()\n+}\n+\n // creates a file with `fn main() { <random ident> }` and checks the\n // compiler emits a span of the appropriate length (for the\n // \"unresolved name\" message); currently just using the number of code\n@@ -65,10 +70,17 @@ fn main() {\n \n         let err = String::from_utf8_lossy(&result.stderr);\n \n-        // the span should end the line (e.g no extra ~'s)\n-        let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n-                                                        .collect::<String>());\n-        assert!(err.contains(&expected_span));\n+        if check_old_skool() {\n+            // the span should end the line (e.g no extra ~'s)\n+            let expected_span = format!(\"^{}\\n\", repeat(\"~\").take(n - 1)\n+                                                            .collect::<String>());\n+            assert!(err.contains(&expected_span));\n+        } else {\n+            // the span should end the line (e.g no extra ~'s)\n+            let expected_span = format!(\"^{}\\n\", repeat(\"^\").take(n - 1)\n+                                                            .collect::<String>());\n+            assert!(err.contains(&expected_span));\n+        }\n     }\n \n     // Test multi-column characters and tabs\n@@ -77,9 +89,6 @@ fn main() {\n                        r#\"extern \"\uf937\uf922\uf92ba\u0301\u0301\u0301\" fn foo() {{}} extern \"\uf937\uf922\uf92ba\u0301\u0301\" fn bar() {{}}\"#);\n     }\n \n-    // Extra characters. Every line is preceded by `filename:lineno <actual code>`\n-    let offset = main_file.to_str().unwrap().len() + 3;\n-\n     let result = Command::new(\"sh\")\n                          .arg(\"-c\")\n                          .arg(format!(\"{} {}\",\n@@ -91,17 +100,31 @@ fn main() {\n \n     // Test both the length of the snake and the leading spaces up to it\n \n-    // First snake is 8 ~s long, with 7 preceding spaces (excluding file name/line offset)\n-    let expected_span = format!(\"\\n{}^{}\\n\",\n-                                repeat(\" \").take(offset + 7).collect::<String>(),\n-                                repeat(\"~\").take(8).collect::<String>());\n-    assert!(err.contains(&expected_span));\n-    // Second snake is only 7 ~s long, with 36 preceding spaces,\n-    // because rustc counts chars() now rather than width(). This\n-    // is because width() functions are to be removed from\n-    // librustc_unicode\n-    let expected_span = format!(\"\\n{}^{}\\n\",\n-                                repeat(\" \").take(offset + 36).collect::<String>(),\n-                                repeat(\"~\").take(7).collect::<String>());\n-    assert!(err.contains(&expected_span));\n+    if check_old_skool() {\n+        // Extra characters. Every line is preceded by `filename:lineno <actual code>`\n+        let offset = main_file.to_str().unwrap().len() + 3;\n+\n+        // First snake is 8 ~s long, with 7 preceding spaces (excluding file name/line offset)\n+        let expected_span = format!(\"\\n{}^{}\\n\",\n+                                    repeat(\" \").take(offset + 7).collect::<String>(),\n+                                    repeat(\"~\").take(8).collect::<String>());\n+        assert!(err.contains(&expected_span));\n+        // Second snake is only 7 ~s long, with 36 preceding spaces,\n+        // because rustc counts chars() now rather than width(). This\n+        // is because width() functions are to be removed from\n+        // librustc_unicode\n+        let expected_span = format!(\"\\n{}^{}\\n\",\n+                                    repeat(\" \").take(offset + 36).collect::<String>(),\n+                                    repeat(\"~\").take(7).collect::<String>());\n+        assert!(err.contains(&expected_span));\n+    } else {\n+        let expected_span = format!(\"\\n  |>{}{}\\n\",\n+                                    repeat(\" \").take(8).collect::<String>(),\n+                                    repeat(\"^\").take(9).collect::<String>());\n+        assert!(err.contains(&expected_span));\n+        let expected_span = format!(\"\\n  |>{}{}\\n\",\n+                                    repeat(\" \").take(37).collect::<String>(),\n+                                    repeat(\"^\").take(8).collect::<String>());\n+        assert!(err.contains(&expected_span));\n+    }\n }"}, {"sha": "96db31f4b116fb87bd823ca9b6eb9b1a3c80192e", "filename": "src/test/ui/mismatched_types/issue-26480.rs", "status": "renamed", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.rs?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// rustc-env:RUST_NEW_ERROR_FORMAT\n extern {\n     fn write(fildes: i32, buf: *const i8, nbyte: u64) -> i64;\n }\n@@ -24,25 +25,16 @@ macro_rules! write {\n         unsafe {\n             write(stdout, $arr.as_ptr() as *const i8,\n                   $arr.len() * size_of($arr[0]));\n-            //~^ ERROR mismatched types\n-            //~| expected u64, found usize\n-            //~| expected type\n-            //~| found type\n         }\n     }}\n }\n \n macro_rules! cast {\n-    ($x:expr) => ($x as ()) //~ ERROR non-scalar cast\n+    ($x:expr) => ($x as ())\n }\n \n fn main() {\n     let hello = ['H', 'e', 'y'];\n     write!(hello);\n-    //~^ NOTE in this expansion of write!\n-    //~| NOTE in this expansion of write!\n-    //~| NOTE in this expansion of write!\n-\n     cast!(2);\n-    //~^ NOTE in this expansion of cast!\n }", "previous_filename": "src/test/compile-fail/issue-26480.rs"}, {"sha": "c00594a59c1150fc6f8dde664fcf3b440a736c4b", "filename": "src/test/ui/mismatched_types/issue-26480.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fissue-26480.stderr?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -0,0 +1,15 @@\n+error: mismatched types [--explain E0308]\n+  --> $DIR/issue-26480.rs:27:19\n+   |>\n+27 |>                   $arr.len() * size_of($arr[0]));\n+   |>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected u64, found usize\n+$DIR/issue-26480.rs:38:5: 38:19: note: in this expansion of write! (defined in $DIR/issue-26480.rs)\n+\n+error: non-scalar cast: `_` as `()`\n+  --> $DIR/issue-26480.rs:33:19\n+   |>\n+33 |>     ($x:expr) => ($x as ())\n+   |>                   ^^^^^^^^\n+$DIR/issue-26480.rs:39:5: 39:14: note: in this expansion of cast! (defined in $DIR/issue-26480.rs)\n+\n+error: aborting due to 2 previous errors"}, {"sha": "1af332ee5bea7036b7f216bb554b6c3420a4f67e", "filename": "src/test/ui/mismatched_types/main.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f1776fe244d8603006536dceb7a21967e1c21f9c/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fmain.stderr?ref=f1776fe244d8603006536dceb7a21967e1c21f9c", "patch": "@@ -1,5 +1,6 @@\n error: mismatched types [--explain E0308]\n   --> $DIR/main.rs:14:18\n+   |>\n 14 |>     let x: u32 = (\n    |>                  ^ expected u32, found ()\n note: expected type `u32`"}]}