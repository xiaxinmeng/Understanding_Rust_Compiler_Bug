{"sha": "d4f20eb7e32bad9049663d30cfcb0e246ef2e031", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0ZjIwZWI3ZTMyYmFkOTA0OTY2M2QzMGNmY2IwZTI0NmVmMmUwMzE=", "commit": {"author": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2017-05-14T16:57:59Z"}, "committer": {"name": "Oliver Middleton", "email": "olliemail27@gmail.com", "date": "2017-05-14T17:06:35Z"}, "message": "linkchecker: Add support for <base> tag\n\nAdd support for the HTML <base> tag as used by mdBook so The Unstable\nBook can be checked.\n\nAlso cleanup a few things:\n* Stop checking the name attribute. It should never have been used and\nmdBook has since been fixed not to use it.\n* Make sure we only check html files.\n* Remove a few unnecessary allocations.\n\nFinally, dead links in The Unstable Book have been fixed.", "tree": {"sha": "adfd3fa354243633be8759e144c5fee8e3d63486", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adfd3fa354243633be8759e144c5fee8e3d63486"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d4f20eb7e32bad9049663d30cfcb0e246ef2e031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d4f20eb7e32bad9049663d30cfcb0e246ef2e031", "html_url": "https://github.com/rust-lang/rust/commit/d4f20eb7e32bad9049663d30cfcb0e246ef2e031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d4f20eb7e32bad9049663d30cfcb0e246ef2e031/comments", "author": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ollie27", "id": 7189418, "node_id": "MDQ6VXNlcjcxODk0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/7189418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ollie27", "html_url": "https://github.com/ollie27", "followers_url": "https://api.github.com/users/ollie27/followers", "following_url": "https://api.github.com/users/ollie27/following{/other_user}", "gists_url": "https://api.github.com/users/ollie27/gists{/gist_id}", "starred_url": "https://api.github.com/users/ollie27/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ollie27/subscriptions", "organizations_url": "https://api.github.com/users/ollie27/orgs", "repos_url": "https://api.github.com/users/ollie27/repos", "events_url": "https://api.github.com/users/ollie27/events{/privacy}", "received_events_url": "https://api.github.com/users/ollie27/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21ca9cab7d3a91379005546ac6b0e8c4118e0f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/21ca9cab7d3a91379005546ac6b0e8c4118e0f34", "html_url": "https://github.com/rust-lang/rust/commit/21ca9cab7d3a91379005546ac6b0e8c4118e0f34"}], "stats": {"total": 89, "additions": 33, "deletions": 56}, "files": [{"sha": "1b55dc792c2e5d1ec77182504fc4454acb151ca2", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 33, "deletions": 56, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d4f20eb7e32bad9049663d30cfcb0e246ef2e031/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d4f20eb7e32bad9049663d30cfcb0e246ef2e031/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=d4f20eb7e32bad9049663d30cfcb0e246ef2e031", "patch": "@@ -41,7 +41,7 @@ macro_rules! t {\n }\n \n fn main() {\n-    let docs = env::args().nth(1).unwrap();\n+    let docs = env::args_os().nth(1).unwrap();\n     let docs = env::current_dir().unwrap().join(docs);\n     let mut errors = false;\n     walk(&mut HashMap::new(), &docs, &docs, &mut errors);\n@@ -65,15 +65,14 @@ enum Redirect {\n struct FileEntry {\n     source: String,\n     ids: HashSet<String>,\n-    names: HashSet<String>,\n }\n \n type Cache = HashMap<PathBuf, FileEntry>;\n \n impl FileEntry {\n     fn parse_ids(&mut self, file: &Path, contents: &str, errors: &mut bool) {\n         if self.ids.is_empty() {\n-            with_attrs_in_source(contents, \" id\", |fragment, i| {\n+            with_attrs_in_source(contents, \" id\", |fragment, i, _| {\n                 let frag = fragment.trim_left_matches(\"#\").to_owned();\n                 if !self.ids.insert(frag) {\n                     *errors = true;\n@@ -82,15 +81,6 @@ impl FileEntry {\n             });\n         }\n     }\n-\n-    fn parse_names(&mut self, contents: &str) {\n-        if self.names.is_empty() {\n-            with_attrs_in_source(contents, \" name\", |fragment, _| {\n-                let frag = fragment.trim_left_matches(\"#\").to_owned();\n-                self.names.insert(frag);\n-            });\n-        }\n-    }\n }\n \n fn walk(cache: &mut Cache, root: &Path, dir: &Path, errors: &mut bool) {\n@@ -116,15 +106,8 @@ fn check(cache: &mut Cache,\n          file: &Path,\n          errors: &mut bool)\n          -> Option<PathBuf> {\n-    // ignore js files as they are not prone to errors as the rest of the\n-    // documentation is and they otherwise bring up false positives.\n-    if file.extension().and_then(|s| s.to_str()) == Some(\"js\") {\n-        return None;\n-    }\n-\n-    // ignore handlebars files as they use {{}} to build links, we only\n-    // want to test the generated files\n-    if file.extension().and_then(|s| s.to_str()) == Some(\"hbs\") {\n+    // Ignore none HTML files.\n+    if file.extension().and_then(|s| s.to_str()) != Some(\"html\") {\n         return None;\n     }\n \n@@ -147,13 +130,7 @@ fn check(cache: &mut Cache,\n         return None;\n     }\n \n-    // mdbook uses the HTML <base> tag to handle links for subdirectories, which\n-    // linkchecker doesn't support\n-    if file.to_str().unwrap().contains(\"unstable-book\") {\n-        return None;\n-    }\n-\n-    let res = load_file(cache, root, PathBuf::from(file), SkipRedirect);\n+    let res = load_file(cache, root, file, SkipRedirect);\n     let (pretty_file, contents) = match res {\n         Ok(res) => res,\n         Err(_) => return None,\n@@ -162,13 +139,10 @@ fn check(cache: &mut Cache,\n         cache.get_mut(&pretty_file)\n              .unwrap()\n              .parse_ids(&pretty_file, &contents, errors);\n-        cache.get_mut(&pretty_file)\n-             .unwrap()\n-             .parse_names(&contents);\n     }\n \n     // Search for anything that's the regex 'href[ ]*=[ ]*\".*?\"'\n-    with_attrs_in_source(&contents, \" href\", |url, i| {\n+    with_attrs_in_source(&contents, \" href\", |url, i, base| {\n         // Ignore external URLs\n         if url.starts_with(\"http:\") || url.starts_with(\"https:\") ||\n            url.starts_with(\"javascript:\") || url.starts_with(\"ftp:\") ||\n@@ -184,9 +158,9 @@ fn check(cache: &mut Cache,\n         // Once we've plucked out the URL, parse it using our base url and\n         // then try to extract a file path.\n         let mut path = file.to_path_buf();\n-        if !url.is_empty() {\n+        if !base.is_empty() || !url.is_empty() {\n             path.pop();\n-            for part in Path::new(url).components() {\n+            for part in Path::new(base).join(url).components() {\n                 match part {\n                     Component::Prefix(_) |\n                     Component::RootDir => panic!(),\n@@ -197,13 +171,6 @@ fn check(cache: &mut Cache,\n             }\n         }\n \n-        if let Some(extension) = path.extension() {\n-            // don't check these files\n-            if extension == \"png\" {\n-                return;\n-            }\n-        }\n-\n         // Alright, if we've found a file name then this file had better\n         // exist! If it doesn't then we register and print an error.\n         if path.exists() {\n@@ -218,11 +185,17 @@ fn check(cache: &mut Cache,\n                          pretty_path.display());\n                 return;\n             }\n-            let res = load_file(cache, root, path.clone(), FromRedirect(false));\n+            if let Some(extension) = path.extension() {\n+                // Ignore none HTML files.\n+                if extension != \"html\" {\n+                    return;\n+                }\n+            }\n+            let res = load_file(cache, root, &path, FromRedirect(false));\n             let (pretty_path, contents) = match res {\n                 Ok(res) => res,\n                 Err(LoadError::IOError(err)) => {\n-                    panic!(format!(\"error loading {}: {}\", path.display(), err));\n+                    panic!(\"error loading {}: {}\", path.display(), err);\n                 }\n                 Err(LoadError::BrokenRedirect(target, _)) => {\n                     *errors = true;\n@@ -245,11 +218,10 @@ fn check(cache: &mut Cache,\n \n                 let entry = &mut cache.get_mut(&pretty_path).unwrap();\n                 entry.parse_ids(&pretty_path, &contents, errors);\n-                entry.parse_names(&contents);\n \n-                if !(entry.ids.contains(*fragment) || entry.names.contains(*fragment)) {\n+                if !entry.ids.contains(*fragment) {\n                     *errors = true;\n-                    print!(\"{}:{}: broken link fragment  \",\n+                    print!(\"{}:{}: broken link fragment \",\n                            pretty_file.display(),\n                            i + 1);\n                     println!(\"`#{}` pointing to `{}`\", fragment, pretty_path.display());\n@@ -267,7 +239,7 @@ fn check(cache: &mut Cache,\n \n fn load_file(cache: &mut Cache,\n              root: &Path,\n-             mut file: PathBuf,\n+             file: &Path,\n              redirect: Redirect)\n              -> Result<(PathBuf, String), LoadError> {\n     let mut contents = String::new();\n@@ -279,9 +251,9 @@ fn load_file(cache: &mut Cache,\n             None\n         }\n         Entry::Vacant(entry) => {\n-            let mut fp = File::open(file.clone()).map_err(|err| {\n+            let mut fp = File::open(file).map_err(|err| {\n                 if let FromRedirect(true) = redirect {\n-                    LoadError::BrokenRedirect(file.clone(), err)\n+                    LoadError::BrokenRedirect(file.to_path_buf(), err)\n                 } else {\n                     LoadError::IOError(err)\n                 }\n@@ -297,17 +269,14 @@ fn load_file(cache: &mut Cache,\n                 entry.insert(FileEntry {\n                     source: contents.clone(),\n                     ids: HashSet::new(),\n-                    names: HashSet::new(),\n                 });\n             }\n             maybe\n         }\n     };\n-    file.pop();\n-    match maybe_redirect.map(|url| file.join(url)) {\n+    match maybe_redirect.map(|url| file.parent().unwrap().join(url)) {\n         Some(redirect_file) => {\n-            let path = PathBuf::from(redirect_file);\n-            load_file(cache, root, path, FromRedirect(true))\n+            load_file(cache, root, &redirect_file, FromRedirect(true))\n         }\n         None => Ok((pretty_file, contents)),\n     }\n@@ -329,10 +298,14 @@ fn maybe_redirect(source: &str) -> Option<String> {\n     })\n }\n \n-fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f: F) {\n+fn with_attrs_in_source<F: FnMut(&str, usize, &str)>(contents: &str, attr: &str, mut f: F) {\n+    let mut base = \"\";\n     for (i, mut line) in contents.lines().enumerate() {\n         while let Some(j) = line.find(attr) {\n             let rest = &line[j + attr.len()..];\n+            // The base tag should always be the first link in the document so\n+            // we can get away with using one pass.\n+            let is_base = line[..j].ends_with(\"<base\");\n             line = rest;\n             let pos_equals = match rest.find(\"=\") {\n                 Some(i) => i,\n@@ -358,7 +331,11 @@ fn with_attrs_in_source<F: FnMut(&str, usize)>(contents: &str, attr: &str, mut f\n                 Some(i) => &rest[..i],\n                 None => continue,\n             };\n-            f(url, i)\n+            if is_base {\n+                base = url;\n+                continue;\n+            }\n+            f(url, i, base)\n         }\n     }\n }"}]}