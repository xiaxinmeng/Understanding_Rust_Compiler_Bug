{"sha": "af622a491a18c27764199608f927a408af2f317c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNjIyYTQ5MWExOGMyNzc2NDE5OTYwOGY5MjdhNDA4YWYyZjMxN2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T08:56:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-18T08:56:43Z"}, "message": "auto merge of #14994 : nick29581/rust/comments, r=bstrie\n\nPlus a few other misc style things.", "tree": {"sha": "6d18e7779ab2a74cfe50d8e9705db9cb85c68be0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d18e7779ab2a74cfe50d8e9705db9cb85c68be0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af622a491a18c27764199608f927a408af2f317c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af622a491a18c27764199608f927a408af2f317c", "html_url": "https://github.com/rust-lang/rust/commit/af622a491a18c27764199608f927a408af2f317c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af622a491a18c27764199608f927a408af2f317c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "410d70b5af30a4e5d566b981c9bf1b10b12b796b", "url": "https://api.github.com/repos/rust-lang/rust/commits/410d70b5af30a4e5d566b981c9bf1b10b12b796b", "html_url": "https://github.com/rust-lang/rust/commit/410d70b5af30a4e5d566b981c9bf1b10b12b796b"}, {"sha": "f2dd4f3c065193e869d6feeb15d95d6495e7bd50", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2dd4f3c065193e869d6feeb15d95d6495e7bd50", "html_url": "https://github.com/rust-lang/rust/commit/f2dd4f3c065193e869d6feeb15d95d6495e7bd50"}], "stats": {"total": 685, "additions": 400, "deletions": 285}, "files": [{"sha": "11166f92b1cc2629229b0d7e3f8b2f2bf770649d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 400, "deletions": 285, "changes": 685, "blob_url": "https://github.com/rust-lang/rust/blob/af622a491a18c27764199608f927a408af2f317c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af622a491a18c27764199608f927a408af2f317c/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=af622a491a18c27764199608f927a408af2f317c", "patch": "@@ -12,45 +12,53 @@\n # Debug Info Module\n \n This module serves the purpose of generating debug symbols. We use LLVM's\n-[source level debugging](http://llvm.org/docs/SourceLevelDebugging.html) features for generating\n-the debug information. The general principle is this:\n-\n-Given the right metadata in the LLVM IR, the LLVM code generator is able to create DWARF debug\n-symbols for the given code. The [metadata](http://llvm.org/docs/LangRef.html#metadata-type) is\n-structured much like DWARF *debugging information entries* (DIE), representing type information\n-such as datatype layout, function signatures, block layout, variable location and scope information,\n-etc. It is the purpose of this module to generate correct metadata and insert it into the LLVM IR.\n-\n-As the exact format of metadata trees may change between different LLVM versions, we now use LLVM\n-[DIBuilder](http://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html) to create metadata\n-where possible. This will hopefully ease the adaption of this module to future LLVM versions.\n-\n-The public API of the module is a set of functions that will insert the correct metadata into the\n-LLVM IR when called with the right parameters. The module is thus driven from an outside client with\n-functions like `debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n-\n-Internally the module will try to reuse already created metadata by utilizing a cache. The way to\n-get a shared metadata node when needed is thus to just call the corresponding function in this\n-module:\n+[source level debugging](http://llvm.org/docs/SourceLevelDebugging.html)\n+features for generating the debug information. The general principle is this:\n+\n+Given the right metadata in the LLVM IR, the LLVM code generator is able to\n+create DWARF debug symbols for the given code. The\n+[metadata](http://llvm.org/docs/LangRef.html#metadata-type) is structured much\n+like DWARF *debugging information entries* (DIE), representing type information\n+such as datatype layout, function signatures, block layout, variable location\n+and scope information, etc. It is the purpose of this module to generate correct\n+metadata and insert it into the LLVM IR.\n+\n+As the exact format of metadata trees may change between different LLVM\n+versions, we now use LLVM\n+[DIBuilder](http://llvm.org/docs/doxygen/html/classllvm_1_1DIBuilder.html) to\n+create metadata where possible. This will hopefully ease the adaption of this\n+module to future LLVM versions.\n+\n+The public API of the module is a set of functions that will insert the correct\n+metadata into the LLVM IR when called with the right parameters. The module is\n+thus driven from an outside client with functions like\n+`debuginfo::create_local_var_metadata(bcx: block, local: &ast::local)`.\n+\n+Internally the module will try to reuse already created metadata by utilizing a\n+cache. The way to get a shared metadata node when needed is thus to just call\n+the corresponding function in this module:\n \n     let file_metadata = file_metadata(crate_context, path);\n \n-The function will take care of probing the cache for an existing node for that exact file path.\n+The function will take care of probing the cache for an existing node for that\n+exact file path.\n \n-All private state used by the module is stored within either the CrateDebugContext struct (owned by\n-the CrateContext) or the FunctionDebugContext (owned by the FunctionContext).\n+All private state used by the module is stored within either the\n+CrateDebugContext struct (owned by the CrateContext) or the FunctionDebugContext\n+(owned by the FunctionContext).\n \n This file consists of three conceptual sections:\n 1. The public interface of the module\n 2. Module-internal metadata creation functions\n 3. Minor utility functions\n \n \n-## Recursive Types\n-Some kinds of types, such as structs and enums can be recursive. That means that the type definition\n-of some type X refers to some other type which in turn (transitively) refers to X. This introduces\n-cycles into the type referral graph. A naive algorithm doing an on-demand, depth-first traversal of\n-this graph when describing types, can get trapped in an endless loop when it reaches such a cycle.\n+## Recursive Types Some kinds of types, such as structs and enums can be\n+recursive. That means that the type definition of some type X refers to some\n+other type which in turn (transitively) refers to X. This introduces cycles into\n+the type referral graph. A naive algorithm doing an on-demand, depth-first\n+traversal of this graph when describing types, can get trapped in an endless\n+loop when it reaches such a cycle.\n \n For example, the following simple type for a singly-linked list...\n \n@@ -72,86 +80,103 @@ describe(t = List)\n       ...\n ```\n \n-To break cycles like these, we use \"forward declarations\". That is, when the algorithm encounters a\n-possibly recursive type (any struct or enum), it immediately creates a type description node and\n-inserts it into the cache *before* describing the members of the type. This type description is just\n-a stub (as type members are not described and added to it yet) but it allows the algorithm to\n-already refer to the type. After the stub is inserted into the cache, the algorithm continues as\n-before. If it now encounters a recursive reference, it will hit the cache and does not try to\n-describe the type anew.\n+To break cycles like these, we use \"forward declarations\". That is, when the\n+algorithm encounters a possibly recursive type (any struct or enum), it\n+immediately creates a type description node and inserts it into the cache\n+*before* describing the members of the type. This type description is just a\n+stub (as type members are not described and added to it yet) but it allows the\n+algorithm to already refer to the type. After the stub is inserted into the\n+cache, the algorithm continues as before. If it now encounters a recursive\n+reference, it will hit the cache and does not try to describe the type anew.\n \n-This behaviour is encapsulated in the 'RecursiveTypeDescription' enum, which represents a kind of\n-continuation, storing all state needed to continue traversal at the type members after the type has\n-been registered with the cache. (This implementation approach might be a tad over-engineered and\n-may change in the future)\n+This behaviour is encapsulated in the 'RecursiveTypeDescription' enum, which\n+represents a kind of continuation, storing all state needed to continue\n+traversal at the type members after the type has been registered with the cache.\n+(This implementation approach might be a tad over-engineered and may change in\n+the future)\n \n \n-## Source Locations and Line Information\n-In addition to data type descriptions the debugging information must also allow to map machine code\n-locations back to source code locations in order to be useful. This functionality is also handled in\n-this module. The following functions allow to control source mappings:\n+## Source Locations and Line Information In addition to data type descriptions\n+the debugging information must also allow to map machine code locations back to\n+source code locations in order to be useful. This functionality is also handled\n+in this module. The following functions allow to control source mappings:\n \n + set_source_location()\n + clear_source_location()\n + start_emitting_source_locations()\n \n-`set_source_location()` allows to set the current source location. All IR instructions created after\n-a call to this function will be linked to the given source location, until another location is\n-specified with `set_source_location()` or the source location is cleared with\n-`clear_source_location()`. In the later case, subsequent IR instruction will not be linked to any\n-source location. As you can see, this is a stateful API (mimicking the one in LLVM), so be careful\n-with source locations set by previous calls. It's probably best to not rely on any specific state\n-being present at a given point in code.\n-\n-One topic that deserves some extra attention is *function prologues*. At the beginning of a\n-function's machine code there are typically a few instructions for loading argument values into\n-allocas and checking if there's enough stack space for the function to execute. This *prologue* is\n-not visible in the source code and LLVM puts a special PROLOGUE END marker into the line table at\n-the first non-prologue instruction of the function. In order to find out where the prologue ends,\n-LLVM looks for the first instruction in the function body that is linked to a source location. So,\n-when generating prologue instructions we have to make sure that we don't emit source location\n-information until the 'real' function body begins. For this reason, source location emission is\n-disabled by default for any new function being translated and is only activated after a call to the\n-third function from the list above, `start_emitting_source_locations()`. This function should be\n-called right before regularly starting to translate the top-level block of the given function.\n-\n-There is one exception to the above rule: `llvm.dbg.declare` instruction must be linked to the\n-source location of the variable being declared. For function parameters these `llvm.dbg.declare`\n-instructions typically occur in the middle of the prologue, however, they are ignored by LLVM's\n-prologue detection. The `create_argument_metadata()` and related functions take care of linking the\n-`llvm.dbg.declare` instructions to the correct source locations even while source location emission\n-is still disabled, so there is no need to do anything special with source location handling here.\n-\n-## Unique Type Identification\n-In order for link-time optimization to work properly, LLVM needs a unique type identifier that tells\n-it across compilation units which types are the same as others. This type identifier is created by\n+`set_source_location()` allows to set the current source location. All IR\n+instructions created after a call to this function will be linked to the given\n+source location, until another location is specified with\n+`set_source_location()` or the source location is cleared with\n+`clear_source_location()`. In the later case, subsequent IR instruction will not\n+be linked to any source location. As you can see, this is a stateful API\n+(mimicking the one in LLVM), so be careful with source locations set by previous\n+calls. It's probably best to not rely on any specific state being present at a\n+given point in code.\n+\n+One topic that deserves some extra attention is *function prologues*. At the\n+beginning of a function's machine code there are typically a few instructions\n+for loading argument values into allocas and checking if there's enough stack\n+space for the function to execute. This *prologue* is not visible in the source\n+code and LLVM puts a special PROLOGUE END marker into the line table at the\n+first non-prologue instruction of the function. In order to find out where the\n+prologue ends, LLVM looks for the first instruction in the function body that is\n+linked to a source location. So, when generating prologue instructions we have\n+to make sure that we don't emit source location information until the 'real'\n+function body begins. For this reason, source location emission is disabled by\n+default for any new function being translated and is only activated after a call\n+to the third function from the list above, `start_emitting_source_locations()`.\n+This function should be called right before regularly starting to translate the\n+top-level block of the given function.\n+\n+There is one exception to the above rule: `llvm.dbg.declare` instruction must be\n+linked to the source location of the variable being declared. For function\n+parameters these `llvm.dbg.declare` instructions typically occur in the middle\n+of the prologue, however, they are ignored by LLVM's prologue detection. The\n+`create_argument_metadata()` and related functions take care of linking the\n+`llvm.dbg.declare` instructions to the correct source locations even while\n+source location emission is still disabled, so there is no need to do anything\n+special with source location handling here.\n+\n+## Unique Type Identification In order for link-time optimization to work\n+properly, LLVM needs a unique type identifier that tells it across compilation\n+units which types are the same as others. This type identifier is created by\n TypeMap::get_unique_type_id_of_type() using the following algorithm:\n \n (1) Primitive types have their name as ID\n (2) Structs, enums and traits have a multipart identifier\n-    (1) The first part is the SVH (strict version hash) of the crate they were originally defined in\n-    (2) The second part is the ast::NodeId of the definition in their original crate\n-    (3) The final part is a concatenation of the type IDs of their concrete type arguments if they\n-        are generic types.\n-(3) Tuple-, pointer and function types are structurally identified, which means that they are\n-    equivalent if their component types are equivalent (i.e. (int, int) is the same regardless in\n-    which crate it is used).\n-\n-This algorithm also provides a stable ID for types that are defined in one crate but instantiated\n-from metadata within another crate. We just have to take care to always map crate and node IDs back\n-to the original crate context.\n-\n-As a side-effect these unique type IDs also help to solve a problem arising from lifetime\n-parameters. Since lifetime parameters are completely omitted in debuginfo, more than one `ty::t`\n-instance may map to the same debuginfo type metadata, that is, some struct `Struct<'a>` may have N\n-instantiations with different concrete substitutions for `'a`, and thus there will be N `ty::t`\n-instances for the type `Struct<'a>` even though it is not generic otherwise. Unfortunately this\n-means that we cannot use `ty::type_id()` as cheap identifier for type metadata---we have done this\n-in the past, but it led to unnecessary metadata duplication in the best case and LLVM assertions in\n-the worst. However, the unique type ID as described above *can* be used as identifier. Since it is\n-comparatively expensive to construct, though, `ty::type_id()` is still used additionally as an\n-optimization for cases where the exact same type has been seen before (which is most of the time).\n-*/\n+\n+    (1) The first part is the SVH (strict version hash) of the crate they were\n+        originally defined in\n+\n+    (2) The second part is the ast::NodeId of the definition in their original\n+        crate\n+\n+    (3) The final part is a concatenation of the type IDs of their concrete type\n+        arguments if they are generic types.\n+\n+(3) Tuple-, pointer and function types are structurally identified, which means\n+    that they are equivalent if their component types are equivalent (i.e. (int,\n+    int) is the same regardless in which crate it is used).\n+\n+This algorithm also provides a stable ID for types that are defined in one crate\n+but instantiated from metadata within another crate. We just have to take care\n+to always map crate and node IDs back to the original crate context.\n+\n+As a side-effect these unique type IDs also help to solve a problem arising from\n+lifetime parameters. Since lifetime parameters are completely omitted in\n+debuginfo, more than one `ty::t` instance may map to the same debuginfo type\n+metadata, that is, some struct `Struct<'a>` may have N instantiations with\n+different concrete substitutions for `'a`, and thus there will be N `ty::t`\n+instances for the type `Struct<'a>` even though it is not generic otherwise.\n+Unfortunately this means that we cannot use `ty::type_id()` as cheap identifier\n+for type metadata---we have done this in the past, but it led to unnecessary\n+metadata duplication in the best case and LLVM assertions in the worst. However,\n+the unique type ID as described above *can* be used as identifier. Since it is\n+comparatively expensive to construct, though, `ty::type_id()` is still used\n+additionally as an optimization for cases where the exact same type has been\n+seen before (which is most of the time). */\n \n use driver::config;\n use driver::config::{FullDebugInfo, LimitedDebugInfo, NoDebugInfo};\n@@ -197,16 +222,17 @@ static DW_ATE_signed: c_uint = 0x05;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n #[deriving(Copy, Show, Hash, Eq, PartialEq, Clone)]\n struct UniqueTypeId(ast::Name);\n \n-// The TypeMap is where the CrateDebugContext holds the type metadata nodes created so far. The\n-// metadata nodes are indexed by UniqueTypeId, and, for faster lookup, also by ty::t. The\n-// TypeMap is responsible for creating UniqueTypeIds.\n+// The TypeMap is where the CrateDebugContext holds the type metadata nodes\n+// created so far. The metadata nodes are indexed by UniqueTypeId, and, for\n+// faster lookup, also by ty::t. The TypeMap is responsible for creating\n+// UniqueTypeIds.\n struct TypeMap {\n     // The UniqueTypeIds created so far\n     unique_id_interner: Interner<Rc<String>>,\n@@ -229,8 +255,8 @@ impl TypeMap {\n         }\n     }\n \n-    // Adds a ty::t to metadata mapping to the TypeMap. The method will fail if the mapping already\n-    // exists.\n+    // Adds a ty::t to metadata mapping to the TypeMap. The method will fail if\n+    // the mapping already exists.\n     fn register_type_with_metadata(&mut self,\n                                    cx: &CrateContext,\n                                    type_: ty::t,\n@@ -241,8 +267,8 @@ impl TypeMap {\n         }\n     }\n \n-    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will fail if the mapping\n-    // already exists.\n+    // Adds a UniqueTypeId to metadata mapping to the TypeMap. The method will\n+    // fail if the mapping already exists.\n     fn register_unique_id_with_metadata(&mut self,\n                                         cx: &CrateContext,\n                                         unique_type_id: UniqueTypeId,\n@@ -262,15 +288,16 @@ impl TypeMap {\n         self.unique_id_to_metadata.find_copy(&unique_type_id)\n     }\n \n-    // Get the string representation of a UniqueTypeId. This method will fail if the id is unknown.\n+    // Get the string representation of a UniqueTypeId. This method will fail if\n+    // the id is unknown.\n     fn get_unique_type_id_as_string(&self, unique_type_id: UniqueTypeId) -> Rc<String> {\n         let UniqueTypeId(interner_key) = unique_type_id;\n         self.unique_id_interner.get(interner_key)\n     }\n \n-    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given type has been\n-    // requested before, this is just a table lookup. Otherwise an ID will be generated and stored\n-    // for later lookup.\n+    // Get the UniqueTypeId for the given type. If the UniqueTypeId for the given\n+    // type has been requested before, this is just a table lookup. Otherwise an\n+    // ID will be generated and stored for later lookup.\n     fn get_unique_type_id_of_type(&mut self, cx: &CrateContext, type_: ty::t) -> UniqueTypeId {\n \n         // basic type           -> {:name of the type:}\n@@ -324,8 +351,10 @@ impl TypeMap {\n             ty::ty_tup(ref component_types) => {\n                 unique_type_id.push_str(\"tuple \");\n                 for &component_type in component_types.iter() {\n-                    let component_type_id = self.get_unique_type_id_of_type(cx, component_type);\n-                    let component_type_id = self.get_unique_type_id_as_string(component_type_id);\n+                    let component_type_id =\n+                        self.get_unique_type_id_of_type(cx, component_type);\n+                    let component_type_id =\n+                        self.get_unique_type_id_as_string(component_type_id);\n                     unique_type_id.push_str(component_type_id.as_slice());\n                 }\n             },\n@@ -394,8 +423,10 @@ impl TypeMap {\n                 unique_type_id.push_str(\" fn(\");\n \n                 for &parameter_type in sig.inputs.iter() {\n-                    let parameter_type_id = self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id = self.get_unique_type_id_as_string(parameter_type_id);\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_of_type(cx, parameter_type);\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_as_string(parameter_type_id);\n                     unique_type_id.push_str(parameter_type_id.as_slice());\n                     unique_type_id.push_char(',');\n                 }\n@@ -424,13 +455,19 @@ impl TypeMap {\n \n                 match store {\n                     ty::UniqTraitStore => unique_type_id.push_str(\"~|\"),\n-                    ty::RegionTraitStore(_, ast::MutMutable) => unique_type_id.push_str(\"&mut|\"),\n-                    ty::RegionTraitStore(_, ast::MutImmutable) => unique_type_id.push_str(\"&|\"),\n+                    ty::RegionTraitStore(_, ast::MutMutable) => {\n+                        unique_type_id.push_str(\"&mut|\")\n+                    }\n+                    ty::RegionTraitStore(_, ast::MutImmutable) => {\n+                        unique_type_id.push_str(\"&|\")\n+                    }\n                 };\n \n                 for &parameter_type in sig.inputs.iter() {\n-                    let parameter_type_id = self.get_unique_type_id_of_type(cx, parameter_type);\n-                    let parameter_type_id = self.get_unique_type_id_as_string(parameter_type_id);\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_of_type(cx, parameter_type);\n+                    let parameter_type_id =\n+                        self.get_unique_type_id_as_string(parameter_type_id);\n                     unique_type_id.push_str(parameter_type_id.as_slice());\n                     unique_type_id.push_char(',');\n                 }\n@@ -482,13 +519,13 @@ impl TypeMap {\n                                   output: &mut String) {\n             use std::num::ToStrRadix;\n \n-            // First, find out the 'real' def_id of the type. Items inlined from other crates have\n-            // to be mapped back to their source.\n+            // First, find out the 'real' def_id of the type. Items inlined from\n+            // other crates have to be mapped back to their source.\n             let source_def_id = if def_id.krate == ast::LOCAL_CRATE {\n                 match cx.external_srcs.borrow().find_copy(&def_id.node) {\n                     Some(source_def_id) => {\n-                        // The given def_id identifies the inlined copy of a type definition,\n-                        // let's take the source of the copy\n+                        // The given def_id identifies the inlined copy of a\n+                        // type definition, let's take the source of the copy.\n                         source_def_id\n                     }\n                     None => def_id\n@@ -497,7 +534,7 @@ impl TypeMap {\n                 def_id\n             };\n \n-            // Get the crate hash as first part of the identifier\n+            // Get the crate hash as first part of the identifier.\n             let crate_hash = if source_def_id.krate == ast::LOCAL_CRATE {\n                 cx.link_meta.crate_hash.clone()\n             } else {\n@@ -508,15 +545,17 @@ impl TypeMap {\n             output.push_str(\"/\");\n             output.push_str(def_id.node.to_str_radix(16).as_slice());\n \n-            // Maybe check that there is no self type here\n+            // Maybe check that there is no self type here.\n \n             let tps = substs.types.get_vec(subst::TypeSpace);\n             if tps.len() > 0 {\n                 output.push_char('<');\n \n                 for &type_parameter in tps.iter() {\n-                    let param_type_id = type_map.get_unique_type_id_of_type(cx, type_parameter);\n-                    let param_type_id = type_map.get_unique_type_id_as_string(param_type_id);\n+                    let param_type_id =\n+                        type_map.get_unique_type_id_of_type(cx, type_parameter);\n+                    let param_type_id =\n+                        type_map.get_unique_type_id_as_string(param_type_id);\n                     output.push_str(param_type_id.as_slice());\n                     output.push_char(',');\n                 }\n@@ -526,9 +565,9 @@ impl TypeMap {\n         }\n     }\n \n-    // Get the UniqueTypeId for an enum variant. Enum variants are not really types of their own,\n-    // so they need special handling. We still need a UniqueTypeId for them, since to debuginfo they\n-    // *are* real types.\n+    // Get the UniqueTypeId for an enum variant. Enum variants are not really\n+    // types of their own, so they need special handling. We still need a\n+    // UniqueTypeId for them, since to debuginfo they *are* real types.\n     fn get_unique_type_id_of_enum_variant(&mut self,\n                                           cx: &CrateContext,\n                                           enum_type: ty::t,\n@@ -580,8 +619,8 @@ pub struct CrateDebugContext {\n     type_map: RefCell<TypeMap>,\n     namespace_map: RefCell<HashMap<Vec<ast::Name>, Rc<NamespaceTreeNode>>>,\n \n-    // This collection is used to assert that composite types (structs, enums, ...) have their\n-    // members only set once:\n+    // This collection is used to assert that composite types (structs, enums,\n+    // ...) have their members only set once:\n     composite_types_completed: RefCell<HashSet<DIType>>,\n }\n \n@@ -615,14 +654,19 @@ enum FunctionDebugContextRepr {\n }\n \n impl FunctionDebugContext {\n-    fn get_ref<'a>(&'a self, cx: &CrateContext, span: Span) -> &'a FunctionDebugContextData {\n+    fn get_ref<'a>(&'a self,\n+                   cx: &CrateContext,\n+                   span: Span)\n+                   -> &'a FunctionDebugContextData {\n         match self.repr {\n             FunctionDebugContext(box ref data) => data,\n             DebugInfoDisabled => {\n-                cx.sess().span_bug(span, FunctionDebugContext::debuginfo_disabled_message());\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::debuginfo_disabled_message());\n             }\n             FunctionWithoutDebugInfo => {\n-                cx.sess().span_bug(span, FunctionDebugContext::should_be_ignored_message());\n+                cx.sess().span_bug(span,\n+                                   FunctionDebugContext::should_be_ignored_message());\n             }\n         }\n     }\n@@ -647,8 +691,8 @@ struct FunctionDebugContextData {\n enum VariableAccess<'a> {\n     // The llptr given is an alloca containing the variable's value\n     DirectVariable { alloca: ValueRef },\n-    // The llptr given is an alloca containing the start of some pointer chain leading to the\n-    // variable's content.\n+    // The llptr given is an alloca containing the start of some pointer chain\n+    // leading to the variable's content.\n     IndirectVariable { alloca: ValueRef, address_operations: &'a [ValueRef] }\n }\n \n@@ -703,9 +747,10 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         return;\n     }\n \n-    // Don't create debuginfo for globals inlined from other crates. The other crate should already\n-    // contain debuginfo for it. More importantly, the global might not even exist in un-inlined\n-    // form anywhere which would lead to a linker errors.\n+    // Don't create debuginfo for globals inlined from other crates. The other\n+    // crate should already contain debuginfo for it. More importantly, the\n+    // global might not even exist in un-inlined form anywhere which would lead\n+    // to a linker errors.\n     if cx.external_srcs.borrow().contains_key(&node_id) {\n         return;\n     }\n@@ -853,7 +898,9 @@ pub fn create_captured_var_metadata(bcx: &Block,\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, span).fn_metadata;\n \n     let llvm_env_data_type = type_of::type_of(cx, env_data_type);\n-    let byte_offset_of_var_in_env = machine::llelement_offset(cx, llvm_env_data_type, env_index);\n+    let byte_offset_of_var_in_env = machine::llelement_offset(cx,\n+                                                              llvm_env_data_type,\n+                                                              env_index);\n \n     let address_operations = unsafe {\n         [llvm::LLVMDIBuilderCreateOpDeref(Type::i64(cx).to_ref()),\n@@ -885,7 +932,8 @@ pub fn create_captured_var_metadata(bcx: &Block,\n                   span);\n }\n \n-/// Creates debug information for a local variable introduced in the head of a match-statement arm.\n+/// Creates debug information for a local variable introduced in the head of a\n+/// match-statement arm.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n pub fn create_match_binding_metadata(bcx: &Block,\n@@ -958,8 +1006,9 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n \n /// Sets the current debug location at the beginning of the span.\n ///\n-/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id parameter is used to\n-/// reliably find the correct visibility scope for the code position.\n+/// Maps to a call to llvm::LLVMSetCurrentDebugLocation(...). The node_id\n+/// parameter is used to reliably find the correct visibility scope for the code\n+/// position.\n pub fn set_source_location(fcx: &FunctionContext,\n                            node_id: ast::NodeId,\n                            span: Span) {\n@@ -978,7 +1027,9 @@ pub fn set_source_location(fcx: &FunctionContext,\n                 let loc = span_start(cx, span);\n                 let scope = scope_metadata(fcx, node_id, span);\n \n-                set_debug_location(cx, DebugLocation::new(scope, loc.line, loc.col.to_uint()));\n+                set_debug_location(cx, DebugLocation::new(scope,\n+                                                          loc.line,\n+                                                          loc.col.to_uint()));\n             } else {\n                 set_debug_location(cx, UnknownLocation);\n             }\n@@ -999,10 +1050,10 @@ pub fn clear_source_location(fcx: &FunctionContext) {\n \n /// Enables emitting source locations for the given functions.\n ///\n-/// Since we don't want source locations to be emitted for the function prelude, they are disabled\n-/// when beginning to translate a new function. This functions switches source location emitting on\n-/// and must therefore be called before the first real statement/expression of the function is\n-/// translated.\n+/// Since we don't want source locations to be emitted for the function prelude,\n+/// they are disabled when beginning to translate a new function. This functions\n+/// switches source location emitting on and must therefore be called before the\n+/// first real statement/expression of the function is translated.\n pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n     match fcx.debug_context.repr {\n         FunctionDebugContext(box ref data) => {\n@@ -1014,9 +1065,10 @@ pub fn start_emitting_source_locations(fcx: &FunctionContext) {\n \n /// Creates the function-specific debug context.\n ///\n-/// Returns the FunctionDebugContext for the function which holds state needed for debug info\n-/// creation. The function may also return another variant of the FunctionDebugContext enum which\n-/// indicates why no debuginfo should be created for the function.\n+/// Returns the FunctionDebugContext for the function which holds state needed\n+/// for debug info creation. The function may also return another variant of the\n+/// FunctionDebugContext enum which indicates why no debuginfo should be created\n+/// for the function.\n pub fn create_function_debug_context(cx: &CrateContext,\n                                      fn_ast_id: ast::NodeId,\n                                      param_substs: &param_substs,\n@@ -1025,15 +1077,16 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         return FunctionDebugContext { repr: DebugInfoDisabled };\n     }\n \n-    // Clear the debug location so we don't assign them in the function prelude. Do this here\n-    // already, in case we do an early exit from this function.\n+    // Clear the debug location so we don't assign them in the function prelude.\n+    // Do this here already, in case we do an early exit from this function.\n     set_debug_location(cx, UnknownLocation);\n \n     if fn_ast_id == -1 {\n         return FunctionDebugContext { repr: FunctionWithoutDebugInfo };\n     }\n \n-    let empty_generics = ast::Generics { lifetimes: Vec::new(), ty_params: OwnedSlice::empty() };\n+    let empty_generics = ast::Generics { lifetimes: Vec::new(),\n+                                         ty_params: OwnedSlice::empty() };\n \n     let fnitem = cx.tcx.map.get(fn_ast_id);\n \n@@ -1064,8 +1117,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n                     let name = token::str_to_ident(name.as_slice());\n                     (name, fn_decl,\n-                        // This is not quite right. It should actually inherit the generics of the\n-                        // enclosing function.\n+                        // This is not quite right. It should actually inherit\n+                        // the generics of the enclosing function.\n                         &empty_generics,\n                         top_level_block,\n                         expr.span,\n@@ -1113,21 +1166,27 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     let file_metadata = file_metadata(cx, loc.file.name.as_slice());\n \n     let function_type_metadata = unsafe {\n-        let fn_signature = get_function_signature(cx, fn_ast_id, &*fn_decl, param_substs, span);\n+        let fn_signature = get_function_signature(cx,\n+                                                  fn_ast_id,\n+                                                  &*fn_decl,\n+                                                  param_substs,\n+                                                  span);\n         llvm::LLVMDIBuilderCreateSubroutineType(DIB(cx), file_metadata, fn_signature)\n     };\n \n-    // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n+    // Get_template_parameters() will append a `<...>` clause to the function\n+    // name if necessary.\n     let mut function_name = String::from_str(token::get_ident(ident).get());\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n                                                       file_metadata,\n                                                       &mut function_name);\n \n-    // There is no ast_map::Path for ast::ExprFnBlock-type functions. For now, just don't put them\n-    // into a namespace. In the future this could be improved somehow (storing a path in the\n-    // ast_map, or construct a path using the enclosing function).\n+    // There is no ast_map::Path for ast::ExprFnBlock-type functions. For now,\n+    // just don't put them into a namespace. In the future this could be improved\n+    // somehow (storing a path in the ast_map, or construct a path using the\n+    // enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n@@ -1138,7 +1197,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         (function_name.as_slice().to_string(), file_metadata)\n     };\n \n-    // Clang sets this parameter to the opening brace of the function's block, so let's do this too.\n+    // Clang sets this parameter to the opening brace of the function's block,\n+    // so let's do this too.\n     let scope_line = span_start(cx, top_level_block.span).line;\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n@@ -1316,18 +1376,19 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     }\n }\n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Module-Internal debug info creation functions\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n fn is_node_local_to_unit(cx: &CrateContext, node_id: ast::NodeId) -> bool\n {\n-    // The is_local_to_unit flag indicates whether a function is local to the current compilation\n-    // unit (i.e. if it is *static* in the C-sense). The *reachable* set should provide a good\n-    // approximation of this, as it contains everything that might leak out of the current crate\n-    // (by being externally visible or by being inlined into something externally visible). It might\n-    // better to use the `exported_items` set from `driver::CrateAnalysis` in the future, but (atm)\n-    // this set is not available in the translation pass.\n+    // The is_local_to_unit flag indicates whether a function is local to the\n+    // current compilation unit (i.e. if it is *static* in the C-sense). The\n+    // *reachable* set should provide a good approximation of this, as it\n+    // contains everything that might leak out of the current crate (by being\n+    // externally visible or by being inlined into something externally visible).\n+    // It might better to use the `exported_items` set from `driver::CrateAnalysis`\n+    // in the future, but (atm) this set is not available in the translation pass.\n     !cx.reachable.contains(&node_id)\n }\n \n@@ -1459,7 +1520,9 @@ fn declare_local(bcx: &Block,\n         }\n     });\n \n-    set_debug_location(cx, DebugLocation::new(scope_metadata, loc.line, loc.col.to_uint()));\n+    set_debug_location(cx, DebugLocation::new(scope_metadata,\n+                                              loc.line,\n+                                              loc.col.to_uint()));\n     unsafe {\n         let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n             DIB(cx),\n@@ -1599,28 +1662,29 @@ fn pointer_type_metadata(cx: &CrateContext,\n     return ptr_metadata;\n }\n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Common facilities for record-like types (structs, enums, tuples)\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n enum MemberOffset {\n     FixedMemberOffset { bytes: uint },\n     // For ComputedMemberOffset, the offset is read from the llvm type definition\n     ComputedMemberOffset\n }\n \n-// Description of a type member, which can either be a regular field (as in structs or tuples) or\n-// an enum variant\n+// Description of a type member, which can either be a regular field (as in\n+// structs or tuples) or an enum variant\n struct MemberDescription {\n     name: String,\n     llvm_type: Type,\n     type_metadata: DIType,\n     offset: MemberOffset,\n }\n \n-// A factory for MemberDescriptions. It produces a list of member descriptions for some record-like\n-// type. MemberDescriptionFactories are used to defer the creation of type member descriptions in\n-// order to break cycles arising from recursive type definitions.\n+// A factory for MemberDescriptions. It produces a list of member descriptions\n+// for some record-like type. MemberDescriptionFactories are used to defer the\n+// creation of type member descriptions in order to break cycles arising from\n+// recursive type definitions.\n enum MemberDescriptionFactory {\n     StructMDF(StructMemberDescriptionFactory),\n     TupleMDF(TupleMemberDescriptionFactory),\n@@ -1647,10 +1711,10 @@ impl MemberDescriptionFactory {\n     }\n }\n \n-// A description of some recursive type. It can either be already finished (as with FinalMetadata)\n-// or it is not yet finished, but contains all information needed to generate the missing parts of\n-// the description. See the documentation section on Recursive Types at the top of this file for\n-// more information.\n+// A description of some recursive type. It can either be already finished (as\n+// with FinalMetadata) or it is not yet finished, but contains all information\n+// needed to generate the missing parts of the description. See the documentation\n+// section on Recursive Types at the top of this file for more information.\n enum RecursiveTypeDescription {\n     UnfinishedMetadata {\n         unfinished_type: ty::t,\n@@ -1689,8 +1753,8 @@ fn create_and_register_recursive_type_forward_declaration(\n }\n \n impl RecursiveTypeDescription {\n-    // Finishes up the description of the type in question (mostly by providing descriptions of the\n-    // fields of the given type) and returns the final type metadata.\n+    // Finishes up the description of the type in question (mostly by providing\n+    // descriptions of the fields of the given type) and returns the final type metadata.\n     fn finalize(&self, cx: &CrateContext) -> MetadataCreationResult {\n         match *self {\n             FinalMetadata(metadata) => MetadataCreationResult::new(metadata, false),\n@@ -1702,9 +1766,10 @@ impl RecursiveTypeDescription {\n                 file_metadata,\n                 ref member_description_factory\n             } => {\n-                // Make sure that we have a forward declaration of the type in the TypeMap so that\n-                // recursive references are possible. This will always be the case if the\n-                // RecursiveTypeDescription has been properly created through the\n+                // Make sure that we have a forward declaration of the type in\n+                // the TypeMap so that recursive references are possible. This\n+                // will always be the case if the RecursiveTypeDescription has\n+                // been properly created through the\n                 // create_and_register_recursive_type_forward_declaration() function.\n                 {\n                     let type_map = debug_context(cx).type_map.borrow();\n@@ -1718,7 +1783,8 @@ impl RecursiveTypeDescription {\n                 }\n \n                 // ... then create the member descriptions ...\n-                let member_descriptions = member_description_factory.create_member_descriptions(cx);\n+                let member_descriptions =\n+                    member_description_factory.create_member_descriptions(cx);\n \n                 // ... and attach them to the stub to complete it.\n                 set_members_of_composite_type(cx,\n@@ -1734,9 +1800,9 @@ impl RecursiveTypeDescription {\n }\n \n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Structs\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory {\n@@ -1822,9 +1888,9 @@ fn prepare_struct_metadata(cx: &CrateContext,\n }\n \n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Tuples\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n // Creates MemberDescriptions for the fields of a tuple\n struct TupleMemberDescriptionFactory {\n@@ -1879,14 +1945,15 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n }\n \n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Enums\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n-// Describes the members of an enum value: An enum is described as a union of structs in DWARF. This\n-// MemberDescriptionFactory provides the description for the members of this union; so for every\n-// variant of the given enum, this factory will produce one MemberDescription (all with no name and\n-// a fixed offset of zero bytes).\n+// Describes the members of an enum value: An enum is described as a union of\n+// structs in DWARF. This MemberDescriptionFactory provides the description for\n+// the members of this union; so for every variant of the given enum, this factory\n+// will produce one MemberDescription (all with no name and a fixed offset of\n+// zero bytes).\n struct EnumMemberDescriptionFactory {\n     enum_type: ty::t,\n     type_rep: Rc<adt::Repr>,\n@@ -1908,7 +1975,9 @@ impl EnumMemberDescriptionFactory {\n                     .iter()\n                     .enumerate()\n                     .map(|(i, struct_def)| {\n-                        let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                        let (variant_type_metadata,\n+                             variant_llvm_type,\n+                             member_desc_factory) =\n                             describe_enum_variant(cx,\n                                                   self.enum_type,\n                                                   struct_def,\n@@ -1941,7 +2010,9 @@ impl EnumMemberDescriptionFactory {\n                 if self.variants.len() == 0 {\n                     vec![]\n                 } else {\n-                    let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n+                    let (variant_type_metadata,\n+                         variant_llvm_type,\n+                         member_description_factory) =\n                         describe_enum_variant(cx,\n                                               self.enum_type,\n                                               struct_def,\n@@ -1971,8 +2042,9 @@ impl EnumMemberDescriptionFactory {\n                 }\n             }\n             adt::RawNullablePointer { nndiscr: non_null_variant_index, nnty, .. } => {\n-                // As far as debuginfo is concerned, the pointer this enum represents is still\n-                // wrapped in a struct. This is to make the DWARF representation of enums uniform.\n+                // As far as debuginfo is concerned, the pointer this enum\n+                // represents is still wrapped in a struct. This is to make the\n+                // DWARF representation of enums uniform.\n \n                 // First create a description of the artificial wrapper struct:\n                 let non_null_variant = self.variants.get(non_null_variant_index as uint);\n@@ -1984,10 +2056,12 @@ impl EnumMemberDescriptionFactory {\n                 let non_null_type_metadata = type_metadata(cx, nnty, self.span);\n \n                 // The type of the artificial struct wrapping the pointer\n-                let artificial_struct_llvm_type = Type::struct_(cx, &[non_null_llvm_type], false);\n+                let artificial_struct_llvm_type = Type::struct_(cx,\n+                                                                &[non_null_llvm_type],\n+                                                                false);\n \n-                // For the metadata of the wrapper struct, we need to create a MemberDescription\n-                // of the struct's single field.\n+                // For the metadata of the wrapper struct, we need to create a\n+                // MemberDescription of the struct's single field.\n                 let sole_struct_member_description = MemberDescription {\n                     name: match non_null_variant.arg_names {\n                         Some(ref names) => token::get_ident(*names.get(0)).get().to_string(),\n@@ -2016,13 +2090,15 @@ impl EnumMemberDescriptionFactory {\n                                             self.file_metadata,\n                                             codemap::DUMMY_SP);\n \n-                // Encode the information about the null variant in the union member's name\n+                // Encode the information about the null variant in the union\n+                // member's name.\n                 let null_variant_index = (1 - non_null_variant_index) as uint;\n                 let null_variant_ident = self.variants.get(null_variant_index).name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\", 0, null_variant_name);\n \n-                // Finally create the (singleton) list of descriptions of union members\n+                // Finally create the (singleton) list of descriptions of union\n+                // members.\n                 vec![\n                     MemberDescription {\n                         name: union_member_name,\n@@ -2032,7 +2108,9 @@ impl EnumMemberDescriptionFactory {\n                     }\n                 ]\n             },\n-            adt::StructWrappedNullablePointer { nonnull: ref struct_def, nndiscr, ptrfield, ..} => {\n+            adt::StructWrappedNullablePointer { nonnull: ref struct_def,\n+                                                nndiscr,\n+                                                ptrfield, ..} => {\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, variant_llvm_type, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -2054,15 +2132,16 @@ impl EnumMemberDescriptionFactory {\n                                               self.file_metadata,\n                                               codemap::DUMMY_SP);\n \n-                // Encode the information about the null variant in the union member's name\n+                // Encode the information about the null variant in the union\n+                // member's name.\n                 let null_variant_index = (1 - nndiscr) as uint;\n                 let null_variant_ident = self.variants.get(null_variant_index).name;\n                 let null_variant_name = token::get_ident(null_variant_ident);\n                 let union_member_name = format!(\"RUST$ENCODED$ENUM${}${}\",\n                                                 ptrfield,\n                                                 null_variant_name);\n \n-                // Create the (singleton) list of descriptions of union members\n+                // Create the (singleton) list of descriptions of union members.\n                 vec![\n                     MemberDescription {\n                         name: union_member_name,\n@@ -2077,7 +2156,7 @@ impl EnumMemberDescriptionFactory {\n     }\n }\n \n-// Creates MemberDescriptions for the fields of a single enum variant\n+// Creates MemberDescriptions for the fields of a single enum variant.\n struct VariantMemberDescriptionFactory {\n     args: Vec<(String, ty::t)> ,\n     discriminant_type_metadata: Option<DIType>,\n@@ -2106,9 +2185,10 @@ enum EnumDiscriminantInfo {\n     NoDiscriminant\n }\n \n-// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type of the variant, and\n-// (3) a MemberDescriptionFactory for producing the descriptions of the fields of the variant. This\n-// is a rudimentary version of a full RecursiveTypeDescription.\n+// Returns a tuple of (1) type_metadata_stub of the variant, (2) the llvm_type\n+// of the variant, and (3) a MemberDescriptionFactory for producing the\n+// descriptions of the fields of the variant. This is a rudimentary version of a\n+// full RecursiveTypeDescription.\n fn describe_enum_variant(cx: &CrateContext,\n                          enum_type: ty::t,\n                          struct_def: &adt::Struct,\n@@ -2163,7 +2243,7 @@ fn describe_enum_variant(cx: &CrateContext,\n         None => variant_info.args.iter().map(|_| \"\".to_string()).collect()\n     };\n \n-    // If this is not a univariant enum, there is also the (unnamed) discriminant field\n+    // If this is not a univariant enum, there is also the (unnamed) discriminant field.\n     match discriminant_info {\n         RegularDiscriminant(_) => arg_names.insert(0, \"\".to_string()),\n         _ => { /* do nothing */ }\n@@ -2179,7 +2259,9 @@ fn describe_enum_variant(cx: &CrateContext,\n         VariantMDF(VariantMemberDescriptionFactory {\n             args: args,\n             discriminant_type_metadata: match discriminant_info {\n-                RegularDiscriminant(discriminant_type_metadata) => Some(discriminant_type_metadata),\n+                RegularDiscriminant(discriminant_type_metadata) => {\n+                    Some(discriminant_type_metadata)\n+                }\n                 _ => None\n             },\n             span: span,\n@@ -2217,9 +2299,10 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         .collect();\n \n     let discriminant_type_metadata = |inttype| {\n-        // We can reuse the type of the discriminant for all monomorphized instances of an enum\n-        // because it doesn't depend on any type parameters. The def_id, uniquely identifying the\n-        // enum's polytype acts as key in this cache.\n+        // We can reuse the type of the discriminant for all monomorphized\n+        // instances of an enum because it doesn't depend on any type parameters.\n+        // The def_id, uniquely identifying the enum's polytype acts as key in\n+        // this cache.\n         let cached_discriminant_type_metadata = debug_context(cx).created_enum_disr_types\n                                                                  .borrow()\n                                                                  .find_copy(&enum_def_id);\n@@ -2315,7 +2398,9 @@ fn prepare_enum_metadata(cx: &CrateContext,\n         }),\n     );\n \n-    fn get_enum_discriminant_name(cx: &CrateContext, def_id: ast::DefId) -> token::InternedString {\n+    fn get_enum_discriminant_name(cx: &CrateContext,\n+                                  def_id: ast::DefId)\n+                                  -> token::InternedString {\n         let name = if def_id.krate == ast::LOCAL_CRATE {\n             cx.tcx.map.get_path_elem(def_id.node).name()\n         } else {\n@@ -2326,7 +2411,8 @@ fn prepare_enum_metadata(cx: &CrateContext,\n     }\n }\n \n-/// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n+/// Creates debug information for a composite type, that is, anything that\n+/// results in a LLVM struct.\n ///\n /// Examples of Rust types to use this are: structs, tuples, boxes, vecs, and enums.\n fn composite_type_metadata(cx: &CrateContext,\n@@ -2363,10 +2449,11 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                                  member_descriptions: &[MemberDescription],\n                                  file_metadata: DIFile,\n                                  definition_span: Span) {\n-    // In some rare cases LLVM metadata uniquing would lead to an existing type description being\n-    // used instead of a new one created in create_struct_stub. This would cause a hard to trace\n-    // assertion in DICompositeType::SetTypeArray(). The following check makes sure that we get a\n-    // better error message if this should happen again due to some regression.\n+    // In some rare cases LLVM metadata uniquing would lead to an existing type\n+    // description being used instead of a new one created in create_struct_stub.\n+    // This would cause a hard to trace assertion in DICompositeType::SetTypeArray().\n+    // The following check makes sure that we get a better error message if this\n+    // should happen again due to some regression.\n     {\n         let mut composite_types_completed =\n             debug_context(cx).composite_types_completed.borrow_mut();\n@@ -2379,10 +2466,14 @@ fn set_members_of_composite_type(cx: &CrateContext,\n             let min_supported_llvm_version = 3 * 1000000 + 4 * 1000;\n \n             if actual_llvm_version < min_supported_llvm_version {\n-                cx.sess().warn(format!(\"This version of rustc was built with LLVM {}.{}. \\\n-                    Rustc just ran into a known debuginfo corruption problem that \\\n-                    often occurs with LLVM versions below 3.4. Please use a rustc built with a \\\n-                    newer version of LLVM.\", llvm_version_major, llvm_version_minor).as_slice());\n+                cx.sess().warn(format!(\"This version of rustc was built with LLVM \\\n+                                        {}.{}. Rustc just ran into a known \\\n+                                        debuginfo corruption problem thatoften \\\n+                                        occurs with LLVM versions below 3.4. \\\n+                                        Please use a rustc built with anewer \\\n+                                        version of LLVM.\",\n+                                       llvm_version_major,\n+                                       llvm_version_minor).as_slice());\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2428,8 +2519,9 @@ fn set_members_of_composite_type(cx: &CrateContext,\n     }\n }\n \n-// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n-// add any fields to the struct. This can be done later with set_members_of_composite_type().\n+// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any\n+// caching, does not add any fields to the struct. This can be done later with\n+// set_members_of_composite_type().\n fn create_struct_stub(cx: &CrateContext,\n                       struct_llvm_type: Type,\n                       struct_type_name: &str,\n@@ -2447,8 +2539,9 @@ fn create_struct_stub(cx: &CrateContext,\n     let metadata_stub = unsafe {\n         struct_type_name.with_c_str(|name| {\n             unique_type_id_str.as_slice().with_c_str(|unique_type_id| {\n-                // LLVMDIBuilderCreateStructType() wants an empty array. A null pointer will lead to\n-                // hard to trace and debug LLVM assertions later on in llvm/lib/IR/Value.cpp\n+                // LLVMDIBuilderCreateStructType() wants an empty array. A null\n+                // pointer will lead to hard to trace and debug LLVM assertions\n+                // later on in llvm/lib/IR/Value.cpp.\n                 let empty_array = create_DIArray(DIB(cx), []);\n \n                 llvm::LLVMDIBuilderCreateStructType(\n@@ -2497,7 +2590,9 @@ fn at_box_metadata(cx: &CrateContext,\n \n     let int_type = ty::mk_int();\n     let nil_pointer_type = ty::mk_nil_ptr(cx.tcx());\n-    let nil_pointer_type_metadata = type_metadata(cx, nil_pointer_type, codemap::DUMMY_SP);\n+    let nil_pointer_type_metadata = type_metadata(cx,\n+                                                  nil_pointer_type,\n+                                                  codemap::DUMMY_SP);\n \n     let member_descriptions = [\n         MemberDescription {\n@@ -2549,12 +2644,14 @@ fn at_box_metadata(cx: &CrateContext,\n         file_metadata,\n         codemap::DUMMY_SP);\n \n-    let gc_pointer_metadata = pointer_type_metadata(cx, at_pointer_type, gc_box_metadata);\n+    let gc_pointer_metadata = pointer_type_metadata(cx,\n+                                                    at_pointer_type,\n+                                                    gc_box_metadata);\n \n     return MetadataCreationResult::new(gc_pointer_metadata, false);\n \n-    // Unfortunately, we cannot assert anything but the correct types here---and not whether the\n-    // 'next' and 'prev' pointers are in the correct order.\n+    // Unfortunately, we cannot assert anything but the correct types here---and\n+    // not whether the 'next' and 'prev' pointers are in the correct order.\n     fn box_layout_is_correct(cx: &CrateContext,\n                              member_llvm_types: &[Type],\n                              content_llvm_type: Type)\n@@ -2664,7 +2761,8 @@ fn heap_vec_metadata(cx: &CrateContext,\n \n     let vec_box_unique_id = debug_context(cx).type_map\n                                              .borrow_mut()\n-                                             .get_unique_type_id_of_heap_vec_box(cx, element_type);\n+                                             .get_unique_type_id_of_heap_vec_box(cx,\n+                                                                                 element_type);\n \n     let vecbox_metadata = composite_type_metadata(cx,\n                                                   vecbox_llvm_type,\n@@ -2675,7 +2773,9 @@ fn heap_vec_metadata(cx: &CrateContext,\n                                                   file_metadata,\n                                                   span);\n \n-    MetadataCreationResult::new(pointer_type_metadata(cx, vec_pointer_type, vecbox_metadata), false)\n+    MetadataCreationResult::new(pointer_type_metadata(cx,\n+                                                      vec_pointer_type,\n+                                                      vecbox_metadata), false)\n }\n \n fn vec_slice_metadata(cx: &CrateContext,\n@@ -2786,9 +2886,9 @@ fn trait_metadata(cx: &CrateContext,\n                   _: &ty::BuiltinBounds,\n                   unique_type_id: UniqueTypeId)\n                -> DIType {\n-    // The implementation provided here is a stub. It makes sure that the trait type is\n-    // assigned the correct name, size, namespace, and source location. But it does not describe\n-    // the trait's methods.\n+    // The implementation provided here is a stub. It makes sure that the trait\n+    // type is assigned the correct name, size, namespace, and source location.\n+    // But it does not describe the trait's methods.\n     let last = ty::with_path(cx.tcx(), def_id, |mut path| path.last().unwrap());\n     let ident_string = token::get_name(last.name());\n     let mut name = ppaux::trait_store_to_str(cx.tcx(), trait_store);\n@@ -2823,25 +2923,29 @@ fn type_metadata(cx: &CrateContext,\n     // Get the unique type id of this type.\n     let unique_type_id = {\n         let mut type_map = debug_context(cx).type_map.borrow_mut();\n-        // First, try to find the type in TypeMap. If we have seen it before, we can exit early here\n+        // First, try to find the type in TypeMap. If we have seen it before, we\n+        // can exit early here.\n         match type_map.find_metadata_for_type(t) {\n             Some(metadata) => {\n                 return metadata;\n             },\n             None => {\n-                // The ty::t is not in the TypeMap but maybe we have already seen an equivalent type\n-                // (e.g. only differing in region arguments). In order to find out, generate the\n-                // unique type id and look that up.\n+                // The ty::t is not in the TypeMap but maybe we have already seen\n+                // an equivalent type (e.g. only differing in region arguments).\n+                // In order to find out, generate the unique type id and look\n+                // that up.\n                 let unique_type_id = type_map.get_unique_type_id_of_type(cx, t);\n                 match type_map.find_metadata_for_unique_id(unique_type_id) {\n                     Some(metadata) => {\n-                        // There is already an equivalent type in the TypeMap. Register this ty::t\n-                        // as an alias in the cache and return the cached metadata\n+                        // There is already an equivalent type in the TypeMap.\n+                        // Register this ty::t as an alias in the cache and\n+                        // return the cached metadata.\n                         type_map.register_type_with_metadata(cx, t, metadata);\n                         return metadata;\n                     },\n                     None => {\n-                        // There really is no type metadata for this type, so proceed by creating it\n+                        // There really is no type metadata for this type, so\n+                        // proceed by creating it.\n                         unique_type_id\n                     }\n                 }\n@@ -2968,11 +3072,14 @@ fn type_metadata(cx: &CrateContext,\n             let metadata_for_uid = match type_map.find_metadata_for_unique_id(unique_type_id) {\n                 Some(metadata) => metadata,\n                 None => {\n-                    let unique_type_id_str = type_map.get_unique_type_id_as_string(unique_type_id);\n-                    let error_message = format!(\"Expected type metadata for unique type id '{}' to \\\n-                        already be in the debuginfo::TypeMap but it was not. (ty::t = {})\",\n-                        unique_type_id_str.as_slice(),\n-                        ppaux::ty_to_str(cx.tcx(), t));\n+                    let unique_type_id_str =\n+                        type_map.get_unique_type_id_as_string(unique_type_id);\n+                    let error_message = format!(\"Expected type metadata for unique \\\n+                                                 type id '{}' to already be in \\\n+                                                 the debuginfo::TypeMap but it \\\n+                                                 was not. (ty::t = {})\",\n+                                                unique_type_id_str.as_slice(),\n+                                                ppaux::ty_to_str(cx.tcx(), t));\n                     cx.sess().span_bug(usage_site_span, error_message.as_slice());\n                 }\n             };\n@@ -2982,8 +3089,10 @@ fn type_metadata(cx: &CrateContext,\n                     if metadata != metadata_for_uid {\n                         let unique_type_id_str =\n                             type_map.get_unique_type_id_as_string(unique_type_id);\n-                        let error_message = format!(\"Mismatch between ty::t and UniqueTypeId maps \\\n-                            in debuginfo::TypeMap. UniqueTypeId={}, ty::t={}\",\n+                        let error_message = format!(\"Mismatch between ty::t and \\\n+                                                     UniqueTypeId maps in \\\n+                                                     debuginfo::TypeMap. \\\n+                                                     UniqueTypeId={}, ty::t={}\",\n                             unique_type_id_str.as_slice(),\n                             ppaux::ty_to_str(cx.tcx(), t));\n                         cx.sess().span_bug(usage_site_span, error_message.as_slice());\n@@ -3063,9 +3172,9 @@ fn set_debug_location(cx: &CrateContext, debug_location: DebugLocation) {\n     debug_context(cx).current_debug_location.set(debug_location);\n }\n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n //  Utility Functions\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n /// Return codemap::Loc corresponding to the beginning of the span\n fn span_start(cx: &CrateContext, span: Span) -> codemap::Loc {\n@@ -3118,13 +3227,13 @@ fn get_namespace_and_span_for_item(cx: &CrateContext, def_id: ast::DefId)\n     (containing_scope, definition_span)\n }\n \n-// This procedure builds the *scope map* for a given function, which maps any given ast::NodeId in\n-// the function's AST to the correct DIScope metadata instance.\n+// This procedure builds the *scope map* for a given function, which maps any\n+// given ast::NodeId in the function's AST to the correct DIScope metadata instance.\n //\n-// This builder procedure walks the AST in execution order and keeps track of what belongs to which\n-// scope, creating DIScope DIEs along the way, and introducing *artificial* lexical scope\n-// descriptors where necessary. These artificial scopes allow GDB to correctly handle name\n-// shadowing.\n+// This builder procedure walks the AST in execution order and keeps track of\n+// what belongs to which scope, creating DIScope DIEs along the way, and\n+// introducing *artificial* lexical scope descriptors where necessary. These\n+// artificial scopes allow GDB to correctly handle name shadowing.\n fn populate_scope_map(cx: &CrateContext,\n                       arg_pats: &[Gc<ast::Pat>],\n                       fn_entry_block: &ast::Block,\n@@ -3137,18 +3246,20 @@ fn populate_scope_map(cx: &CrateContext,\n         ident: Option<ast::Ident>\n     }\n \n-    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata, ident: None });\n+    let mut scope_stack = vec!(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                                 ident: None });\n \n-    // Push argument identifiers onto the stack so arguments integrate nicely with variable\n-    // shadowing.\n+    // Push argument identifiers onto the stack so arguments integrate nicely\n+    // with variable shadowing.\n     for &arg_pat in arg_pats.iter() {\n         pat_util::pat_bindings(def_map, &*arg_pat, |_, _, _, path_ref| {\n             let ident = ast_util::path_to_ident(path_ref);\n-            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata, ident: Some(ident) });\n+            scope_stack.push(ScopeStackEntry { scope_metadata: fn_metadata,\n+                                               ident: Some(ident) });\n         })\n     }\n \n-    // Clang creates a separate scope for function bodies, so let's do this too\n+    // Clang creates a separate scope for function bodies, so let's do this too.\n     with_new_scope(cx,\n                    fn_entry_block.span,\n                    &mut scope_stack,\n@@ -3180,7 +3291,8 @@ fn populate_scope_map(cx: &CrateContext,\n                 0)\n         };\n \n-        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata, ident: None });\n+        scope_stack.push(ScopeStackEntry { scope_metadata: scope_metadata,\n+                                           ident: None });\n \n         inner_walk(cx, scope_stack, scope_map);\n \n@@ -3213,7 +3325,7 @@ fn populate_scope_map(cx: &CrateContext,\n                 ast::StmtExpr(ref exp, _) |\n                 ast::StmtSemi(ref exp, _) =>\n                     walk_expr(cx, &**exp, scope_stack, scope_map),\n-                ast::StmtMac(..) => () // ignore macros (which should be expanded anyway)\n+                ast::StmtMac(..) => () // Ignore macros (which should be expanded anyway).\n             }\n         }\n \n@@ -3247,21 +3359,22 @@ fn populate_scope_map(cx: &CrateContext,\n \n         let def_map = &cx.tcx.def_map;\n \n-        // Unfortunately, we cannot just use pat_util::pat_bindings() or ast_util::walk_pat() here\n-        // because we have to visit *all* nodes in order to put them into the scope map. The above\n-        // functions don't do that.\n+        // Unfortunately, we cannot just use pat_util::pat_bindings() or\n+        // ast_util::walk_pat() here because we have to visit *all* nodes in\n+        // order to put them into the scope map. The above functions don't do that.\n         match pat.node {\n             ast::PatIdent(_, ref path_ref, ref sub_pat_opt) => {\n \n-                // Check if this is a binding. If so we need to put it on the scope stack and maybe\n-                // introduce an artificial scope\n+                // Check if this is a binding. If so we need to put it on the\n+                // scope stack and maybe introduce an artificial scope\n                 if pat_util::pat_is_binding(def_map, &*pat) {\n \n                     let ident = ast_util::path_to_ident(path_ref);\n \n-                    // LLVM does not properly generate 'DW_AT_start_scope' fields for variable DIEs.\n-                    // For this reason we have to introduce an artificial scope at bindings whenever\n-                    // a variable with the same name is declared in *any* parent scope.\n+                    // LLVM does not properly generate 'DW_AT_start_scope' fields\n+                    // for variable DIEs. For this reason we have to introduce\n+                    // an artificial scope at bindings whenever a variable with\n+                    // the same name is declared in *any* parent scope.\n                     //\n                     // Otherwise the following error occurs:\n                     //\n@@ -3270,8 +3383,9 @@ fn populate_scope_map(cx: &CrateContext,\n                     // do_something(); // 'gdb print x' correctly prints 10\n                     //\n                     // {\n-                    //     do_something(); // 'gdb print x' prints 0, because it already reads the\n-                    //                     // uninitialized 'x' from the next line...\n+                    //     do_something(); // 'gdb print x' prints 0, because it\n+                    //                     // already reads the uninitialized 'x'\n+                    //                     // from the next line...\n                     //     let x = 100;\n                     //     do_something(); // 'gdb print x' correctly prints 100\n                     // }\n@@ -3531,9 +3645,10 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::ExprMatch(ref discriminant_exp, ref arms) => {\n                 walk_expr(cx, &**discriminant_exp, scope_stack, scope_map);\n \n-                // for each arm we have to first walk the pattern as these might introduce new\n-                // artificial scopes. It should be sufficient to walk only one pattern per arm, as\n-                // they all must contain the same binding names\n+                // For each arm we have to first walk the pattern as these might\n+                // introduce new artificial scopes. It should be sufficient to\n+                // walk only one pattern per arm, as they all must contain the\n+                // same binding names.\n \n                 for arm_ref in arms.iter() {\n                     let arm_span = arm_ref.pats.get(0).span;\n@@ -3584,9 +3699,9 @@ fn populate_scope_map(cx: &CrateContext,\n }\n \n \n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n // Namespace Handling\n-//=-------------------------------------------------------------------------------------------------\n+//=-----------------------------------------------------------------------------\n \n struct NamespaceTreeNode {\n     name: ast::Name,"}]}