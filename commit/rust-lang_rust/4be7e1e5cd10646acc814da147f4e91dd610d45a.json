{"sha": "4be7e1e5cd10646acc814da147f4e91dd610d45a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiZTdlMWU1Y2QxMDY0NmFjYzgxNGRhMTQ3ZjRlOTFkZDYxMGQ0NWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-07T13:13:19Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-09-12T09:06:54Z"}, "message": "Pass all arguments by reference, make immut alias mode equiv to value\n\nArguments that can't be safely referenced will be implicitly copied.\n\n(Warnings for expensive copies will be forthcoming.)\n\nThis will allow us to get rid of most of the ampersands in function\nsignatures. See [1].\n\n[1] https://mail.mozilla.org/pipermail/rust-dev/2011-September/000759.html", "tree": {"sha": "2df2d6cea1f30373c33437c35197cd517ea86623", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df2d6cea1f30373c33437c35197cd517ea86623"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4be7e1e5cd10646acc814da147f4e91dd610d45a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4be7e1e5cd10646acc814da147f4e91dd610d45a", "html_url": "https://github.com/rust-lang/rust/commit/4be7e1e5cd10646acc814da147f4e91dd610d45a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4be7e1e5cd10646acc814da147f4e91dd610d45a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "html_url": "https://github.com/rust-lang/rust/commit/476bbca87abb9aa17f84d1a8fb91bdefda4668ba"}], "stats": {"total": 346, "additions": 188, "deletions": 158}, "files": [{"sha": "3a6f738629209e3c9c42d05c76f5bb6a67753ab3", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -158,14 +158,14 @@ fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &str,\n     let mut_map =\n         time(time_passes, \"mutability checking\",\n              bind middle::mut::check_crate(ty_cx, crate));\n-    time(time_passes, \"alias checking\",\n-         bind middle::alias::check_crate(ty_cx, crate));\n+    let copy_map = time(time_passes, \"alias checking\",\n+                        bind middle::alias::check_crate(ty_cx, crate));\n     time(time_passes, \"kind checking\", bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n     let llmod =\n         time(time_passes, \"translation\",\n              bind trans::trans_crate(sess, crate, ty_cx, output, ast_map,\n-                                     mut_map));\n+                                     mut_map, copy_map));\n     time(time_passes, \"LLVM passes\",\n          bind link::write::run_passes(sess, llmod, output));\n }"}, {"sha": "e1d96cf9a05983036bd6d132b58877c5de0a3c35", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 95, "deletions": 70, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -24,35 +24,43 @@ tag valid { valid; overwritten(span, ast::path); val_taken(span, ast::path); }\n \n type restrict =\n     @{root_var: option::t<node_id>,\n+      node_id: node_id,\n+      ty: ty::t,\n       local_id: uint,\n       bindings: [node_id],\n       unsafe_ty: option::t<ty::t>,\n       depends_on: [uint],\n-      mutable ok: valid};\n+      mutable ok: valid,\n+      mutable given_up: bool};\n \n type scope = @[restrict];\n \n tag local_info { local(uint); }\n \n+type copy_map = std::map::hashmap<node_id, ()>;\n+\n type ctx =\n     {tcx: ty::ctxt,\n      local_map: std::map::hashmap<node_id, local_info>,\n-     mutable next_local: uint};\n+     mutable next_local: uint,\n+     copy_map: copy_map};\n \n-fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) {\n+fn check_crate(tcx: ty::ctxt, crate: &@ast::crate) -> copy_map {\n     // Stores information about object fields and function\n     // arguments that's otherwise not easily available.\n     let cx =\n         @{tcx: tcx,\n           local_map: std::map::new_int_hash(),\n-          mutable next_local: 0u};\n+          mutable next_local: 0u,\n+          copy_map: std::map::new_int_hash()};\n     let v =\n         @{visit_fn: visit_fn,\n           visit_expr: bind visit_expr(cx, _, _, _),\n           visit_decl: bind visit_decl(cx, _, _, _)\n              with *visit::default_visitor::<scope>()};\n     visit::visit_crate(*crate, @[], visit::mk_vt(v));\n     tcx.sess.abort_if_errors();\n+    ret cx.copy_map;\n }\n \n fn visit_fn(f: &ast::_fn, _tp: &[ast::ty_param], _sp: &span, _name: &fn_ident,\n@@ -148,37 +156,53 @@ fn visit_decl(cx: &@ctx, d: &@ast::decl, sc: &scope, v: &vt<scope>) {\n     }\n }\n \n-fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n-   [restrict] {\n+fn cant_copy(cx: &ctx, r: &restrict) -> bool {\n+    if r.given_up { ret false; }\n+    // FIXME alt contexts copying not supported yet\n+    if r.node_id == 0 { ret true; }\n+    // FIXME warn when copy is expensive\n+    if ty::type_allows_implicit_copy(cx.tcx, r.ty) {\n+        r.given_up = true;\n+        cx.copy_map.insert(r.node_id, ());\n+        ret false;\n+    } else {\n+        ret true;\n+    }\n+}\n+\n+fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope)\n+    -> [restrict] {\n     let fty = ty::type_autoderef(cx.tcx, ty::expr_ty(cx.tcx, f));\n     let arg_ts = ty::ty_fn_args(cx.tcx, fty);\n     let mut_roots: [{arg: uint, node: node_id}] = [];\n     let restricts = [];\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n-        if arg_t.mode != ty::mo_val {\n-            let arg = args[i];\n-            let root = expr_root(cx.tcx, arg, false);\n-            if arg_t.mode == ty::mo_alias(true) {\n-                alt path_def(cx, arg) {\n-                  some(def) {\n-                    let dnum = ast_util::def_id_of_def(def).node;\n-                    mut_roots += [{arg: i, node: dnum}];\n-                  }\n-                  _ { }\n-                }\n+        let arg = args[i];\n+        let root = expr_root(cx.tcx, arg, false);\n+        if arg_t.mode == ty::mo_alias(true) {\n+            alt path_def(cx, arg) {\n+              some(def) {\n+                let dnum = ast_util::def_id_of_def(def).node;\n+                mut_roots += [{arg: i, node: dnum}];\n+              }\n+              _ { }\n             }\n-            let root_var = path_def_id(cx, root.ex);\n-            let unsafe_t =\n-                alt inner_mut(root.ds) { some(t) { some(t) } _ { none } };\n-            restricts +=\n-                [@{root_var: root_var,\n-                   local_id: cx.next_local,\n-                   bindings: [arg.id],\n-                   unsafe_ty: unsafe_t,\n-                   depends_on: deps(sc, root_var),\n-                   mutable ok: valid}];\n         }\n+        let root_var = path_def_id(cx, root.ex);\n+        let unsafe_t =\n+            alt inner_mut(root.ds) { some(t) { some(t) } _ { none } };\n+        restricts +=\n+            [@{root_var: root_var,\n+               node_id: arg_t.mode == ast::by_mut_ref ? 0 : arg.id,\n+               ty: arg_t.ty,\n+               local_id: cx.next_local,\n+               bindings: [arg.id],\n+               unsafe_ty: unsafe_t,\n+               depends_on: deps(sc, root_var),\n+               mutable ok: valid,\n+               // FIXME kludge\n+               mutable given_up: arg_t.mode == ty::mo_move}];\n         i += 1u;\n     }\n     let f_may_close =\n@@ -189,7 +213,7 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n     if f_may_close {\n         let i = 0u;\n         for r in restricts {\n-            if !option::is_none(r.unsafe_ty) {\n+            if !option::is_none(r.unsafe_ty) && cant_copy(cx, r) {\n                 cx.tcx.sess.span_err(f.span,\n                                      #fmt[\"function may alias with argument \\\n                                            %u, which is not immutably rooted\",\n@@ -199,19 +223,19 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n         }\n     }\n     let j = 0u;\n-    for @{unsafe_ty: unsafe_ty, _} in restricts {\n-        alt unsafe_ty {\n+    for r in restricts {\n+        alt r.unsafe_ty {\n           some(ty) {\n             let i = 0u;\n             for arg_t: ty::arg in arg_ts {\n                 let mut_alias = arg_t.mode == ty::mo_alias(true);\n                 if i != j &&\n-                       ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) {\n+                   ty_can_unsafely_include(cx, ty, arg_t.ty, mut_alias) &&\n+                   cant_copy(cx, r) {\n                     cx.tcx.sess.span_err(\n                         args[i].span,\n                         #fmt[\"argument %u may alias with argument %u, \\\n-                               which is not immutably rooted\",\n-                                              i, j]);\n+                              which is not immutably rooted\", i, j]);\n                 }\n                 i += 1u;\n             }\n@@ -223,27 +247,22 @@ fn check_call(cx: &ctx, f: &@ast::expr, args: &[@ast::expr], sc: &scope) ->\n     // Ensure we're not passing a root by mutable alias.\n \n     for {node: node, arg: arg} in mut_roots {\n-        let mut_alias_to_root = false;\n-        let mut_alias_to_root_count = 0u;\n-        for @{root_var: root_var, _} in restricts {\n-            alt root_var {\n-              some(root) {\n-                if node == root {\n-                    mut_alias_to_root_count += 1u;\n-                    if mut_alias_to_root_count > 1u {\n-                        mut_alias_to_root = true;\n+        let i = 0u;\n+        for r in restricts {\n+            if i != arg {\n+                alt r.root_var {\n+                  some(root) {\n+                    if node == root && cant_copy(cx, r) {\n+                        cx.tcx.sess.span_err(\n+                            args[arg].span, \"passing a mutable alias to a \\\n+                            variable that roots another alias\");\n                         break;\n                     }\n+                  }\n+                  none. { }\n                 }\n-              }\n-              none. { }\n             }\n-        }\n-\n-        if mut_alias_to_root {\n-            cx.tcx.sess.span_err(args[arg].span,\n-                                 \"passing a mutable alias to a variable \\\n-                                   that roots another alias\");\n+            i += 1u;\n         }\n     }\n     ret restricts;\n@@ -261,11 +280,15 @@ fn check_alt(cx: &ctx, input: &@ast::expr, arms: &[ast::arm], sc: &scope,\n             new_sc =\n                 @(*sc +\n                       [@{root_var: root_var,\n+                     // FIXME need to use separate restrict for each binding\n+                         node_id: 0,\n+                         ty: ty::mk_int(cx.tcx),\n                          local_id: cx.next_local,\n                          bindings: dnums,\n                          unsafe_ty: inner_mut(root.ds),\n                          depends_on: deps(sc, root_var),\n-                         mutable ok: valid}]);\n+                         mutable ok: valid,\n+                         mutable given_up: false}]);\n         }\n         register_locals(cx, a.pats[0]);\n         visit::visit_arm(a, new_sc, v);\n@@ -292,23 +315,28 @@ fn check_for(cx: &ctx, local: &@ast::local, seq: &@ast::expr, blk: &ast::blk,\n \n     // If this is a mutable vector, don't allow it to be touched.\n     let seq_t = ty::expr_ty(cx.tcx, seq);\n+    let elt_t;\n     alt ty::struct(cx.tcx, seq_t) {\n-      ty::ty_vec(mt) { if mt.mut != ast::imm { unsafe = some(seq_t); } }\n-      ty::ty_str. {/* no-op */ }\n-      _ {\n-        cx.tcx.sess.span_unimpl(seq.span,\n-                                \"unknown seq type \" +\n-                                    util::ppaux::ty_to_str(cx.tcx, seq_t));\n+      ty::ty_vec(mt) {\n+        if mt.mut != ast::imm { unsafe = some(seq_t); }\n+        elt_t = mt.ty;\n+      }\n+      ty::ty_str. {\n+        elt_t = ty::mk_mach(cx.tcx, ast::ty_u8);\n       }\n     }\n     let root_var = path_def_id(cx, root.ex);\n     let new_sc =\n         @{root_var: root_var,\n+          // FIXME reenable when trans knows how to copy for vars\n+          node_id: 0, // blk.node.id,\n+          ty: elt_t,\n           local_id: cx.next_local,\n           bindings: ast_util::pat_binding_ids(local.node.pat),\n           unsafe_ty: unsafe,\n           depends_on: deps(sc, root_var),\n-          mutable ok: valid};\n+          mutable ok: valid,\n+          mutable given_up: false};\n     register_locals(cx, local.node.pat);\n     visit::visit_block(blk, @(*sc + [new_sc]), v);\n }\n@@ -322,7 +350,6 @@ fn check_var(cx: &ctx, ex: &@ast::expr, p: &ast::path, id: ast::node_id,\n         alt cx.local_map.find(my_defnum) { some(local(id)) { id } _ { 0u } };\n     let var_t = ty::expr_ty(cx.tcx, ex);\n     for r: restrict in *sc {\n-\n         // excludes variables introduced since the alias was made\n         if my_local_id < r.local_id {\n             alt r.unsafe_ty {\n@@ -364,17 +391,15 @@ fn test_scope(cx: &ctx, sc: &scope, r: &restrict, p: &ast::path) {\n         if prob != valid { break; }\n         prob = sc[dep].ok;\n     }\n-    if prob != valid {\n-        let msg =\n-            alt prob {\n-              overwritten(sp, wpt) {\n-                {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n-              }\n-              val_taken(sp, vpt) {\n-                {span: sp,\n-                 msg: \"taking the value of \" + ast_util::path_name(vpt)}\n-              }\n-            };\n+    if prob != valid && cant_copy(cx, r) {\n+        let msg = alt prob {\n+          overwritten(sp, wpt) {\n+            {span: sp, msg: \"overwriting \" + ast_util::path_name(wpt)}\n+          }\n+          val_taken(sp, vpt) {\n+            {span: sp, msg: \"taking the value of \" + ast_util::path_name(vpt)}\n+          }\n+        };\n         cx.tcx.sess.span_err(msg.span,\n                              msg.msg + \" will invalidate alias \" +\n                                  ast_util::path_name(p) +"}, {"sha": "ae1379970541be842a718faa725e37e388cf3d55", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -68,10 +68,14 @@ fn expr_root(tcx: &ty::ctxt, ex: @expr, autoderef: bool) ->\n             let auto_unbox = maybe_auto_unbox(tcx, ty::expr_ty(tcx, base));\n             alt ty::struct(tcx, auto_unbox.t) {\n               ty::ty_vec(mt) {\n-                ds +=\n-                    [@{mut: mt.mut != imm,\n-                       kind: index,\n-                       outer_t: auto_unbox.t}];\n+                ds += [@{mut: mt.mut != imm,\n+                         kind: index,\n+                         outer_t: auto_unbox.t}];\n+              }\n+              ty::ty_str. {\n+                ds += [@{mut: false,\n+                         kind: index,\n+                         outer_t: auto_unbox.t}];\n               }\n             }\n             ds += auto_unbox.ds;"}, {"sha": "4f702448fd20a734d366974601e66e481f3a48f1", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 50, "deletions": 80, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -79,20 +79,9 @@ fn type_of(cx: &@crate_ctxt, sp: &span, t: ty::t)\n \n fn type_of_explicit_args(cx: &@crate_ctxt, sp: &span, inputs: &[ty::arg]) ->\n    [TypeRef] {\n-    let atys: [TypeRef] = [];\n-    for arg: ty::arg in inputs {\n-        let t: TypeRef = type_of_inner(cx, sp, arg.ty);\n-        t =\n-            alt arg.mode {\n-              ty::mo_alias(_) { T_ptr(t) }\n-              ty::mo_move. { T_ptr(t) }\n-              _ {\n-                if ty::type_is_structural(cx.tcx, arg.ty) {\n-                    T_ptr(t)\n-                } else { t }\n-              }\n-            };\n-        atys += [t];\n+    let atys = [];\n+    for arg in inputs {\n+        atys += [T_ptr(type_of_inner(cx, sp, arg.ty))];\n     }\n     ret atys;\n }\n@@ -2038,12 +2027,6 @@ fn copy_val(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n fn copy_val_no_check(cx: &@block_ctxt, action: copy_action, dst: ValueRef,\n                      src: ValueRef, t: ty::t) -> @block_ctxt {\n     let ccx = bcx_ccx(cx);\n-    // FIXME this is just a clunky stopgap. we should do proper checking in an\n-    // earlier pass.\n-    if !ty::type_is_copyable(ccx.tcx, t) {\n-        ccx.sess.span_fatal(cx.sp, \"Copying a non-copyable type.\");\n-    }\n-\n     if ty::type_is_scalar(ccx.tcx, t) || ty::type_is_native(ccx.tcx, t) {\n         Store(cx, src, dst);\n         ret cx;\n@@ -3387,14 +3370,12 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n     for arg: option::t<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n-        let is_val = out_arg.mode == ty::mo_val;\n         alt arg {\n \n \n           // Arg provided at binding time; thunk copies it from\n           // closure.\n           some(e) {\n-            let e_ty = ty::expr_ty(cx.ccx.tcx, e);\n             let bound_arg =\n                 GEP_tup_like(bcx, closure_ty, llclosure,\n                              [0, abi::box_rc_field_body,\n@@ -3404,20 +3385,12 @@ fn trans_bind_thunk(cx: &@local_ctxt, sp: &span, incoming_fty: ty::t,\n             // If the type is parameterized, then we need to cast the\n             // type we actually have to the parameterized out type.\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n-                let ty =\n-                    if is_val { T_ptr(llout_arg_ty) } else { llout_arg_ty };\n-                val = PointerCast(bcx, val, ty);\n-            }\n-            if is_val && (type_is_immediate(cx.ccx, e_ty) ||\n-                          ty::type_is_unique(cx.ccx.tcx, e_ty)) {\n-                val = Load(bcx, val);\n+                val = PointerCast(bcx, val, llout_arg_ty);\n             }\n             llargs += [val];\n             b += 1;\n           }\n \n-\n-\n           // Arg will be provided when the thunk is invoked.\n           none. {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a);\n@@ -3543,27 +3516,22 @@ fn trans_arg_expr(cx: &@block_ctxt, arg: &ty::arg, lldestty0: TypeRef,\n         // be inspected. It's important for the value\n         // to have type lldestty0 (the callee's expected type).\n         val = llvm::LLVMGetUndef(lldestty0);\n-    } else if arg.mode == ty::mo_val {\n-        if ty::type_is_vec(ccx.tcx, e_ty) {\n-            let r = do_spill(bcx, Load(bcx, val), e_ty);\n-            bcx = r.bcx;\n-            let arg_copy = r.val;\n-\n-            bcx = take_ty(bcx, arg_copy, e_ty);\n-            val = Load(bcx, arg_copy);\n-            add_clean_temp(bcx, arg_copy, e_ty);\n-        } else if !lv.is_mem {\n-            // Do nothing for non-vector temporaries; just give them to the\n-            // callee.\n-        } else if type_is_structural_or_param(ccx.tcx, e_ty) {\n-            let dst = alloc_ty(bcx, e_ty);\n-            bcx = copy_val(dst.bcx, INIT, dst.val, val, e_ty);\n-            val = dst.val;\n-            add_clean_temp(bcx, val, e_ty);\n-        } else {\n-            bcx = take_ty(bcx, val, e_ty);\n-            val = load_if_immediate(bcx, val, e_ty);\n-            add_clean_temp(bcx, val, e_ty);\n+    } else if arg.mode == ty::mo_val || arg.mode == ty::mo_alias(false) {\n+        let copied = false;\n+        if !lv.is_mem && type_is_immediate(ccx, e_ty) {\n+            val = do_spill_noroot(bcx, val);\n+            copied = true;\n+        }\n+        if ccx.copy_map.contains_key(e.id) && lv.is_mem {\n+            if !copied {\n+                let alloc = alloc_ty(bcx, e_ty);\n+                bcx = copy_val(alloc.bcx, INIT, alloc.val,\n+                               load_if_immediate(alloc.bcx, val, e_ty), e_ty);\n+                val = alloc.val;\n+            } else {\n+                bcx = take_ty(bcx, val, e_ty);\n+            }\n+            add_clean(bcx, val, e_ty);\n         }\n     } else if type_is_immediate(ccx, e_ty) && !lv.is_mem {\n         let r = do_spill(bcx, val, e_ty);\n@@ -4768,7 +4736,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n     da: BasicBlockRef,\n     rt: BasicBlockRef} {\n     ret {sa:\n-             str::as_buf(\"statuc_allocas\",\n+             str::as_buf(\"static_allocas\",\n                          {|buf| llvm::LLVMAppendBasicBlock(llfn, buf) }),\n          ca:\n              str::as_buf(\"copy_args\",\n@@ -4892,33 +4860,25 @@ fn create_llargs_for_fn_args(cx: &@fn_ctxt, proto: ast::proto,\n }\n \n fn copy_args_to_allocas(fcx: @fn_ctxt, scope: @block_ctxt, args: &[ast::arg],\n-                        arg_tys: &[ty::arg]) {\n+                        arg_tys: &[ty::arg], ignore_mut: bool) {\n     let llcopyargs = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n     let bcx = llcopyargs;\n     let arg_n: uint = 0u;\n     for aarg: ast::arg in args {\n         let arg_ty = arg_tys[arg_n].ty;\n         alt aarg.mode {\n-          ast::val. {\n-\n-            // Structural types are passed by pointer, and we use the\n-            // pointed-to memory for the local.\n-            if !type_is_structural_or_param(fcx_tcx(fcx), arg_ty) {\n-                // Overwrite the llargs entry for this arg with its alloca.\n-                let aval = bcx.fcx.llargs.get(aarg.id);\n-\n-                let r = do_spill(bcx, aval, arg_ty);\n-                bcx = r.bcx;\n-                let addr = r.val;\n-\n-                bcx.fcx.llargs.insert(aarg.id, addr);\n-\n-                // Args that are locally assigned to need to do a local\n-                // take/drop\n-                if fcx.lcx.ccx.mut_map.contains_key(aarg.id) {\n-                    bcx = take_ty(bcx, addr, arg_ty);\n-                    add_clean(scope, addr, arg_ty);\n-                }\n+          ast::val. | ast::alias(false) {\n+            let mutated = !ignore_mut &&\n+                fcx.lcx.ccx.mut_map.contains_key(aarg.id);\n+            // Overwrite the llargs entry for locally mutated params\n+            // with a local alloca.\n+            if mutated {\n+                let aptr = bcx.fcx.llargs.get(aarg.id);\n+                let {bcx, val: alloc} = alloc_ty(bcx, arg_ty);\n+                bcx = copy_val(bcx, INIT, alloc,\n+                               load_if_immediate(bcx, aptr, arg_ty), arg_ty);\n+                bcx.fcx.llargs.insert(aarg.id, alloc);\n+                add_clean(scope, alloc, arg_ty);\n             }\n           }\n           ast::move. {\n@@ -5027,7 +4987,7 @@ fn trans_closure(bcx_maybe: &option::t<@block_ctxt>,\n     let block_ty = node_id_type(cx.ccx, f.body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys);\n+    copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys, false);\n \n     // Figure out if we need to build a closure and act accordingly\n     let res =\n@@ -5175,7 +5135,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     }\n     let arg_tys = arg_tys_of_fn(cx.ccx, variant.node.id);\n     let bcx = new_top_block_ctxt(fcx);\n-    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n     let lltop = bcx.llbb;\n \n     // Cast the tag to a type we can GEP into.\n@@ -5389,9 +5349,15 @@ fn create_main_wrapper(ccx: &@crate_ctxt, sp: &span, main_llfn: ValueRef,\n         let lloutputarg = llvm::LLVMGetParam(llfdecl, 0u);\n         let lltaskarg = llvm::LLVMGetParam(llfdecl, 1u);\n         let llenvarg = llvm::LLVMGetParam(llfdecl, 2u);\n-        let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n         let args = [lloutputarg, lltaskarg, llenvarg];\n-        if takes_argv { args += [llargvarg]; }\n+        if takes_argv {\n+            let llargvarg = llvm::LLVMGetParam(llfdecl, 3u);\n+            // The runtime still passes the arg vector by value, this kludge\n+            // makes sure it becomes a pointer (to a pointer to a vec).\n+            let minus_ptr = llvm::LLVMGetElementType(val_ty(llargvarg));\n+            llargvarg = PointerCast(bcx, llargvarg, minus_ptr);\n+            args += [do_spill_noroot(bcx, llargvarg)];\n+        }\n         FastCall(bcx, main_llfn, args);\n         build_return(bcx);\n \n@@ -5616,6 +5582,9 @@ fn decl_native_fn_and_pair(ccx: &@crate_ctxt, sp: &span, path: &[str],\n     let i = arg_n;\n     for arg: ty::arg in args {\n         let llarg = llvm::LLVMGetParam(fcx.llfn, i);\n+        if arg.mode == ty::mo_val {\n+            llarg = load_if_immediate(bcx, llarg, arg.ty);\n+        }\n         assert (llarg as int != 0);\n         if cast_to_i32 {\n             let llarg_i32 = convert_arg_to_i32(bcx, llarg, arg.ty, arg.mode);\n@@ -5981,8 +5950,8 @@ fn write_abi_version(ccx: &@crate_ctxt) {\n }\n \n fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n-               output: &str, amap: &ast_map::map, mut_map: mut::mut_map) ->\n-   ModuleRef {\n+               output: &str, amap: &ast_map::map, mut_map: mut::mut_map,\n+               copy_map: alias::copy_map) -> ModuleRef {\n     let llmod =\n         str::as_buf(\"rust_out\", {|buf|\n             llvm::LLVMModuleCreateWithNameInContext(\n@@ -6039,6 +6008,7 @@ fn trans_crate(sess: &session::session, crate: &@ast::crate, tcx: &ty::ctxt,\n           type_short_names: short_names,\n           tcx: tcx,\n           mut_map: mut_map,\n+          copy_map: copy_map,\n           stats:\n               {mutable n_static_tydescs: 0u,\n                mutable n_derived_tydescs: 0u,"}, {"sha": "9247135cdec2fcf57e56dc3b18a320c4092bee7e", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -144,6 +144,7 @@ type crate_ctxt =\n      type_short_names: hashmap<ty::t, str>,\n      tcx: ty::ctxt,\n      mut_map: mut::mut_map,\n+     copy_map: alias::copy_map,\n      stats: stats,\n      upcalls: @upcall::upcalls,\n      rust_object_type: TypeRef,"}, {"sha": "ca1740df0349e3b14ff87023a109351f27239b21", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -63,7 +63,7 @@ fn trans_obj(cx: @local_ctxt, sp: &span, ob: &ast::_obj,\n                               ty::ret_ty_of_fn(ccx.tcx, ctor_id), fn_args,\n                               ty_params);\n     let arg_tys: [ty::arg] = arg_tys_of_fn(ccx, ctor_id);\n-    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n+    copy_args_to_allocas(fcx, bcx, fn_args, arg_tys, true);\n \n     // Pick up the type of this object by looking at our own output type, that\n     // is, the output type of the object constructor we're building."}, {"sha": "95d4270831e71eca98d03beec5637d00fe9edaae", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4be7e1e5cd10646acc814da147f4e91dd610d45a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=4be7e1e5cd10646acc814da147f4e91dd610d45a", "patch": "@@ -155,6 +155,7 @@ export type_is_box;\n export type_is_boxed;\n export type_is_vec;\n export type_is_fp;\n+export type_allows_implicit_copy;\n export type_is_integral;\n export type_is_native;\n export type_is_nil;\n@@ -167,6 +168,7 @@ export type_is_copyable;\n export type_is_tup_like;\n export type_is_str;\n export type_is_unique;\n+export type_structurally_contains_uniques;\n export type_autoderef;\n export type_param;\n export unify;\n@@ -1161,6 +1163,34 @@ pure fn type_has_dynamic_size(cx: &ctxt, ty: t) -> bool {\n     }\n }\n \n+// Returns true for types where a copy of a value can be distinguished from\n+// the value itself. I.e. types with mutable content that's not shared through\n+// a pointer.\n+fn type_allows_implicit_copy(cx: &ctxt, ty: t) -> bool {\n+    ret !type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n+        ret alt sty {\n+          ty_param(_, _) { true }\n+          ty_vec(mt) { mt.mut != ast::imm }\n+          ty_rec(fields) {\n+            for field in fields { if field.mt.mut != ast::imm { ret true; } }\n+            false\n+          }\n+          _ { false }\n+        };\n+    });\n+}\n+\n+fn type_structurally_contains_uniques(cx: &ctxt, ty: t) -> bool {\n+    ret type_structurally_contains(cx, ty, fn(sty: &sty) -> bool {\n+        ret alt sty {\n+          ty_uniq(_) { ret true; }\n+          ty_vec(_) { true }\n+          ty_str. { true }\n+          _ { ret false; }\n+        };\n+    });\n+}\n+\n fn type_is_integral(cx: &ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_int. { ret true; }"}]}