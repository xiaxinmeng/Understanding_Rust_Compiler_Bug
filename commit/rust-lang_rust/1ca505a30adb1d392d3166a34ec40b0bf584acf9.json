{"sha": "1ca505a30adb1d392d3166a34ec40b0bf584acf9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjYTUwNWEzMGFkYjFkMzkyZDMxNjZhMzRlYzQwYjBiZjU4NGFjZjk=", "commit": {"author": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-11-14T16:41:16Z"}, "committer": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2018-11-14T16:53:02Z"}, "message": "capture_disjoint_fields(rust-lang#53488)\n\nJust running RustFmt on upvar.rs", "tree": {"sha": "675f1a2dd3a870f70b98387a9f9fbb4854c8c4b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675f1a2dd3a870f70b98387a9f9fbb4854c8c4b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ca505a30adb1d392d3166a34ec40b0bf584acf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ca505a30adb1d392d3166a34ec40b0bf584acf9", "html_url": "https://github.com/rust-lang/rust/commit/1ca505a30adb1d392d3166a34ec40b0bf584acf9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ca505a30adb1d392d3166a34ec40b0bf584acf9/comments", "author": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f244c9011eb01ae4d167b631ba5e3e163bafa72", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f244c9011eb01ae4d167b631ba5e3e163bafa72", "html_url": "https://github.com/rust-lang/rust/commit/6f244c9011eb01ae4d167b631ba5e3e163bafa72"}], "stats": {"total": 144, "additions": 72, "deletions": 72}, "files": [{"sha": "ef29e13d9fe123848e705abc7ddb8e93dbd65f75", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/1ca505a30adb1d392d3166a34ec40b0bf584acf9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ca505a30adb1d392d3166a34ec40b0bf584acf9/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=1ca505a30adb1d392d3166a34ec40b0bf584acf9", "patch": "@@ -45,14 +45,14 @@ use super::FnCtxt;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n+use rustc::hir::def_id::LocalDefId;\n+use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::infer::UpvarRegion;\n+use rustc::ty::{self, Ty, TyCtxt, UpvarSubsts};\n use syntax::ast;\n use syntax_pos::Span;\n-use rustc::hir;\n-use rustc::hir::def_id::LocalDefId;\n-use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn closure_analyze(&self, body: &'gcx hir::Body) {\n@@ -121,7 +121,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs{\n+        let infer_kind = if let UpvarSubsts::Closure(closure_substs) = substs {\n             if self.closure_kind(closure_def_id, closure_substs).is_none() {\n                 Some(closure_substs)\n             } else {\n@@ -213,12 +213,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let final_upvar_tys = self.final_upvar_tys(closure_node_id);\n         debug!(\n             \"analyze_closure: id={:?} substs={:?} final_upvar_tys={:?}\",\n-            closure_node_id,\n-            substs,\n-            final_upvar_tys\n+            closure_node_id, substs, final_upvar_tys\n         );\n-        for (upvar_ty, final_upvar_ty) in substs.upvar_tys(closure_def_id, self.tcx)\n-                                                .zip(final_upvar_tys)\n+        for (upvar_ty, final_upvar_ty) in substs\n+            .upvar_tys(closure_def_id, self.tcx)\n+            .zip(final_upvar_tys)\n         {\n             self.demand_suptype(span, upvar_ty, final_upvar_ty);\n         }\n@@ -256,9 +255,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                     debug!(\n                         \"var_id={:?} freevar_ty={:?} capture={:?}\",\n-                        var_node_id,\n-                        freevar_ty,\n-                        capture\n+                        var_node_id, freevar_ty, capture\n                     );\n \n                     match capture {\n@@ -271,8 +268,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             },\n                         ),\n                     }\n-                })\n-                .collect()\n+                }).collect()\n         })\n     }\n }\n@@ -301,12 +297,14 @@ struct InferBorrowKind<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n-    fn adjust_upvar_borrow_kind_for_consume(&mut self, cmt: &mc::cmt_<'tcx>,\n-                                            mode: euv::ConsumeMode) {\n+    fn adjust_upvar_borrow_kind_for_consume(\n+        &mut self,\n+        cmt: &mc::cmt_<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\n             \"adjust_upvar_borrow_kind_for_consume(cmt={:?}, mode={:?})\",\n-            cmt,\n-            mode\n+            cmt, mode\n         );\n \n         // we only care about moves\n@@ -381,9 +379,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique) |\n-            Categorization::Interior(base, _) |\n-            Categorization::Downcast(base, _) => {\n+            Categorization::Deref(base, mc::Unique)\n+            | Categorization::Interior(base, _)\n+            | Categorization::Downcast(base, _) => {\n                 // Interior or owned data is mutable if base is\n                 // mutable, so iterate to the base.\n                 self.adjust_upvar_borrow_kind_for_mut(&base);\n@@ -399,12 +397,12 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, mc::UnsafePtr(..)) |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Rvalue(..) |\n-            Categorization::Local(_) |\n-            Categorization::Upvar(..) => {\n+            Categorization::Deref(_, mc::UnsafePtr(..))\n+            | Categorization::StaticItem\n+            | Categorization::ThreadLocal(..)\n+            | Categorization::Rvalue(..)\n+            | Categorization::Local(_)\n+            | Categorization::Upvar(..) => {\n                 return;\n             }\n         }\n@@ -414,9 +412,9 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={:?})\", cmt);\n \n         match cmt.cat.clone() {\n-            Categorization::Deref(base, mc::Unique) |\n-            Categorization::Interior(base, _) |\n-            Categorization::Downcast(base, _) => {\n+            Categorization::Deref(base, mc::Unique)\n+            | Categorization::Interior(base, _)\n+            | Categorization::Downcast(base, _) => {\n                 // Interior or owned data is unique if base is\n                 // unique.\n                 self.adjust_upvar_borrow_kind_for_unique(&base);\n@@ -430,18 +428,20 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Categorization::Deref(_, mc::UnsafePtr(..)) |\n-            Categorization::StaticItem |\n-            Categorization::ThreadLocal(..) |\n-            Categorization::Rvalue(..) |\n-            Categorization::Local(_) |\n-            Categorization::Upvar(..) => {}\n+            Categorization::Deref(_, mc::UnsafePtr(..))\n+            | Categorization::StaticItem\n+            | Categorization::ThreadLocal(..)\n+            | Categorization::Rvalue(..)\n+            | Categorization::Local(_)\n+            | Categorization::Upvar(..) => {}\n         }\n     }\n \n-    fn try_adjust_upvar_deref(&mut self, cmt: &mc::cmt_<'tcx>, borrow_kind: ty::BorrowKind)\n-                              -> bool\n-    {\n+    fn try_adjust_upvar_deref(\n+        &mut self,\n+        cmt: &mc::cmt_<'tcx>,\n+        borrow_kind: ty::BorrowKind,\n+    ) -> bool {\n         assert!(match borrow_kind {\n             ty::MutBorrow => true,\n             ty::UniqueImmBorrow => true,\n@@ -493,15 +493,14 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     /// Here the argument `mutbl` is the borrow_kind that is required by\n     /// some particular use.\n     fn adjust_upvar_borrow_kind(&mut self, upvar_id: ty::UpvarId, kind: ty::BorrowKind) {\n-        let upvar_capture = self.adjust_upvar_captures\n+        let upvar_capture = self\n+            .adjust_upvar_captures\n             .get(&upvar_id)\n             .cloned()\n             .unwrap_or_else(|| self.fcx.tables.borrow().upvar_capture(upvar_id));\n         debug!(\n             \"adjust_upvar_borrow_kind(upvar_id={:?}, upvar_capture={:?}, kind={:?})\",\n-            upvar_id,\n-            upvar_capture,\n-            kind\n+            upvar_id, upvar_capture, kind\n         );\n \n         match upvar_capture {\n@@ -511,18 +510,18 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n             ty::UpvarCapture::ByRef(mut upvar_borrow) => {\n                 match (upvar_borrow.kind, kind) {\n                     // Take RHS:\n-                    (ty::ImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::ImmBorrow, ty::MutBorrow) |\n-                    (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+                    (ty::ImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::ImmBorrow, ty::MutBorrow)\n+                    | (ty::UniqueImmBorrow, ty::MutBorrow) => {\n                         upvar_borrow.kind = kind;\n                         self.adjust_upvar_captures\n                             .insert(upvar_id, ty::UpvarCapture::ByRef(upvar_borrow));\n                     }\n                     // Take LHS:\n-                    (ty::ImmBorrow, ty::ImmBorrow) |\n-                    (ty::UniqueImmBorrow, ty::ImmBorrow) |\n-                    (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n-                    (ty::MutBorrow, _) => {}\n+                    (ty::ImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::ImmBorrow)\n+                    | (ty::UniqueImmBorrow, ty::UniqueImmBorrow)\n+                    | (ty::MutBorrow, _) => {}\n                 }\n             }\n         }\n@@ -537,10 +536,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"adjust_closure_kind(closure_id={:?}, new_kind={:?}, upvar_span={:?}, var_name={})\",\n-            closure_id,\n-            new_kind,\n-            upvar_span,\n-            var_name\n+            closure_id, new_kind, upvar_span, var_name\n         );\n \n         // Is this the closure whose kind is currently being inferred?\n@@ -554,22 +550,20 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n \n         debug!(\n             \"adjust_closure_kind: closure_id={:?}, existing_kind={:?}, new_kind={:?}\",\n-            closure_id,\n-            existing_kind,\n-            new_kind\n+            closure_id, existing_kind, new_kind\n         );\n \n         match (existing_kind, new_kind) {\n-            (ty::ClosureKind::Fn, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::Fn) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::FnOnce, _) => {\n+            (ty::ClosureKind::Fn, ty::ClosureKind::Fn)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::Fn)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut)\n+            | (ty::ClosureKind::FnOnce, _) => {\n                 // no change needed\n             }\n \n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) |\n-            (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n-            (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n+            (ty::ClosureKind::Fn, ty::ClosureKind::FnMut)\n+            | (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce)\n+            | (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                 // new kind is stronger than the old kind\n                 self.current_closure_kind = new_kind;\n                 self.current_origin = Some((upvar_span, var_name));\n@@ -590,12 +584,20 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n \n-    fn matched_pat(&mut self, _matched_pat: &hir::Pat, _cmt: &mc::cmt_<'tcx>,\n-                   _mode: euv::MatchMode) {\n+    fn matched_pat(\n+        &mut self,\n+        _matched_pat: &hir::Pat,\n+        _cmt: &mc::cmt_<'tcx>,\n+        _mode: euv::MatchMode,\n+    ) {\n     }\n \n-    fn consume_pat(&mut self, _consume_pat: &hir::Pat, cmt: &mc::cmt_<'tcx>,\n-                   mode: euv::ConsumeMode) {\n+    fn consume_pat(\n+        &mut self,\n+        _consume_pat: &hir::Pat,\n+        cmt: &mc::cmt_<'tcx>,\n+        mode: euv::ConsumeMode,\n+    ) {\n         debug!(\"consume_pat(cmt={:?},mode={:?})\", cmt, mode);\n         self.adjust_upvar_borrow_kind_for_consume(cmt, mode);\n     }\n@@ -611,9 +613,7 @@ impl<'a, 'gcx, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\n             \"borrow(borrow_id={}, cmt={:?}, bk={:?})\",\n-            borrow_id,\n-            cmt,\n-            bk\n+            borrow_id, cmt, bk\n         );\n \n         match bk {"}]}