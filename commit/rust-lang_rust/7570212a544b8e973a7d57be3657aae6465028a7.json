{"sha": "7570212a544b8e973a7d57be3657aae6465028a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NzAyMTJhNTQ0YjhlOTczYTdkNTdiZTM2NTdhYWU2NDY1MDI4YTc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-04-18T23:08:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-18T23:08:44Z"}, "message": "Merge #8569\n\n8569: Support inherent impls in unnamed consts r=jonas-schievink a=jonas-schievink\n\nIt turns out that some proc. macros not only generate *trait* impls wrapped in `const _: () = { ... };`, but inherent impls too. Even though it is questionable whether *custom derives* should produce non-trait impls, this is useful for procedural attribute macros once we support them.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "9f01d4563413e95e0b743b991f2a6ff522db889d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f01d4563413e95e0b743b991f2a6ff522db889d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7570212a544b8e973a7d57be3657aae6465028a7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgfLv8CRBK7hj4Ov3rIwAAuuwIAF8c4VE2G0TChQjWO6/etp6D\ntJVwqIVS5KrNrJY8iqTTjar3TrcqtA8CxH7EixgmrkgaBgf/7RT6InreID2YJl3V\nc+Sc5dYzdFc71tUq8huIyT4bdwZz0QuLwh4s4yVw1ekTTr/Wlcw0YToon1K0Iru5\n4StUQyS7stYOMJTVG4sibje+2YxPpzg2U8PckGQmZNiHtevq0GADuhWCusVU1caw\nbwku4CDu1q1KbfcNJko9PxXlXt8JDA9aT2DgmhPe8gZBFsdAXTMfCrAD6syZeONf\n1ERL8HUFqM4sT+Z8BfwN/qvDXrz1iUdMNYj00rgYPJxXcAuqSCz97C74W9OILuQ=\n=lakd\n-----END PGP SIGNATURE-----\n", "payload": "tree 9f01d4563413e95e0b743b991f2a6ff522db889d\nparent d39873e88b12b6c6c56bed530500baf07bf3391f\nparent 20c27dbdbe3116be205d66af88e6f5ac88b862d3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1618787324 +0000\ncommitter GitHub <noreply@github.com> 1618787324 +0000\n\nMerge #8569\n\n8569: Support inherent impls in unnamed consts r=jonas-schievink a=jonas-schievink\n\nIt turns out that some proc. macros not only generate *trait* impls wrapped in `const _: () = { ... };`, but inherent impls too. Even though it is questionable whether *custom derives* should produce non-trait impls, this is useful for procedural attribute macros once we support them.\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7570212a544b8e973a7d57be3657aae6465028a7", "html_url": "https://github.com/rust-lang/rust/commit/7570212a544b8e973a7d57be3657aae6465028a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7570212a544b8e973a7d57be3657aae6465028a7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d39873e88b12b6c6c56bed530500baf07bf3391f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d39873e88b12b6c6c56bed530500baf07bf3391f", "html_url": "https://github.com/rust-lang/rust/commit/d39873e88b12b6c6c56bed530500baf07bf3391f"}, {"sha": "20c27dbdbe3116be205d66af88e6f5ac88b862d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/20c27dbdbe3116be205d66af88e6f5ac88b862d3", "html_url": "https://github.com/rust-lang/rust/commit/20c27dbdbe3116be205d66af88e6f5ac88b862d3"}], "stats": {"total": 101, "additions": 83, "deletions": 18}, "files": [{"sha": "5ac1670b55ea10bea3054bb580388a3a9fb62b01", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=7570212a544b8e973a7d57be3657aae6465028a7", "patch": "@@ -108,6 +108,18 @@ impl ModuleId {\n     pub fn containing_module(&self, db: &dyn db::DefDatabase) -> Option<ModuleId> {\n         self.def_map(db).containing_module(self.local_id)\n     }\n+\n+    /// Returns `true` if this module represents a block expression.\n+    ///\n+    /// Returns `false` if this module is a submodule *inside* a block expression\n+    /// (eg. `m` in `{ mod m {} }`).\n+    pub fn is_block_root(&self, db: &dyn db::DefDatabase) -> bool {\n+        if self.block.is_none() {\n+            return false;\n+        }\n+\n+        self.def_map(db)[self.local_id].parent.is_none()\n+    }\n }\n \n /// An ID of a module, **local** to a specific crate"}, {"sha": "d4b7c9970cea457c4e37d9fee306f384ba2b2442", "filename": "crates/hir_def/src/visibility.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fvisibility.rs?ref=7570212a544b8e973a7d57be3657aae6465028a7", "patch": "@@ -123,11 +123,19 @@ impl Visibility {\n         def_map: &DefMap,\n         mut from_module: crate::LocalModuleId,\n     ) -> bool {\n-        let to_module = match self {\n+        let mut to_module = match self {\n             Visibility::Module(m) => m,\n             Visibility::Public => return true,\n         };\n \n+        // `to_module` might be the root module of a block expression. Those have the same\n+        // visibility as the containing module (even though no items are directly nameable from\n+        // there, getting this right is important for method resolution).\n+        // In that case, we adjust the visibility of `to_module` to point to the containing module.\n+        if to_module.is_block_root(db) {\n+            to_module = to_module.containing_module(db).unwrap();\n+        }\n+\n         // from_module needs to be a descendant of to_module\n         let mut def_map = def_map;\n         let mut parent_arc;"}, {"sha": "48bbcfd9ffada0e2cfeb6605a7dc7008ef09903c", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=7570212a544b8e973a7d57be3657aae6465028a7", "patch": "@@ -246,29 +246,39 @@ pub struct InherentImpls {\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let mut map: FxHashMap<_, Vec<_>> = FxHashMap::default();\n+        let mut impls = Self { map: FxHashMap::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n-        for (_module_id, module_data) in crate_def_map.modules() {\n-            for impl_id in module_data.scope.impls() {\n-                let data = db.impl_data(impl_id);\n-                if data.target_trait.is_some() {\n-                    continue;\n+        collect_def_map(db, &crate_def_map, &mut impls);\n+\n+        return Arc::new(impls);\n+\n+        fn collect_def_map(db: &dyn HirDatabase, def_map: &DefMap, impls: &mut InherentImpls) {\n+            for (_module_id, module_data) in def_map.modules() {\n+                for impl_id in module_data.scope.impls() {\n+                    let data = db.impl_data(impl_id);\n+                    if data.target_trait.is_some() {\n+                        continue;\n+                    }\n+\n+                    let self_ty = db.impl_self_ty(impl_id);\n+                    let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n+                    if let Some(fp) = fp {\n+                        impls.map.entry(fp).or_default().push(impl_id);\n+                    }\n+                    // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n                 }\n \n-                let self_ty = db.impl_self_ty(impl_id);\n-                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n-                if let Some(fp) = fp {\n-                    map.entry(fp).or_default().push(impl_id);\n+                // To better support custom derives, collect impls in all unnamed const items.\n+                // const _: () = { ... };\n+                for konst in module_data.scope.unnamed_consts() {\n+                    let body = db.body(konst.into());\n+                    for (_, block_def_map) in body.blocks(db.upcast()) {\n+                        collect_def_map(db, &block_def_map, impls);\n+                    }\n                 }\n-                // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n             }\n         }\n-\n-        // NOTE: We're not collecting inherent impls from unnamed consts here, we intentionally only\n-        // support trait impls there.\n-\n-        Arc::new(Self { map })\n     }\n \n     pub fn for_self_ty(&self, self_ty: &Ty) -> &[ImplId] {"}, {"sha": "a4c132bc5f206143e0c85543f6346a184fd89887", "filename": "crates/hir_ty/src/tests/method_resolution.rs", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7570212a544b8e973a7d57be3657aae6465028a7/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=7570212a544b8e973a7d57be3657aae6465028a7", "patch": "@@ -1294,7 +1294,7 @@ mod b {\n }\n \n #[test]\n-fn impl_in_unnamed_const() {\n+fn trait_impl_in_unnamed_const() {\n     check_types(\n         r#\"\n struct S;\n@@ -1314,3 +1314,38 @@ fn f() {\n     \"#,\n     );\n }\n+\n+#[test]\n+fn inherent_impl_in_unnamed_const() {\n+    check_types(\n+        r#\"\n+struct S;\n+\n+const _: () = {\n+    impl S {\n+        fn method(&self) -> u16 { 0 }\n+\n+        pub(super) fn super_method(&self) -> u16 { 0 }\n+\n+        pub(crate) fn crate_method(&self) -> u16 { 0 }\n+\n+        pub fn pub_method(&self) -> u16 { 0 }\n+    }\n+};\n+\n+fn f() {\n+    S.method();\n+  //^^^^^^^^^^ u16\n+\n+    S.super_method();\n+  //^^^^^^^^^^^^^^^^ u16\n+\n+    S.crate_method();\n+  //^^^^^^^^^^^^^^^^ u16\n+\n+    S.pub_method();\n+  //^^^^^^^^^^^^^^ u16\n+}\n+    \"#,\n+    );\n+}"}]}