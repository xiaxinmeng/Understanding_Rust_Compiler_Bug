{"sha": "1436fea271e3df5db241e1ff3b879ef48c38beed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MzZmZWEyNzFlM2RmNWRiMjQxZTFmZjNiODc5ZWY0OGMzOGJlZWQ=", "commit": {"author": {"name": "Jeremy Stucki", "email": "stucki.jeremy@gmail.com", "date": "2019-08-23T12:20:55Z"}, "committer": {"name": "Jeremy Stucki", "email": "stucki.jeremy@gmail.com", "date": "2019-08-23T12:20:55Z"}, "message": "Refactor 'check_impl_item'", "tree": {"sha": "ebb045e03dabc6d26c8d7617fc5e234d3652e951", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebb045e03dabc6d26c8d7617fc5e234d3652e951"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1436fea271e3df5db241e1ff3b879ef48c38beed", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEnLVrz+MJS3aQxZ9oj1SKWi7RP1gFAl1f2icACgkQj1SKWi7R\nP1iP4Q//eOJ62cF6ft+nsTRpEFEtkdKd0R86JnltukBU1s3GhSqhNjBHVC+dSpH0\nvTTOs3YqK8rvEO6Wee2mqXUKYA9tU1/gPp1lKeUrqk5a5FmpY2qVq6Ed5aDyd50J\nNyFmc1SCkPg/+JyS/pK3ns0JixEIOi/UsQsjOKtr5MS8CqUIDn+bzIBlttBlItUN\nE9hM6WsUODK3Gq71+oEOVSR9IMlSdmffrhVvWbHnLkYC3nzAQMHULbxckrft6b5d\n2d/NHWt/S86+PB9MT9QoC3RnWfSx4Xts9+sJvDhAY2fGeyfDrvLPpt9TRSYt0Bkk\n4XRDqgAgcjrmzxF3ikUYiHckjiI5Z1ZdJXJTXS3rPN6xlRiWN9IkmdI26BmUUb76\nAouey92lgkh6JVDd0N8z70Y/DAsRF/Gs4vlYlEk3WV8geZK8o+hR2huZ2N27XwVO\nYCpIlACeex/XXt3A3lsgw2X79x7N07V7LZqxdUSlCA5oeqXg3cIUZe5Ojcy+OZkW\nGtFNNkYXsVjbteVyeZLj7/CedjkxG2ZCfVpaR7q3VifKDk3Yyv/OHDgy55JhqKLA\nicUnTF8hAdsEn1B4Hf16QJbHl+BxIisPSqQLwXGpe3mpUdP0ZxXiHkpOH82myNdq\nEoO7vcagxLIyEDsQkaA74kRgfpjP1xCT/LqIG3Xt4g4VosODciM=\n=XMn2\n-----END PGP SIGNATURE-----", "payload": "tree ebb045e03dabc6d26c8d7617fc5e234d3652e951\nparent 7a118438537c3be82d64389fddafbcfc22ef4dd3\nauthor Jeremy Stucki <stucki.jeremy@gmail.com> 1566562855 +0200\ncommitter Jeremy Stucki <stucki.jeremy@gmail.com> 1566562855 +0200\n\nRefactor 'check_impl_item'\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1436fea271e3df5db241e1ff3b879ef48c38beed", "html_url": "https://github.com/rust-lang/rust/commit/1436fea271e3df5db241e1ff3b879ef48c38beed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1436fea271e3df5db241e1ff3b879ef48c38beed/comments", "author": {"login": "jeremystucki", "id": 7629727, "node_id": "MDQ6VXNlcjc2Mjk3Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/7629727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeremystucki", "html_url": "https://github.com/jeremystucki", "followers_url": "https://api.github.com/users/jeremystucki/followers", "following_url": "https://api.github.com/users/jeremystucki/following{/other_user}", "gists_url": "https://api.github.com/users/jeremystucki/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeremystucki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeremystucki/subscriptions", "organizations_url": "https://api.github.com/users/jeremystucki/orgs", "repos_url": "https://api.github.com/users/jeremystucki/repos", "events_url": "https://api.github.com/users/jeremystucki/events{/privacy}", "received_events_url": "https://api.github.com/users/jeremystucki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jeremystucki", "id": 7629727, "node_id": "MDQ6VXNlcjc2Mjk3Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/7629727?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jeremystucki", "html_url": "https://github.com/jeremystucki", "followers_url": "https://api.github.com/users/jeremystucki/followers", "following_url": "https://api.github.com/users/jeremystucki/following{/other_user}", "gists_url": "https://api.github.com/users/jeremystucki/gists{/gist_id}", "starred_url": "https://api.github.com/users/jeremystucki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jeremystucki/subscriptions", "organizations_url": "https://api.github.com/users/jeremystucki/orgs", "repos_url": "https://api.github.com/users/jeremystucki/repos", "events_url": "https://api.github.com/users/jeremystucki/events{/privacy}", "received_events_url": "https://api.github.com/users/jeremystucki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a118438537c3be82d64389fddafbcfc22ef4dd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a118438537c3be82d64389fddafbcfc22ef4dd3", "html_url": "https://github.com/rust-lang/rust/commit/7a118438537c3be82d64389fddafbcfc22ef4dd3"}], "stats": {"total": 97, "additions": 48, "deletions": 49}, "files": [{"sha": "25f80996a11cfb6ea1f017b495a22d552247df50", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 48, "deletions": 49, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/1436fea271e3df5db241e1ff3b879ef48c38beed/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1436fea271e3df5db241e1ff3b879ef48c38beed/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=1436fea271e3df5db241e1ff3b879ef48c38beed", "patch": "@@ -1075,56 +1075,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             if let hir::ImplItemKind::Method(ref sig, id) = impl_item.node;\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, _, _) = item.node;\n+\n+            let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n+            let method_sig = cx.tcx.fn_sig(method_def_id);\n+            let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n+\n+            let first_arg_ty = &method_sig.inputs().iter().next();\n+\n+            // check conventions w.r.t. conversion method names and predicates\n+            if let Some(first_arg_ty) = first_arg_ty;\n+\n             then {\n-                let method_def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);\n-                let method_sig = cx.tcx.fn_sig(method_def_id);\n-                let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n-\n-                let first_arg_ty = &method_sig.inputs().iter().next();\n-\n-                // check conventions w.r.t. conversion method names and predicates\n-                if let Some(first_arg_ty) = first_arg_ty {\n-\n-                    if cx.access_levels.is_exported(impl_item.hir_id) {\n-                    // check missing trait implementations\n-                        for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                            if name == method_name &&\n-                            sig.decl.inputs.len() == n_args &&\n-                            out_type.matches(cx, &sig.decl.output) &&\n-                            self_kind.matches(cx, ty, first_arg_ty) {\n-                                span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n-                                    \"defining a method called `{}` on this type; consider implementing \\\n-                                    the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n-                            }\n+                if cx.access_levels.is_exported(impl_item.hir_id) {\n+                // check missing trait implementations\n+                    for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                        if name == method_name &&\n+                        sig.decl.inputs.len() == n_args &&\n+                        out_type.matches(cx, &sig.decl.output) &&\n+                        self_kind.matches(cx, ty, first_arg_ty) {\n+                            span_lint(cx, SHOULD_IMPLEMENT_TRAIT, impl_item.span, &format!(\n+                                \"defining a method called `{}` on this type; consider implementing \\\n+                                the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n                         }\n                     }\n+                }\n \n-                    for &(ref conv, self_kinds) in &CONVENTIONS {\n-                        if conv.check(&name) {\n-                            if !self_kinds\n-                                    .iter()\n-                                    .any(|k| k.matches(cx, ty, first_arg_ty)) {\n-                                let lint = if item.vis.node.is_pub() {\n-                                    WRONG_PUB_SELF_CONVENTION\n-                                } else {\n-                                    WRONG_SELF_CONVENTION\n-                                };\n-                                span_lint(cx,\n-                                          lint,\n-                                          first_arg.pat.span,\n-                                          &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                                    ambiguous name\",\n-                                                   conv,\n-                                                   &self_kinds.iter()\n-                                                              .map(|k| k.description())\n-                                                              .collect::<Vec<_>>()\n-                                                              .join(\" or \")));\n-                            }\n+                if let Some((ref conv, self_kinds)) = &CONVENTIONS\n+                    .iter()\n+                    .find(|(ref conv, _)| conv.check(&name))\n+                {\n+                    if !self_kinds.iter().any(|k| k.matches(cx, ty, first_arg_ty)) {\n+                        let lint = if item.vis.node.is_pub() {\n+                            WRONG_PUB_SELF_CONVENTION\n+                        } else {\n+                            WRONG_SELF_CONVENTION\n+                        };\n \n-                            // Only check the first convention to match (CONVENTIONS should be listed from most to least\n-                            // specific)\n-                            break;\n-                        }\n+                        span_lint(\n+                            cx,\n+                            lint,\n+                            first_arg.pat.span,\n+                            &format!(\n+                               \"methods called `{}` usually take {}; consider choosing a less \\\n+                                 ambiguous name\",\n+                                conv,\n+                                &self_kinds\n+                                    .iter()\n+                                    .map(|k| k.description())\n+                                    .collect::<Vec<_>>()\n+                                    .join(\" or \")\n+                            ),\n+                        );\n                     }\n                 }\n             }\n@@ -1134,10 +1135,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n             let ret_ty = return_ty(cx, impl_item.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n-            for inner_type in ret_ty.walk() {\n-                if same_tys(cx, ty, inner_type) {\n-                    return;\n-                }\n+            if ret_ty.walk().any(|inner_type| same_tys(cx, ty, inner_type)) {\n+                return;\n             }\n \n             // if return type is impl trait, check the associated types"}]}