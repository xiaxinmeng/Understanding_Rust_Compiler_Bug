{"sha": "960893c50a61e6eec6635d8f18b586e3ce0865d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2MDg5M2M1MGE2MWU2ZWVjNjYzNWQ4ZjE4YjU4NmUzY2UwODY1ZDk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-07-20T11:59:12Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-09-14T11:56:33Z"}, "message": "Store DefPathHash->DefIndex map in on-disk-hash-table format in crate metadata.\n\nThis encoding allows for random access without an expensive upfront decoding\nstate which in turn allows simplifying the DefPathIndex lookup logic without\nregressing performance.", "tree": {"sha": "a1a2dbb96b4aac12a51ee017c4063b9be7a3d0f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1a2dbb96b4aac12a51ee017c4063b9be7a3d0f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/960893c50a61e6eec6635d8f18b586e3ce0865d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/960893c50a61e6eec6635d8f18b586e3ce0865d9", "html_url": "https://github.com/rust-lang/rust/commit/960893c50a61e6eec6635d8f18b586e3ce0865d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/960893c50a61e6eec6635d8f18b586e3ce0865d9/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0be27c8ec448e4dd10dfa0f290ffe1bf997de5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0be27c8ec448e4dd10dfa0f290ffe1bf997de5f", "html_url": "https://github.com/rust-lang/rust/commit/d0be27c8ec448e4dd10dfa0f290ffe1bf997de5f"}], "stats": {"total": 275, "additions": 131, "deletions": 144}, "files": [{"sha": "48d8cdf57dcfcd348421a3c0f7f1a145b55ea984", "filename": "compiler/rustc_metadata/src/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fcreader.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -45,7 +45,7 @@ pub struct CStore {\n \n     /// This map is used to verify we get no hash conflicts between\n     /// `StableCrateId` values.\n-    stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n+    pub(crate) stable_crate_ids: FxHashMap<StableCrateId, CrateNum>,\n \n     /// Unused externs of the crate\n     unused_externs: Vec<Symbol>,"}, {"sha": "d925e3102f2b71d84ce708004d4dddd7b1c7c866", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 18, "deletions": 57, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -95,10 +95,8 @@ crate struct CrateMetadata {\n     raw_proc_macros: Option<&'static [ProcMacro]>,\n     /// Source maps for code from the crate.\n     source_map_import_info: OnceCell<Vec<ImportedSourceFile>>,\n-    /// For every definition in this crate, maps its `DefPathHash` to its\n-    /// `DefIndex`. See `raw_def_id_to_def_id` for more details about how\n-    /// this is used.\n-    def_path_hash_map: OnceCell<UnhashMap<DefPathHash, DefIndex>>,\n+    /// For every definition in this crate, maps its `DefPathHash` to its `DefIndex`.\n+    def_path_hash_map: DefPathHashMap<'static>,\n     /// Likewise for ExpnHash.\n     expn_hash_map: OnceCell<UnhashMap<ExpnHash, ExpnIndex>>,\n     /// Used for decoding interpret::AllocIds in a cached & thread-safe manner.\n@@ -320,6 +318,11 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n         self.lazy_state = LazyState::Previous(NonZeroUsize::new(position + min_size).unwrap());\n         Ok(Lazy::from_position_and_meta(NonZeroUsize::new(position).unwrap(), meta))\n     }\n+\n+    #[inline]\n+    pub fn read_raw_bytes(&mut self, len: usize) -> &'a [u8] {\n+        self.opaque.read_raw_bytes(len)\n+    }\n }\n \n impl<'a, 'tcx> TyDecoder<'tcx> for DecodeContext<'a, 'tcx> {\n@@ -1596,58 +1599,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .or_insert_with(|| self.root.tables.def_keys.get(self, index).unwrap().decode(self))\n     }\n \n-    /// Finds the corresponding `DefId` for the provided `DefPathHash`, if it exists.\n-    /// This is used by incremental compilation to map a serialized `DefPathHash` to\n-    /// its `DefId` in the current session.\n-    /// Normally, only one 'main' crate will change between incremental compilation sessions:\n-    /// all dependencies will be completely unchanged. In this case, we can avoid\n-    /// decoding every `DefPathHash` in the crate, since the `DefIndex` from the previous\n-    /// session will still be valid. If our 'guess' is wrong (the `DefIndex` no longer exists,\n-    /// or has a different `DefPathHash`, then we need to decode all `DefPathHashes` to determine\n-    /// the correct mapping).\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        krate: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId> {\n-        let def_index_guess = DefIndex::from_u32(index_guess);\n-        let old_hash = self\n-            .root\n-            .tables\n-            .def_path_hashes\n-            .get(self, def_index_guess)\n-            .map(|lazy| lazy.decode(self));\n-\n-        // Fast path: the definition and its index is unchanged from the\n-        // previous compilation session. There is no need to decode anything\n-        // else\n-        if old_hash == Some(hash) {\n-            return Some(DefId { krate, index: def_index_guess });\n-        }\n-\n-        let is_proc_macro = self.is_proc_macro_crate();\n-\n-        // Slow path: We need to find out the new `DefIndex` of the provided\n-        // `DefPathHash`, if its still exists. This requires decoding every `DefPathHash`\n-        // stored in this crate.\n-        let map = self.cdata.def_path_hash_map.get_or_init(|| {\n-            let end_id = self.root.tables.def_path_hashes.size() as u32;\n-            let mut map = UnhashMap::with_capacity_and_hasher(end_id as usize, Default::default());\n-            for i in 0..end_id {\n-                let def_index = DefIndex::from_u32(i);\n-                // There may be gaps in the encoded table if we're decoding a proc-macro crate\n-                if let Some(hash) = self.root.tables.def_path_hashes.get(self, def_index) {\n-                    map.insert(hash.decode(self), def_index);\n-                } else if !is_proc_macro {\n-                    panic!(\"Missing def_path_hashes entry for {:?}\", def_index);\n-                }\n-            }\n-            map\n-        });\n-        map.get(&hash).map(|index| DefId { krate, index: *index })\n-    }\n-\n     // Returns the path leading to the thing with this `id`.\n     fn def_path(&self, id: DefIndex) -> DefPath {\n         debug!(\"def_path(cnum={:?}, id={:?})\", self.cnum, id);\n@@ -1670,6 +1621,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         self.def_path_hash_unlocked(index, &mut def_path_hashes)\n     }\n \n+    #[inline]\n+    fn def_path_hash_to_def_index(&self, hash: DefPathHash) -> Option<DefIndex> {\n+        self.def_path_hash_map.def_path_hash_to_def_index(&hash)\n+    }\n+\n     fn expn_hash_to_expn_id(&self, index_guess: u32, hash: ExpnHash) -> ExpnId {\n         debug_assert_eq!(ExpnId::from_hash(hash), None);\n         let index_guess = ExpnIndex::from_u32(index_guess);\n@@ -1936,13 +1892,18 @@ impl CrateMetadata {\n         let alloc_decoding_state =\n             AllocDecodingState::new(root.interpret_alloc_index.decode(&blob).collect());\n         let dependencies = Lock::new(cnum_map.iter().cloned().collect());\n+\n+        // Pre-decode the DefPathHash->DefIndex table. This is a cheap operation\n+        // that does not copy any data. It just does some data verification.\n+        let def_path_hash_map = root.def_path_hash_map.decode(&blob);\n+\n         CrateMetadata {\n             blob,\n             root,\n             trait_impls,\n             raw_proc_macros,\n             source_map_import_info: OnceCell::new(),\n-            def_path_hash_map: Default::default(),\n+            def_path_hash_map,\n             expn_hash_map: Default::default(),\n             alloc_decoding_state,\n             cnum,"}, {"sha": "4885de103a04a3e05914649b54390f2c60ee9532", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -498,6 +498,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(cnum).root.stable_crate_id\n     }\n \n+    fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum {\n+        self.stable_crate_ids[&stable_crate_id]\n+    }\n+\n     /// Returns the `DefKey` for a given `DefId`. This indicates the\n     /// parent `DefId` as well as some idea of what kind of data the\n     /// `DefId` refers to.\n@@ -513,14 +517,10 @@ impl CrateStore for CStore {\n         self.get_crate_data(def.krate).def_path_hash(def.index)\n     }\n \n-    // See `CrateMetadataRef::def_path_hash_to_def_id` for more details\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        cnum: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId> {\n-        self.get_crate_data(cnum).def_path_hash_to_def_id(cnum, index_guess, hash)\n+    fn def_path_hash_to_def_id(&self, cnum: CrateNum, hash: DefPathHash) -> Option<DefId> {\n+        self.get_crate_data(cnum)\n+            .def_path_hash_to_def_index(hash)\n+            .map(|index| DefId { krate: cnum, index })\n     }\n \n     fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId {"}, {"sha": "3f500fce33499a29a32ee0fed1ba758c6d556091", "filename": "compiler/rustc_metadata/src/rmeta/def_path_hash_map.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdef_path_hash_map.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -0,0 +1,60 @@\n+use crate::rmeta::DecodeContext;\n+use crate::rmeta::EncodeContext;\n+use crate::rmeta::MetadataBlob;\n+use rustc_data_structures::owning_ref::OwningRef;\n+use rustc_hir::def_path_hash_map::{\n+    Config as HashMapConfig, DefPathHashMap as DefPathHashMapInner,\n+};\n+use rustc_serialize::{opaque, Decodable, Decoder, Encodable, Encoder};\n+use rustc_span::def_id::{DefIndex, DefPathHash};\n+\n+crate enum DefPathHashMap<'tcx> {\n+    OwnedFromMetadata(odht::HashTable<HashMapConfig, OwningRef<MetadataBlob, [u8]>>),\n+    BorrowedFromTcx(&'tcx DefPathHashMapInner),\n+}\n+\n+impl DefPathHashMap<'tcx> {\n+    #[inline]\n+    pub fn def_path_hash_to_def_index(&self, def_path_hash: &DefPathHash) -> Option<DefIndex> {\n+        match *self {\n+            DefPathHashMap::OwnedFromMetadata(ref map) => map.get(def_path_hash),\n+            DefPathHashMap::BorrowedFromTcx(_) => {\n+                panic!(\"DefPathHashMap::BorrowedFromTcx variant only exists for serialization\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for DefPathHashMap<'tcx> {\n+    fn encode(&self, e: &mut EncodeContext<'a, 'tcx>) -> opaque::EncodeResult {\n+        match *self {\n+            DefPathHashMap::BorrowedFromTcx(def_path_hash_map) => {\n+                let bytes = def_path_hash_map.raw_bytes();\n+                e.emit_usize(bytes.len())?;\n+                e.emit_raw_bytes(bytes)\n+            }\n+            DefPathHashMap::OwnedFromMetadata(_) => {\n+                panic!(\"DefPathHashMap::OwnedFromMetadata variant only exists for deserialization\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for DefPathHashMap<'static> {\n+    fn decode(d: &mut DecodeContext<'a, 'tcx>) -> Result<DefPathHashMap<'static>, String> {\n+        // Import TyDecoder so we can access the DecodeContext::position() method\n+        use crate::rustc_middle::ty::codec::TyDecoder;\n+\n+        let len = d.read_usize()?;\n+        let pos = d.position();\n+        let o = OwningRef::new(d.blob().clone()).map(|x| &x[pos..pos + len]);\n+\n+        // Although we already have the data we need via the OwningRef, we still need\n+        // to advance the DecodeContext's position so it's in a valid state after\n+        // the method. We use read_raw_bytes() for that.\n+        let _ = d.read_raw_bytes(len);\n+\n+        let inner = odht::HashTable::from_raw_bytes(o).map_err(|e| format!(\"{}\", e))?;\n+        Ok(DefPathHashMap::OwnedFromMetadata(inner))\n+    }\n+}"}, {"sha": "5a901e33df9452eb3997b1cb2cfa5de28bb8ae87", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -1,3 +1,4 @@\n+use crate::rmeta::def_path_hash_map::DefPathHashMap;\n use crate::rmeta::table::{FixedSizeEncoding, TableBuilder};\n use crate::rmeta::*;\n \n@@ -472,6 +473,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n+    fn encode_def_path_hash_map(&mut self) -> Lazy<DefPathHashMap<'tcx>> {\n+        self.lazy(DefPathHashMap::BorrowedFromTcx(\n+            self.tcx.resolutions(()).definitions.def_path_hash_to_def_index_map(),\n+        ))\n+    }\n+\n     fn encode_source_map(&mut self) -> Lazy<[rustc_span::SourceFile]> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n@@ -675,6 +682,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let (syntax_contexts, expn_data, expn_hashes) = self.encode_hygiene();\n         let hygiene_bytes = self.position() - i;\n \n+        i = self.position();\n+        let def_path_hash_map = self.encode_def_path_hash_map();\n+        let def_path_hash_map_bytes = self.position() - i;\n+\n         // Encode source_map. This needs to be done last,\n         // since encoding `Span`s tells us which `SourceFiles` we actually\n         // need to encode.\n@@ -722,6 +733,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             syntax_contexts,\n             expn_data,\n             expn_hashes,\n+            def_path_hash_map,\n         });\n \n         let total_bytes = self.position();\n@@ -744,6 +756,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             eprintln!(\"            impl bytes: {}\", impl_bytes);\n             eprintln!(\"    exp. symbols bytes: {}\", exported_symbols_bytes);\n             eprintln!(\"  def-path table bytes: {}\", def_path_table_bytes);\n+            eprintln!(\" def-path hashes bytes: {}\", def_path_hash_map_bytes);\n             eprintln!(\" proc-macro-data-bytes: {}\", proc_macro_data_bytes);\n             eprintln!(\"             mir bytes: {}\", mir_bytes);\n             eprintln!(\"            item bytes: {}\", item_bytes);"}, {"sha": "d47537b86ab58b4347adf2b0a34c000c2bd9b077", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -1,4 +1,5 @@\n use decoder::Metadata;\n+use def_path_hash_map::DefPathHashMap;\n use table::{Table, TableBuilder};\n \n use rustc_ast::{self as ast, MacroDef};\n@@ -35,6 +36,7 @@ use encoder::EncodeContext;\n use rustc_span::hygiene::SyntaxContextData;\n \n mod decoder;\n+mod def_path_hash_map;\n mod encoder;\n mod table;\n \n@@ -231,6 +233,8 @@ crate struct CrateRoot<'tcx> {\n     expn_data: ExpnDataTable,\n     expn_hashes: ExpnHashTable,\n \n+    def_path_hash_map: Lazy<DefPathHashMap<'tcx>>,\n+\n     source_map: Lazy<[rustc_span::SourceFile]>,\n \n     compiler_builtins: bool,"}, {"sha": "b66260c5de36d08c3da9ee0f7374cb75b2fc2772", "filename": "compiler/rustc_middle/src/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fcstore.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -199,14 +199,10 @@ pub trait CrateStore: std::fmt::Debug {\n     // incr.  comp. uses to identify a CrateNum.\n     fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn stable_crate_id(&self, cnum: CrateNum) -> StableCrateId;\n+    fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum;\n \n     /// Fetch a DefId from a DefPathHash for a foreign crate.\n-    fn def_path_hash_to_def_id(\n-        &self,\n-        cnum: CrateNum,\n-        index_guess: u32,\n-        hash: DefPathHash,\n-    ) -> Option<DefId>;\n+    fn def_path_hash_to_def_id(&self, cnum: CrateNum, hash: DefPathHash) -> Option<DefId>;\n     fn expn_hash_to_expn_id(&self, cnum: CrateNum, index_guess: u32, hash: ExpnHash) -> ExpnId;\n \n     // utility functions"}, {"sha": "224a01c4ab663b898c1d95928cf14949c054d5d8", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -1316,6 +1316,17 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n+    /// Maps a StableCrateId to the corresponding CrateNum. This method assumes\n+    /// that the crate in question has already been loaded by the CrateStore.\n+    #[inline]\n+    pub fn stable_crate_id_to_crate_num(self, stable_crate_id: StableCrateId) -> CrateNum {\n+        if stable_crate_id == self.sess.local_stable_crate_id() {\n+            LOCAL_CRATE\n+        } else {\n+            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+        }\n+    }\n+\n     pub fn def_path_debug_str(self, def_id: DefId) -> String {\n         // We are explicitly not going through queries here in order to get\n         // crate name and stable crate id since this code is called from debug!()"}, {"sha": "ddba6e5ae7aac9a25f181dd85ea7b9333e1d1fe4", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 14, "deletions": 72, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/960893c50a61e6eec6635d8f18b586e3ce0865d9/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=960893c50a61e6eec6635d8f18b586e3ce0865d9", "patch": "@@ -25,7 +25,6 @@ use rustc_span::hygiene::{\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n use rustc_span::{BytePos, ExpnData, ExpnHash, Pos, SourceFile, Span};\n-use std::collections::hash_map::Entry;\n use std::mem;\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n@@ -414,79 +413,22 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n     }\n \n     fn def_path_hash_to_def_id(&self, tcx: TyCtxt<'tcx>, hash: DefPathHash) -> Option<DefId> {\n-        let mut cache = self.def_path_hash_to_def_id_cache.lock();\n-        match cache.entry(hash) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                debug!(\"def_path_hash_to_def_id({:?})\", hash);\n-                // Check if the `DefPathHash` corresponds to a definition in the current\n-                // crate\n-                if let Some(def_id) =\n-                    tcx.definitions_untracked().local_def_path_hash_to_def_id(hash)\n-                {\n-                    let def_id = def_id.to_def_id();\n-                    e.insert(Some(def_id));\n-                    return Some(def_id);\n-                }\n-                // This `raw_def_id` represents the `DefId` of this `DefPathHash` in\n-                // the *previous* compliation session. The `DefPathHash` includes the\n-                // owning crate, so if the corresponding definition still exists in the\n-                // current compilation session, the crate is guaranteed to be the same\n-                // (otherwise, we would compute a different `DefPathHash`).\n-                let raw_def_id = self.get_raw_def_id(&hash)?;\n-                debug!(\"def_path_hash_to_def_id({:?}): raw_def_id = {:?}\", hash, raw_def_id);\n-                // If the owning crate no longer exists, the corresponding definition definitely\n-                // no longer exists.\n-                let krate = self.try_remap_cnum(tcx, hash.stable_crate_id())?;\n-                debug!(\"def_path_hash_to_def_id({:?}): krate = {:?}\", hash, krate);\n-                // If our `DefPathHash` corresponded to a definition in the local crate,\n-                // we should have either found it in `local_def_path_hash_to_def_id`, or\n-                // never attempted to load it in the first place. Any query result or `DepNode`\n-                // that references a local `DefId` should depend on some HIR-related `DepNode`.\n-                // If a local definition is removed/modified such that its old `DefPathHash`\n-                // no longer has a corresponding definition, that HIR-related `DepNode` should\n-                // end up red. This should prevent us from ever calling\n-                // `tcx.def_path_hash_to_def_id`, since we'll end up recomputing any\n-                // queries involved.\n-                debug_assert_ne!(krate, LOCAL_CRATE);\n-                // Try to find a definition in the current session, using the previous `DefIndex`\n-                // as an initial guess.\n-                let opt_def_id =\n-                    tcx.cstore_untracked().def_path_hash_to_def_id(krate, raw_def_id.index, hash);\n-                debug!(\"def_path_to_def_id({:?}): opt_def_id = {:?}\", hash, opt_def_id);\n-                e.insert(opt_def_id);\n-                opt_def_id\n-            }\n-        }\n-    }\n+        debug!(\"def_path_hash_to_def_id({:?})\", hash);\n \n-    fn register_reused_dep_node(&self, tcx: TyCtxt<'sess>, dep_node: &DepNode) {\n-        // For reused dep nodes, we only need to store the mapping if the node\n-        // is one whose query key we can reconstruct from the hash. We use the\n-        // mapping to aid that reconstruction in the next session. While we also\n-        // use it to decode `DefId`s we encoded in the cache as `DefPathHashes`,\n-        // they're already registered during `DefId` encoding.\n-        if dep_node.kind.can_reconstruct_query_key() {\n-            let hash = DefPathHash(dep_node.hash.into());\n-\n-            // We can't simply copy the `RawDefId` from `foreign_def_path_hashes` to\n-            // `latest_foreign_def_path_hashes`, since the `RawDefId` might have\n-            // changed in the current compilation session (e.g. we've added/removed crates,\n-            // or added/removed definitions before/after the target definition).\n-            if let Some(def_id) = self.def_path_hash_to_def_id(tcx, hash) {\n-                if !def_id.is_local() {\n-                    self.store_foreign_def_id_hash(def_id, hash);\n-                }\n-            }\n-        }\n-    }\n+        let stable_crate_id = hash.stable_crate_id();\n \n-    fn store_foreign_def_id_hash(&self, def_id: DefId, hash: DefPathHash) {\n-        // We may overwrite an existing entry, but it will have the same value,\n-        // so it's fine\n-        self.latest_foreign_def_path_hashes\n-            .lock()\n-            .insert(hash, RawDefId { krate: def_id.krate.as_u32(), index: def_id.index.as_u32() });\n+        // If this is a DefPathHash from the local crate, we can look up the\n+        // DefId in the tcx's `Definitions`.\n+        if stable_crate_id == tcx.sess.local_stable_crate_id() {\n+            tcx.definitions_untracked()\n+                .local_def_path_hash_to_def_id(hash)\n+                .map(LocalDefId::to_def_id)\n+        } else {\n+            // If this is a DefPathHash from an upstream crate, let the CrateStore map\n+            // it to a DefId.\n+            let cnum = tcx.cstore_untracked().stable_crate_id_to_crate_num(stable_crate_id);\n+            tcx.cstore_untracked().def_path_hash_to_def_id(cnum, hash)\n+        }\n     }\n }\n "}]}