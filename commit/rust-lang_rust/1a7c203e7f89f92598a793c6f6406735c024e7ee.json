{"sha": "1a7c203e7f89f92598a793c6f6406735c024e7ee", "node_id": "C_kwDOAAsO6NoAKDFhN2MyMDNlN2Y4OWY5MjU5OGE3OTNjNmY2NDA2NzM1YzAyNGU3ZWU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-09T21:02:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-09T21:02:33Z"}, "message": "Auto merge of #89123 - the8472:push_in_capacity, r=amanieu\n\nadd Vec::push_within_capacity - fallible, does not allocate\n\nThis method can serve several purposes. It\n\n* is fallible\n* guarantees that items in Vec aren't moved\n* allows loops that do `reserve` and `push` separately to avoid pulling in the allocation machinery a second time in the `push` part which should make things easier on the optimizer\n* eases the path towards `ArrayVec` a bit since - compared to `push()` - there are fewer questions around how it should be implemented\n\nI haven't named it `try_push` because that should probably occupy a middle ground that will still try to reserve and only return an error in the unlikely OOM case.\n\nresolves #84649", "tree": {"sha": "092e5362232165047754ef24ff91a0a242790bbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/092e5362232165047754ef24ff91a0a242790bbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a7c203e7f89f92598a793c6f6406735c024e7ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a7c203e7f89f92598a793c6f6406735c024e7ee", "html_url": "https://github.com/rust-lang/rust/commit/1a7c203e7f89f92598a793c6f6406735c024e7ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a7c203e7f89f92598a793c6f6406735c024e7ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81f391930301afbc121b7c468138069daa354bf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/81f391930301afbc121b7c468138069daa354bf8", "html_url": "https://github.com/rust-lang/rust/commit/81f391930301afbc121b7c468138069daa354bf8"}, {"sha": "bb74f97445f04d68e42e7e308a109f78a2d2b0f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb74f97445f04d68e42e7e308a109f78a2d2b0f7", "html_url": "https://github.com/rust-lang/rust/commit/bb74f97445f04d68e42e7e308a109f78a2d2b0f7"}], "stats": {"total": 45, "additions": 45, "deletions": 0}, "files": [{"sha": "b2bb7a5b2e65906b762a991b70b0e4005a82dd4e", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/1a7c203e7f89f92598a793c6f6406735c024e7ee/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a7c203e7f89f92598a793c6f6406735c024e7ee/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=1a7c203e7f89f92598a793c6f6406735c024e7ee", "patch": "@@ -1839,6 +1839,51 @@ impl<T, A: Allocator> Vec<T, A> {\n         }\n     }\n \n+    /// Appends an element if there is sufficient spare capacity, otherwise an error is returned\n+    /// with the element.\n+    ///\n+    /// Unlike [`push`] this method will not reallocate when there's insufficient capacity.\n+    /// The caller should use [`reserve`] or [`try_reserve`] to ensure that there is enough capacity.\n+    ///\n+    /// [`push`]: Vec::push\n+    /// [`reserve`]: Vec::reserve\n+    /// [`try_reserve`]: Vec::try_reserve\n+    ///\n+    /// # Examples\n+    ///\n+    /// A manual, panic-free alternative to [`FromIterator`]:\n+    ///\n+    /// ```\n+    /// #![feature(vec_push_within_capacity)]\n+    ///\n+    /// use std::collections::TryReserveError;\n+    /// fn from_iter_fallible<T>(iter: impl Iterator<Item=T>) -> Result<Vec<T>, TryReserveError> {\n+    ///     let mut vec = Vec::new();\n+    ///     for value in iter {\n+    ///         if let Err(value) = vec.push_within_capacity(value) {\n+    ///             vec.try_reserve(1)?;\n+    ///             // this cannot fail, the previous line either returned or added at least 1 free slot\n+    ///             let _ = vec.push_within_capacity(value);\n+    ///         }\n+    ///     }\n+    ///     Ok(vec)\n+    /// }\n+    /// assert_eq!(from_iter_fallible(0..100), Ok(Vec::from_iter(0..100)));\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"vec_push_within_capacity\", issue = \"100486\")]\n+    pub fn push_within_capacity(&mut self, value: T) -> Result<(), T> {\n+        if self.len == self.buf.capacity() {\n+            return Err(value);\n+        }\n+        unsafe {\n+            let end = self.as_mut_ptr().add(self.len);\n+            ptr::write(end, value);\n+            self.len += 1;\n+        }\n+        Ok(())\n+    }\n+\n     /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///"}]}