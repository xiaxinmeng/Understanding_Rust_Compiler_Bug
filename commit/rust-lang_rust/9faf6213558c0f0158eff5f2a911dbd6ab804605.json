{"sha": "9faf6213558c0f0158eff5f2a911dbd6ab804605", "node_id": "C_kwDOAAsO6NoAKDlmYWY2MjEzNTU4YzBmMDE1OGVmZjVmMmE5MTFkYmQ2YWI4MDQ2MDU", "commit": {"author": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2021-08-07T10:11:59Z"}, "committer": {"name": "Beno\u00eet du Garreau", "email": "bdgdlm@outlook.com", "date": "2021-10-01T17:09:52Z"}, "message": "Add methods to add/sub `uX` to/from `iX`", "tree": {"sha": "e9156b722a10d25f0e5539a979b1435d388a0bec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9156b722a10d25f0e5539a979b1435d388a0bec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9faf6213558c0f0158eff5f2a911dbd6ab804605", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9faf6213558c0f0158eff5f2a911dbd6ab804605", "html_url": "https://github.com/rust-lang/rust/commit/9faf6213558c0f0158eff5f2a911dbd6ab804605", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9faf6213558c0f0158eff5f2a911dbd6ab804605/comments", "author": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "a1phyr", "id": 47725341, "node_id": "MDQ6VXNlcjQ3NzI1MzQx", "avatar_url": "https://avatars.githubusercontent.com/u/47725341?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a1phyr", "html_url": "https://github.com/a1phyr", "followers_url": "https://api.github.com/users/a1phyr/followers", "following_url": "https://api.github.com/users/a1phyr/following{/other_user}", "gists_url": "https://api.github.com/users/a1phyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/a1phyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a1phyr/subscriptions", "organizations_url": "https://api.github.com/users/a1phyr/orgs", "repos_url": "https://api.github.com/users/a1phyr/repos", "events_url": "https://api.github.com/users/a1phyr/events{/privacy}", "received_events_url": "https://api.github.com/users/a1phyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5dd5227ee7785174f006a5281622c52533c6075", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5dd5227ee7785174f006a5281622c52533c6075", "html_url": "https://github.com/rust-lang/rust/commit/b5dd5227ee7785174f006a5281622c52533c6075"}], "stats": {"total": 218, "additions": 204, "deletions": 14}, "files": [{"sha": "f41eeae9cc1faa53aa37b00890736d58ab7fd5d2", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=9faf6213558c0f0158eff5f2a911dbd6ab804605", "patch": "@@ -142,6 +142,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(llvm_asm)]\n #![feature(min_specialization)]\n+#![feature(mixed_integer_ops)]\n #![cfg_attr(not(bootstrap), feature(must_not_suspend))]\n #![feature(negative_impls)]\n #![feature(never_type)]\n@@ -159,7 +160,6 @@\n #![feature(trait_alias)]\n #![feature(transparent_unions)]\n #![feature(try_blocks)]\n-#![feature(uint_add_signed)]\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]\n //"}, {"sha": "5f299687780ef74b275632ef878398d251f15c66", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=9faf6213558c0f0158eff5f2a911dbd6ab804605", "patch": "@@ -433,6 +433,28 @@ macro_rules! int_impl {\n             unsafe { intrinsics::unchecked_add(self, rhs) }\n         }\n \n+        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n+        /// returning `None` if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n+            let (a, b) = self.overflowing_add_unsigned(rhs);\n+            if unlikely!(b) {None} else {Some(a)}\n+        }\n+\n         /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n         /// overflow occurred.\n         ///\n@@ -479,6 +501,28 @@ macro_rules! int_impl {\n             unsafe { intrinsics::unchecked_sub(self, rhs) }\n         }\n \n+        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n+        /// returning `None` if overflow occurred.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n+            let (a, b) = self.overflowing_sub_unsigned(rhs);\n+            if unlikely!(b) {None} else {Some(a)}\n+        }\n+\n         /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n         /// overflow occurred.\n         ///\n@@ -822,6 +866,31 @@ macro_rules! int_impl {\n             intrinsics::saturating_add(self, rhs)\n         }\n \n+        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n+            // Overflow can only happen at the upper bound\n+            match self.checked_add_unsigned(rhs) {\n+                Some(x) => x,\n+                None => Self::MAX,\n+            }\n+        }\n+\n         /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n         /// numeric bounds instead of overflowing.\n         ///\n@@ -843,6 +912,31 @@ macro_rules! int_impl {\n             intrinsics::saturating_sub(self, rhs)\n         }\n \n+        /// Saturating substraction with an unsigned integer. Computes `self - rhs`,\n+        /// saturating at the numeric bounds instead of overflowing.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n+            // Overflow can only happen at the lower bound\n+            match self.checked_sub_unsigned(rhs) {\n+                Some(x) => x,\n+                None => Self::MIN,\n+            }\n+        }\n+\n         /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n         /// instead of overflowing.\n         ///\n@@ -998,6 +1092,27 @@ macro_rules! int_impl {\n             intrinsics::wrapping_add(self, rhs)\n         }\n \n+        /// Wrapping (modular) addition with an unsigned integer. Computes\n+        /// `self + rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline(always)]\n+        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n+            self.wrapping_add(rhs as Self)\n+        }\n+\n         /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n         /// boundary of the type.\n         ///\n@@ -1018,6 +1133,27 @@ macro_rules! int_impl {\n             intrinsics::wrapping_sub(self, rhs)\n         }\n \n+        /// Wrapping (modular) substraction with an unsigned integer. Computes\n+        /// `self - rhs`, wrapping around at the boundary of the type.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n+        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline(always)]\n+        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n+            self.wrapping_sub(rhs as Self)\n+        }\n+\n         /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n         /// the boundary of the type.\n         ///\n@@ -1368,6 +1504,33 @@ macro_rules! int_impl {\n             (sum as $SelfT, carry)\n         }\n \n+        /// Calculates `self` + `rhs` with an unsigned `rhs`\n+        ///\n+        /// Returns a tuple of the addition along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n+            let rhs = rhs as Self;\n+            let (res, overflowed) = self.overflowing_add(rhs);\n+            (res, overflowed ^ (rhs < 0))\n+        }\n+\n         /// Calculates `self` - `rhs`\n         ///\n         /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n@@ -1419,6 +1582,33 @@ macro_rules! int_impl {\n             (sum as $SelfT, borrow)\n         }\n \n+        /// Calculates `self` - `rhs` with an unsigned `rhs`\n+        ///\n+        /// Returns a tuple of the substraction along with a boolean indicating\n+        /// whether an arithmetic overflow would occur. If an overflow would\n+        /// have occurred then the wrapped value is returned.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(mixed_integer_ops)]\n+        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n+        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n+        /// ```\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n+            let rhs = rhs as Self;\n+            let (res, overflowed) = self.overflowing_sub(rhs);\n+            (res, overflowed ^ (rhs < 0))\n+        }\n+\n         /// Calculates the multiplication of `self` and `rhs`.\n         ///\n         /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow"}, {"sha": "5a65f77a87993059cf8bdec46925604131a5e13e", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=9faf6213558c0f0158eff5f2a911dbd6ab804605", "patch": "@@ -450,13 +450,13 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(uint_add_signed)]\n+        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n         /// ```\n-        #[unstable(feature = \"uint_add_signed\", issue = \"none\")]\n-        #[rustc_const_unstable(feature = \"uint_add_signed\", issue = \"none\")]\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1026,13 +1026,13 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(uint_add_signed)]\n+        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n         /// ```\n-        #[unstable(feature = \"uint_add_signed\", issue = \"none\")]\n-        #[rustc_const_unstable(feature = \"uint_add_signed\", issue = \"none\")]\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1168,13 +1168,13 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(uint_add_signed)]\n+        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n         /// ```\n-        #[unstable(feature = \"uint_add_signed\", issue = \"none\")]\n-        #[rustc_const_unstable(feature = \"uint_add_signed\", issue = \"none\")]\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]\n@@ -1517,13 +1517,13 @@ macro_rules! uint_impl {\n         /// Basic usage:\n         ///\n         /// ```\n-        /// # #![feature(uint_add_signed)]\n+        /// # #![feature(mixed_integer_ops)]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n         #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n         #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n         /// ```\n-        #[unstable(feature = \"uint_add_signed\", issue = \"none\")]\n-        #[rustc_const_unstable(feature = \"uint_add_signed\", issue = \"none\")]\n+        #[unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n+        #[rustc_const_unstable(feature = \"mixed_integer_ops\", issue = \"87840\")]\n         #[must_use = \"this returns the result of the operation, \\\n                       without modifying the original\"]\n         #[inline]"}, {"sha": "1781a3cb7c4021d5c3610af2a6c60b3ca948ea43", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9faf6213558c0f0158eff5f2a911dbd6ab804605/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9faf6213558c0f0158eff5f2a911dbd6ab804605", "patch": "@@ -297,6 +297,7 @@\n #![feature(maybe_uninit_slice)]\n #![feature(maybe_uninit_uninit_array)]\n #![feature(min_specialization)]\n+#![feature(mixed_integer_ops)]\n #![cfg_attr(not(bootstrap), feature(must_not_suspend))]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n@@ -333,7 +334,6 @@\n #![feature(try_blocks)]\n #![feature(try_reserve)]\n #![feature(try_reserve_kind)]\n-#![feature(uint_add_signed)]\n #![feature(unboxed_closures)]\n #![feature(unwrap_infallible)]\n #![feature(vec_into_raw_parts)]"}]}