{"sha": "0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MDViNGJmMmU2MDcwYTZlMmYxMDI2NjI0ZGVlODdiNjVlZTRlZDc=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-13T15:31:19Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-15T10:39:19Z"}, "message": "retag return places", "tree": {"sha": "757b1daf84c768bc8f6fab16c24fd97886a4bd9d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/757b1daf84c768bc8f6fab16c24fd97886a4bd9d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "html_url": "https://github.com/rust-lang/rust/commit/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90d71cd13f26c50f1d1904eb3b436c4e1faf7d2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/90d71cd13f26c50f1d1904eb3b436c4e1faf7d2c", "html_url": "https://github.com/rust-lang/rust/commit/90d71cd13f26c50f1d1904eb3b436c4e1faf7d2c"}], "stats": {"total": 59, "additions": 50, "deletions": 9}, "files": [{"sha": "94603c3dfb4d67f86f2e490f83d951702c3baae0", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "patch": "@@ -481,11 +481,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if ecx.memory.extra.stacked_borrows.is_none() {\n-            // No tracking.\n-            Ok(())\n-        } else {\n+        if ecx.memory.extra.stacked_borrows.is_some() {\n             ecx.retag(kind, place)\n+        } else {\n+            Ok(())\n         }\n     }\n \n@@ -502,6 +501,15 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(frame.with_extra(extra))\n     }\n \n+    #[inline(always)]\n+    fn after_stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        if ecx.memory.extra.stacked_borrows.is_some() {\n+            ecx.retag_return_place()\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "a69948002c1269e5a6c469a87cea70b7235a847d", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0805b4bf2e6070a6e2f1026624dee87b65ee4ed7/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=0805b4bf2e6070a6e2f1026624dee87b65ee4ed7", "patch": "@@ -11,7 +11,7 @@ use log::trace;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::RetagKind;\n use rustc_middle::ty;\n-use rustc_target::abi::Size;\n+use rustc_target::abi::{LayoutOf, Size};\n use rustc_hir::Mutability;\n \n use crate::*;\n@@ -569,7 +569,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n         protect: bool,\n-    ) -> InterpResult<'tcx, Immediate<Tag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n@@ -582,7 +582,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let place = this.mplace_access_checked(place)?;\n         if size == Size::ZERO {\n             // Nothing to do for ZSTs.\n-            return Ok(*val);\n+            return Ok(val);\n         }\n \n         // Compute new borrow.\n@@ -603,7 +603,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let new_place = place.replace_tag(new_tag);\n \n         // Return new pointer.\n-        Ok(new_place.to_ref())\n+        Ok(ImmTy::from_immediate(new_place.to_ref(), val.layout))\n     }\n }\n \n@@ -640,9 +640,42 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n             let val = this.retag_reference(val, mutbl, protector)?;\n-            this.write_immediate(val, place)?;\n+            this.write_immediate(*val, place)?;\n         }\n \n         Ok(())\n     }\n+\n+    /// After a stack frame got pushed, retag the return place so that we are sure\n+    /// it does not alias with anything.\n+    /// \n+    /// This is a HACK because there is nothing in MIR that would make the retag\n+    /// explicit. Also see https://github.com/rust-lang/rust/issues/71117.\n+    fn retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let return_place = if let Some(return_place) = this.frame_mut().return_place {\n+            return_place\n+        } else {\n+            // No return place, nothing to do.\n+            return Ok(());\n+        };\n+        if return_place.layout.is_zst() {\n+            // There may not be any memory here, nothing to do.\n+            return Ok(());\n+        }\n+        // We need this to be in-memory to use tagged pointers.\n+        let return_place = this.force_allocation(return_place)?;\n+\n+        // We have to turn the place into a pointer to use the existing code.\n+        // (The pointer type does not matter, so we use a raw pointer.)\n+        let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n+        let val = ImmTy::from_immediate(return_place.to_ref(), ptr_layout);\n+        // Reborrow it.\n+        let val = this.retag_reference(val, RefKind::Unique { two_phase: false }, /*protector*/ true)?;\n+        // And use reborrowed pointer for return place.\n+        let return_place = this.ref_to_mplace(val)?;\n+        this.frame_mut().return_place = Some(return_place.into());\n+\n+        Ok(())\n+    }\n }"}]}