{"sha": "ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYWZjYzBiNjZlMDRhYzQ3OTMzNjFkM2JkNjA0YzhjOGE5ZDE2YTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-06T01:15:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-06T01:15:37Z"}, "message": "Auto merge of #79650 - the8472:fix-take, r=dtolnay\n\nFix incorrect io::Take's limit resulting from io::copy specialization\n\nThe specialization introduced in #75272 fails to update `io::Take` wrappers after performing the copy syscalls which bypass those wrappers. The buffer flushing before the copy does update them correctly, but the bytes copied after the initial flush weren't subtracted.\n\nThe fix is to subtract the bytes copied from each `Take` in the chain of wrappers, even when an error occurs during the syscall loop. To do so the `CopyResult` enum now has to carry the bytes copied so far in the error case.", "tree": {"sha": "3699f48cb75d5e3bbd82ef32200dc7d2c3897a8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3699f48cb75d5e3bbd82ef32200dc7d2c3897a8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "html_url": "https://github.com/rust-lang/rust/commit/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bb0d481b5a9e78145f5644ec46015065fa83b4cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0d481b5a9e78145f5644ec46015065fa83b4cc", "html_url": "https://github.com/rust-lang/rust/commit/bb0d481b5a9e78145f5644ec46015065fa83b4cc"}, {"sha": "a9b1381b8dd0704966a5c2ab7e4ca0ff96d05a18", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9b1381b8dd0704966a5c2ab7e4ca0ff96d05a18", "html_url": "https://github.com/rust-lang/rust/commit/a9b1381b8dd0704966a5c2ab7e4ca0ff96d05a18"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "d1b0ad9e5f847cd34a7292ca5e7d0abab7ca8127", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "patch": "@@ -1211,7 +1211,8 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n     use super::kernel_copy::{copy_regular_files, CopyResult};\n \n     match copy_regular_files(reader.as_raw_fd(), writer.as_raw_fd(), max_len) {\n-        CopyResult::Ended(result) => result,\n+        CopyResult::Ended(bytes) => Ok(bytes),\n+        CopyResult::Error(e, _) => Err(e),\n         CopyResult::Fallback(written) => match io::copy::generic_copy(&mut reader, &mut writer) {\n             Ok(bytes) => Ok(bytes + written),\n             Err(e) => Err(e),"}, {"sha": "5bfac80315348b959a5671805ed0fcc115514459", "filename": "library/std/src/sys/unix/kernel_copy.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy.rs?ref=ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "patch": "@@ -167,10 +167,11 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n \n             if input_meta.copy_file_range_candidate() && output_meta.copy_file_range_candidate() {\n                 let result = copy_regular_files(readfd, writefd, max_write);\n+                result.update_take(reader);\n \n                 match result {\n-                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n+                    CopyResult::Error(e, _) => return Err(e),\n                     CopyResult::Fallback(bytes) => written += bytes,\n                 }\n             }\n@@ -182,20 +183,22 @@ impl<R: CopyRead, W: CopyWrite> SpecCopy for Copier<'_, '_, R, W> {\n             // fall back to the generic copy loop.\n             if input_meta.potential_sendfile_source() {\n                 let result = sendfile_splice(SpliceMode::Sendfile, readfd, writefd, max_write);\n+                result.update_take(reader);\n \n                 match result {\n-                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n+                    CopyResult::Error(e, _) => return Err(e),\n                     CopyResult::Fallback(bytes) => written += bytes,\n                 }\n             }\n \n             if input_meta.maybe_fifo() || output_meta.maybe_fifo() {\n                 let result = sendfile_splice(SpliceMode::Splice, readfd, writefd, max_write);\n+                result.update_take(reader);\n \n                 match result {\n-                    CopyResult::Ended(Ok(bytes_copied)) => return Ok(bytes_copied + written),\n-                    CopyResult::Ended(err) => return err,\n+                    CopyResult::Ended(bytes_copied) => return Ok(bytes_copied + written),\n+                    CopyResult::Error(e, _) => return Err(e),\n                     CopyResult::Fallback(0) => { /* use the fallback below */ }\n                     CopyResult::Fallback(_) => {\n                         unreachable!(\"splice should not return > 0 bytes on the fallback path\")\n@@ -225,6 +228,9 @@ trait CopyRead: Read {\n         Ok(0)\n     }\n \n+    /// Updates `Take` wrappers to remove the number of bytes copied.\n+    fn taken(&mut self, _bytes: u64) {}\n+\n     /// The minimum of the limit of all `Take<_>` wrappers, `u64::MAX` otherwise.\n     /// This method does not account for data `BufReader` buffers and would underreport\n     /// the limit of a `Take<BufReader<Take<_>>>` type. Thus its result is only valid\n@@ -251,6 +257,10 @@ where\n         (**self).drain_to(writer, limit)\n     }\n \n+    fn taken(&mut self, bytes: u64) {\n+        (**self).taken(bytes);\n+    }\n+\n     fn min_limit(&self) -> u64 {\n         (**self).min_limit()\n     }\n@@ -407,6 +417,11 @@ impl<T: CopyRead> CopyRead for Take<T> {\n         Ok(bytes_drained)\n     }\n \n+    fn taken(&mut self, bytes: u64) {\n+        self.set_limit(self.limit() - bytes);\n+        self.get_mut().taken(bytes);\n+    }\n+\n     fn min_limit(&self) -> u64 {\n         min(Take::limit(self), self.get_ref().min_limit())\n     }\n@@ -432,6 +447,10 @@ impl<T: CopyRead> CopyRead for BufReader<T> {\n         Ok(bytes as u64 + inner_bytes)\n     }\n \n+    fn taken(&mut self, bytes: u64) {\n+        self.get_mut().taken(bytes);\n+    }\n+\n     fn min_limit(&self) -> u64 {\n         self.get_ref().min_limit()\n     }\n@@ -457,10 +476,21 @@ fn fd_to_meta<T: AsRawFd>(fd: &T) -> FdMeta {\n }\n \n pub(super) enum CopyResult {\n-    Ended(Result<u64>),\n+    Ended(u64),\n+    Error(Error, u64),\n     Fallback(u64),\n }\n \n+impl CopyResult {\n+    fn update_take(&self, reader: &mut impl CopyRead) {\n+        match *self {\n+            CopyResult::Fallback(bytes)\n+            | CopyResult::Ended(bytes)\n+            | CopyResult::Error(_, bytes) => reader.taken(bytes),\n+        }\n+    }\n+}\n+\n /// linux-specific implementation that will attempt to use copy_file_range for copy offloading\n /// as the name says, it only works on regular files\n ///\n@@ -527,7 +557,7 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                 // - copying from an overlay filesystem in docker. reported to occur on fedora 32.\n                 return CopyResult::Fallback(0);\n             }\n-            Ok(0) => return CopyResult::Ended(Ok(written)), // reached EOF\n+            Ok(0) => return CopyResult::Ended(written), // reached EOF\n             Ok(ret) => written += ret as u64,\n             Err(err) => {\n                 return match err.raw_os_error() {\n@@ -545,12 +575,12 @@ pub(super) fn copy_regular_files(reader: RawFd, writer: RawFd, max_len: u64) ->\n                         assert_eq!(written, 0);\n                         CopyResult::Fallback(0)\n                     }\n-                    _ => CopyResult::Ended(Err(err)),\n+                    _ => CopyResult::Error(err, written),\n                 };\n             }\n         }\n     }\n-    CopyResult::Ended(Ok(written))\n+    CopyResult::Ended(written)\n }\n \n #[derive(PartialEq)]\n@@ -623,10 +653,10 @@ fn sendfile_splice(mode: SpliceMode, reader: RawFd, writer: RawFd, len: u64) ->\n                     Some(os_err) if mode == SpliceMode::Sendfile && os_err == libc::EOVERFLOW => {\n                         CopyResult::Fallback(written)\n                     }\n-                    _ => CopyResult::Ended(Err(err)),\n+                    _ => CopyResult::Error(err, written),\n                 };\n             }\n         }\n     }\n-    CopyResult::Ended(Ok(written))\n+    CopyResult::Ended(written)\n }"}, {"sha": "3937a1ffa38b5fee6d7271c3e6c755ca262cae52", "filename": "library/std/src/sys/unix/kernel_copy/tests.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fkernel_copy%2Ftests.rs?ref=ddafcc0b66e04ac4793361d3bd604c8c8a9d16a8", "patch": "@@ -42,8 +42,15 @@ fn copy_specialization() -> Result<()> {\n         assert_eq!(sink.buffer(), b\"wxyz\");\n \n         let copied = crate::io::copy(&mut source, &mut sink)?;\n-        assert_eq!(copied, 10);\n-        assert_eq!(sink.buffer().len(), 0);\n+        assert_eq!(copied, 10, \"copy obeyed limit imposed by Take\");\n+        assert_eq!(sink.buffer().len(), 0, \"sink buffer was flushed\");\n+        assert_eq!(source.limit(), 0, \"outer Take was exhausted\");\n+        assert_eq!(source.get_ref().buffer().len(), 0, \"source buffer should be drained\");\n+        assert_eq!(\n+            source.get_ref().get_ref().limit(),\n+            1,\n+            \"inner Take allowed reading beyond end of file, some bytes should be left\"\n+        );\n \n         let mut sink = sink.into_inner()?;\n         sink.seek(SeekFrom::Start(0))?;\n@@ -210,7 +217,7 @@ fn bench_socket_pipe_socket_copy(b: &mut test::Bencher) {\n     );\n \n     match probe {\n-        CopyResult::Ended(Ok(1)) => {\n+        CopyResult::Ended(1) => {\n             // splice works\n         }\n         _ => {"}]}