{"sha": "a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzM2I4MDhhYzBlYzM3YThlZjc4YjA1ODFiM2IwNjEyNzFjOTNhYjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-23T17:33:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-23T17:33:54Z"}, "message": "Auto merge of #25735 - oli-obk:rollup, r=steveklabnik\n\n- Successful merges: #25681, #25687, #25695, #25697, #25702, #25703, #25709, #25710, #25714, #25715, #25716, #25722\n- Failed merges:", "tree": {"sha": "6d539c03e398dec1e3b922521f025e135a1144f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d539c03e398dec1e3b922521f025e135a1144f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "html_url": "https://github.com/rust-lang/rust/commit/a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ee6820911d29b9abf0b0f0481d065bc6ae5f7d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ee6820911d29b9abf0b0f0481d065bc6ae5f7d6", "html_url": "https://github.com/rust-lang/rust/commit/4ee6820911d29b9abf0b0f0481d065bc6ae5f7d6"}, {"sha": "a650075f89d562766b97f5b845343e1a3e36a1d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/a650075f89d562766b97f5b845343e1a3e36a1d1", "html_url": "https://github.com/rust-lang/rust/commit/a650075f89d562766b97f5b845343e1a3e36a1d1"}], "stats": {"total": 601, "additions": 313, "deletions": 288}, "files": [{"sha": "efa836ca9764669d8b1b995a8b54a41cffcac16d", "filename": "configure", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/configure", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -1,7 +1,7 @@\n #!/bin/sh\n \n msg() {\n-    echo \"configure: $1\"\n+    echo \"configure: $*\"\n }\n \n step_msg() {\n@@ -33,8 +33,8 @@ need_ok() {\n \n need_cmd() {\n     if command -v $1 >/dev/null 2>&1\n-    then msg \"found program $1\"\n-    else err \"need program $1\"\n+    then msg \"found program '$1'\"\n+    else err \"program '$1' is missing, please install it\"\n     fi\n }\n \n@@ -986,7 +986,7 @@ then\n             | cut -d ' ' -f 2)\n \n         case $CFG_CLANG_VERSION in\n-            (3.2* | 3.3* | 3.4* | 3.5* | 3.6*)\n+            (3.2* | 3.3* | 3.4* | 3.5* | 3.6* | 3.7*)\n             step_msg \"found ok version of CLANG: $CFG_CLANG_VERSION\"\n             if [ -z \"$CC\" ]\n             then"}, {"sha": "8d1b93ce3c8b98cac0a83efc9f69cc20024174d2", "filename": "src/doc/reference.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -2003,6 +2003,10 @@ arbitrarily complex configurations through nesting.\n \n The following configurations must be defined by the implementation:\n \n+* `debug_assertions`. Enabled by default when compiling without optimizations.\n+  This can be used to enable extra debugging code in development but not in\n+  production.  For example, it controls the behavior of the standard library's\n+  `debug_assert!` macro.\n * `target_arch = \"...\"`. Target CPU architecture, such as `\"x86\"`, `\"x86_64\"`\n   `\"mips\"`, `\"powerpc\"`, `\"arm\"`, or `\"aarch64\"`.\n * `target_endian = \"...\"`. Endianness of the target CPU, either `\"little\"` or"}, {"sha": "7e37473ac8feaf1aeb2eb0c943d0593f6689753c", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -2,26 +2,28 @@\n \n For our second project, let\u2019s look at a classic concurrency problem. It\u2019s\n called \u2018the dining philosophers\u2019. It was originally conceived by Dijkstra in\n-1965, but we\u2019ll use the version from [this paper][paper] by Tony Hoare in 1985.\n+1965, but we\u2019ll use a lightly adapted version from [this paper][paper] by Tony\n+Hoare in 1985.\n \n [paper]: http://www.usingcsp.com/cspbook.pdf\n \n > In ancient times, a wealthy philanthropist endowed a College to accommodate\n-> five eminent philosophers. Each philosopher had a room in which she could\n-> engage in her professional activity of thinking; there was also a common\n+> five eminent philosophers. Each philosopher had a room in which they could\n+> engage in their professional activity of thinking; there was also a common\n > dining room, furnished with a circular table, surrounded by five chairs, each\n > labelled by the name of the philosopher who was to sit in it. They sat\n > anticlockwise around the table. To the left of each philosopher there was\n > laid a golden fork, and in the centre stood a large bowl of spaghetti, which\n-> was constantly replenished. A philosopher was expected to spend most of her\n-> time thinking; but when she felt hungry, she went to the dining room, sat down\n-> in her own chair, picked up her own fork on her left, and plunged it into the\n-> spaghetti. But such is the tangled nature of spaghetti that a second fork is\n-> required to carry it to the mouth. The philosopher therefore had also to pick\n-> up the fork on her right. When she was finished she would put down both her\n-> forks, get up from her chair, and continue thinking. Of course, a fork can be\n-> used by only one philosopher at a time. If the other philosopher wants it, she\n-> just has to wait until the fork is available again.\n+> was constantly replenished. A philosopher was expected to spend most of\n+> their time thinking; but when they felt hungry, they went to the dining\n+> room, sat down in their own chair, picked up their own fork on their left,\n+> and plunged it into the spaghetti. But such is the tangled nature of\n+> spaghetti that a second fork is required to carry it to the mouth. The\n+> philosopher therefore had also to pick up the fork on their right. When\n+> they were finished they would put down both their forks, get up from their\n+> chair, and continue thinking. Of course, a fork can be used by only one\n+> philosopher at a time. If the other philosopher wants it, they just have\n+> to wait until the fork is available again.\n \n This classic problem shows off a few different elements of concurrency. The\n reason is that it's actually slightly tricky to implement: a simple\n@@ -60,10 +62,10 @@ impl Philosopher {\n }\n \n fn main() {\n-    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p1 = Philosopher::new(\"Judith Butler\");\n     let p2 = Philosopher::new(\"Gilles Deleuze\");\n     let p3 = Philosopher::new(\"Karl Marx\");\n-    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p4 = Philosopher::new(\"Emma Goldman\");\n     let p5 = Philosopher::new(\"Michel Foucault\");\n }\n ```\n@@ -159,10 +161,10 @@ look at `main()` again:\n # }\n # \n fn main() {\n-    let p1 = Philosopher::new(\"Baruch Spinoza\");\n+    let p1 = Philosopher::new(\"Judith Butler\");\n     let p2 = Philosopher::new(\"Gilles Deleuze\");\n     let p3 = Philosopher::new(\"Karl Marx\");\n-    let p4 = Philosopher::new(\"Friedrich Nietzsche\");\n+    let p4 = Philosopher::new(\"Emma Goldman\");\n     let p5 = Philosopher::new(\"Michel Foucault\");\n }\n ```\n@@ -176,10 +178,10 @@ that `new()` function, it would look like this:\n #     name: String,\n # }\n fn main() {\n-    let p1 = Philosopher { name: \"Baruch Spinoza\".to_string() };\n+    let p1 = Philosopher { name: \"Judith Butler\".to_string() };\n     let p2 = Philosopher { name: \"Gilles Deleuze\".to_string() };\n     let p3 = Philosopher { name: \"Karl Marx\".to_string() };\n-    let p4 = Philosopher { name: \"Friedrich Nietzche\".to_string() };\n+    let p4 = Philosopher { name: \"Emma Goldman\".to_string() };\n     let p5 = Philosopher { name: \"Michel Foucault\".to_string() };\n }\n ```\n@@ -211,10 +213,10 @@ impl Philosopher {\n \n fn main() {\n     let philosophers = vec![\n-        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Judith Butler\"),\n         Philosopher::new(\"Gilles Deleuze\"),\n         Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Emma Goldman\"),\n         Philosopher::new(\"Michel Foucault\"),\n     ];\n \n@@ -247,10 +249,10 @@ mention they\u2019re done eating. Running this program should give you the followin\n output:\n \n ```text\n-Baruch Spinoza is done eating.\n+Judith Butler is done eating.\n Gilles Deleuze is done eating.\n Karl Marx is done eating.\n-Friedrich Nietzsche is done eating.\n+Emma Goldman is done eating.\n Michel Foucault is done eating.\n ```\n \n@@ -285,10 +287,10 @@ impl Philosopher {\n \n fn main() {\n     let philosophers = vec![\n-        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Judith Butler\"),\n         Philosopher::new(\"Gilles Deleuze\"),\n         Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Emma Goldman\"),\n         Philosopher::new(\"Michel Foucault\"),\n     ];\n \n@@ -323,14 +325,14 @@ simulate the time it takes a philosopher to eat.\n If you run this program, you should see each philosopher eat in turn:\n \n ```text\n-Baruch Spinoza is eating.\n-Baruch Spinoza is done eating.\n+Judith Butler is eating.\n+Judith Butler is done eating.\n Gilles Deleuze is eating.\n Gilles Deleuze is done eating.\n Karl Marx is eating.\n Karl Marx is done eating.\n-Friedrich Nietzsche is eating.\n-Friedrich Nietzsche is done eating.\n+Emma Goldman is eating.\n+Emma Goldman is done eating.\n Michel Foucault is eating.\n Michel Foucault is done eating.\n ```\n@@ -366,10 +368,10 @@ impl Philosopher {\n \n fn main() {\n     let philosophers = vec![\n-        Philosopher::new(\"Baruch Spinoza\"),\n+        Philosopher::new(\"Judith Butler\"),\n         Philosopher::new(\"Gilles Deleuze\"),\n         Philosopher::new(\"Karl Marx\"),\n-        Philosopher::new(\"Friedrich Nietzsche\"),\n+        Philosopher::new(\"Emma Goldman\"),\n         Philosopher::new(\"Michel Foucault\"),\n     ];\n \n@@ -458,11 +460,11 @@ We have multi-threading!\n ```text\n Gilles Deleuze is eating.\n Gilles Deleuze is done eating.\n-Friedrich Nietzsche is eating.\n-Friedrich Nietzsche is done eating.\n+Emma Goldman is eating.\n+Emma Goldman is done eating.\n Michel Foucault is eating.\n-Baruch Spinoza is eating.\n-Baruch Spinoza is done eating.\n+Judith Butler is eating.\n+Judith Butler is done eating.\n Karl Marx is eating.\n Karl Marx is done eating.\n Michel Foucault is done eating.\n@@ -532,10 +534,10 @@ fn main() {\n     ]});\n \n     let philosophers = vec![\n-        Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+        Philosopher::new(\"Judith Butler\", 0, 1),\n         Philosopher::new(\"Gilles Deleuze\", 1, 2),\n         Philosopher::new(\"Karl Marx\", 2, 3),\n-        Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+        Philosopher::new(\"Emma Goldman\", 3, 4),\n         Philosopher::new(\"Michel Foucault\", 0, 4),\n     ];\n \n@@ -643,10 +645,10 @@ count will go up, and when each thread ends, it will go back down.\n \n ```rust,ignore\n let philosophers = vec![\n-    Philosopher::new(\"Baruch Spinoza\", 0, 1),\n+    Philosopher::new(\"Judith Butler\", 0, 1),\n     Philosopher::new(\"Gilles Deleuze\", 1, 2),\n     Philosopher::new(\"Karl Marx\", 2, 3),\n-    Philosopher::new(\"Friedrich Nietzsche\", 3, 4),\n+    Philosopher::new(\"Emma Goldman\", 3, 4),\n     Philosopher::new(\"Michel Foucault\", 0, 4),\n ];\n ```\n@@ -679,12 +681,12 @@ and so you\u2019ll get some output like this:\n \n ```text\n Gilles Deleuze is eating.\n-Friedrich Nietzsche is eating.\n-Friedrich Nietzsche is done eating.\n+Emma Goldman is eating.\n+Emma Goldman is done eating.\n Gilles Deleuze is done eating.\n-Baruch Spinoza is eating.\n+Judith Butler is eating.\n Karl Marx is eating.\n-Baruch Spinoza is done eating.\n+Judith Butler is done eating.\n Michel Foucault is eating.\n Karl Marx is done eating.\n Michel Foucault is done eating."}, {"sha": "41d4146c9acdc3d191fb8dd22a5100f8330ebdbd", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -637,7 +637,7 @@ When we wrote `let guess = String::new()`, Rust was able to infer that `guess`\n should be a `String`, and so it doesn\u2019t make us write out the type. And with\n our `secret_number`, there are a number of types which can have a value\n between one and a hundred: `i32`, a thirty-two-bit number, or `u32`, an\n-unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number. Or others.\n+unsigned thirty-two-bit number, or `i64`, a sixty-four-bit number or others.\n So far, that hasn\u2019t mattered, and so Rust defaults to an `i32`. However, here,\n Rust doesn\u2019t know how to compare the `guess` and the `secret_number`. They\n need to be the same type. Ultimately, we want to convert the `String` we"}, {"sha": "1f660449593fb6fd46ba7e986a9622143f88eacd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -144,7 +144,7 @@\n //!     // At the end of the method, gadget_owner, gadget1 and gadget2 get\n //!     // destroyed. There are now no strong (`Rc<T>`) references to the gadgets.\n //!     // Once they get destroyed, the Gadgets get destroyed. This zeroes the\n-//!     // reference count on Gadget Man, so he gets destroyed as well.\n+//!     // reference count on Gadget Man, they get destroyed as well.\n //! }\n //! ```\n "}, {"sha": "d9a45872489a425428bb9ca7218b07fcd47794f6", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -1110,9 +1110,8 @@ impl str {\n     /// such as leaving a combining character as the first code point of the\n     /// string.\n     ///\n-    /// Due to the design of UTF-8, this operation is `O(end)`. See `slice`,\n-    /// `slice_to` and `slice_from` for `O(1)` variants that use byte indices\n-    /// rather than code point indices.\n+    /// Due to the design of UTF-8, this operation is `O(end)`. Use slicing\n+    /// syntax if you want to use byte indices rather than codepoint indices.\n     ///\n     /// # Panics\n     ///"}, {"sha": "84fe5ba1fbf5a4c071482f41d5f7ec9d4780a6c9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -11,7 +11,8 @@\n //! A growable list type with heap-allocated contents, written `Vec<T>` but\n //! pronounced 'vector.'\n //!\n-//! Vectors have `O(1)` indexing, push (to the end) and pop (from the end).\n+//! Vectors have `O(1)` indexing, amortized `O(1)` push (to the end) and\n+//! `O(1)` pop (from the end).\n //!\n //! # Examples\n //!"}, {"sha": "bf26022692d09362562d55c1a2d86bae11904d89", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 114, "deletions": 114, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -73,11 +73,11 @@ macro_rules! zero_one_impl {\n     ($($t:ty)*) => ($(\n         impl Zero for $t {\n             #[inline]\n-            fn zero() -> $t { 0 }\n+            fn zero() -> Self { 0 }\n         }\n         impl One for $t {\n             #[inline]\n-            fn one() -> $t { 1 }\n+            fn one() -> Self { 1 }\n         }\n     )*)\n }\n@@ -87,20 +87,20 @@ macro_rules! zero_one_impl_float {\n     ($($t:ty)*) => ($(\n         impl Zero for $t {\n             #[inline]\n-            fn zero() -> $t { 0.0 }\n+            fn zero() -> Self { 0.0 }\n         }\n         impl One for $t {\n             #[inline]\n-            fn one() -> $t { 1.0 }\n+            fn one() -> Self { 1.0 }\n         }\n     )*)\n }\n zero_one_impl_float! { f32 f64 }\n \n macro_rules! checked_op {\n-    ($T:ty, $U:ty, $op:path, $x:expr, $y:expr) => {{\n+    ($U:ty, $op:path, $x:expr, $y:expr) => {{\n         let (result, overflowed) = unsafe { $op($x as $U, $y as $U) };\n-        if overflowed { None } else { Some(result as $T) }\n+        if overflowed { None } else { Some(result as Self) }\n     }}\n }\n \n@@ -110,22 +110,22 @@ unsafe fn bswap8(x: u8) -> u8 { x }\n \n // `Int` + `SignedInt` implemented for signed integers\n macro_rules! int_impl {\n-    ($T:ident = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n+    ($ActualT:ty, $UnsignedT:ty, $BITS:expr,\n      $add_with_overflow:path,\n      $sub_with_overflow:path,\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn min_value() -> $T {\n-            (-1 as $T) << ($BITS - 1)\n+        pub fn min_value() -> Self {\n+            (-1 as Self) << ($BITS - 1)\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn max_value() -> $T {\n-            let min = $T::min_value(); !min\n+        pub fn max_value() -> Self {\n+            let min = Self::min_value(); !min\n         }\n \n         /// Converts a string slice in a given base to an integer.\n@@ -139,7 +139,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n \n@@ -216,8 +216,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_left(self, n: u32) -> $T {\n-            (self as $UnsignedT).rotate_left(n) as $T\n+        pub fn rotate_left(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_left(n) as Self\n         }\n \n         /// Shifts the bits to the right by a specified amount, `n`,\n@@ -234,8 +234,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_right(self, n: u32) -> $T {\n-            (self as $UnsignedT).rotate_right(n) as $T\n+        pub fn rotate_right(self, n: u32) -> Self {\n+            (self as $UnsignedT).rotate_right(n) as Self\n         }\n \n         /// Reverses the byte order of the integer.\n@@ -250,8 +250,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> $T {\n-            (self as $UnsignedT).swap_bytes() as $T\n+        pub fn swap_bytes(self) -> Self {\n+            (self as $UnsignedT).swap_bytes() as Self\n         }\n \n         /// Converts an integer from big endian to the target's endianness.\n@@ -272,7 +272,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_be(x: $T) -> $T {\n+        pub fn from_be(x: Self) -> Self {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n@@ -294,7 +294,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_le(x: $T) -> $T {\n+        pub fn from_le(x: Self) -> Self {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n@@ -316,7 +316,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_be(self) -> $T { // or not to be?\n+        pub fn to_be(self) -> Self { // or not to be?\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n@@ -338,7 +338,7 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_le(self) -> $T {\n+        pub fn to_le(self) -> Self {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n@@ -353,8 +353,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        pub fn checked_add(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $add_with_overflow, self, other)\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -368,8 +368,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        pub fn checked_sub(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $sub_with_overflow, self, other)\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -383,8 +383,8 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        pub fn checked_mul(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $mul_with_overflow, self, other)\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -399,10 +399,10 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, v: $T) -> Option<$T> {\n+        pub fn checked_div(self, v: Self) -> Option<Self> {\n             match v {\n                 0   => None,\n-               -1 if self == <$T>::min_value()\n+               -1 if self == Self::min_value()\n                     => None,\n                 v   => Some(self / v),\n             }\n@@ -412,31 +412,31 @@ macro_rules! int_impl {\n         /// the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: $T) -> $T {\n+        pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n-                None => <$T>::min_value(),\n+                None if other >= Self::zero() => Self::max_value(),\n+                None => Self::min_value(),\n             }\n         }\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: $T) -> $T {\n+        pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x)                      => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n-                None => <$T>::max_value(),\n+                None if other >= Self::zero() => Self::min_value(),\n+                None => Self::max_value(),\n             }\n         }\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_add(self, rhs: $T) -> $T {\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_add(self, rhs)\n             }\n@@ -446,7 +446,7 @@ macro_rules! int_impl {\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n@@ -456,7 +456,7 @@ macro_rules! int_impl {\n         /// other`, wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n@@ -473,7 +473,7 @@ macro_rules! int_impl {\n         /// itself..\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_div(self, rhs: $T) -> $T {\n+        pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n         }\n \n@@ -486,7 +486,7 @@ macro_rules! int_impl {\n         /// minimal value). In such a case, this function returns `0`.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+        pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n         }\n \n@@ -500,7 +500,7 @@ macro_rules! int_impl {\n         /// a case, this function returns `MIN` itself.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_neg(self) -> $T {\n+        pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n \n@@ -509,7 +509,7 @@ macro_rules! int_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n \n@@ -518,7 +518,7 @@ macro_rules! int_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n \n@@ -533,9 +533,9 @@ macro_rules! int_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn pow(self, mut exp: u32) -> $T {\n+        pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = <$T as One>::one();\n+            let mut acc = Self::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -569,7 +569,7 @@ macro_rules! int_impl {\n         /// optimized code will return `i32::min_value()` without a panic.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn abs(self) -> $T {\n+        pub fn abs(self) -> Self {\n             if self.is_negative() {\n                 // Note that the #[inline] above means that the overflow\n                 // semantics of this negation depend on the crate we're being\n@@ -587,7 +587,7 @@ macro_rules! int_impl {\n         /// - `-1` if the number is negative\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn signum(self) -> $T {\n+        pub fn signum(self) -> Self {\n             match self {\n                 n if n > 0 =>  1,\n                 0          =>  0,\n@@ -611,31 +611,31 @@ macro_rules! int_impl {\n \n #[lang = \"i8\"]\n impl i8 {\n-    int_impl! { i8 = i8, u8, 8,\n+    int_impl! { i8, u8, 8,\n         intrinsics::i8_add_with_overflow,\n         intrinsics::i8_sub_with_overflow,\n         intrinsics::i8_mul_with_overflow }\n }\n \n #[lang = \"i16\"]\n impl i16 {\n-    int_impl! { i16 = i16, u16, 16,\n+    int_impl! { i16, u16, 16,\n         intrinsics::i16_add_with_overflow,\n         intrinsics::i16_sub_with_overflow,\n         intrinsics::i16_mul_with_overflow }\n }\n \n #[lang = \"i32\"]\n impl i32 {\n-    int_impl! { i32 = i32, u32, 32,\n+    int_impl! { i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n }\n \n #[lang = \"i64\"]\n impl i64 {\n-    int_impl! { i64 = i64, u64, 64,\n+    int_impl! { i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n@@ -644,7 +644,7 @@ impl i64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize = i32, u32, 32,\n+    int_impl! { i32, u32, 32,\n         intrinsics::i32_add_with_overflow,\n         intrinsics::i32_sub_with_overflow,\n         intrinsics::i32_mul_with_overflow }\n@@ -653,15 +653,15 @@ impl isize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"isize\"]\n impl isize {\n-    int_impl! { isize = i64, u64, 64,\n+    int_impl! { i64, u64, 64,\n         intrinsics::i64_add_with_overflow,\n         intrinsics::i64_sub_with_overflow,\n         intrinsics::i64_mul_with_overflow }\n }\n \n // `Int` + `UnsignedInt` implemented for signed integers\n macro_rules! uint_impl {\n-    ($T:ty = $ActualT:ty, $BITS:expr,\n+    ($ActualT:ty, $BITS:expr,\n      $ctpop:path,\n      $ctlz:path,\n      $cttz:path,\n@@ -671,11 +671,11 @@ macro_rules! uint_impl {\n      $mul_with_overflow:path) => {\n         /// Returns the smallest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn min_value() -> $T { 0 }\n+        pub fn min_value() -> Self { 0 }\n \n         /// Returns the largest value that can be represented by this integer type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn max_value() -> $T { !0 }\n+        pub fn max_value() -> Self { !0 }\n \n         /// Converts a string slice in a given base to an integer.\n         ///\n@@ -692,7 +692,7 @@ macro_rules! uint_impl {\n         /// Otherwise, `Ok(n)` where `n` is the integer represented by `src`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        pub fn from_str_radix(src: &str, radix: u32) -> Result<$T, ParseIntError> {\n+        pub fn from_str_radix(src: &str, radix: u32) -> Result<Self, ParseIntError> {\n             from_str_radix(src, radix)\n         }\n \n@@ -784,7 +784,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_left(self, n: u32) -> $T {\n+        pub fn rotate_left(self, n: u32) -> Self {\n             // Protect against undefined behaviour for over-long bit shifts\n             let n = n % $BITS;\n             (self << n) | (self >> (($BITS - n) % $BITS))\n@@ -804,7 +804,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn rotate_right(self, n: u32) -> $T {\n+        pub fn rotate_right(self, n: u32) -> Self {\n             // Protect against undefined behaviour for over-long bit shifts\n             let n = n % $BITS;\n             (self >> n) | (self << (($BITS - n) % $BITS))\n@@ -822,8 +822,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn swap_bytes(self) -> $T {\n-            unsafe { $bswap(self as $ActualT) as $T }\n+        pub fn swap_bytes(self) -> Self {\n+            unsafe { $bswap(self as $ActualT) as Self }\n         }\n \n         /// Converts an integer from big endian to the target's endianness.\n@@ -844,7 +844,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_be(x: $T) -> $T {\n+        pub fn from_be(x: Self) -> Self {\n             if cfg!(target_endian = \"big\") { x } else { x.swap_bytes() }\n         }\n \n@@ -866,7 +866,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn from_le(x: $T) -> $T {\n+        pub fn from_le(x: Self) -> Self {\n             if cfg!(target_endian = \"little\") { x } else { x.swap_bytes() }\n         }\n \n@@ -888,7 +888,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_be(self) -> $T { // or not to be?\n+        pub fn to_be(self) -> Self { // or not to be?\n             if cfg!(target_endian = \"big\") { self } else { self.swap_bytes() }\n         }\n \n@@ -910,7 +910,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn to_le(self) -> $T {\n+        pub fn to_le(self) -> Self {\n             if cfg!(target_endian = \"little\") { self } else { self.swap_bytes() }\n         }\n \n@@ -925,8 +925,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_add(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $add_with_overflow, self, other)\n+        pub fn checked_add(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $add_with_overflow, self, other)\n         }\n \n         /// Checked integer subtraction. Computes `self - other`, returning\n@@ -940,8 +940,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_sub(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $sub_with_overflow, self, other)\n+        pub fn checked_sub(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $sub_with_overflow, self, other)\n         }\n \n         /// Checked integer multiplication. Computes `self * other`, returning\n@@ -955,8 +955,8 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_mul(self, other: $T) -> Option<$T> {\n-            checked_op!($T, $ActualT, $mul_with_overflow, self, other)\n+        pub fn checked_mul(self, other: Self) -> Option<Self> {\n+            checked_op!($ActualT, $mul_with_overflow, self, other)\n         }\n \n         /// Checked integer division. Computes `self / other`, returning `None`\n@@ -971,7 +971,7 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn checked_div(self, v: $T) -> Option<$T> {\n+        pub fn checked_div(self, v: Self) -> Option<Self> {\n             match v {\n                 0 => None,\n                 v => Some(self / v),\n@@ -982,31 +982,31 @@ macro_rules! uint_impl {\n         /// the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_add(self, other: $T) -> $T {\n+        pub fn saturating_add(self, other: Self) -> Self {\n             match self.checked_add(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::max_value(),\n-                None => <$T>::min_value(),\n+                None if other >= Self::zero() => Self::max_value(),\n+                None => Self::min_value(),\n             }\n         }\n \n         /// Saturating integer subtraction. Computes `self - other`, saturating\n         /// at the numeric bounds instead of overflowing.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn saturating_sub(self, other: $T) -> $T {\n+        pub fn saturating_sub(self, other: Self) -> Self {\n             match self.checked_sub(other) {\n                 Some(x)                       => x,\n-                None if other >= <$T as Zero>::zero() => <$T>::min_value(),\n-                None => <$T>::max_value(),\n+                None if other >= Self::zero() => Self::min_value(),\n+                None => Self::max_value(),\n             }\n         }\n \n         /// Wrapping (modular) addition. Computes `self + other`,\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_add(self, rhs: $T) -> $T {\n+        pub fn wrapping_add(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_add(self, rhs)\n             }\n@@ -1016,7 +1016,7 @@ macro_rules! uint_impl {\n         /// wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_sub(self, rhs: $T) -> $T {\n+        pub fn wrapping_sub(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_sub(self, rhs)\n             }\n@@ -1026,7 +1026,7 @@ macro_rules! uint_impl {\n         /// other`, wrapping around at the boundary of the type.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn wrapping_mul(self, rhs: $T) -> $T {\n+        pub fn wrapping_mul(self, rhs: Self) -> Self {\n             unsafe {\n                 intrinsics::overflowing_mul(self, rhs)\n             }\n@@ -1043,7 +1043,7 @@ macro_rules! uint_impl {\n         /// itself..\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_div(self, rhs: $T) -> $T {\n+        pub fn wrapping_div(self, rhs: Self) -> Self {\n             self.overflowing_div(rhs).0\n         }\n \n@@ -1056,7 +1056,7 @@ macro_rules! uint_impl {\n         /// minimal value). In such a case, this function returns `0`.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_rem(self, rhs: $T) -> $T {\n+        pub fn wrapping_rem(self, rhs: Self) -> Self {\n             self.overflowing_rem(rhs).0\n         }\n \n@@ -1070,7 +1070,7 @@ macro_rules! uint_impl {\n         /// a case, this function returns `MIN` itself.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_neg(self) -> $T {\n+        pub fn wrapping_neg(self) -> Self {\n             self.overflowing_neg().0\n         }\n \n@@ -1079,7 +1079,7 @@ macro_rules! uint_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shl(self, rhs: u32) -> $T {\n+        pub fn wrapping_shl(self, rhs: u32) -> Self {\n             self.overflowing_shl(rhs).0\n         }\n \n@@ -1088,7 +1088,7 @@ macro_rules! uint_impl {\n         /// would cause the shift to exceed the bitwidth of the type.\n         #[unstable(feature = \"core\", since = \"1.0.0\")]\n         #[inline(always)]\n-        pub fn wrapping_shr(self, rhs: u32) -> $T {\n+        pub fn wrapping_shr(self, rhs: u32) -> Self {\n             self.overflowing_shr(rhs).0\n         }\n \n@@ -1101,9 +1101,9 @@ macro_rules! uint_impl {\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn pow(self, mut exp: u32) -> $T {\n+        pub fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n-            let mut acc = <$T as One>::one();\n+            let mut acc = Self::one();\n \n             let mut prev_base = self;\n             let mut base_oflo = false;\n@@ -1131,25 +1131,25 @@ macro_rules! uint_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub fn is_power_of_two(self) -> bool {\n-            (self.wrapping_sub(<$T as One>::one())) & self == <$T as Zero>::zero() &&\n-                !(self == <$T as Zero>::zero())\n+            (self.wrapping_sub(Self::one())) & self == Self::zero() &&\n+                !(self == Self::zero())\n         }\n \n         /// Returns the smallest power of two greater than or equal to `self`.\n         /// Unspecified behavior on overflow.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n-        pub fn next_power_of_two(self) -> $T {\n-            let bits = size_of::<$T>() * 8;\n-            let one: $T = <$T as One>::one();\n+        pub fn next_power_of_two(self) -> Self {\n+            let bits = size_of::<Self>() * 8;\n+            let one: Self = Self::one();\n             one << ((bits - self.wrapping_sub(one).leading_zeros() as usize) % bits)\n         }\n \n         /// Returns the smallest power of two greater than or equal to `n`. If\n         /// the next power of two is greater than the type's maximum value,\n         /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        pub fn checked_next_power_of_two(self) -> Option<$T> {\n+        pub fn checked_next_power_of_two(self) -> Option<Self> {\n             let npot = self.next_power_of_two();\n             if npot >= self {\n                 Some(npot)\n@@ -1162,7 +1162,7 @@ macro_rules! uint_impl {\n \n #[lang = \"u8\"]\n impl u8 {\n-    uint_impl! { u8 = u8, 8,\n+    uint_impl! { u8, 8,\n         intrinsics::ctpop8,\n         intrinsics::ctlz8,\n         intrinsics::cttz8,\n@@ -1174,7 +1174,7 @@ impl u8 {\n \n #[lang = \"u16\"]\n impl u16 {\n-    uint_impl! { u16 = u16, 16,\n+    uint_impl! { u16, 16,\n         intrinsics::ctpop16,\n         intrinsics::ctlz16,\n         intrinsics::cttz16,\n@@ -1186,7 +1186,7 @@ impl u16 {\n \n #[lang = \"u32\"]\n impl u32 {\n-    uint_impl! { u32 = u32, 32,\n+    uint_impl! { u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1199,7 +1199,7 @@ impl u32 {\n \n #[lang = \"u64\"]\n impl u64 {\n-    uint_impl! { u64 = u64, 64,\n+    uint_impl! { u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1212,7 +1212,7 @@ impl u64 {\n #[cfg(target_pointer_width = \"32\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize = u32, 32,\n+    uint_impl! { u32, 32,\n         intrinsics::ctpop32,\n         intrinsics::ctlz32,\n         intrinsics::cttz32,\n@@ -1225,7 +1225,7 @@ impl usize {\n #[cfg(target_pointer_width = \"64\")]\n #[lang = \"usize\"]\n impl usize {\n-    uint_impl! { usize = u64, 64,\n+    uint_impl! { u64, 64,\n         intrinsics::ctpop64,\n         intrinsics::ctlz64,\n         intrinsics::cttz64,\n@@ -1362,9 +1362,9 @@ pub trait Float {\n }\n \n macro_rules! from_str_float_impl {\n-    ($T:ident) => {\n+    ($t:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl FromStr for $T {\n+        impl FromStr for $t {\n             type Err = ParseFloatError;\n \n             /// Converts a string in base 10 to a float.\n@@ -1395,8 +1395,8 @@ macro_rules! from_str_float_impl {\n             /// number represented by `src`.\n             #[inline]\n             #[allow(deprecated)]\n-            fn from_str(src: &str) -> Result<$T, ParseFloatError> {\n-                $T::from_str_radix(src, 10)\n+            fn from_str(src: &str) -> Result<Self, ParseFloatError> {\n+                Self::from_str_radix(src, 10)\n             }\n         }\n     }\n@@ -1405,12 +1405,12 @@ from_str_float_impl!(f32);\n from_str_float_impl!(f64);\n \n macro_rules! from_str_radix_int_impl {\n-    ($($T:ident)*) => {$(\n+    ($($t:ty)*) => {$(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[allow(deprecated)]\n-        impl FromStr for $T {\n+        impl FromStr for $t {\n             type Err = ParseIntError;\n-            fn from_str(src: &str) -> Result<$T, ParseIntError> {\n+            fn from_str(src: &str) -> Result<Self, ParseIntError> {\n                 from_str_radix(src, 10)\n             }\n         }\n@@ -1428,17 +1428,17 @@ trait FromStrRadixHelper: PartialOrd + Copy {\n }\n \n macro_rules! doit {\n-    ($($t:ident)*) => ($(impl FromStrRadixHelper for $t {\n-        fn min_value() -> Self { <$t>::min_value() }\n-        fn from_u32(u: u32) -> Self { u as $t }\n+    ($($t:ty)*) => ($(impl FromStrRadixHelper for $t {\n+        fn min_value() -> Self { Self::min_value() }\n+        fn from_u32(u: u32) -> Self { u as Self }\n         fn checked_mul(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_mul(*self, other as $t)\n+            Self::checked_mul(*self, other as Self)\n         }\n         fn checked_sub(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_sub(*self, other as $t)\n+            Self::checked_sub(*self, other as Self)\n         }\n         fn checked_add(&self, other: u32) -> Option<Self> {\n-            <$t>::checked_add(*self, other as $t)\n+            Self::checked_add(*self, other as Self)\n         }\n     })*)\n }"}, {"sha": "8562d8c01cc67d9cc8fceb76608a0da129c4e9c0", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -21,6 +21,7 @@ use metadata::decoder;\n use metadata::loader;\n use metadata::loader::CratePaths;\n \n+use std::cell::RefCell;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::fs;\n@@ -376,14 +377,13 @@ impl<'a> CrateReader<'a> {\n         let loader::Library { dylib, rlib, metadata } = lib;\n \n         let cnum_map = self.resolve_crate_deps(root, metadata.as_slice(), span);\n-        let codemap_import_info = import_codemap(self.sess.codemap(), &metadata);\n \n         let cmeta = Rc::new( cstore::crate_metadata {\n             name: name.to_string(),\n             data: metadata,\n             cnum_map: cnum_map,\n             cnum: cnum,\n-            codemap_import_info: codemap_import_info,\n+            codemap_import_info: RefCell::new(vec![]),\n             span: span,\n         });\n \n@@ -616,9 +616,9 @@ impl<'a> CrateReader<'a> {\n /// file they represent, just information about length, line breaks, and\n /// multibyte characters. This information is enough to generate valid debuginfo\n /// for items inlined from other crates.\n-fn import_codemap(local_codemap: &codemap::CodeMap,\n-                  metadata: &MetadataBlob)\n-                  -> Vec<cstore::ImportedFileMap> {\n+pub fn import_codemap(local_codemap: &codemap::CodeMap,\n+                      metadata: &MetadataBlob)\n+                      -> Vec<cstore::ImportedFileMap> {\n     let external_codemap = decoder::get_imported_filemaps(metadata.as_slice());\n \n     let imported_filemaps = external_codemap.into_iter().map(|filemap_to_import| {"}, {"sha": "885e7ffb3050ef0ab121df46990da4a23a689c79", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -18,12 +18,11 @@ pub use self::LinkagePreference::*;\n pub use self::NativeLibraryKind::*;\n \n use back::svh::Svh;\n-use metadata::decoder;\n-use metadata::loader;\n+use metadata::{creader, decoder, loader};\n use session::search_paths::PathKind;\n use util::nodemap::{FnvHashMap, NodeMap};\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Ref};\n use std::rc::Rc;\n use std::path::PathBuf;\n use flate::Bytes;\n@@ -58,7 +57,7 @@ pub struct crate_metadata {\n     pub data: MetadataBlob,\n     pub cnum_map: cnum_map,\n     pub cnum: ast::CrateNum,\n-    pub codemap_import_info: Vec<ImportedFileMap>,\n+    pub codemap_import_info: RefCell<Vec<ImportedFileMap>>,\n     pub span: codemap::Span,\n }\n \n@@ -240,6 +239,20 @@ impl crate_metadata {\n     pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n     pub fn name(&self) -> String { decoder::get_crate_name(self.data()) }\n     pub fn hash(&self) -> Svh { decoder::get_crate_hash(self.data()) }\n+    pub fn imported_filemaps<'a>(&'a self, codemap: &codemap::CodeMap)\n+                                 -> Ref<'a, Vec<ImportedFileMap>> {\n+        let filemaps = self.codemap_import_info.borrow();\n+        if filemaps.is_empty() {\n+            drop(filemaps);\n+            let filemaps = creader::import_codemap(codemap, &self.data);\n+\n+            // This shouldn't borrow twice, but there is no way to downgrade RefMut to Ref.\n+            *self.codemap_import_info.borrow_mut() = filemaps;\n+            self.codemap_import_info.borrow()\n+        } else {\n+            filemaps\n+        }\n+    }\n }\n \n impl MetadataBlob {"}, {"sha": "b7e57819b93b4941c234bf1d7a934ba20b204297", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -233,8 +233,6 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n     /// codemap as a side-effect of creating the crate_metadata's\n     /// `codemap_import_info`.\n     pub fn tr_span(&self, span: Span) -> Span {\n-        let imported_filemaps = &self.cdata.codemap_import_info[..];\n-\n         let span = if span.lo > span.hi {\n             // Currently macro expansion sometimes produces invalid Span values\n             // where lo > hi. In order not to crash the compiler when trying to\n@@ -248,16 +246,18 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n             span\n         };\n \n-        let filemap_index = {\n+        let imported_filemaps = self.cdata.imported_filemaps(self.tcx.sess.codemap());\n+        let filemap = {\n             // Optimize for the case that most spans within a translated item\n             // originate from the same filemap.\n             let last_filemap_index = self.last_filemap_index.get();\n+            let last_filemap = &imported_filemaps[last_filemap_index];\n \n-            if span.lo >= imported_filemaps[last_filemap_index].original_start_pos &&\n-               span.lo <= imported_filemaps[last_filemap_index].original_end_pos &&\n-               span.hi >= imported_filemaps[last_filemap_index].original_start_pos &&\n-               span.hi <= imported_filemaps[last_filemap_index].original_end_pos {\n-                last_filemap_index\n+            if span.lo >= last_filemap.original_start_pos &&\n+               span.lo <= last_filemap.original_end_pos &&\n+               span.hi >= last_filemap.original_start_pos &&\n+               span.hi <= last_filemap.original_end_pos {\n+                last_filemap\n             } else {\n                 let mut a = 0;\n                 let mut b = imported_filemaps.len();\n@@ -272,14 +272,14 @@ impl<'a, 'b, 'tcx> DecodeContext<'a, 'b, 'tcx> {\n                 }\n \n                 self.last_filemap_index.set(a);\n-                a\n+                &imported_filemaps[a]\n             }\n         };\n \n-        let lo = (span.lo - imported_filemaps[filemap_index].original_start_pos) +\n-                  imported_filemaps[filemap_index].translated_filemap.start_pos;\n-        let hi = (span.hi - imported_filemaps[filemap_index].original_start_pos) +\n-                  imported_filemaps[filemap_index].translated_filemap.start_pos;\n+        let lo = (span.lo - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n+        let hi = (span.hi - filemap.original_start_pos) +\n+                  filemap.translated_filemap.start_pos;\n \n         codemap::mk_sp(lo, hi)\n     }"}, {"sha": "575322e63526d531b10611eb3cd6b1aeb0f93759", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -443,6 +443,8 @@ a {\n .content .search-results td:first-child { padding-right: 0; }\n .content .search-results td:first-child a { padding-right: 10px; }\n \n+tr.result span.primitive::after { content: ' (primitive type)'; font-style: italic; }\n+\n #help {\n     background: #e9e9e9;\n     border-radius: 4px;"}, {"sha": "7f8f40ff08a4d71e108b024adccc00b2b7be80aa", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 64, "deletions": 60, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -13,7 +13,6 @@\n \n (function() {\n     \"use strict\";\n-    var resizeTimeout, interval;\n \n     // This mapping table should match the discriminants of\n     // `rustdoc::html::item_type::ItemType` type in Rust.\n@@ -37,6 +36,9 @@\n                      \"constant\",\n                      \"associatedconstant\"];\n \n+    // used for special search precedence\n+    var TY_PRIMITIVE = itemTypes.indexOf(\"primitive\");\n+\n     $('.js-only').removeClass('js-only');\n \n     function getQueryStringParams() {\n@@ -64,7 +66,7 @@\n             if ($('#' + from).length === 0) {\n                 return;\n             }\n-            if (ev === null) $('#' + from)[0].scrollIntoView();\n+            if (ev === null) { $('#' + from)[0].scrollIntoView(); };\n             $('.line-numbers span').removeClass('line-highlighted');\n             for (i = from; i <= to; ++i) {\n                 $('#' + i).addClass('line-highlighted');\n@@ -74,7 +76,7 @@\n     highlightSourceLines(null);\n     $(window).on('hashchange', highlightSourceLines);\n \n-    $(document).on('keyup', function(e) {\n+    $(document).on('keyup', function handleKeyboardShortcut(e) {\n         if (document.activeElement.tagName === 'INPUT') {\n             return;\n         }\n@@ -133,29 +135,28 @@\n         return function(s1, s2) {\n             if (s1 === s2) {\n                 return 0;\n-            } else {\n-                var s1_len = s1.length, s2_len = s2.length;\n-                if (s1_len && s2_len) {\n-                    var i1 = 0, i2 = 0, a, b, c, c2, row = row2;\n-                    while (i1 < s1_len)\n-                        row[i1] = ++i1;\n-                    while (i2 < s2_len) {\n-                        c2 = s2.charCodeAt(i2);\n-                        a = i2;\n-                        ++i2;\n-                        b = i2;\n-                        for (i1 = 0; i1 < s1_len; ++i1) {\n-                            c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n-                            a = row[i1];\n-                            b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n-                            row[i1] = b;\n-                        }\n+            }\n+            var s1_len = s1.length, s2_len = s2.length;\n+            if (s1_len && s2_len) {\n+                var i1 = 0, i2 = 0, a, b, c, c2, row = row2;\n+                while (i1 < s1_len) {\n+                    row[i1] = ++i1;\n+                }\n+                while (i2 < s2_len) {\n+                    c2 = s2.charCodeAt(i2);\n+                    a = i2;\n+                    ++i2;\n+                    b = i2;\n+                    for (i1 = 0; i1 < s1_len; ++i1) {\n+                        c = a + (s1.charCodeAt(i1) !== c2 ? 1 : 0);\n+                        a = row[i1];\n+                        b = b < a ? (b < c ? b + 1 : c) : (a < c ? a + 1 : c);\n+                        row[i1] = b;\n                     }\n-                    return b;\n-                } else {\n-                    return s1_len + s2_len;\n                 }\n+                return b;\n             }\n+            return s1_len + s2_len;\n         };\n     })();\n \n@@ -187,7 +188,7 @@\n                 results = [],\n                 split = valLower.split(\"::\");\n \n-            //remove empty keywords\n+            // remove empty keywords\n             for (var j = 0; j < split.length; ++j) {\n                 split[j].toLowerCase();\n                 if (split[j] === \"\") {\n@@ -286,58 +287,63 @@\n                 return [];\n             }\n \n-            results.sort(function(aaa, bbb) {\n+            results.sort(function sortResults(aaa, bbb) {\n                 var a, b;\n \n                 // Sort by non levenshtein results and then levenshtein results by the distance\n                 // (less changes required to match means higher rankings)\n                 a = (aaa.lev);\n                 b = (bbb.lev);\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by crate (non-current crate goes later)\n                 a = (aaa.item.crate !== window.currentCrate);\n                 b = (bbb.item.crate !== window.currentCrate);\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by exact match (mismatch goes later)\n                 a = (aaa.word !== valLower);\n                 b = (bbb.word !== valLower);\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by item name length (longer goes later)\n                 a = aaa.word.length;\n                 b = bbb.word.length;\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by item name (lexicographically larger goes later)\n                 a = aaa.word;\n                 b = bbb.word;\n-                if (a !== b) return (a > b ? +1 : -1);\n+                if (a !== b) { return (a > b ? +1 : -1); }\n \n                 // sort by index of keyword in item name (no literal occurrence goes later)\n                 a = (aaa.index < 0);\n                 b = (bbb.index < 0);\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n                 // (later literal occurrence, if any, goes later)\n                 a = aaa.index;\n                 b = bbb.index;\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n+\n+                // special precedence for primitive pages\n+                if ((aaa.item.ty === TY_PRIMITIVE) && (bbb.item.ty !== TY_PRIMITIVE)) {\n+                    return -1;\n+                }\n \n                 // sort by description (no description goes later)\n                 a = (aaa.item.desc === '');\n                 b = (bbb.item.desc === '');\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by type (later occurrence in `itemTypes` goes later)\n                 a = aaa.item.ty;\n                 b = bbb.item.ty;\n-                if (a !== b) return a - b;\n+                if (a !== b) { return a - b; }\n \n                 // sort by path (lexicographically larger goes later)\n                 a = aaa.item.path;\n                 b = bbb.item.path;\n-                if (a !== b) return (a > b ? +1 : -1);\n+                if (a !== b) { return (a > b ? +1 : -1); }\n \n                 // que sera, sera\n                 return 0;\n@@ -388,7 +394,7 @@\n          * @return {[boolean]}       [Whether the result is valid or not]\n          */\n         function validateResult(name, path, keys, parent) {\n-            for (var i=0; i < keys.length; ++i) {\n+            for (var i = 0; i < keys.length; ++i) {\n                 // each check is for validation so we negate the conditions and invalidate\n                 if (!(\n                     // check for an exact name match\n@@ -423,7 +429,7 @@\n                 raw: raw,\n                 query: query,\n                 type: type,\n-                id: query + type,\n+                id: query + type\n             };\n         }\n \n@@ -432,7 +438,7 @@\n \n             $results.on('click', function() {\n                 var dst = $(this).find('a')[0];\n-                if (window.location.pathname == dst.pathname) {\n+                if (window.location.pathname === dst.pathname) {\n                     $('#search').addClass('hidden');\n                     $('#main').removeClass('hidden');\n                     document.location.href = dst.href;\n@@ -595,7 +601,7 @@\n \n         function itemTypeFromName(typename) {\n             for (var i = 0; i < itemTypes.length; ++i) {\n-                if (itemTypes[i] === typename) return i;\n+                if (itemTypes[i] === typename) { return i; }\n             }\n             return -1;\n         }\n@@ -604,7 +610,7 @@\n             searchIndex = [];\n             var searchWords = [];\n             for (var crate in rawSearchIndex) {\n-                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n \n                 // an array of [(Number) item type,\n                 //              (String) name,\n@@ -690,32 +696,31 @@\n         }\n \n         function plainSummaryLine(markdown) {\n-            var str = markdown.replace(/\\n/g, ' ')\n-            str = str.replace(/'/g, \"\\'\")\n-            str = str.replace(/^#+? (.+?)/, \"$1\")\n-            str = str.replace(/\\[(.*?)\\]\\(.*?\\)/g, \"$1\")\n-            str = str.replace(/\\[(.*?)\\]\\[.*?\\]/g, \"$1\")\n-            return str;\n+            markdown.replace(/\\n/g, ' ')\n+            .replace(/'/g, \"\\'\")\n+            .replace(/^#+? (.+?)/, \"$1\")\n+            .replace(/\\[(.*?)\\]\\(.*?\\)/g, \"$1\")\n+            .replace(/\\[(.*?)\\]\\[.*?\\]/g, \"$1\");\n         }\n \n         index = buildIndex(rawSearchIndex);\n         startSearch();\n \n         // Draw a convenient sidebar of known crates if we have a listing\n-        if (rootPath == '../') {\n+        if (rootPath === '../') {\n             var sidebar = $('.sidebar');\n             var div = $('<div>').attr('class', 'block crate');\n             div.append($('<h2>').text('Crates'));\n \n             var crates = [];\n             for (var crate in rawSearchIndex) {\n-                if (!rawSearchIndex.hasOwnProperty(crate)) { continue }\n+                if (!rawSearchIndex.hasOwnProperty(crate)) { continue; }\n                 crates.push(crate);\n             }\n             crates.sort();\n             for (var i = 0; i < crates.length; ++i) {\n                 var klass = 'crate';\n-                if (crates[i] == window.currentCrate) {\n+                if (crates[i] === window.currentCrate) {\n                     klass += ' current';\n                 }\n                 if (rawSearchIndex[crates[i]].items[0]) {\n@@ -738,7 +743,7 @@\n \n         function block(shortty, longty) {\n             var filtered = items[shortty];\n-            if (!filtered) return;\n+            if (!filtered) { return; }\n \n             var div = $('<div>').attr('class', 'block ' + shortty);\n             div.append($('<h2>').text(longty));\n@@ -749,7 +754,7 @@\n                 var desc = item[1]; // can be null\n \n                 var klass = shortty;\n-                if (name === current.name && shortty == current.ty) {\n+                if (name === current.name && shortty === current.ty) {\n                     klass += ' current';\n                 }\n                 var path;\n@@ -779,7 +784,7 @@\n         var list = $('#implementors-list');\n         var libs = Object.getOwnPropertyNames(imp);\n         for (var i = 0; i < libs.length; ++i) {\n-            if (libs[i] == currentCrate) continue;\n+            if (libs[i] === currentCrate) { continue; }\n             var structs = imp[libs[i]];\n             for (var j = 0; j < structs.length; ++j) {\n                 var code = $('<code>').append(structs[j]);\n@@ -811,11 +816,10 @@\n         if (sectionIsCollapsed) {\n             // button will expand the section\n             return \"+\";\n-        } else {\n-            // button will collapse the section\n-            // note that this text is also set in the HTML template in render.rs\n-            return \"\\u2212\"; // \"\\u2212\" is '\u2212' minus sign\n         }\n+        // button will collapse the section\n+        // note that this text is also set in the HTML template in render.rs\n+        return \"\\u2212\"; // \"\\u2212\" is '\u2212' minus sign\n     }\n \n     $(\"#toggle-all-docs\").on(\"click\", function() {\n@@ -847,12 +851,12 @@\n         }\n         if (relatedDoc.is(\".docblock\")) {\n             if (relatedDoc.is(\":visible\")) {\n-                relatedDoc.slideUp({duration:'fast', easing:'linear'});\n+                relatedDoc.slideUp({duration: 'fast', easing: 'linear'});\n                 toggle.parent(\".toggle-wrapper\").addClass(\"collapsed\");\n                 toggle.children(\".inner\").text(labelForToggleButton(true));\n                 toggle.children(\".toggle-label\").fadeIn();\n             } else {\n-                relatedDoc.slideDown({duration:'fast', easing:'linear'});\n+                relatedDoc.slideDown({duration: 'fast', easing: 'linear'});\n                 toggle.parent(\".toggle-wrapper\").removeClass(\"collapsed\");\n                 toggle.children(\".inner\").text(labelForToggleButton(false));\n                 toggle.children(\".toggle-label\").hide();\n@@ -877,7 +881,7 @@\n                 $('<span/>', {'class': 'toggle-label'})\n                     .css('display', 'none')\n                     .html('&nbsp;Expand&nbsp;description'));\n-        var wrapper =  $(\"<div class='toggle-wrapper'>\").append(mainToggle);\n+        var wrapper = $(\"<div class='toggle-wrapper'>\").append(mainToggle);\n         $(\"#main > .docblock\").before(wrapper);\n     });\n \n@@ -894,7 +898,7 @@\n         }\n \n         return function(ev) {\n-            var cur_id = parseInt(ev.target.id);\n+            var cur_id = parseInt(ev.target.id, 10);\n \n             if (ev.shiftKey && prev_id) {\n                 if (prev_id > cur_id) {"}, {"sha": "17bd27337acd21ac7cf81b5c97b825b0cf1ac899", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -26,7 +26,7 @@\n //!\n //! ## What is in the standard library\n //!\n-//! The standard library is minimal, a set of battle-tested\n+//! The standard library is a set of minimal, battle-tested\n //! core types and shared abstractions for the [broader Rust\n //! ecosystem](https://crates.io) to build on.\n //!"}, {"sha": "c2ed3583835a7e0623f855496628cbbaaae32767", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -154,18 +154,18 @@ pub trait MultiItemDecorator {\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n-              item: Annotatable,\n+              item: &Annotatable,\n               push: &mut FnMut(Annotatable));\n }\n \n impl<F> MultiItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, Annotatable, &mut FnMut(Annotatable))\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &Annotatable, &mut FnMut(Annotatable))\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n-              item: Annotatable,\n+              item: &Annotatable,\n               push: &mut FnMut(Annotatable)) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }"}, {"sha": "689a4e96aec80bd40c01604b55132a0218fa78a7", "filename": "src/libsyntax/ext/deriving/bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fbounds.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -17,7 +17,7 @@ use ext::deriving::generic::ty::*;\n pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n                                     span: Span,\n                                     _: &MetaItem,\n-                                    _: Annotatable,\n+                                    _: &Annotatable,\n                                     _: &mut FnMut(Annotatable))\n {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n@@ -26,7 +26,7 @@ pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: Annotatable,\n+                            item: &Annotatable,\n                             push: &mut FnMut(Annotatable))\n {\n     let path = Path::new(vec![\n@@ -45,5 +45,5 @@ pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push);\n+    trait_def.expand(cx, mitem, item, push);\n }"}, {"sha": "a9c05339894d270f1215f603796b2499c49d511a", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -20,7 +20,7 @@ use ptr::P;\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n-                             item: Annotatable,\n+                             item: &Annotatable,\n                              push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -48,7 +48,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n fn cs_clone("}, {"sha": "b370757e8fb4b12dfaa623b9a2f5b564be691316", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -20,7 +20,7 @@ use ptr::P;\n pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           span: Span,\n                           mitem: &MetaItem,\n-                          item: Annotatable,\n+                          item: &Annotatable,\n                           push: &mut FnMut(Annotatable))\n {\n     fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n@@ -67,5 +67,5 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "d605e0286f525138baa8eb2675cf743b2b8131e5", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -21,7 +21,7 @@ use ptr::P;\n pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                            span: Span,\n                            mitem: &MetaItem,\n-                           item: Annotatable,\n+                           item: &Annotatable,\n                            push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -49,7 +49,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n "}, {"sha": "e5d6408ca1b6dfd0d166693f97e598e388bf9770", "filename": "src/libsyntax/ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -20,7 +20,7 @@ use ptr::P;\n pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n                                   span: Span,\n                                   mitem: &MetaItem,\n-                                  item: Annotatable,\n+                                  item: &Annotatable,\n                                   push: &mut FnMut(Annotatable))\n {\n     // structures are equal if all fields are equal, and non equal, if\n@@ -91,5 +91,5 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "4eb95343a49a75d5c4f5c5b2e464c353588fbc8c", "filename": "src/libsyntax/ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -23,7 +23,7 @@ use ptr::P;\n pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n                                    span: Span,\n                                    mitem: &MetaItem,\n-                                   item: Annotatable,\n+                                   item: &Annotatable,\n                                    push: &mut FnMut(Annotatable))\n {\n     macro_rules! md {\n@@ -82,7 +82,7 @@ pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n         ],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "99f217a419af84c0a7bb51a1cc2062f2cb8f8796", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -24,7 +24,7 @@ use ptr::P;\n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: Annotatable,\n+                                       item: &Annotatable,\n                                        push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n@@ -33,7 +33,7 @@ pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: Annotatable,\n+                                 item: &Annotatable,\n                                  push: &mut FnMut(Annotatable))\n {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n@@ -42,7 +42,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: Annotatable,\n+                                 item: &Annotatable,\n                                  push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n@@ -88,7 +88,7 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "ab22b7107003b08ab5283bff83ef8c1c7c068d5e", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -20,7 +20,7 @@ use ptr::P;\n pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                                span: Span,\n                                mitem: &MetaItem,\n-                               item: Annotatable,\n+                               item: &Annotatable,\n                                push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -47,7 +47,7 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n         ),\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "0ef23705f95ac0b78272b7996652d104707e8b11", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -100,7 +100,7 @@ use ptr::P;\n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n                                        span: Span,\n                                        mitem: &MetaItem,\n-                                       item: Annotatable,\n+                                       item: &Annotatable,\n                                        push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n@@ -109,7 +109,7 @@ pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: Annotatable,\n+                                 item: &Annotatable,\n                                  push: &mut FnMut(Annotatable))\n {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n@@ -118,7 +118,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n                                  span: Span,\n                                  mitem: &MetaItem,\n-                                 item: Annotatable,\n+                                 item: &Annotatable,\n                                  push: &mut FnMut(Annotatable),\n                                  krate: &'static str)\n {\n@@ -164,7 +164,7 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,"}, {"sha": "cdb378a34d487c427801dad1efc1666208579bda", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -19,7 +19,7 @@ use ptr::P;\n pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: Annotatable,\n+                            item: &Annotatable,\n                             push: &mut FnMut(Annotatable))\n {\n \n@@ -53,7 +53,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    hash_trait_def.expand(cx, mitem, &item, push);\n+    hash_trait_def.expand(cx, mitem, item, push);\n }\n \n fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "344515b875f0a91929565c112e5c7f1e6ae664d9", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -134,7 +134,7 @@ macro_rules! derive_traits {\n                               ecx: &mut ExtCtxt,\n                               sp: Span,\n                               mitem: &MetaItem,\n-                              annotatable: Annotatable,\n+                              annotatable: &Annotatable,\n                               push: &mut FnMut(Annotatable)) {\n                         warn_if_deprecated(ecx, sp, $name);\n                         $func(ecx, sp, mitem, annotatable, push);"}, {"sha": "5eb98d3aa15988d91685be9ef412d30d1c57b125", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -21,7 +21,7 @@ use ptr::P;\n pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                       span: Span,\n                                       mitem: &MetaItem,\n-                                      item: Annotatable,\n+                                      item: &Annotatable,\n                                       push: &mut FnMut(Annotatable))\n {\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n@@ -69,7 +69,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n fn cs_from(name: &str, cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {"}, {"sha": "dbde963bda988110886aa9ed79ec09021ee0b4c5", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -21,7 +21,7 @@ use ptr::P;\n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n                             mitem: &MetaItem,\n-                            item: Annotatable,\n+                            item: &Annotatable,\n                             push: &mut FnMut(Annotatable))\n {\n     // &mut ::std::fmt::Formatter\n@@ -50,7 +50,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n         ],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n /// We use the debug builders to do the heavy lifting here"}, {"sha": "744849de44582a0ceaa809cd9082e5e70569fb4f", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -1212,7 +1212,7 @@ fn expand_decorators(a: Annotatable,\n                     dec.expand(fld.cx,\n                                attr.span,\n                                &attr.node.value,\n-                               a.clone(),\n+                               &a,\n                                &mut |ann| items.push(ann));\n                     decorator_items.extend(items.into_iter()\n                         .flat_map(|ann| expand_annotatable(ann, fld).into_iter()));"}, {"sha": "8c1445a172d8d21eb74b5ce6a60af930416a4e55", "filename": "src/test/auxiliary/custom_derive_plugin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -37,7 +37,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n fn expand(cx: &mut ExtCtxt,\n           span: Span,\n           mitem: &ast::MetaItem,\n-          item: Annotatable,\n+          item: &Annotatable,\n           push: &mut FnMut(Annotatable)) {\n     let trait_def = TraitDef {\n         span: span,\n@@ -71,5 +71,5 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }"}, {"sha": "01fde91fef57b93ca0bce8f1eae5bf0ef26c3b49", "filename": "src/test/auxiliary/custom_derive_plugin_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcustom_derive_plugin_attr.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -39,7 +39,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n fn expand(cx: &mut ExtCtxt,\n           span: Span,\n           mitem: &ast::MetaItem,\n-          item: Annotatable,\n+          item: &Annotatable,\n           push: &mut FnMut(Annotatable)) {\n     let trait_def = TraitDef {\n         span: span,\n@@ -62,7 +62,7 @@ fn expand(cx: &mut ExtCtxt,\n         ],\n     };\n \n-    trait_def.expand(cx, mitem, &item, push)\n+    trait_def.expand(cx, mitem, item, push)\n }\n \n // Mostly copied from syntax::ext::deriving::hash"}, {"sha": "9474533a9b5a756b5abb6250164c36c42623381c", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b808ac0ec37a8ef78b0581b3b061271c93ab8/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=a33b808ac0ec37a8ef78b0581b3b061271c93ab8", "patch": "@@ -108,7 +108,7 @@ fn expand_into_foo_multi(cx: &mut ExtCtxt,\n fn expand_duplicate(cx: &mut ExtCtxt,\n                     sp: Span,\n                     mi: &MetaItem,\n-                    it: Annotatable,\n+                    it: &Annotatable,\n                     push: &mut FnMut(Annotatable))\n {\n     let copy_name = match mi.node {"}]}