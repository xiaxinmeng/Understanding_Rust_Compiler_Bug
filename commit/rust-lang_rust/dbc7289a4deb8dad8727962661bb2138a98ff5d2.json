{"sha": "dbc7289a4deb8dad8727962661bb2138a98ff5d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzcyODlhNGRlYjhkYWQ4NzI3OTYyNjYxYmIyMTM4YTk4ZmY1ZDI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-27T00:36:47Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-27T00:36:47Z"}, "message": "Start refactoring name-mangling in trans.", "tree": {"sha": "2df6e455dc798e4357bc35ad9e440998c4db0879", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2df6e455dc798e4357bc35ad9e440998c4db0879"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc7289a4deb8dad8727962661bb2138a98ff5d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc7289a4deb8dad8727962661bb2138a98ff5d2", "html_url": "https://github.com/rust-lang/rust/commit/dbc7289a4deb8dad8727962661bb2138a98ff5d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc7289a4deb8dad8727962661bb2138a98ff5d2/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "643a75b86e2d5c26ff061ce61a44c39899893754", "url": "https://api.github.com/repos/rust-lang/rust/commits/643a75b86e2d5c26ff061ce61a44c39899893754", "html_url": "https://github.com/rust-lang/rust/commit/643a75b86e2d5c26ff061ce61a44c39899893754"}], "stats": {"total": 133, "additions": 90, "deletions": 43}, "files": [{"sha": "10742d7bd90d876d726dfbe0ce297cccb67b7c87", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 90, "deletions": 43, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/dbc7289a4deb8dad8727962661bb2138a98ff5d2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc7289a4deb8dad8727962661bb2138a98ff5d2/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dbc7289a4deb8dad8727962661bb2138a98ff5d2", "patch": "@@ -90,7 +90,6 @@ state type crate_ctxt = rec(session.session sess,\n                             ValueRef crate_ptr,\n                             hashmap[str, ValueRef] externs,\n                             hashmap[str, ValueRef] intrinsics,\n-                            hashmap[str, ValueRef] item_names,\n                             hashmap[ast.def_id, ValueRef] item_ids,\n                             hashmap[ast.def_id, @ast.item] items,\n                             hashmap[ast.def_id,\n@@ -108,7 +107,8 @@ state type crate_ctxt = rec(session.session sess,\n                             vec[ast.obj_field] obj_fields,\n                             @glue_fns glues,\n                             namegen names,\n-                            str path);\n+                            vec[str] path,\n+                            std.sha1.sha1 sha);\n \n state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef lltaskptr,\n@@ -156,6 +156,30 @@ fn sep() -> str {\n     ret \"_\";\n }\n \n+fn extend_path(@crate_ctxt cx, str name) -> @crate_ctxt {\n+  ret @rec(path = cx.path + vec(name) with *cx);\n+}\n+\n+fn path_name(vec[str] path) -> str {\n+    ret _str.connect(path, sep());\n+}\n+\n+\n+fn mangle_name_by_type(@crate_ctxt cx, @ty.t t) -> str {\n+    cx.sha.reset();\n+    auto f = metadata.def_to_str;\n+    cx.sha.input_str(metadata.ty_str(t, f));\n+    ret sep() + \"rust\" + sep()\n+        + cx.sha.result_str() + sep()\n+        + path_name(cx.path);\n+}\n+\n+fn mangle_name_by_seq(@crate_ctxt cx, str flav) -> str {\n+    ret sep() + \"rust\" + sep()\n+        + cx.names.next(flav) + sep()\n+        + path_name(cx.path);\n+}\n+\n fn res(@block_ctxt bcx, ValueRef val) -> result {\n     ret rec(mutable bcx = bcx,\n             mutable val = val);\n@@ -1549,7 +1573,8 @@ fn define_tydesc(@crate_ctxt cx, @ty.t t, vec[ast.def_id] typaram_defs) {\n fn declare_generic_glue(@crate_ctxt cx, @ty.t t, str name) -> ValueRef {\n     auto llfnty = T_glue_fn(cx.tn);\n \n-    auto fn_name = cx.names.next(\"_rust_\" + name) + sep() + ty.ty_to_str(t);\n+    auto gcx = @rec(path=vec(\"glue\", name) with *cx);\n+    auto fn_name = mangle_name_by_type(gcx, t);\n     fn_name = sanitize(fn_name);\n     auto llfn = decl_fastcall_fn(cx.llmod, fn_name, llfnty);\n     llvm.LLVMSetLinkage(llfn, lib.llvm.LLVMPrivateLinkage as llvm.Linkage);\n@@ -3193,9 +3218,7 @@ fn trans_for_each(@block_ctxt cx,\n \n     // Step 2: Declare foreach body function.\n \n-    let str s =\n-        cx.fcx.ccx.names.next(\"_rust_foreach\")\n-        + sep() + cx.fcx.ccx.path;\n+    let str s = mangle_name_by_seq(cx.fcx.ccx, \"foreach\");\n \n     // The 'env' arg entering the body function is a fake env member (as in\n     // the env-part of the normal rust calling convention) that actually\n@@ -3788,7 +3811,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     // Construct a thunk-call with signature incoming_fty, and that copies\n     // args forward into a call to outgoing_fty.\n \n-    let str s = cx.names.next(\"_rust_thunk\") + sep() + cx.path;\n+    let str s = mangle_name_by_seq(cx, \"thunk\");\n     let TypeRef llthunk_ty = get_pair_fn_ty(type_of(cx, incoming_fty));\n     let ValueRef llthunk = decl_fastcall_fn(cx.llmod, s, llthunk_ty);\n \n@@ -5327,7 +5350,6 @@ fn trans_fn(@crate_ctxt cx, &ast._fn f, ast.def_id fid,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llfndecl = cx.item_ids.get(fid);\n-    cx.item_names.insert(cx.path, llfndecl);\n \n     auto fcx = new_fn_ctxt(cx, llfndecl);\n     create_llargs_for_fn_args(fcx, f.proto,\n@@ -5378,22 +5400,21 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n             }\n         }\n \n-        let @crate_ctxt mcx = @rec(path=cx.path + sep() + m.node.ident\n-                                   with *cx);\n-\n-        let str s = cx.names.next(\"_rust_method\") + sep() + mcx.path;\n+        let @crate_ctxt mcx = extend_path(cx, m.node.ident);\n+        let str s = mangle_name_by_seq(mcx, \"method\");\n         let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfnty);\n         cx.item_ids.insert(m.node.id, llfn);\n         cx.item_symbols.insert(m.node.id, s);\n \n+\n         trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n                  ty_params, m.node.ann);\n         methods += vec(llfn);\n     }\n     auto vtbl = C_struct(methods);\n-    auto gvar = llvm.LLVMAddGlobal(cx.llmod,\n-                                   val_ty(vtbl),\n-                                   _str.buf(\"_rust_vtbl\" + sep() + cx.path));\n+    auto vtbl_name = mangle_name_by_seq(cx, \"vtbl\");\n+    auto gvar = llvm.LLVMAddGlobal(cx.llmod, val_ty(vtbl),\n+                                   _str.buf(vtbl_name));\n     llvm.LLVMSetInitializer(gvar, vtbl);\n     llvm.LLVMSetGlobalConstant(gvar, True);\n     llvm.LLVMSetLinkage(gvar, lib.llvm.LLVMPrivateLinkage\n@@ -5405,7 +5426,6 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n              &vec[ast.ty_param] ty_params, &ast.ann ann) {\n \n     auto llctor_decl = cx.item_ids.get(oid);\n-    cx.item_names.insert(cx.path, llctor_decl);\n \n     // Translate obj ctor args to function arguments.\n     let vec[ast.arg] fn_args = vec();\n@@ -5628,29 +5648,29 @@ fn trans_const(@crate_ctxt cx, @ast.expr e,\n fn trans_item(@crate_ctxt cx, &ast.item item) {\n     alt (item.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n-            auto sub_cx = @rec(path=cx.path + sep() + name with *cx);\n+            auto sub_cx = extend_path(cx, name);\n             trans_fn(sub_cx, f, fid, none[TypeRef], tps, ann);\n         }\n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n-            auto sub_cx = @rec(path=cx.path + sep() + name,\n-                               obj_typarams=tps,\n-                               obj_fields=ob.fields with *cx);\n+            auto sub_cx = @rec(obj_typarams=tps,\n+                               obj_fields=ob.fields with\n+                               *extend_path(cx, name));\n             trans_obj(sub_cx, ob, oid, tps, ann);\n         }\n         case (ast.item_mod(?name, ?m, _)) {\n-            auto sub_cx = @rec(path=cx.path + sep() + name with *cx);\n+            auto sub_cx = extend_path(cx, name);\n             trans_mod(sub_cx, m);\n         }\n         case (ast.item_tag(?name, ?variants, ?tps, ?tag_id)) {\n-            auto sub_cx = @rec(path=cx.path + sep() + name with *cx);\n+            auto sub_cx = extend_path(cx, name);\n             auto i = 0;\n             for (ast.variant variant in variants) {\n                 trans_tag_variant(sub_cx, tag_id, variant, i, tps);\n                 i += 1;\n             }\n         }\n         case (ast.item_const(?name, _, ?expr, ?cid, ?ann)) {\n-            auto sub_cx = @rec(path=cx.path + sep() + name with *cx);\n+            auto sub_cx = extend_path(cx, name);\n             trans_const(sub_cx, expr, cid, ann);\n         }\n         case (_) { /* fall through */ }\n@@ -5672,8 +5692,7 @@ fn get_pair_fn_ty(TypeRef llpairty) -> TypeRef {\n }\n \n fn decl_fn_and_pair(@crate_ctxt cx,\n-                    str kind,\n-                    str name,\n+                    str flav,\n                     vec[ast.ty_param] ty_params,\n                     &ast.ann ann,\n                     ast.def_id id) {\n@@ -5693,11 +5712,11 @@ fn decl_fn_and_pair(@crate_ctxt cx,\n     }\n \n     // Declare the function itself.\n-    let str s = cx.names.next(\"_rust_\" + kind) + sep() + name;\n+    let str s = mangle_name_by_seq(cx, flav);\n     let ValueRef llfn = decl_fastcall_fn(cx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n-    let str ps = cx.names.next(\"_rust_\" + kind + \"_pair\") + sep() + name;\n+    let str ps = mangle_name_by_type(cx, node_ann_type(cx, ann));\n \n     register_fn_pair(cx, ps, llpairty, llfn, id);\n }\n@@ -5756,14 +5775,14 @@ fn decl_native_fn_and_pair(@crate_ctxt cx,\n \n     // Declare the wrapper.\n     auto wrapper_type = native_fn_wrapper_type(cx, num_ty_param, ann);\n-    let str s = cx.names.next(\"_rust_wrapper\") + sep() + name;\n+    let str s = mangle_name_by_seq(cx, \"wrapper\");\n     let ValueRef wrapper_fn = decl_fastcall_fn(cx.llmod, s, wrapper_type);\n     llvm.LLVMSetLinkage(wrapper_fn, lib.llvm.LLVMPrivateLinkage\n                         as llvm.Linkage);\n \n     // Declare the global constant pair that points to it.\n     auto wrapper_pair_type = T_fn_pair(cx.tn, wrapper_type);\n-    let str ps = cx.names.next(\"_rust_wrapper_pair\") + sep() + name;\n+    let str ps = mangle_name_by_type(cx, node_ann_type(cx, ann));\n \n     register_fn_pair(cx, ps, wrapper_pair_type, wrapper_fn, id);\n \n@@ -5827,8 +5846,33 @@ fn collect_native_item(&@crate_ctxt cx, @ast.native_item i) -> @crate_ctxt {\n     ret cx;\n }\n \n-fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n+fn item_name(@ast.item i) -> str {\n+    alt (i.node) {\n+        case (ast.item_mod(?name, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_tag(?name, _, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_const(?name, _, _, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_fn(?name, _, _, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_native_mod(?name, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_ty(?name, _, _, _, _)) {\n+            ret name;\n+        }\n+        case (ast.item_obj(?name, _, _, _, _)) {\n+            ret name;\n+        }\n+    }\n+}\n \n+fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_const(?name, _, _, ?cid, ?ann)) {\n             auto typ = node_ann_type(cx, ann);\n@@ -5844,35 +5888,36 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n             cx.items.insert(mid, i);\n         }\n \n-        case (ast.item_tag(_, ?variants, ?tps, ?tag_id)) {\n+        case (ast.item_tag(?name, ?variants, ?tps, ?tag_id)) {\n             cx.items.insert(tag_id, i);\n         }\n-\n         case (_) { /* fall through */ }\n     }\n-    ret cx;\n+    ret extend_path(cx, item_name(i));\n }\n \n fn collect_item_pass2(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, ?tps, ?fid, ?ann)) {\n             cx.items.insert(fid, i);\n             if (! cx.obj_methods.contains_key(fid)) {\n-                decl_fn_and_pair(cx, \"fn\", name, tps, ann, fid);\n+                decl_fn_and_pair(extend_path(cx, name), \"fn\",\n+                                 tps, ann, fid);\n             }\n         }\n \n         case (ast.item_obj(?name, ?ob, ?tps, ?oid, ?ann)) {\n             cx.items.insert(oid, i);\n-            decl_fn_and_pair(cx, \"obj_ctor\", name, tps, ann, oid);\n+            decl_fn_and_pair(extend_path(cx, name), \"obj_ctor\",\n+                             tps, ann, oid);\n             for (@ast.method m in ob.methods) {\n                 cx.obj_methods.insert(m.node.id, ());\n             }\n         }\n \n         case (_) { /* fall through */ }\n     }\n-    ret cx;\n+    ret extend_path(cx, item_name(i));\n }\n \n \n@@ -5904,7 +5949,7 @@ fn collect_tag_ctor(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n         case (ast.item_tag(_, ?variants, ?tps, _)) {\n             for (ast.variant variant in variants) {\n                 if (_vec.len[ast.variant_arg](variant.args) != 0u) {\n-                    decl_fn_and_pair(cx, \"tag\", variant.name,\n+                    decl_fn_and_pair(extend_path(cx, variant.name), \"tag\",\n                                      tps, variant.ann, variant.id);\n                 }\n             }\n@@ -5963,7 +6008,8 @@ fn trans_constant(&@crate_ctxt cx, @ast.item it) -> @crate_ctxt {\n             // with consts.\n             auto v = C_int(1);\n             cx.item_ids.insert(cid, v);\n-            auto s = cx.names.next(\"_rust_const\") + sep() + name;\n+            auto s = mangle_name_by_type(extend_path(cx, name),\n+                                         node_ann_type(cx, ann));\n             cx.item_symbols.insert(cid, s);\n         }\n \n@@ -6064,10 +6110,10 @@ fn find_main_fn(@crate_ctxt cx) -> ValueRef {\n     auto e = sep() + \"main\";\n     let ValueRef v = C_nil();\n     let uint n = 0u;\n-    for each (@tup(str,ValueRef) i in cx.item_names.items()) {\n-        if (_str.ends_with(i._0, e)) {\n+    for each (@tup(ast.def_id, str) i in cx.item_symbols.items()) {\n+        if (_str.ends_with(i._1, e)) {\n             n += 1u;\n-            v = i._1;\n+            v = cx.item_ids.get(i._0);\n         }\n     }\n     alt (n) {\n@@ -6534,14 +6580,14 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n     let vec[ast.ty_param] obj_typarams = vec();\n     let vec[ast.obj_field] obj_fields = vec();\n \n+    let vec[str] pth = vec();\n     auto cx = @rec(sess = sess,\n                    llmod = llmod,\n                    td = td,\n                    tn = tn,\n                    crate_ptr = crate_ptr,\n                    externs = new_str_hash[ValueRef](),\n                    intrinsics = intrinsics,\n-                   item_names = new_str_hash[ValueRef](),\n                    item_ids = new_def_hash[ValueRef](),\n                    items = new_def_hash[@ast.item](),\n                    native_items = new_def_hash[@ast.native_item](),\n@@ -6557,7 +6603,8 @@ fn trans_crate(session.session sess, @ast.crate crate, str output,\n                    obj_fields = obj_fields,\n                    glues = glues,\n                    names = namegen(0),\n-                   path = \"_rust\");\n+                   path = pth,\n+                   sha = std.sha1.mk_sha1());\n \n     create_typedefs(cx);\n "}]}