{"sha": "6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkYjRiZWIzZTgzM2ViN2Q4ZGFhZDMwZTJhOWVjYzI3ZDU0YTAzMTg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-12T09:43:48Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-05-15T21:36:07Z"}, "message": "use equality in the coerce-unsized check\n\nThis seems both to be a safe, conservative choice,\nand it sidesteps the cycle in #41936.\n\nFixes #41936.", "tree": {"sha": "87e10efa1364b18db67cd7a82c98d6854cfdff3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87e10efa1364b18db67cd7a82c98d6854cfdff3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "html_url": "https://github.com/rust-lang/rust/commit/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75b05681239cb309a23fcb4f8864f177e5aa62da", "url": "https://api.github.com/repos/rust-lang/rust/commits/75b05681239cb309a23fcb4f8864f177e5aa62da", "html_url": "https://github.com/rust-lang/rust/commit/75b05681239cb309a23fcb4f8864f177e5aa62da"}], "stats": {"total": 108, "additions": 106, "deletions": 2}, "files": [{"sha": "aabb6aff55140c4138efecfa741db1245b2e0e4b", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "patch": "@@ -39,10 +39,12 @@ use super::sub::Sub;\n use super::InferCtxt;\n use super::{MiscVariable, TypeTrace};\n \n+use hir::def_id::DefId;\n use ty::{IntType, UintType};\n use ty::{self, Ty, TyCtxt};\n use ty::error::TypeError;\n use ty::relate::{self, Relate, RelateResult, TypeRelation};\n+use ty::subst::Substs;\n use traits::{Obligation, PredicateObligations};\n \n use syntax::ast;\n@@ -336,6 +338,23 @@ impl<'cx, 'gcx, 'tcx> TypeRelation<'cx, 'gcx, 'tcx> for Generalizer<'cx, 'gcx, '\n         Ok(ty::Binder(self.relate(a.skip_binder(), b.skip_binder())?))\n     }\n \n+    fn relate_item_substs(&mut self,\n+                          item_def_id: DefId,\n+                          a_subst: &'tcx Substs<'tcx>,\n+                          b_subst: &'tcx Substs<'tcx>)\n+                          -> RelateResult<'tcx, &'tcx Substs<'tcx>>\n+    {\n+        if self.ambient_variance == ty::Variance::Invariant {\n+            // Avoid fetching the variance if we are in an invariant\n+            // context; no need, and it can induce dependency cycles\n+            // (e.g. #41849).\n+            relate::relate_substs(self, None, a_subst, b_subst)\n+        } else {\n+            let opt_variances = self.tcx().variances_of(item_def_id);\n+            relate::relate_substs(self, Some(&opt_variances), a_subst, b_subst)\n+        }\n+    }\n+\n     fn relate_with_variance<T: Relate<'tcx>>(&mut self,\n                                              variance: ty::Variance,\n                                              a: &T,"}, {"sha": "556bd618c78cbb22e49b90b503f1daad2577d4a6", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "patch": "@@ -249,6 +249,45 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     return err_info;\n                 }\n \n+                // Here we are considering a case of converting\n+                // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+                // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n+                //\n+                //     struct Foo<T, U> {\n+                //         extra: T,\n+                //         ptr: *mut U,\n+                //     }\n+                //\n+                // We might have an impl that allows (e.g.) `Foo<T, [i32; 3]>` to be unsized\n+                // to `Foo<T, [i32]>`. That impl would look like:\n+                //\n+                //   impl<T, U: Unsize<V>, V> CoerceUnsized<Foo<T, V>> for Foo<T, U> {}\n+                //\n+                // Here `U = [i32; 3]` and `V = [i32]`. At runtime,\n+                // when this coercion occurs, we would be changing the\n+                // field `ptr` from a thin pointer of type `*mut [i32;\n+                // 3]` to a fat pointer of type `*mut [i32]` (with\n+                // extra data `3`).  **The purpose of this check is to\n+                // make sure that we know how to do this conversion.**\n+                //\n+                // To check if this impl is legal, we would walk down\n+                // the fields of `Foo` and consider their types with\n+                // both substitutes. We are looking to find that\n+                // exactly one (non-phantom) field has changed its\n+                // type, which we will expect to be the pointer that\n+                // is becoming fat (we could probably generalize this\n+                // to mutiple thin pointers of the same type becoming\n+                // fat, but we don't). In this case:\n+                //\n+                // - `extra` has type `T` before and type `T` after\n+                // - `ptr` has type `*mut U` before and type `*mut V` after\n+                //\n+                // Since just one field changed, we would then check\n+                // that `*mut U: CoerceUnsized<*mut V>` is implemented\n+                // (in other words, that we know how to do this\n+                // conversion). This will work out because `U:\n+                // Unsize<V>`, and we have a builtin rule that `*mut\n+                // U` can be coerced to `*mut V` if `U: Unsize<V>`.\n                 let fields = &def_a.struct_variant().fields;\n                 let diff_fields = fields.iter()\n                     .enumerate()\n@@ -260,8 +299,16 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             return None;\n                         }\n \n-                        // Ignore fields that aren't significantly changed\n-                        if let Ok(ok) = infcx.sub_types(false, &cause, b, a) {\n+                        // Ignore fields that aren't changed; it may\n+                        // be that we could get away with subtyping or\n+                        // something more accepting, but we use\n+                        // equality because we want to be able to\n+                        // perform this check without computing\n+                        // variance where possible. (This is because\n+                        // we may have to evaluate constraint\n+                        // expressions in the course of execution.)\n+                        // See e.g. #41936.\n+                        if let Ok(ok) = infcx.eq_types(false, &cause, b, a) {\n                             if ok.obligations.is_empty() {\n                                 return None;\n                             }"}, {"sha": "bfbead87891784e123ba6ae6ad5dd5ff3f797e5d", "filename": "src/test/run-pass/issue-41936-variance-coerce-unsized-cycle.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6db4beb3e833eb7d8daad30e2a9ecc27d54a0318/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-41936-variance-coerce-unsized-cycle.rs?ref=6db4beb3e833eb7d8daad30e2a9ecc27d54a0318", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #41936. The coerce-unsized trait check in\n+// coherence was using subtyping, which triggered variance\n+// computation, which failed because it required type info for fields\n+// that had not (yet) been computed.\n+\n+#![feature(unsize)]\n+#![feature(coerce_unsized)]\n+\n+use std::{marker,ops};\n+\n+// Change the array to a non-array, and error disappears\n+// Adding a new field to the end keeps the error\n+struct LogDataBuf([u8;8]);\n+\n+struct Aref<T: ?Sized>\n+{\n+    // Inner structure triggers the error, removing the inner removes the message.\n+    ptr: Box<ArefInner<T>>,\n+}\n+impl<T: ?Sized + marker::Unsize<U>, U: ?Sized> ops::CoerceUnsized<Aref<U>> for Aref<T> {}\n+\n+struct ArefInner<T: ?Sized>\n+{\n+    // Even with this field commented out, the error is raised.\n+    data: T,\n+}\n+\n+fn main(){}"}]}