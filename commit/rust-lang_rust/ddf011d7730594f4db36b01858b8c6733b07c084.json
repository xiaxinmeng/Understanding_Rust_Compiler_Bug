{"sha": "ddf011d7730594f4db36b01858b8c6733b07c084", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZjAxMWQ3NzMwNTk0ZjRkYjM2YjAxODU4YjhjNjczM2IwN2MwODQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-11-24T14:26:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-11-24T14:26:36Z"}, "message": "Auto merge of #37770 - pnkfelix:print-type-sizes, r=arielb1\n\nAdd debug flag `-Z print-type-sizes` for instrumention type/variant sizes\n\nAdd debug flag `-Z print-type-sizes` for instrumention type/variant sizes\n\nThis is meant to help with things like #36799 in a very local way; namely, once you have a hypothesis as to which types have a large population or are \"too large\", you can use `-Z print-type-sizes` to learn how large each type is, and how much each variant in an enum contributes to the size of that overall enum.", "tree": {"sha": "05c3a6190c0d95f42efbfed07b6dceec72eb7695", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c3a6190c0d95f42efbfed07b6dceec72eb7695"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddf011d7730594f4db36b01858b8c6733b07c084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddf011d7730594f4db36b01858b8c6733b07c084", "html_url": "https://github.com/rust-lang/rust/commit/ddf011d7730594f4db36b01858b8c6733b07c084", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddf011d7730594f4db36b01858b8c6733b07c084/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "217f57c0b58aeaf6a4a885ab49148095124d9f46", "url": "https://api.github.com/repos/rust-lang/rust/commits/217f57c0b58aeaf6a4a885ab49148095124d9f46", "html_url": "https://github.com/rust-lang/rust/commit/217f57c0b58aeaf6a4a885ab49148095124d9f46"}, {"sha": "75825fe1df47866e1821d8b09f4c75930b6e57c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/75825fe1df47866e1821d8b09f4c75930b6e57c1", "html_url": "https://github.com/rust-lang/rust/commit/75825fe1df47866e1821d8b09f4c75930b6e57c1"}], "stats": {"total": 832, "additions": 830, "deletions": 2}, "files": [{"sha": "8308c54d70bf49a3a574b908a3fb165c244ef5c2", "filename": "src/librustc/session/code_stats.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::AdtKind;\n+use ty::layout::{Align, Size};\n+\n+use rustc_data_structures::fx::{FxHashSet};\n+\n+use std::cmp::{self, Ordering};\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct VariantInfo {\n+    pub name: Option<String>,\n+    pub kind: SizeKind,\n+    pub size: u64,\n+    pub align: u64,\n+    pub fields: Vec<FieldInfo>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum SizeKind { Exact, Min }\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FieldInfo {\n+    pub name: String,\n+    pub offset: u64,\n+    pub size: u64,\n+    pub align: u64,\n+}\n+\n+impl From<AdtKind> for DataTypeKind {\n+    fn from(kind: AdtKind) -> Self {\n+        match kind {\n+            AdtKind::Struct => DataTypeKind::Struct,\n+            AdtKind::Enum => DataTypeKind::Enum,\n+            AdtKind::Union => DataTypeKind::Union,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DataTypeKind {\n+    Struct,\n+    Union,\n+    Enum,\n+    Closure,\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct TypeSizeInfo {\n+    pub kind: DataTypeKind,\n+    pub type_description: String,\n+    pub align: u64,\n+    pub overall_size: u64,\n+    pub opt_discr_size: Option<u64>,\n+    pub variants: Vec<VariantInfo>,\n+}\n+\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct CodeStats {\n+    type_sizes: FxHashSet<TypeSizeInfo>,\n+}\n+\n+impl CodeStats {\n+    pub fn new() -> Self { CodeStats { type_sizes: FxHashSet() } }\n+\n+    pub fn record_type_size<S: ToString>(&mut self,\n+                                         kind: DataTypeKind,\n+                                         type_desc: S,\n+                                         align: Align,\n+                                         overall_size: Size,\n+                                         opt_discr_size: Option<Size>,\n+                                         variants: Vec<VariantInfo>) {\n+        let info = TypeSizeInfo {\n+            kind: kind,\n+            type_description: type_desc.to_string(),\n+            align: align.abi(),\n+            overall_size: overall_size.bytes(),\n+            opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n+            variants: variants,\n+        };\n+        self.type_sizes.insert(info);\n+    }\n+\n+    pub fn print_type_sizes(&self) {\n+        let mut sorted: Vec<_> = self.type_sizes.iter().collect();\n+\n+        // Primary sort: large-to-small.\n+        // Secondary sort: description (dictionary order)\n+        sorted.sort_by(|info1, info2| {\n+            // (reversing cmp order to get large-to-small ordering)\n+            match info2.overall_size.cmp(&info1.overall_size) {\n+                Ordering::Equal => info1.type_description.cmp(&info2.type_description),\n+                other => other,\n+            }\n+        });\n+\n+        for info in &sorted {\n+            println!(\"print-type-size type: `{}`: {} bytes, alignment: {} bytes\",\n+                     info.type_description, info.overall_size, info.align);\n+            let indent = \"    \";\n+\n+            let discr_size = if let Some(discr_size) = info.opt_discr_size {\n+                println!(\"print-type-size {}discriminant: {} bytes\",\n+                         indent, discr_size);\n+                discr_size\n+            } else {\n+                0\n+            };\n+\n+            // We start this at discr_size (rather than 0) because\n+            // things like C-enums do not have variants but we still\n+            // want the max_variant_size at the end of the loop below\n+            // to reflect the presence of the discriminant.\n+            let mut max_variant_size = discr_size;\n+\n+            let struct_like = match info.kind {\n+                DataTypeKind::Struct | DataTypeKind::Closure => true,\n+                DataTypeKind::Enum | DataTypeKind::Union => false,\n+            };\n+            for (i, variant_info) in info.variants.iter().enumerate() {\n+                let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;\n+                let indent = if !struct_like {\n+                    let name = match name.as_ref() {\n+                        Some(name) => format!(\"{}\", name),\n+                        None => format!(\"{}\", i),\n+                    };\n+                    println!(\"print-type-size {}variant `{}`: {} bytes\",\n+                             indent, name, size - discr_size);\n+                    \"        \"\n+                } else {\n+                    assert!(i < 1);\n+                    \"    \"\n+                };\n+                max_variant_size = cmp::max(max_variant_size, size);\n+\n+                let mut min_offset = discr_size;\n+                for field in fields {\n+                    let FieldInfo { ref name, offset, size, align } = *field;\n+\n+                    // Include field alignment in output only if it caused padding injection\n+                    if min_offset != offset {\n+                        let pad = offset - min_offset;\n+                        println!(\"print-type-size {}padding: {} bytes\",\n+                                 indent, pad);\n+                        println!(\"print-type-size {}field `.{}`: {} bytes, alignment: {} bytes\",\n+                                 indent, name, size, align);\n+                    } else {\n+                        println!(\"print-type-size {}field `.{}`: {} bytes\",\n+                                 indent, name, size);\n+                    }\n+\n+                    min_offset = offset + size;\n+                }\n+            }\n+\n+            assert!(max_variant_size <= info.overall_size,\n+                    \"max_variant_size {} !<= {} overall_size\",\n+                    max_variant_size, info.overall_size);\n+            if max_variant_size < info.overall_size {\n+                println!(\"print-type-size {}end padding: {} bytes\",\n+                         indent, info.overall_size - max_variant_size);\n+            }\n+        }\n+    }\n+}"}, {"sha": "26dafed7019ed7b9e25c8f6732fb222636aa4ab6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -909,6 +909,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"keep the AST after lowering it to HIR\"),\n     show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n+    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n+          \"print layout information for each type encountered\"),\n     print_trans_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"print the result of the translation item collection pass\"),\n     mir_opt_level: Option<usize> = (None, parse_opt_uint, [TRACKED],"}, {"sha": "3d8cfd199615e491c916909e0c81cc10e12b5b82", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n+pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n+\n use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n@@ -49,6 +52,7 @@ use std::fmt;\n use std::time::Duration;\n use libc::c_int;\n \n+mod code_stats;\n pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n@@ -112,6 +116,9 @@ pub struct Session {\n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n \n+    /// Data about code being compiled, gathered during compilation.\n+    pub code_stats: RefCell<CodeStats>,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n@@ -624,7 +631,8 @@ pub fn build_session_(sopts: config::Options,\n             incr_comp_hashes_count: Cell::new(0),\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n-        }\n+        },\n+        code_stats: RefCell::new(CodeStats::new()),\n     };\n \n     init_llvm(&sess);"}, {"sha": "bc3c5d6ed4e203d845ae3e6c3697d0a8394175ab", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -559,11 +559,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             self.offsets.push(offset);\n \n+            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        debug!(\"Struct::extend min_size: {:?}\", offset);\n+\n         self.min_size = offset;\n \n         Ok(())\n@@ -707,12 +710,16 @@ impl<'a, 'gcx, 'tcx> Union {\n                      index, scapegoat);\n             }\n \n+            debug!(\"Union::extend field: {:?} {:?}\", field, field.size(dl));\n+\n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n \n+        debug!(\"Union::extend min-size: {:?}\", self.min_size);\n+\n         Ok(())\n     }\n "}, {"sha": "9a4ecef0c0ebd16d91aa36670a9a6835e2bb4248", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -215,6 +215,10 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n+    if sess.opts.debugging_opts.print_type_sizes {\n+        sess.code_stats.borrow().print_type_sizes();\n+    }\n+\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,"}, {"sha": "e091ba07d4feaffd7f76dae85eedb3934f8e362c", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -247,6 +247,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             let size = size.bytes();\n             let align = align.abi();\n+            assert!(align <= std::u32::MAX as u64);\n             let discr_ty = Type::from_integer(cx, discr);\n             let discr_size = discr.size().bytes();\n             let padded_discr_size = roundup(discr_size, align as u32);"}, {"sha": "d697a5bafb79ed5a6d9503fb88269c5fdb6fabab", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 192, "deletions": 1, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -47,7 +47,7 @@ use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use session::config::{self, NoDebugInfo};\n use rustc_incremental::IncrementalHashesMap;\n-use session::Session;\n+use session::{self, DataTypeKind, Session};\n use abi::{self, Abi, FnType};\n use adt;\n use attributes;\n@@ -93,6 +93,7 @@ use std::i32;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::attr;\n use rustc::hir;\n+use rustc::ty::layout::{self, Layout};\n use syntax::ast;\n \n thread_local! {\n@@ -1741,6 +1742,10 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               .collect())\n     });\n \n+    if tcx.sess.opts.debugging_opts.print_type_sizes {\n+        gather_type_sizes(tcx);\n+    }\n+\n     if sess.target.target.options.is_like_msvc &&\n        sess.crate_types.borrow().iter().any(|ct| *ct == config::CrateTypeRlib) {\n         create_imps(&crate_context_list);\n@@ -1771,6 +1776,192 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let layout_cache = tcx.layout_cache.borrow();\n+    for (ty, layout) in layout_cache.iter() {\n+\n+        // (delay format until we actually need it)\n+        let record = |kind, opt_discr_size, variants| {\n+            let type_desc = format!(\"{:?}\", ty);\n+            let overall_size = layout.size(&tcx.data_layout);\n+            let align = layout.align(&tcx.data_layout);\n+            tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n+                                                              type_desc,\n+                                                              align,\n+                                                              overall_size,\n+                                                              opt_discr_size,\n+                                                              variants);\n+        };\n+\n+        let (adt_def, substs) = match ty.sty {\n+            ty::TyAdt(ref adt_def, substs) => {\n+                debug!(\"print-type-size t: `{:?}` process adt\", ty);\n+                (adt_def, substs)\n+            }\n+\n+            ty::TyClosure(..) => {\n+                debug!(\"print-type-size t: `{:?}` record closure\", ty);\n+                record(DataTypeKind::Closure, None, vec![]);\n+                continue;\n+            }\n+\n+            _ => {\n+                debug!(\"print-type-size t: `{:?}` skip non-nominal\", ty);\n+                continue;\n+            }\n+        };\n+\n+        let adt_kind = adt_def.adt_kind();\n+\n+        let build_field_info = |(field_name, field_ty): (ast::Name, Ty), offset: &layout::Size| {\n+            match layout_cache.get(&field_ty) {\n+                None => bug!(\"no layout found for field {} type: `{:?}`\", field_name, field_ty),\n+                Some(field_layout) => {\n+                    session::FieldInfo {\n+                        name: field_name.to_string(),\n+                        offset: offset.bytes(),\n+                        size: field_layout.size(&tcx.data_layout).bytes(),\n+                        align: field_layout.align(&tcx.data_layout).abi(),\n+                    }\n+                }\n+            }\n+        };\n+\n+        let build_primitive_info = |name: ast::Name, value: &layout::Primitive| {\n+            session::VariantInfo {\n+                name: Some(name.to_string()),\n+                kind: session::SizeKind::Exact,\n+                align: value.align(&tcx.data_layout).abi(),\n+                size: value.size(&tcx.data_layout).bytes(),\n+                fields: vec![],\n+            }\n+        };\n+\n+        enum Fields<'a> {\n+            WithDiscrim(&'a layout::Struct),\n+            NoDiscrim(&'a layout::Struct),\n+        }\n+\n+        let build_variant_info = |n: Option<ast::Name>, flds: &[(ast::Name, Ty)], layout: Fields| {\n+            let (s, field_offsets) = match layout {\n+                Fields::WithDiscrim(s) => (s, &s.offsets[1..]),\n+                Fields::NoDiscrim(s) => (s, &s.offsets[0..]),\n+            };\n+            let field_info: Vec<_> = flds.iter()\n+                .zip(field_offsets.iter())\n+                .map(|(&field_name_ty, offset)| build_field_info(field_name_ty, offset))\n+                .collect();\n+\n+            session::VariantInfo {\n+                name: n.map(|n|n.to_string()),\n+                kind: if s.sized {\n+                    session::SizeKind::Exact\n+                } else {\n+                    session::SizeKind::Min\n+                },\n+                align: s.align.abi(),\n+                size: s.min_size.bytes(),\n+                fields: field_info,\n+            }\n+        };\n+\n+        match **layout {\n+            Layout::StructWrappedNullablePointer { nonnull: ref variant_layout,\n+                                                   nndiscr,\n+                                                   discrfield: _ } => {\n+                debug!(\"print-type-size t: `{:?}` adt struct-wrapped nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, variant_layout);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                let fields: Vec<_> = variant_def.fields.iter()\n+                    .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                    .collect();\n+                record(adt_kind.into(),\n+                       None,\n+                       vec![build_variant_info(Some(variant_def.name),\n+                                               &fields,\n+                                               Fields::NoDiscrim(variant_layout))]);\n+            }\n+            Layout::RawNullablePointer { nndiscr, value } => {\n+                debug!(\"print-type-size t: `{:?}` adt raw nullable nndiscr {} is {:?}\",\n+                       ty, nndiscr, value);\n+                let variant_def = &adt_def.variants[nndiscr as usize];\n+                record(adt_kind.into(), None,\n+                       vec![build_primitive_info(variant_def.name, &value)]);\n+            }\n+            Layout::Univariant { variant: ref variant_layout, non_zero: _ } => {\n+                let variant_names = || {\n+                    adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n+                };\n+                debug!(\"print-type-size t: `{:?}` adt univariant {:?} variants: {:?}\",\n+                       ty, variant_layout, variant_names());\n+                assert!(adt_def.variants.len() <= 1,\n+                        \"univariant with variants {:?}\", variant_names());\n+                if adt_def.variants.len() == 1 {\n+                    let variant_def = &adt_def.variants[0];\n+                    let fields: Vec<_> = variant_def.fields.iter()\n+                        .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                        .collect();\n+                    record(adt_kind.into(),\n+                           None,\n+                           vec![build_variant_info(Some(variant_def.name),\n+                                                   &fields,\n+                                                   Fields::NoDiscrim(variant_layout))]);\n+                } else {\n+                    // (This case arises for *empty* enums; so give it\n+                    // zero variants.)\n+                    record(adt_kind.into(), None, vec![]);\n+                }\n+            }\n+\n+            Layout::General { ref variants, discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt general variants def {} layouts {} {:?}\",\n+                       ty, adt_def.variants.len(), variants.len(), variants);\n+                let variant_infos: Vec<_> = adt_def.variants.iter()\n+                    .zip(variants.iter())\n+                    .map(|(variant_def, variant_layout)| {\n+                        let fields: Vec<_> = variant_def.fields.iter()\n+                            .map(|field_def| (field_def.name, field_def.ty(tcx, substs)))\n+                            .collect();\n+                        build_variant_info(Some(variant_def.name),\n+                                           &fields,\n+                                           Fields::WithDiscrim(variant_layout))\n+                    })\n+                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            Layout::UntaggedUnion { ref variants } => {\n+                debug!(\"print-type-size t: `{:?}` adt union variants {:?}\",\n+                       ty, variants);\n+                // layout does not currently store info about each\n+                // variant...\n+                record(adt_kind.into(), None, Vec::new());\n+            }\n+\n+            Layout::CEnum { discr, .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt c-like enum\", ty);\n+                let variant_infos: Vec<_> = adt_def.variants.iter()\n+                    .map(|variant_def| {\n+                        build_primitive_info(variant_def.name,\n+                                             &layout::Primitive::Int(discr))\n+                    })\n+                    .collect();\n+                record(adt_kind.into(), Some(discr.size()), variant_infos);\n+            }\n+\n+            // other cases provide little interesting (i.e. adjustable\n+            // via representation tweaks) size info beyond total size.\n+            Layout::Scalar { .. } |\n+            Layout::Vector { .. } |\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } => {\n+                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n+                record(adt_kind.into(), None, Vec::new())\n+            }\n+        }\n+    }\n+}\n+\n /// For each CGU, identify if we can reuse an existing object file (or\n /// maybe other context).\n fn trans_reuse_previous_work_products(tcx: TyCtxt,"}, {"sha": "dc93bddbad8e2d83cfc52117f8088a1e3797cd42", "filename": "src/test/ui/print_type_sizes/anonymous.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fanonymous.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// All of the types that occur in this function are uninteresting, in\n+// that one cannot control the sizes of these types with the same sort\n+// of enum-variant manipulation tricks.\n+\n+pub fn main() {\n+    let _byte: u8 = 0;\n+    let _word: usize = 0;\n+    let _tuple: (u8, usize)= (0, 0);\n+    let _array: [u8; 128] = [0; 128];\n+    let _fn: fn (u8) -> u8 = id;\n+    let _diverging: fn (u8) -> ! = bye;\n+\n+    fn id(x: u8) -> u8 { x };\n+    fn bye(_: u8) -> ! { loop { } }\n+}"}, {"sha": "93bcd1c36e5926595094d6e9501d2c4a7e4e5dfd", "filename": "src/test/ui/print_type_sizes/generics.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how generics are handled: types have to be\n+// monomorphized, in the MIR of the original function in which they\n+// occur, to have their size reported.\n+\n+// In an ad-hoc attempt to avoid the injection of unwinding code\n+// (which clutters the output of `-Z print-type-sizes` with types from\n+// `unwind::libunwind`):\n+//\n+//   * I am not using Default to build values because that seems to\n+//     cause the injection of unwinding code. (Instead I just make `fn new`\n+//     methods.)\n+//\n+//   * Pair derive Copy to ensure that we don't inject\n+//     unwinding code into generic uses of Pair when T itself is also\n+//     Copy.\n+//\n+//     (I suspect this reflect some naivety within the rust compiler\n+//      itself; it should be checking for drop glue, i.e. a destructor\n+//      somewhere in the monomorphized types. It should not matter whether\n+//      the type is Copy.)\n+#[derive(Copy, Clone)]\n+pub struct Pair<T> {\n+    _car: T,\n+    _cdr: T,\n+}\n+\n+impl<T> Pair<T> {\n+    fn new(a: T, d: T) -> Self {\n+        Pair {\n+            _car: a,\n+            _cdr: d,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct SevenBytes([u8; 7]);\n+pub struct FiftyBytes([u8; 50]);\n+\n+pub struct ZeroSized;\n+\n+impl SevenBytes {\n+    fn new() -> Self { SevenBytes([0; 7]) }\n+}\n+\n+impl FiftyBytes {\n+    fn new() -> Self { FiftyBytes([0; 50]) }\n+}\n+\n+pub fn f1<T:Copy>(x: T) {\n+    let _v: Pair<T> = Pair::new(x, x);\n+    let _v2: Pair<FiftyBytes> =\n+        Pair::new(FiftyBytes::new(), FiftyBytes::new());\n+}\n+\n+pub fn main() {\n+    let _b: Pair<u8> = Pair::new(0, 0);\n+    let _s: Pair<SevenBytes> = Pair::new(SevenBytes::new(), SevenBytes::new());\n+    let _z: ZeroSized = ZeroSized;\n+    f1::<SevenBytes>(SevenBytes::new());\n+}"}, {"sha": "0f02f39795365d83b196311d96b4e111e3192633", "filename": "src/test/ui/print_type_sizes/generics.stdout", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fgenerics.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,14 @@\n+print-type-size type: `Pair<FiftyBytes>`: 100 bytes, alignment: 1 bytes\n+print-type-size     field `._car`: 50 bytes\n+print-type-size     field `._cdr`: 50 bytes\n+print-type-size type: `FiftyBytes`: 50 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 50 bytes\n+print-type-size type: `Pair<SevenBytes>`: 14 bytes, alignment: 1 bytes\n+print-type-size     field `._car`: 7 bytes\n+print-type-size     field `._cdr`: 7 bytes\n+print-type-size type: `SevenBytes`: 7 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 7 bytes\n+print-type-size type: `Pair<u8>`: 2 bytes, alignment: 1 bytes\n+print-type-size     field `._car`: 1 bytes\n+print-type-size     field `._cdr`: 1 bytes\n+print-type-size type: `ZeroSized`: 0 bytes, alignment: 1 bytes"}, {"sha": "2b5010767fdef2923efcbf984cadff2f2188179b", "filename": "src/test/ui/print_type_sizes/multiple_types.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates that when multiple structural types occur in\n+// a function, every one of them is included in the output.\n+\n+pub struct SevenBytes([u8;  7]);\n+pub struct FiftyBytes([u8; 50]);\n+\n+pub enum Enum {\n+    Small(SevenBytes),\n+    Large(FiftyBytes),\n+}\n+\n+pub fn main() {\n+    let _e: Enum;\n+    let _f: FiftyBytes;\n+    let _s: SevenBytes;\n+}"}, {"sha": "eed9af26987b46f64929c5895489a8941b62213f", "filename": "src/test/ui/print_type_sizes/multiple_types.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fmultiple_types.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,10 @@\n+print-type-size type: `Enum`: 51 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Small`: 7 bytes\n+print-type-size         field `.0`: 7 bytes\n+print-type-size     variant `Large`: 50 bytes\n+print-type-size         field `.0`: 50 bytes\n+print-type-size type: `FiftyBytes`: 50 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 50 bytes\n+print-type-size type: `SevenBytes`: 7 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 7 bytes"}, {"sha": "6008a346c059f529b589b6b00967a1be672d2c54", "filename": "src/test/ui/print_type_sizes/no_duplicates.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates that when the same type occurs repeatedly\n+// (even if multiple functions), it is only printed once in the\n+// print-type-sizes output.\n+\n+pub struct SevenBytes([u8; 7]);\n+\n+pub fn f1() {\n+    let _s: SevenBytes = SevenBytes([0; 7]);\n+}\n+\n+pub fn main() {\n+    let _s: SevenBytes = SevenBytes([0; 7]);\n+}"}, {"sha": "50180f356ea36c4d3330fd233fd09aa0bc778385", "filename": "src/test/ui/print_type_sizes/no_duplicates.stdout", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fno_duplicates.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,2 @@\n+print-type-size type: `SevenBytes`: 7 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 7 bytes"}, {"sha": "f7fdcac81daad4247e74cee79a034e56085d4c49", "filename": "src/test/ui/print_type_sizes/nullable.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how enums with a non-null field are handled,\n+// modelled after cases like `Option<&u32>` and such.\n+//\n+// It uses NonZero directly, rather than `&_` or `Unique<_>`, because\n+// the test is not set up to deal with target-dependent pointer width.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+\n+#![feature(nonzero)]\n+#![allow(dead_code)]\n+\n+extern crate core;\n+use core::nonzero::{NonZero, Zeroable};\n+\n+pub enum MyOption<T> { None, Some(T) }\n+\n+impl<T> Default for MyOption<T> {\n+    fn default() -> Self { MyOption::None }\n+}\n+\n+pub enum EmbeddedDiscr {\n+    None,\n+    Record { pre: u8, val: NonZero<u32>, post: u16 },\n+}\n+\n+impl Default for EmbeddedDiscr {\n+    fn default() -> Self { EmbeddedDiscr::None }\n+}\n+\n+#[derive(Default)]\n+pub struct IndirectNonZero<T: Zeroable> {\n+    pre: u8,\n+    nested: NestedNonZero<T>,\n+    post: u16,\n+}\n+\n+pub struct NestedNonZero<T: Zeroable> {\n+    pre: u8,\n+    val: NonZero<T>,\n+    post: u16,\n+}\n+\n+impl<T: Zeroable+Default> Default for NestedNonZero<T> {\n+    fn default() -> Self {\n+        unsafe {\n+            NestedNonZero { pre: 0, val: NonZero::new(Default::default()), post: 0 }\n+        }\n+    }\n+}\n+\n+pub fn main() {\n+    let _x: MyOption<NonZero<u32>> = Default::default();\n+    let _y: EmbeddedDiscr = Default::default();\n+    let _z: MyOption<IndirectNonZero<u32>> = Default::default();\n+}"}, {"sha": "dd999c4a5e4c779d1e30f105926d4a4ef4e07eda", "filename": "src/test/ui/print_type_sizes/nullable.stdout", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fnullable.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,27 @@\n+print-type-size type: `IndirectNonZero<u32>`: 20 bytes, alignment: 4 bytes\n+print-type-size     field `.pre`: 1 bytes\n+print-type-size     padding: 3 bytes\n+print-type-size     field `.nested`: 12 bytes, alignment: 4 bytes\n+print-type-size     field `.post`: 2 bytes\n+print-type-size     end padding: 2 bytes\n+print-type-size type: `MyOption<IndirectNonZero<u32>>`: 20 bytes, alignment: 4 bytes\n+print-type-size     variant `Some`: 20 bytes\n+print-type-size         field `.0`: 20 bytes\n+print-type-size type: `EmbeddedDiscr`: 12 bytes, alignment: 4 bytes\n+print-type-size     variant `Record`: 10 bytes\n+print-type-size         field `.pre`: 1 bytes\n+print-type-size         padding: 3 bytes\n+print-type-size         field `.val`: 4 bytes, alignment: 4 bytes\n+print-type-size         field `.post`: 2 bytes\n+print-type-size     end padding: 2 bytes\n+print-type-size type: `NestedNonZero<u32>`: 12 bytes, alignment: 4 bytes\n+print-type-size     field `.pre`: 1 bytes\n+print-type-size     padding: 3 bytes\n+print-type-size     field `.val`: 4 bytes, alignment: 4 bytes\n+print-type-size     field `.post`: 2 bytes\n+print-type-size     end padding: 2 bytes\n+print-type-size type: `MyOption<core::nonzero::NonZero<u32>>`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `Some`: 4 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size type: `core::nonzero::NonZero<u32>`: 4 bytes, alignment: 4 bytes\n+print-type-size     field `.0`: 4 bytes"}, {"sha": "cd7ef86d70ee3f4892fb0c66181af1c09eb7f367", "filename": "src/test/ui/print_type_sizes/packed.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how packing is handled; it should cause\n+// the elimination of padding that would normally be introduced\n+// to satisfy alignment desirata.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+\n+#![feature(untagged_unions)]\n+\n+#![allow(dead_code)]\n+\n+#[derive(Default)]\n+#[repr(packed)]\n+struct Packed {\n+    a: u8,\n+    b: u8,\n+    g: i32,\n+    c: u8,\n+    h: i16,\n+    d: u8,\n+}\n+\n+#[derive(Default)]\n+struct Padded {\n+    a: u8,\n+    b: u8,\n+    g: i32,\n+    c: u8,\n+    h: i16,\n+    d: u8,\n+}\n+\n+pub fn main() {\n+    let _c: Packed = Default::default();\n+    let _d: Padded = Default::default();\n+}"}, {"sha": "1278a7d7c92c67836d9e74db7eefd791ef4b3b23", "filename": "src/test/ui/print_type_sizes/packed.stdout", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpacked.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,17 @@\n+print-type-size type: `Padded`: 16 bytes, alignment: 4 bytes\n+print-type-size     field `.a`: 1 bytes\n+print-type-size     field `.b`: 1 bytes\n+print-type-size     padding: 2 bytes\n+print-type-size     field `.g`: 4 bytes, alignment: 4 bytes\n+print-type-size     field `.c`: 1 bytes\n+print-type-size     padding: 1 bytes\n+print-type-size     field `.h`: 2 bytes, alignment: 2 bytes\n+print-type-size     field `.d`: 1 bytes\n+print-type-size     end padding: 3 bytes\n+print-type-size type: `Packed`: 10 bytes, alignment: 1 bytes\n+print-type-size     field `.a`: 1 bytes\n+print-type-size     field `.b`: 1 bytes\n+print-type-size     field `.g`: 4 bytes\n+print-type-size     field `.c`: 1 bytes\n+print-type-size     field `.h`: 2 bytes\n+print-type-size     field `.d`: 1 bytes"}, {"sha": "af34a908ce883ca258ddecd81345f9f1d7b39774", "filename": "src/test/ui/print_type_sizes/padding.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates how padding is handled: alignment\n+// requirements can lead to the introduction of padding, either before\n+// fields or at the end of the structure as a whole.\n+//\n+// It avoids using u64/i64 because on some targets that is only 4-byte\n+// aligned (while on most it is 8-byte aligned) and so the resulting\n+// padding and overall computed sizes can be quite different.\n+\n+#![allow(dead_code)]\n+\n+struct S {\n+    a: bool,\n+    b: bool,\n+    g: i32,\n+}\n+\n+enum E1 {\n+    A(i32, i8),\n+    B(S),\n+}\n+\n+enum E2 {\n+    A(i8, i32),\n+    B(S),\n+}\n+\n+fn main() { }"}, {"sha": "bb95f790bd9e471bdd740e5f9817faf8af8d4f54", "filename": "src/test/ui/print_type_sizes/padding.stdout", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fpadding.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,21 @@\n+print-type-size type: `E1`: 12 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 4 bytes\n+print-type-size     variant `A`: 5 bytes\n+print-type-size         field `.0`: 4 bytes\n+print-type-size         field `.1`: 1 bytes\n+print-type-size     variant `B`: 8 bytes\n+print-type-size         field `.0`: 8 bytes\n+print-type-size type: `E2`: 12 bytes, alignment: 4 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `A`: 7 bytes\n+print-type-size         field `.0`: 1 bytes\n+print-type-size         padding: 2 bytes\n+print-type-size         field `.1`: 4 bytes, alignment: 4 bytes\n+print-type-size     variant `B`: 11 bytes\n+print-type-size         padding: 3 bytes\n+print-type-size         field `.0`: 8 bytes, alignment: 4 bytes\n+print-type-size type: `S`: 8 bytes, alignment: 4 bytes\n+print-type-size     field `.a`: 1 bytes\n+print-type-size     field `.b`: 1 bytes\n+print-type-size     padding: 2 bytes\n+print-type-size     field `.g`: 4 bytes, alignment: 4 bytes"}, {"sha": "875edb4515a1797c5fc01d14326e22fa4954d044", "filename": "src/test/ui/print_type_sizes/variants.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.rs?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z print-type-sizes\n+\n+// This file illustrates two things:\n+//\n+// 1. Only types that appear in a monomorphized function appear in the\n+//    print-type-sizes output, and\n+//\n+// 2. For an enum, the print-type-sizes output will also include the\n+//    size of each variant.\n+\n+pub struct SevenBytes([u8;  7]);\n+pub struct FiftyBytes([u8; 50]);\n+\n+pub enum Enum {\n+    Small(SevenBytes),\n+    Large(FiftyBytes),\n+}\n+\n+pub fn main() {\n+    let _e: Enum;\n+}"}, {"sha": "eed9af26987b46f64929c5895489a8941b62213f", "filename": "src/test/ui/print_type_sizes/variants.stdout", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/ddf011d7730594f4db36b01858b8c6733b07c084/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprint_type_sizes%2Fvariants.stdout?ref=ddf011d7730594f4db36b01858b8c6733b07c084", "patch": "@@ -0,0 +1,10 @@\n+print-type-size type: `Enum`: 51 bytes, alignment: 1 bytes\n+print-type-size     discriminant: 1 bytes\n+print-type-size     variant `Small`: 7 bytes\n+print-type-size         field `.0`: 7 bytes\n+print-type-size     variant `Large`: 50 bytes\n+print-type-size         field `.0`: 50 bytes\n+print-type-size type: `FiftyBytes`: 50 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 50 bytes\n+print-type-size type: `SevenBytes`: 7 bytes, alignment: 1 bytes\n+print-type-size     field `.0`: 7 bytes"}]}