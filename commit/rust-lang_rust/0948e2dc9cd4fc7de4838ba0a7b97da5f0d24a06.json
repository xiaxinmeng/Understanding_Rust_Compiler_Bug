{"sha": "0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NDhlMmRjOWNkNGZjN2RlNDgzOGJhMGE3Yjk3ZGE1ZjBkMjRhMDY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-07-07T09:35:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-07T09:35:03Z"}, "message": "Merge pull request #43 from oli-obk/the_outer_limits\n\nlimit stack size, memory size and execution time", "tree": {"sha": "40f94852588e923f29f12e849b529015d5633b05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40f94852588e923f29f12e849b529015d5633b05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "html_url": "https://github.com/rust-lang/rust/commit/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4afb59e8afa2134cd7ad7bb62fd77a13af68897", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4afb59e8afa2134cd7ad7bb62fd77a13af68897", "html_url": "https://github.com/rust-lang/rust/commit/f4afb59e8afa2134cd7ad7bb62fd77a13af68897"}, {"sha": "44bef2523552b3764506d027f4afc0d7996e376c", "url": "https://api.github.com/repos/rust-lang/rust/commits/44bef2523552b3764506d027f4afc0d7996e376c", "html_url": "https://github.com/rust-lang/rust/commit/44bef2523552b3764506d027f4afc0d7996e376c"}], "stats": {"total": 292, "additions": 240, "deletions": 52}, "files": [{"sha": "14a947302c65e0e3eb528c7ade72011a8dcb2a2d", "filename": "src/bin/miri.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -13,6 +13,7 @@ use miri::{eval_main, run_mir_passes};\n use rustc::session::Session;\n use rustc::mir::mir_map::MirMap;\n use rustc_driver::{driver, CompilerCalls, Compilation};\n+use syntax::ast::MetaItemKind;\n \n struct MiriCompilerCalls;\n \n@@ -23,7 +24,9 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n         _: &getopts::Matches\n     ) -> driver::CompileController<'a> {\n         let mut control = driver::CompileController::basic();\n-\n+        control.after_hir_lowering.callback = Box::new(|state| {\n+            state.session.plugin_attributes.borrow_mut().push((\"miri\".to_owned(), syntax::feature_gate::AttributeType::Whitelisted));\n+        });\n         control.after_analysis.stop = Compilation::Stop;\n         control.after_analysis.callback = Box::new(|state| {\n             state.session.abort_if_errors();\n@@ -33,9 +36,39 @@ impl<'a> CompilerCalls<'a> for MiriCompilerCalls {\n             let (node_id, _) = state.session.entry_fn.borrow()\n                 .expect(\"no main or start function found\");\n \n+            let krate = state.hir_crate.as_ref().unwrap();\n+            let mut memory_size = 100*1024*1024; // 100MB\n+            let mut step_limit = 1000_000;\n+            let mut stack_limit = 100;\n+            fn extract_str(lit: &syntax::ast::Lit) -> syntax::parse::token::InternedString {\n+                match lit.node {\n+                    syntax::ast::LitKind::Str(ref s, _) => s.clone(),\n+                    _ => panic!(\"attribute values need to be strings\"),\n+                }\n+            }\n+            for attr in krate.attrs.iter() {\n+                match attr.node.value.node {\n+                    MetaItemKind::List(ref name, _) if name != \"miri\" => {}\n+                    MetaItemKind::List(_, ref items) => for item in items {\n+                        match item.node {\n+                            MetaItemKind::NameValue(ref name, ref value) => {\n+                                match &**name {\n+                                    \"memory_size\" => memory_size = extract_str(value).parse().expect(\"not a number\"),\n+                                    \"step_limit\" => step_limit = extract_str(value).parse().expect(\"not a number\"),\n+                                    \"stack_limit\" => stack_limit = extract_str(value).parse().expect(\"not a number\"),\n+                                    _ => state.session.span_err(item.span, \"unknown miri attribute\"),\n+                                }\n+                            }\n+                            _ => state.session.span_err(item.span, \"miri attributes need to be of key = value kind\"),\n+                        }\n+                    },\n+                    _ => {},\n+                }\n+            }\n+\n             let mut mir_map = MirMap { map: mir_map.map.clone() };\n             run_mir_passes(tcx, &mut mir_map);\n-            eval_main(tcx, &mir_map, node_id);\n+            eval_main(tcx, &mir_map, node_id, memory_size, step_limit, stack_limit);\n \n             state.session.abort_if_errors();\n         });"}, {"sha": "2d723e692352522afe291bd0c938e87133a8c132", "filename": "src/error.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -29,6 +29,13 @@ pub enum EvalError<'tcx> {\n     ArrayIndexOutOfBounds(Span, u64, u64),\n     Math(Span, ConstMathErr),\n     InvalidChar(u32),\n+    OutOfMemory {\n+        allocation_size: usize,\n+        memory_size: usize,\n+        memory_usage: usize,\n+    },\n+    ExecutionTimeLimitReached,\n+    StackFrameLimitReached,\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -69,6 +76,12 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"mathematical operation failed\",\n             EvalError::InvalidChar(..) =>\n                 \"tried to interpret an invalid 32-bit value as a char\",\n+            EvalError::OutOfMemory{..} =>\n+                \"could not allocate more memory\",\n+            EvalError::ExecutionTimeLimitReached =>\n+                \"reached the configured maximum execution time\",\n+            EvalError::StackFrameLimitReached =>\n+                \"reached the configured maximum number of stack frames\",\n         }\n     }\n \n@@ -90,6 +103,9 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n                 write!(f, \"{:?} at {:?}\", err, span),\n             EvalError::InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n+            EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>\n+                write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n+                       allocation_size, memory_size - memory_usage, memory_size),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "4200340e6a9c6127f244079c1a711e8f8b836f78", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -42,6 +42,9 @@ pub struct EvalContext<'a, 'tcx: 'a> {\n \n     /// The virtual call stack.\n     stack: Vec<Frame<'a, 'tcx>>,\n+\n+    /// The maximum number of stack frames allowed\n+    stack_limit: usize,\n }\n \n /// A stack frame.\n@@ -133,24 +136,25 @@ enum ConstantKind {\n }\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n+    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>, mir_map: &'a MirMap<'tcx>, memory_size: usize, stack_limit: usize) -> Self {\n         EvalContext {\n             tcx: tcx,\n             mir_map: mir_map,\n             mir_cache: RefCell::new(DefIdMap()),\n-            memory: Memory::new(&tcx.data_layout),\n+            memory: Memory::new(&tcx.data_layout, memory_size),\n             statics: HashMap::new(),\n             stack: Vec::new(),\n+            stack_limit: stack_limit,\n         }\n     }\n \n-    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> Option<Pointer> {\n+    pub fn alloc_ret_ptr(&mut self, output_ty: ty::FnOutput<'tcx>, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, Option<Pointer>> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size_with_substs(ty, substs);\n-                Some(self.memory.allocate(size))\n+                self.memory.allocate(size).map(Some)\n             }\n-            ty::FnDiverging => None,\n+            ty::FnDiverging => Ok(None),\n         }\n     }\n \n@@ -172,19 +176,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstFloat};\n         macro_rules! i2p {\n             ($i:ident, $n:expr) => {{\n-                let ptr = self.memory.allocate($n);\n+                let ptr = self.memory.allocate($n)?;\n                 self.memory.write_int(ptr, $i as i64, $n)?;\n                 Ok(ptr)\n             }}\n         }\n         match *const_val {\n             Float(ConstFloat::F32(f)) => {\n-                let ptr = self.memory.allocate(4);\n+                let ptr = self.memory.allocate(4)?;\n                 self.memory.write_f32(ptr, f)?;\n                 Ok(ptr)\n             },\n             Float(ConstFloat::F64(f)) => {\n-                let ptr = self.memory.allocate(8);\n+                let ptr = self.memory.allocate(8)?;\n                 self.memory.write_f64(ptr, f)?;\n                 Ok(ptr)\n             },\n@@ -207,28 +211,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Integral(ConstInt::Usize(ConstUsize::Us64(i))) => i2p!(i, 8),\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(s.len());\n-                let ptr = self.memory.allocate(psize * 2);\n+                let static_ptr = self.memory.allocate(s.len())?;\n+                let ptr = self.memory.allocate(psize * 2)?;\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(bs.len());\n-                let ptr = self.memory.allocate(psize);\n+                let static_ptr = self.memory.allocate(bs.len())?;\n+                let ptr = self.memory.allocate(psize)?;\n                 self.memory.write_bytes(static_ptr, bs)?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 Ok(ptr)\n             }\n             Bool(b) => {\n-                let ptr = self.memory.allocate(1);\n+                let ptr = self.memory.allocate(1)?;\n                 self.memory.write_bool(ptr, b)?;\n                 Ok(ptr)\n             }\n             Char(c) => {\n-                let ptr = self.memory.allocate(4);\n+                let ptr = self.memory.allocate(4)?;\n                 self.memory.write_uint(ptr, c as u64, 4)?;\n                 Ok(ptr)\n             },\n@@ -292,9 +296,14 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    pub fn push_stack_frame(&mut self, def_id: DefId, span: codemap::Span, mir: CachedMir<'a, 'tcx>, substs: &'tcx Substs<'tcx>,\n-        return_ptr: Option<Pointer>)\n-    {\n+    pub fn push_stack_frame(\n+        &mut self,\n+        def_id: DefId,\n+        span: codemap::Span,\n+        mir: CachedMir<'a, 'tcx>,\n+        substs: &'tcx Substs<'tcx>,\n+        return_ptr: Option<Pointer>,\n+    ) -> EvalResult<'tcx, ()> {\n         let arg_tys = mir.arg_decls.iter().map(|a| a.ty);\n         let var_tys = mir.var_decls.iter().map(|v| v.ty);\n         let temp_tys = mir.temp_decls.iter().map(|t| t.ty);\n@@ -304,7 +313,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         ::log_settings::settings().indentation += 1;\n \n-        let locals: Vec<Pointer> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n+        let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n             self.memory.allocate(size)\n         }).collect();\n@@ -313,14 +322,19 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             mir: mir.clone(),\n             block: mir::START_BLOCK,\n             return_ptr: return_ptr,\n-            locals: locals,\n+            locals: locals?,\n             var_offset: num_args,\n             temp_offset: num_args + num_vars,\n             span: span,\n             def_id: def_id,\n             substs: substs,\n             stmt: 0,\n         });\n+        if self.stack.len() > self.stack_limit {\n+            Err(EvalError::StackFrameLimitReached)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     fn pop_stack_frame(&mut self) {\n@@ -548,7 +562,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let size = self.type_size(ty);\n-                let ptr = self.memory.allocate(size);\n+                let ptr = self.memory.allocate(size)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n@@ -696,7 +710,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n                             // function items are zero sized\n-                            Ok(self.memory.allocate(0))\n+                            Ok(self.memory.allocate(0)?)\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,\n@@ -935,37 +949,44 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n     node_id: ast::NodeId,\n+    memory_size: usize,\n+    step_limit: u64,\n+    stack_limit: usize,\n ) {\n     let mir = mir_map.map.get(&node_id).expect(\"no mir for main function\");\n     let def_id = tcx.map.local_def_id(node_id);\n-    let mut ecx = EvalContext::new(tcx, mir_map);\n+    let mut ecx = EvalContext::new(tcx, mir_map, memory_size, stack_limit);\n     let substs = tcx.mk_substs(subst::Substs::empty());\n-    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"main function should not be diverging\");\n+    let return_ptr = ecx.alloc_ret_ptr(mir.return_ty, substs)\n+                        .expect(\"should at least be able to allocate space for the main function's return value\")\n+                        .expect(\"main function should not be diverging\");\n \n-    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr));\n+    ecx.push_stack_frame(def_id, mir.span, CachedMir::Ref(mir), substs, Some(return_ptr))\n+       .expect(\"could not allocate first stack frame\");\n \n     if mir.arg_decls.len() == 2 {\n         // start function\n         let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size);\n+        let nargs = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for nargs\");\n         ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size);\n+        let args = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for arg pointer\");\n         ecx.memory_mut().write_usize(args, 0).unwrap();\n         ecx.frame_mut().locals[0] = nargs;\n         ecx.frame_mut().locals[1] = args;\n     }\n \n-    loop {\n+    for _ in 0..step_limit {\n         match ecx.step() {\n             Ok(true) => {}\n-            Ok(false) => break,\n+            Ok(false) => return,\n             // FIXME: diverging functions can end up here in some future miri\n             Err(e) => {\n                 report(tcx, &ecx, e);\n-                break;\n+                return;\n             }\n         }\n     }\n+    report(tcx, &ecx, EvalError::ExecutionTimeLimitReached);\n }\n \n fn report(tcx: TyCtxt, ecx: &EvalContext, e: EvalError) {"}, {"sha": "5bfe85fff92fc9811244e99a9f9f1fd0f7e8f5f5", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -29,15 +29,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         let basic_block = &mir.basic_blocks()[block];\n \n         if let Some(ref stmt) = basic_block.statements.get(stmt) {\n-            let current_stack = self.stack.len();\n+            let mut new = Ok(0);\n             ConstantExtractor {\n                 span: stmt.source_info.span,\n                 substs: self.substs(),\n                 def_id: self.frame().def_id,\n                 ecx: self,\n                 mir: &mir,\n+                new_constants: &mut new,\n             }.visit_statement(block, stmt);\n-            if current_stack == self.stack.len() {\n+            if new? == 0 {\n                 self.statement(stmt)?;\n             }\n             // if ConstantExtractor added new frames, we don't execute anything here\n@@ -46,15 +47,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         }\n \n         let terminator = basic_block.terminator();\n-        let current_stack = self.stack.len();\n+        let mut new = Ok(0);\n         ConstantExtractor {\n             span: terminator.source_info.span,\n             substs: self.substs(),\n             def_id: self.frame().def_id,\n             ecx: self,\n             mir: &mir,\n+            new_constants: &mut new,\n         }.visit_terminator(block, terminator);\n-        if current_stack == self.stack.len() {\n+        if new? == 0 {\n             self.terminator(terminator)?;\n         }\n         // if ConstantExtractor added new frames, we don't execute anything here\n@@ -92,6 +94,7 @@ struct ConstantExtractor<'a, 'b: 'a, 'tcx: 'b> {\n     mir: &'a mir::Mir<'tcx>,\n     def_id: DefId,\n     substs: &'tcx subst::Substs<'tcx>,\n+    new_constants: &'a mut EvalResult<'tcx, u64>,\n }\n \n impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n@@ -105,9 +108,22 @@ impl<'a, 'b, 'tcx> ConstantExtractor<'a, 'b, 'tcx> {\n             return;\n         }\n         let mir = self.ecx.load_mir(def_id);\n-        let ptr = self.ecx.alloc_ret_ptr(mir.return_ty, substs).expect(\"there's no such thing as an unreachable static\");\n-        self.ecx.statics.insert(cid.clone(), ptr);\n-        self.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr));\n+        self.try(|this| {\n+            let ptr = this.ecx.alloc_ret_ptr(mir.return_ty, substs)?;\n+            let ptr = ptr.expect(\"there's no such thing as an unreachable static\");\n+            this.ecx.statics.insert(cid.clone(), ptr);\n+            this.ecx.push_stack_frame(def_id, span, mir, substs, Some(ptr))\n+        });\n+    }\n+    fn try<F: FnOnce(&mut Self) -> EvalResult<'tcx, ()>>(&mut self, f: F) {\n+        if let Ok(ref mut n) = *self.new_constants {\n+            *n += 1;\n+        } else {\n+            return;\n+        }\n+        if let Err(e) = f(self) {\n+            *self.new_constants = Err(e);\n+        }\n     }\n }\n \n@@ -137,10 +153,13 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n                 }\n                 let mir = self.mir.promoted[index].clone();\n                 let return_ty = mir.return_ty;\n-                let return_ptr = self.ecx.alloc_ret_ptr(return_ty, cid.substs).expect(\"there's no such thing as an unreachable static\");\n-                let mir = CachedMir::Owned(Rc::new(mir));\n-                self.ecx.statics.insert(cid.clone(), return_ptr);\n-                self.ecx.push_stack_frame(self.def_id, constant.span, mir, self.substs, Some(return_ptr));\n+                self.try(|this| {\n+                    let return_ptr = this.ecx.alloc_ret_ptr(return_ty, cid.substs)?;\n+                    let return_ptr = return_ptr.expect(\"there's no such thing as an unreachable static\");\n+                    let mir = CachedMir::Owned(Rc::new(mir));\n+                    this.ecx.statics.insert(cid.clone(), return_ptr);\n+                    this.ecx.push_stack_frame(this.def_id, constant.span, mir, this.substs, Some(return_ptr))\n+                });\n             }\n         }\n     }"}, {"sha": "2fbc9a63ef68d236d34aaba6ea8a3cc16a315660", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -212,7 +212,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n \n                 let mir = self.load_mir(resolved_def_id);\n-                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr);\n+                self.push_stack_frame(def_id, span, mir, resolved_substs, return_ptr)?;\n \n                 for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];\n@@ -416,7 +416,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n                 let size = self.memory.read_usize(args[0])?;\n-                let ptr = self.memory.allocate(size as usize);\n+                let ptr = self.memory.allocate(size as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n "}, {"sha": "90725fdbba5764ce21ef36b1dbff492771637088", "filename": "src/memory.rs", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -66,6 +66,10 @@ pub struct FunctionDefinition<'tcx> {\n pub struct Memory<'a, 'tcx> {\n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations)\n     alloc_map: HashMap<AllocId, Allocation>,\n+    /// Number of virtual bytes allocated\n+    memory_usage: usize,\n+    /// Maximum number of virtual bytes that may be allocated\n+    memory_size: usize,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n     functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n@@ -78,13 +82,15 @@ pub struct Memory<'a, 'tcx> {\n const ZST_ALLOC_ID: AllocId = AllocId(0);\n \n impl<'a, 'tcx> Memory<'a, 'tcx> {\n-    pub fn new(layout: &'a TargetDataLayout) -> Self {\n+    pub fn new(layout: &'a TargetDataLayout, max_memory: usize) -> Self {\n         let mut mem = Memory {\n             alloc_map: HashMap::new(),\n             functions: HashMap::new(),\n             function_alloc_cache: HashMap::new(),\n             next_id: AllocId(1),\n             layout: layout,\n+            memory_size: max_memory,\n+            memory_usage: 0,\n         };\n         // alloc id 0 is reserved for ZSTs, this is an optimization to prevent ZST\n         // (e.g. function items, (), [], ...) from requiring memory\n@@ -95,7 +101,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0).points_to_zst());\n+        debug_assert!(mem.allocate(0).unwrap().points_to_zst());\n         debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n         mem\n     }\n@@ -127,10 +133,18 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn allocate(&mut self, size: usize) -> Pointer {\n+    pub fn allocate(&mut self, size: usize) -> EvalResult<'tcx, Pointer> {\n         if size == 0 {\n-            return Pointer::zst_ptr();\n+            return Ok(Pointer::zst_ptr());\n         }\n+        if self.memory_size - self.memory_usage < size {\n+            return Err(EvalError::OutOfMemory {\n+                allocation_size: size,\n+                memory_size: self.memory_size,\n+                memory_usage: self.memory_usage,\n+            });\n+        }\n+        self.memory_usage += size;\n         let alloc = Allocation {\n             bytes: vec![0; size],\n             relocations: BTreeMap::new(),\n@@ -139,10 +153,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n-        Pointer {\n+        Ok(Pointer {\n             alloc_id: id,\n             offset: 0,\n-        }\n+        })\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n@@ -153,20 +167,23 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n         if ptr.points_to_zst() {\n-            return Ok(self.allocate(new_size));\n+            return self.allocate(new_size);\n         }\n \n         let size = self.get_mut(ptr.alloc_id)?.bytes.len();\n \n         if new_size > size {\n             let amount = new_size - size;\n+            self.memory_usage += amount;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n         } else if size > new_size {\n+            self.memory_usage -= size - new_size;\n             self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.truncate(new_size);\n+            alloc.bytes.shrink_to_fit();\n             alloc.undef_mask.truncate(new_size);\n         }\n \n@@ -183,7 +200,9 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n \n-        if self.alloc_map.remove(&ptr.alloc_id).is_none() {\n+        if let Some(alloc) = self.alloc_map.remove(&ptr.alloc_id) {\n+            self.memory_usage -= alloc.bytes.len();\n+        } else {\n             debug!(\"deallocated a pointer twice: {}\", ptr.alloc_id);\n             // TODO(solson): Report error about erroneous free. This is blocked on properly tracking\n             // already-dropped state since this if-statement is entered even in safe code without\n@@ -710,6 +729,7 @@ impl UndefMask {\n     fn truncate(&mut self, length: usize) {\n         self.len = length;\n         self.blocks.truncate(self.len / BLOCK_SIZE + 1);\n+        self.blocks.shrink_to_fit();\n     }\n }\n "}, {"sha": "83109a77e62016961643d2434aac5178dc05f023", "filename": "tests/compile-fail/oom.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -0,0 +1,11 @@\n+#![feature(custom_attribute)]\n+#![miri(memory_size=\"0\")]\n+\n+fn bar() {\n+    let x = 5;\n+    assert_eq!(x, 6);\n+}\n+\n+fn main() { //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n+    bar();\n+}"}, {"sha": "63c51dbaa7d2689cef85d3ee94a14272d7a241aa", "filename": "tests/compile-fail/oom2.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -0,0 +1,39 @@\n+#![feature(custom_attribute)]\n+#![miri(memory_size=\"1000\")]\n+\n+fn bar(i: i32) {\n+    if i < 1000 {\n+        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 1 bytes are free of the 1000 byte memory\n+        //~^NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+        //~|NOTE inside call to bar\n+    }\n+}\n+\n+fn main() { //~NOTE inside call to main\n+    bar(1);\n+    //~^NOTE inside call to bar\n+}"}, {"sha": "3b6d4186dc9055c6818e53ed33f23b94a7e2ca78", "filename": "tests/compile-fail/stack_limit.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Fstack_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Fstack_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstack_limit.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -0,0 +1,20 @@\n+#![feature(custom_attribute)]\n+#![miri(stack_limit=\"2\")]\n+\n+fn bar() {\n+    foo();\n+}\n+\n+fn foo() {\n+    cake(); //~ ERROR reached the configured maximum number of stack frames\n+}\n+\n+fn cake() {\n+    flubber();\n+}\n+\n+fn flubber() {}\n+\n+fn main() {\n+    bar();\n+}"}, {"sha": "bcb6c993089a72cab2bba5fbf766ab869316a48a", "filename": "tests/compile-fail/timeout.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Ftimeout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06/tests%2Fcompile-fail%2Ftimeout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftimeout.rs?ref=0948e2dc9cd4fc7de4838ba0a7b97da5f0d24a06", "patch": "@@ -0,0 +1,9 @@\n+//error-pattern: reached the configured maximum execution time\n+#![feature(custom_attribute)]\n+#![miri(step_limit=\"1000\")]\n+\n+fn main() {\n+    for i in 0..1000000 {\n+        assert!(i < 1000);\n+    }\n+}"}]}