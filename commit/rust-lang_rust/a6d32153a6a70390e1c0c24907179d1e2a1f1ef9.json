{"sha": "a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZDMyMTUzYTZhNzAzOTBlMWMwYzI0OTA3MTc5ZDFlMmExZjFlZjk=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-10T03:30:33Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-06-11T20:40:04Z"}, "message": "Learn to parse `a as usize < b`\n\nParsing `a as usize > b` always works, but `a as usize < b` was a\nparsing error because the parser would think the `<` started a generic\ntype argument for `usize`. The parser now attempts to parse as before,\nand if a DiagnosticError is returned, try to parse again as a type with\nno generic arguments. If this fails, return the original\n`DiagnosticError`.", "tree": {"sha": "e3ea0ded6219ea9c40a9385468c4bc387114125e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ea0ded6219ea9c40a9385468c4bc387114125e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "html_url": "https://github.com/rust-lang/rust/commit/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13eb0ec9f17c89a3cb06a8f3ae627c076839fa52", "url": "https://api.github.com/repos/rust-lang/rust/commits/13eb0ec9f17c89a3cb06a8f3ae627c076839fa52", "html_url": "https://github.com/rust-lang/rust/commit/13eb0ec9f17c89a3cb06a8f3ae627c076839fa52"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "a6ecd304dbd16e3fe639b33acedc36ef14d14a83", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 90, "deletions": 8, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "patch": "@@ -193,11 +193,13 @@ pub struct Parser<'a> {\n }\n \n \n+#[derive(Clone)]\n struct TokenCursor {\n     frame: TokenCursorFrame,\n     stack: Vec<TokenCursorFrame>,\n }\n \n+#[derive(Clone)]\n struct TokenCursorFrame {\n     delim: token::DelimToken,\n     span: Span,\n@@ -397,6 +399,7 @@ impl Error {\n     }\n }\n \n+#[derive(Debug)]\n pub enum LhsExpr {\n     NotYetParsed,\n     AttributesParsed(ThinVec<Attribute>),\n@@ -438,6 +441,8 @@ fn dummy_arg(span: Span) -> Arg {\n     Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n }\n \n+type RewindPoint = (token::Token, Span, Option<Span>, Span, TokenCursor, Vec<TokenType>);\n+\n impl<'a> Parser<'a> {\n     pub fn new(sess: &'a ParseSess,\n                tokens: TokenStream,\n@@ -786,6 +791,13 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    fn is_lt(&mut self) -> bool {\n+        match self.token {\n+            token::Lt | token::BinOp(token::Shl) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Attempt to consume a `<`. If `<<` is seen, replace it with a single\n     /// `<` and continue. If a `<` is not seen, return false.\n     ///\n@@ -1724,7 +1736,7 @@ impl<'a> Parser<'a> {\n \n         let segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons()?\n+                self.parse_path_segments_without_colons(false)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1745,6 +1757,16 @@ impl<'a> Parser<'a> {\n     /// bounds are permitted and whether `::` must precede type parameter\n     /// groups.\n     pub fn parse_path(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+        self.parse_path_common(mode, false)\n+    }\n+\n+    pub fn parse_path_without_generics(&mut self, mode: PathStyle) -> PResult<'a, ast::Path> {\n+        self.parse_path_common(mode, true)\n+    }\n+\n+    fn parse_path_common(&mut self, mode: PathStyle, dont_parse_generics: bool)\n+        -> PResult<'a, ast::Path>\n+    {\n         maybe_whole!(self, NtPath, |x| x);\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n@@ -1755,7 +1777,7 @@ impl<'a> Parser<'a> {\n         // A bound set is a set of type parameter bounds.\n         let mut segments = match mode {\n             PathStyle::Type => {\n-                self.parse_path_segments_without_colons()?\n+                self.parse_path_segments_without_colons(dont_parse_generics)?\n             }\n             PathStyle::Expr => {\n                 self.parse_path_segments_with_colons()?\n@@ -1800,7 +1822,9 @@ impl<'a> Parser<'a> {\n     /// - `a::b<T,U>::c<V,W>`\n     /// - `a::b<T,U>::c(V) -> W`\n     /// - `a::b<T,U>::c(V)`\n-    pub fn parse_path_segments_without_colons(&mut self) -> PResult<'a, Vec<PathSegment>> {\n+    pub fn parse_path_segments_without_colons(&mut self, dont_parse_generics: bool)\n+        -> PResult<'a, Vec<PathSegment>>\n+    {\n         let mut segments = Vec::new();\n         loop {\n             // First, parse an identifier.\n@@ -1819,7 +1843,8 @@ impl<'a> Parser<'a> {\n             }\n \n             // Parse types, optionally.\n-            let parameters = if self.eat_lt() {\n+            let parameters = if self.is_lt() && !dont_parse_generics {\n+                let _ = self.eat_lt();\n                 let (lifetimes, types, bindings) = self.parse_generic_args()?;\n                 self.expect_gt()?;\n                 ast::AngleBracketedParameterData {\n@@ -2798,8 +2823,40 @@ impl<'a> Parser<'a> {\n             }\n             // Special cases:\n             if op == AssocOp::As {\n-                let rhs = self.parse_ty_no_plus()?;\n-                lhs = self.mk_expr(lhs_span.to(rhs.span), ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                // Save the state of the parser before parsing type normally, in case there is a\n+                // LessThan comparison after this cast.\n+                let rp = self.get_rewind_point();\n+                match self.parse_ty_no_plus() {\n+                    Ok(rhs) => {\n+                        lhs = self.mk_expr(lhs_span.to(rhs.span),\n+                                           ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                    }\n+                    Err(mut err) => {\n+                        // Rewind to before attempting to parse the type with generics, to get\n+                        // arround #22644.\n+                        let rp_err = self.get_rewind_point();\n+                        self.rewind(rp);\n+                        let lo = self.span;\n+                        let path = match self.parse_path_without_generics(PathStyle::Type) {\n+                            Ok(path) => {\n+                                // Successfully parsed the type leaving a `<` yet to parse\n+                                err.cancel();\n+                                path\n+                            }\n+                            Err(mut path_err) => {\n+                                // Still couldn't parse, return original error and parser state\n+                                path_err.cancel();\n+                                self.rewind(rp_err);\n+                                return Err(err);\n+                            }\n+                        };\n+                        let path = TyKind::Path(None, path);\n+                        let span = lo.to(self.prev_span);\n+                        let rhs = P(Ty { node: path, span: span, id: ast::DUMMY_NODE_ID });\n+                        lhs = self.mk_expr(lhs_span.to(rhs.span),\n+                                           ExprKind::Cast(lhs, rhs), ThinVec::new());\n+                    }\n+                };\n                 continue\n             } else if op == AssocOp::Colon {\n                 let rhs = self.parse_ty_no_plus()?;\n@@ -2901,7 +2958,9 @@ impl<'a> Parser<'a> {\n     /// We only need to check lhs, not rhs, because all comparison ops\n     /// have same precedence and are left-associative\n     fn check_no_chained_comparison(&mut self, lhs: &Expr, outer_op: &AssocOp) {\n-        debug_assert!(outer_op.is_comparison());\n+        debug_assert!(outer_op.is_comparison(),\n+                      \"check_no_chained_comparison: {:?} is not comparison\",\n+                      outer_op);\n         match lhs.node {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n@@ -2925,7 +2984,9 @@ impl<'a> Parser<'a> {\n     fn parse_prefix_range_expr(&mut self,\n                                already_parsed_attrs: Option<ThinVec<Attribute>>)\n                                -> PResult<'a, P<Expr>> {\n-        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot);\n+        debug_assert!(self.token == token::DotDot || self.token == token::DotDotDot,\n+                      \"parse_prefix_range_expr: token {:?} is not DotDot or DotDotDot\",\n+                      self.token);\n         let tok = self.token.clone();\n         let attrs = self.parse_or_use_outer_attributes(already_parsed_attrs)?;\n         let lo = self.span;\n@@ -6174,4 +6235,25 @@ impl<'a> Parser<'a> {\n             _ =>  Err(self.fatal(\"expected string literal\"))\n         }\n     }\n+\n+    fn get_rewind_point(&mut self) -> RewindPoint {\n+        (\n+            self.token.clone(),\n+            self.span,\n+            self.meta_var_span,\n+            self.prev_span,\n+            self.token_cursor.clone(),\n+            self.expected_tokens.clone(),\n+        )\n+    }\n+\n+    fn rewind(&mut self, rp: RewindPoint) {\n+        let (token, span, meta_var_span, prev_span, token_cursor, expected_tokens,) = rp;\n+        self.token = token;\n+        self.span = span;\n+        self.meta_var_span = meta_var_span;\n+        self.prev_span = prev_span;\n+        self.token_cursor = token_cursor;\n+        self.expected_tokens = expected_tokens;\n+    }\n }"}, {"sha": "963482fc223f1befa6c0a518db4f9c8c4084efd4", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "patch": "@@ -227,14 +227,17 @@ impl TokenStream {\n     }\n }\n \n+#[derive(Clone)]\n pub struct Cursor(CursorKind);\n \n+#[derive(Clone)]\n enum CursorKind {\n     Empty,\n     Tree(TokenTree, bool /* consumed? */),\n     Stream(StreamCursor),\n }\n \n+#[derive(Clone)]\n struct StreamCursor {\n     stream: RcSlice<TokenStream>,\n     index: usize,"}, {"sha": "9269180396c5481ccaef648a9d640af194f5af37", "filename": "src/test/run-pass/issue-22644.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Ftest%2Frun-pass%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d32153a6a70390e1c0c24907179d1e2a1f1ef9/src%2Ftest%2Frun-pass%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-22644.rs?ref=a6d32153a6a70390e1c0c24907179d1e2a1f1ef9", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let a : u32 = 0;\n+    let b : usize = 0;\n+\n+    println!(\"{}\", a as usize > b);\n+    println!(\"{}\", a as usize < b);\n+    println!(\"{}\", a as usize < 4);\n+}"}]}