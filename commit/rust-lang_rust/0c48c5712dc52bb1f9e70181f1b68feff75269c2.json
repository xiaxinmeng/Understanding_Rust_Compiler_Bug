{"sha": "0c48c5712dc52bb1f9e70181f1b68feff75269c2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNDhjNTcxMmRjNTJiYjFmOWU3MDE4MWYxYjY4ZmVmZjc1MjY5YzI=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-11T12:05:16Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-10-12T18:36:48Z"}, "message": "Never expand specialized columns that only contain wild patterns in them\n\nDoing so would incur deeply nested expansion of the tree with no useful\nside effects. This is problematic for \"wide\" data types such as structs\nwith dozens of fields but where only a few are actually being matched or bound.\nMost notably, matching a fixed slice would use a number of stack frames that\ngrows with the number of elements in the slice.\n\nFixes #17877.", "tree": {"sha": "88c83fd0a0976e977e5c24f75b534e838cbf33dc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c83fd0a0976e977e5c24f75b534e838cbf33dc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c48c5712dc52bb1f9e70181f1b68feff75269c2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c48c5712dc52bb1f9e70181f1b68feff75269c2", "html_url": "https://github.com/rust-lang/rust/commit/0c48c5712dc52bb1f9e70181f1b68feff75269c2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c48c5712dc52bb1f9e70181f1b68feff75269c2/comments", "author": null, "committer": null, "parents": [{"sha": "86509d8d7ab68c5e4202dea9ff1bfb79409f2f8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/86509d8d7ab68c5e4202dea9ff1bfb79409f2f8d", "html_url": "https://github.com/rust-lang/rust/commit/86509d8d7ab68c5e4202dea9ff1bfb79409f2f8d"}], "stats": {"total": 169, "additions": 107, "deletions": 62}, "files": [{"sha": "16329fe9c650725e0c83b54782a8b683b63ba7fe", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=0c48c5712dc52bb1f9e70181f1b68feff75269c2", "patch": "@@ -638,15 +638,15 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n         PatEnum(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)\n             },\n         PatStruct(..) =>\n             match cx.tcx.def_map.borrow().find(&pat.id) {\n                 Some(&DefConst(..)) =>\n-                    cx.tcx.sess.span_bug(pat.span, \"static pattern should've \\\n+                    cx.tcx.sess.span_bug(pat.span, \"const pattern should've \\\n                                                     been rewritten\"),\n                 Some(&DefVariant(_, id, _)) => vec!(Variant(id)),\n                 _ => vec!(Single)"}, {"sha": "357f4cdf0ebcf464799a589d58539d5dd224f095", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0c48c5712dc52bb1f9e70181f1b68feff75269c2", "patch": "@@ -25,11 +25,25 @@ pub type PatIdMap = HashMap<Ident, NodeId>;\n pub fn pat_id_map(dm: &resolve::DefMap, pat: &Pat) -> PatIdMap {\n     let mut map = HashMap::new();\n     pat_bindings(dm, pat, |_bm, p_id, _s, path1| {\n-      map.insert(path1.node, p_id);\n+        map.insert(path1.node, p_id);\n     });\n     map\n }\n \n+pub fn pat_is_refutable(dm: &resolve::DefMap, pat: &Pat) -> bool {\n+    match pat.node {\n+        PatLit(_) | PatRange(_, _) => true,\n+        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n+            match dm.borrow().find(&pat.id) {\n+                Some(&DefVariant(..)) => true,\n+                _ => false\n+            }\n+        }\n+        PatVec(_, _, _) => true,\n+        _ => false\n+    }\n+}\n+\n pub fn pat_is_variant_or_struct(dm: &resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n         PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {"}, {"sha": "55486354e7d68e8b667ca1b82e621da715a3cf28", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0c48c5712dc52bb1f9e70181f1b68feff75269c2", "patch": "@@ -218,6 +218,7 @@ use util::ppaux::{Repr, vec_map_to_string};\n \n use std;\n use std::collections::HashMap;\n+use std::iter::AdditiveIterator;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::ast::{DUMMY_NODE_ID, Ident};\n@@ -754,33 +755,41 @@ impl FailureHandler {\n     }\n }\n \n-fn pick_col(m: &[Match]) -> uint {\n-    fn score(p: &ast::Pat) -> uint {\n-        match p.node {\n-          ast::PatLit(_) | ast::PatEnum(_, _) | ast::PatRange(_, _) => 1u,\n-          ast::PatIdent(_, _, Some(ref p)) => score(&**p),\n-          _ => 0u\n+fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n+    fn pat_score(def_map: &DefMap, pat: &ast::Pat) -> uint {\n+        match pat.node {\n+            ast::PatIdent(_, _, Some(ref inner)) => pat_score(def_map, &**inner),\n+            _ if pat_is_refutable(def_map, pat) => 1u,\n+            _ => 0u\n         }\n     }\n-    let mut scores = Vec::from_elem(m[0].pats.len(), 0u);\n-    for br in m.iter() {\n-        for (i, ref p) in br.pats.iter().enumerate() {\n-            *scores.get_mut(i) += score(&***p);\n+\n+    let column_score: |&[Match], uint| -> uint = |m, col| {\n+        let total_score = m.iter()\n+            .map(|row| row.pats[col])\n+            .map(|pat| pat_score(def_map, pat))\n+            .sum();\n+\n+        // Irrefutable columns always go first, they'd only be duplicated in the branches.\n+        if total_score == 0 {\n+            std::uint::MAX\n+        } else {\n+            total_score\n         }\n-    }\n-    let mut max_score = 0u;\n-    let mut best_col = 0u;\n-    for (i, score) in scores.iter().enumerate() {\n-        let score = *score;\n-\n-        // Irrefutable columns always go first, they'd only be duplicated in\n-        // the branches.\n-        if score == 0u { return i; }\n-        // If no irrefutable ones are found, we pick the one with the biggest\n-        // branching factor.\n-        if score > max_score { max_score = score; best_col = i; }\n-    }\n-    return best_col;\n+    };\n+\n+    let column_contains_any_nonwild_patterns: |&uint| -> bool = |&col| {\n+        m.iter().any(|row| match row.pats[col].node {\n+            ast::PatWild(_) => false,\n+            _ => true\n+        })\n+    };\n+\n+    range(0, m[0].pats.len())\n+        .filter(column_contains_any_nonwild_patterns)\n+        .map(|col| (col, column_score(m, col)))\n+        .max_by(|&(_, score)| score)\n+        .map(|(col, _)| col)\n }\n \n // Compiles a comparison between two things.\n@@ -951,44 +960,45 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         return;\n     }\n \n-    let col_count = m[0].pats.len();\n-    if col_count == 0u {\n-        let data = &m[0].data;\n-        for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n-            let llmatch = data.bindings_map.get(ident).llmatch;\n-            call_lifetime_start(bcx, llmatch);\n-            Store(bcx, *value_ptr, llmatch);\n+    let tcx = bcx.tcx();\n+    let def_map = &tcx.def_map;\n+    match pick_column_to_specialize(def_map, m) {\n+        Some(col) => {\n+            let val = vals[col];\n+            if has_nested_bindings(m, col) {\n+                let expanded = expand_nested_bindings(bcx, m, col, val);\n+                compile_submatch_continue(bcx,\n+                                          expanded.as_slice(),\n+                                          vals,\n+                                          chk,\n+                                          col,\n+                                          val,\n+                                          has_genuine_default)\n+            } else {\n+                compile_submatch_continue(bcx, m, vals, chk, col, val, has_genuine_default)\n+            }\n         }\n-        match data.arm.guard {\n-            Some(ref guard_expr) => {\n-                bcx = compile_guard(bcx,\n-                                    &**guard_expr,\n-                                    m[0].data,\n-                                    m[1..m.len()],\n-                                    vals,\n-                                    chk,\n-                                    has_genuine_default);\n+        None => {\n+            let data = &m[0].data;\n+            for &(ref ident, ref value_ptr) in m[0].bound_ptrs.iter() {\n+                let llmatch = data.bindings_map.get(ident).llmatch;\n+                call_lifetime_start(bcx, llmatch);\n+                Store(bcx, *value_ptr, llmatch);\n             }\n-            _ => ()\n+            match data.arm.guard {\n+                Some(ref guard_expr) => {\n+                    bcx = compile_guard(bcx,\n+                                        &**guard_expr,\n+                                        m[0].data,\n+                                        m[1..m.len()],\n+                                        vals,\n+                                        chk,\n+                                        has_genuine_default);\n+                }\n+                _ => ()\n+            }\n+            Br(bcx, data.bodycx.llbb);\n         }\n-        Br(bcx, data.bodycx.llbb);\n-        return;\n-    }\n-\n-    let col = pick_col(m);\n-    let val = vals[col];\n-\n-    if has_nested_bindings(m, col) {\n-        let expanded = expand_nested_bindings(bcx, m, col, val);\n-        compile_submatch_continue(bcx,\n-                                  expanded.as_slice(),\n-                                  vals,\n-                                  chk,\n-                                  col,\n-                                  val,\n-                                  has_genuine_default)\n-    } else {\n-        compile_submatch_continue(bcx, m, vals, chk, col, val, has_genuine_default)\n     }\n }\n "}, {"sha": "51db2f0595997f0841e73ee7b82d42a904f83002", "filename": "src/test/run-pass/issue-17877.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Ftest%2Frun-pass%2Fissue-17877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c48c5712dc52bb1f9e70181f1b68feff75269c2/src%2Ftest%2Frun-pass%2Fissue-17877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17877.rs?ref=0c48c5712dc52bb1f9e70181f1b68feff75269c2", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert_eq!(match [0u8, ..1024] {\n+        _ => 42u,\n+    }, 42u);\n+\n+    assert_eq!(match [0u8, ..1024] {\n+        [1, _..] => 0u,\n+        [0, _..] => 1u,\n+        _ => 2u\n+    }, 1u);\n+}"}]}