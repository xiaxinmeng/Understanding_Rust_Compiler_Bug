{"sha": "cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "node_id": "C_kwDOAAsO6NoAKGNkZTdiZGM2NzhjNTJlZmQxNmJhZWFkMmM5Y2I4ZWIzYmY4YmU4NTQ", "commit": {"author": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-01-27T19:23:40Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-01-27T19:23:40Z"}, "message": "Sync rust-lang/portable-simd@03f6fbb21e6050da2a05b3ce8f480c020b384916", "tree": {"sha": "08c60c2c81e9936197a827c2ebd427ee256792ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08c60c2c81e9936197a827c2ebd427ee256792ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "html_url": "https://github.com/rust-lang/rust/commit/cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/comments", "author": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74fbbefea8d13683cca5eee62e4740706cb3144a", "url": "https://api.github.com/repos/rust-lang/rust/commits/74fbbefea8d13683cca5eee62e4740706cb3144a", "html_url": "https://github.com/rust-lang/rust/commit/74fbbefea8d13683cca5eee62e4740706cb3144a"}, {"sha": "03f6fbb21e6050da2a05b3ce8f480c020b384916", "url": "https://api.github.com/repos/rust-lang/rust/commits/03f6fbb21e6050da2a05b3ce8f480c020b384916", "html_url": "https://github.com/rust-lang/rust/commit/03f6fbb21e6050da2a05b3ce8f480c020b384916"}], "stats": {"total": 801, "additions": 480, "deletions": 321}, "files": [{"sha": "9802386e4566dab1749ccda5991d65594b4fa7c1", "filename": "library/portable-simd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2FCargo.toml?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -2,5 +2,6 @@\n \n members = [\n     \"crates/core_simd\",\n+    \"crates/std_float\",\n     \"crates/test_helpers\",\n ]"}, {"sha": "d2ff5f3b1b195fbbf3a55683c173ac19b69f86f0", "filename": "library/portable-simd/crates/core_simd/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2FCargo.toml?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -26,3 +26,6 @@ features = [\"alloc\"]\n \n [dev-dependencies.test_helpers]\n path = \"../test_helpers\"\n+\n+[dev-dependencies]\n+std_float = { path = \"../std_float/\", features = [\"as_crate\"] }"}, {"sha": "7b1e6840f6424f2f0f232f909c0eaf57e56c2223", "filename": "library/portable-simd/crates/core_simd/examples/nbody.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fexamples%2Fnbody.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -1,11 +1,13 @@\n-#![cfg_attr(feature = \"std\", feature(portable_simd))]\n+#![feature(portable_simd)]\n+extern crate std_float;\n \n /// Benchmarks game nbody code\n /// Taken from the `packed_simd` crate\n /// Run this benchmark with `cargo test --example nbody`\n-#[cfg(feature = \"std\")]\n mod nbody {\n-    use core_simd::*;\n+    use core_simd::simd::*;\n+    #[allow(unused)] // False positive?\n+    use std_float::StdFloat;\n \n     use std::f64::consts::PI;\n     const SOLAR_MASS: f64 = 4.0 * PI * PI;\n@@ -167,7 +169,6 @@ mod nbody {\n     }\n }\n \n-#[cfg(feature = \"std\")]\n #[cfg(test)]\n mod tests {\n     // Good enough for demonstration purposes, not going for strictness here.\n@@ -184,7 +185,6 @@ mod tests {\n }\n \n fn main() {\n-    #[cfg(feature = \"std\")]\n     {\n         let (energy_before, energy_after) = nbody::run(1000);\n         println!(\"Energy before: {}\", energy_before);"}, {"sha": "233657202f7e8def0053c03a12e4775ba98332b1", "filename": "library/portable-simd/crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -39,13 +39,21 @@ extern \"platform-intrinsic\" {\n \n     /// fptoui/fptosi/uitofp/sitofp\n     pub(crate) fn simd_cast<T, U>(x: T) -> U;\n+    /// follows Rust's `T as U` semantics, including saturating float casts\n+    /// which amounts to the same as `simd_cast` for many cases\n+    #[cfg(not(bootstrap))]\n+    pub(crate) fn simd_as<T, U>(x: T) -> U;\n \n     /// neg/fneg\n     pub(crate) fn simd_neg<T>(x: T) -> T;\n \n     /// fabs\n     pub(crate) fn simd_fabs<T>(x: T) -> T;\n \n+    // minnum/maxnum\n+    pub(crate) fn simd_fmin<T>(x: T, y: T) -> T;\n+    pub(crate) fn simd_fmax<T>(x: T, y: T) -> T;\n+\n     pub(crate) fn simd_eq<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_ne<T, U>(x: T, y: T) -> U;\n     pub(crate) fn simd_lt<T, U>(x: T, y: T) -> U;\n@@ -87,29 +95,3 @@ extern \"platform-intrinsic\" {\n     #[allow(unused)]\n     pub(crate) fn simd_select_bitmask<M, T>(m: M, a: T, b: T) -> T;\n }\n-\n-#[cfg(feature = \"std\")]\n-mod std {\n-    extern \"platform-intrinsic\" {\n-        // ceil\n-        pub(crate) fn simd_ceil<T>(x: T) -> T;\n-\n-        // floor\n-        pub(crate) fn simd_floor<T>(x: T) -> T;\n-\n-        // round\n-        pub(crate) fn simd_round<T>(x: T) -> T;\n-\n-        // trunc\n-        pub(crate) fn simd_trunc<T>(x: T) -> T;\n-\n-        // fsqrt\n-        pub(crate) fn simd_fsqrt<T>(x: T) -> T;\n-\n-        // fma\n-        pub(crate) fn simd_fma<T>(x: T, y: T, z: T) -> T;\n-    }\n-}\n-\n-#[cfg(feature = \"std\")]\n-pub(crate) use crate::simd::intrinsics::std::*;"}, {"sha": "ae1fef53da88e571db159de9614c44163ad069bf", "filename": "library/portable-simd/crates/core_simd/src/masks.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -12,9 +12,10 @@\n )]\n mod mask_impl;\n \n+use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::cmp::Ordering;\n-use core::fmt;\n+use core::{fmt, mem};\n \n mod sealed {\n     use super::*;\n@@ -105,22 +106,39 @@ where\n         Self(mask_impl::Mask::splat(value))\n     }\n \n-    /// Converts an array to a SIMD vector.\n+    /// Converts an array of bools to a SIMD mask.\n     pub fn from_array(array: [bool; LANES]) -> Self {\n-        let mut vector = Self::splat(false);\n-        for (i, v) in array.iter().enumerate() {\n-            vector.set(i, *v);\n+        // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n+        //     true:    0b_0000_0001\n+        //     false:   0b_0000_0000\n+        // Thus, an array of bools is also a valid array of bytes: [u8; N]\n+        // This would be hypothetically valid as an \"in-place\" transmute,\n+        // but these are \"dependently-sized\" types, so copy elision it is!\n+        unsafe {\n+            let bytes: [u8; LANES] = mem::transmute_copy(&array);\n+            let bools: Simd<i8, LANES> =\n+                intrinsics::simd_ne(Simd::from_array(bytes), Simd::splat(0u8));\n+            Mask::from_int_unchecked(intrinsics::simd_cast(bools))\n         }\n-        vector\n     }\n \n-    /// Converts a SIMD vector to an array.\n+    /// Converts a SIMD mask to an array of bools.\n     pub fn to_array(self) -> [bool; LANES] {\n-        let mut array = [false; LANES];\n-        for (i, v) in array.iter_mut().enumerate() {\n-            *v = self.test(i);\n+        // This follows mostly the same logic as from_array.\n+        // SAFETY: Rust's bool has a layout of 1 byte (u8) with a value of\n+        //     true:    0b_0000_0001\n+        //     false:   0b_0000_0000\n+        // Thus, an array of bools is also a valid array of bytes: [u8; N]\n+        // Since our masks are equal to integers where all bits are set,\n+        // we can simply convert them to i8s, and then bitand them by the\n+        // bitpattern for Rust's \"true\" bool.\n+        // This would be hypothetically valid as an \"in-place\" transmute,\n+        // but these are \"dependently-sized\" types, so copy elision it is!\n+        unsafe {\n+            let mut bytes: Simd<i8, LANES> = intrinsics::simd_cast(self.to_int());\n+            bytes &= Simd::splat(1i8);\n+            mem::transmute_copy(&bytes)\n         }\n-        array\n     }\n \n     /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n@@ -516,7 +534,7 @@ pub type mask16x8 = Mask<i16, 8>;\n pub type mask16x16 = Mask<i16, 16>;\n \n /// Vector of 32 16-bit masks\n-pub type mask16x32 = Mask<i32, 32>;\n+pub type mask16x32 = Mask<i16, 32>;\n \n /// Vector of two 32-bit masks\n pub type mask32x2 = Mask<i32, 2>;"}, {"sha": "b65038933bf33c185305f31fbcad70d1576166a1", "filename": "library/portable-simd/crates/core_simd/src/ops.rs", "status": "modified", "additions": 180, "deletions": 202, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fops.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -1,4 +1,3 @@\n-use crate::simd::intrinsics;\n use crate::simd::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n use core::ops::{Add, Mul};\n use core::ops::{BitAnd, BitOr, BitXor};\n@@ -32,232 +31,211 @@ where\n     }\n }\n \n-/// Checks if the right-hand side argument of a left- or right-shift would cause overflow.\n-fn invalid_shift_rhs<T>(rhs: T) -> bool\n-where\n-    T: Default + PartialOrd + core::convert::TryFrom<usize>,\n-    <T as core::convert::TryFrom<usize>>::Error: core::fmt::Debug,\n-{\n-    let bits_in_type = T::try_from(8 * core::mem::size_of::<T>()).unwrap();\n-    rhs < T::default() || rhs >= bits_in_type\n+macro_rules! unsafe_base {\n+    ($lhs:ident, $rhs:ident, {$simd_call:ident}, $($_:tt)*) => {\n+        unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n+    };\n }\n \n-/// Automatically implements operators over references in addition to the provided operator.\n-macro_rules! impl_ref_ops {\n-    // binary op\n-    {\n-        impl<const $lanes:ident: usize> core::ops::$trait:ident<$rhs:ty> for $type:ty\n-        where\n-            LaneCount<$lanes2:ident>: SupportedLaneCount,\n-        {\n-            type Output = $output:ty;\n-\n-            $(#[$attrs:meta])*\n-            fn $fn:ident($self_tok:ident, $rhs_arg:ident: $rhs_arg_ty:ty) -> Self::Output $body:tt\n-        }\n-    } => {\n-        impl<const $lanes: usize> core::ops::$trait<$rhs> for $type\n-        where\n-            LaneCount<$lanes2>: SupportedLaneCount,\n-        {\n-            type Output = $output;\n-\n-            $(#[$attrs])*\n-            fn $fn($self_tok, $rhs_arg: $rhs_arg_ty) -> Self::Output $body\n+/// SAFETY: This macro should not be used for anything except Shl or Shr, and passed the appropriate shift intrinsic.\n+/// It handles performing a bitand in addition to calling the shift operator, so that the result\n+/// is well-defined: LLVM can return a poison value if you shl, lshr, or ashr if rhs >= <Int>::BITS\n+/// At worst, this will maybe add another instruction and cycle,\n+/// at best, it may open up more optimization opportunities,\n+/// or simply be elided entirely, especially for SIMD ISAs which default to this.\n+///\n+// FIXME: Consider implementing this in cg_llvm instead?\n+// cg_clif defaults to this, and scalar MIR shifts also default to wrapping\n+macro_rules! wrap_bitshift {\n+    ($lhs:ident, $rhs:ident, {$simd_call:ident}, $int:ident) => {\n+        unsafe {\n+            $crate::simd::intrinsics::$simd_call(\n+                $lhs,\n+                $rhs.bitand(Simd::splat(<$int>::BITS as $int - 1)),\n+            )\n         }\n     };\n }\n \n-/// Automatically implements operators over vectors and scalars for a particular vector.\n-macro_rules! impl_op {\n-    { impl Add for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Add::add, simd_add }\n-    };\n-    { impl Sub for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Sub::sub, simd_sub }\n-    };\n-    { impl Mul for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Mul::mul, simd_mul }\n-    };\n-    { impl Div for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Div::div, simd_div }\n-    };\n-    { impl Rem for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Rem::rem, simd_rem }\n-    };\n-    { impl Shl for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shl::shl, simd_shl }\n-    };\n-    { impl Shr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, Shr::shr, simd_shr }\n-    };\n-    { impl BitAnd for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitAnd::bitand, simd_and }\n-    };\n-    { impl BitOr for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitOr::bitor, simd_or }\n-    };\n-    { impl BitXor for $scalar:ty } => {\n-        impl_op! { @binary $scalar, BitXor::bitxor, simd_xor }\n+// Division by zero is poison, according to LLVM.\n+// So is dividing the MIN value of a signed integer by -1,\n+// since that would return MAX + 1.\n+// FIXME: Rust allows <SInt>::MIN / -1,\n+// so we should probably figure out how to make that safe.\n+macro_rules! int_divrem_guard {\n+    (   $lhs:ident,\n+        $rhs:ident,\n+        {   const PANIC_ZERO: &'static str = $zero:literal;\n+            const PANIC_OVERFLOW: &'static str = $overflow:literal;\n+            $simd_call:ident\n+        },\n+        $int:ident ) => {\n+        if $rhs.lanes_eq(Simd::splat(0)).any() {\n+            panic!($zero);\n+        } else if <$int>::MIN != 0\n+            && ($lhs.lanes_eq(Simd::splat(<$int>::MIN))\n+                // type inference can break here, so cut an SInt to size\n+                & $rhs.lanes_eq(Simd::splat(-1i64 as _))).any()\n+        {\n+            panic!($overflow);\n+        } else {\n+            unsafe { $crate::simd::intrinsics::$simd_call($lhs, $rhs) }\n+        }\n     };\n+}\n \n-    // generic binary op with assignment when output is `Self`\n-    { @binary $scalar:ty, $trait:ident :: $trait_fn:ident, $intrinsic:ident } => {\n-        impl_ref_ops! {\n-            impl<const LANES: usize> core::ops::$trait<Self> for Simd<$scalar, LANES>\n-            where\n-                LaneCount<LANES>: SupportedLaneCount,\n-            {\n-                type Output = Self;\n+macro_rules! for_base_types {\n+    (   T = ($($scalar:ident),*);\n+        type Lhs = Simd<T, N>;\n+        type Rhs = Simd<T, N>;\n+        type Output = $out:ty;\n+\n+        impl $op:ident::$call:ident {\n+            $macro_impl:ident $inner:tt\n+        }) => {\n+            $(\n+                impl<const N: usize> $op<Self> for Simd<$scalar, N>\n+                where\n+                    $scalar: SimdElement,\n+                    LaneCount<N>: SupportedLaneCount,\n+                {\n+                    type Output = $out;\n \n-                #[inline]\n-                fn $trait_fn(self, rhs: Self) -> Self::Output {\n-                    unsafe {\n-                        intrinsics::$intrinsic(self, rhs)\n+                    #[inline]\n+                    #[must_use = \"operator returns a new vector without mutating the inputs\"]\n+                    fn $call(self, rhs: Self) -> Self::Output {\n+                        $macro_impl!(self, rhs, $inner, $scalar)\n                     }\n-                }\n-            }\n-        }\n-    };\n+                })*\n+    }\n }\n \n-/// Implements floating-point operators for the provided types.\n-macro_rules! impl_float_ops {\n-    { $($scalar:ty),* } => {\n-        $(\n-            impl_op! { impl Add for $scalar }\n-            impl_op! { impl Sub for $scalar }\n-            impl_op! { impl Mul for $scalar }\n-            impl_op! { impl Div for $scalar }\n-            impl_op! { impl Rem for $scalar }\n-        )*\n+// A \"TokenTree muncher\": takes a set of scalar types `T = {};`\n+// type parameters for the ops it implements, `Op::fn` names,\n+// and a macro that expands into an expr, substituting in an intrinsic.\n+// It passes that to for_base_types, which expands an impl for the types,\n+// using the expanded expr in the function, and recurses with itself.\n+//\n+// tl;dr impls a set of ops::{Traits} for a set of types\n+macro_rules! for_base_ops {\n+    (\n+        T = $types:tt;\n+        type Lhs = Simd<T, N>;\n+        type Rhs = Simd<T, N>;\n+        type Output = $out:ident;\n+        impl $op:ident::$call:ident\n+            $inner:tt\n+        $($rest:tt)*\n+    ) => {\n+        for_base_types! {\n+            T = $types;\n+            type Lhs = Simd<T, N>;\n+            type Rhs = Simd<T, N>;\n+            type Output = $out;\n+            impl $op::$call\n+                $inner\n+        }\n+        for_base_ops! {\n+            T = $types;\n+            type Lhs = Simd<T, N>;\n+            type Rhs = Simd<T, N>;\n+            type Output = $out;\n+            $($rest)*\n+        }\n     };\n+    ($($done:tt)*) => {\n+        // Done.\n+    }\n }\n \n-/// Implements unsigned integer operators for the provided types.\n-macro_rules! impl_unsigned_int_ops {\n-    { $($scalar:ty),* } => {\n-        $(\n-            impl_op! { impl Add for $scalar }\n-            impl_op! { impl Sub for $scalar }\n-            impl_op! { impl Mul for $scalar }\n-            impl_op! { impl BitAnd for $scalar }\n-            impl_op! { impl BitOr  for $scalar }\n-            impl_op! { impl BitXor for $scalar }\n+// Integers can always accept add, mul, sub, bitand, bitor, and bitxor.\n+// For all of these operations, simd_* intrinsics apply wrapping logic.\n+for_base_ops! {\n+    T = (i8, i16, i32, i64, isize, u8, u16, u32, u64, usize);\n+    type Lhs = Simd<T, N>;\n+    type Rhs = Simd<T, N>;\n+    type Output = Self;\n \n-            // Integers panic on divide by 0\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Div<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n+    impl Add::add {\n+        unsafe_base { simd_add }\n+    }\n \n-                    #[inline]\n-                    fn div(self, rhs: Self) -> Self::Output {\n-                        if rhs.as_array()\n-                            .iter()\n-                            .any(|x| *x == 0)\n-                        {\n-                            panic!(\"attempt to divide by zero\");\n-                        }\n+    impl Mul::mul {\n+        unsafe_base { simd_mul }\n+    }\n \n-                        // Guards for div(MIN, -1),\n-                        // this check only applies to signed ints\n-                        if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                .zip(rhs.as_array().iter())\n-                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                            panic!(\"attempt to divide with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_div(self, rhs) }\n-                    }\n-                }\n-            }\n+    impl Sub::sub {\n+        unsafe_base { simd_sub }\n+    }\n \n-            // remainder panics on zero divisor\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Rem<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n+    impl BitAnd::bitand {\n+        unsafe_base { simd_and }\n+    }\n \n-                    #[inline]\n-                    fn rem(self, rhs: Self) -> Self::Output {\n-                        if rhs.as_array()\n-                            .iter()\n-                            .any(|x| *x == 0)\n-                        {\n-                            panic!(\"attempt to calculate the remainder with a divisor of zero\");\n-                        }\n+    impl BitOr::bitor {\n+        unsafe_base { simd_or }\n+    }\n \n-                        // Guards for rem(MIN, -1)\n-                        // this branch applies the check only to signed ints\n-                        if <$scalar>::MIN != 0 && self.as_array().iter()\n-                                .zip(rhs.as_array().iter())\n-                                .any(|(x,y)| *x == <$scalar>::MIN && *y == -1 as _) {\n-                            panic!(\"attempt to calculate the remainder with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_rem(self, rhs) }\n-                    }\n-                }\n-            }\n+    impl BitXor::bitxor {\n+        unsafe_base { simd_xor }\n+    }\n \n-            // shifts panic on overflow\n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shl<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n+    impl Div::div {\n+        int_divrem_guard {\n+            const PANIC_ZERO: &'static str = \"attempt to divide by zero\";\n+            const PANIC_OVERFLOW: &'static str = \"attempt to divide with overflow\";\n+            simd_div\n+        }\n+    }\n \n-                    #[inline]\n-                    fn shl(self, rhs: Self) -> Self::Output {\n-                        // TODO there is probably a better way of doing this\n-                        if rhs.as_array()\n-                            .iter()\n-                            .copied()\n-                            .any(invalid_shift_rhs)\n-                        {\n-                            panic!(\"attempt to shift left with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_shl(self, rhs) }\n-                    }\n-                }\n-            }\n+    impl Rem::rem {\n+        int_divrem_guard {\n+            const PANIC_ZERO: &'static str = \"attempt to calculate the remainder with a divisor of zero\";\n+            const PANIC_OVERFLOW: &'static str = \"attempt to calculate the remainder with overflow\";\n+            simd_rem\n+        }\n+    }\n \n-            impl_ref_ops! {\n-                impl<const LANES: usize> core::ops::Shr<Self> for Simd<$scalar, LANES>\n-                where\n-                    LaneCount<LANES>: SupportedLaneCount,\n-                {\n-                    type Output = Self;\n+    // The only question is how to handle shifts >= <Int>::BITS?\n+    // Our current solution uses wrapping logic.\n+    impl Shl::shl {\n+        wrap_bitshift { simd_shl }\n+    }\n \n-                    #[inline]\n-                    fn shr(self, rhs: Self) -> Self::Output {\n-                        // TODO there is probably a better way of doing this\n-                        if rhs.as_array()\n-                            .iter()\n-                            .copied()\n-                            .any(invalid_shift_rhs)\n-                        {\n-                            panic!(\"attempt to shift with overflow\");\n-                        }\n-                        unsafe { intrinsics::simd_shr(self, rhs) }\n-                    }\n-                }\n-            }\n-        )*\n-    };\n+    impl Shr::shr {\n+        wrap_bitshift {\n+            // This automatically monomorphizes to lshr or ashr, depending,\n+            // so it's fine to use it for both UInts and SInts.\n+            simd_shr\n+        }\n+    }\n }\n \n-/// Implements unsigned integer operators for the provided types.\n-macro_rules! impl_signed_int_ops {\n-    { $($scalar:ty),* } => {\n-        impl_unsigned_int_ops! { $($scalar),* }\n-    };\n-}\n+// We don't need any special precautions here:\n+// Floats always accept arithmetic ops, but may become NaN.\n+for_base_ops! {\n+    T = (f32, f64);\n+    type Lhs = Simd<T, N>;\n+    type Rhs = Simd<T, N>;\n+    type Output = Self;\n+\n+    impl Add::add {\n+        unsafe_base { simd_add }\n+    }\n \n-impl_unsigned_int_ops! { u8, u16, u32, u64, usize }\n-impl_signed_int_ops! { i8, i16, i32, i64, isize }\n-impl_float_ops! { f32, f64 }\n+    impl Mul::mul {\n+        unsafe_base { simd_mul }\n+    }\n+\n+    impl Sub::sub {\n+        unsafe_base { simd_sub }\n+    }\n+\n+    impl Div::div {\n+        unsafe_base { simd_div }\n+    }\n+\n+    impl Rem::rem {\n+        unsafe_base { simd_rem }\n+    }\n+}"}, {"sha": "06ccab3ec494c6b0799bc43f29416b143318deab", "filename": "library/portable-simd/crates/core_simd/src/round.rs", "status": "modified", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fround.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -5,47 +5,6 @@ macro_rules! implement {\n     {\n         $type:ty, $int_type:ty\n     } => {\n-        #[cfg(feature = \"std\")]\n-        impl<const LANES: usize> Simd<$type, LANES>\n-        where\n-            LaneCount<LANES>: SupportedLaneCount,\n-        {\n-            /// Returns the smallest integer greater than or equal to each lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn ceil(self) -> Self {\n-                unsafe { intrinsics::simd_ceil(self) }\n-            }\n-\n-            /// Returns the largest integer value less than or equal to each lane.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn floor(self) -> Self {\n-                unsafe { intrinsics::simd_floor(self) }\n-            }\n-\n-            /// Rounds to the nearest integer value. Ties round toward zero.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn round(self) -> Self {\n-                unsafe { intrinsics::simd_round(self) }\n-            }\n-\n-            /// Returns the floating point's integer value, with its fractional part removed.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn trunc(self) -> Self {\n-                unsafe { intrinsics::simd_trunc(self) }\n-            }\n-\n-            /// Returns the floating point's fractional value, with its integer part removed.\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[inline]\n-            pub fn fract(self) -> Self {\n-                self - self.trunc()\n-            }\n-        }\n-\n         impl<const LANES: usize> Simd<$type, LANES>\n         where\n             LaneCount<LANES>: SupportedLaneCount,"}, {"sha": "b7ef7a56c7319b6404d1464149a7c68e28d3ba83", "filename": "library/portable-simd/crates/core_simd/src/vector.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -75,6 +75,36 @@ where\n         Self(array)\n     }\n \n+    /// Performs lanewise conversion of a SIMD vector's elements to another SIMD-valid type.\n+    /// This follows the semantics of Rust's `as` conversion for casting\n+    /// integers to unsigned integers (interpreting as the other type, so `-1` to `MAX`),\n+    /// and from floats to integers (truncating, or saturating at the limits) for each lane,\n+    /// or vice versa.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// # #![feature(portable_simd)]\n+    /// # #[cfg(feature = \"std\")] use core_simd::Simd;\n+    /// # #[cfg(not(feature = \"std\"))] use core::simd::Simd;\n+    /// let floats: Simd<f32, 4> = Simd::from_array([1.9, -4.5, f32::INFINITY, f32::NAN]);\n+    /// let ints = floats.cast::<i32>();\n+    /// assert_eq!(ints, Simd::from_array([1, -4, i32::MAX, 0]));\n+    ///\n+    /// // Formally equivalent, but `Simd::cast` can optimize better.\n+    /// assert_eq!(ints, Simd::from_array(floats.to_array().map(|x| x as i32)));\n+    ///\n+    /// // The float conversion does not round-trip.\n+    /// let floats_again = ints.cast();\n+    /// assert_ne!(floats, floats_again);\n+    /// assert_eq!(floats_again, Simd::from_array([1.0, -4.0, 2147483647.0, 0.0]));\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[cfg(not(bootstrap))]\n+    pub fn cast<U: SimdElement>(self) -> Simd<U, LANES> {\n+        unsafe { intrinsics::simd_as(self) }\n+    }\n+\n     /// Reads from potentially discontiguous indices in `slice` to construct a SIMD vector.\n     /// If an index is out-of-bounds, the lane is instead selected from the `or` vector.\n     ///"}, {"sha": "fcc7f6d8d1c50c96caab26c4b8dae20103c90ee2", "filename": "library/portable-simd/crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 4, "deletions": 35, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -38,29 +38,6 @@ macro_rules! impl_float_vector {\n                 unsafe { intrinsics::simd_fabs(self) }\n             }\n \n-            /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n-            /// yielding a more accurate result than an unfused multiply-add.\n-            ///\n-            /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n-            /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n-            /// true, and will be heavily dependent on designing algorithms with specific target\n-            /// hardware in mind.\n-            #[cfg(feature = \"std\")]\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            pub fn mul_add(self, a: Self, b: Self) -> Self {\n-                unsafe { intrinsics::simd_fma(self, a, b) }\n-            }\n-\n-            /// Produces a vector where every lane has the square root value\n-            /// of the equivalently-indexed lane in `self`\n-            #[inline]\n-            #[must_use = \"method returns a new vector and does not mutate the original value\"]\n-            #[cfg(feature = \"std\")]\n-            pub fn sqrt(self) -> Self {\n-                unsafe { intrinsics::simd_fsqrt(self) }\n-            }\n-\n             /// Takes the reciprocal (inverse) of each lane, `1/x`.\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n@@ -128,8 +105,8 @@ macro_rules! impl_float_vector {\n                 self.abs().lanes_ne(Self::splat(0.0)) & (self.to_bits() & Self::splat(<$type>::INFINITY).to_bits()).lanes_eq(Simd::splat(0))\n             }\n \n-            /// Returns true for each lane if its value is neither neither zero, infinite,\n-            /// subnormal, or `NaN`.\n+            /// Returns true for each lane if its value is neither zero, infinite,\n+            /// subnormal, nor `NaN`.\n             #[inline]\n             #[must_use = \"method returns a new mask and does not mutate the original value\"]\n             pub fn is_normal(self) -> Mask<$mask_ty, LANES> {\n@@ -164,11 +141,7 @@ macro_rules! impl_float_vector {\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn min(self, other: Self) -> Self {\n-                // TODO consider using an intrinsic\n-                self.is_nan().select(\n-                    other,\n-                    self.lanes_ge(other).select(other, self)\n-                )\n+                unsafe { intrinsics::simd_fmin(self, other) }\n             }\n \n             /// Returns the maximum of each lane.\n@@ -177,11 +150,7 @@ macro_rules! impl_float_vector {\n             #[inline]\n             #[must_use = \"method returns a new vector and does not mutate the original value\"]\n             pub fn max(self, other: Self) -> Self {\n-                // TODO consider using an intrinsic\n-                self.is_nan().select(\n-                    other,\n-                    self.lanes_le(other).select(other, self)\n-                )\n+                unsafe { intrinsics::simd_fmax(self, other) }\n             }\n \n             /// Restrict each lane to a certain interval unless it is NaN."}, {"sha": "ab5650f071323a9e0b96dbb80c123495372bbf1e", "filename": "library/portable-simd/crates/core_simd/tests/cast.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fcast.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -0,0 +1,37 @@\n+#![feature(portable_simd)]\n+macro_rules! cast_types {\n+    ($start:ident, $($target:ident),*) => {\n+        mod $start {\n+            use core_simd::simd::Simd;\n+            type Vector<const N: usize> = Simd<$start, N>;\n+            $(\n+                mod $target {\n+                    use super::*;\n+                    test_helpers::test_lanes! {\n+                        fn cast_as<const N: usize>() {\n+                            test_helpers::test_unary_elementwise(\n+                                &Vector::<N>::cast::<$target>,\n+                                &|x| x as $target,\n+                                &|_| true,\n+                            )\n+                        }\n+                    }\n+                }\n+            )*\n+        }\n+    };\n+}\n+\n+// The hypothesis is that widening conversions aren't terribly interesting.\n+cast_types!(f32, f64, i8, u8, usize, isize);\n+cast_types!(f64, f32, i8, u8, usize, isize);\n+cast_types!(i8, u8, f32);\n+cast_types!(u8, i8, f32);\n+cast_types!(i16, u16, i8, u8, f32);\n+cast_types!(u16, i16, i8, u8, f32);\n+cast_types!(i32, u32, i8, u8, f32, f64);\n+cast_types!(u32, i32, i8, u8, f32, f64);\n+cast_types!(i64, u64, i8, u8, isize, usize, f32, f64);\n+cast_types!(u64, i64, i8, u8, isize, usize, f32, f64);\n+cast_types!(isize, usize, i8, u8, f32, f64);\n+cast_types!(usize, isize, i8, u8, f32, f64);"}, {"sha": "4fb9de198ee15f5678a18eedbed49fbb463f3336", "filename": "library/portable-simd/crates/core_simd/tests/ops_macros.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fops_macros.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -546,6 +546,8 @@ macro_rules! impl_float_tests {\n \n             #[cfg(feature = \"std\")]\n             mod std {\n+                use std_float::StdFloat;\n+\n                 use super::*;\n                 test_helpers::test_lanes! {\n                     fn sqrt<const LANES: usize>() {"}, {"sha": "1a1bc9ebca76a15d0b5b1bb1b486801d20104168", "filename": "library/portable-simd/crates/core_simd/tests/round.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fcore_simd%2Ftests%2Fround.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -3,6 +3,8 @@\n macro_rules! float_rounding_test {\n     { $scalar:tt, $int_scalar:tt } => {\n         mod $scalar {\n+            use std_float::StdFloat;\n+\n             type Vector<const LANES: usize> = core_simd::Simd<$scalar, LANES>;\n             type Scalar = $scalar;\n             type IntScalar = $int_scalar;"}, {"sha": "82f66b8dcb7493a378956a3e09578e8ed7b39d66", "filename": "library/portable-simd/crates/std_float/Cargo.toml", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fstd_float%2FCargo.toml?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -0,0 +1,13 @@\n+[package]\n+name = \"std_float\"\n+version = \"0.1.0\"\n+edition = \"2021\"\n+\n+# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n+\n+[dependencies]\n+core_simd = { path = \"../core_simd\" }\n+\n+[features]\n+default = [\"as_crate\"]\n+as_crate = []"}, {"sha": "4bd4d4c05e3b9cb9f1ad258577c6c31d3f0f67db", "filename": "library/portable-simd/crates/std_float/src/lib.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cde7bdc678c52efd16baead2c9cb8eb3bf8be854/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fportable-simd%2Fcrates%2Fstd_float%2Fsrc%2Flib.rs?ref=cde7bdc678c52efd16baead2c9cb8eb3bf8be854", "patch": "@@ -0,0 +1,165 @@\n+#![cfg_attr(feature = \"as_crate\", no_std)] // We are std!\n+#![cfg_attr(\n+    feature = \"as_crate\",\n+    feature(platform_intrinsics),\n+    feature(portable_simd)\n+)]\n+#[cfg(not(feature = \"as_crate\"))]\n+use core::simd;\n+#[cfg(feature = \"as_crate\")]\n+use core_simd::simd;\n+\n+use simd::{LaneCount, Simd, SupportedLaneCount};\n+\n+#[cfg(feature = \"as_crate\")]\n+mod experimental {\n+    pub trait Sealed {}\n+}\n+\n+#[cfg(feature = \"as_crate\")]\n+use experimental as sealed;\n+\n+use crate::sealed::Sealed;\n+\n+// \"platform intrinsics\" are essentially \"codegen intrinsics\"\n+// each of these may be scalarized and lowered to a libm call\n+extern \"platform-intrinsic\" {\n+    // ceil\n+    fn simd_ceil<T>(x: T) -> T;\n+\n+    // floor\n+    fn simd_floor<T>(x: T) -> T;\n+\n+    // round\n+    fn simd_round<T>(x: T) -> T;\n+\n+    // trunc\n+    fn simd_trunc<T>(x: T) -> T;\n+\n+    // fsqrt\n+    fn simd_fsqrt<T>(x: T) -> T;\n+\n+    // fma\n+    fn simd_fma<T>(x: T, y: T, z: T) -> T;\n+}\n+\n+/// This trait provides a possibly-temporary implementation of float functions\n+/// that may, in the absence of hardware support, canonicalize to calling an\n+/// operating system's `math.h` dynamically-loaded library (also known as a\n+/// shared object). As these conditionally require runtime support, they\n+/// should only appear in binaries built assuming OS support: `std`.\n+///\n+/// However, there is no reason SIMD types, in general, need OS support,\n+/// as for many architectures an embedded binary may simply configure that\n+/// support itself. This means these types must be visible in `core`\n+/// but have these functions available in `std`.\n+///\n+/// [`f32`] and [`f64`] achieve a similar trick by using \"lang items\", but\n+/// due to compiler limitations, it is harder to implement this approach for\n+/// abstract data types like [`Simd`]. From that need, this trait is born.\n+///\n+/// It is possible this trait will be replaced in some manner in the future,\n+/// when either the compiler or its supporting runtime functions are improved.\n+/// For now this trait is available to permit experimentation with SIMD float\n+/// operations that may lack hardware support, such as `mul_add`.\n+pub trait StdFloat: Sealed + Sized {\n+    /// Fused multiply-add.  Computes `(self * a) + b` with only one rounding error,\n+    /// yielding a more accurate result than an unfused multiply-add.\n+    ///\n+    /// Using `mul_add` *may* be more performant than an unfused multiply-add if the target\n+    /// architecture has a dedicated `fma` CPU instruction.  However, this is not always\n+    /// true, and will be heavily dependent on designing algorithms with specific target\n+    /// hardware in mind.\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn mul_add(self, a: Self, b: Self) -> Self {\n+        unsafe { simd_fma(self, a, b) }\n+    }\n+\n+    /// Produces a vector where every lane has the square root value\n+    /// of the equivalently-indexed lane in `self`\n+    #[inline]\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn sqrt(self) -> Self {\n+        unsafe { simd_fsqrt(self) }\n+    }\n+\n+    /// Returns the smallest integer greater than or equal to each lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn ceil(self) -> Self {\n+        unsafe { simd_ceil(self) }\n+    }\n+\n+    /// Returns the largest integer value less than or equal to each lane.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn floor(self) -> Self {\n+        unsafe { simd_floor(self) }\n+    }\n+\n+    /// Rounds to the nearest integer value. Ties round toward zero.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn round(self) -> Self {\n+        unsafe { simd_round(self) }\n+    }\n+\n+    /// Returns the floating point's integer value, with its fractional part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn trunc(self) -> Self {\n+        unsafe { simd_trunc(self) }\n+    }\n+\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    fn fract(self) -> Self;\n+}\n+\n+impl<const N: usize> Sealed for Simd<f32, N> where LaneCount<N>: SupportedLaneCount {}\n+impl<const N: usize> Sealed for Simd<f64, N> where LaneCount<N>: SupportedLaneCount {}\n+\n+// We can safely just use all the defaults.\n+impl<const N: usize> StdFloat for Simd<f32, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn fract(self) -> Self {\n+        self - self.trunc()\n+    }\n+}\n+\n+impl<const N: usize> StdFloat for Simd<f64, N>\n+where\n+    LaneCount<N>: SupportedLaneCount,\n+{\n+    /// Returns the floating point's fractional value, with its integer part removed.\n+    #[must_use = \"method returns a new vector and does not mutate the original value\"]\n+    #[inline]\n+    fn fract(self) -> Self {\n+        self - self.trunc()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use simd::*;\n+\n+    #[test]\n+    fn everything_works() {\n+        let x = f32x4::from_array([0.1, 0.5, 0.6, -1.5]);\n+        let x2 = x + x;\n+        let _xc = x.ceil();\n+        let _xf = x.floor();\n+        let _xr = x.round();\n+        let _xt = x.trunc();\n+        let _xfma = x.mul_add(x, x);\n+        let _xsqrt = x.sqrt();\n+        let _ = x2.abs() * x2;\n+    }\n+}"}]}