{"sha": "cca80b9a81d495f543cdc122fa330c7f68fff3a8", "node_id": "C_kwDOAAsO6NoAKGNjYTgwYjlhODFkNDk1ZjU0M2NkYzEyMmZhMzMwYzdmNjhmZmYzYTg", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T17:48:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-22T17:48:43Z"}, "message": "Auto merge of #103957 - JakobDegen:drop-retag, r=RalfJung\n\nRetag as FnEntry on `drop_in_place`\n\nThis commit changes the mir drop shim to always retag its argument as if it were a `&mut`.\n\ncc rust-lang/unsafe-code-guidelines#373", "tree": {"sha": "fd3758d2b90812aa48579864bd465db68ded874c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd3758d2b90812aa48579864bd465db68ded874c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca80b9a81d495f543cdc122fa330c7f68fff3a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca80b9a81d495f543cdc122fa330c7f68fff3a8", "html_url": "https://github.com/rust-lang/rust/commit/cca80b9a81d495f543cdc122fa330c7f68fff3a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca80b9a81d495f543cdc122fa330c7f68fff3a8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e4eef02d443eae5089a330e59a69a4f350db81", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e4eef02d443eae5089a330e59a69a4f350db81", "html_url": "https://github.com/rust-lang/rust/commit/e5e4eef02d443eae5089a330e59a69a4f350db81"}, {"sha": "0229281d03d92eec1b167377fec1e9978af1f704", "url": "https://api.github.com/repos/rust-lang/rust/commits/0229281d03d92eec1b167377fec1e9978af1f704", "html_url": "https://github.com/rust-lang/rust/commit/0229281d03d92eec1b167377fec1e9978af1f704"}], "stats": {"total": 214, "additions": 199, "deletions": 15}, "files": [{"sha": "550c7a44c4199e6cf7043d4dd60f6e49c7f4b436", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -119,11 +119,20 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n \n             Drop { place, target, unwind } => {\n+                let frame = self.frame();\n+                let ty = place.ty(&frame.body.local_decls, *self.tcx).ty;\n+                let ty = self.subst_from_frame_and_normalize_erasing_regions(frame, ty)?;\n+                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n+                if let ty::InstanceDef::DropGlue(_, None) = instance.def {\n+                    // This is the branch we enter if and only if the dropped type has no drop glue\n+                    // whatsoever. This can happen as a result of monomorphizing a drop of a\n+                    // generic. In order to make sure that generic and non-generic code behaves\n+                    // roughly the same (and in keeping with Mir semantics) we do nothing here.\n+                    self.go_to_block(target);\n+                    return Ok(());\n+                }\n                 let place = self.eval_place(place)?;\n-                let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", place, ty);\n-\n-                let instance = Instance::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_in_place(&place, instance, target, unwind)?;\n             }\n "}, {"sha": "6b4489026d3d379dee958125b73ced3eb3d40fb1", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -564,14 +564,13 @@ pub enum TerminatorKind<'tcx> {\n     Unreachable,\n \n     /// The behavior of this statement differs significantly before and after drop elaboration.\n-    /// After drop elaboration, `Drop` executes the drop glue for the specified place, after which\n-    /// it continues execution/unwinds at the given basic blocks. It is possible that executing drop\n-    /// glue is special - this would be part of Rust's memory model. (**FIXME**: due we have an\n-    /// issue tracking if drop glue has any interesting semantics in addition to those of a function\n-    /// call?)\n-    ///\n-    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically, the\n-    /// `Drop` will be executed if...\n+    ///\n+    /// After drop elaboration: `Drop` terminators are a complete nop for types that have no drop\n+    /// glue. For other types, `Drop` terminators behave exactly like a call to\n+    /// `core::mem::drop_in_place` with a pointer to the given place.\n+    ///\n+    /// `Drop` before drop elaboration is a *conditional* execution of the drop glue. Specifically,\n+    /// the `Drop` will be executed if...\n     ///\n     /// **Needs clarification**: End of that sentence. This in effect should document the exact\n     /// behavior of drop elaboration. The following sounds vaguely right, but I'm not quite sure:"}, {"sha": "dace540fa29d2596739379f140d446909c08cc5f", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -174,9 +174,36 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n     let mut body =\n         new_body(source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n+    // The first argument (index 0), but add 1 for the return value.\n+    let mut dropee_ptr = Place::from(Local::new(1 + 0));\n+    if tcx.sess.opts.unstable_opts.mir_emit_retag {\n+        // We want to treat the function argument as if it was passed by `&mut`. As such, we\n+        // generate\n+        // ```\n+        // temp = &mut *arg;\n+        // Retag(temp, FnEntry)\n+        // ```\n+        // It's important that we do this first, before anything that depends on `dropee_ptr`\n+        // has been put into the body.\n+        let reborrow = Rvalue::Ref(\n+            tcx.lifetimes.re_erased,\n+            BorrowKind::Mut { allow_two_phase_borrow: false },\n+            tcx.mk_place_deref(dropee_ptr),\n+        );\n+        let ref_ty = reborrow.ty(body.local_decls(), tcx);\n+        dropee_ptr = body.local_decls.push(LocalDecl::new(ref_ty, span)).into();\n+        let new_statements = [\n+            StatementKind::Assign(Box::new((dropee_ptr, reborrow))),\n+            StatementKind::Retag(RetagKind::FnEntry, Box::new(dropee_ptr)),\n+        ];\n+        for s in new_statements {\n+            body.basic_blocks_mut()[START_BLOCK]\n+                .statements\n+                .push(Statement { source_info, kind: s });\n+        }\n+    }\n+\n     if ty.is_some() {\n-        // The first argument (index 0), but add 1 for the return value.\n-        let dropee_ptr = Place::from(Local::new(1 + 0));\n         let patch = {\n             let param_env = tcx.param_env_reveal_all_normalized(def_id);\n             let mut elaborator ="}, {"sha": "f495f147be3df8682425b312beccef6bfc837248", "filename": "src/test/mir-opt/retag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.core.ptr-drop_in_place.Test.SimplifyCfg-make_shim.after.mir?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -3,11 +3,14 @@\n fn std::ptr::drop_in_place(_1: *mut Test) -> () {\n     let mut _0: ();                      // return place in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n     let mut _2: &mut Test;               // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-    let mut _3: ();                      // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _3: &mut Test;               // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+    let mut _4: ();                      // in scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n \n     bb0: {\n         _2 = &mut (*_1);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n-        _3 = <Test as Drop>::drop(move _2) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        Retag([fn entry] _2);            // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _3 = &mut (*_2);                 // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n+        _4 = <Test as Drop>::drop(move _3) -> bb1; // scope 0 at $SRC_DIR/core/src/ptr/mod.rs:+0:1: +0:56\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/ptr/mod.rs:LL:COL\n                                          // + literal: Const { ty: for<'a> fn(&'a mut Test) {<Test as Drop>::drop}, val: Value(<ZST>) }"}, {"sha": "8cf63ee700b8552bf62f581a98147e62336eed72", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_protector.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,27 @@\n+//! Test that drop_in_place retags the entire place,\n+//! invalidating all aliases to it.\n+\n+// A zero-sized drop type -- the retagging of `fn drop` itself won't\n+// do anything (since it is zero-sized); we are entirely relying on the retagging\n+// in `drop_in_place` here.\n+#[repr(transparent)]\n+struct HasDrop;\n+impl Drop for HasDrop {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let _val = *P;\n+            //~^ ERROR: /not granting access .* because that would remove .* which is strongly protected/\n+        }\n+    }\n+}\n+\n+static mut P: *mut u8 = core::ptr::null_mut();\n+\n+fn main() {\n+    unsafe {\n+        let mut x = (HasDrop, 0u8);\n+        let x = core::ptr::addr_of_mut!(x);\n+        P = x.cast();\n+        core::ptr::drop_in_place(x);\n+    }\n+}"}, {"sha": "bd51a6645a676ed181a6afc66edc5d9ca3ce69f3", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_protector.stderr", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_protector.stderr?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,33 @@\n+error: Undefined Behavior: not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n+  --> $DIR/drop_in_place_protector.rs:LL:CC\n+   |\n+LL |             let _val = *P;\n+   |                        ^^ not granting access to tag <TAG> because that would remove [Unique for <TAG>] which is strongly protected because it is an argument of call ID\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadWrite retag at offsets [0x0..0x1]\n+  --> $DIR/drop_in_place_protector.rs:LL:CC\n+   |\n+LL |         let x = core::ptr::addr_of_mut!(x);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: <TAG> is this argument\n+  --> $DIR/drop_in_place_protector.rs:LL:CC\n+   |\n+LL |         core::ptr::drop_in_place(x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `<HasDrop as std::ops::Drop>::drop` at $DIR/drop_in_place_protector.rs:LL:CC\n+   = note: inside `std::ptr::drop_in_place::<HasDrop> - shim(Some(HasDrop))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   = note: inside `std::ptr::drop_in_place::<(HasDrop, u8)> - shim(Some((HasDrop, u8)))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/drop_in_place_protector.rs:LL:CC\n+   |\n+LL |         core::ptr::drop_in_place(x);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the macro `core::ptr::addr_of_mut` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "8180e2f03a79c4c05c62a340283e74839ea79406", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_retag.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,12 @@\n+//! Test that drop_in_place mutably retags the entire place, even for a type that does not need\n+//! dropping, ensuring among other things that it is writeable\n+\n+//@error-pattern: /retag .* for Unique permission .* only grants SharedReadOnly permission/\n+\n+fn main() {\n+    unsafe {\n+        let x = 0u8;\n+        let x = core::ptr::addr_of!(x);\n+        core::ptr::drop_in_place(x.cast_mut());\n+    }\n+}"}, {"sha": "3f9e6708bdaade56cb6e7d19038a240eaca42718", "filename": "src/tools/miri/tests/fail/stacked_borrows/drop_in_place_retag.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdrop_in_place_retag.stderr?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,29 @@\n+error: Undefined Behavior: trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | trying to retag from <TAG> for Unique permission at ALLOC[0x0], but that tag only grants SharedReadOnly permission for this location\n+   | this error occurs as part of retag at ALLOC[0x0..0x1]\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n+   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n+help: <TAG> was created by a SharedReadOnly retag at offsets [0x0..0x1]\n+  --> $DIR/drop_in_place_retag.rs:LL:CC\n+   |\n+LL |         let x = core::ptr::addr_of!(x);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: BACKTRACE:\n+   = note: inside `std::ptr::drop_in_place::<u8> - shim(None)` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/drop_in_place_retag.rs:LL:CC\n+   |\n+LL |         core::ptr::drop_in_place(x.cast_mut());\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the macro `core::ptr::addr_of` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "cf3a558bb994adff00fd717b0891a915fbac5725", "filename": "src/tools/miri/tests/fail/unaligned_pointers/drop_in_place.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.rs?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,25 @@\n+#[repr(transparent)]\n+struct HasDrop(u8);\n+\n+impl Drop for HasDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+#[repr(C, align(2))]\n+struct PartialDrop {\n+    a: HasDrop,\n+    b: u8,\n+}\n+\n+//@error-pattern: /alignment 2 is required/\n+fn main() {\n+    unsafe {\n+        // Create an unaligned pointer\n+        let mut x = [0_u16; 2];\n+        let p = core::ptr::addr_of_mut!(x).cast::<u8>();\n+        let p = p.add(1);\n+        let p = p.cast::<PartialDrop>();\n+\n+        core::ptr::drop_in_place(p);\n+    }\n+}"}, {"sha": "ef20b43c118ff5619eb557312bccbe420638f097", "filename": "src/tools/miri/tests/fail/unaligned_pointers/drop_in_place.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cca80b9a81d495f543cdc122fa330c7f68fff3a8/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fdrop_in_place.stderr?ref=cca80b9a81d495f543cdc122fa330c7f68fff3a8", "patch": "@@ -0,0 +1,20 @@\n+error: Undefined Behavior: accessing memory with alignment ALIGN, but alignment ALIGN is required\n+  --> RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+   |\n+LL | pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ accessing memory with alignment ALIGN, but alignment ALIGN is required\n+   |\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE:\n+   = note: inside `std::ptr::drop_in_place::<PartialDrop> - shim(Some(PartialDrop))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/drop_in_place.rs:LL:CC\n+   |\n+LL |         core::ptr::drop_in_place(p);\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}]}