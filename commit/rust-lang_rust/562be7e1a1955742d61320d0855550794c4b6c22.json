{"sha": "562be7e1a1955742d61320d0855550794c4b6c22", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MmJlN2UxYTE5NTU3NDJkNjEzMjBkMDg1NTU1MDc5NGM0YjZjMjI=", "commit": {"author": {"name": "Olivier Goffart", "email": "ogoffart@woboq.com", "date": "2018-11-08T19:12:05Z"}, "committer": {"name": "Olivier Goffart", "email": "ogoffart@woboq.com", "date": "2018-11-13T10:24:00Z"}, "message": "Forward the ABI of the non-zero sized fields of an union if they have the same ABI\n\nThis is supposed to fix the performence regression of using MaybeUninit in\nhttps://github.com/rust-lang/rust/pull/54668", "tree": {"sha": "493c6dcdb5583f1f3d0efd8dfe5af0e30fbc336f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493c6dcdb5583f1f3d0efd8dfe5af0e30fbc336f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/562be7e1a1955742d61320d0855550794c4b6c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/562be7e1a1955742d61320d0855550794c4b6c22", "html_url": "https://github.com/rust-lang/rust/commit/562be7e1a1955742d61320d0855550794c4b6c22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/562be7e1a1955742d61320d0855550794c4b6c22/comments", "author": {"login": "ogoffart", "id": 959326, "node_id": "MDQ6VXNlcjk1OTMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/959326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ogoffart", "html_url": "https://github.com/ogoffart", "followers_url": "https://api.github.com/users/ogoffart/followers", "following_url": "https://api.github.com/users/ogoffart/following{/other_user}", "gists_url": "https://api.github.com/users/ogoffart/gists{/gist_id}", "starred_url": "https://api.github.com/users/ogoffart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ogoffart/subscriptions", "organizations_url": "https://api.github.com/users/ogoffart/orgs", "repos_url": "https://api.github.com/users/ogoffart/repos", "events_url": "https://api.github.com/users/ogoffart/events{/privacy}", "received_events_url": "https://api.github.com/users/ogoffart/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ogoffart", "id": 959326, "node_id": "MDQ6VXNlcjk1OTMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/959326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ogoffart", "html_url": "https://github.com/ogoffart", "followers_url": "https://api.github.com/users/ogoffart/followers", "following_url": "https://api.github.com/users/ogoffart/following{/other_user}", "gists_url": "https://api.github.com/users/ogoffart/gists{/gist_id}", "starred_url": "https://api.github.com/users/ogoffart/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ogoffart/subscriptions", "organizations_url": "https://api.github.com/users/ogoffart/orgs", "repos_url": "https://api.github.com/users/ogoffart/repos", "events_url": "https://api.github.com/users/ogoffart/events{/privacy}", "received_events_url": "https://api.github.com/users/ogoffart/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "485397e49a02a3b7ff77c17e4a3f16c653925cb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/485397e49a02a3b7ff77c17e4a3f16c653925cb3", "html_url": "https://github.com/rust-lang/rust/commit/485397e49a02a3b7ff77c17e4a3f16c653925cb3"}], "stats": {"total": 121, "additions": 120, "deletions": 1}, "files": [{"sha": "0b00cfc2d7fd42f71aaa18de0418413d8f349386", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/562be7e1a1955742d61320d0855550794c4b6c22/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562be7e1a1955742d61320d0855550794c4b6c22/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=562be7e1a1955742d61320d0855550794c4b6c22", "patch": "@@ -697,7 +697,9 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                             Align::from_bytes(repr_align, repr_align).unwrap());\n                     }\n \n+                    let optimize = !def.repr.inhibit_union_abi_opt();\n                     let mut size = Size::ZERO;\n+                    let mut abi = Abi::Aggregate { sized: true };\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n@@ -708,13 +710,44 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n                         } else {\n                             align = align.max(field.align);\n                         }\n+\n+                        // If all non-ZST fields have the same ABI, forward this ABI\n+                        if optimize && !field.is_zst() {\n+                            // Normalize scalar_unit to the maximal valid range\n+                            let field_abi = match &field.abi {\n+                                Abi::Scalar(x) => Abi::Scalar(scalar_unit(x.value)),\n+                                Abi::ScalarPair(x, y) => {\n+                                    Abi::ScalarPair(\n+                                        scalar_unit(x.value),\n+                                        scalar_unit(y.value),\n+                                    )\n+                                }\n+                                Abi::Vector { element: x, count } => {\n+                                    Abi::Vector {\n+                                        element: scalar_unit(x.value),\n+                                        count: *count,\n+                                    }\n+                                }\n+                                Abi::Uninhabited |\n+                                Abi::Aggregate { .. }  => Abi::Aggregate { sized: true },\n+                            };\n+\n+                            if size == Size::ZERO {\n+                                // first non ZST: initialize 'abi'\n+                                abi = field_abi;\n+                            } else if abi != field_abi  {\n+                                // different fields have different ABI: reset to Aggregate\n+                                abi = Abi::Aggregate { sized: true };\n+                            }\n+                        }\n+\n                         size = cmp::max(size, field.size);\n                     }\n \n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n-                        abi: Abi::Aggregate { sized: true },\n+                        abi,\n                         align,\n                         size: size.abi_align(align)\n                     }));"}, {"sha": "9553d1244837c3d75e06d6088696475cac0dbc70", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/562be7e1a1955742d61320d0855550794c4b6c22/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562be7e1a1955742d61320d0855550794c4b6c22/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=562be7e1a1955742d61320d0855550794c4b6c22", "patch": "@@ -1994,6 +1994,12 @@ impl ReprOptions {\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n         !(self.flags & ReprFlags::IS_UNOPTIMISABLE).is_empty() || (self.pack == 1)\n     }\n+\n+    /// Returns true if this `#[repr()]` should inhibit union abi optimisations\n+    pub fn inhibit_union_abi_opt(&self) -> bool {\n+        self.c()\n+    }\n+\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {"}, {"sha": "0fa06fa777b29010c400c9a108062afe5b8bb4dc", "filename": "src/test/codegen/union-abi.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/562be7e1a1955742d61320d0855550794c4b6c22/src%2Ftest%2Fcodegen%2Funion-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562be7e1a1955742d61320d0855550794c4b6c22/src%2Ftest%2Fcodegen%2Funion-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funion-abi.rs?ref=562be7e1a1955742d61320d0855550794c4b6c22", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// This test that using union forward the abi of the inner type, as\n+// discussed in #54668\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_simd)]\n+\n+#[derive(Copy, Clone)]\n+pub enum Unhab {}\n+\n+#[repr(simd)]\n+#[derive(Copy, Clone)]\n+pub struct i64x4(i64, i64, i64, i64);\n+\n+#[derive(Copy, Clone)]\n+pub union UnionI64x4{ a:(), b: i64x4 }\n+\n+// CHECK: define <4 x i64> @test_UnionI64x4(<4 x i64> %arg0)\n+#[no_mangle]\n+pub extern fn test_UnionI64x4(_: UnionI64x4) -> UnionI64x4 { loop {} }\n+\n+pub union UnionI64x4_{ a: i64x4, b: (), c:i64x4, d: Unhab, e: ((),()), f: UnionI64x4 }\n+\n+// CHECK: define <4 x i64> @test_UnionI64x4_(<4 x i64> %arg0)\n+#[no_mangle]\n+pub extern fn test_UnionI64x4_(_: UnionI64x4_) -> UnionI64x4_ { loop {} }\n+\n+pub union UnionI64x4I64{ a: i64x4, b: i64 }\n+\n+// CHECK: define void @test_UnionI64x4I64(%UnionI64x4I64* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4I64(_: UnionI64x4I64) { loop {} }\n+\n+pub union UnionI64x4Tuple{ a: i64x4, b: (i64, i64, i64, i64) }\n+\n+// CHECK: define void @test_UnionI64x4Tuple(%UnionI64x4Tuple* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_UnionI64x4Tuple(_: UnionI64x4Tuple) { loop {} }\n+\n+\n+pub union UnionF32{a:f32}\n+\n+// CHECK: define float @test_UnionF32(float %arg0)\n+#[no_mangle]\n+pub extern fn test_UnionF32(_: UnionF32) -> UnionF32 { loop {} }\n+\n+pub union UnionF32F32{a:f32, b:f32}\n+\n+// CHECK: define float @test_UnionF32F32(float %arg0)\n+#[no_mangle]\n+pub extern fn test_UnionF32F32(_: UnionF32F32) -> UnionF32F32 { loop {} }\n+\n+pub union UnionF32U32{a:f32, b:u32}\n+\n+// CHECK: define i32 @test_UnionF32U32(i32)\n+#[no_mangle]\n+pub extern fn test_UnionF32U32(_: UnionF32U32) -> UnionF32U32 { loop {} }\n+\n+pub union UnionU128{a:u128}\n+// CHECK: define i128 @test_UnionU128(i128 %arg0)\n+#[no_mangle]\n+pub fn test_UnionU128(_: UnionU128) -> UnionU128 { loop {} }\n+\n+#[repr(C)]\n+pub union CUnionU128{a:u128}\n+// CHECK: define void @test_CUnionU128(%CUnionU128* {{.*}} %arg0)\n+#[no_mangle]\n+pub fn test_CUnionU128(_: CUnionU128) { loop {} }\n+"}]}