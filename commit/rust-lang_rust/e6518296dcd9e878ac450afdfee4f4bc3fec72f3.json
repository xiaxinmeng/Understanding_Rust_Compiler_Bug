{"sha": "e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "node_id": "C_kwDOAAsO6NoAKGU2NTE4Mjk2ZGNkOWU4NzhhYzQ1MGFmZGZlZTRmNGJjM2ZlYzcyZjM", "commit": {"author": {"name": "A\u00efssata", "email": "aimaiga2@gmail.com", "date": "2022-07-25T13:54:49Z"}, "committer": {"name": "A\u00efssata", "email": "aimaiga2@gmail.com", "date": "2022-07-25T13:54:49Z"}, "message": "removed CanConstProp + Visitor", "tree": {"sha": "0707a1d01f47276a16cae01fb87030b50f5027c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0707a1d01f47276a16cae01fb87030b50f5027c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "html_url": "https://github.com/rust-lang/rust/commit/e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6518296dcd9e878ac450afdfee4f4bc3fec72f3/comments", "author": {"login": "Dajamante", "id": 40670675, "node_id": "MDQ6VXNlcjQwNjcwNjc1", "avatar_url": "https://avatars.githubusercontent.com/u/40670675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dajamante", "html_url": "https://github.com/Dajamante", "followers_url": "https://api.github.com/users/Dajamante/followers", "following_url": "https://api.github.com/users/Dajamante/following{/other_user}", "gists_url": "https://api.github.com/users/Dajamante/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dajamante/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dajamante/subscriptions", "organizations_url": "https://api.github.com/users/Dajamante/orgs", "repos_url": "https://api.github.com/users/Dajamante/repos", "events_url": "https://api.github.com/users/Dajamante/events{/privacy}", "received_events_url": "https://api.github.com/users/Dajamante/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Dajamante", "id": 40670675, "node_id": "MDQ6VXNlcjQwNjcwNjc1", "avatar_url": "https://avatars.githubusercontent.com/u/40670675?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dajamante", "html_url": "https://github.com/Dajamante", "followers_url": "https://api.github.com/users/Dajamante/followers", "following_url": "https://api.github.com/users/Dajamante/following{/other_user}", "gists_url": "https://api.github.com/users/Dajamante/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dajamante/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dajamante/subscriptions", "organizations_url": "https://api.github.com/users/Dajamante/orgs", "repos_url": "https://api.github.com/users/Dajamante/repos", "events_url": "https://api.github.com/users/Dajamante/events{/privacy}", "received_events_url": "https://api.github.com/users/Dajamante/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68b433a089deff105063feaad598a1635615eb1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/68b433a089deff105063feaad598a1635615eb1a", "html_url": "https://github.com/rust-lang/rust/commit/68b433a089deff105063feaad598a1635615eb1a"}], "stats": {"total": 132, "additions": 7, "deletions": 125}, "files": [{"sha": "85ad6b8f2feff052b70b19c74fb2a3244a1f5226", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6518296dcd9e878ac450afdfee4f4bc3fec72f3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6518296dcd9e878ac450afdfee4f4bc3fec72f3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "patch": "@@ -828,7 +828,7 @@ pub enum ConstPropMode {\n     NoPropagation,\n }\n \n-struct CanConstProp {\n+pub struct CanConstProp {\n     can_const_prop: IndexVec<Local, ConstPropMode>,\n     // False at the beginning. Once set, no more assignments are allowed to that local.\n     found_assignment: BitSet<Local>,\n@@ -838,7 +838,7 @@ struct CanConstProp {\n \n impl CanConstProp {\n     /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n+    pub fn check<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n         body: &Body<'tcx>,"}, {"sha": "3ae6a88a140ead840ecbe322b11078fa74ad0202", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 5, "deletions": 123, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e6518296dcd9e878ac450afdfee4f4bc3fec72f3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6518296dcd9e878ac450afdfee4f4bc3fec72f3/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=e6518296dcd9e878ac450afdfee4f4bc3fec72f3", "patch": "@@ -1,6 +1,7 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n+use crate::const_prop::CanConstProp;\n use crate::const_prop::ConstPropMachine;\n use crate::const_prop::ConstPropMode;\n use crate::MirLint;\n@@ -13,11 +14,11 @@ use rustc_hir::def::DefKind;\n use rustc_hir::HirId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n-use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n+use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{\n-    AssertKind, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, LocalKind, Location,\n-    Operand, Place, Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind,\n-    Terminator, TerminatorKind, UnOp, RETURN_PLACE,\n+    AssertKind, BinOp, Body, Constant, ConstantKind, Local, LocalDecl, Location, Operand, Place,\n+    Rvalue, SourceInfo, SourceScope, SourceScopeData, Statement, StatementKind, Terminator,\n+    TerminatorKind, UnOp, RETURN_PLACE,\n };\n use rustc_middle::ty::layout::{LayoutError, LayoutOf, LayoutOfHelpers, TyAndLayout};\n use rustc_middle::ty::subst::{InternalSubsts, Subst};\n@@ -522,125 +523,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     }\n }\n \n-struct CanConstProp {\n-    can_const_prop: IndexVec<Local, ConstPropMode>,\n-    // False at the beginning. Once set, no more assignments are allowed to that local.\n-    found_assignment: BitSet<Local>,\n-    // Cache of locals' information\n-    local_kinds: IndexVec<Local, LocalKind>,\n-}\n-\n-impl CanConstProp {\n-    /// Returns true if `local` can be propagated\n-    fn check<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n-        param_env: ParamEnv<'tcx>,\n-        body: &Body<'tcx>,\n-    ) -> IndexVec<Local, ConstPropMode> {\n-        let mut cpv = CanConstProp {\n-            can_const_prop: IndexVec::from_elem(ConstPropMode::FullConstProp, &body.local_decls),\n-            found_assignment: BitSet::new_empty(body.local_decls.len()),\n-            local_kinds: IndexVec::from_fn_n(\n-                |local| body.local_kind(local),\n-                body.local_decls.len(),\n-            ),\n-        };\n-        for (local, val) in cpv.can_const_prop.iter_enumerated_mut() {\n-            let ty = body.local_decls[local].ty;\n-            match tcx.layout_of(param_env.and(ty)) {\n-                Ok(layout) if layout.size < Size::from_bytes(MAX_ALLOC_LIMIT) => {}\n-                // Either the layout fails to compute, then we can't use this local anyway\n-                // or the local is too large, then we don't want to.\n-                _ => {\n-                    *val = ConstPropMode::NoPropagation;\n-                    continue;\n-                }\n-            }\n-            // Cannot use args at all\n-            // Cannot use locals because if x < y { y - x } else { x - y } would\n-            //        lint for x != y\n-            // FIXME(oli-obk): lint variables until they are used in a condition\n-            // FIXME(oli-obk): lint if return value is constant\n-            if cpv.local_kinds[local] == LocalKind::Arg {\n-                *val = ConstPropMode::OnlyPropagateInto;\n-                trace!(\n-                    \"local {:?} can't be const propagated because it's a function argument\",\n-                    local\n-                );\n-            } else if cpv.local_kinds[local] == LocalKind::Var {\n-                *val = ConstPropMode::OnlyInsideOwnBlock;\n-                trace!(\n-                    \"local {:?} will only be propagated inside its block, because it's a user variable\",\n-                    local\n-                );\n-            }\n-        }\n-        cpv.visit_body(&body);\n-        cpv.can_const_prop\n-    }\n-}\n-\n-impl Visitor<'_> for CanConstProp {\n-    fn visit_local(&mut self, local: Local, context: PlaceContext, _: Location) {\n-        use rustc_middle::mir::visit::PlaceContext::*;\n-        match context {\n-            // Projections are fine, because `&mut foo.x` will be caught by\n-            // `MutatingUseContext::Borrow` elsewhere.\n-            MutatingUse(MutatingUseContext::Projection)\n-            // These are just stores, where the storing is not propagatable, but there may be later\n-            // mutations of the same local via `Store`\n-            | MutatingUse(MutatingUseContext::Call)\n-            | MutatingUse(MutatingUseContext::AsmOutput)\n-            | MutatingUse(MutatingUseContext::Deinit)\n-            // Actual store that can possibly even propagate a value\n-            | MutatingUse(MutatingUseContext::SetDiscriminant)\n-            | MutatingUse(MutatingUseContext::Store) => {\n-                if !self.found_assignment.insert(local) {\n-                    match &mut self.can_const_prop[local] {\n-                        // If the local can only get propagated in its own block, then we don't have\n-                        // to worry about multiple assignments, as we'll nuke the const state at the\n-                        // end of the block anyway, and inside the block we overwrite previous\n-                        // states as applicable.\n-                        ConstPropMode::OnlyInsideOwnBlock => {}\n-                        ConstPropMode::NoPropagation => {}\n-                        ConstPropMode::OnlyPropagateInto => {}\n-                        other @ ConstPropMode::FullConstProp => {\n-                            trace!(\n-                                \"local {:?} can't be propagated because of multiple assignments. Previous state: {:?}\",\n-                                local, other,\n-                            );\n-                            *other = ConstPropMode::OnlyInsideOwnBlock;\n-                        }\n-                    }\n-                }\n-            }\n-            // Reading constants is allowed an arbitrary number of times\n-            NonMutatingUse(NonMutatingUseContext::Copy)\n-            | NonMutatingUse(NonMutatingUseContext::Move)\n-            | NonMutatingUse(NonMutatingUseContext::Inspect)\n-            | NonMutatingUse(NonMutatingUseContext::Projection)\n-            | NonUse(_) => {}\n-\n-            // These could be propagated with a smarter analysis or just some careful thinking about\n-            // whether they'd be fine right now.\n-            MutatingUse(MutatingUseContext::Yield)\n-            | MutatingUse(MutatingUseContext::Drop)\n-            | MutatingUse(MutatingUseContext::Retag)\n-            // These can't ever be propagated under any scheme, as we can't reason about indirect\n-            // mutation.\n-            | NonMutatingUse(NonMutatingUseContext::SharedBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::ShallowBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::UniqueBorrow)\n-            | NonMutatingUse(NonMutatingUseContext::AddressOf)\n-            | MutatingUse(MutatingUseContext::Borrow)\n-            | MutatingUse(MutatingUseContext::AddressOf) => {\n-                trace!(\"local {:?} can't be propagaged because it's used: {:?}\", local, context);\n-                self.can_const_prop[local] = ConstPropMode::NoPropagation;\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for ConstPropagator<'_, 'tcx> {\n     fn visit_body(&mut self, body: &Body<'tcx>) {\n         for (bb, data) in body.basic_blocks().iter_enumerated() {"}]}