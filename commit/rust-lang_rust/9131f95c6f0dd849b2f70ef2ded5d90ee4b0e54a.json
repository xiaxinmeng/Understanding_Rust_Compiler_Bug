{"sha": "9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMzFmOTVjNmYwZGQ4NDliMmY3MGVmMmRlZDVkOTBlZTRiMGU1NGE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:56:10Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-14T23:56:10Z"}, "message": "typeck/expr.rs: extract out check_expr_path.", "tree": {"sha": "1f24d03f3eb9878121b00477d0aa1bd271e6585d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f24d03f3eb9878121b00477d0aa1bd271e6585d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "html_url": "https://github.com/rust-lang/rust/commit/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5cc080b738f25529200f7928bdad0b06011490d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5cc080b738f25529200f7928bdad0b06011490d", "html_url": "https://github.com/rust-lang/rust/commit/d5cc080b738f25529200f7928bdad0b06011490d"}], "stats": {"total": 119, "additions": 61, "deletions": 58}, "files": [{"sha": "cb626da0294bbf052f940f7d6ad7c188a33cd520", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 61, "deletions": 58, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=9131f95c6f0dd849b2f70ef2ded5d90ee4b0e54a", "patch": "@@ -47,7 +47,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n \n         let tcx = self.tcx;\n-        let id = expr.hir_id;\n         match expr.node {\n             ExprKind::Box(ref subexpr) => {\n                 self.check_expr_box(subexpr, expected)\n@@ -68,63 +67,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_expr_addr_of(mutbl, oprnd, expected, expr)\n             }\n             ExprKind::Path(ref qpath) => {\n-                let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id,\n-                    expr.span);\n-                let ty = match res {\n-                    Res::Err => {\n-                        self.set_tainted_by_errors();\n-                        tcx.types.err\n-                    }\n-                    Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                        report_unexpected_variant_res(tcx, res, expr.span, qpath);\n-                        tcx.types.err\n-                    }\n-                    _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, id).0,\n-                };\n-\n-                if let ty::FnDef(..) = ty.sty {\n-                    let fn_sig = ty.fn_sig(tcx);\n-                    if !tcx.features().unsized_locals {\n-                        // We want to remove some Sized bounds from std functions,\n-                        // but don't want to expose the removal to stable Rust.\n-                        // i.e., we don't want to allow\n-                        //\n-                        // ```rust\n-                        // drop as fn(str);\n-                        // ```\n-                        //\n-                        // to work in stable even if the Sized bound on `drop` is relaxed.\n-                        for i in 0..fn_sig.inputs().skip_binder().len() {\n-                            // We just want to check sizedness, so instead of introducing\n-                            // placeholder lifetimes with probing, we just replace higher lifetimes\n-                            // with fresh vars.\n-                            let input = self.replace_bound_vars_with_fresh_vars(\n-                                expr.span,\n-                                infer::LateBoundRegionConversionTime::FnCall,\n-                                &fn_sig.input(i)).0;\n-                            self.require_type_is_sized_deferred(input, expr.span,\n-                                                                traits::SizedArgumentType);\n-                        }\n-                    }\n-                    // Here we want to prevent struct constructors from returning unsized types.\n-                    // There were two cases this happened: fn pointer coercion in stable\n-                    // and usual function call in presense of unsized_locals.\n-                    // Also, as we just want to check sizedness, instead of introducing\n-                    // placeholder lifetimes with probing, we just replace higher lifetimes\n-                    // with fresh vars.\n-                    let output = self.replace_bound_vars_with_fresh_vars(\n-                        expr.span,\n-                        infer::LateBoundRegionConversionTime::FnCall,\n-                        &fn_sig.output()).0;\n-                    self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n-                }\n-\n-                // We always require that the type provided as the value for\n-                // a type parameter outlives the moment of instantiation.\n-                let substs = self.tables.borrow().node_substs(expr.hir_id);\n-                self.add_wf_bounds(substs, expr);\n-\n-                ty\n+                self.check_expr_path(qpath, expr)\n             }\n             ExprKind::InlineAsm(_, ref outputs, ref inputs) => {\n                 for expr in outputs.iter().chain(inputs.iter()) {\n@@ -722,4 +665,64 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tcx.mk_ref(region, tm)\n         }\n     }\n+\n+    fn check_expr_path(&self, qpath: &hir::QPath, expr: &'tcx hir::Expr) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n+        let ty = match res {\n+            Res::Err => {\n+                self.set_tainted_by_errors();\n+                tcx.types.err\n+            }\n+            Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n+                report_unexpected_variant_res(tcx, res, expr.span, qpath);\n+                tcx.types.err\n+            }\n+            _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n+        };\n+\n+        if let ty::FnDef(..) = ty.sty {\n+            let fn_sig = ty.fn_sig(tcx);\n+            if !tcx.features().unsized_locals {\n+                // We want to remove some Sized bounds from std functions,\n+                // but don't want to expose the removal to stable Rust.\n+                // i.e., we don't want to allow\n+                //\n+                // ```rust\n+                // drop as fn(str);\n+                // ```\n+                //\n+                // to work in stable even if the Sized bound on `drop` is relaxed.\n+                for i in 0..fn_sig.inputs().skip_binder().len() {\n+                    // We just want to check sizedness, so instead of introducing\n+                    // placeholder lifetimes with probing, we just replace higher lifetimes\n+                    // with fresh vars.\n+                    let input = self.replace_bound_vars_with_fresh_vars(\n+                        expr.span,\n+                        infer::LateBoundRegionConversionTime::FnCall,\n+                        &fn_sig.input(i)).0;\n+                    self.require_type_is_sized_deferred(input, expr.span,\n+                                                        traits::SizedArgumentType);\n+                }\n+            }\n+            // Here we want to prevent struct constructors from returning unsized types.\n+            // There were two cases this happened: fn pointer coercion in stable\n+            // and usual function call in presense of unsized_locals.\n+            // Also, as we just want to check sizedness, instead of introducing\n+            // placeholder lifetimes with probing, we just replace higher lifetimes\n+            // with fresh vars.\n+            let output = self.replace_bound_vars_with_fresh_vars(\n+                expr.span,\n+                infer::LateBoundRegionConversionTime::FnCall,\n+                &fn_sig.output()).0;\n+            self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n+        }\n+\n+        // We always require that the type provided as the value for\n+        // a type parameter outlives the moment of instantiation.\n+        let substs = self.tables.borrow().node_substs(expr.hir_id);\n+        self.add_wf_bounds(substs, expr);\n+\n+        ty\n+    }\n }"}]}