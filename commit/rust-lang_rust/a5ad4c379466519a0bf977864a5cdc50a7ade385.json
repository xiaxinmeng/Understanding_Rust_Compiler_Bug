{"sha": "a5ad4c379466519a0bf977864a5cdc50a7ade385", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1YWQ0YzM3OTQ2NjUxOWEwYmY5Nzc4NjRhNWNkYzUwYTdhZGUzODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-09-07T02:11:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-09-10T09:45:12Z"}, "message": "Delay assignment of node ids until after expansion. Ensures that each AST node\nhas a unique id. Fixes numerous bugs in macro expansion and deriving. Add two\nrepresentative tests.\n\nFixes #7971\nFixes #6304\nFixes #8367\nFixes #8754\nFixes #8852\nFixes #2543\nFixes #7654", "tree": {"sha": "177576d6ff2d94006334872769bbe760933b8d27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/177576d6ff2d94006334872769bbe760933b8d27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5ad4c379466519a0bf977864a5cdc50a7ade385", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ad4c379466519a0bf977864a5cdc50a7ade385", "html_url": "https://github.com/rust-lang/rust/commit/a5ad4c379466519a0bf977864a5cdc50a7ade385", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5ad4c379466519a0bf977864a5cdc50a7ade385/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed695d470bf1568b896f2944815f4723905ab66e", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed695d470bf1568b896f2944815f4723905ab66e", "html_url": "https://github.com/rust-lang/rust/commit/ed695d470bf1568b896f2944815f4723905ab66e"}], "stats": {"total": 916, "additions": 532, "deletions": 384}, "files": [{"sha": "0fd93d65b70b8dcdfc15d459288341ca853ed478", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -190,6 +190,9 @@ pub fn phase_2_configure_and_expand(sess: Session,\n     crate = time(time_passes, ~\"std injection\", ||\n                  front::std_inject::maybe_inject_libstd_ref(sess, crate));\n \n+    crate = time(time_passes, ~\"assigning node ids\", ||\n+                 front::assign_node_ids::assign_node_ids(sess, crate));\n+\n     return crate;\n }\n \n@@ -207,6 +210,7 @@ pub fn phase_3_run_analysis_passes(sess: Session,\n                                    crate: @ast::Crate) -> CrateAnalysis {\n \n     let time_passes = sess.time_passes();\n+\n     let ast_map = time(time_passes, ~\"ast indexing\", ||\n                        syntax::ast_map::map_crate(sess.diagnostic(), crate));\n \n@@ -812,6 +816,7 @@ pub fn build_session_(sopts: @session::options,\n         building_library: @mut false,\n         working_dir: os::getcwd(),\n         lints: @mut HashMap::new(),\n+        node_id: @mut 1\n     }\n }\n "}, {"sha": "7f3f1f88a5244f59da81544c88ff3fc7fb290404", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 56, "deletions": 46, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -28,6 +28,7 @@ use syntax::abi;\n use syntax::parse::token;\n use syntax;\n \n+use std::int;\n use std::hashmap::HashMap;\n \n #[deriving(Eq)]\n@@ -216,57 +217,58 @@ pub struct Session_ {\n     building_library: @mut bool,\n     working_dir: Path,\n     lints: @mut HashMap<ast::NodeId, ~[(lint::lint, codemap::Span, ~str)]>,\n+    node_id: @mut uint,\n }\n \n pub type Session = @Session_;\n \n impl Session_ {\n-    pub fn span_fatal(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_fatal(&self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    pub fn fatal(@self, msg: &str) -> ! {\n+    pub fn fatal(&self, msg: &str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    pub fn span_err(@self, sp: Span, msg: &str) {\n+    pub fn span_err(&self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    pub fn err(@self, msg: &str) {\n+    pub fn err(&self, msg: &str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n-    pub fn err_count(@self) -> uint {\n+    pub fn err_count(&self) -> uint {\n         self.span_diagnostic.handler().err_count()\n     }\n-    pub fn has_errors(@self) -> bool {\n+    pub fn has_errors(&self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n-    pub fn abort_if_errors(@self) {\n+    pub fn abort_if_errors(&self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    pub fn span_warn(@self, sp: Span, msg: &str) {\n+    pub fn span_warn(&self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    pub fn warn(@self, msg: &str) {\n+    pub fn warn(&self, msg: &str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    pub fn span_note(@self, sp: Span, msg: &str) {\n+    pub fn span_note(&self, sp: Span, msg: &str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    pub fn note(@self, msg: &str) {\n+    pub fn note(&self, msg: &str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    pub fn span_bug(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_bug(&self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    pub fn bug(@self, msg: &str) -> ! {\n+    pub fn bug(&self, msg: &str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    pub fn span_unimpl(@self, sp: Span, msg: &str) -> ! {\n+    pub fn span_unimpl(&self, sp: Span, msg: &str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    pub fn unimpl(@self, msg: &str) -> ! {\n+    pub fn unimpl(&self, msg: &str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    pub fn add_lint(@self,\n+    pub fn add_lint(&self,\n                     lint: lint::lint,\n                     id: ast::NodeId,\n                     sp: Span,\n@@ -277,77 +279,85 @@ impl Session_ {\n         }\n         self.lints.insert(id, ~[(lint, sp, msg)]);\n     }\n-    pub fn next_node_id(@self) -> ast::NodeId {\n-        return syntax::parse::next_node_id(self.parse_sess);\n+    pub fn next_node_id(&self) -> ast::NodeId {\n+        self.reserve_node_ids(1)\n     }\n-    pub fn diagnostic(@self) -> @mut diagnostic::span_handler {\n+    pub fn reserve_node_ids(&self, count: uint) -> ast::NodeId {\n+        let v = *self.node_id;\n+        *self.node_id += count;\n+        if v > (int::max_value as uint) {\n+            self.bug(\"Input too large, ran out of node ids!\");\n+        }\n+        v as int\n+    }\n+    pub fn diagnostic(&self) -> @mut diagnostic::span_handler {\n         self.span_diagnostic\n     }\n-    pub fn debugging_opt(@self, opt: uint) -> bool {\n+    pub fn debugging_opt(&self, opt: uint) -> bool {\n         (self.opts.debugging_opts & opt) != 0u\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    pub fn impossible_case(@self, sp: Span, msg: &str) -> ! {\n+    pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n-    pub fn verbose(@self) -> bool { self.debugging_opt(verbose) }\n-    pub fn time_passes(@self) -> bool { self.debugging_opt(time_passes) }\n-    pub fn count_llvm_insns(@self) -> bool {\n+    pub fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n+    pub fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }\n+    pub fn count_llvm_insns(&self) -> bool {\n         self.debugging_opt(count_llvm_insns)\n     }\n-    pub fn count_type_sizes(@self) -> bool {\n+    pub fn count_type_sizes(&self) -> bool {\n         self.debugging_opt(count_type_sizes)\n     }\n-    pub fn time_llvm_passes(@self) -> bool {\n+    pub fn time_llvm_passes(&self) -> bool {\n         self.debugging_opt(time_llvm_passes)\n     }\n-    pub fn trans_stats(@self) -> bool { self.debugging_opt(trans_stats) }\n-    pub fn meta_stats(@self) -> bool { self.debugging_opt(meta_stats) }\n-    pub fn asm_comments(@self) -> bool { self.debugging_opt(asm_comments) }\n-    pub fn no_verify(@self) -> bool { self.debugging_opt(no_verify) }\n-    pub fn lint_llvm(@self) -> bool { self.debugging_opt(lint_llvm) }\n-    pub fn trace(@self) -> bool { self.debugging_opt(trace) }\n-    pub fn coherence(@self) -> bool { self.debugging_opt(coherence) }\n-    pub fn borrowck_stats(@self) -> bool { self.debugging_opt(borrowck_stats) }\n-    pub fn borrowck_note_pure(@self) -> bool {\n+    pub fn trans_stats(&self) -> bool { self.debugging_opt(trans_stats) }\n+    pub fn meta_stats(&self) -> bool { self.debugging_opt(meta_stats) }\n+    pub fn asm_comments(&self) -> bool { self.debugging_opt(asm_comments) }\n+    pub fn no_verify(&self) -> bool { self.debugging_opt(no_verify) }\n+    pub fn lint_llvm(&self) -> bool { self.debugging_opt(lint_llvm) }\n+    pub fn trace(&self) -> bool { self.debugging_opt(trace) }\n+    pub fn coherence(&self) -> bool { self.debugging_opt(coherence) }\n+    pub fn borrowck_stats(&self) -> bool { self.debugging_opt(borrowck_stats) }\n+    pub fn borrowck_note_pure(&self) -> bool {\n         self.debugging_opt(borrowck_note_pure)\n     }\n-    pub fn borrowck_note_loan(@self) -> bool {\n+    pub fn borrowck_note_loan(&self) -> bool {\n         self.debugging_opt(borrowck_note_loan)\n     }\n-    pub fn no_monomorphic_collapse(@self) -> bool {\n+    pub fn no_monomorphic_collapse(&self) -> bool {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n-    pub fn debug_borrows(@self) -> bool {\n+    pub fn debug_borrows(&self) -> bool {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n-    pub fn once_fns(@self) -> bool { self.debugging_opt(once_fns) }\n-    pub fn print_llvm_passes(@self) -> bool {\n+    pub fn once_fns(&self) -> bool { self.debugging_opt(once_fns) }\n+    pub fn print_llvm_passes(&self) -> bool {\n         self.debugging_opt(print_llvm_passes)\n     }\n-    pub fn no_prepopulate_passes(@self) -> bool {\n+    pub fn no_prepopulate_passes(&self) -> bool {\n         self.debugging_opt(no_prepopulate_passes)\n     }\n-    pub fn no_vectorize_loops(@self) -> bool {\n+    pub fn no_vectorize_loops(&self) -> bool {\n         self.debugging_opt(no_vectorize_loops)\n     }\n-    pub fn no_vectorize_slp(@self) -> bool {\n+    pub fn no_vectorize_slp(&self) -> bool {\n         self.debugging_opt(no_vectorize_slp)\n     }\n \n     // pointless function, now...\n-    pub fn str_of(@self, id: ast::Ident) -> @str {\n+    pub fn str_of(&self, id: ast::Ident) -> @str {\n         token::ident_to_str(&id)\n     }\n \n     // pointless function, now...\n-    pub fn ident_of(@self, st: &str) -> ast::Ident {\n+    pub fn ident_of(&self, st: &str) -> ast::Ident {\n         token::str_to_ident(st)\n     }\n \n     // pointless function, now...\n-    pub fn intr(@self) -> @syntax::parse::token::ident_interner {\n+    pub fn intr(&self) -> @syntax::parse::token::ident_interner {\n         token::get_ident_interner()\n     }\n }"}, {"sha": "446db5c35e9b8bf44d06b7bdf6640604ce70900f", "filename": "src/librustc/front/assign_node_ids.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fassign_node_ids.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use driver::session::Session;\n+\n+use syntax::ast;\n+use syntax::ast_util;\n+\n+pub fn assign_node_ids(sess: Session, crate: @ast::Crate) -> @ast::Crate {\n+    let fold = ast_util::node_id_assigner(|| sess.next_node_id());\n+    @fold.fold_crate(crate)\n+}"}, {"sha": "d685b8a3e766765bfc7e025d30387eacd73329ff", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -45,7 +45,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n \n     let precursor = @fold::AstFoldFns {\n         fold_crate: |crate, fld| {\n-            let n1 = sess.next_node_id();\n+            let n1 = ast::DUMMY_NODE_ID;\n             let vi1 = ast::view_item {\n                 node: ast::view_item_extern_mod(\n                         sess.ident_of(\"std\"), None, ~[], n1),\n@@ -86,7 +86,7 @@ fn inject_libstd_ref(sess: Session, crate: &ast::Crate) -> @ast::Crate {\n             }\n         },\n         fold_mod: |module, fld| {\n-            let n2 = sess.next_node_id();\n+            let n2 = ast::DUMMY_NODE_ID;\n \n             let prelude_path = ast::Path {\n                 span: dummy_sp(),"}, {"sha": "9c7880651337a8ff8236d3a9382de122ccf5cfad", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -280,10 +280,10 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n         ast::view_item_use(\n             ~[@nospan(ast::view_path_simple(id_extra,\n                                             path_node(~[id_extra]),\n-                                            cx.sess.next_node_id()))])\n+                                            ast::DUMMY_NODE_ID))])\n     } else {\n         let mi = attr::mk_name_value_item_str(@\"vers\", @\"0.8-pre\");\n-        ast::view_item_extern_mod(id_extra, None, ~[mi], cx.sess.next_node_id())\n+        ast::view_item_extern_mod(id_extra, None, ~[mi], ast::DUMMY_NODE_ID)\n     };\n     ast::view_item {\n         node: vi,\n@@ -325,7 +325,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     let item = ast::item {\n         ident: cx.sess.ident_of(\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n-        id: cx.sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n@@ -367,7 +367,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n     let item = ast::item {\n         ident: cx.sess.ident_of(\"__test\"),\n         attrs: ~[resolve_unexported_attr],\n-        id: cx.sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: item_,\n         vis: ast::public,\n         span: dummy_sp(),\n@@ -448,15 +448,14 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::Expr {\n         descs.push(mk_test_desc_and_fn_rec(cx, test));\n     }\n \n-    let sess = cx.sess;\n     let inner_expr = @ast::Expr {\n-        id: sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprVec(descs, ast::MutImmutable),\n         span: dummy_sp(),\n     };\n \n     @ast::Expr {\n-        id: sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprVstore(inner_expr, ast::ExprVstoreSlice),\n         span: dummy_sp(),\n     }\n@@ -475,15 +474,15 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n     let name_expr = @ast::Expr {\n-          id: cx.sess.next_node_id(),\n+          id: ast::DUMMY_NODE_ID,\n           node: ast::ExprLit(@name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n     let fn_expr = @ast::Expr {\n-        id: cx.sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(fn_path),\n         span: span,\n     };\n@@ -529,15 +528,15 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::Expr {\n         nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n     let name_expr = @ast::Expr {\n-          id: cx.sess.next_node_id(),\n+          id: ast::DUMMY_NODE_ID,\n           node: ast::ExprLit(@name_lit),\n           span: span\n     };\n \n     let fn_path = path_node_global(path);\n \n     let fn_expr = @ast::Expr {\n-        id: cx.sess.next_node_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(fn_path),\n         span: span,\n     };"}, {"sha": "b6ccda5e1d1cab9a100df6725f9ba3f83f95ea13", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -157,10 +157,10 @@ fn reserve_id_range(sess: Session,\n     // Handle the case of an empty range:\n     if from_id_range.empty() { return from_id_range; }\n     let cnt = from_id_range.max - from_id_range.min;\n-    let to_id_min = sess.parse_sess.next_id;\n-    let to_id_max = sess.parse_sess.next_id + cnt;\n-    sess.parse_sess.next_id = to_id_max;\n-    ast_util::id_range { min: to_id_min, max: to_id_min }\n+    assert!(cnt >= 0);\n+    let to_id_min = sess.reserve_node_ids(cnt as uint);\n+    let to_id_max = to_id_min + cnt;\n+    ast_util::id_range { min: to_id_min, max: to_id_max }\n }\n \n impl ExtendedDecodeContext {"}, {"sha": "f1d3ecf69e1c0db1b3b28583ae8ab195d40581dc", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -5403,7 +5403,15 @@ impl Resolver {\n \n     pub fn record_def(@mut self, node_id: NodeId, def: Def) {\n         debug!(\"(recording def) recording %? for %?\", def, node_id);\n-        self.def_map.insert(node_id, def);\n+        do self.def_map.insert_or_update_with(node_id, def) |_, old_value| {\n+            // Resolve appears to \"resolve\" the same ID multiple\n+            // times, so here is a sanity check it at least comes to\n+            // the same conclusion! - nmatsakis\n+            if def != *old_value {\n+                self.session.bug(fmt!(\"node_id %? resolved first to %? \\\n+                                      and then %?\", node_id, *old_value, def));\n+            }\n+        };\n     }\n \n     pub fn enforce_default_binding_mode(@mut self,"}, {"sha": "61d00dff584657bb252a9808c9bec57e75fffbaa", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -45,7 +45,6 @@ use syntax::ast_util::{def_id_of_def, local_def};\n use syntax::codemap::Span;\n use syntax::opt_vec;\n use syntax::visit;\n-use syntax::parse;\n \n use std::hashmap::HashSet;\n use std::result::Ok;\n@@ -334,7 +333,7 @@ impl CoherenceChecker {\n         let provided = ty::provided_trait_methods(tcx, trait_ref.def_id);\n         for trait_method in provided.iter() {\n             // Synthesize an ID.\n-            let new_id = parse::next_node_id(tcx.sess.parse_sess);\n+            let new_id = tcx.sess.next_node_id();\n             let new_did = local_def(new_id);\n \n             debug!(\"new_did=%? trait_method=%s\", new_did, trait_method.repr(tcx));"}, {"sha": "adf11a9fa21205e8a934022cf193d247bed09a8e", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -80,6 +80,7 @@ pub mod front {\n     pub mod config;\n     pub mod test;\n     pub mod std_inject;\n+    pub mod assign_node_ids;\n }\n \n pub mod back {"}, {"sha": "b2b7599aae3a79704c124f2991a3be36d0561f68", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -29,6 +29,7 @@ use rustc::driver::session::{basic_options, options};\n use rustc::front;\n use syntax::ast;\n use syntax::ast_map;\n+use syntax::ast_util;\n use syntax;\n \n pub struct Ctxt {\n@@ -108,6 +109,16 @@ pub fn exec<T:Send>(\n     po.recv()\n }\n \n+fn assign_node_ids(crate: @ast::Crate) -> @ast::Crate {\n+    let next_id = @mut 0;\n+    let fold = ast_util::node_id_assigner(|| {\n+            let i = *next_id;\n+            *next_id += 1;\n+            i\n+        });\n+    @fold.fold_crate(crate)\n+}\n+\n fn build_ctxt(sess: Session,\n               ast: @ast::Crate) -> Ctxt {\n \n@@ -121,6 +132,7 @@ fn build_ctxt(sess: Session,\n                                                 sess.opts.cfg.clone(),\n                                                 ast);\n     let ast = front::test::modify_for_testing(sess, ast);\n+    let ast = assign_node_ids(ast);\n     let ast_map = ast_map::map_crate(sess.diagnostic(), ast);\n \n     Ctxt {"}, {"sha": "2e7c73d34215eafb33347b4b65a1f56d7ec47a19", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -281,6 +281,7 @@ mod test {\n     fn should_extract_enum_docs() {\n         let doc = mk_doc(~\"#[doc = \\\"b\\\"]\\\n                                  enum a { v }\");\n+        debug!(\"%?\", doc);\n         assert!(doc.cratemod().enums()[0].desc() == Some(~\"b\"));\n     }\n "}, {"sha": "2ab0530ccb3c3b59e580c90fdc2d9d9f84043b48", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -285,6 +285,7 @@ mod test {\n \n     fn mk_doc(source: @str) -> doc::Doc {\n         let ast = parse::from_str(source);\n+        debug!(\"ast=%?\", ast);\n         extract(ast, ~\"\")\n     }\n "}, {"sha": "a32e84464cb663796462f339554108d62b6ace41", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -187,6 +187,11 @@ pub struct DefId {\n pub static LOCAL_CRATE: CrateNum = 0;\n pub static CRATE_NODE_ID: NodeId = 0;\n \n+// When parsing and doing expansions, we initially give all AST nodes this AST\n+// node value. Then later, in the renumber pass, we renumber them to have\n+// small, positive ids.\n+pub static DUMMY_NODE_ID: NodeId = -1;\n+\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and"}, {"sha": "311e10fc11106c135952915cdbfe257f34e6e7e6", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -12,6 +12,7 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{Span, dummy_sp};\n+use fold;\n use opt_vec;\n use parse::token;\n use visit::{SimpleVisitor, SimpleVisitorVisitor, Visitor};\n@@ -370,6 +371,21 @@ pub fn empty_generics() -> Generics {\n               ty_params: opt_vec::Empty}\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Assigning node ids\n+\n+fn node_id_assigner(next_id: @fn() -> ast::NodeId) -> @fold::ast_fold {\n+    let precursor = @fold::AstFoldFns {\n+        new_id: |old_id| {\n+            assert_eq!(old_id, ast::DUMMY_NODE_ID);\n+            next_id()\n+        },\n+        ..*fold::default_ast_fold()\n+    };\n+\n+    fold::make_fold(precursor)\n+}\n+\n // ______________________________________________________________________\n // Enumerating the IDs which appear in an AST\n "}, {"sha": "b350ef7bb08079a1095f902f9b2f7aeb888d82dd", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -76,7 +76,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                     p.expect(&token::RPAREN);\n \n                     let out = @ast::Expr {\n-                        id: cx.next_id(),\n+                        id: ast::DUMMY_NODE_ID,\n                         span: out.span,\n                         node: ast::ExprAddrOf(ast::MutMutable, out)\n                     };\n@@ -172,7 +172,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     }\n \n     MRExpr(@ast::Expr {\n-        id: cx.next_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprInlineAsm(ast::inline_asm {\n             asm: asm,\n             clobbers: cons.to_managed(),"}, {"sha": "48a1364668688a58c24937d8e1aa2478eb6f6395", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -319,9 +319,6 @@ impl ExtCtxt {\n         self.print_backtrace();\n         self.parse_sess.span_diagnostic.handler().bug(msg);\n     }\n-    pub fn next_id(&self) -> ast::NodeId {\n-        parse::next_node_id(self.parse_sess)\n-    }\n     pub fn trace_macros(&self) -> bool {\n         *self.trace_mac\n     }"}, {"sha": "6cb5a93a3131bf46610223cae636e244bd28b917", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 24, "deletions": 48, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -13,7 +13,6 @@ use ast::Ident;\n use ast;\n use ast_util;\n use codemap::{Span, respan, dummy_sp};\n-use fold;\n use ext::base::ExtCtxt;\n use ext::quote::rt::*;\n use opt_vec;\n@@ -277,7 +276,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn ty(&self, span: Span, ty: ast::ty_) -> ast::Ty {\n         ast::Ty {\n-            id: self.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: span,\n             node: ty\n         }\n@@ -286,7 +285,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n               -> ast::Ty {\n         self.ty(path.span,\n-                ast::ty_path(path, bounds, self.next_id()))\n+                ast::ty_path(path, bounds, ast::DUMMY_NODE_ID))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n@@ -340,14 +339,14 @@ impl AstBuilder for @ExtCtxt {\n \n     fn ty_nil(&self) -> ast::Ty {\n         ast::Ty {\n-            id: self.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: ast::ty_nil,\n             span: dummy_sp(),\n         }\n     }\n \n     fn typaram(&self, id: ast::Ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam {\n-        ast::TyParam { ident: id, id: self.next_id(), bounds: bounds }\n+        ast::TyParam { ident: id, id: ast::DUMMY_NODE_ID, bounds: bounds }\n     }\n \n     // these are strange, and probably shouldn't be used outside of\n@@ -377,7 +376,7 @@ impl AstBuilder for @ExtCtxt {\n     fn trait_ref(&self, path: ast::Path) -> ast::trait_ref {\n         ast::trait_ref {\n             path: path,\n-            ref_id: self.next_id()\n+            ref_id: ast::DUMMY_NODE_ID\n         }\n     }\n \n@@ -386,11 +385,11 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     fn lifetime(&self, span: Span, ident: ast::Ident) -> ast::Lifetime {\n-        ast::Lifetime { id: self.next_id(), span: span, ident: ident }\n+        ast::Lifetime { id: ast::DUMMY_NODE_ID, span: span, ident: ident }\n     }\n \n     fn stmt_expr(&self, expr: @ast::Expr) -> @ast::Stmt {\n-        @respan(expr.span, ast::StmtSemi(expr, self.next_id()))\n+        @respan(expr.span, ast::StmtSemi(expr, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let(&self, sp: Span, mutbl: bool, ident: ast::Ident, ex: @ast::Expr) -> @ast::Stmt {\n@@ -400,11 +399,11 @@ impl AstBuilder for @ExtCtxt {\n             ty: self.ty_infer(sp),\n             pat: pat,\n             init: Some(ex),\n-            id: self.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: sp,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, self.next_id()))\n+        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n     }\n \n     fn stmt_let_typed(&self,\n@@ -420,11 +419,11 @@ impl AstBuilder for @ExtCtxt {\n             ty: typ,\n             pat: pat,\n             init: Some(ex),\n-            id: self.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: sp,\n         };\n         let decl = respan(sp, ast::DeclLocal(local));\n-        @respan(sp, ast::StmtDecl(@decl, self.next_id()))\n+        @respan(sp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID))\n     }\n \n     fn block(&self, span: Span, stmts: ~[@ast::Stmt], expr: Option<@Expr>) -> ast::Block {\n@@ -443,15 +442,15 @@ impl AstBuilder for @ExtCtxt {\n                view_items: view_items,\n                stmts: stmts,\n                expr: expr,\n-               id: self.next_id(),\n+               id: ast::DUMMY_NODE_ID,\n                rules: ast::DefaultBlock,\n                span: span,\n            }\n     }\n \n     fn expr(&self, span: Span, node: ast::Expr_) -> @ast::Expr {\n         @ast::Expr {\n-            id: self.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: span,\n         }\n@@ -470,15 +469,15 @@ impl AstBuilder for @ExtCtxt {\n \n     fn expr_binary(&self, sp: Span, op: ast::BinOp,\n                    lhs: @ast::Expr, rhs: @ast::Expr) -> @ast::Expr {\n-        self.expr(sp, ast::ExprBinary(self.next_id(), op, lhs, rhs))\n+        self.expr(sp, ast::ExprBinary(ast::DUMMY_NODE_ID, op, lhs, rhs))\n     }\n \n     fn expr_deref(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n         self.expr_unary(sp, ast::UnDeref, e)\n     }\n     fn expr_unary(&self, sp: Span, op: ast::UnOp, e: @ast::Expr)\n         -> @ast::Expr {\n-        self.expr(sp, ast::ExprUnary(self.next_id(), op, e))\n+        self.expr(sp, ast::ExprUnary(ast::DUMMY_NODE_ID, op, e))\n     }\n \n     fn expr_managed(&self, sp: Span, e: @ast::Expr) -> @ast::Expr {\n@@ -512,7 +511,7 @@ impl AstBuilder for @ExtCtxt {\n                         ident: ast::Ident,\n                         args: ~[@ast::Expr]) -> @ast::Expr {\n         self.expr(span,\n-                  ast::ExprMethodCall(self.next_id(), expr, ident, ~[], args, ast::NoSugar))\n+                  ast::ExprMethodCall(ast::DUMMY_NODE_ID, expr, ident, ~[], args, ast::NoSugar))\n     }\n     fn expr_block(&self, b: ast::Block) -> @ast::Expr {\n         self.expr(b.span, ast::ExprBlock(b))\n@@ -583,7 +582,7 @@ impl AstBuilder for @ExtCtxt {\n \n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n-        @ast::Pat { id: self.next_id(), node: pat, span: span }\n+        @ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }\n     }\n     fn pat_wild(&self, span: Span) -> @ast::Pat {\n         self.pat(span, ast::PatWild)\n@@ -695,7 +694,7 @@ impl AstBuilder for @ExtCtxt {\n             is_mutbl: false,\n             ty: ty,\n             pat: arg_pat,\n-            id: self.next_id()\n+            id: ast::DUMMY_NODE_ID\n         }\n     }\n \n@@ -714,7 +713,7 @@ impl AstBuilder for @ExtCtxt {\n         // Rust coding conventions\n         @ast::item { ident: name,\n                     attrs: attrs,\n-                    id: self.next_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     node: node,\n                     vis: ast::public,\n                     span: span }\n@@ -755,15 +754,15 @@ impl AstBuilder for @ExtCtxt {\n \n     fn variant(&self, span: Span, name: Ident, tys: ~[ast::Ty]) -> ast::variant {\n         let args = tys.move_iter().map(|ty| {\n-            ast::variant_arg { ty: ty, id: self.next_id() }\n+            ast::variant_arg { ty: ty, id: ast::DUMMY_NODE_ID }\n         }).collect();\n \n         respan(span,\n                ast::variant_ {\n                    name: name,\n                    attrs: ~[],\n                    kind: ast::tuple_variant_kind(args),\n-                   id: self.next_id(),\n+                   id: ast::DUMMY_NODE_ID,\n                    disr_expr: None,\n                    vis: ast::public\n                })\n@@ -860,43 +859,20 @@ impl AstBuilder for @ExtCtxt {\n     fn view_use_list(&self, sp: Span, vis: ast::visibility,\n                      path: ~[ast::Ident], imports: &[ast::Ident]) -> ast::view_item {\n         let imports = do imports.map |id| {\n-            respan(sp, ast::path_list_ident_ { name: *id, id: self.next_id() })\n+            respan(sp, ast::path_list_ident_ { name: *id, id: ast::DUMMY_NODE_ID })\n         };\n \n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n                                 ast::view_path_list(self.path(sp, path),\n                                                     imports,\n-                                                    self.next_id()))])\n+                                                    ast::DUMMY_NODE_ID))])\n     }\n \n     fn view_use_glob(&self, sp: Span,\n                      vis: ast::visibility, path: ~[ast::Ident]) -> ast::view_item {\n         self.view_use(sp, vis,\n                       ~[@respan(sp,\n-                                ast::view_path_glob(self.path(sp, path), self.next_id()))])\n-    }\n-}\n-\n-\n-pub trait Duplicate {\n-    //\n-    // Duplication functions\n-    //\n-    // These functions just duplicate AST nodes.\n-    //\n-\n-    fn duplicate(&self, cx: @ExtCtxt) -> Self;\n-}\n-\n-impl Duplicate for @ast::Expr {\n-    fn duplicate(&self, cx: @ExtCtxt) -> @ast::Expr {\n-        let folder = fold::default_ast_fold();\n-        let folder = @fold::AstFoldFns {\n-            new_id: |_| cx.next_id(),\n-            ..*folder\n-        };\n-        let folder = fold::make_fold(folder);\n-        folder.fold_expr(*self)\n+                                ast::view_path_glob(self.path(sp, path), ast::DUMMY_NODE_ID))])\n     }\n }"}, {"sha": "0ca18f1208d0db715df7ebec13569a8c8cbdac93", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -35,7 +35,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n     let res = str_to_ident(res_str);\n \n     let e = @ast::Expr {\n-        id: cx.next_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprPath(\n             ast::Path {\n                  span: sp,"}, {"sha": "b244a63845c6e19630e971d0e3fbc51ee28b22e4", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -539,9 +539,9 @@ impl<'self> MethodDef<'self> {\n             purity: ast::impure_fn,\n             decl: fn_decl,\n             body: body_block,\n-            id: cx.next_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: span,\n-            self_id: cx.next_id(),\n+            self_id: ast::DUMMY_NODE_ID,\n             vis: ast::inherited,\n         }\n     }"}, {"sha": "56f92246d8fe0f9a9b35c5bc5228ce8b1e31cf65", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -12,7 +12,7 @@ use ast;\n use ast::{MetaItem, item, Expr, Ident};\n use codemap::Span;\n use ext::base::ExtCtxt;\n-use ext::build::{AstBuilder, Duplicate};\n+use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n \n use std::vec;\n@@ -62,7 +62,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n     let rand_call = || {\n         cx.expr_call_global(span,\n                             rand_ident.clone(),\n-                            ~[ rng[0].duplicate(cx) ])\n+                            ~[ rng[0] ])\n     };\n \n     return match *substr.fields {\n@@ -86,7 +86,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             // ::std::rand::Rand::rand(rng)\n             let rv_call = cx.expr_call(span,\n                                        rand_name,\n-                                       ~[ rng[0].duplicate(cx) ]);\n+                                       ~[ rng[0] ]);\n \n             // need to specify the uint-ness of the random number\n             let uint_ty = cx.ty_ident(span, cx.ident_of(\"uint\"));"}, {"sha": "80fd7971efdd74157b5d52e087466416405046cb", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -406,8 +406,8 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             let marked_ctxt = new_mark(fm,ctxt);\n             let expanded = match expandfun(cx, mac.span, marked_tts, marked_ctxt) {\n                 MRExpr(e) =>\n-                    @codemap::Spanned { node: StmtExpr(e, cx.next_id()),\n-                                    span: e.span},\n+                    @codemap::Spanned { node: StmtExpr(e, ast::DUMMY_NODE_ID),\n+                                        span: e.span},\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,\n@@ -1365,8 +1365,8 @@ pub fn fun_to_ctxt_folder<T : 'static + CtxtFn>(cf: @T) -> @AstFoldFns {\n         match *m {\n             mac_invoc_tt(ref path, ref tts, ctxt) =>\n             (mac_invoc_tt(fld.fold_path(path),\n-                         fold_tts(*tts,fld),\n-                         cf.f(ctxt)),\n+                          fold_tts(*tts,fld),\n+                          cf.f(ctxt)),\n             sp)\n         }\n "}, {"sha": "b7722ffc29710887da887e4b6d6599cce1189c37", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -550,7 +550,7 @@ impl Context {\n         for &method in self.method_statics.iter() {\n             let decl = respan(self.fmtsp, ast::DeclItem(method));\n             lets.push(@respan(self.fmtsp,\n-                              ast::StmtDecl(@decl, self.ecx.next_id())));\n+                              ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n         }\n \n         // Next, build up the static array which will become our precompiled\n@@ -581,7 +581,7 @@ impl Context {\n         let unnamed = self.ecx.attribute(self.fmtsp, unnamed);\n         let item = self.ecx.item(self.fmtsp, static_name, ~[unnamed], st);\n         let decl = respan(self.fmtsp, ast::DeclItem(item));\n-        lets.push(@respan(self.fmtsp, ast::StmtDecl(@decl, self.ecx.next_id())));\n+        lets.push(@respan(self.fmtsp, ast::StmtDecl(@decl, ast::DUMMY_NODE_ID)));\n \n         // Right now there is a bug such that for the expression:\n         //      foo(bar(&1))\n@@ -631,7 +631,7 @@ impl Context {\n            view_items: ~[],\n            stmts: ~[],\n            expr: Some(result),\n-           id: self.ecx.next_id(),\n+           id: ast::DUMMY_NODE_ID,\n            rules: ast::UnsafeBlock,\n            span: self.fmtsp,\n         });"}, {"sha": "52807009073b1b0ed14856594c7c17afaf81905b", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -30,7 +30,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n \n     //trivial expression\n     MRExpr(@ast::Expr {\n-        id: cx.next_id(),\n+        id: ast::DUMMY_NODE_ID,\n         node: ast::ExprLit(@codemap::Spanned {\n             node: ast::lit_nil,\n             span: sp"}, {"sha": "0b19e4462f08a095162608654ee3d92d12efba28", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 213, "deletions": 149, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -29,6 +29,7 @@ pub trait ast_fold {\n     fn fold_item(@self, @item) -> Option<@item>;\n     fn fold_struct_field(@self, @struct_field) -> @struct_field;\n     fn fold_item_underscore(@self, &item_) -> item_;\n+    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod;\n     fn fold_method(@self, @method) -> @method;\n     fn fold_block(@self, &Block) -> Block;\n     fn fold_stmt(@self, &Stmt) -> Option<@Stmt>;\n@@ -47,6 +48,149 @@ pub trait ast_fold {\n     fn map_exprs(@self, @fn(@Expr) -> @Expr, &[@Expr]) -> ~[@Expr];\n     fn new_id(@self, NodeId) -> NodeId;\n     fn new_span(@self, Span) -> Span;\n+\n+    // New style, using default methods:\n+\n+    fn fold_variant_arg(@self, va: &variant_arg) -> variant_arg {\n+        variant_arg {\n+            ty: self.fold_ty(&va.ty),\n+            id: self.new_id(va.id)\n+        }\n+    }\n+\n+    fn fold_spanned<T>(@self, s: &Spanned<T>, f: &fn(&T) -> T) -> Spanned<T> {\n+        Spanned {\n+            node: f(&s.node),\n+            span: self.new_span(s.span)\n+        }\n+    }\n+\n+    fn fold_view_path(@self, vp: &view_path) -> view_path {\n+        self.fold_spanned(vp, |v| self.fold_view_path_(v))\n+    }\n+\n+    fn fold_view_paths(@self, vps: &[@view_path]) -> ~[@view_path] {\n+        vps.map(|vp| @self.fold_view_path(*vp))\n+    }\n+\n+    fn fold_view_path_(@self, vp: &view_path_) -> view_path_ {\n+        match *vp {\n+            view_path_simple(ident, ref path, node_id) => {\n+                view_path_simple(self.fold_ident(ident),\n+                                 self.fold_path(path),\n+                                 self.new_id(node_id))\n+            }\n+            view_path_glob(ref path, node_id) => {\n+                view_path_glob(self.fold_path(path),\n+                               self.new_id(node_id))\n+            }\n+            view_path_list(ref path, ref idents, node_id) => {\n+                view_path_list(self.fold_path(path),\n+                               self.fold_path_list_idents(*idents),\n+                               self.new_id(node_id))\n+            }\n+        }\n+    }\n+\n+    fn fold_path_list_idents(@self, idents: &[path_list_ident]) -> ~[path_list_ident] {\n+        idents.map(|i| self.fold_path_list_ident(i))\n+    }\n+\n+    fn fold_path_list_ident(@self, ident: &path_list_ident) -> path_list_ident {\n+        self.fold_spanned(ident, |i| self.fold_path_list_ident_(i))\n+    }\n+\n+    fn fold_path_list_ident_(@self, ident: &path_list_ident_) -> path_list_ident_ {\n+        path_list_ident_ {\n+            name: self.fold_ident(ident.name),\n+            id: self.new_id(ident.id)\n+        }\n+    }\n+\n+    fn fold_arg(@self, a: &arg) -> arg {\n+        arg {\n+            is_mutbl: a.is_mutbl,\n+            ty: self.fold_ty(&a.ty),\n+            pat: self.fold_pat(a.pat),\n+            id: self.new_id(a.id),\n+        }\n+    }\n+\n+    fn fold_trait_ref(@self, p: &trait_ref) -> trait_ref {\n+        trait_ref {\n+            path: self.fold_path(&p.path),\n+            ref_id: self.new_id(p.ref_id),\n+        }\n+    }\n+\n+    fn fold_ty_param_bound(@self, tpb: &TyParamBound) -> TyParamBound {\n+        match *tpb {\n+            TraitTyParamBound(ref ty) => {\n+                TraitTyParamBound(self.fold_trait_ref(ty))\n+            }\n+            RegionTyParamBound => {\n+                RegionTyParamBound\n+            }\n+        }\n+    }\n+\n+    fn fold_ty_param(@self, tp: &TyParam) -> TyParam {\n+        TyParam {\n+            ident: self.fold_ident(tp.ident),\n+            id: self.new_id(tp.id),\n+            bounds: tp.bounds.map(|x| self.fold_ty_param_bound(x))\n+        }\n+    }\n+\n+    fn fold_ty_params(@self, tps: &OptVec<TyParam>) -> OptVec<TyParam> {\n+        tps.map(|tp| self.fold_ty_param(tp))\n+    }\n+\n+    fn fold_lifetime(@self, l: &Lifetime) -> Lifetime {\n+        Lifetime {\n+            id: self.new_id(l.id),\n+            span: self.new_span(l.span),\n+            ident: l.ident, // Folding this ident causes hygiene errors - ndm\n+        }\n+    }\n+\n+    fn fold_lifetimes(@self, lts: &OptVec<Lifetime>) -> OptVec<Lifetime> {\n+        lts.map(|l| self.fold_lifetime(l))\n+    }\n+\n+\n+    fn fold_meta_item(@self, mi: &MetaItem) -> @MetaItem {\n+        @self.fold_spanned(mi, |n| match *n {\n+                MetaWord(id) => {\n+                    MetaWord(id)\n+                }\n+                MetaList(id, ref mis) => {\n+                    MetaList(id, self.fold_meta_items(*mis))\n+                }\n+                MetaNameValue(id, s) => {\n+                    MetaNameValue(id, s)\n+                }\n+            })\n+    }\n+\n+    fn fold_meta_items(@self, mis: &[@MetaItem]) -> ~[@MetaItem] {\n+        mis.map(|&mi| self.fold_meta_item(mi))\n+    }\n+\n+    fn fold_attribute(@self, at: &Attribute) -> Attribute {\n+        Spanned {\n+            span: self.new_span(at.span),\n+            node: Attribute_ {\n+                style: at.node.style,\n+                value: self.fold_meta_item(at.node.value),\n+                is_sugared_doc: at.node.is_sugared_doc\n+            }\n+        }\n+    }\n+\n+    fn fold_attributes(@self, attrs: &[Attribute]) -> ~[Attribute] {\n+        attrs.map(|x| self.fold_attribute(x))\n+    }\n }\n \n // We may eventually want to be able to fold over type parameters, too\n@@ -59,6 +203,7 @@ pub struct AstFoldFns {\n     fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n     fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n     fold_item_underscore: @fn(&item_, @ast_fold) -> item_,\n+    fold_type_method: @fn(&TypeMethod, @ast_fold) -> TypeMethod,\n     fold_method: @fn(@method, @ast_fold) -> @method,\n     fold_block: @fn(&Block, @ast_fold) -> Block,\n     fold_stmt: @fn(&Stmt_, Span, @ast_fold) -> (Option<Stmt_>, Span),\n@@ -83,61 +228,20 @@ pub type ast_fold_fns = @AstFoldFns;\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n-//used in noop_fold_item and noop_fold_crate and noop_fold_crate_directive\n-fn fold_meta_item_(mi: @MetaItem, fld: @ast_fold) -> @MetaItem {\n-    @Spanned {\n-        node:\n-            match mi.node {\n-                MetaWord(id) => MetaWord(id),\n-                MetaList(id, ref mis) => {\n-                    let fold_meta_item = |x| fold_meta_item_(x, fld);\n-                    MetaList(\n-                        id,\n-                        mis.map(|e| fold_meta_item(*e))\n-                    )\n-                }\n-                MetaNameValue(id, s) => MetaNameValue(id, s)\n-            },\n-        span: fld.new_span(mi.span) }\n-}\n-//used in noop_fold_item and noop_fold_crate\n-fn fold_attribute_(at: Attribute, fld: @ast_fold) -> Attribute {\n-    Spanned {\n-        span: fld.new_span(at.span),\n-        node: ast::Attribute_ {\n-            style: at.node.style,\n-            value: fold_meta_item_(at.node.value, fld),\n-            is_sugared_doc: at.node.is_sugared_doc\n-        }\n-    }\n-}\n-\n-//used in noop_fold_foreign_item and noop_fold_fn_decl\n-fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n-    ast::arg {\n-        is_mutbl: a.is_mutbl,\n-        ty: fld.fold_ty(&a.ty),\n-        pat: fld.fold_pat(a.pat),\n-        id: fld.new_id(a.id),\n-    }\n-}\n-\n-// build a new vector of tts by appling the ast_fold's fold_ident to\n-// all of the identifiers in the token trees.\n-pub fn fold_tts(tts : &[token_tree], f : @ast_fold) -> ~[token_tree] {\n+pub fn fold_tts(tts : &[token_tree], fld: @ast_fold) -> ~[token_tree] {\n     do tts.map |tt| {\n         match *tt {\n             tt_tok(span, ref tok) =>\n-            tt_tok(span,maybe_fold_ident(tok,f)),\n+            tt_tok(span,maybe_fold_ident(tok,fld)),\n             tt_delim(ref tts) =>\n-            tt_delim(@mut fold_tts(**tts, f)),\n+            tt_delim(@mut fold_tts(**tts, fld)),\n             tt_seq(span, ref pattern, ref sep, is_optional) =>\n             tt_seq(span,\n-                   @mut fold_tts(**pattern, f),\n-                   sep.map(|tok|maybe_fold_ident(tok,f)),\n+                   @mut fold_tts(**pattern, fld),\n+                   sep.map(|tok|maybe_fold_ident(tok,fld)),\n                    is_optional),\n             tt_nonterminal(sp,ref ident) =>\n-            tt_nonterminal(sp,f.fold_ident(*ident))\n+            tt_nonterminal(sp,fld.fold_ident(*ident))\n         }\n     }\n }\n@@ -153,82 +257,51 @@ fn maybe_fold_ident(t : &token::Token, f: @ast_fold) -> token::Token {\n \n pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ (*x).clone(), fld)),\n+        inputs: decl.inputs.map(|x| fld.fold_arg(x)),\n         output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n \n-fn fold_ty_param_bound(tpb: &TyParamBound, fld: @ast_fold) -> TyParamBound {\n-    match *tpb {\n-        TraitTyParamBound(ref ty) => TraitTyParamBound(fold_trait_ref(ty, fld)),\n-        RegionTyParamBound => RegionTyParamBound\n-    }\n-}\n-\n-pub fn fold_ty_param(tp: TyParam,\n-                     fld: @ast_fold) -> TyParam {\n-    TyParam {ident: tp.ident,\n-             id: fld.new_id(tp.id),\n-             bounds: tp.bounds.map(|x| fold_ty_param_bound(x, fld))}\n-}\n-\n-pub fn fold_ty_params(tps: &OptVec<TyParam>,\n-                      fld: @ast_fold) -> OptVec<TyParam> {\n-    let tps = /*bad*/ (*tps).clone();\n-    tps.map_move(|tp| fold_ty_param(tp, fld))\n-}\n-\n-pub fn fold_lifetime(l: &Lifetime,\n-                     fld: @ast_fold) -> Lifetime {\n-    Lifetime {id: fld.new_id(l.id),\n-              span: fld.new_span(l.span),\n-              ident: l.ident}\n-}\n-\n-pub fn fold_lifetimes(lts: &OptVec<Lifetime>,\n-                      fld: @ast_fold) -> OptVec<Lifetime> {\n-    lts.map(|l| fold_lifetime(l, fld))\n-}\n-\n pub fn fold_generics(generics: &Generics, fld: @ast_fold) -> Generics {\n-    Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n-              lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n+    Generics {ty_params: fld.fold_ty_params(&generics.ty_params),\n+              lifetimes: fld.fold_lifetimes(&generics.lifetimes)}\n }\n \n pub fn noop_fold_crate(c: &Crate, fld: @ast_fold) -> Crate {\n-    let fold_meta_item = |x| fold_meta_item_(x, fld);\n-    let fold_attribute = |x| fold_attribute_(x, fld);\n-\n     Crate {\n         module: fld.fold_mod(&c.module),\n-        attrs: c.attrs.map(|x| fold_attribute(*x)),\n-        config: c.config.map(|x| fold_meta_item(*x)),\n+        attrs: fld.fold_attributes(c.attrs),\n+        config: fld.fold_meta_items(c.config),\n         span: fld.new_span(c.span),\n     }\n }\n \n-fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n-    // FIXME #7654: doesn't iterate over idents in a view_item_use\n-    return /* FIXME (#2543) */ (*vi).clone();\n+fn noop_fold_view_item(vi: &view_item_, fld: @ast_fold) -> view_item_ {\n+    match *vi {\n+        view_item_extern_mod(ident, name, ref meta_items, node_id) => {\n+            view_item_extern_mod(ident,\n+                                 name,\n+                                 fld.fold_meta_items(*meta_items),\n+                                 fld.new_id(node_id))\n+        }\n+        view_item_use(ref view_paths) => {\n+            view_item_use(fld.fold_view_paths(*view_paths))\n+        }\n+    }\n }\n \n-\n fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n     -> @foreign_item {\n-    let fold_arg = |x| fold_arg_(x, fld);\n-    let fold_attribute = |x| fold_attribute_(x, fld);\n-\n     @ast::foreign_item {\n         ident: fld.fold_ident(ni.ident),\n-        attrs: ni.attrs.map(|x| fold_attribute(*x)),\n+        attrs: fld.fold_attributes(ni.attrs),\n         node:\n             match ni.node {\n                 foreign_item_fn(ref fdec, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a|\n-                                fold_arg(/*bad*/(*a).clone())),\n+                            inputs: fdec.inputs.map(|a| fld.fold_arg(a)),\n                             output: fld.fold_ty(&fdec.output),\n                             cf: fdec.cf,\n                         },\n@@ -245,10 +318,8 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n }\n \n pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n-    let fold_attribute = |x| fold_attribute_(x, fld);\n-\n     Some(@ast::item { ident: fld.fold_ident(i.ident),\n-                      attrs: i.attrs.map(|e| fold_attribute(*e)),\n+                      attrs: fld.fold_attributes(i.attrs),\n                       id: fld.new_id(i.id),\n                       node: fld.fold_item_underscore(&i.node),\n                       vis: i.vis,\n@@ -257,22 +328,35 @@ pub fn noop_fold_item(i: @item, fld: @ast_fold) -> Option<@item> {\n \n fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n-    let fold_attribute = |x| fold_attribute_(x, fld);\n-\n     @Spanned {\n         node: ast::struct_field_ {\n             kind: sf.node.kind,\n-            id: sf.node.id,\n+            id: fld.new_id(sf.node.id),\n             ty: fld.fold_ty(&sf.node.ty),\n-            attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n+            attrs: fld.fold_attributes(sf.node.attrs),\n         },\n         span: sf.span\n     }\n }\n \n+pub fn noop_fold_type_method(m: &TypeMethod, fld: @ast_fold) -> TypeMethod {\n+    TypeMethod {\n+        ident: fld.fold_ident(m.ident),\n+        attrs: fld.fold_attributes(m.attrs),\n+        purity: m.purity,\n+        decl: fold_fn_decl(&m.decl, fld),\n+        generics: fold_generics(&m.generics, fld),\n+        explicit_self: m.explicit_self,\n+        id: fld.new_id(m.id),\n+        span: fld.new_span(m.span),\n+    }\n+}\n+\n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n-        item_static(ref t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n+        item_static(ref t, m, e) => {\n+            item_static(fld.fold_ty(t), m, fld.fold_expr(e))\n+        }\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n@@ -282,7 +366,9 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n                 fld.fold_block(body)\n             )\n         }\n-        item_mod(ref m) => item_mod(fld.fold_mod(m)),\n+        item_mod(ref m) => {\n+            item_mod(fld.fold_mod(m))\n+        }\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(fld.fold_foreign_mod(nm))\n         }\n@@ -300,26 +386,26 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         }\n         item_struct(ref struct_def, ref generics) => {\n             let struct_def = fold_struct_def(*struct_def, fld);\n-            item_struct(struct_def, /* FIXME (#2543) */ (*generics).clone())\n+            item_struct(struct_def, fold_generics(generics, fld))\n         }\n         item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(\n                 fold_generics(generics, fld),\n-                ifce.map(|p| fold_trait_ref(p, fld)),\n+                ifce.map(|p| fld.fold_trait_ref(p)),\n                 fld.fold_ty(ty),\n                 methods.map(|x| fld.fold_method(*x))\n             )\n         }\n         item_trait(ref generics, ref traits, ref methods) => {\n             let methods = do methods.map |method| {\n                 match *method {\n-                    required(*) => (*method).clone(),\n+                    required(ref m) => required(fld.fold_type_method(m)),\n                     provided(method) => provided(fld.fold_method(method))\n                 }\n             };\n             item_trait(\n                 fold_generics(generics, fld),\n-                traits.map(|p| fold_trait_ref(p, fld)),\n+                traits.map(|p| fld.fold_trait_ref(p)),\n                 methods\n             )\n         }\n@@ -337,20 +423,13 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: @ast_fold)\n     }\n }\n \n-fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n-    ast::trait_ref {\n-        path: fld.fold_path(&p.path),\n-        ref_id: fld.new_id(p.ref_id),\n-    }\n-}\n-\n fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n     @Spanned {\n         node: ast::struct_field_ {\n             kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(&f.node.ty),\n-            attrs: /* FIXME (#2543) */ f.node.attrs.clone(),\n+            attrs: fld.fold_attributes(f.node.attrs),\n         },\n         span: fld.new_span(f.span),\n     }\n@@ -359,7 +438,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n fn noop_fold_method(m: @method, fld: @ast_fold) -> @method {\n     @ast::method {\n         ident: fld.fold_ident(m.ident),\n-        attrs: /* FIXME (#2543) */ m.attrs.clone(),\n+        attrs: fld.fold_attributes(m.attrs),\n         generics: fold_generics(&m.generics, fld),\n         explicit_self: m.explicit_self,\n         purity: m.purity,\n@@ -654,7 +733,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n     fn fold_opt_bounds(b: &Option<OptVec<TyParamBound>>, fld: @ast_fold)\n                         -> Option<OptVec<TyParamBound>> {\n         do b.map |bounds| {\n-            do bounds.map |bound| { fold_ty_param_bound(bound, fld) }\n+            do bounds.map |bound| { fld.fold_ty_param_bound(bound) }\n         }\n     }\n     match *t {\n@@ -672,12 +751,12 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 onceness: f.onceness,\n                 bounds: fold_opt_bounds(&f.bounds, fld),\n                 decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: f.lifetimes.clone(),\n+                lifetimes: fld.fold_lifetimes(&f.lifetimes)\n             })\n         }\n         ty_bare_fn(ref f) => {\n             ty_bare_fn(@TyBareFn {\n-                lifetimes: f.lifetimes.clone(),\n+                lifetimes: fld.fold_lifetimes(&f.lifetimes),\n                 purity: f.purity,\n                 abis: f.abis,\n                 decl: fold_fn_decl(&f.decl, fld)\n@@ -715,29 +794,20 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n }\n \n fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n-    fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n-        ast::variant_arg { ty: fld.fold_ty(&va.ty), id: fld.new_id(va.id) }\n-    }\n-    let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n-\n-    let kind;\n-    match v.kind {\n+    let kind = match v.kind {\n         tuple_variant_kind(ref variant_args) => {\n-            kind = tuple_variant_kind(do variant_args.map |x| {\n-                fold_variant_arg(/*bad*/ (*x).clone())\n-            })\n+            tuple_variant_kind(variant_args.map(|x| fld.fold_variant_arg(x)))\n         }\n         struct_variant_kind(ref struct_def) => {\n-            kind = struct_variant_kind(@ast::struct_def {\n+            struct_variant_kind(@ast::struct_def {\n                 fields: struct_def.fields.iter()\n                     .map(|f| fld.fold_struct_field(*f)).collect(),\n                 ctor_id: struct_def.ctor_id.map(|c| fld.new_id(*c))\n             })\n         }\n-    }\n+    };\n \n-    let fold_attribute = |x| fold_attribute_(x, fld);\n-    let attrs = v.attrs.map(|x| fold_attribute(*x));\n+    let attrs = fld.fold_attributes(v.attrs);\n \n     let de = match v.disr_expr {\n       Some(e) => Some(fld.fold_expr(e)),\n@@ -811,6 +881,7 @@ pub fn default_ast_fold() -> ast_fold_fns {\n         fold_item: noop_fold_item,\n         fold_struct_field: noop_fold_struct_field,\n         fold_item_underscore: noop_fold_item_underscore,\n+        fold_type_method: noop_fold_type_method,\n         fold_method: noop_fold_method,\n         fold_block: noop_fold_block,\n         fold_stmt: |x, s, fld| (noop_fold_stmt(x, fld), s),\n@@ -840,7 +911,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_view_item(@self, x: &view_item) -> view_item {\n         ast::view_item {\n             node: (self.fold_view_item)(&x.node, self as @ast_fold),\n-            attrs: x.attrs.iter().map(|a| fold_attribute_(*a, self as @ast_fold)).collect(),\n+            attrs: self.fold_attributes(x.attrs),\n             vis: x.vis,\n             span: (self.new_span)(x.span),\n         }\n@@ -855,16 +926,19 @@ impl ast_fold for AstFoldFns {\n         @Spanned {\n             node: ast::struct_field_ {\n                 kind: sf.node.kind,\n-                id: sf.node.id,\n+                id: (self.new_id)(sf.node.id),\n                 ty: self.fold_ty(&sf.node.ty),\n-                attrs: sf.node.attrs.clone(),\n+                attrs: self.fold_attributes(sf.node.attrs),\n             },\n             span: (self.new_span)(sf.span),\n         }\n     }\n     fn fold_item_underscore(@self, i: &item_) -> item_ {\n         (self.fold_item_underscore)(i, self as @ast_fold)\n     }\n+    fn fold_type_method(@self, m: &TypeMethod) -> TypeMethod {\n+        (self.fold_type_method)(m, self as @ast_fold)\n+    }\n     fn fold_method(@self, x: @method) -> @method {\n         (self.fold_method)(x, self as @ast_fold)\n     }\n@@ -949,16 +1023,6 @@ impl ast_fold for AstFoldFns {\n     }\n }\n \n-pub trait AstFoldExtensions {\n-    fn fold_attributes(&self, attrs: ~[Attribute]) -> ~[Attribute];\n-}\n-\n-impl AstFoldExtensions for @ast_fold {\n-    fn fold_attributes(&self, attrs: ~[Attribute]) -> ~[Attribute] {\n-        attrs.map(|x| fold_attribute_(*x, *self))\n-    }\n-}\n-\n // brson agrees with me that this function's existence is probably\n // not a good or useful thing.\n pub fn make_fold(afp: ast_fold_fns) -> @ast_fold {"}, {"sha": "f7c76fee1809307380e6fb3cfa2115c215e52028", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 17, "deletions": 32, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -11,7 +11,6 @@\n //! The main parser interface\n \n \n-use ast::NodeId;\n use ast;\n use codemap::{Span, CodeMap, FileMap, FileSubstr};\n use codemap;\n@@ -29,7 +28,6 @@ pub mod token;\n pub mod comments;\n pub mod attr;\n \n-\n /// Common routines shared by parser mods\n pub mod common;\n \n@@ -42,7 +40,6 @@ pub mod obsolete;\n // info about a parsing session.\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n-    next_id: NodeId,\n     span_diagnostic: @mut span_handler, // better be the same as the one in the reader!\n     /// Used to determine and report recursive mod inclusions\n     included_mod_stack: ~[Path],\n@@ -52,7 +49,6 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n     let cm = @CodeMap::new();\n     @mut ParseSess {\n         cm: cm,\n-        next_id: 1,\n         span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n         included_mod_stack: ~[],\n     }\n@@ -63,7 +59,6 @@ pub fn new_parse_sess_special_handler(sh: @mut span_handler,\n                                    -> @mut ParseSess {\n     @mut ParseSess {\n         cm: cm,\n-        next_id: 1,\n         span_diagnostic: sh,\n         included_mod_stack: ~[],\n     }\n@@ -201,15 +196,6 @@ pub fn parse_from_source_str<T>(\n     maybe_aborted(r,p)\n }\n \n-// return the next unused node id.\n-pub fn next_node_id(sess: @mut ParseSess) -> NodeId {\n-    let rv = sess.next_id;\n-    sess.next_id += 1;\n-    // ID 0 is reserved for the crate and doesn't actually exist in the AST\n-    assert!(rv != 0);\n-    return rv;\n-}\n-\n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: @mut ParseSess,\n                                   cfg: ast::CrateConfig,\n@@ -364,7 +350,7 @@ mod test {\n     #[test] fn path_exprs_1() {\n         assert_eq!(string_to_expr(@\"a\"),\n                    @ast::Expr{\n-                    id: 1,\n+                    id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                         span: sp(0, 1),\n                         global: false,\n@@ -383,7 +369,7 @@ mod test {\n     #[test] fn path_exprs_2 () {\n         assert_eq!(string_to_expr(@\"::a::b\"),\n                    @ast::Expr {\n-                    id:1,\n+                    id: ast::DUMMY_NODE_ID,\n                     node: ast::ExprPath(ast::Path {\n                             span: sp(0, 6),\n                             global: true,\n@@ -441,9 +427,9 @@ mod test {\n     #[test] fn ret_expr() {\n         assert_eq!(string_to_expr(@\"return d\"),\n                    @ast::Expr{\n-                    id:2,\n+                    id: ast::DUMMY_NODE_ID,\n                     node:ast::ExprRet(Some(@ast::Expr{\n-                        id:1,\n+                        id: ast::DUMMY_NODE_ID,\n                         node:ast::ExprPath(ast::Path{\n                             span: sp(7, 8),\n                             global: false,\n@@ -465,7 +451,7 @@ mod test {\n         assert_eq!(string_to_stmt(@\"b;\"),\n                    @Spanned{\n                        node: ast::StmtExpr(@ast::Expr {\n-                           id: 1,\n+                           id: ast::DUMMY_NODE_ID,\n                            node: ast::ExprPath(ast::Path {\n                                span:sp(0,1),\n                                global:false,\n@@ -478,7 +464,7 @@ mod test {\n                                ],\n                             }),\n                            span: sp(0,1)},\n-                                            2), // fixme\n+                                           ast::DUMMY_NODE_ID),\n                        span: sp(0,1)})\n \n     }\n@@ -490,7 +476,7 @@ mod test {\n     #[test] fn parse_ident_pat () {\n         let parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n-                   @ast::Pat{id:1, // fixme\n+                   @ast::Pat{id: ast::DUMMY_NODE_ID,\n                              node: ast::PatIdent(\n                                 ast::BindInfer,\n                                 ast::Path {\n@@ -511,17 +497,16 @@ mod test {\n \n     // check the contents of the tt manually:\n     #[test] fn parse_fundecl () {\n-        // this test depends on the intern order of \"fn\" and \"int\", and on the\n-        // assignment order of the NodeIds.\n+        // this test depends on the intern order of \"fn\" and \"int\"\n         assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n                   Some(\n                       @ast::item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n-                            id: 9, // fixme\n+                            id: ast::DUMMY_NODE_ID,\n                             node: ast::item_fn(ast::fn_decl{\n                                 inputs: ~[ast::arg{\n                                     is_mutbl: false,\n-                                    ty: ast::Ty{id:3, // fixme\n+                                    ty: ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ty_path(ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n@@ -533,11 +518,11 @@ mod test {\n                                                 types: opt_vec::Empty,\n                                             }\n                                         ],\n-                                        }, None, 2),\n+                                        }, None, ast::DUMMY_NODE_ID),\n                                         span:sp(10,13)\n                                     },\n                                     pat: @ast::Pat {\n-                                        id:1, // fixme\n+                                        id: ast::DUMMY_NODE_ID,\n                                         node: ast::PatIdent(\n                                             ast::BindInfer,\n                                             ast::Path {\n@@ -556,9 +541,9 @@ mod test {\n                                         ),\n                                         span: sp(6,7)\n                                     },\n-                                    id: 4 // fixme\n+                                    id: ast::DUMMY_NODE_ID\n                                 }],\n-                                output: ast::Ty{id:5, // fixme\n+                                output: ast::Ty{id: ast::DUMMY_NODE_ID,\n                                                  node: ast::ty_nil,\n                                                  span:sp(15,15)}, // not sure\n                                 cf: ast::return_val\n@@ -573,7 +558,7 @@ mod test {\n                                         view_items: ~[],\n                                         stmts: ~[@Spanned{\n                                             node: ast::StmtSemi(@ast::Expr{\n-                                                id: 6,\n+                                                id: ast::DUMMY_NODE_ID,\n                                                 node: ast::ExprPath(\n                                                       ast::Path{\n                                                         span:sp(17,18),\n@@ -591,10 +576,10 @@ mod test {\n                                                         ],\n                                                       }),\n                                                 span: sp(17,18)},\n-                                                                 7), // fixme\n+                                                ast::DUMMY_NODE_ID),\n                                             span: sp(17,18)}],\n                                         expr: None,\n-                                        id: 8, // fixme\n+                                        id: ast::DUMMY_NODE_ID,\n                                         rules: ast::DefaultBlock, // no idea\n                                         span: sp(15,21),\n                                     }),"}, {"sha": "9a09a1d9cecbaeaa87b1dd313251348c58eb86ef", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 69, "deletions": 70, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -41,7 +41,7 @@ use ast::{lit_bool, lit_float, lit_float_unsuffixed, lit_int, lit_char};\n use ast::{lit_int_unsuffixed, lit_nil, lit_str, lit_uint, Local};\n use ast::{MutImmutable, MutMutable, mac_, mac_invoc_tt, matcher, match_nonterminal};\n use ast::{match_seq, match_tok, method, mt, BiMul, Mutability};\n-use ast::{named_field, UnNeg, NodeId, noreturn, UnNot, Pat, PatBox, PatEnum};\n+use ast::{named_field, UnNeg, noreturn, UnNot, Pat, PatBox, PatEnum};\n use ast::{PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatUniq, PatWild, private};\n use ast::{BiRem, required};\n@@ -76,7 +76,7 @@ use parse::token::{is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n use parse::token::{token_to_binop};\n use parse::token;\n-use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n+use parse::{new_sub_parser_from_file, ParseSess};\n use opt_vec;\n use opt_vec::OptVec;\n \n@@ -507,7 +507,7 @@ impl Parser {\n         let ident = self.parse_ident();\n         let hi = self.last_span.hi;\n         spanned(lo, hi, ast::path_list_ident_ { name: ident,\n-                                                id: self.get_id() })\n+                                                id: ast::DUMMY_NODE_ID })\n     }\n \n     // consume token 'tok' if it exists. Returns true if the given\n@@ -758,7 +758,6 @@ impl Parser {\n     pub fn abort_if_errors(&self) {\n         self.sess.span_diagnostic.handler().abort_if_errors();\n     }\n-    pub fn get_id(&self) -> NodeId { next_node_id(self.sess) }\n \n     pub fn id_to_str(&self, id: Ident) -> @str {\n         get_ident_interner().get(id.name)\n@@ -961,7 +960,7 @@ impl Parser {\n                     decl: d,\n                     generics: generics,\n                     explicit_self: explicit_self,\n-                    id: p.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi)\n                 })\n               }\n@@ -978,9 +977,9 @@ impl Parser {\n                     purity: pur,\n                     decl: d,\n                     body: body,\n-                    id: p.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     span: mk_sp(lo, hi),\n-                    self_id: p.get_id(),\n+                    self_id: ast::DUMMY_NODE_ID,\n                     vis: vis,\n                 })\n               }\n@@ -1028,7 +1027,7 @@ impl Parser {\n                 (\n                     noreturn,\n                     Ty {\n-                        id: self.get_id(),\n+                        id: ast::DUMMY_NODE_ID,\n                         node: ty_bot,\n                         span: mk_sp(lo, self.last_span.hi)\n                     }\n@@ -1041,7 +1040,7 @@ impl Parser {\n             (\n                 return_val,\n                 Ty {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     node: ty_nil,\n                     span: mk_sp(pos, pos),\n                 }\n@@ -1154,14 +1153,14 @@ impl Parser {\n                 path,\n                 bounds\n             } = self.parse_path(LifetimeAndTypesAndBounds);\n-            ty_path(path, bounds, self.get_id())\n+            ty_path(path, bounds, ast::DUMMY_NODE_ID)\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n                             *self.token));\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        Ty {id: self.get_id(), node: t, span: sp}\n+        Ty {id: ast::DUMMY_NODE_ID, node: t, span: sp}\n     }\n \n     // parse the type following a @ or a ~\n@@ -1275,7 +1274,7 @@ impl Parser {\n             pat\n         } else {\n             debug!(\"parse_arg_general ident_to_pat\");\n-            ast_util::ident_to_pat(self.get_id(),\n+            ast_util::ident_to_pat(ast::DUMMY_NODE_ID,\n                                    *self.last_span,\n                                    special_idents::invalid)\n         };\n@@ -1286,7 +1285,7 @@ impl Parser {\n             is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n@@ -1304,7 +1303,7 @@ impl Parser {\n             self.parse_ty(false)\n         } else {\n             Ty {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: ty_infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n             }\n@@ -1313,7 +1312,7 @@ impl Parser {\n             is_mutbl: is_mutbl,\n             ty: t,\n             pat: pat,\n-            id: self.get_id()\n+            id: ast::DUMMY_NODE_ID\n         })\n     }\n \n@@ -1562,7 +1561,7 @@ impl Parser {\n                 let span = self.span;\n                 self.bump();\n                 return ast::Lifetime {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     span: *span,\n                     ident: i\n                 };\n@@ -1575,7 +1574,7 @@ impl Parser {\n                 self.expect(&token::BINOP(token::SLASH));\n                 self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                 return ast::Lifetime {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     span: *span,\n                     ident: i\n                 };\n@@ -1654,18 +1653,18 @@ impl Parser {\n \n     pub fn mk_expr(&self, lo: BytePos, hi: BytePos, node: Expr_) -> @Expr {\n         @Expr {\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: node,\n             span: mk_sp(lo, hi),\n         }\n     }\n \n     pub fn mk_unary(&self, unop: ast::UnOp, expr: @Expr) -> ast::Expr_ {\n-        ExprUnary(self.get_id(), unop, expr)\n+        ExprUnary(ast::DUMMY_NODE_ID, unop, expr)\n     }\n \n     pub fn mk_binary(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n-        ExprBinary(self.get_id(), binop, lhs, rhs)\n+        ExprBinary(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n     pub fn mk_call(&self, f: @Expr, args: ~[@Expr], sugar: CallSugar) -> ast::Expr_ {\n@@ -1678,24 +1677,24 @@ impl Parser {\n                       tps: ~[Ty],\n                       args: ~[@Expr],\n                       sugar: CallSugar) -> ast::Expr_ {\n-        ExprMethodCall(self.get_id(), rcvr, ident, tps, args, sugar)\n+        ExprMethodCall(ast::DUMMY_NODE_ID, rcvr, ident, tps, args, sugar)\n     }\n \n     pub fn mk_index(&self, expr: @Expr, idx: @Expr) -> ast::Expr_ {\n-        ExprIndex(self.get_id(), expr, idx)\n+        ExprIndex(ast::DUMMY_NODE_ID, expr, idx)\n     }\n \n     pub fn mk_field(&self, expr: @Expr, ident: Ident, tys: ~[Ty]) -> ast::Expr_ {\n         ExprField(expr, ident, tys)\n     }\n \n     pub fn mk_assign_op(&self, binop: ast::BinOp, lhs: @Expr, rhs: @Expr) -> ast::Expr_ {\n-        ExprAssignOp(self.get_id(), binop, lhs, rhs)\n+        ExprAssignOp(ast::DUMMY_NODE_ID, binop, lhs, rhs)\n     }\n \n     pub fn mk_mac_expr(&self, lo: BytePos, hi: BytePos, m: mac_) -> @Expr {\n         @Expr {\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: ExprMac(codemap::Spanned {node: m, span: mk_sp(lo, hi)}),\n             span: mk_sp(lo, hi),\n         }\n@@ -1709,7 +1708,7 @@ impl Parser {\n         };\n \n         @Expr {\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: ExprLit(lv_lit),\n             span: *span,\n         }\n@@ -2415,7 +2414,7 @@ impl Parser {\n                       ast::fn_decl {\n                           inputs: ~[],\n                           output: Ty {\n-                              id: self.get_id(),\n+                              id: ast::DUMMY_NODE_ID,\n                               node: ty_infer,\n                               span: *self.span\n                           },\n@@ -2450,7 +2449,7 @@ impl Parser {\n             view_items: ~[],\n             stmts: ~[],\n             expr: Some(body),\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             rules: DefaultBlock,\n             span: body.span,\n         };\n@@ -2631,7 +2630,7 @@ impl Parser {\n                 view_items: ~[],\n                 stmts: ~[],\n                 expr: Some(expr),\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 rules: DefaultBlock,\n                 span: expr.span,\n             };\n@@ -2764,7 +2763,7 @@ impl Parser {\n                 subpat = self.parse_pat();\n             } else {\n                 subpat = @ast::Pat {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     node: PatIdent(BindInfer, fieldpath, None),\n                     span: *self.last_span\n                 };\n@@ -2788,7 +2787,7 @@ impl Parser {\n             pat = PatWild;\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2806,7 +2805,7 @@ impl Parser {\n                     span: _}), _\n               }) => {\n                 let vst = @Expr {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     node: ExprVstore(e, ExprVstoreBox),\n                     span: mk_sp(lo, hi),\n                 };\n@@ -2816,7 +2815,7 @@ impl Parser {\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2834,7 +2833,7 @@ impl Parser {\n                     span: _}), _\n               }) => {\n                 let vst = @Expr {\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     node: ExprVstore(e, ExprVstoreUniq),\n                     span: mk_sp(lo, hi),\n                 };\n@@ -2844,7 +2843,7 @@ impl Parser {\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2862,7 +2861,7 @@ impl Parser {\n                             node: lit_str(_), span: _}), _\n                   }) => {\n                       let vst = @Expr {\n-                          id: self.get_id(),\n+                          id: ast::DUMMY_NODE_ID,\n                           node: ExprVstore(e, ExprVstoreSlice),\n                           span: mk_sp(lo, hi)\n                       };\n@@ -2872,7 +2871,7 @@ impl Parser {\n             };\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2885,7 +2884,7 @@ impl Parser {\n             pat = PatWild;\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2915,7 +2914,7 @@ impl Parser {\n             }\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -2930,7 +2929,7 @@ impl Parser {\n             pat = ast::PatVec(before, slice, after);\n             hi = self.last_span.hi;\n             return @ast::Pat {\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 node: pat,\n                 span: mk_sp(lo, hi)\n             }\n@@ -3046,7 +3045,7 @@ impl Parser {\n         }\n         hi = self.last_span.hi;\n         @ast::Pat {\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: pat,\n             span: mk_sp(lo, hi),\n         }\n@@ -3095,7 +3094,7 @@ impl Parser {\n         }\n \n         let mut ty = Ty {\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n         };\n@@ -3106,7 +3105,7 @@ impl Parser {\n             ty: ty,\n             pat: pat,\n             init: init,\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, self.last_span.hi),\n         }\n     }\n@@ -3136,7 +3135,7 @@ impl Parser {\n         let ty = self.parse_ty(false);\n         @spanned(lo, self.last_span.hi, ast::struct_field_ {\n             kind: named_field(name, pr),\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             ty: ty,\n             attrs: attrs,\n         })\n@@ -3159,7 +3158,7 @@ impl Parser {\n             check_expected_item(self, !item_attrs.is_empty());\n             self.expect_keyword(keywords::Let);\n             let decl = self.parse_let();\n-            return @spanned(lo, decl.span.hi, StmtDecl(decl, self.get_id()));\n+            return @spanned(lo, decl.span.hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n         } else if is_ident(&*self.token)\n             && !token::is_any_keyword(self.token)\n             && self.look_ahead(1, |t| *t == token::NOT) {\n@@ -3208,7 +3207,7 @@ impl Parser {\n                             lo, hi, id /*id is good here*/,\n                             item_mac(spanned(lo, hi, mac_invoc_tt(pth, tts, EMPTY_CTXT))),\n                             inherited, ~[/*no attrs*/]))),\n-                    self.get_id()));\n+                    ast::DUMMY_NODE_ID));\n             }\n \n         } else {\n@@ -3217,7 +3216,7 @@ impl Parser {\n                 iovi_item(i) => {\n                     let hi = i.span.hi;\n                     let decl = @spanned(lo, hi, DeclItem(i));\n-                    return @spanned(lo, hi, StmtDecl(decl, self.get_id()));\n+                    return @spanned(lo, hi, StmtDecl(decl, ast::DUMMY_NODE_ID));\n                 }\n                 iovi_view_item(vi) => {\n                     self.span_fatal(vi.span,\n@@ -3233,7 +3232,7 @@ impl Parser {\n \n             // Remainder are line-expr stmts.\n             let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n-            return @spanned(lo, e.span.hi, StmtExpr(e, self.get_id()));\n+            return @spanned(lo, e.span.hi, StmtExpr(e, ast::DUMMY_NODE_ID));\n         }\n     }\n \n@@ -3298,7 +3297,7 @@ impl Parser {\n         for item in items.iter() {\n             let decl = @spanned(item.span.lo, item.span.hi, DeclItem(*item));\n             stmts.push(@spanned(item.span.lo, item.span.hi,\n-                                StmtDecl(decl, self.get_id())));\n+                                StmtDecl(decl, ast::DUMMY_NODE_ID)));\n         }\n \n         let mut attributes_box = attrs_remaining;\n@@ -3397,7 +3396,7 @@ impl Parser {\n             view_items: view_items,\n             stmts: stmts,\n             expr: expr,\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             rules: s,\n             span: mk_sp(lo, hi),\n         }\n@@ -3463,7 +3462,7 @@ impl Parser {\n         let opt_bounds = self.parse_optional_ty_param_bounds();\n         // For typarams we don't care about the difference b/w \"<T>\" and \"<T:>\".\n         let bounds = opt_bounds.unwrap_or_default(opt_vec::Empty);\n-        ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n+        ast::TyParam { ident: ident, id: ast::DUMMY_NODE_ID, bounds: bounds }\n     }\n \n     // parse a set of optional generic type parameter declarations\n@@ -3717,7 +3716,7 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n+            Ty { id: ast::DUMMY_NODE_ID, node: ty_infer, span: *self.span }\n         };\n \n         ast::fn_decl {\n@@ -3739,7 +3738,7 @@ impl Parser {\n                attrs: ~[Attribute]) -> @item {\n         @ast::item { ident: ident,\n                      attrs: attrs,\n-                     id: self.get_id(),\n+                     id: ast::DUMMY_NODE_ID,\n                      node: node,\n                      vis: vis,\n                      span: mk_sp(lo, hi) }\n@@ -3779,9 +3778,9 @@ impl Parser {\n             purity: pur,\n             decl: decl,\n             body: body,\n-            id: self.get_id(),\n+            id: ast::DUMMY_NODE_ID,\n             span: mk_sp(lo, hi),\n-            self_id: self.get_id(),\n+            self_id: ast::DUMMY_NODE_ID,\n             vis: visa,\n         }\n     }\n@@ -3873,7 +3872,7 @@ impl Parser {\n     fn parse_trait_ref(&self) -> trait_ref {\n         ast::trait_ref {\n             path: self.parse_path(LifetimeAndTypesWithoutColons).path,\n-            ref_id: self.get_id(),\n+            ref_id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n@@ -3926,7 +3925,7 @@ impl Parser {\n                 let lo = p.span.lo;\n                 let struct_field_ = ast::struct_field_ {\n                     kind: unnamed_field,\n-                    id: self.get_id(),\n+                    id: ast::DUMMY_NODE_ID,\n                     ty: p.parse_ty(false),\n                     attrs: attrs,\n                 };\n@@ -3947,8 +3946,8 @@ impl Parser {\n             );\n         }\n \n-        let _ = self.get_id();  // XXX: Workaround for crazy bug.\n-        let new_id = self.get_id();\n+        let _ = ast::DUMMY_NODE_ID;  // XXX: Workaround for crazy bug.\n+        let new_id = ast::DUMMY_NODE_ID;\n         (class_name,\n          item_struct(@ast::struct_def {\n              fields: fields,\n@@ -4238,7 +4237,7 @@ impl Parser {\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n                              node: foreign_item_fn(decl, generics),\n-                             id: self.get_id(),\n+                             id: ast::DUMMY_NODE_ID,\n                              span: mk_sp(lo, hi),\n                              vis: vis }\n     }\n@@ -4264,7 +4263,7 @@ impl Parser {\n         @ast::foreign_item { ident: ident,\n                              attrs: attrs,\n                              node: foreign_item_static(ty, mutbl),\n-                             id: self.get_id(),\n+                             id: ast::DUMMY_NODE_ID,\n                              span: mk_sp(lo, hi),\n                              vis: vis }\n     }\n@@ -4386,7 +4385,7 @@ impl Parser {\n         let metadata = self.parse_optional_meta();\n         self.expect(&token::SEMI);\n         iovi_view_item(ast::view_item {\n-            node: view_item_extern_mod(ident, maybe_path, metadata, self.get_id()),\n+            node: view_item_extern_mod(ident, maybe_path, metadata, ast::DUMMY_NODE_ID),\n             attrs: attrs,\n             vis: visibility,\n             span: mk_sp(lo, self.last_span.hi)\n@@ -4461,7 +4460,7 @@ impl Parser {\n                 for ty in arg_tys.move_iter() {\n                     args.push(ast::variant_arg {\n                         ty: ty,\n-                        id: self.get_id(),\n+                        id: ast::DUMMY_NODE_ID,\n                     });\n                 }\n                 kind = tuple_variant_kind(args);\n@@ -4477,7 +4476,7 @@ impl Parser {\n                 name: ident,\n                 attrs: variant_attrs,\n                 kind: kind,\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 disr_expr: disr_expr,\n                 vis: vis,\n             };\n@@ -4509,9 +4508,9 @@ impl Parser {\n                 name: id,\n                 attrs: ~[],\n                 kind: tuple_variant_kind(\n-                    ~[ast::variant_arg {ty: ty, id: self.get_id()}]\n+                    ~[ast::variant_arg {ty: ty, id: ast::DUMMY_NODE_ID}]\n                 ),\n-                id: self.get_id(),\n+                id: ast::DUMMY_NODE_ID,\n                 disr_expr: None,\n                 vis: public,\n             });\n@@ -4886,7 +4885,7 @@ impl Parser {\n             return @spanned(lo, self.span.hi,\n                             view_path_simple(first_ident,\n                                              path,\n-                                             self.get_id()));\n+                                             ast::DUMMY_NODE_ID));\n           }\n \n           token::MOD_SEP => {\n@@ -4920,7 +4919,7 @@ impl Parser {\n                         }).collect()\n                     };\n                     return @spanned(lo, self.span.hi,\n-                                 view_path_list(path, idents, self.get_id()));\n+                                 view_path_list(path, idents, ast::DUMMY_NODE_ID));\n                   }\n \n                   // foo::bar::*\n@@ -4938,7 +4937,7 @@ impl Parser {\n                         }).collect()\n                     };\n                     return @spanned(lo, self.span.hi,\n-                                    view_path_glob(path, self.get_id()));\n+                                    view_path_glob(path, ast::DUMMY_NODE_ID));\n                   }\n \n                   _ => break\n@@ -4961,7 +4960,7 @@ impl Parser {\n         };\n         return @spanned(lo,\n                         self.last_span.hi,\n-                        view_path_simple(last, path, self.get_id()));\n+                        view_path_simple(last, path, ast::DUMMY_NODE_ID));\n     }\n \n     // matches view_paths = view_path | view_path , view_paths\n@@ -5008,7 +5007,7 @@ impl Parser {\n             }\n             else { None };\n             let metadata = self.parse_optional_meta();\n-            view_item_extern_mod(ident, path, metadata, self.get_id())\n+            view_item_extern_mod(ident, path, metadata, ast::DUMMY_NODE_ID)\n         } else {\n             self.bug(\"expected view item\");\n         };"}, {"sha": "65d377173c8e91c7c48c7a0315f2354f2873ea8d", "filename": "src/test/run-pass/borrowck-macro-interaction-issue-6304.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-macro-interaction-issue-6304.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -0,0 +1,29 @@\n+// Check that we do not ICE when compiling this\n+// macro, which reuses the expression `$id`\n+\n+struct Foo {\n+  a: int\n+}\n+\n+pub enum Bar {\n+  Bar1, Bar2(int, ~Bar),\n+}\n+\n+impl Foo {\n+  fn elaborate_stm(&mut self, s: ~Bar) -> ~Bar {\n+    macro_rules! declare(\n+      ($id:expr, $rest:expr) => ({\n+        self.check_id($id);\n+        ~Bar2($id, $rest)\n+      })\n+    );\n+    match s {\n+      ~Bar2(id, rest) => declare!(id, self.elaborate_stm(rest)),\n+      _ => fail!()\n+    }\n+  }\n+\n+  fn check_id(&mut self, s: int) { fail!() }\n+}\n+ \n+fn main() { }"}, {"sha": "a1368365c4000ae7b3dc38ee8258b3f68d92dc90", "filename": "src/test/run-pass/typeck-macro-interaction-issue-8852.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ad4c379466519a0bf977864a5cdc50a7ade385/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs?ref=a5ad4c379466519a0bf977864a5cdc50a7ade385", "patch": "@@ -0,0 +1,22 @@\n+enum T {\n+    A(int),\n+    B(float)\n+}\n+\n+macro_rules! test(\n+    ($e:expr) => (\n+        fn foo(a:T, b:T) -> T {\n+            match (a, b) {\n+                (A(x), A(y)) => A($e),\n+                (B(x), B(y)) => B($e),\n+                _ => fail!()\n+            }\n+        }\n+    )\n+)\n+\n+test!(x + y)\n+\n+fn main() {\n+    foo(A(1), A(2));\n+}\n\\ No newline at end of file"}]}