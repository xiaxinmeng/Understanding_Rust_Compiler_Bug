{"sha": "cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkYzBiMTk5YTkwNGZlMDMxOGM3YTVjZjU1YTYxMGMyZGVkNmNhNjg=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-01-19T18:07:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-19T16:51:56Z"}, "message": "Split DepKindStruct in two.", "tree": {"sha": "6a3583df647c477a3631caba727d890af03dcb94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a3583df647c477a3631caba727d890af03dcb94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "html_url": "https://github.com/rust-lang/rust/commit/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ac21e4571320c24e62044fabbcdb8886f45e375", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac21e4571320c24e62044fabbcdb8886f45e375", "html_url": "https://github.com/rust-lang/rust/commit/1ac21e4571320c24e62044fabbcdb8886f45e375"}], "stats": {"total": 254, "additions": 151, "deletions": 103}, "files": [{"sha": "ba9d0a40732e6bec841cc6a239bdd9fa61565618", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 101, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "patch": "@@ -55,15 +55,13 @@\n //!\n //! [dependency graph]: https://rustc-dev-guide.rust-lang.org/query.html\n \n-use crate::ty::query::QueryCtxt;\n use crate::ty::TyCtxt;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::DefPathHash;\n use rustc_hir::HirId;\n use rustc_span::symbol::Symbol;\n-use rustc_span::DUMMY_SP;\n use std::hash::Hash;\n \n pub use rustc_query_system::dep_graph::{DepContext, DepNodeParams};\n@@ -92,53 +90,6 @@ pub struct DepKindStruct {\n     // FIXME: Make this a simple boolean once DepNodeParams::can_reconstruct_query_key\n     // can be made a specialized associated const.\n     can_reconstruct_query_key: fn() -> bool,\n-\n-    /// The red/green evaluation system will try to mark a specific DepNode in the\n-    /// dependency graph as green by recursively trying to mark the dependencies of\n-    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n-    /// where we don't know if it is red or green and we therefore actually have\n-    /// to recompute its value in order to find out. Since the only piece of\n-    /// information that we have at that point is the `DepNode` we are trying to\n-    /// re-evaluate, we need some way to re-run a query from just that. This is what\n-    /// `force_from_dep_node()` implements.\n-    ///\n-    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n-    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n-    /// is usually constructed by computing a stable hash of the query-key that the\n-    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n-    /// back from hash to query-key (since hash functions are not reversible). For\n-    /// this reason `force_from_dep_node()` is expected to fail from time to time\n-    /// because we just cannot find out, from the `DepNode` alone, what the\n-    /// corresponding query-key is and therefore cannot re-run the query.\n-    ///\n-    /// The system deals with this case letting `try_mark_green` fail which forces\n-    /// the root query to be re-evaluated.\n-    ///\n-    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n-    /// Fortunately, we can use some contextual information that will allow us to\n-    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n-    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n-    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n-    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n-    /// everything we need to re-run the query.\n-    ///\n-    /// Take the `mir_promoted` query as an example. Like many other queries, it\n-    /// just has a single parameter: the `DefId` of the item it will compute the\n-    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n-    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n-    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n-    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n-    ///\n-    /// When you implement a new query, it will likely have a corresponding new\n-    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n-    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n-    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n-    /// add it to the \"We don't have enough information to reconstruct...\" group in\n-    /// the match below.\n-    pub(crate) force_from_dep_node: fn(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool,\n-\n-    /// Invoke a query to put the on-disk cached value in memory.\n-    pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),\n }\n \n impl std::ops::Deref for DepKind {\n@@ -197,8 +148,7 @@ macro_rules! contains_eval_always_attr {\n #[allow(non_upper_case_globals)]\n pub mod dep_kind {\n     use super::*;\n-    use crate::ty::query::{queries, query_keys};\n-    use rustc_query_system::query::{force_query, QueryDescription};\n+    use crate::ty::query::query_keys;\n \n     // We use this for most things when incr. comp. is turned off.\n     pub const Null: DepKindStruct = DepKindStruct {\n@@ -207,8 +157,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || true,\n-        force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     pub const TraitSelect: DepKindStruct = DepKindStruct {\n@@ -217,8 +165,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || true,\n-        force_from_dep_node: |_, _| false,\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     pub const CompileCodegenUnit: DepKindStruct = DepKindStruct {\n@@ -227,8 +173,6 @@ pub mod dep_kind {\n         is_eval_always: false,\n \n         can_reconstruct_query_key: || false,\n-        force_from_dep_node: |_, _| false,\n-        try_load_from_on_disk_cache: |_, _| {},\n     };\n \n     macro_rules! define_query_dep_kinds {\n@@ -247,54 +191,11 @@ pub mod dep_kind {\n                         ::can_reconstruct_query_key()\n                 }\n \n-                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$variant<'tcx>> {\n-                    <query_keys::$variant<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n-                }\n-\n-                fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n-                    if is_anon {\n-                        return false;\n-                    }\n-\n-                    if !can_reconstruct_query_key() {\n-                        return false;\n-                    }\n-\n-                    if let Some(key) = recover(*tcx, dep_node) {\n-                        force_query::<queries::$variant<'_>, _>(tcx, key, DUMMY_SP, *dep_node);\n-                        return true;\n-                    }\n-\n-                    false\n-                }\n-\n-                fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {\n-                    if is_anon {\n-                        return\n-                    }\n-\n-                    if !can_reconstruct_query_key() {\n-                        return\n-                    }\n-\n-                    debug_assert!(tcx.dep_graph\n-                                     .node_color(dep_node)\n-                                     .map(|c| c.is_green())\n-                                     .unwrap_or(false));\n-\n-                    let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n-                    if queries::$variant::cache_on_disk(tcx, &key, None) {\n-                        let _ = tcx.$variant(key);\n-                    }\n-                }\n-\n                 DepKindStruct {\n                     has_params,\n                     is_anon,\n                     is_eval_always,\n                     can_reconstruct_query_key,\n-                    force_from_dep_node,\n-                    try_load_from_on_disk_cache,\n                 }\n             };)*\n         );\n@@ -310,7 +211,12 @@ macro_rules! define_dep_nodes {\n         $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n       ,)*\n     ) => (\n-        static DEP_KINDS: &[DepKindStruct] = &[ $(dep_kind::$variant),* ];\n+        #[macro_export]\n+        macro_rules! make_dep_kind_array {\n+            ($mod:ident) => {[ $(($mod::$variant),)* ]};\n+        }\n+\n+        static DEP_KINDS: &[DepKindStruct] = &make_dep_kind_array!(dep_kind);\n \n         /// This enum serves as an index into the `DEP_KINDS` array.\n         #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]"}, {"sha": "d862db2674ebd02de1076b22e5e897ebbd318de3", "filename": "compiler/rustc_middle/src/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fmod.rs?ref=cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "patch": "@@ -3,6 +3,7 @@ use crate::ty::{self, TyCtxt};\n use rustc_data_structures::profiling::SelfProfilerRef;\n use rustc_data_structures::sync::Lock;\n \n+#[macro_use]\n mod dep_node;\n \n pub use rustc_query_system::dep_graph::{"}, {"sha": "d9e88265050023bfc699eff1e67e38bf277e1166", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "patch": "@@ -76,6 +76,7 @@ pub mod query;\n \n #[macro_use]\n pub mod arena;\n+#[macro_use]\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;"}, {"sha": "a2f3c6eedcb8b9bc08d5e3750a01fdeee7e897eb", "filename": "compiler/rustc_middle/src/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fmod.rs?ref=cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "patch": "@@ -62,6 +62,7 @@ use std::sync::Arc;\n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n+use plumbing::QueryStruct;\n pub(crate) use rustc_query_system::query::CycleError;\n use rustc_query_system::query::*;\n "}, {"sha": "18ae6318a006910057f6722a72525d35356755ba", "filename": "compiler/rustc_middle/src/ty/query/plumbing.rs", "status": "modified", "additions": 141, "deletions": 2, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdc0b199a904fe0318c7a5cf55a610c2ded6ca68/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fplumbing.rs?ref=cdc0b199a904fe0318c7a5cf55a610c2ded6ca68", "patch": "@@ -69,7 +69,8 @@ impl QueryContext for QueryCtxt<'tcx> {\n     }\n \n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode) {\n-        (dep_node.kind.try_load_from_on_disk_cache)(*self, dep_node)\n+        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n+        (cb.try_load_from_on_disk_cache)(*self, dep_node)\n     }\n \n     fn try_force_from_dep_node(&self, dep_node: &DepNode) -> bool {\n@@ -126,7 +127,8 @@ impl QueryContext for QueryCtxt<'tcx> {\n             \"calling force_from_dep_node() on DepKind::codegen_unit\"\n         );\n \n-        (dep_node.kind.force_from_dep_node)(*self, dep_node)\n+        let cb = &super::QUERY_CALLBACKS[dep_node.kind as usize];\n+        (cb.force_from_dep_node)(*self, dep_node)\n     }\n \n     fn has_errors_or_delayed_span_bugs(&self) -> bool {\n@@ -307,6 +309,60 @@ impl<'tcx> Queries<'tcx> {\n     }\n }\n \n+/// This struct stores metadata about each Query.\n+///\n+/// Information is retrieved by indexing the `QUERIES` array using the integer value\n+/// of the `DepKind`. Overall, this allows to implement `QueryContext` using this manual\n+/// jump table instead of large matches.\n+pub struct QueryStruct {\n+    /// The red/green evaluation system will try to mark a specific DepNode in the\n+    /// dependency graph as green by recursively trying to mark the dependencies of\n+    /// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n+    /// where we don't know if it is red or green and we therefore actually have\n+    /// to recompute its value in order to find out. Since the only piece of\n+    /// information that we have at that point is the `DepNode` we are trying to\n+    /// re-evaluate, we need some way to re-run a query from just that. This is what\n+    /// `force_from_dep_node()` implements.\n+    ///\n+    /// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n+    /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n+    /// is usually constructed by computing a stable hash of the query-key that the\n+    /// `DepNode` corresponds to. Consequently, it is not in general possible to go\n+    /// back from hash to query-key (since hash functions are not reversible). For\n+    /// this reason `force_from_dep_node()` is expected to fail from time to time\n+    /// because we just cannot find out, from the `DepNode` alone, what the\n+    /// corresponding query-key is and therefore cannot re-run the query.\n+    ///\n+    /// The system deals with this case letting `try_mark_green` fail which forces\n+    /// the root query to be re-evaluated.\n+    ///\n+    /// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n+    /// Fortunately, we can use some contextual information that will allow us to\n+    /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n+    /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n+    /// valid `DefPathHash`. Since we also always build a huge table that maps every\n+    /// `DefPathHash` in the current codebase to the corresponding `DefId`, we have\n+    /// everything we need to re-run the query.\n+    ///\n+    /// Take the `mir_promoted` query as an example. Like many other queries, it\n+    /// just has a single parameter: the `DefId` of the item it will compute the\n+    /// validated MIR for. Now, when we call `force_from_dep_node()` on a `DepNode`\n+    /// with kind `MirValidated`, we know that the GUID/fingerprint of the `DepNode`\n+    /// is actually a `DefPathHash`, and can therefore just look up the corresponding\n+    /// `DefId` in `tcx.def_path_hash_to_def_id`.\n+    ///\n+    /// When you implement a new query, it will likely have a corresponding new\n+    /// `DepKind`, and you'll have to support it here in `force_from_dep_node()`. As\n+    /// a rule of thumb, if your query takes a `DefId` or `LocalDefId` as sole parameter,\n+    /// then `force_from_dep_node()` should not fail for it. Otherwise, you can just\n+    /// add it to the \"We don't have enough information to reconstruct...\" group in\n+    /// the match below.\n+    pub(crate) force_from_dep_node: fn(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool,\n+\n+    /// Invoke a query to put the on-disk cached value in memory.\n+    pub(crate) try_load_from_on_disk_cache: fn(QueryCtxt<'_>, &DepNode),\n+}\n+\n macro_rules! handle_cycle_error {\n     ([][$tcx: expr, $error:expr]) => {{\n         $tcx.report_cycle($error).emit();\n@@ -545,6 +601,89 @@ macro_rules! define_queries {\n             }\n         })*\n \n+        #[allow(non_upper_case_globals)]\n+        pub mod query_callbacks {\n+            use super::*;\n+            use crate::dep_graph::DepNode;\n+            use crate::ty::query::{queries, query_keys};\n+            use rustc_query_system::dep_graph::DepNodeParams;\n+            use rustc_query_system::query::{force_query, QueryDescription};\n+\n+            // We use this for most things when incr. comp. is turned off.\n+            pub const Null: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, dep_node| bug!(\"force_from_dep_node: encountered {:?}\", dep_node),\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            pub const TraitSelect: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, _| false,\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            pub const CompileCodegenUnit: QueryStruct = QueryStruct {\n+                force_from_dep_node: |_, _| false,\n+                try_load_from_on_disk_cache: |_, _| {},\n+            };\n+\n+            $(pub const $name: QueryStruct = {\n+                const is_anon: bool = is_anon!([$($modifiers)*]);\n+\n+                #[inline(always)]\n+                fn can_reconstruct_query_key() -> bool {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>\n+                        ::can_reconstruct_query_key()\n+                }\n+\n+                fn recover<'tcx>(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<query_keys::$name<'tcx>> {\n+                    <query_keys::$name<'_> as DepNodeParams<TyCtxt<'_>>>::recover(tcx, dep_node)\n+                }\n+\n+                fn force_from_dep_node(tcx: QueryCtxt<'_>, dep_node: &DepNode) -> bool {\n+                    if is_anon {\n+                        return false;\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return false;\n+                    }\n+\n+                    if let Some(key) = recover(*tcx, dep_node) {\n+                        force_query::<queries::$name<'_>, _>(tcx, key, DUMMY_SP, *dep_node);\n+                        return true;\n+                    }\n+\n+                    false\n+                }\n+\n+                fn try_load_from_on_disk_cache(tcx: QueryCtxt<'_>, dep_node: &DepNode) {\n+                    if is_anon {\n+                        return\n+                    }\n+\n+                    if !can_reconstruct_query_key() {\n+                        return\n+                    }\n+\n+                    debug_assert!(tcx.dep_graph\n+                                     .node_color(dep_node)\n+                                     .map(|c| c.is_green())\n+                                     .unwrap_or(false));\n+\n+                    let key = recover(*tcx, dep_node).unwrap_or_else(|| panic!(\"Failed to recover key for {:?} with hash {}\", dep_node, dep_node.hash));\n+                    if queries::$name::cache_on_disk(tcx, &key, None) {\n+                        let _ = tcx.$name(key);\n+                    }\n+                }\n+\n+                QueryStruct {\n+                    force_from_dep_node,\n+                    try_load_from_on_disk_cache,\n+                }\n+            };)*\n+        }\n+\n+        static QUERY_CALLBACKS: &[QueryStruct] = &make_dep_kind_array!(query_callbacks);\n+\n         define_provider_struct! {\n             tcx: $tcx,\n             input: ($(([$($modifiers)*] [$name] [$($K)*] [$V]))*)"}]}