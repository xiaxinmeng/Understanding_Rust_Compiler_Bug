{"sha": "52b01c50cbf001e383fb20bde313f6e58ee6f601", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyYjAxYzUwY2JmMDAxZTM4M2ZiMjBiZGUzMTNmNmU1OGVlNmY2MDE=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-08-06T18:17:06Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2013-08-08T02:41:14Z"}, "message": "extra: External iterators for TreeSet set operations\n\nWrite external iterators for Difference, Sym. Difference, Intersection\nand Union set operations.\n\nThese iterators are generic insofar that they could work on any ordered\nsequence iterators, even though they are type specialized to the\nTreeSetIterator in this case.\n\nLooking at the `check` function in the treeset tests, rustc seems\nunwilling to compile a function resembling::\n\n    fn check<'a, T: Iterator<&'a int>>(... )\n\nso the tests for these iterators are still running the legacy loop\nprotocol.", "tree": {"sha": "c58f398a64c580bcf76a23c23161ae6514faa3f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c58f398a64c580bcf76a23c23161ae6514faa3f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52b01c50cbf001e383fb20bde313f6e58ee6f601", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52b01c50cbf001e383fb20bde313f6e58ee6f601", "html_url": "https://github.com/rust-lang/rust/commit/52b01c50cbf001e383fb20bde313f6e58ee6f601", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52b01c50cbf001e383fb20bde313f6e58ee6f601/comments", "author": null, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ab05f91f49b1248aab7d21630cfb38d6dafacfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ab05f91f49b1248aab7d21630cfb38d6dafacfa", "html_url": "https://github.com/rust-lang/rust/commit/4ab05f91f49b1248aab7d21630cfb38d6dafacfa"}], "stats": {"total": 248, "additions": 134, "deletions": 114}, "files": [{"sha": "051587a74f963262949dbd80927afeb33630f02e", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 134, "deletions": 114, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/52b01c50cbf001e383fb20bde313f6e58ee6f601/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52b01c50cbf001e383fb20bde313f6e58ee6f601/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=52b01c50cbf001e383fb20bde313f6e58ee6f601", "patch": "@@ -433,20 +433,7 @@ impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set has no elements in common with `other`.\n     /// This is equivalent to checking for an empty intersection.\n     fn is_disjoint(&self, other: &TreeSet<T>) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-            match a1.cmp(b1) {\n-              Less => a = x.next(),\n-              Greater => b = y.next(),\n-              Equal => return false\n-            }\n-        }\n-        true\n+        self.intersection(other).next().is_none()\n     }\n \n     /// Return true if the set is a subset of another\n@@ -526,131 +513,164 @@ impl<T: TotalOrd> TreeSet<T> {\n     }\n \n     /// Visit the values (in-order) representing the difference\n-    pub fn difference(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+    pub fn difference<'a>(&'a self, other: &'a TreeSet<T>) -> Difference<'a, T> {\n+        Difference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+    /// Visit the values (in-order) representing the symmetric difference\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> SymDifference<'a, T> {\n+        SymDifference{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+    /// Visit the values (in-order) representing the intersection\n+    pub fn intersection<'a>(&'a self, other: &'a TreeSet<T>)\n+        -> Intersection<'a, T> {\n+        Intersection{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+    /// Visit the values (in-order) representing the union\n+    pub fn union<'a>(&'a self, other: &'a TreeSet<T>) -> Union<'a, T> {\n+        Union{a: Focus::new(self.iter()), b: Focus::new(other.iter())}\n+    }\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy forward iterator over a set\n+pub struct TreeSetIterator<'self, T> {\n+    priv iter: TreeMapIterator<'self, T, ()>\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Equal { a = x.next() }\n-                b = y.next();\n-            }\n-        }\n-        return true;\n-    }\n+// Encapsulate an iterator and hold its latest value until stepped forward\n+struct Focus<A, T> {\n+    priv iter: T,\n+    priv focus: Option<A>,\n+}\n \n-    /// Visit the values (in-order) representing the symmetric difference\n-    pub fn symmetric_difference(&self, other: &TreeSet<T>,\n-                            f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n+impl<A, T: Iterator<A>> Focus<A, T> {\n+    fn new(mut it: T) -> Focus<A, T> {\n+        Focus{focus: it.next(), iter: it}\n+    }\n+    fn step(&mut self) {\n+        self.focus = self.iter.next()\n+    }\n+}\n \n-        let mut a = x.next();\n-        let mut b = y.next();\n+/// Lazy iterator producing elements in the set difference (in-order)\n+pub struct Difference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n-            }\n+/// Lazy iterator producing elements in the set symmetric difference (in-order)\n+pub struct SymDifference<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Intersection<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            let cmp = a1.cmp(b1);\n+/// Lazy iterator producing elements in the set intersection (in-order)\n+pub struct Union<'self, T> {\n+    priv a: Focus<&'self T, TreeSetIterator<'self, T>>,\n+    priv b: Focus<&'self T, TreeSetIterator<'self, T>>,\n+}\n \n-            if cmp == Less {\n-                if !f(a1) { return false; }\n-                a = x.next();\n-            } else {\n-                if cmp == Greater {\n-                    if !f(b1) { return false; }\n-                } else {\n-                    a = x.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        if cmp == Equal { self.a.step() }\n+                        self.b.step();\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n+}\n \n-    /// Visit the values (in-order) representing the intersection\n-    pub fn intersection(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() && b.is_some() {\n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Less {\n-                a = x.next();\n-            } else {\n-                if cmp == Equal {\n-                    if !f(a1) { return false }\n+impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None    ) => { self.a.step(); return ret },\n+                (None    , ret     ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                        return Some(a1);\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Greater {\n+                            return Some(b1);\n+                        } else {\n+                            self.a.step();\n+                        }\n+                    }\n                 }\n-                b = y.next();\n             }\n         }\n-        return true;\n     }\n+}\n \n-    /// Visit the values (in-order) representing the union\n-    pub fn union(&self, other: &TreeSet<T>, f: &fn(&T) -> bool) -> bool {\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-\n-        let mut a = x.next();\n-        let mut b = y.next();\n-\n-        while a.is_some() {\n-            if b.is_none() {\n-                return f(a.unwrap()) && x.advance(f);\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (None    , _       ) => return None,\n+                (_       , None    ) => return None,\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Less {\n+                        self.a.step();\n+                    } else {\n+                        self.b.step();\n+                        if cmp == Equal {\n+                            return Some(a1);\n+                        }\n+                    }\n+                },\n             }\n+        }\n+    }\n+}\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n-\n-            let cmp = a1.cmp(b1);\n-\n-            if cmp == Greater {\n-                if !f(b1) { return false; }\n-                b = y.next();\n-            } else {\n-                if !f(a1) { return false; }\n-                if cmp == Equal {\n-                    b = y.next();\n+impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n+    fn next(&mut self) -> Option<&'self T> {\n+        loop {\n+            match (self.a.focus, self.b.focus) {\n+                (ret     , None) => { self.a.step(); return ret },\n+                (None    , ret ) => { self.b.step(); return ret },\n+                (Some(a1), Some(b1)) => {\n+                    let cmp = a1.cmp(b1);\n+                    if cmp == Greater {\n+                        self.b.step();\n+                        return Some(b1);\n+                    } else {\n+                        self.a.step();\n+                        if cmp == Equal {\n+                            self.b.step();\n+                        }\n+                        return Some(a1);\n+                    }\n                 }\n-                a = x.next();\n             }\n         }\n-        b.iter().advance(|&x| f(x)) && y.advance(f)\n     }\n }\n \n-/// Lazy forward iterator over a set\n-pub struct TreeSetIterator<'self, T> {\n-    priv iter: TreeMapIterator<'self, T, ()>\n-}\n \n // Nodes keep track of their level in the tree, starting at 1 in the\n // leaves and with a red child sharing the level of the parent.\n@@ -1426,7 +1446,7 @@ mod test_set {\n     #[test]\n     fn test_intersection() {\n         fn check_intersection(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.intersection(y, z))\n+            check(a, b, expected, |x, y, f| x.intersection(y).advance(f))\n         }\n \n         check_intersection([], [], []);\n@@ -1442,7 +1462,7 @@ mod test_set {\n     #[test]\n     fn test_difference() {\n         fn check_difference(a: &[int], b: &[int], expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.difference(y, z))\n+            check(a, b, expected, |x, y, f| x.difference(y).advance(f))\n         }\n \n         check_difference([], [], []);\n@@ -1460,7 +1480,7 @@ mod test_set {\n     fn test_symmetric_difference() {\n         fn check_symmetric_difference(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.symmetric_difference(y, z))\n+            check(a, b, expected, |x, y, f| x.symmetric_difference(y).advance(f))\n         }\n \n         check_symmetric_difference([], [], []);\n@@ -1475,7 +1495,7 @@ mod test_set {\n     fn test_union() {\n         fn check_union(a: &[int], b: &[int],\n                                       expected: &[int]) {\n-            check(a, b, expected, |x, y, z| x.union(y, z))\n+            check(a, b, expected, |x, y, f| x.union(y).advance(f))\n         }\n \n         check_union([], [], []);"}]}