{"sha": "5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxOTNjNWQ2MDg4MWUxOWFmZGZiYWI5OGNiYzdiYTZiNzYwN2VlMTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-15T07:57:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-15T07:57:28Z"}, "message": "Rollup merge of #72598 - Aaron1011:feature/fnmut-capture-span, r=nikomatsakis\n\nDisplay information about captured variable in `FnMut` error\n\nFixes #69446\n\nWhen we encounter a region error involving an `FnMut` closure, we\ndisplay a specialized error message. However, we currently do not\ntell the user which upvar was captured. This makes it difficult to\ndetermine the cause of the error, especially when the closure is large.\n\nThis commit records marks constraints involving closure upvars\nwith `ConstraintCategory::ClosureUpvar`. When we decide to 'blame'\na `ConstraintCategory::Return`, we additionall store\nthe captured upvar if we found a `ConstraintCategory::ClosureUpvar` in\nthe path.\n\nWhen generating an error message, we point to relevant spans if we have\nclosure upvar information available. We further customize the message if\nan `async` closure is being returned, to make it clear that the captured\nvariable is being returned indirectly.", "tree": {"sha": "548621e4e5e97d37bff0f91e704cc6d53f6ab0e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/548621e4e5e97d37bff0f91e704cc6d53f6ab0e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe5ynpCRBK7hj4Ov3rIwAAdHIIADdspDk/dSHA6erN9BJmm44Y\nrmJUCgJQ2tvs0CXbH7MaaOuKyZUWiIRwXEIZ5b6v3F4iw9SbFvZGP9jnFFe19frp\nRhRYzF1qq+ebRpIGdldlMzhoYNId9FX09JpS8BWOrMQHvETBNbdJtPWww5agERfm\nU13az7l1CahS97VH2hcA0zexGjR3SqESSkPjhMP1Bo331fgw4+sfDVFhxVMooL3Z\n4RTL7NEqnWMl3WhyG8DN6kn0fJBEnyangm+D8OjxUWLeArZr1msuD7vnzwNIo9BG\nB4qo3WbdET3Vps/o19OWDXj6WRSnd5v0Jr3Z6bCrcP4fU/6o53bSbHWylziwQCQ=\n=+qPU\n-----END PGP SIGNATURE-----\n", "payload": "tree 548621e4e5e97d37bff0f91e704cc6d53f6ab0e8\nparent e6510babc786469075f76db94fedfe651072bf25\nparent 9cee22c1a401ace6dd8633335b131c47a37d7bac\nauthor Ralf Jung <post@ralfj.de> 1592207848 +0200\ncommitter GitHub <noreply@github.com> 1592207848 +0200\n\nRollup merge of #72598 - Aaron1011:feature/fnmut-capture-span, r=nikomatsakis\n\nDisplay information about captured variable in `FnMut` error\n\nFixes #69446\n\nWhen we encounter a region error involving an `FnMut` closure, we\ndisplay a specialized error message. However, we currently do not\ntell the user which upvar was captured. This makes it difficult to\ndetermine the cause of the error, especially when the closure is large.\n\nThis commit records marks constraints involving closure upvars\nwith `ConstraintCategory::ClosureUpvar`. When we decide to 'blame'\na `ConstraintCategory::Return`, we additionall store\nthe captured upvar if we found a `ConstraintCategory::ClosureUpvar` in\nthe path.\n\nWhen generating an error message, we point to relevant spans if we have\nclosure upvar information available. We further customize the message if\nan `async` closure is being returned, to make it clear that the captured\nvariable is being returned indirectly.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "html_url": "https://github.com/rust-lang/rust/commit/5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6510babc786469075f76db94fedfe651072bf25", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6510babc786469075f76db94fedfe651072bf25", "html_url": "https://github.com/rust-lang/rust/commit/e6510babc786469075f76db94fedfe651072bf25"}, {"sha": "9cee22c1a401ace6dd8633335b131c47a37d7bac", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cee22c1a401ace6dd8633335b131c47a37d7bac", "html_url": "https://github.com/rust-lang/rust/commit/9cee22c1a401ace6dd8633335b131c47a37d7bac"}], "stats": {"total": 261, "additions": 203, "deletions": 58}, "files": [{"sha": "9dbc23f5c04c5cea9262c56255e2d94727a84491", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -56,6 +56,7 @@ pub const fn from_generator<T>(gen: T) -> impl Future<Output = T::Return>\n where\n     T: Generator<ResumeTy, Yield = ()>,\n {\n+    #[rustc_diagnostic_item = \"gen_future\"]\n     struct GenFuture<T: Generator<ResumeTy, Yield = ()>>(T);\n \n     // We rely on the fact that async/await futures are immovable in order to create"}, {"sha": "d82faf3e5fbaa4a89d4ece92bd233869a4faf12b", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -183,7 +183,7 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n #[derive(RustcEncodable, RustcDecodable, HashStable)]\n pub enum ConstraintCategory {\n-    Return,\n+    Return(ReturnConstraint),\n     Yield,\n     UseAsConst,\n     UseAsStatic,\n@@ -199,6 +199,7 @@ pub enum ConstraintCategory {\n     SizedBound,\n     Assignment,\n     OpaqueType,\n+    ClosureUpvar(hir::HirId),\n \n     /// A \"boring\" constraint (caused by the given location) is one that\n     /// the user probably doesn't want to see described in diagnostics,\n@@ -216,6 +217,13 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash)]\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub enum ReturnConstraint {\n+    Normal,\n+    ClosureUpvar(hir::HirId),\n+}\n+\n /// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]"}, {"sha": "2e897647a3beb18a32ca9638d881142cc5c0ca80", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -824,7 +824,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     category:\n                         category\n                         @\n-                        (ConstraintCategory::Return\n+                        (ConstraintCategory::Return(_)\n                         | ConstraintCategory::CallArgument\n                         | ConstraintCategory::OpaqueType),\n                     from_closure: false,\n@@ -1147,7 +1147,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         opt_place_desc: Option<&String>,\n     ) -> Option<DiagnosticBuilder<'cx>> {\n         let return_kind = match category {\n-            ConstraintCategory::Return => \"return\",\n+            ConstraintCategory::Return(_) => \"return\",\n             ConstraintCategory::Yield => \"yield\",\n             _ => return None,\n         };\n@@ -1261,7 +1261,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         );\n \n         let msg = match category {\n-            ConstraintCategory::Return | ConstraintCategory::OpaqueType => {\n+            ConstraintCategory::Return(_) | ConstraintCategory::OpaqueType => {\n                 format!(\"{} is returned here\", kind)\n             }\n             ConstraintCategory::CallArgument => {"}, {"sha": "f1923b9e81c66ab23f591e80d3ea07a7d402b051", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -5,9 +5,9 @@ use rustc_infer::infer::{\n     error_reporting::nice_region_error::NiceRegionError,\n     error_reporting::unexpected_hidden_region_diagnostic, NLLRegionVariableOrigin,\n };\n-use rustc_middle::mir::ConstraintCategory;\n+use rustc_middle::mir::{ConstraintCategory, ReturnConstraint};\n use rustc_middle::ty::{self, RegionVid, Ty};\n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, sym};\n use rustc_span::Span;\n \n use crate::util::borrowck_errors;\n@@ -26,7 +26,7 @@ impl ConstraintDescription for ConstraintCategory {\n         // Must end with a space. Allows for empty names to be provided.\n         match self {\n             ConstraintCategory::Assignment => \"assignment \",\n-            ConstraintCategory::Return => \"returning this value \",\n+            ConstraintCategory::Return(_) => \"returning this value \",\n             ConstraintCategory::Yield => \"yielding this value \",\n             ConstraintCategory::UseAsConst => \"using this value as a constant \",\n             ConstraintCategory::UseAsStatic => \"using this value as a static \",\n@@ -37,6 +37,7 @@ impl ConstraintDescription for ConstraintCategory {\n             ConstraintCategory::SizedBound => \"proving this value is `Sized` \",\n             ConstraintCategory::CopyBound => \"copying this value \",\n             ConstraintCategory::OpaqueType => \"opaque type \",\n+            ConstraintCategory::ClosureUpvar(_) => \"closure capture \",\n             ConstraintCategory::Boring\n             | ConstraintCategory::BoringNoLocation\n             | ConstraintCategory::Internal => \"\",\n@@ -306,8 +307,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n \n         let diag = match (category, fr_is_local, outlived_fr_is_local) {\n-            (ConstraintCategory::Return, true, false) if self.is_closure_fn_mut(fr) => {\n-                self.report_fnmut_error(&errci)\n+            (ConstraintCategory::Return(kind), true, false) if self.is_closure_fn_mut(fr) => {\n+                self.report_fnmut_error(&errci, kind)\n             }\n             (ConstraintCategory::Assignment, true, false)\n             | (ConstraintCategory::CallArgument, true, false) => {\n@@ -347,7 +348,11 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     ///            executing...\n     ///    = note: ...therefore, returned references to captured variables will escape the closure\n     /// ```\n-    fn report_fnmut_error(&self, errci: &ErrorConstraintInfo) -> DiagnosticBuilder<'tcx> {\n+    fn report_fnmut_error(\n+        &self,\n+        errci: &ErrorConstraintInfo,\n+        kind: ReturnConstraint,\n+    ) -> DiagnosticBuilder<'tcx> {\n         let ErrorConstraintInfo { outlived_fr, span, .. } = errci;\n \n         let mut diag = self\n@@ -356,19 +361,39 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             .sess\n             .struct_span_err(*span, \"captured variable cannot escape `FnMut` closure body\");\n \n-        // We should check if the return type of this closure is in fact a closure - in that\n-        // case, we can special case the error further.\n-        let return_type_is_closure =\n-            self.regioncx.universal_regions().unnormalized_output_ty.is_closure();\n-        let message = if return_type_is_closure {\n-            \"returns a closure that contains a reference to a captured variable, which then \\\n-             escapes the closure body\"\n-        } else {\n-            \"returns a reference to a captured variable which escapes the closure body\"\n+        let mut output_ty = self.regioncx.universal_regions().unnormalized_output_ty;\n+        if let ty::Opaque(def_id, _) = output_ty.kind {\n+            output_ty = self.infcx.tcx.type_of(def_id)\n+        };\n+\n+        debug!(\"report_fnmut_error: output_ty={:?}\", output_ty);\n+\n+        let message = match output_ty.kind {\n+            ty::Closure(_, _) => {\n+                \"returns a closure that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            ty::Adt(def, _) if self.infcx.tcx.is_diagnostic_item(sym::gen_future, def.did) => {\n+                \"returns an `async` block that contains a reference to a captured variable, which then \\\n+                 escapes the closure body\"\n+            }\n+            _ => \"returns a reference to a captured variable which escapes the closure body\",\n         };\n \n         diag.span_label(*span, message);\n \n+        if let ReturnConstraint::ClosureUpvar(upvar) = kind {\n+            let def_id = match self.regioncx.universal_regions().defining_ty {\n+                DefiningTy::Closure(def_id, _) => def_id,\n+                ty @ _ => bug!(\"unexpected DefiningTy {:?}\", ty),\n+            };\n+\n+            let upvar_def_span = self.infcx.tcx.hir().span(upvar);\n+            let upvar_span = self.infcx.tcx.upvars_mentioned(def_id).unwrap()[&upvar].span;\n+            diag.span_label(upvar_def_span, \"variable defined here\");\n+            diag.span_label(upvar_span, \"variable captured here\");\n+        }\n+\n         match self.give_region_a_name(*outlived_fr).unwrap().source {\n             RegionNameSource::NamedEarlyBoundRegion(fr_span)\n             | RegionNameSource::NamedFreeRegion(fr_span)\n@@ -506,7 +531,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         outlived_fr_name.highlight_region_name(&mut diag);\n \n         match (category, outlived_fr_is_local, fr_is_local) {\n-            (ConstraintCategory::Return, true, _) => {\n+            (ConstraintCategory::Return(_), true, _) => {\n                 diag.span_label(\n                     *span,\n                     format!("}, {"sha": "d099f48adc5c6312534cacd1b74001c90d9eb326", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -216,6 +216,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         &mut flow_inits,\n         &mdpe.move_data,\n         &borrow_set,\n+        &upvars,\n     );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n@@ -2314,30 +2315,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     /// be `self` in the current MIR, because that is the only time we directly access the fields\n     /// of a closure type.\n     pub fn is_upvar_field_projection(&self, place_ref: PlaceRef<'tcx>) -> Option<Field> {\n-        let mut place_projection = place_ref.projection;\n-        let mut by_ref = false;\n-\n-        if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n-            place_projection = proj_base;\n-            by_ref = true;\n-        }\n-\n-        match place_projection {\n-            [base @ .., ProjectionElem::Field(field, _ty)] => {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = Place::ty_from(place_ref.local, base, self.body(), tcx).ty;\n-\n-                if (base_ty.is_closure() || base_ty.is_generator())\n-                    && (!by_ref || self.upvars[field.index()].by_ref)\n-                {\n-                    Some(*field)\n-                } else {\n-                    None\n-                }\n-            }\n-\n-            _ => None,\n-        }\n+        path_utils::is_upvar_field_projection(self.infcx.tcx, &self.upvars, place_ref, self.body())\n     }\n }\n "}, {"sha": "ea68364be37a339aa4e60d8dcf4dbfa78cb97cc6", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -39,6 +39,7 @@ use crate::borrow_check::{\n     renumber,\n     type_check::{self, MirTypeckRegionConstraints, MirTypeckResults},\n     universal_regions::UniversalRegions,\n+    Upvar,\n };\n \n crate type PoloniusOutput = Output<RustcFacts>;\n@@ -166,6 +167,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     flow_inits: &mut ResultsCursor<'cx, 'tcx, MaybeInitializedPlaces<'cx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     borrow_set: &BorrowSet<'tcx>,\n+    upvars: &[Upvar],\n ) -> NllOutput<'tcx> {\n     let mut all_facts = AllFacts::enabled(infcx.tcx).then_some(AllFacts::default());\n \n@@ -188,6 +190,7 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n             flow_inits,\n             move_data,\n             elements,\n+            upvars,\n         );\n \n     if let Some(all_facts) = &mut all_facts {"}, {"sha": "934729553a73be6588cc0f34b4b444cfd89d157e", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,10 +1,11 @@\n use crate::borrow_check::borrow_set::{BorrowData, BorrowSet, TwoPhaseActivation};\n use crate::borrow_check::places_conflict;\n use crate::borrow_check::AccessDepth;\n+use crate::borrow_check::Upvar;\n use crate::dataflow::indexes::BorrowIndex;\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_middle::mir::BorrowKind;\n-use rustc_middle::mir::{BasicBlock, Body, Location, Place};\n+use rustc_middle::mir::{BasicBlock, Body, Field, Location, Place, PlaceRef, ProjectionElem};\n use rustc_middle::ty::TyCtxt;\n \n /// Returns `true` if the borrow represented by `kind` is\n@@ -135,3 +136,38 @@ pub(super) fn borrow_of_local_data(place: Place<'_>) -> bool {\n     // Any errors will be caught on the initial borrow\n     !place.is_indirect()\n }\n+\n+/// If `place` is a field projection, and the field is being projected from a closure type,\n+/// then returns the index of the field being projected. Note that this closure will always\n+/// be `self` in the current MIR, because that is the only time we directly access the fields\n+/// of a closure type.\n+pub(crate) fn is_upvar_field_projection(\n+    tcx: TyCtxt<'tcx>,\n+    upvars: &[Upvar],\n+    place_ref: PlaceRef<'tcx>,\n+    body: &Body<'tcx>,\n+) -> Option<Field> {\n+    let mut place_projection = place_ref.projection;\n+    let mut by_ref = false;\n+\n+    if let [proj_base @ .., ProjectionElem::Deref] = place_projection {\n+        place_projection = proj_base;\n+        by_ref = true;\n+    }\n+\n+    match place_projection {\n+        [base @ .., ProjectionElem::Field(field, _ty)] => {\n+            let base_ty = Place::ty_from(place_ref.local, base, body, tcx).ty;\n+\n+            if (base_ty.is_closure() || base_ty.is_generator())\n+                && (!by_ref || upvars[field.index()].by_ref)\n+            {\n+                Some(*field)\n+            } else {\n+                None\n+            }\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "3e459bd52f75728838147bd09a77246c67b56c7f", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -12,7 +12,7 @@ use rustc_infer::infer::region_constraints::{GenericKind, VarInfos, VerifyBound}\n use rustc_infer::infer::{InferCtxt, NLLRegionVariableOrigin, RegionVariableOrigin};\n use rustc_middle::mir::{\n     Body, ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegionRequirements,\n-    ConstraintCategory, Local, Location,\n+    ConstraintCategory, Local, Location, ReturnConstraint,\n };\n use rustc_middle::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_span::Span;\n@@ -2017,7 +2017,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     | ConstraintCategory::BoringNoLocation\n                     | ConstraintCategory::Internal => false,\n                     ConstraintCategory::TypeAnnotation\n-                    | ConstraintCategory::Return\n+                    | ConstraintCategory::Return(_)\n                     | ConstraintCategory::Yield => true,\n                     _ => constraint_sup_scc != target_scc,\n                 }\n@@ -2042,14 +2042,26 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n-                if categorized_path[i].0 == ConstraintCategory::Return\n+                if matches!(categorized_path[i].0, ConstraintCategory::Return(_))\n                     && next.0 == ConstraintCategory::OpaqueType\n                 {\n                     // The return expression is being influenced by the return type being\n                     // impl Trait, point at the return type and not the return expr.\n                     return *next;\n                 }\n             }\n+\n+            if categorized_path[i].0 == ConstraintCategory::Return(ReturnConstraint::Normal) {\n+                let field = categorized_path.iter().find_map(|p| {\n+                    if let ConstraintCategory::ClosureUpvar(f) = p.0 { Some(f) } else { None }\n+                });\n+\n+                if let Some(field) = field {\n+                    categorized_path[i].0 =\n+                        ConstraintCategory::Return(ReturnConstraint::ClosureUpvar(field));\n+                }\n+            }\n+\n             return categorized_path[i];\n         }\n "}, {"sha": "168612f9beec06f76832a1da662359a4cecedef8", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -55,13 +55,15 @@ use crate::borrow_check::{\n     location::LocationTable,\n     member_constraints::MemberConstraintSet,\n     nll::ToRegionVid,\n+    path_utils,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndex, PlaceholderIndices, RegionValueElements,\n     },\n     region_infer::{ClosureRegionRequirementsExt, TypeTest},\n     renumber,\n     type_check::free_region_relations::{CreateResult, UniversalRegionRelations},\n     universal_regions::{DefiningTy, UniversalRegions},\n+    Upvar,\n };\n \n macro_rules! span_mirbug {\n@@ -132,6 +134,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n     flow_inits: &mut ResultsCursor<'mir, 'tcx, MaybeInitializedPlaces<'mir, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n     elements: &Rc<RegionValueElements>,\n+    upvars: &[Upvar],\n ) -> MirTypeckResults<'tcx> {\n     let implicit_region_bound = infcx.tcx.mk_region(ty::ReVar(universal_regions.fr_fn_body));\n     let mut constraints = MirTypeckRegionConstraints {\n@@ -162,6 +165,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         borrow_set,\n         all_facts,\n         constraints: &mut constraints,\n+        upvars,\n     };\n \n     let opaque_type_values = type_check_internal(\n@@ -577,7 +581,7 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n         for constraint in constraints.outlives().iter() {\n             let mut constraint = *constraint;\n             constraint.locations = locations;\n-            if let ConstraintCategory::Return\n+            if let ConstraintCategory::Return(_)\n             | ConstraintCategory::UseAsConst\n             | ConstraintCategory::UseAsStatic = constraint.category\n             {\n@@ -827,6 +831,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n     all_facts: &'a mut Option<AllFacts>,\n     borrow_set: &'a BorrowSet<'tcx>,\n     constraints: &'a mut MirTypeckRegionConstraints<'tcx>,\n+    upvars: &'a [Upvar],\n }\n \n crate struct MirTypeckResults<'tcx> {\n@@ -1420,7 +1425,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -1703,7 +1708,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 ConstraintCategory::UseAsConst\n                             }\n                         } else {\n-                            ConstraintCategory::Return\n+                            ConstraintCategory::Return(ReturnConstraint::Normal)\n                         }\n                     }\n                     Some(l) if !body.local_decls[l].is_user_variable() => {\n@@ -2489,14 +2494,26 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         );\n \n         let mut cursor = borrowed_place.projection.as_ref();\n+        let tcx = self.infcx.tcx;\n+        let field = path_utils::is_upvar_field_projection(\n+            tcx,\n+            &self.borrowck_context.upvars,\n+            borrowed_place.as_ref(),\n+            body,\n+        );\n+        let category = if let Some(field) = field {\n+            ConstraintCategory::ClosureUpvar(self.borrowck_context.upvars[field.index()].var_hir_id)\n+        } else {\n+            ConstraintCategory::Boring\n+        };\n+\n         while let [proj_base @ .., elem] = cursor {\n             cursor = proj_base;\n \n             debug!(\"add_reborrow_constraint - iteration {:?}\", elem);\n \n             match elem {\n                 ProjectionElem::Deref => {\n-                    let tcx = self.infcx.tcx;\n                     let base_ty = Place::ty_from(borrowed_place.local, proj_base, body, tcx).ty;\n \n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n@@ -2506,7 +2523,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                                 sup: ref_region.to_region_vid(),\n                                 sub: borrow_region.to_region_vid(),\n                                 locations: location.to_locations(),\n-                                category: ConstraintCategory::Boring,\n+                                category,\n                             });\n \n                             match mutbl {"}, {"sha": "842115538c9d85058e8b30cc754772f4bed4402a", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.rs?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -0,0 +1,22 @@\n+// Regression test for issue #69446 - we should display\n+// which variable is captured\n+// edition:2018\n+\n+use core::future::Future;\n+\n+struct Foo;\n+impl Foo {\n+    fn foo(&mut self) {}\n+}\n+\n+async fn bar<T>(_: impl FnMut() -> T)\n+where\n+    T: Future<Output = ()>,\n+{}\n+\n+fn main() {\n+    let mut x = Foo;\n+    bar(move || async { //~ ERROR captured\n+        x.foo();\n+    });\n+}"}, {"sha": "3d2b0402bc52c614564988f0e53b8705b0691acf", "filename": "src/test/ui/async-await/issue-69446-fnmut-capture.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissue-69446-fnmut-capture.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -0,0 +1,19 @@\n+error: captured variable cannot escape `FnMut` closure body\n+  --> $DIR/issue-69446-fnmut-capture.rs:19:17\n+   |\n+LL |       let mut x = Foo;\n+   |           ----- variable defined here\n+LL |       bar(move || async {\n+   |  _______________-_^\n+   | |               |\n+   | |               inferred to be a `FnMut` closure\n+LL | |         x.foo();\n+   | |         - variable captured here\n+LL | |     });\n+   | |_____^ returns an `async` block that contains a reference to a captured variable, which then escapes the closure body\n+   |\n+   = note: `FnMut` closures only have access to their captured variables while they are executing...\n+   = note: ...therefore, they cannot allow references to captured variables to escape\n+\n+error: aborting due to previous error\n+"}, {"sha": "4144d70cc16012dd62579e8c6dcd34093e9a7ba0", "filename": "src/test/ui/borrowck/borrowck-describe-lvalue.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-describe-lvalue.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -21,10 +21,13 @@ LL |                    *y = 1;\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/borrowck-describe-lvalue.rs:264:16\n    |\n+LL |           let mut x = 0;\n+   |               ----- variable defined here\n LL |              || {\n    |               - inferred to be a `FnMut` closure\n LL | /                || {\n LL | |                    let y = &mut x;\n+   | |                                 - variable captured here\n LL | |                    &mut x;\n LL | |                    *y = 1;\n LL | |                    drop(y);"}, {"sha": "54df40b6e3d05bda35530bfc79366ef51edd57d6", "filename": "src/test/ui/issues/issue-40510-1.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-1.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,10 +1,16 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-40510-1.rs:7:9\n    |\n+LL |     let mut x: Box<()> = Box::new(());\n+   |         ----- variable defined here\n+LL | \n LL |     || {\n    |      - inferred to be a `FnMut` closure\n LL |         &mut x\n-   |         ^^^^^^ returns a reference to a captured variable which escapes the closure body\n+   |         ^^^^^-\n+   |         |    |\n+   |         |    variable captured here\n+   |         returns a reference to a captured variable which escapes the closure body\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing...\n    = note: ...therefore, they cannot allow references to captured variables to escape"}, {"sha": "cb885ec7d952aa67802b6e4ade19a7c815f58072", "filename": "src/test/ui/issues/issue-40510-3.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-40510-3.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,10 +1,14 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-40510-3.rs:7:9\n    |\n+LL |       let mut x: Vec<()> = Vec::new();\n+   |           ----- variable defined here\n+LL | \n LL |       || {\n    |        - inferred to be a `FnMut` closure\n LL | /         || {\n LL | |             x.push(())\n+   | |             - variable captured here\n LL | |         }\n    | |_________^ returns a closure that contains a reference to a captured variable, which then escapes the closure body\n    |"}, {"sha": "2fec482543d7b410970857aa40ad1bbd5799e6a8", "filename": "src/test/ui/issues/issue-49824.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-49824.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,11 +1,14 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-49824.rs:4:9\n    |\n+LL |       let mut x = 0;\n+   |           ----- variable defined here\n LL |       || {\n    |        - inferred to be a `FnMut` closure\n LL | /         || {\n LL | |\n LL | |             let _y = &mut x;\n+   | |                           - variable captured here\n LL | |         }\n    | |_________^ returns a closure that contains a reference to a captured variable, which then escapes the closure body\n    |"}, {"sha": "87ffe9b1abf456d26abc45aaa18a0902cf8bf2b1", "filename": "src/test/ui/nll/issue-53040.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-53040.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,9 +1,13 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/issue-53040.rs:3:8\n    |\n+LL |     let mut v: Vec<()> = Vec::new();\n+   |         ----- variable defined here\n LL |     || &mut v;\n-   |      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n-   |      |\n+   |      - ^^^^^-\n+   |      | |    |\n+   |      | |    variable captured here\n+   |      | returns a reference to a captured variable which escapes the closure body\n    |      inferred to be a `FnMut` closure\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing..."}, {"sha": "b087e03b464b38586c017af38eeac10233991ac9", "filename": "src/test/ui/regions/regions-return-ref-to-upvar-issue-17403.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5193c5d60881e19afdfbab98cbc7ba6b7607ee18/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-return-ref-to-upvar-issue-17403.stderr?ref=5193c5d60881e19afdfbab98cbc7ba6b7607ee18", "patch": "@@ -1,9 +1,13 @@\n error: captured variable cannot escape `FnMut` closure body\n   --> $DIR/regions-return-ref-to-upvar-issue-17403.rs:7:24\n    |\n+LL |         let mut x = 0;\n+   |             ----- variable defined here\n LL |         let mut f = || &mut x;\n-   |                      - ^^^^^^ returns a reference to a captured variable which escapes the closure body\n-   |                      |\n+   |                      - ^^^^^-\n+   |                      | |    |\n+   |                      | |    variable captured here\n+   |                      | returns a reference to a captured variable which escapes the closure body\n    |                      inferred to be a `FnMut` closure\n    |\n    = note: `FnMut` closures only have access to their captured variables while they are executing..."}]}