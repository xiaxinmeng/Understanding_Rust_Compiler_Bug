{"sha": "86bf96291d8222dbec9e07461404ecb189be0a98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2YmY5NjI5MWQ4MjIyZGJlYzllMDc0NjE0MDRlY2IxODliZTBhOTg=", "commit": {"author": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2019-12-15T19:05:25Z"}, "committer": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2020-02-09T14:48:52Z"}, "message": "Implement split_inclusive for slice and str, an splitting iterator that includes the matched part in the iterated substrings as a terminator.", "tree": {"sha": "3271b1a4a02101eafcb4c01007b0825ea43b0d6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3271b1a4a02101eafcb4c01007b0825ea43b0d6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86bf96291d8222dbec9e07461404ecb189be0a98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86bf96291d8222dbec9e07461404ecb189be0a98", "html_url": "https://github.com/rust-lang/rust/commit/86bf96291d8222dbec9e07461404ecb189be0a98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86bf96291d8222dbec9e07461404ecb189be0a98/comments", "author": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8647aa1a2ce279f8ec7cc5252d10b8cb9ea504eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/8647aa1a2ce279f8ec7cc5252d10b8cb9ea504eb", "html_url": "https://github.com/rust-lang/rust/commit/8647aa1a2ce279f8ec7cc5252d10b8cb9ea504eb"}], "stats": {"total": 423, "additions": 422, "deletions": 1}, "files": [{"sha": "ea75f8903c3685fdd73203a18a810889c2e49615", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=86bf96291d8222dbec9e07461404ecb189be0a98", "patch": "@@ -12,6 +12,7 @@\n #![feature(binary_heap_into_iter_sorted)]\n #![feature(binary_heap_drain_sorted)]\n #![feature(vec_remove_item)]\n+#![feature(split_inclusive)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "9e903b16a2621dd79acd27c4e015b3e9ede3f95c", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=86bf96291d8222dbec9e07461404ecb189be0a98", "patch": "@@ -851,6 +851,26 @@ fn test_splitator() {\n     assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n }\n \n+#[test]\n+fn test_splitator_inclusive() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5], &[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5], &[]];\n+    assert_eq!(xs.split_inclusive(|_| true).collect::<Vec<&[i32]>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n+}\n+\n #[test]\n fn test_splitnator() {\n     let xs = &[1, 2, 3, 4, 5];"}, {"sha": "fc2fcb6e5693906ce1049efd58a0eb49e27bb9d9", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=86bf96291d8222dbec9e07461404ecb189be0a98", "patch": "@@ -1247,6 +1247,24 @@ fn test_split_char_iterator_no_trailing() {\n     assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n+#[test]\n+fn test_split_char_iterator_inclusive() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').collect();\n+    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\", \"\"]);\n+\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut first_char = true;\n+    let split: Vec<&str> = uppercase_separated.split_inclusive(|c: char| {\n+        let split = !first_char && c.is_uppercase();\n+        first_char = split;\n+        split\n+    }).collect();\n+    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\", \"\"]);\n+}\n+\n+\n #[test]\n fn test_rsplit() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "202ffc390e4c39300ddc5bc07c042e42fe300917", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 260, "deletions": 1, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=86bf96291d8222dbec9e07461404ecb189be0a98", "patch": "@@ -1155,6 +1155,72 @@ impl<T> [T] {\n         SplitMut { v: self, pred, finished: false }\n     }\n \n+    /// Returns an iterator over subslices separated by elements that match\n+    /// `pred`. The matched element is contained in the end of the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    #[inline]\n+    pub fn split_inclusive<F>(&self, pred: F) -> SplitInclusive<'_, T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SplitInclusive {\n+            v: self,\n+            pred,\n+            finished: false\n+        }\n+    }\n+\n+    /// Returns an iterator over mutable subslices separated by elements that\n+    /// match `pred`. The matched element is contained in the previous\n+    /// subslice as a terminator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let mut v = [10, 40, 30, 20, 60, 50];\n+    ///\n+    /// for group in v.split_inclusive_mut(|num| *num % 3 == 0) {\n+    ///     let terminator_idx = group.len()-1;\n+    ///     group[terminator_idx] = 1;\n+    /// }\n+    /// assert_eq!(v, [10, 40, 1, 20, 1, 1]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    #[inline]\n+    pub fn split_inclusive_mut<F>(&mut self, pred: F) -> SplitInclusiveMut<'_, T, F>\n+        where F: FnMut(&T) -> bool\n+    {\n+        SplitInclusiveMut { v: self, pred, finished: false }\n+    }\n+\n     /// Returns an iterator over subslices separated by elements that match\n     /// `pred`, starting at the end of the slice and working backwards.\n     /// The matched element is not contained in the subslices.\n@@ -3675,7 +3741,100 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n \n-/// An iterator over the subslices of the vector which are separated\n+/// An iterator over subslices separated by elements that match a predicate\n+/// function. Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [slices].\n+///\n+/// [`split_inclusive`]: ../../std/primitive.slice.html#method.split_inclusive\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+pub struct SplitInclusive<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    v: &'a [T],\n+    pred: P,\n+    finished: bool\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<T, P> Clone for SplitInclusive<'_, T, P> where P: Clone + FnMut(&T) -> bool {\n+    fn clone(&self) -> Self {\n+        SplitInclusive {\n+            v: self.v,\n+            pred: self.pred.clone(),\n+            finished: self.finished,\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> Iterator for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().position(|x| (self.pred)(x)) {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let ret = Some(&self.v[..idx + 1]);\n+                self.v = &self.v[idx + 1..];\n+                ret\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n+        if self.finished { return None; }\n+\n+        match self.v.iter().rposition(|x| (self.pred)(x)) {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let ret = Some(&self.v[idx + 1..]);\n+                self.v = &self.v[..idx];\n+                ret\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> SplitIter for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a [T]> {\n+        if self.finished { None } else { self.finished = true; Some(self.v) }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n+/// An iterator over the mutable subslices of the vector which are separated\n /// by elements that match `pred`.\n ///\n /// This struct is created by the [`split_mut`] method on [slices].\n@@ -3789,6 +3948,106 @@ where\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n \n+/// An iterator over the mutable subslices of the vector which are separated\n+/// by elements that match `pred`. Unlike `SplitMut`, it contains the matched\n+/// parts in the ends of the subslices.\n+///\n+/// This struct is created by the [`split_inclusive_mut`] method on [slices].\n+///\n+/// [`split_inclusive_mut`]: ../../std/primitive.slice.html#method.split_inclusive_mut\n+/// [slices]: ../../std/primitive.slice.html\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+pub struct SplitInclusiveMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+    v: &'a mut [T],\n+    pred: P,\n+    finished: bool\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusiveMut\")\n+            .field(\"v\", &self.v)\n+            .field(\"finished\", &self.finished)\n+            .finish()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> SplitIter for SplitInclusiveMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    #[inline]\n+    fn finish(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished {\n+            None\n+        } else {\n+            self.finished = true;\n+            Some(mem::replace(&mut self.v, &mut []))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P> where P: FnMut(&T) -> bool {\n+    type Item = &'a mut [T];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let idx_opt = { // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().position(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.split_at_mut(idx+1);\n+                self.v = tail;\n+                Some(head)\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        if self.finished {\n+            (0, Some(0))\n+        } else {\n+            // if the predicate doesn't match anything, we yield one slice\n+            // if it matches every element, we yield len+1 empty slices.\n+            (1, Some(self.v.len() + 1))\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P> where\n+    P: FnMut(&T) -> bool,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n+        if self.finished { return None; }\n+\n+        let idx_opt = { // work around borrowck limitations\n+            let pred = &mut self.pred;\n+            self.v.iter().rposition(|x| (*pred)(x))\n+        };\n+        match idx_opt {\n+            None => self.finish(),\n+            Some(idx) => {\n+                let tmp = mem::replace(&mut self.v, &mut []);\n+                let (head, tail) = tmp.split_at_mut(idx+1);\n+                self.v = head;\n+                Some(tail)\n+            }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n+\n /// An iterator over subslices separated by elements that match a predicate\n /// function, starting from the end of the slice.\n ///"}, {"sha": "3f7defa912bb1502453f653b7e11c036f0f8ec48", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86bf96291d8222dbec9e07461404ecb189be0a98/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=86bf96291d8222dbec9e07461404ecb189be0a98", "patch": "@@ -1132,6 +1132,21 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n         }\n     }\n \n+    #[inline]\n+    fn next_inclusive(&mut self) -> Option<&'a str> {\n+        if self.finished { return None }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(self.start..b);\n+                self.start = b;\n+                Some(elt)\n+            },\n+            None => self.get_end(),\n+        }\n+    }\n+\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str>\n     where\n@@ -1168,6 +1183,34 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n             },\n         }\n     }\n+\n+    #[inline]\n+    fn next_back_inclusive(&mut self) -> Option<&'a str>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        if self.finished { return None }\n+\n+        if !self.allow_trailing_empty {\n+            self.allow_trailing_empty = true;\n+            match self.next_back() {\n+                Some(elt) if !elt.is_empty() => return Some(elt),\n+                _ => if self.finished { return None }\n+            }\n+        }\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n+            Some((_, b)) => unsafe {\n+                let elt = haystack.get_unchecked(b..self.end);\n+                self.end = b;\n+                Some(elt)\n+            },\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.get_unchecked(self.start..self.end))\n+            },\n+        }\n+    }\n }\n \n generate_pattern_iterators! {\n@@ -3212,6 +3255,31 @@ impl str {\n         })\n     }\n \n+    /// An iterator over substrings of this string slice, separated by\n+    /// characters matched by a pattern. Differs from the iterator produced by\n+    /// `split` in that `split_inclusive` leaves the matched part as the\n+    /// terminator of the substring.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    #[inline]\n+    pub fn split_inclusive<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitInclusive<'a, P> {\n+        SplitInclusive(SplitInternal {\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n+            allow_trailing_empty: true,\n+            finished: false,\n+        })\n+    }\n+\n     /// An iterator over substrings of the given string slice, separated by\n     /// characters matched by a pattern and yielded in reverse order.\n     ///\n@@ -4405,6 +4473,19 @@ pub struct SplitAsciiWhitespace<'a> {\n     inner: Map<Filter<SliceSplit<'a, u8, IsAsciiWhitespace>, BytesIsNotEmpty>, UnsafeBytesToStr>,\n }\n \n+/// An iterator over the substrings of a string,\n+/// terminated by a substring matching to a predicate function\n+/// Unlike `Split`, it contains the matched part as a terminator\n+/// of the subslice.\n+///\n+/// This struct is created by the [`split_inclusive`] method on [`str`].\n+/// See its documentation for more.\n+///\n+/// [`split_inclusive`]: ../../std/primitive.str.html#method.split_inclusive\n+/// [`str`]: ../../std/primitive.str.html\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n+\n impl_fn_for_zst! {\n     #[derive(Clone)]\n     struct IsWhitespace impl Fn = |c: char| -> bool {\n@@ -4433,6 +4514,8 @@ impl_fn_for_zst! {\n     };\n }\n \n+\n+\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n@@ -4495,6 +4578,46 @@ impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n impl FusedIterator for SplitAsciiWhitespace<'_> {}\n \n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SplitInclusive\")\n+            .field(\"0\", &self.0)\n+            .finish()\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n+    fn clone(&self) -> Self {\n+        SplitInclusive(self.0.clone())\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n+    for SplitInclusive<'a, P>\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back_inclusive()\n+    }\n+}\n+\n+#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n+\n /// An iterator of [`u16`] over the string encoded as UTF-16.\n ///\n /// [`u16`]: ../../std/primitive.u16.html"}]}