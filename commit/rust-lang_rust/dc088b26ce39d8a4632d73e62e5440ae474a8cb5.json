{"sha": "dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMDg4YjI2Y2UzOWQ4YTQ2MzJkNzNlNjJlNTQ0MGFlNDc0YThjYjU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-02T08:06:01Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-07-02T08:16:33Z"}, "message": "refactor check_for_substitution\n\nNo behavior change, just flatter and simpler code", "tree": {"sha": "9e87810ec1ccea4f5cd309266ad86aafe3dc9745", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e87810ec1ccea4f5cd309266ad86aafe3dc9745"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "html_url": "https://github.com/rust-lang/rust/commit/dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc088b26ce39d8a4632d73e62e5440ae474a8cb5/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40ab9d2bd57a2203131abd723f7120e960299fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/40ab9d2bd57a2203131abd723f7120e960299fae", "html_url": "https://github.com/rust-lang/rust/commit/40ab9d2bd57a2203131abd723f7120e960299fae"}], "stats": {"total": 139, "additions": 72, "deletions": 67}, "files": [{"sha": "2309ead55b29673da5cff3a6ca396589b66b2a0b", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dc088b26ce39d8a4632d73e62e5440ae474a8cb5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc088b26ce39d8a4632d73e62e5440ae474a8cb5/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "patch": "@@ -84,28 +84,6 @@ impl<'a> StringReader<'a> {\n         Ok(ret_val)\n     }\n \n-    /// Immutably extract string if found at current position with given delimiters\n-    fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<String> {\n-        let mut pos = self.pos;\n-        let mut idx = self.src_index(pos);\n-        let mut ch = char_at(&self.src, idx);\n-        if ch != from_ch {\n-            return None;\n-        }\n-        pos = pos + Pos::from_usize(ch.len_utf8());\n-        let start_pos = pos;\n-        idx = self.src_index(pos);\n-        while idx < self.end_src_index {\n-            ch = char_at(&self.src, idx);\n-            if ch == to_ch {\n-                return Some(self.src[self.src_index(start_pos)..self.src_index(pos)].to_string());\n-            }\n-            pos = pos + Pos::from_usize(ch.len_utf8());\n-            idx = self.src_index(pos);\n-        }\n-        return None;\n-    }\n-\n     fn try_real_token(&mut self) -> Result<Token, ()> {\n         let mut t = self.try_next_token()?;\n         loop {"}, {"sha": "6a870685938a04bb8463baf75a5c22b463b5e234", "filename": "src/libsyntax/parse/lexer/unicode_chars.rs", "status": "modified", "additions": 72, "deletions": 45, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/dc088b26ce39d8a4632d73e62e5440ae474a8cb5/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc088b26ce39d8a4632d73e62e5440ae474a8cb5/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=dc088b26ce39d8a4632d73e62e5440ae474a8cb5", "patch": "@@ -1,10 +1,11 @@\n // Characters and their corresponding confusables were collected from\n // http://www.unicode.org/Public/security/10.0.0/confusables.txt\n \n-use syntax_pos::{Span, Pos, NO_EXPANSION};\n-use errors::{Applicability, DiagnosticBuilder};\n use super::StringReader;\n+use errors::{Applicability, DiagnosticBuilder};\n+use syntax_pos::{Pos, Span, NO_EXPANSION};\n \n+#[rustfmt::skip] // for line breaks\n const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\u2028', \"Line Separator\", ' '),\n     ('\u2029', \"Paragraph Separator\", ' '),\n@@ -293,8 +294,8 @@ const UNICODE_ARRAY: &[(char, &str, char)] = &[\n     ('\u232a', \"Right-Pointing Angle Bracket\", '>'),\n     ('\u3009', \"Right Angle Bracket\", '>'),\n     ('\u300b', \"Right Double Angle Bracket\", '>'),\n-    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'), ];\n-\n+    ('\uff1e', \"Fullwidth Greater-Than Sign\", '>'),\n+];\n \n const ASCII_ARRAY: &[(char, &str)] = &[\n     (' ', \"Space\"),\n@@ -321,46 +322,72 @@ const ASCII_ARRAY: &[(char, &str)] = &[\n     ('+', \"Plus Sign\"),\n     ('<', \"Less-Than Sign\"),\n     ('=', \"Equals Sign\"),\n-    ('>', \"Greater-Than Sign\"), ];\n-\n-crate fn check_for_substitution<'a>(reader: &StringReader<'a>,\n-                                  ch: char,\n-                                  err: &mut DiagnosticBuilder<'a>) -> bool {\n-    UNICODE_ARRAY\n-    .iter()\n-    .find(|&&(c, _, _)| c == ch)\n-    .map(|&(_, u_name, ascii_char)| {\n-        let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n-        match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n-            Some(&(ascii_char, ascii_name)) => {\n-                // special help suggestion for \"directed\" double quotes\n-                if let Some(s) = reader.peek_delimited('\u201c', '\u201d') {\n-                    let msg = format!(\"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n-                        '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n-                                ascii_char, ascii_name);\n-                    err.span_suggestion(\n-                        Span::new(reader.pos, reader.next_pos + Pos::from_usize(s.len()) +\n-                            Pos::from_usize('\u201d'.len_utf8()), NO_EXPANSION),\n-                        &msg,\n-                        format!(\"\\\"{}\\\"\", s),\n-                        Applicability::MaybeIncorrect);\n-                } else {\n-                    let msg =\n-                        format!(\"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n-                                ch, u_name, ascii_char, ascii_name);\n-                    err.span_suggestion(\n-                        span,\n-                        &msg,\n-                        ascii_char.to_string(),\n-                        Applicability::MaybeIncorrect);\n-                }\n-                true\n-            },\n-            None => {\n-                let msg = format!(\"substitution character not found for '{}'\", ch);\n-                reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n-                false\n-            }\n+    ('>', \"Greater-Than Sign\"),\n+];\n+\n+crate fn check_for_substitution<'a>(\n+    reader: &StringReader<'a>,\n+    ch: char,\n+    err: &mut DiagnosticBuilder<'a>,\n+) -> bool {\n+    let (u_name, ascii_char) = match UNICODE_ARRAY.iter().find(|&&(c, _, _)| c == ch) {\n+        Some(&(_u_char, u_name, ascii_char)) => (u_name, ascii_char),\n+        None => return false,\n+    };\n+\n+    let span = Span::new(reader.pos, reader.next_pos, NO_EXPANSION);\n+\n+    let ascii_name = match ASCII_ARRAY.iter().find(|&&(c, _)| c == ascii_char) {\n+        Some((_ascii_char, ascii_name)) => ascii_name,\n+        None => {\n+            let msg = format!(\"substitution character not found for '{}'\", ch);\n+            reader.sess.span_diagnostic.span_bug_no_panic(span, &msg);\n+            return false\n+        },\n+    };\n+\n+    // special help suggestion for \"directed\" double quotes\n+    if let Some(s) = reader.peek_delimited('\u201c', '\u201d') {\n+        let msg = format!(\n+            \"Unicode characters '\u201c' (Left Double Quotation Mark) and \\\n+             '\u201d' (Right Double Quotation Mark) look like '{}' ({}), but are not\",\n+            ascii_char, ascii_name\n+        );\n+        err.span_suggestion(\n+            Span::new(\n+                reader.pos,\n+                reader.next_pos + Pos::from_usize(s.len()) + Pos::from_usize('\u201d'.len_utf8()),\n+                NO_EXPANSION,\n+            ),\n+            &msg,\n+            format!(\"\\\"{}\\\"\", s),\n+            Applicability::MaybeIncorrect,\n+        );\n+    } else {\n+        let msg = format!(\n+            \"Unicode character '{}' ({}) looks like '{}' ({}), but it is not\",\n+            ch, u_name, ascii_char, ascii_name\n+        );\n+        err.span_suggestion(\n+            span,\n+            &msg,\n+            ascii_char.to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+    true\n+}\n+\n+impl StringReader<'_> {\n+    /// Immutably extract string if found at current position with given delimiters\n+    fn peek_delimited(&self, from_ch: char, to_ch: char) -> Option<&str> {\n+        let tail = &self.src[self.src_index(self.pos)..];\n+        let mut chars = tail.chars();\n+        let first_char = chars.next()?;\n+        if first_char != from_ch {\n+            return None;\n         }\n-    }).unwrap_or(false)\n+        let last_char_idx = chars.as_str().find(to_ch)?;\n+        Some(&chars.as_str()[..last_char_idx])\n+    }\n }"}]}