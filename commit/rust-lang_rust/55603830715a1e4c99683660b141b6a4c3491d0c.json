{"sha": "55603830715a1e4c99683660b141b6a4c3491d0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NjAzODMwNzE1YTFlNGM5OTY4MzY2MGIxNDFiNmE0YzM0OTFkMGM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-21T01:52:00Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-22T15:57:58Z"}, "message": "std: Add an I/O reader method to fill a buffer\n\nI've found a common use case being to fill a slice (not an owned vector)\ncompletely with bytes. It's posible for short reads to happen, and if you're\ntrying to get an exact number of bytes then this helper will be useful.", "tree": {"sha": "405c8ef196c3823cab262be353e9cfa9a525d2dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/405c8ef196c3823cab262be353e9cfa9a525d2dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55603830715a1e4c99683660b141b6a4c3491d0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55603830715a1e4c99683660b141b6a4c3491d0c", "html_url": "https://github.com/rust-lang/rust/commit/55603830715a1e4c99683660b141b6a4c3491d0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55603830715a1e4c99683660b141b6a4c3491d0c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e233a43f5a0e14ceb322b955b16c8967adb2f4a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e233a43f5a0e14ceb322b955b16c8967adb2f4a8", "html_url": "https://github.com/rust-lang/rust/commit/e233a43f5a0e14ceb322b955b16c8967adb2f4a8"}], "stats": {"total": 45, "additions": 38, "deletions": 7}, "files": [{"sha": "5f3b88d5205788a4803857d47dee8f28aa64c2d7", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=55603830715a1e4c99683660b141b6a4c3491d0c", "patch": "@@ -87,7 +87,7 @@ impl<R: Reader> BufferedReader<R> {\n }\n \n impl<R: Reader> Buffer for BufferedReader<R> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos == self.cap {\n             self.cap = try!(self.inner.read(self.buf));\n             self.pos = 0;\n@@ -104,7 +104,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n impl<R: Reader> Reader for BufferedReader<R> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let nread = {\n-            let available = try!(self.fill());\n+            let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n             slice::bytes::copy_memory(buf, available.slice_to(nread));\n             nread\n@@ -336,7 +336,7 @@ impl<S: Stream> BufferedStream<S> {\n }\n \n impl<S: Stream> Buffer for BufferedStream<S> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill() }\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> { self.inner.fill_buf() }\n     fn consume(&mut self, amt: uint) { self.inner.consume(amt) }\n }\n "}, {"sha": "7ae717cfccf971c0bb059a8b93db298c5dac8127", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=55603830715a1e4c99683660b141b6a4c3491d0c", "patch": "@@ -190,7 +190,7 @@ impl Seek for MemReader {\n }\n \n impl Buffer for MemReader {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n@@ -322,7 +322,7 @@ impl<'a> Seek for BufReader<'a> {\n }\n \n impl<'a> Buffer for BufReader<'a> {\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n             Ok(self.buf.slice_from(self.pos))\n         } else {\n@@ -555,4 +555,18 @@ mod test {\n         let mut r = BufWriter::new(buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n     }\n+\n+    #[test]\n+    fn io_fill() {\n+        let mut r = MemReader::new(~[1, 2, 3, 4, 5, 6, 7, 8]);\n+        let mut buf = [0, ..3];\n+        assert_eq!(r.fill(buf), Ok(()));\n+        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(r.fill(buf.mut_slice_to(0)), Ok(()));\n+        assert_eq!(buf.as_slice(), &[1, 2, 3]);\n+        assert_eq!(r.fill(buf), Ok(()));\n+        assert_eq!(buf.as_slice(), &[4, 5, 6]);\n+        assert!(r.fill(buf).is_err());\n+        assert_eq!(buf.as_slice(), &[7, 8, 6]);\n+    }\n }"}, {"sha": "6bd8f119ba29b408f9036f2802b6ed26786e384a", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55603830715a1e4c99683660b141b6a4c3491d0c/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=55603830715a1e4c99683660b141b6a4c3491d0c", "patch": "@@ -360,6 +360,23 @@ pub trait Reader {\n         }\n     }\n \n+    /// Fills the provided slice with bytes from this reader\n+    ///\n+    /// This will continue to call `read` until the slice has been completely\n+    /// filled with bytes.\n+    ///\n+    /// # Error\n+    ///\n+    /// If an error occurs at any point, that error is returned, and no further\n+    /// bytes are read.\n+    fn fill(&mut self, buf: &mut [u8]) -> IoResult<()> {\n+        let mut read = 0;\n+        while read < buf.len() {\n+            read += try!(self.read(buf.mut_slice_from(read)));\n+        }\n+        Ok(())\n+    }\n+\n     /// Reads exactly `len` bytes and appends them to a vector.\n     ///\n     /// May push fewer than the requested number of bytes on error\n@@ -1045,7 +1062,7 @@ pub trait Buffer: Reader {\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error. Note that it is not an error to return a\n     /// 0-length buffer.\n-    fn fill<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n+    fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `fill` or `read`.\n@@ -1116,7 +1133,7 @@ pub trait Buffer: Reader {\n         let mut used;\n         loop {\n             {\n-                let available = match self.fill() {\n+                let available = match self.fill_buf() {\n                     Ok(n) => n,\n                     Err(ref e) if res.len() > 0 && e.kind == EndOfFile => {\n                         used = 0;"}]}