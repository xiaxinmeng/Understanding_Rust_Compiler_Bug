{"sha": "5bd451b26580de465d59ed5389209ed191b7dbdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViZDQ1MWIyNjU4MGRlNDY1ZDU5ZWQ1Mzg5MjA5ZWQxOTFiN2RiZGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T16:08:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-25T16:08:01Z"}, "message": "Auto merge of #56215 - pietroalbini:rollup, r=pietroalbini\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #56024 (Don't auto-inline const functions)\n - #56045 (Check arg/ret sizedness at ExprKind::Path)\n - #56072 (Stabilize macro_literal_matcher)\n - #56075 (Encode a custom \"producers\" section in wasm files)\n - #56100 (generator fields are not necessarily initialized)\n - #56101 (Incorporate `dyn` into more comments and docs.)\n - #56144 (Fix BTreeSet and BTreeMap gdb pretty-printers)\n - #56151 (Move a flaky process test out of libstd)\n - #56170 (Fix self profiler ICE on Windows)\n - #56176 (Panic setup msg)\n - #56204 (Suggest correct enum variant on typo)\n - #56207 (Stabilize the int_to_from_bytes feature)\n - #56210 (read_c_str should call the AllocationExtra hooks)\n - #56211 ([master] Forward-ports from beta)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "dc2e1499910466e79efee5f35d7e60fd578d4d1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dc2e1499910466e79efee5f35d7e60fd578d4d1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5bd451b26580de465d59ed5389209ed191b7dbdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5bd451b26580de465d59ed5389209ed191b7dbdd", "html_url": "https://github.com/rust-lang/rust/commit/5bd451b26580de465d59ed5389209ed191b7dbdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5bd451b26580de465d59ed5389209ed191b7dbdd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9bca7a993d740291568c57eeef797b175c591cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bca7a993d740291568c57eeef797b175c591cf", "html_url": "https://github.com/rust-lang/rust/commit/e9bca7a993d740291568c57eeef797b175c591cf"}, {"sha": "cd17b1d4b684df5fb04d0ee08342446463d20b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd17b1d4b684df5fb04d0ee08342446463d20b18", "html_url": "https://github.com/rust-lang/rust/commit/cd17b1d4b684df5fb04d0ee08342446463d20b18"}], "stats": {"total": 1060, "additions": 686, "deletions": 374}, "files": [{"sha": "870158200dee90aa9c2787bed74d71e60cff9365", "filename": "src/doc/unstable-book/src/language-features/macro-literal-matcher.md", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmacro-literal-matcher.md?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -1,17 +0,0 @@\n-# `macro_literal_matcher`\n-\n-The tracking issue for this feature is: [#35625]\n-\n-The RFC is: [rfc#1576].\n-\n-With this feature gate enabled, the [list of designators] gains one more entry:\n-\n-* `literal`: a literal. Examples: 2, \"string\", 'c'\n-\n-A `literal` may be followed by anything, similarly to the `ident` specifier.\n-\n-[rfc#1576]: http://rust-lang.github.io/rfcs/1576-macros-literal-matcher.html\n-[#35625]: https://github.com/rust-lang/rust/issues/35625\n-[list of designators]: ../reference/macros-by-example.html\n-\n-------------------------"}, {"sha": "1165ab93a146953da8d37096e9c226edb492ca5b", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -80,8 +80,6 @@ fn main() {\n }\n ```\n \n-However, the current implementation allows `MyTupleStruct(..)` to be unsized. This will be fixed in the future.\n-\n ## By-value trait objects\n \n With this feature, you can have by-value `self` arguments without `Self: Sized` bounds."}, {"sha": "b99e401929e62f643ea33b281af2dc5253ccb4d3", "filename": "src/etc/debugger_pretty_printers_common.py", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fetc%2Fdebugger_pretty_printers_common.py", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fetc%2Fdebugger_pretty_printers_common.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fdebugger_pretty_printers_common.py?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -375,32 +375,6 @@ def extract_tail_head_ptr_and_cap_from_std_vecdeque(vec_val):\n     assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n     return (tail, head, data_ptr, capacity)\n \n-\n-def extract_length_and_ptr_from_std_btreeset(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_BTREESET\n-    map = vec_val.get_child_at_index(0)\n-    root = map.get_child_at_index(0)\n-    length = map.get_child_at_index(1).as_integer()\n-    node = root.get_child_at_index(0)\n-    ptr = node.get_child_at_index(0)\n-    unique_ptr_val = ptr.get_child_at_index(0)\n-    data_ptr = unique_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr)\n-\n-\n-def extract_length_and_ptr_from_std_btreemap(vec_val):\n-    assert vec_val.type.get_type_kind() == TYPE_KIND_STD_BTREEMAP\n-    root = vec_val.get_child_at_index(0)\n-    length = vec_val.get_child_at_index(1).as_integer()\n-    node = root.get_child_at_index(0)\n-    ptr = node.get_child_at_index(0)\n-    unique_ptr_val = ptr.get_child_at_index(0)\n-    data_ptr = unique_ptr_val.get_child_at_index(0)\n-    assert data_ptr.type.get_dwarf_type_kind() == DWARF_TYPE_CODE_PTR\n-    return (length, data_ptr)\n-\n-\n def extract_length_and_ptr_from_slice(slice_val):\n     assert (slice_val.type.get_type_kind() == TYPE_KIND_SLICE or\n             slice_val.type.get_type_kind() == TYPE_KIND_STR_SLICE)"}, {"sha": "a376c8593f4c066cbf7b326e17f44f9838ea075f", "filename": "src/etc/gdb_rust_pretty_printing.py", "status": "modified", "additions": 41, "deletions": 29, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fetc%2Fgdb_rust_pretty_printing.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_rust_pretty_printing.py?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -319,6 +319,32 @@ def children(self):\n             yield (str(index), (gdb_ptr + ((tail + index) % cap)).dereference())\n \n \n+# Yield each key (and optionally value) from a BoxedNode.\n+def children_of_node(boxed_node, height, want_values):\n+    ptr = boxed_node['ptr']['pointer']\n+    # This is written oddly because we don't want to rely on the field name being `__0`.\n+    node_ptr = ptr[ptr.type.fields()[0]]\n+    if height > 0:\n+        type_name = str(node_ptr.type.target()).replace('LeafNode', 'InternalNode')\n+        node_type = gdb.lookup_type(type_name)\n+        node_ptr = node_ptr.cast(node_type.pointer())\n+        leaf = node_ptr['data']\n+    else:\n+        leaf = node_ptr.dereference()\n+    keys = leaf['keys']['value']['value']\n+    if want_values:\n+        values = leaf['vals']['value']['value']\n+    length = int(leaf['len'])\n+    for i in xrange(0, length + 1):\n+        if height > 0:\n+            for child in children_of_node(node_ptr['edges'][i], height - 1, want_values):\n+                yield child\n+        if i < length:\n+            if want_values:\n+                yield (keys[i], values[i])\n+            else:\n+                yield keys[i]\n+\n class RustStdBTreeSetPrinter(object):\n     def __init__(self, val):\n         self.__val = val\n@@ -328,21 +354,16 @@ def display_hint():\n         return \"array\"\n \n     def to_string(self):\n-        (length, data_ptr) = \\\n-            rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n         return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % length))\n+                (\"(len: %i)\" % self.__val.get_wrapped_value()['map']['length']))\n \n     def children(self):\n-        (length, data_ptr) = \\\n-            rustpp.extract_length_and_ptr_from_std_btreeset(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n-        gdb_ptr = keys.get_wrapped_value()\n-        for index in xrange(length):\n-            yield (str(index), gdb_ptr[index])\n+        root = self.__val.get_wrapped_value()['map']['root']\n+        node_ptr = root['node']\n+        i = 0\n+        for child in children_of_node(node_ptr, root['height'], False):\n+            yield (str(i), child)\n+            i = i + 1\n \n \n class RustStdBTreeMapPrinter(object):\n@@ -354,26 +375,17 @@ def display_hint():\n         return \"map\"\n \n     def to_string(self):\n-        (length, data_ptr) = \\\n-            rustpp.extract_length_and_ptr_from_std_btreemap(self.__val)\n         return (self.__val.type.get_unqualified_type_name() +\n-                (\"(len: %i)\" % length))\n+                (\"(len: %i)\" % self.__val.get_wrapped_value()['length']))\n \n     def children(self):\n-        (length, data_ptr) = \\\n-            rustpp.extract_length_and_ptr_from_std_btreemap(self.__val)\n-        leaf_node = GdbValue(data_ptr.get_wrapped_value().dereference())\n-        maybe_uninit_keys = leaf_node.get_child_at_index(3)\n-        manually_drop_keys = maybe_uninit_keys.get_child_at_index(1)\n-        keys = manually_drop_keys.get_child_at_index(0)\n-        keys_ptr = keys.get_wrapped_value()\n-        maybe_uninit_vals = leaf_node.get_child_at_index(4)\n-        manually_drop_vals = maybe_uninit_vals.get_child_at_index(1)\n-        vals = manually_drop_vals.get_child_at_index(0)\n-        vals_ptr = vals.get_wrapped_value()\n-        for index in xrange(length):\n-            yield (str(index), keys_ptr[index])\n-            yield (str(index), vals_ptr[index])\n+        root = self.__val.get_wrapped_value()['root']\n+        node_ptr = root['node']\n+        i = 0\n+        for child in children_of_node(node_ptr, root['height'], True):\n+            yield (str(i), child[0])\n+            yield (str(i), child[1])\n+            i = i + 1\n \n \n class RustStdStringPrinter(object):"}, {"sha": "c3a84bf778d03de1d67ed15c09a352006845c47a", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -489,7 +489,7 @@ impl Box<dyn Any> {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn print_if_string(value: Box<Any>) {\n+    /// fn print_if_string(value: Box<dyn Any>) {\n     ///     if let Ok(string) = value.downcast::<String>() {\n     ///         println!(\"String ({}): {}\", string.len(), string);\n     ///     }\n@@ -523,7 +523,7 @@ impl Box<dyn Any + Send> {\n     /// ```\n     /// use std::any::Any;\n     ///\n-    /// fn print_if_string(value: Box<Any + Send>) {\n+    /// fn print_if_string(value: Box<dyn Any + Send>) {\n     ///     if let Ok(string) = value.downcast::<String>() {\n     ///         println!(\"String ({}): {}\", string.len(), string);\n     ///     }\n@@ -618,18 +618,18 @@ impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n \n /// `FnBox` is a version of the `FnOnce` intended for use with boxed\n /// closure objects. The idea is that where one would normally store a\n-/// `Box<FnOnce()>` in a data structure, you should use\n-/// `Box<FnBox()>`. The two traits behave essentially the same, except\n+/// `Box<dyn FnOnce()>` in a data structure, you should use\n+/// `Box<dyn FnBox()>`. The two traits behave essentially the same, except\n /// that a `FnBox` closure can only be called if it is boxed. (Note\n-/// that `FnBox` may be deprecated in the future if `Box<FnOnce()>`\n+/// that `FnBox` may be deprecated in the future if `Box<dyn FnOnce()>`\n /// closures become directly usable.)\n ///\n /// # Examples\n ///\n /// Here is a snippet of code which creates a hashmap full of boxed\n /// once closures and then removes them one by one, calling each\n /// closure as it is removed. Note that the type of the closures\n-/// stored in the map is `Box<FnBox() -> i32>` and not `Box<FnOnce()\n+/// stored in the map is `Box<dyn FnBox() -> i32>` and not `Box<dyn FnOnce()\n /// -> i32>`.\n ///\n /// ```\n@@ -638,8 +638,8 @@ impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n /// use std::boxed::FnBox;\n /// use std::collections::HashMap;\n ///\n-/// fn make_map() -> HashMap<i32, Box<FnBox() -> i32>> {\n-///     let mut map: HashMap<i32, Box<FnBox() -> i32>> = HashMap::new();\n+/// fn make_map() -> HashMap<i32, Box<dyn FnBox() -> i32>> {\n+///     let mut map: HashMap<i32, Box<dyn FnBox() -> i32>> = HashMap::new();\n ///     map.insert(1, Box::new(|| 22));\n ///     map.insert(2, Box::new(|| 44));\n ///     map"}, {"sha": "3ca6de191de2d03542adadca579931e4c1dbdd39", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -633,15 +633,15 @@ impl<T: Clone> Rc<T> {\n impl Rc<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rc_downcast\", since = \"1.29.0\")]\n-    /// Attempt to downcast the `Rc<Any>` to a concrete type.\n+    /// Attempt to downcast the `Rc<dyn Any>` to a concrete type.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// use std::any::Any;\n     /// use std::rc::Rc;\n     ///\n-    /// fn print_if_string(value: Rc<Any>) {\n+    /// fn print_if_string(value: Rc<dyn Any>) {\n     ///     if let Ok(string) = value.downcast::<String>() {\n     ///         println!(\"String ({}): {}\", string.len(), string);\n     ///     }"}, {"sha": "9deae12482976cf75b9ddca0abb3a3f8ce11ddf3", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 12, "deletions": 36, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1921,12 +1921,10 @@ big-endian (network) byte order.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n assert_eq!(bytes, \", $be_bytes, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -1941,12 +1939,10 @@ little-endian byte order.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n assert_eq!(bytes, \", $le_bytes, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -1969,16 +1965,14 @@ instead.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n     });\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -1993,12 +1987,10 @@ big endian.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n@@ -2014,12 +2006,10 @@ little endian.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n@@ -2041,16 +2031,14 @@ appropriate instead.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n@@ -3663,12 +3651,10 @@ big-endian (network) byte order.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\n assert_eq!(bytes, \", $be_bytes, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_be_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -3683,12 +3669,10 @@ little-endian byte order.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\n assert_eq!(bytes, \", $le_bytes, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_le_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -3711,16 +3695,14 @@ instead.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n     });\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn to_ne_bytes(self) -> [u8; mem::size_of::<Self>()] {\n@@ -3735,12 +3717,10 @@ big endian.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_be_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n@@ -3756,12 +3736,10 @@ little endian.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_le_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {\n@@ -3783,16 +3761,14 @@ appropriate instead.\n # Examples\n \n ```\n-#![feature(int_to_from_bytes)]\n-\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n     });\n assert_eq!(value, \", $swap_op, \");\n ```\"),\n-            #[unstable(feature = \"int_to_from_bytes\", issue = \"52963\")]\n+            #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n             #[inline]\n             pub const fn from_ne_bytes(bytes: [u8; mem::size_of::<Self>()]) -> Self {"}, {"sha": "3d4bccb4f9d654ebc049cb95588cda36fc245b09", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -21,7 +21,7 @@\n /// The representation of a trait object like `&SomeTrait`.\n ///\n /// This struct has the same layout as types like `&SomeTrait` and\n-/// `Box<AnotherTrait>`.\n+/// `Box<dyn AnotherTrait>`.\n ///\n /// `TraitObject` is guaranteed to match layouts, but it is not the\n /// type of trait objects (e.g. the fields are not directly accessible"}, {"sha": "ab63e882c4a555b601c35b80d4b922b3afaf11da", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -172,10 +172,11 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let offset = ptr.offset.bytes() as usize;\n         match self.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n-                let p1 = Size::from_bytes((size + 1) as u64);\n-                self.check_relocations(cx, ptr, p1)?;\n-                self.check_defined(ptr, p1)?;\n-                Ok(&self.bytes[offset..offset + size])\n+                let size_with_null = Size::from_bytes((size + 1) as u64);\n+                // Go through `get_bytes` for checks and AllocationExtra hooks.\n+                // We read the null, so we include it in the request, but we want it removed\n+                // from the result!\n+                Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             None => err!(UnterminatedCString(ptr.erase_tag())),\n         }\n@@ -315,11 +316,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             },\n         };\n \n-        {\n-            let endian = cx.data_layout().endian;\n-            let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n-            write_target_uint(endian, dst, bytes).unwrap();\n-        }\n+        let endian = cx.data_layout().endian;\n+        let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n+        write_target_uint(endian, dst, bytes).unwrap();\n \n         // See if we have to also write a relocation\n         match val {"}, {"sha": "af1255c438a95043e4c6a94e1ceb919ba10ac061", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -2200,7 +2200,7 @@ pub enum CastKind {\n     /// \"Unsize\" -- convert a thin-or-fat pointer to a fat pointer.\n     /// codegen must figure out the details once full monomorphization\n     /// is known. For example, this could be used to cast from a\n-    /// `&[i32;N]` to a `&[i32]`, or a `Box<T>` to a `Box<Trait>`\n+    /// `&[i32;N]` to a `&[i32]`, or a `Box<T>` to a `Box<dyn Trait>`\n     /// (presuming `T: Trait`).\n     Unsize,\n }"}, {"sha": "1187c53305d1c36956df23f32f5c9606ff28c2c2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -826,8 +826,10 @@ impl Session {\n     }\n \n     pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n-        let mut profiler = self.self_profiling.borrow_mut();\n-        f(&mut profiler);\n+        if self.opts.debugging_opts.self_profile {\n+            let mut profiler = self.self_profiling.borrow_mut();\n+            f(&mut profiler);\n+        }\n     }\n \n     pub fn print_profiler_results(&self) {"}, {"sha": "83521c5f7240682064d1c73e9dd6c45da8a8fe35", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -48,7 +48,7 @@ use ty::subst::Substs;\n ///    stored in `unsize` is `Foo<[i32]>`, we don't store any further detail about\n ///    the underlying conversions from `[i32; 4]` to `[i32]`.\n ///\n-/// 3. Coercing a `Box<T>` to `Box<Trait>` is an interesting special case.  In\n+/// 3. Coercing a `Box<T>` to `Box<dyn Trait>` is an interesting special case.  In\n ///    that case, we have the pointer we need coming in, so there are no\n ///    autoderefs, and no autoref. Instead we just do the `Unsize` transformation.\n ///    At some point, of course, `Box` should move out of the compiler, in which"}, {"sha": "411a6e7e6238ef470973ce9ede3a8ec9556a52b4", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -173,10 +173,7 @@ impl<'tcx> InstanceDef<'tcx> {\n             // available to normal end-users.\n             return true\n         }\n-        let codegen_fn_attrs = tcx.codegen_fn_attrs(self.def_id());\n-        // need to use `is_const_fn_raw` since we don't really care if the user can use it as a\n-        // const fn, just whether the function should be inlined\n-        codegen_fn_attrs.requests_inline() || tcx.is_const_fn_raw(self.def_id())\n+        tcx.codegen_fn_attrs(self.def_id()).requests_inline()\n     }\n }\n "}, {"sha": "51b197d7b990bbe58eca1e3cede8ec1caa65bbbc", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -303,7 +303,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Same as applying struct_tail on `source` and `target`, but only\n     /// keeps going as long as the two types are instances of the same\n     /// structure definitions.\n-    /// For `(Foo<Foo<T>>, Foo<Trait>)`, the result will be `(Foo<T>, Trait)`,\n+    /// For `(Foo<Foo<T>>, Foo<dyn Trait>)`, the result will be `(Foo<T>, Trait)`,\n     /// whereas struct_tail produces `T`, and `Trait`, respectively.\n     pub fn struct_lockstep_tails(self,\n                                  source: Ty<'tcx>,"}, {"sha": "6540a09d87763c181788bd0e1ca162abe1023a8c", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -12,7 +12,7 @@ use session::config::Options;\n \n use std::fs;\n use std::io::{self, StdoutLock, Write};\n-use std::time::Instant;\n+use std::time::{Duration, Instant};\n \n macro_rules! define_categories {\n     ($($name:ident,)*) => {\n@@ -208,7 +208,20 @@ impl SelfProfiler {\n     }\n \n     fn stop_timer(&mut self) -> u64 {\n-        let elapsed = self.current_timer.elapsed();\n+        let elapsed = if cfg!(windows) {\n+            // On Windows, timers don't always appear to be monotonic (see #51648)\n+            // which can lead to panics when calculating elapsed time.\n+            // Work around this by testing to see if the current time is less than\n+            // our recorded time, and if it is, just returning 0.\n+            let now = Instant::now();\n+            if self.current_timer >= now {\n+                Duration::new(0, 0)\n+            } else {\n+                self.current_timer.elapsed()\n+            }\n+        } else {\n+            self.current_timer.elapsed()\n+        };\n \n         self.current_timer = Instant::now();\n "}, {"sha": "89d84acdd88764427f787144078451d66b3a308b", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -700,6 +700,11 @@ fn link_natively(sess: &Session,\n \n     if sess.opts.target_triple.triple() == \"wasm32-unknown-unknown\" {\n         wasm::rewrite_imports(&out_filename, &codegen_results.crate_info.wasm_imports);\n+        wasm::add_producer_section(\n+            &out_filename,\n+            &sess.edition().to_string(),\n+            option_env!(\"CFG_VERSION\").unwrap_or(\"unknown\"),\n+        );\n     }\n }\n "}, {"sha": "1a5c65f3c43974e42ddfae1ff49502c367ea2a11", "filename": "src/librustc_codegen_llvm/back/wasm.rs", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwasm.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -17,6 +17,7 @@ use serialize::leb128;\n \n // https://webassembly.github.io/spec/core/binary/modules.html#binary-importsec\n const WASM_IMPORT_SECTION_ID: u8 = 2;\n+const WASM_CUSTOM_SECTION_ID: u8 = 0;\n \n const WASM_EXTERNAL_KIND_FUNCTION: u8 = 0;\n const WASM_EXTERNAL_KIND_TABLE: u8 = 1;\n@@ -121,6 +122,112 @@ pub fn rewrite_imports(path: &Path, import_map: &FxHashMap<String, String>) {\n     }\n }\n \n+/// Add or augment the existing `producers` section to encode information about\n+/// the Rust compiler used to produce the wasm file.\n+pub fn add_producer_section(\n+    path: &Path,\n+    rust_version: &str,\n+    rustc_version: &str,\n+) {\n+    struct Field<'a> {\n+        name: &'a str,\n+        values: Vec<FieldValue<'a>>,\n+    }\n+\n+    #[derive(Copy, Clone)]\n+    struct FieldValue<'a> {\n+        name: &'a str,\n+        version: &'a str,\n+    }\n+\n+    let wasm = fs::read(path).expect(\"failed to read wasm output\");\n+    let mut ret = WasmEncoder::new();\n+    ret.data.extend(&wasm[..8]);\n+\n+    // skip the 8 byte wasm/version header\n+    let rustc_value = FieldValue {\n+        name: \"rustc\",\n+        version: rustc_version,\n+    };\n+    let rust_value = FieldValue {\n+        name: \"Rust\",\n+        version: rust_version,\n+    };\n+    let mut fields = Vec::new();\n+    let mut wrote_rustc = false;\n+    let mut wrote_rust = false;\n+\n+    // Move all sections from the original wasm file to our output, skipping\n+    // everything except the producers section\n+    for (id, raw) in WasmSections(WasmDecoder::new(&wasm[8..])) {\n+        if id != WASM_CUSTOM_SECTION_ID {\n+            ret.byte(id);\n+            ret.bytes(raw);\n+            continue\n+        }\n+        let mut decoder = WasmDecoder::new(raw);\n+        if decoder.str() != \"producers\" {\n+            ret.byte(id);\n+            ret.bytes(raw);\n+            continue\n+        }\n+\n+        // Read off the producers section into our fields outside the loop,\n+        // we'll re-encode the producers section when we're done (to handle an\n+        // entirely missing producers section as well).\n+        info!(\"rewriting existing producers section\");\n+\n+        for _ in 0..decoder.u32() {\n+            let name = decoder.str();\n+            let mut values = Vec::new();\n+            for _ in 0..decoder.u32() {\n+                let name = decoder.str();\n+                let version = decoder.str();\n+                values.push(FieldValue { name, version });\n+            }\n+\n+            if name == \"language\" {\n+                values.push(rust_value);\n+                wrote_rust = true;\n+            } else if name == \"processed-by\" {\n+                values.push(rustc_value);\n+                wrote_rustc = true;\n+            }\n+            fields.push(Field { name, values });\n+        }\n+    }\n+\n+    if !wrote_rust {\n+        fields.push(Field {\n+            name: \"language\",\n+            values: vec![rust_value],\n+        });\n+    }\n+    if !wrote_rustc {\n+        fields.push(Field {\n+            name: \"processed-by\",\n+            values: vec![rustc_value],\n+        });\n+    }\n+\n+    // Append the producers section to the end of the wasm file.\n+    let mut section = WasmEncoder::new();\n+    section.str(\"producers\");\n+    section.u32(fields.len() as u32);\n+    for field in fields {\n+        section.str(field.name);\n+        section.u32(field.values.len() as u32);\n+        for value in field.values {\n+            section.str(value.name);\n+            section.str(value.version);\n+        }\n+    }\n+    ret.byte(WASM_CUSTOM_SECTION_ID);\n+    ret.bytes(&section.data);\n+\n+    fs::write(path, &ret.data).expect(\"failed to write wasm output\");\n+}\n+\n struct WasmSections<'a>(WasmDecoder<'a>);\n \n impl<'a> Iterator for WasmSections<'a> {"}, {"sha": "d70fcf60fdf35009d18041a06e31864e3ceeeb03", "filename": "src/librustc_codegen_ssa/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_codegen_ssa%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmeth.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'tcx: 'a> VirtualIndex {\n /// The vtables are cached instead of created on every call.\n ///\n /// The `trait_ref` encodes the erased self type. Hence if we are\n-/// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n+/// making an object `Foo<dyn Trait>` from a value of type `Foo<T>`, then\n /// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n     cx: &Cx,"}, {"sha": "81e56f3115d26cfd8aa1b39ef4d88d36e45c7839", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -158,7 +158,9 @@ macro_rules! make_value_visitor {\n             ) -> EvalResult<'tcx> {\n                 self.walk_aggregate(v, fields)\n             }\n-            /// Called each time we recurse down to a field, passing in old and new value.\n+\n+            /// Called each time we recurse down to a field of a \"product-like\" aggregate\n+            /// (structs, tuples, arrays and the like, but not enums), passing in old and new value.\n             /// This gives the visitor the chance to track the stack of nested fields that\n             /// we are descending through.\n             #[inline(always)]\n@@ -171,6 +173,19 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n+            /// Called for recursing into the field of a generator.  These are not known to be\n+            /// initialized, so we treat them like unions.\n+            #[inline(always)]\n+            fn visit_generator_field(\n+                &mut self,\n+                _old_val: Self::V,\n+                _field: usize,\n+                new_val: Self::V,\n+            ) -> EvalResult<'tcx> {\n+                self.visit_union(new_val)\n+            }\n+\n+            /// Called when recursing into an enum variant.\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n@@ -291,17 +306,33 @@ macro_rules! make_value_visitor {\n                         // use that as an unambiguous signal for detecting primitives.  Make sure\n                         // we did not miss any primitive.\n                         debug_assert!(fields > 0);\n-                        self.visit_union(v)?;\n+                        self.visit_union(v)\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                        // FIXME: We collect in a vec because otherwise there are lifetime errors:\n-                        // Projecting to a field needs (mutable!) access to `ecx`.\n-                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                            (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n-                            })\n-                            .collect();\n-                        self.visit_aggregate(v, fields.into_iter())?;\n+                        // Special handling needed for generators: All but the first field\n+                        // (which is the state) are actually implicitly `MaybeUninit`, i.e.,\n+                        // they may or may not be initialized, so we cannot visit them.\n+                        match v.layout().ty.sty {\n+                            ty::Generator(..) => {\n+                                let field = v.project_field(self.ecx(), 0)?;\n+                                self.visit_aggregate(v, std::iter::once(Ok(field)))?;\n+                                for i in 1..offsets.len() {\n+                                    let field = v.project_field(self.ecx(), i as u64)?;\n+                                    self.visit_generator_field(v, i, field)?;\n+                                }\n+                                Ok(())\n+                            }\n+                            _ => {\n+                                // FIXME: We collect in a vec because otherwise there are lifetime\n+                                // errors: Projecting to a field needs access to `ecx`.\n+                                let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                                    (0..offsets.len()).map(|i| {\n+                                        v.project_field(self.ecx(), i as u64)\n+                                    })\n+                                    .collect();\n+                                self.visit_aggregate(v, fields.into_iter())\n+                            }\n+                        }\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n@@ -317,10 +348,9 @@ macro_rules! make_value_visitor {\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n-                        self.visit_aggregate(v, iter)?;\n+                        self.visit_aggregate(v, iter)\n                     }\n                 }\n-                Ok(())\n             }\n         }\n     }"}, {"sha": "7531f62fdab7b7f8f42d8fbb9670986be8503592", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -178,10 +178,6 @@\n //! Some things are not yet fully implemented in the current version of this\n //! module.\n //!\n-//! ### Initializers of Constants and Statics\n-//! Since no MIR is constructed yet for initializer expressions of constants and\n-//! statics we cannot inspect these properly.\n-//!\n //! ### Const Fns\n //! Ideally, no mono item should be generated for const fns unless there\n //! is a call to them that cannot be evaluated at compile time. At the moment\n@@ -191,7 +187,6 @@\n use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n-use rustc::hir::Node;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -741,27 +736,27 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n         ty::InstanceDef::CloneShim(..) => return true\n     };\n \n-    return match tcx.hir.get_if_local(def_id) {\n-        Some(Node::ForeignItem(..)) => {\n-            false // foreign items are linked against, not codegened.\n-        }\n-        Some(_) => true,\n-        None => {\n-            if tcx.is_reachable_non_generic(def_id) ||\n-                tcx.is_foreign_item(def_id) ||\n-                is_available_upstream_generic(tcx, def_id, instance.substs)\n-            {\n-                // We can link to the item in question, no instance needed\n-                // in this crate\n-                false\n-            } else {\n-                if !tcx.is_mir_available(def_id) {\n-                    bug!(\"Cannot create local mono-item for {:?}\", def_id)\n-                }\n-                true\n-            }\n-        }\n-    };\n+    if tcx.is_foreign_item(def_id) {\n+        // We can always link to foreign items\n+        return false;\n+    }\n+\n+    if def_id.is_local() {\n+        // local items cannot be referred to locally without monomorphizing them locally\n+        return true;\n+    }\n+\n+    if tcx.is_reachable_non_generic(def_id) ||\n+       is_available_upstream_generic(tcx, def_id, instance.substs) {\n+        // We can link to the item in question, no instance needed\n+        // in this crate\n+        return false;\n+    }\n+\n+    if !tcx.is_mir_available(def_id) {\n+        bug!(\"Cannot create local mono-item for {:?}\", def_id)\n+    }\n+    return true;\n \n     fn is_available_upstream_generic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                def_id: DefId,"}, {"sha": "443b1ccdef836f6828030678cc4b6e5ab4a4da21", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -4710,7 +4710,18 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 ty::Visibility::Restricted(self.current_module.normal_ancestor_id)\n             }\n             ast::VisibilityKind::Restricted { ref path, id, .. } => {\n-                // Visibilities are resolved as global by default, add starting root segment.\n+                // For visibilities we are not ready to provide correct implementation of \"uniform\n+                // paths\" right now, so on 2018 edition we only allow module-relative paths for now.\n+                let first_ident = path.segments[0].ident;\n+                if self.session.rust_2018() && !first_ident.is_path_segment_keyword() {\n+                    let msg = \"relative paths are not supported in visibilities on 2018 edition\";\n+                    self.session.struct_span_err(first_ident.span, msg)\n+                                .span_suggestion(path.span, \"try\", format!(\"crate::{}\", path))\n+                                .emit();\n+                    return ty::Visibility::Public;\n+                }\n+                // On 2015 visibilities are resolved as crate-relative by default,\n+                // add starting root segment if necessary.\n                 let segments = path.make_root().iter().chain(path.segments.iter())\n                     .map(|seg| Segment { ident: seg.ident, id: Some(seg.id) })\n                     .collect::<Vec<_>>();\n@@ -4988,10 +4999,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                 err.span_suggestion_with_applicability(\n                     binding.span,\n                     &rename_msg,\n-                    match (&directive.subclass, snippet.as_ref()) {\n-                        (ImportDirectiveSubclass::SingleImport { .. }, \"self\") =>\n+                    match directive.subclass {\n+                        ImportDirectiveSubclass::SingleImport { type_ns_only: true, .. } =>\n                             format!(\"self as {}\", suggested_name),\n-                        (ImportDirectiveSubclass::SingleImport { source, .. }, _) =>\n+                        ImportDirectiveSubclass::SingleImport { source, .. } =>\n                             format!(\n                                 \"{} as {}{}\",\n                                 &snippet[..((source.span.hi().0 - binding.span.lo().0) as usize)],\n@@ -5002,13 +5013,13 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n                                     \"\"\n                                 }\n                             ),\n-                        (ImportDirectiveSubclass::ExternCrate { source, target, .. }, _) =>\n+                        ImportDirectiveSubclass::ExternCrate { source, target, .. } =>\n                             format!(\n                                 \"extern crate {} as {};\",\n                                 source.unwrap_or(target.name),\n                                 suggested_name,\n                             ),\n-                        (_, _) => unreachable!(),\n+                        _ => unreachable!(),\n                     },\n                     Applicability::MaybeIncorrect,\n                 );"}, {"sha": "52e3e54b9f93181090918414b7bb8c3052263cd6", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -864,7 +864,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n             PathResult::NonModule(path_res) if path_res.base_def() == Def::Err => {\n                 // The error was already reported earlier.\n-                assert!(directive.imported_module.get().is_none());\n+                assert!(!self.ambiguity_errors.is_empty() ||\n+                        directive.imported_module.get().is_none());\n                 return None;\n             }\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),"}, {"sha": "4fbbe58445254a76836f7a476ef0f8076852de4b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -36,8 +36,9 @@ use lint;\n \n use std::iter;\n use syntax::ast;\n-use syntax::ptr::P;\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n+use syntax::ptr::P;\n+use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{DUMMY_SP, Span, MultiSpan};\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -1303,6 +1304,32 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n                 }\n             }\n+            (&ty::Adt(adt_def, _substs), Def::Enum(_did)) => {\n+                let ty_str = ty.to_string();\n+                // Incorrect enum variant\n+                let mut err = tcx.sess.struct_span_err(\n+                    span,\n+                    &format!(\"no variant `{}` on enum `{}`\", &assoc_name.as_str(), ty_str),\n+                );\n+                // Check if it was a typo\n+                let input = adt_def.variants.iter().map(|variant| &variant.name);\n+                if let Some(suggested_name) = find_best_match_for_name(\n+                    input,\n+                    &assoc_name.as_str(),\n+                    None,\n+                ) {\n+                    err.span_suggestion_with_applicability(\n+                        span,\n+                        \"did you mean\",\n+                        format!(\"{}::{}\", ty_str, suggested_name.to_string()),\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    err.span_label(span, \"unknown variant\");\n+                }\n+                err.emit();\n+                return (tcx.types.err, Def::Err);\n+            }\n             _ => {\n                 // Don't print TyErr to the user.\n                 if !ty.references_error() {"}, {"sha": "e30a79b25de7fdd78535fa0d51d13566e07ac32c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -208,6 +208,10 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     fulfillment_cx: RefCell<Box<dyn TraitEngine<'tcx>>>,\n \n+    // Some additional `Sized` obligations badly affect type inference.\n+    // These obligations are added in a later stage of typeck.\n+    deferred_sized_obligations: RefCell<Vec<(Ty<'tcx>, Span, traits::ObligationCauseCode<'tcx>)>>,\n+\n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n     // `FnOnce` closure. In that case, we defer full resolution of the\n@@ -644,6 +648,7 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n             infcx,\n             fulfillment_cx: RefCell::new(TraitEngine::new(tcx)),\n             locals: RefCell::new(Default::default()),\n+            deferred_sized_obligations: RefCell::new(Vec::new()),\n             deferred_call_resolutions: RefCell::new(Default::default()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n             deferred_generator_interiors: RefCell::new(Vec::new()),\n@@ -907,6 +912,10 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         fcx.closure_analyze(body);\n         assert!(fcx.deferred_call_resolutions.borrow().is_empty());\n         fcx.resolve_generator_interiors(def_id);\n+\n+        for (ty, span, code) in fcx.deferred_sized_obligations.borrow_mut().drain(..) {\n+            fcx.require_type_is_sized(ty, span, code);\n+        }\n         fcx.select_all_obligations_or_error();\n \n         if fn_decl.is_some() {\n@@ -2345,6 +2354,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.require_type_meets(ty, span, code, lang_item);\n     }\n \n+    pub fn require_type_is_sized_deferred(&self,\n+                                          ty: Ty<'tcx>,\n+                                          span: Span,\n+                                          code: traits::ObligationCauseCode<'tcx>)\n+    {\n+        self.deferred_sized_obligations.borrow_mut().push((ty, span, code));\n+    }\n+\n     pub fn register_bound(&self,\n                           ty: Ty<'tcx>,\n                           def_id: DefId,\n@@ -3939,6 +3956,31 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     tcx.types.err\n                 };\n \n+                if let ty::FnDef(..) = ty.sty {\n+                    let fn_sig = ty.fn_sig(tcx);\n+                    if !tcx.features().unsized_locals {\n+                        // We want to remove some Sized bounds from std functions,\n+                        // but don't want to expose the removal to stable Rust.\n+                        // i.e. we don't want to allow\n+                        //\n+                        // ```rust\n+                        // drop as fn(str);\n+                        // ```\n+                        //\n+                        // to work in stable even if the Sized bound on `drop` is relaxed.\n+                        for i in 0..fn_sig.inputs().skip_binder().len() {\n+                            let input = tcx.erase_late_bound_regions(&fn_sig.input(i));\n+                            self.require_type_is_sized_deferred(input, expr.span,\n+                                                                traits::SizedArgumentType);\n+                        }\n+                    }\n+                    // Here we want to prevent struct constructors from returning unsized types.\n+                    // There were two cases this happened: fn pointer coercion in stable\n+                    // and usual function call in presense of unsized_locals.\n+                    let output = tcx.erase_late_bound_regions(&fn_sig.output());\n+                    self.require_type_is_sized_deferred(output, expr.span, traits::SizedReturnType);\n+                }\n+\n                 // We always require that the type provided as the value for\n                 // a type parameter outlives the moment of instantiation.\n                 let substs = self.tables.borrow().node_substs(expr.hir_id);"}, {"sha": "92678dd5cede0db6910594d8fc817e043003686a", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -256,7 +256,7 @@ fn initial_buffer_size(file: &File) -> usize {\n /// use std::fs;\n /// use std::net::SocketAddr;\n ///\n-/// fn main() -> Result<(), Box<std::error::Error + 'static>> {\n+/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n ///     let foo: SocketAddr = String::from_utf8_lossy(&fs::read(\"address.txt\")?).parse()?;\n ///     Ok(())\n /// }\n@@ -298,7 +298,7 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n /// use std::fs;\n /// use std::net::SocketAddr;\n ///\n-/// fn main() -> Result<(), Box<std::error::Error + 'static>> {\n+/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n ///     let foo: SocketAddr = fs::read_to_string(\"address.txt\")?.parse()?;\n ///     Ok(())\n /// }"}, {"sha": "2d0848252be6d9d689fa02dc84b921bf9b25a3cd", "filename": "src/libstd/process.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1889,42 +1889,6 @@ mod tests {\n         cmd\n     }\n \n-    #[test]\n-    fn test_inherit_env() {\n-        use env;\n-\n-        let result = env_cmd().output().unwrap();\n-        let output = String::from_utf8(result.stdout).unwrap();\n-\n-        for (ref k, ref v) in env::vars() {\n-            // Don't check android RANDOM variable which seems to change\n-            // whenever the shell runs, and our `env_cmd` is indeed running a\n-            // shell which means it'll get a different RANDOM than we probably\n-            // have.\n-            //\n-            // Also skip env vars with `-` in the name on android because, well,\n-            // I'm not sure. It appears though that the `set` command above does\n-            // not print env vars with `-` in the name, so we just skip them\n-            // here as we won't find them in the output. Note that most env vars\n-            // use `_` instead of `-`, but our build system sets a few env vars\n-            // with `-` in the name.\n-            if cfg!(target_os = \"android\") &&\n-               (*k == \"RANDOM\" || k.contains(\"-\")) {\n-                continue\n-            }\n-\n-            // Windows has hidden environment variables whose names start with\n-            // equals signs (`=`). Those do not show up in the output of the\n-            // `set` command.\n-            assert!((cfg!(windows) && k.starts_with(\"=\")) ||\n-                    k.starts_with(\"DYLD\") ||\n-                    output.contains(&format!(\"{}={}\", *k, *v)) ||\n-                    output.contains(&format!(\"{}='{}'\", *k, *v)),\n-                    \"output doesn't contain `{}={}`\\n{}\",\n-                    k, v, output);\n-        }\n-    }\n-\n     #[test]\n     fn test_override_env() {\n         use env;"}, {"sha": "d526e464ba4f50935ab50ba00b615fdb675e28a9", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -19,7 +19,7 @@ use ext::tt::macro_parser::{MatchedSeq, MatchedNonterminal};\n use ext::tt::macro_parser::{parse, parse_failure_msg};\n use ext::tt::quoted;\n use ext::tt::transcribe::transcribe;\n-use feature_gate::{self, emit_feature_err, Features, GateIssue};\n+use feature_gate::Features;\n use parse::{Directory, ParseSess};\n use parse::parser::Parser;\n use parse::token::{self, NtTT};\n@@ -1027,26 +1027,21 @@ fn has_legal_fragment_specifier(sess: &ParseSess,\n     Ok(())\n }\n \n-fn is_legal_fragment_specifier(sess: &ParseSess,\n-                               features: &Features,\n-                               attrs: &[ast::Attribute],\n+fn is_legal_fragment_specifier(_sess: &ParseSess,\n+                               _features: &Features,\n+                               _attrs: &[ast::Attribute],\n                                frag_name: &str,\n-                               frag_span: Span) -> bool {\n+                               _frag_span: Span) -> bool {\n+    /*\n+     * If new fragment specifiers are invented in nightly, `_sess`,\n+     * `_features`, `_attrs`, and `_frag_span` will be useful here\n+     * for checking against feature gates. See past versions of\n+     * this function.\n+     */\n     match frag_name {\n         \"item\" | \"block\" | \"stmt\" | \"expr\" | \"pat\" | \"lifetime\" |\n-        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"vis\" | \"\" => true,\n-        \"literal\" => {\n-            if !features.macro_literal_matcher &&\n-               !attr::contains_name(attrs, \"allow_internal_unstable\") {\n-                let explain = feature_gate::EXPLAIN_LITERAL_MATCHER;\n-                emit_feature_err(sess,\n-                                 \"macro_literal_matcher\",\n-                                 frag_span,\n-                                 GateIssue::Language,\n-                                 explain);\n-            }\n-            true\n-        },\n+        \"path\" | \"ty\" | \"ident\" | \"meta\" | \"tt\" | \"vis\" | \"literal\" |\n+        \"\" => true,\n         _ => false,\n     }\n }"}, {"sha": "73567765a04c456ab3912a0a891c4c537dadf548", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -436,9 +436,6 @@ declare_features! (\n     // Allows irrefutable patterns in if-let and while-let statements (RFC 2086)\n     (active, irrefutable_let_patterns, \"1.27.0\", Some(44495), None),\n \n-    // Allows use of the :literal macro fragment specifier (RFC 1576)\n-    (active, macro_literal_matcher, \"1.27.0\", Some(35625), None),\n-\n     // inconsistent bounds in where clauses\n     (active, trivial_bounds, \"1.28.0\", Some(48214), None),\n \n@@ -690,6 +687,8 @@ declare_features! (\n     (accepted, impl_header_lifetime_elision, \"1.31.0\", Some(15872), None),\n     // `extern crate foo as bar;` puts `bar` into extern prelude.\n     (accepted, extern_crate_item_prelude, \"1.31.0\", Some(55599), None),\n+    // Allows use of the :literal macro fragment specifier (RFC 1576)\n+    (accepted, macro_literal_matcher, \"1.31.0\", Some(35625), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1425,9 +1424,6 @@ pub const EXPLAIN_DEPR_CUSTOM_DERIVE: &'static str =\n pub const EXPLAIN_DERIVE_UNDERSCORE: &'static str =\n     \"attributes of the form `#[derive_*]` are reserved for the compiler\";\n \n-pub const EXPLAIN_LITERAL_MATCHER: &'static str =\n-    \":literal fragment specifier is experimental and subject to change\";\n-\n pub const EXPLAIN_UNSIZED_TUPLE_COERCION: &'static str =\n     \"unsized tuple coercion is not stable enough for use and is subject to change\";\n "}, {"sha": "5e181870fed657b7dc8f553eaf16dbdc1cef9f48", "filename": "src/test/codegen-units/item-collection/unreferenced-const-fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funreferenced-const-fn.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -11,11 +11,10 @@\n // ignore-tidy-linelength\n // compile-flags:-Zprint-mono-items=lazy\n \n-// NB: We do not expect *any* monomorphization to be generated here.\n-\n #![deny(dead_code)]\n #![crate_type = \"rlib\"]\n \n+//~ MONO_ITEM fn unreferenced_const_fn::foo[0] @@ unreferenced_const_fn-cgu.0[External]\n pub const fn foo(x: u32) -> u32 {\n     x + 0xf00\n }"}, {"sha": "a51be370aa44bc1641af4f4c118747fc27ef0d2a", "filename": "src/test/debuginfo/pretty-std-collections.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std-collections.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-tidy-linelength\n // ignore-windows failing on win32 bot\n // ignore-freebsd: gdb package too new\n // ignore-android: FIXME(#10381)\n@@ -20,10 +21,10 @@\n // gdb-command: run\n \n // gdb-command: print btree_set\n-// gdb-check:$1 = BTreeSet<i32>(len: 3) = {3, 5, 7}\n+// gdb-check:$1 = BTreeSet<i32>(len: 15) = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}\n \n // gdb-command: print btree_map\n-// gdb-check:$2 = BTreeMap<i32, i32>(len: 3) = {[3] = 3, [5] = 7, [7] = 4}\n+// gdb-check:$2 = BTreeMap<i32, i32>(len: 15) = {[0] = 0, [1] = 1, [2] = 2, [3] = 3, [4] = 4, [5] = 5, [6] = 6, [7] = 7, [8] = 8, [9] = 9, [10] = 10, [11] = 11, [12] = 12, [13] = 13, [14] = 14}\n \n // gdb-command: print vec_deque\n // gdb-check:$3 = VecDeque<i32>(len: 3, cap: 8) = {5, 3, 7}\n@@ -41,15 +42,15 @@ fn main() {\n \n     // BTreeSet\n     let mut btree_set = BTreeSet::new();\n-    btree_set.insert(5);\n-    btree_set.insert(3);\n-    btree_set.insert(7);\n+    for i in 0..15 {\n+        btree_set.insert(i);\n+    }\n \n     // BTreeMap\n     let mut btree_map = BTreeMap::new();\n-    btree_map.insert(5, 7);\n-    btree_map.insert(3, 3);\n-    btree_map.insert(7, 4);\n+    for i in 0..15 {\n+        btree_map.insert(i, i);\n+    }\n \n     // VecDeque\n     let mut vec_deque = VecDeque::new();"}, {"sha": "e199c43858521bbc8e3e70ad913824f03076ccfc", "filename": "src/test/run-pass/const-int-conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-int-conversion.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_int_conversion, const_int_ops, reverse_bits, int_to_from_bytes)]\n+#![feature(const_int_conversion, const_int_ops, reverse_bits)]\n \n const REVERSE: u32 = 0x12345678_u32.reverse_bits();\n const FROM_BE_BYTES: i32 = i32::from_be_bytes([0x12, 0x34, 0x56, 0x78]);"}, {"sha": "856d3a5f72d34f21b206e8ba0b89d4a4a766b13a", "filename": "src/test/run-pass/inherit-env.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Finherit-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Finherit-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finherit-env.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,25 @@\n+// ignore-emscripten\n+// ignore-wasm32\n+\n+use std::env;\n+use std::process::Command;\n+\n+fn main() {\n+    if env::args().nth(1).map(|s| s == \"print\").unwrap_or(false) {\n+        for (k, v) in env::vars() {\n+            println!(\"{}={}\", k, v);\n+        }\n+        return\n+    }\n+\n+    let me = env::current_exe().unwrap();\n+    let result = Command::new(me).arg(\"print\").output().unwrap();\n+    let output = String::from_utf8(result.stdout).unwrap();\n+\n+    for (k, v) in env::vars() {\n+        assert!(output.contains(&format!(\"{}={}\", k, v)),\n+                \"output doesn't contain `{}={}`\\n{}\",\n+                k, v, output);\n+    }\n+}\n+"}, {"sha": "c4ed534cc20ec84e0a3975a8758c1f0e1bce167f", "filename": "src/test/run-pass/issues/issue-52169.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-52169.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fissues%2Fissue-52169.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissues%2Fissue-52169.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // run-pass\n-#![feature(macro_literal_matcher)]\n \n macro_rules! a {\n     ($i:literal) => { \"right\" };"}, {"sha": "de268e3388a5e34440cf789f525e7fd587baa850", "filename": "src/test/run-pass/macros/macro-literal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacros%2Fmacro-literal.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // run-pass\n-#![feature(macro_literal_matcher)]\n \n macro_rules! mtester {\n     ($l:literal) => {"}, {"sha": "5d8a664b93daddb5dcb678bca114a65bb3bd6388", "filename": "src/test/run-pass/string-box-error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fstring-box-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Fstring-box-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-box-error.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Ensure that both `Box<Error + Send + Sync>` and `Box<Error>` can be obtained from `String`.\n+// Ensure that both `Box<dyn Error + Send + Sync>` and `Box<dyn Error>` can be\n+// obtained from `String`.\n \n use std::error::Error;\n "}, {"sha": "bc64fcdec2e3934a68fa378f8b1c51a57cc2fde6", "filename": "src/test/run-pass/unsized-locals/unsized-exprs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funsized-locals%2Funsized-exprs.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -34,4 +34,5 @@ fn main() {\n     udrop::<[u8]>((*foo()));\n     udrop::<[u8]>((*tfoo()).1);\n     *afoo() + 42;\n+    udrop as fn([u8]);\n }"}, {"sha": "72369aae97ce30ab8558555cb6cf8c71222bb88b", "filename": "src/test/ui/consts/auxiliary/const_fn_lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fconst_fn_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fconst_fn_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fauxiliary%2Fconst_fn_lib.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -10,6 +10,24 @@\n \n // Crate that exports a const fn. Used for testing cross-crate.\n \n+#![feature(const_fn)]\n #![crate_type=\"rlib\"]\n \n-pub const fn foo() -> usize { 22 } //~ ERROR const fn is unstable\n+pub const fn foo() -> usize { 22 }\n+\n+pub const fn bar() -> fn() {\n+    fn x() {}\n+    x\n+}\n+\n+#[inline]\n+pub const fn bar_inlined() -> fn() {\n+    fn x() {}\n+    x\n+}\n+\n+#[inline(always)]\n+pub const fn bar_inlined_always() -> fn() {\n+    fn x() {}\n+    x\n+}"}, {"sha": "2a20f0df15ca2630512b713ab87c8fafe55c0a16", "filename": "src/test/ui/consts/const-int-conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-conversion.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(reverse_bits, int_to_from_bytes)]\n+#![feature(reverse_bits)]\n \n fn main() {\n     let x: &'static i32 = &(5_i32.reverse_bits());"}, {"sha": "c7617c9c7ad0342e0152fe28618a22582ac3567f", "filename": "src/test/ui/consts/const_fn_return_nested_fn_ptr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fconst_fn_return_nested_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fconsts%2Fconst_fn_return_nested_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_fn_return_nested_fn_ptr.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,10 @@\n+// compile-pass\n+// aux-build:const_fn_lib.rs\n+\n+extern crate const_fn_lib;\n+\n+fn main() {\n+    const_fn_lib::bar()();\n+    const_fn_lib::bar_inlined()();\n+    const_fn_lib::bar_inlined_always()();\n+}"}, {"sha": "db5cca193ab4eb1dbcba2ab9dcb6434bdb3420a0", "filename": "src/test/ui/feature-gates/feature-gate-macro-literal-matcher.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.rs?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the :lifetime macro fragment cannot be used when macro_lifetime_matcher\n-// feature gate is not used.\n-\n-macro_rules! m { ($lt:literal) => {} }\n-//~^ ERROR :literal fragment specifier is experimental and subject to change\n-\n-fn main() {\n-    m!(\"some string literal\");\n-}"}, {"sha": "f714b916966a14f3dba755d939e408169d263a6d", "filename": "src/test/ui/feature-gates/feature-gate-macro-literal-matcher.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-macro-literal-matcher.stderr?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -1,11 +0,0 @@\n-error[E0658]: :literal fragment specifier is experimental and subject to change (see issue #35625)\n-  --> $DIR/feature-gate-macro-literal-matcher.rs:14:19\n-   |\n-LL | macro_rules! m { ($lt:literal) => {} }\n-   |                   ^^^^^^^^^^^\n-   |\n-   = help: add #![feature(macro_literal_matcher)] to the crate attributes to enable\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0658`."}, {"sha": "8e0797582970d9c0aa427c33a87c798517b6e02d", "filename": "src/test/ui/imports/auxiliary/issue-56125.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fauxiliary%2Fissue-56125.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1,3 +1,5 @@\n+pub mod issue_56125 {}\n+\n pub mod last_segment {\n     pub mod issue_56125 {}\n }"}, {"sha": "843b52f18435e5ec95ec1676bdf55444ce8ec584", "filename": "src/test/ui/imports/issue-56125.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-56125.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -2,11 +2,24 @@\n // compile-flags:--extern issue_56125\n // aux-build:issue-56125.rs\n \n-use issue_56125::last_segment::*;\n-//~^ ERROR `issue_56125` is ambiguous\n-//~| ERROR unresolved import `issue_56125::last_segment`\n-use issue_56125::non_last_segment::non_last_segment::*;\n-//~^ ERROR `issue_56125` is ambiguous\n-//~| ERROR failed to resolve: could not find `non_last_segment` in `issue_56125`\n+#![feature(uniform_paths)]\n+\n+mod m1 {\n+    use issue_56125::last_segment::*;\n+    //~^ ERROR `issue_56125` is ambiguous\n+    //~| ERROR unresolved import `issue_56125::last_segment`\n+}\n+\n+mod m2 {\n+    use issue_56125::non_last_segment::non_last_segment::*;\n+    //~^ ERROR `issue_56125` is ambiguous\n+    //~| ERROR failed to resolve: could not find `non_last_segment` in `issue_56125`\n+}\n+\n+mod m3 {\n+    mod empty {}\n+    use empty::issue_56125; //~ ERROR unresolved import `empty::issue_56125`\n+    use issue_56125::*; //~ ERROR `issue_56125` is ambiguous\n+}\n \n fn main() {}"}, {"sha": "b1292ef8f783e35c4b2048e53ad3f80a938a5cbc", "filename": "src/test/ui/imports/issue-56125.stderr", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-56125.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1,46 +1,67 @@\n error[E0433]: failed to resolve: could not find `non_last_segment` in `issue_56125`\n-  --> $DIR/issue-56125.rs:8:18\n+  --> $DIR/issue-56125.rs:14:22\n    |\n-LL | use issue_56125::non_last_segment::non_last_segment::*;\n-   |                  ^^^^^^^^^^^^^^^^ could not find `non_last_segment` in `issue_56125`\n+LL |     use issue_56125::non_last_segment::non_last_segment::*;\n+   |                      ^^^^^^^^^^^^^^^^ could not find `non_last_segment` in `issue_56125`\n \n error[E0432]: unresolved import `issue_56125::last_segment`\n-  --> $DIR/issue-56125.rs:5:18\n+  --> $DIR/issue-56125.rs:8:22\n    |\n-LL | use issue_56125::last_segment::*;\n-   |                  ^^^^^^^^^^^^ could not find `last_segment` in `issue_56125`\n+LL |     use issue_56125::last_segment::*;\n+   |                      ^^^^^^^^^^^^ could not find `last_segment` in `issue_56125`\n+\n+error[E0432]: unresolved import `empty::issue_56125`\n+  --> $DIR/issue-56125.rs:21:9\n+   |\n+LL |     use empty::issue_56125; //~ ERROR unresolved import `empty::issue_56125`\n+   |         ^^^^^^^^^^^^^^^^^^ no `issue_56125` in `m3::empty`\n \n error[E0659]: `issue_56125` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/issue-56125.rs:5:5\n+  --> $DIR/issue-56125.rs:8:9\n    |\n-LL | use issue_56125::last_segment::*;\n-   |     ^^^^^^^^^^^ ambiguous name\n+LL |     use issue_56125::last_segment::*;\n+   |         ^^^^^^^^^^^ ambiguous name\n    |\n    = note: `issue_56125` could refer to an extern crate passed with `--extern`\n    = help: use `::issue_56125` to refer to this extern crate unambiguously\n note: `issue_56125` could also refer to the module imported here\n-  --> $DIR/issue-56125.rs:5:5\n+  --> $DIR/issue-56125.rs:8:9\n    |\n-LL | use issue_56125::last_segment::*;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     use issue_56125::last_segment::*;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `self::issue_56125` to refer to this module unambiguously\n \n error[E0659]: `issue_56125` is ambiguous (name vs any other name during import resolution)\n-  --> $DIR/issue-56125.rs:8:5\n+  --> $DIR/issue-56125.rs:14:9\n    |\n-LL | use issue_56125::non_last_segment::non_last_segment::*;\n-   |     ^^^^^^^^^^^ ambiguous name\n+LL |     use issue_56125::non_last_segment::non_last_segment::*;\n+   |         ^^^^^^^^^^^ ambiguous name\n    |\n    = note: `issue_56125` could refer to an extern crate passed with `--extern`\n    = help: use `::issue_56125` to refer to this extern crate unambiguously\n note: `issue_56125` could also refer to the module imported here\n-  --> $DIR/issue-56125.rs:5:5\n+  --> $DIR/issue-56125.rs:14:9\n    |\n-LL | use issue_56125::last_segment::*;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     use issue_56125::non_last_segment::non_last_segment::*;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use `self::issue_56125` to refer to this module unambiguously\n \n-error: aborting due to 4 previous errors\n+error[E0659]: `issue_56125` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/issue-56125.rs:22:9\n+   |\n+LL |     use issue_56125::*; //~ ERROR `issue_56125` is ambiguous\n+   |         ^^^^^^^^^^^ ambiguous name\n+   |\n+   = note: `issue_56125` could refer to an extern crate passed with `--extern`\n+   = help: use `::issue_56125` to refer to this extern crate unambiguously\n+note: `issue_56125` could also refer to the unresolved item imported here\n+  --> $DIR/issue-56125.rs:21:9\n+   |\n+LL |     use empty::issue_56125; //~ ERROR unresolved import `empty::issue_56125`\n+   |         ^^^^^^^^^^^^^^^^^^\n+   = help: use `self::issue_56125` to refer to this unresolved item unambiguously\n+\n+error: aborting due to 6 previous errors\n \n Some errors occurred: E0432, E0433, E0659.\n For more information about an error, try `rustc --explain E0432`."}, {"sha": "fdf8157dcf833918233aacc1107973455570d2df", "filename": "src/test/ui/issues/issue-30355.nll.stderr", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Fissues%2Fissue-30355.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e9bca7a993d740291568c57eeef797b175c591cf/src%2Ftest%2Fui%2Fissues%2Fissue-30355.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30355.nll.stderr?ref=e9bca7a993d740291568c57eeef797b175c591cf", "patch": "@@ -1,22 +0,0 @@\n-error[E0161]: cannot move a value of type X: the size of X cannot be statically determined\n-  --> $DIR/issue-30355.rs:15:6\n-   |\n-LL |     &X(*Y)\n-   |      ^^^^^\n-\n-error[E0161]: cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n-  --> $DIR/issue-30355.rs:15:8\n-   |\n-LL |     &X(*Y)\n-   |        ^^\n-\n-error[E0508]: cannot move out of type `[u8]`, a non-copy slice\n-  --> $DIR/issue-30355.rs:15:8\n-   |\n-LL |     &X(*Y)\n-   |        ^^ cannot move out of here\n-\n-error: aborting due to 3 previous errors\n-\n-Some errors occurred: E0161, E0508.\n-For more information about an error, try `rustc --explain E0161`."}, {"sha": "8d5eac06c43795cc630bfcdb8d480eb074a6dc89", "filename": "src/test/ui/issues/issue-30355.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-30355.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-30355.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30355.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -13,9 +13,7 @@ pub struct X([u8]);\n pub static Y: &'static X = {\n     const Y: &'static [u8] = b\"\";\n     &X(*Y)\n-    //~^ ERROR cannot move out\n-    //~^^ ERROR cannot move a\n-    //~^^^ ERROR cannot move a\n+    //~^ ERROR E0277\n };\n \n fn main() {}"}, {"sha": "1b55f20e6b431662ad619ac6c73202c72c734b52", "filename": "src/test/ui/issues/issue-30355.stderr", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-30355.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1,22 +1,14 @@\n-error[E0161]: cannot move a value of type X: the size of X cannot be statically determined\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n   --> $DIR/issue-30355.rs:15:6\n    |\n LL |     &X(*Y)\n-   |      ^^^^^\n-\n-error[E0161]: cannot move a value of type [u8]: the size of [u8] cannot be statically determined\n-  --> $DIR/issue-30355.rs:15:8\n+   |      ^ doesn't have a size known at compile-time\n    |\n-LL |     &X(*Y)\n-   |        ^^\n-\n-error[E0507]: cannot move out of borrowed content\n-  --> $DIR/issue-30355.rs:15:8\n-   |\n-LL |     &X(*Y)\n-   |        ^^ cannot move out of borrowed content\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n \n-error: aborting due to 3 previous errors\n+error: aborting due to previous error\n \n-Some errors occurred: E0161, E0507.\n-For more information about an error, try `rustc --explain E0161`.\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "86eb624edcac125d7203766f645eda3cffd23e9e", "filename": "src/test/ui/issues/issue-34209.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-34209.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-34209.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34209.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -14,8 +14,8 @@ enum S {\n \n fn bug(l: S) {\n     match l {\n-        S::B{ } => { },\n-        //~^ ERROR ambiguous associated type\n+        S::B { } => { },\n+        //~^ ERROR no variant `B` on enum `S`\n     }\n }\n "}, {"sha": "d5a5647422f411804c4c259ec80e758587f1824c", "filename": "src/test/ui/issues/issue-34209.stderr", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34209.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -1,9 +1,8 @@\n-error[E0223]: ambiguous associated type\n+error: no variant `B` on enum `S`\n   --> $DIR/issue-34209.rs:17:9\n    |\n-LL |         S::B{ } => { },\n-   |         ^^^^ help: use fully-qualified syntax: `<S as Trait>::B`\n+LL |         S::B { } => { },\n+   |         ^^^^ help: did you mean: `S::A`\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0223`."}, {"sha": "eb5fb458d827919f0016e29d788834d911935eb7", "filename": "src/test/ui/issues/issue-45829/import-self.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -19,4 +19,7 @@ use foo as self;\n \n use foo::self;\n \n+use foo::A;\n+use foo::{self as A};\n+\n fn main() {}"}, {"sha": "55e51952a8804712297657372a70d84efd41546d", "filename": "src/test/ui/issues/issue-45829/import-self.stderr", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-45829%2Fimport-self.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -25,7 +25,21 @@ help: you can use `as` to change the binding name of the import\n LL | use foo::{self as other_foo};\n    |           ^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error[E0252]: the name `A` is defined multiple times\n+  --> $DIR/import-self.rs:23:11\n+   |\n+LL | use foo::A;\n+   |     ------ previous import of the type `A` here\n+LL | use foo::{self as A};\n+   |           ^^^^^^^^^ `A` reimported here\n+   |\n+   = note: `A` must be defined only once in the type namespace of this module\n+help: you can use `as` to change the binding name of the import\n+   |\n+LL | use foo::{self as OtherA};\n+   |           ^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n \n-Some errors occurred: E0255, E0429.\n-For more information about an error, try `rustc --explain E0255`.\n+Some errors occurred: E0252, E0255, E0429.\n+For more information about an error, try `rustc --explain E0252`."}, {"sha": "69b7c1e4d4f3cd4c0ddbbc680be8899bfa1cf4c3", "filename": "src/test/ui/privacy/restricted/relative-2018.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+\n+mod m {\n+    pub(in crate) struct S1; // OK\n+    pub(in super) struct S2; // OK\n+    pub(in self) struct S3; // OK\n+    pub(in ::core) struct S4;\n+    //~^ ERROR visibilities can only be restricted to ancestor modules\n+    pub(in a::b) struct S5;\n+    //~^ ERROR relative paths are not supported in visibilities on 2018 edition\n+}\n+\n+fn main() {}"}, {"sha": "61effc463e98fc76d415a3812b15220fbefb90d1", "filename": "src/test/ui/privacy/restricted/relative-2018.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Frestricted%2Frelative-2018.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,16 @@\n+error: visibilities can only be restricted to ancestor modules\n+  --> $DIR/relative-2018.rs:7:12\n+   |\n+LL |     pub(in ::core) struct S4;\n+   |            ^^^^^^\n+\n+error: relative paths are not supported in visibilities on 2018 edition\n+  --> $DIR/relative-2018.rs:9:12\n+   |\n+LL |     pub(in a::b) struct S5;\n+   |            ^---\n+   |            |\n+   |            help: try: `crate::a::b`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4a131ed837b8766b7924f07009ba7b38437f218c", "filename": "src/test/ui/suggestions/suggest-variants.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,15 @@\n+#[derive(Debug)]\n+enum Shape {\n+  Square { size: i32 },\n+  Circle { radius: i32 },\n+}\n+\n+struct S {\n+  x: usize,\n+}\n+\n+fn main() {\n+    println!(\"My shape is {:?}\", Shape::Squareee { size: 5});\n+    println!(\"My shape is {:?}\", Shape::Circl { size: 5});\n+    println!(\"My shape is {:?}\", Shape::Rombus{ size: 5});\n+}"}, {"sha": "08ae68ea713023510abb773f4d350f5aad3b2eaf", "filename": "src/test/ui/suggestions/suggest-variants.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-variants.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,20 @@\n+error: no variant `Squareee` on enum `Shape`\n+  --> $DIR/suggest-variants.rs:12:34\n+   |\n+LL |     println!(\"My shape is {:?}\", Shape::Squareee { size: 5});\n+   |                                  ^^^^^^^^^^^^^^^ help: did you mean: `Shape::Square`\n+\n+error: no variant `Circl` on enum `Shape`\n+  --> $DIR/suggest-variants.rs:13:34\n+   |\n+LL |     println!(\"My shape is {:?}\", Shape::Circl { size: 5});\n+   |                                  ^^^^^^^^^^^^ help: did you mean: `Shape::Circle`\n+\n+error: no variant `Rombus` on enum `Shape`\n+  --> $DIR/suggest-variants.rs:14:34\n+   |\n+LL |     println!(\"My shape is {:?}\", Shape::Rombus{ size: 5});\n+   |                                  ^^^^^^^^^^^^^ unknown variant\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "065563d45a472a260283a4c9dc4c9ad5fbd8b94a", "filename": "src/test/ui/unsized-locals/auxiliary/ufuncs.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fauxiliary%2Fufuncs.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,3 @@\n+#![feature(unsized_locals)]\n+\n+pub fn udrop<T: ?Sized>(_x: T) {}"}, {"sha": "3e5d39ab311509000c230009f630ad744c9f3f0f", "filename": "src/test/ui/unsized-locals/issue-50940-with-feature.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,7 @@\n+#![feature(unsized_locals)]\n+\n+fn main() {\n+    struct A<X: ?Sized>(X);\n+    A as fn(str) -> A<str>;\n+    //~^ERROR the size for values of type `str` cannot be known at compilation time\n+}"}, {"sha": "f4f015fa1906580163766991d7440ce76d97e64c", "filename": "src/test/ui/unsized-locals/issue-50940-with-feature.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940-with-feature.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/issue-50940-with-feature.rs:5:5\n+   |\n+LL |     A as fn(str) -> A<str>;\n+   |     ^ doesn't have a size known at compile-time\n+   |\n+   = help: within `main::A<str>`, the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `main::A<str>`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "7ba809b7e83e3a3117f3fca835330481fb1c30cf", "filename": "src/test/ui/unsized-locals/issue-50940.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    struct A<X: ?Sized>(X);\n+    A as fn(str) -> A<str>;\n+    //~^ERROR the size for values of type `str` cannot be known at compilation time\n+}"}, {"sha": "9f3669ccf1f15dbb662b54f37871da749d371fba", "filename": "src/test/ui/unsized-locals/issue-50940.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Fissue-50940.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `str` cannot be known at compilation time\n+  --> $DIR/issue-50940.rs:3:5\n+   |\n+LL |     A as fn(str) -> A<str>;\n+   |     ^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `str`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "8ca88edcb6add6da602ab0aa79b0d1f46e6db111", "filename": "src/test/ui/unsized-locals/unsized-exprs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -23,4 +23,6 @@ fn main() {\n     //~^ERROR E0277\n     udrop::<A<[u8]>>(A { 0: *foo() });\n     //~^ERROR E0277\n+    udrop::<A<[u8]>>(A(*foo()));\n+    //~^ERROR E0277\n }"}, {"sha": "0ca60e8dea0d9a709b768e56e0056bb208217494", "filename": "src/test/ui/unsized-locals/unsized-exprs.stderr", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -20,6 +20,17 @@ LL |     udrop::<A<[u8]>>(A { 0: *foo() });\n    = note: required because it appears within the type `A<[u8]>`\n    = note: structs must have a statically known size to be initialized\n \n-error: aborting due to 2 previous errors\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/unsized-exprs.rs:26:22\n+   |\n+LL |     udrop::<A<[u8]>>(A(*foo()));\n+   |                      ^ doesn't have a size known at compile-time\n+   |\n+   = help: within `A<[u8]>`, the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: required because it appears within the type `A<[u8]>`\n+   = note: the return type of a function must have a statically known size\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "3fb5a002e0e3c4e6468f5f8afc1dc0415a16cf37", "filename": "src/test/ui/unsized-locals/unsized-exprs2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs2.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -21,6 +21,4 @@ impl std::ops::Add<i32> for A<[u8]> {\n fn main() {\n     udrop::<[u8]>(foo()[..]);\n     //~^ERROR cannot move out of indexed content\n-    // FIXME: should be error\n-    udrop::<A<[u8]>>(A(*foo()));\n }"}, {"sha": "2133b01e0948012df9068ee0a69cf6e9ef309ff4", "filename": "src/test/ui/unsized-locals/unsized-exprs3.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.rs?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,10 @@\n+// aux-build:ufuncs.rs\n+\n+extern crate ufuncs;\n+\n+use ufuncs::udrop;\n+\n+fn main() {\n+    udrop as fn([u8]);\n+    //~^ERROR E0277\n+}"}, {"sha": "42f91a946a851b475ba2bb9e41fa2ecec5cc467e", "filename": "src/test/ui/unsized-locals/unsized-exprs3.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5bd451b26580de465d59ed5389209ed191b7dbdd/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs3.stderr?ref=5bd451b26580de465d59ed5389209ed191b7dbdd", "patch": "@@ -0,0 +1,14 @@\n+error[E0277]: the size for values of type `[u8]` cannot be known at compilation time\n+  --> $DIR/unsized-exprs3.rs:8:5\n+   |\n+LL |     udrop as fn([u8]);\n+   |     ^^^^^ doesn't have a size known at compile-time\n+   |\n+   = help: the trait `std::marker::Sized` is not implemented for `[u8]`\n+   = note: to learn more, visit <https://doc.rust-lang.org/book/second-edition/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n+   = note: all function arguments must have a statically known size\n+   = help: unsized locals are gated as an unstable feature\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}