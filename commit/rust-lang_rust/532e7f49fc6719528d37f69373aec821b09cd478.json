{"sha": "532e7f49fc6719528d37f69373aec821b09cd478", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzMmU3ZjQ5ZmM2NzE5NTI4ZDM3ZjY5MzczYWVjODIxYjA5Y2Q0Nzg=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-07-28T12:25:30Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-02T19:42:17Z"}, "message": "Separate off a leafy insert function instead of lying, and split split similarly", "tree": {"sha": "3e1ef7499400ba1b448f16e9194bd83fa08b4b18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1ef7499400ba1b448f16e9194bd83fa08b4b18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/532e7f49fc6719528d37f69373aec821b09cd478", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/532e7f49fc6719528d37f69373aec821b09cd478", "html_url": "https://github.com/rust-lang/rust/commit/532e7f49fc6719528d37f69373aec821b09cd478", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/532e7f49fc6719528d37f69373aec821b09cd478/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "url": "https://api.github.com/repos/rust-lang/rust/commits/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75", "html_url": "https://github.com/rust-lang/rust/commit/a99ae95c722d4dc8d1eef09aaa4e72d50d496e75"}], "stats": {"total": 86, "additions": 42, "deletions": 44}, "files": [{"sha": "c401a47432eb4360e5d0031f165196881c5d768f", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 42, "deletions": 44, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/532e7f49fc6719528d37f69373aec821b09cd478/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/532e7f49fc6719528d37f69373aec821b09cd478/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=532e7f49fc6719528d37f69373aec821b09cd478", "patch": "@@ -819,13 +819,13 @@ impl<BorrowType, K, V, NodeType> Handle<NodeRef<BorrowType, K, V, NodeType>, mar\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::Edge> {\n+    /// Helps implementations of `insert_fit` for a particular `NodeType`,\n+    /// by taking care of leaf data.\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method assumes that there is enough space in the node for the new\n     /// pair to fit.\n-    ///\n-    /// The returned pointer points to the inserted value.\n-    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+    fn leafy_insert_fit(&mut self, key: K, val: V) {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n \n@@ -834,11 +834,23 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n             slice_insert(self.node.vals_mut(), self.idx, val);\n \n             (*self.node.as_leaf_mut()).len += 1;\n-\n-            self.node.vals_mut().get_unchecked_mut(self.idx)\n         }\n     }\n+}\n \n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n+    /// Inserts a new key/value pair between the key/value pairs to the right and left of\n+    /// this edge. This method assumes that there is enough space in the node for the new\n+    /// pair to fit.\n+    ///\n+    /// The returned pointer points to the inserted value.\n+    fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n+        self.leafy_insert_fit(key, val);\n+        unsafe { self.node.vals_mut().get_unchecked_mut(self.idx) }\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Inserts a new key/value pair between the key/value pairs to the right and left of\n     /// this edge. This method splits the node if there isn't enough room.\n     ///\n@@ -880,14 +892,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         }\n     }\n \n-    /// Unsafely asserts to the compiler some static information about whether the underlying\n-    /// node of this handle is a `Leaf` or an `Internal`.\n-    unsafe fn cast_unchecked<NewType>(\n-        &mut self,\n-    ) -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n-        unsafe { Handle::new_edge(self.node.cast_unchecked(), self.idx) }\n-    }\n-\n     /// Inserts a new key/value pair and an edge that will go to the right of that new pair\n     /// between this edge and the key/value pair to the right of this edge. This method assumes\n     /// that there is enough space in the node for the new pair to fit.\n@@ -897,8 +901,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         debug_assert!(edge.height == self.node.height - 1);\n \n         unsafe {\n-            // This cast is a lie, but it allows us to reuse the key/value insertion logic.\n-            self.cast_unchecked::<marker::Leaf>().insert_fit(key, val);\n+            self.leafy_insert_fit(key, val);\n \n             slice_insert(\n                 slice::from_raw_parts_mut(\n@@ -994,18 +997,11 @@ impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker\n     }\n }\n \n-impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n-    /// Splits the underlying node into three parts:\n-    ///\n-    /// - The node is truncated to only contain the key/value pairs to the right of\n-    ///   this handle.\n-    /// - The key and value pointed to by this handle and extracted.\n-    /// - All the key/value pairs to the right of this handle are put into a newly\n-    ///   allocated node.\n-    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+impl<'a, K, V, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>, marker::KV> {\n+    /// Helps implementations of `split` for a particular `NodeType`,\n+    /// by taking care of leaf data.\n+    fn leafy_split(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V, usize) {\n         unsafe {\n-            let mut new_node = Box::new(LeafNode::new());\n-\n             let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n             let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n \n@@ -1024,6 +1020,24 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n \n             (*self.node.as_leaf_mut()).len = self.idx as u16;\n             new_node.len = new_len as u16;\n+            (k, v, new_len)\n+        }\n+    }\n+}\n+\n+impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV> {\n+    /// Splits the underlying node into three parts:\n+    ///\n+    /// - The node is truncated to only contain the key/value pairs to the right of\n+    ///   this handle.\n+    /// - The key and value pointed to by this handle and extracted.\n+    /// - All the key/value pairs to the right of this handle are put into a newly\n+    ///   allocated node.\n+    pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n+        unsafe {\n+            let mut new_node = Box::new(LeafNode::new());\n+\n+            let (k, v, _) = self.leafy_split(&mut new_node);\n \n             (self.node, k, v, Root { node: BoxedNode::from_leaf(new_node), height: 0 })\n         }\n@@ -1055,31 +1069,15 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n \n-            let k = ptr::read(self.node.keys().get_unchecked(self.idx));\n-            let v = ptr::read(self.node.vals().get_unchecked(self.idx));\n-\n+            let (k, v, new_len) = self.leafy_split(&mut new_node.data);\n             let height = self.node.height;\n-            let new_len = self.node.len() - self.idx - 1;\n \n-            ptr::copy_nonoverlapping(\n-                self.node.keys().as_ptr().add(self.idx + 1),\n-                new_node.data.keys.as_mut_ptr() as *mut K,\n-                new_len,\n-            );\n-            ptr::copy_nonoverlapping(\n-                self.node.vals().as_ptr().add(self.idx + 1),\n-                new_node.data.vals.as_mut_ptr() as *mut V,\n-                new_len,\n-            );\n             ptr::copy_nonoverlapping(\n                 self.node.as_internal().edges.as_ptr().add(self.idx + 1),\n                 new_node.edges.as_mut_ptr(),\n                 new_len + 1,\n             );\n \n-            (*self.node.as_leaf_mut()).len = self.idx as u16;\n-            new_node.data.len = new_len as u16;\n-\n             let mut new_root = Root { node: BoxedNode::from_internal(new_node), height };\n \n             for i in 0..(new_len + 1) {"}]}