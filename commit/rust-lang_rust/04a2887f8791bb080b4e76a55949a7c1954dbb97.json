{"sha": "04a2887f8791bb080b4e76a55949a7c1954dbb97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0YTI4ODdmODc5MWJiMDgwYjRlNzZhNTU5NDlhN2MxOTU0ZGJiOTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-19T06:37:22Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-19T07:17:34Z"}, "message": "Remove '.' after nullary tags in patterns\n\nDoes what it says on the tin.\n\nThe next commit will remove support for this syntax.", "tree": {"sha": "f072b2cc1e0b41270041a3a10a4fc313d3fa1a89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f072b2cc1e0b41270041a3a10a4fc313d3fa1a89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04a2887f8791bb080b4e76a55949a7c1954dbb97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04a2887f8791bb080b4e76a55949a7c1954dbb97", "html_url": "https://github.com/rust-lang/rust/commit/04a2887f8791bb080b4e76a55949a7c1954dbb97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04a2887f8791bb080b4e76a55949a7c1954dbb97/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca7cfbe3d0251766217e5d4e559903e655e7549b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca7cfbe3d0251766217e5d4e559903e655e7549b", "html_url": "https://github.com/rust-lang/rust/commit/ca7cfbe3d0251766217e5d4e559903e655e7549b"}], "stats": {"total": 2820, "additions": 1410, "deletions": 1410}, "files": [{"sha": "3ab33e9b0bef49167d971916ebd46fb03a22ac22", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -417,7 +417,7 @@ fn install_source(c: cargo, path: str) {\n     for cf: str in cratefiles {\n         let p = load_pkg(cf);\n         alt p {\n-            none. { cont; }\n+            none { cont; }\n             some(_p) {\n                 if c.test {\n                     test_one_crate(c, path, cf, _p);\n@@ -559,7 +559,7 @@ fn cmd_install(c: cargo, argv: [str]) {\n \n     let wd = alt tempfile::mkdtemp(c.workdir + fs::path_sep(), \"\") {\n         some(_wd) { _wd }\n-        none. { fail \"needed temp dir\"; }\n+        none { fail \"needed temp dir\"; }\n     };\n \n     if str::starts_with(target, \"uuid:\") {"}, {"sha": "a4c35178e3e7aca89670b8112f42f4f9ea4776bf", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -43,7 +43,7 @@ fn load_intrinsics_bc(sess: session) -> option::t<ModuleRef> {\n         sess.filesearch,\n         bind filesearch::pick_file(\"intrinsics.bc\", _)) {\n       option::some(path) { path }\n-      option::none. {\n+      option::none {\n         sess.warn(\"couldn't find intrinsics.bc\");\n         ret option::none;\n       }\n@@ -70,7 +70,7 @@ fn load_intrinsics_ll(sess: session) -> ModuleRef {\n         sess.filesearch,\n         bind filesearch::pick_file(\"intrinsics.ll\", _)) {\n       option::some(path) { path }\n-      option::none. { sess.fatal(\"couldn't find intrinsics.ll\") }\n+      option::none { sess.fatal(\"couldn't find intrinsics.ll\") }\n     };\n     let llintrinsicsmod = str::as_buf(path, { |buf|\n         llvm::LLVMRustParseAssemblyFile(buf)\n@@ -86,7 +86,7 @@ fn link_intrinsics(sess: session, llmod: ModuleRef) {\n     let llintrinsicsmod = {\n         alt load_intrinsics_bc(sess) {\n           option::some(m) { m }\n-          option::none. {\n+          option::none {\n             // When the bitcode format changes we can't parse a .bc\n             // file produced with a newer LLVM (as happens when stage0\n             // is trying to build against a new LLVM revision), in\n@@ -139,7 +139,7 @@ mod write {\n \n         if opts.save_temps {\n             alt opts.output_type {\n-              output_type_bitcode. {\n+              output_type_bitcode {\n                 if opts.optimize != 0u {\n                     let filename = mk_intermediate_name(output, \"no-opt.bc\");\n                     str::as_buf(filename,\n@@ -383,12 +383,12 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n             if attr::get_meta_item_name(meta) == \"name\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { name = some(v); }\n-                  none. { cmh_items += [meta]; }\n+                  none { cmh_items += [meta]; }\n                 }\n             } else if attr::get_meta_item_name(meta) == \"vers\" {\n                 alt attr::get_meta_item_value_str(meta) {\n                   some(v) { vers = some(v); }\n-                  none. { cmh_items += [meta]; }\n+                  none { cmh_items += [meta]; }\n                 }\n             } else { cmh_items += [meta]; }\n         }\n@@ -442,7 +442,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                        output: str, metas: provided_metas) -> str {\n         ret alt metas.name {\n               some(v) { v }\n-              none. {\n+              none {\n                 let name =\n                     {\n                         let os = str::split(fs::basename(output), '.' as u8);\n@@ -463,7 +463,7 @@ fn build_link_meta(sess: session, c: ast::crate, output: str,\n                        metas: provided_metas) -> str {\n         ret alt metas.vers {\n               some(v) { v }\n-              none. {\n+              none {\n                 let vers = \"0.0\";\n                 warn_missing(sess, \"vers\", vers);\n                 vers\n@@ -509,7 +509,7 @@ fn get_symbol_hash(ccx: @crate_ctxt, t: ty::t) -> str {\n     let hash = \"\";\n     alt ccx.type_sha1s.find(t) {\n       some(h) { hash = h; }\n-      none. {\n+      none {\n         hash = symbol_hash(ccx.tcx, ccx.sha, t, ccx.link_meta);\n         ccx.type_sha1s.insert(t, hash);\n       }"}, {"sha": "898b1cad70ec5df1de654c9abab73c9db7356155", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -5,37 +5,37 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n         module_asm: \"\",\n \n         meta_sect_name: alt target_os {\n-          session::os_macos. { \"__DATA,__note.rustc\" }\n-          session::os_win32. { \".note.rustc\" }\n-          session::os_linux. { \".note.rustc\" }\n-          session::os_freebsd. { \".note.rustc\" }\n+          session::os_macos { \"__DATA,__note.rustc\" }\n+          session::os_win32 { \".note.rustc\" }\n+          session::os_linux { \".note.rustc\" }\n+          session::os_freebsd { \".note.rustc\" }\n         },\n \n         data_layout: alt target_os {\n-          session::os_macos. {\n+          session::os_macos {\n             \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\" + \"-i32:32:32-i64:32:64\" +\n                 \"-f32:32:32-f64:32:64-v64:64:64\" +\n               \"-v128:128:128-a0:0:64-f80:128:128\" + \"-n8:16:32\"\n           }\n \n-          session::os_win32. {\n+          session::os_win32 {\n             \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_linux. {\n+          session::os_linux {\n             \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n \n-          session::os_freebsd. {\n+          session::os_freebsd {\n             \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\"\n           }\n         },\n \n         target_triple: alt target_os {\n-          session::os_macos. { \"i686-apple-darwin\" }\n-          session::os_win32. { \"i686-pc-mingw32\" }\n-          session::os_linux. { \"i686-unknown-linux-gnu\" }\n-          session::os_freebsd. { \"i686-unknown-freebsd\" }\n+          session::os_macos { \"i686-apple-darwin\" }\n+          session::os_win32 { \"i686-pc-mingw32\" }\n+          session::os_linux { \"i686-unknown-linux-gnu\" }\n+          session::os_freebsd { \"i686-unknown-freebsd\" }\n         },\n \n         gcc_args: [\"-m32\"]"}, {"sha": "ca10a798cdb83f92728aad0564f75f5886a73093", "filename": "src/comp/back/x86_64.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86_64.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -5,44 +5,44 @@ fn get_target_strs(target_os: session::os) -> target_strs::t {\n         module_asm: \"\",\n \n         meta_sect_name: alt target_os {\n-          session::os_macos. { \"__DATA,__note.rustc\" }\n-          session::os_win32. { \".note.rustc\" }\n-          session::os_linux. { \".note.rustc\" }\n-          session::os_freebsd. { \".note.rustc\" }\n+          session::os_macos { \"__DATA,__note.rustc\" }\n+          session::os_win32 { \".note.rustc\" }\n+          session::os_linux { \".note.rustc\" }\n+          session::os_freebsd { \".note.rustc\" }\n         },\n \n         data_layout: alt target_os {\n-          session::os_macos. {\n+          session::os_macos {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64\"\n           }\n \n-          session::os_win32. {\n+          session::os_win32 {\n             // FIXME: Test this. Copied from linux\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_linux. {\n+          session::os_linux {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n \n-          session::os_freebsd. {\n+          session::os_freebsd {\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\"+\n                 \"f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\"+\n                 \"s0:64:64-f80:128:128-n8:16:32:64-S128\"\n           }\n         },\n \n         target_triple: alt target_os {\n-          session::os_macos. { \"x86_64-apple-darwin\" }\n-          session::os_win32. { \"x86_64-pc-mingw32\" }\n-          session::os_linux. { \"x86_64-unknown-linux-gnu\" }\n-          session::os_freebsd. { \"x86_64-unknown-freebsd\" }\n+          session::os_macos { \"x86_64-apple-darwin\" }\n+          session::os_win32 { \"x86_64-pc-mingw32\" }\n+          session::os_linux { \"x86_64-unknown-linux-gnu\" }\n+          session::os_freebsd { \"x86_64-unknown-freebsd\" }\n         },\n \n         gcc_args: [\"-m64\"]"}, {"sha": "6a44c5763de47b67e5ea6f91d05937f16ce0a103", "filename": "src/comp/driver/diagnostic.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdiagnostic.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -91,7 +91,7 @@ fn mk_handler(cm: codemap::codemap,\n \n     let emit = alt emitter {\n       some(e) { e }\n-      none. {\n+      none {\n         let f = fn@(cmsp: option<(codemap::codemap, span)>,\n             msg: str, t: level) {\n             emit(cmsp, msg, t);\n@@ -116,19 +116,19 @@ tag level {\n \n fn diagnosticstr(lvl: level) -> str {\n     alt lvl {\n-      fatal. { \"error\" }\n-      error. { \"error\" }\n-      warning. { \"warning\" }\n-      note. { \"note\" }\n+      fatal { \"error\" }\n+      error { \"error\" }\n+      warning { \"warning\" }\n+      note { \"note\" }\n     }\n }\n \n fn diagnosticcolor(lvl: level) -> u8 {\n     alt lvl {\n-      fatal. { term::color_bright_red }\n-      error. { term::color_bright_red }\n-      warning. { term::color_bright_yellow }\n-      note. { term::color_bright_green }\n+      fatal { term::color_bright_red }\n+      error { term::color_bright_red }\n+      warning { term::color_bright_yellow }\n+      note { term::color_bright_green }\n     }\n }\n \n@@ -155,7 +155,7 @@ fn emit(cmsp: option<(codemap::codemap, span)>,\n         print_diagnostic(ss, lvl, msg);\n         highlight_lines(cm, sp, lines);\n       }\n-      none. {\n+      none {\n         print_diagnostic(\"\", lvl, msg);\n       }\n     }"}, {"sha": "5b80461133584d946fed0f63cb5b1ff2e59740c5", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -280,22 +280,22 @@ fn pretty_print_input(sess: session, cfg: ast::crate_cfg, input: str,\n     // from stdin, we're going to just suck the source into a string\n     // so both the parser and pretty-printer can use it.\n     let upto = alt ppm {\n-      ppm_expanded. { cu_expand }\n-      ppm_typed. { cu_typeck }\n+      ppm_expanded { cu_expand }\n+      ppm_typed { cu_typeck }\n       _ { cu_parse }\n     };\n     let {crate, tcx, src} = compile_upto(sess, cfg, input, upto, none);\n \n     let ann: pprust::pp_ann = pprust::no_ann();\n     alt ppm {\n-      ppm_typed. {\n+      ppm_typed {\n         ann = {pre: ann_paren_for_expr,\n                post: bind ann_typed_post(option::get(tcx), _)};\n       }\n-      ppm_identified. {\n+      ppm_identified {\n         ann = {pre: ann_paren_for_expr, post: ann_identified_post};\n       }\n-      ppm_expanded. | ppm_normal. {}\n+      ppm_expanded | ppm_normal {}\n     }\n     pprust::print_crate(sess.codemap, sess.diagnostic, crate, input,\n                         io::string_reader(src), io::stdout(), ann);\n@@ -332,11 +332,11 @@ fn build_target_config(sopts: @session::options,\n                        demitter: diagnostic::emitter) -> @session::config {\n     let os = alt get_os(sopts.target_triple) {\n       some(os) { os }\n-      none. { early_error(demitter, \"Unknown operating system!\") }\n+      none { early_error(demitter, \"Unknown operating system!\") }\n     };\n     let arch = alt get_arch(sopts.target_triple) {\n       some(arch) { arch }\n-      none. { early_error(demitter,\n+      none { early_error(demitter,\n                           \"Unknown architecture! \" + sopts.target_triple) }\n     };\n     let (int_type, uint_type, float_type) = alt arch {\n@@ -429,7 +429,7 @@ fn build_session_options(match: getopts::match,\n         } else { 0u };\n     let target =\n         alt target_opt {\n-            none. { host_triple() }\n+            none { host_triple() }\n             some(s) { s }\n         };\n \n@@ -538,8 +538,8 @@ fn build_output_filenames(ifile: str,\n \n     let obj_suffix =\n         alt sopts.output_type {\n-          link::output_type_none. { \"none\" }\n-          link::output_type_bitcode. { \"bc\" }\n+          link::output_type_none { \"none\" }\n+          link::output_type_bitcode { \"bc\" }\n           link::output_type_assembly. { \"s\" }\n           link::output_type_llvm_assembly. { \"ll\" }\n           // Object and exe output both use the '.o' extension here\n@@ -549,13 +549,13 @@ fn build_output_filenames(ifile: str,\n         };\n \n     alt ofile {\n-      none. {\n+      none {\n         // \"-\" as input file will cause the parser to read from stdin so we\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let dirname = alt odir {\n           some(d) { d }\n-          none. {\n+          none {\n             if input_is_stdin(ifile) {\n                 std::os::getcwd()\n             } else {"}, {"sha": "ad1da33673eb3c75f25c0f18b4c5b07b03aaa0d1", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -114,9 +114,9 @@ impl session for session {\n fn building_library(req_crate_type: crate_type, crate: @ast::crate,\n                     testing: bool) -> bool {\n     alt req_crate_type {\n-      bin_crate. { false }\n-      lib_crate. { true }\n-      unknown_crate. {\n+      bin_crate { false }\n+      lib_crate { true }\n+      unknown_crate {\n         if testing {\n             false\n         } else {"}, {"sha": "75ee1e822a42ba143cbcb31c38712abdfb48e4d5", "filename": "src/comp/front/attr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fattr.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -202,7 +202,7 @@ fn require_unique_names(sess: session, metas: [@ast::meta_item]) {\n \n fn native_abi(attrs: [ast::attribute]) -> either::t<str, ast::native_abi> {\n     ret alt attr::get_meta_item_value_str_by_name(attrs, \"abi\") {\n-      option::none. {\n+      option::none {\n         either::right(ast::native_abi_cdecl)\n       }\n       option::some(\"rust-intrinsic\") {\n@@ -236,10 +236,10 @@ fn meta_item_value_from_list(\n       some(item) {\n         alt attr::get_meta_item_value_str(item) {\n           some(value) { some(value) }\n-          none. { none }\n+          none { none }\n         }\n       }\n-      none. { none }\n+      none { none }\n     }\n }\n \n@@ -251,7 +251,7 @@ fn meta_item_list_from_list(\n       some(item) {\n         attr::get_meta_item_list(item)\n       }\n-      none. { none }\n+      none { none }\n     }\n }\n \n@@ -263,7 +263,7 @@ fn name_value_str_pair(\n         let name = attr::get_meta_item_name(item);\n         some((name, value))\n       }\n-      none. { none }\n+      none { none }\n     }\n }\n "}, {"sha": "93a6f76130600df43435ba66a6f7e463a457e612", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -68,7 +68,7 @@ fn visit_item(e: env, i: @ast::item) {\n                 }\n                 nn\n               }\n-              none. { i.ident }\n+              none { i.ident }\n             };\n         let already_added = false;\n         if vec::len(attr::find_attrs_by_name(i.attrs, \"nolink\")) == 0u {\n@@ -84,7 +84,7 @@ fn visit_item(e: env, i: @ast::item) {\n               some(linkarg) {\n                 cstore::add_used_link_args(cstore, linkarg);\n               }\n-              none. {/* fallthrough */ }\n+              none {/* fallthrough */ }\n             }\n         }\n       }\n@@ -96,7 +96,7 @@ fn visit_item(e: env, i: @ast::item) {\n fn list_file_metadata(sess: session::session, path: str, out: io::writer) {\n     alt get_metadata_section(sess, path) {\n       option::some(bytes) { decoder::list_crate_metadata(bytes, out); }\n-      option::none. {\n+      option::none {\n         out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n       }\n     }\n@@ -154,7 +154,7 @@ fn find_library_crate(sess: session::session, ident: ast::ident,\n                   _ { ident }\n                 }\n               }\n-              none. { ident }\n+              none { ident }\n             }\n         };\n \n@@ -239,7 +239,7 @@ fn load_library_crate(sess: session::session, span: span, ident: ast::ident,\n \n     alt find_library_crate(sess, ident, metas) {\n       some(t) { ret t; }\n-      none. {\n+      none {\n         sess.span_fatal(span, #fmt[\"can't find crate for '%s'\", ident]);\n       }\n     }"}, {"sha": "e3790e4b09b3479848a821cc8d85a0ea9459961b", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -286,7 +286,7 @@ fn get_impls_for_mod(cdata: cmd, m_id: ast::node_id,\n     ebml::tagged_docs(mod_item, tag_mod_impl) {|doc|\n         let did = translate_def_id(cdata, parse_def_id(ebml::doc_data(doc)));\n         let item = lookup_item(did.node, data), nm = item_name(item);\n-        if alt name { some(n) { n == nm } none. { true } } {\n+        if alt name { some(n) { n == nm } none { true } } {\n             let base_tps = item_ty_param_count(doc);\n             result += [@{did: did, ident: nm,\n                          methods: item_impl_methods(cdata, item, base_tps)}];\n@@ -393,7 +393,7 @@ fn get_attributes(md: ebml::doc) -> [ast::attribute] {\n                   span: ast_util::dummy_sp()}];\n         };\n       }\n-      option::none. { }\n+      option::none { }\n     }\n     ret attrs;\n }\n@@ -489,7 +489,7 @@ fn translate_def_id(cdata: cmd, did: ast::def_id) -> ast::def_id {\n \n     alt cdata.cnum_map.find(did.crate) {\n       option::some(n) { ret {crate: n, node: did.node}; }\n-      option::none. { fail \"didn't find a crate in the cnum_map\"; }\n+      option::none { fail \"didn't find a crate in the cnum_map\"; }\n     }\n }\n "}, {"sha": "279f761dfb20edb61e9b311935514c6ebb136ee9", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -296,9 +296,9 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w,\n                       alt decl.purity {\n-                        unsafe_fn. { 'u' }\n-                        pure_fn. { 'p' }\n-                        impure_fn. { 'f' }\n+                        unsafe_fn { 'u' }\n+                        pure_fn { 'p' }\n+                        impure_fn { 'f' }\n                       } as u8);\n         encode_type_param_bounds(ebml_w, ecx, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(tcx, item.id));\n@@ -420,7 +420,7 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                                nitem: @native_item) {\n     ebml::start_tag(ebml_w, tag_items_data_item);\n     alt nitem.node {\n-      native_item_ty. {\n+      native_item_ty {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, 'T' as u8);\n         encode_type(ecx, ebml_w,\n@@ -429,9 +429,9 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n       native_item_fn(fn_decl, tps) {\n         let letter =\n             alt fn_decl.purity {\n-              unsafe_fn. { 'U' }\n-              pure_fn. { 'P' }   // this is currently impossible, but hey.\n-              impure_fn. { 'F' }\n+              unsafe_fn { 'U' }\n+              pure_fn { 'P' }   // this is currently impossible, but hey.\n+              impure_fn { 'F' }\n             } as u8;\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, letter);"}, {"sha": "266b319fe29cd779efd05104e20b728feee114ed", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -277,7 +277,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         assert (next(st) as char == '#');\n         alt st.tcx.rcache.find({cnum: st.crate, pos: pos, len: len}) {\n           some(tt) { ret tt; }\n-          none. {\n+          none {\n             let ps = @{pos: pos with *st};\n             let tt = parse_ty(ps, conv);\n             st.tcx.rcache.insert({cnum: st.crate, pos: pos, len: len}, tt);"}, {"sha": "d4c562b67f96725f8fa90752bf891087cd16fda7", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -29,17 +29,17 @@ tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {\n-      ac_no_abbrevs. { ret false; }\n+      ac_no_abbrevs { ret false; }\n       ac_use_abbrevs(_) { ret true; }\n     }\n }\n \n fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n     alt cx.abbrevs {\n-      ac_no_abbrevs. {\n+      ac_no_abbrevs {\n         let result_str = alt cx.tcx.short_names_cache.find(t) {\n           some(s) { *s }\n-          none. {\n+          none {\n             let buf = io::mk_mem_buffer();\n             enc_sty(io::mem_buffer_writer(buf), cx,\n                     ty::struct_raw(cx.tcx, t));\n@@ -52,7 +52,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n       ac_use_abbrevs(abbrevs) {\n         alt abbrevs.find(t) {\n           some(a) { w.write_str(*a.s); ret; }\n-          none. {\n+          none {\n             let pos = w.tell();\n             enc_sty(w, cx, ty::struct_raw(cx.tcx, t));\n             let end = w.tell();\n@@ -79,44 +79,44 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n }\n fn enc_mt(w: io::writer, cx: @ctxt, mt: ty::mt) {\n     alt mt.mut {\n-      imm. { }\n-      mut. { w.write_char('m'); }\n-      maybe_mut. { w.write_char('?'); }\n+      imm { }\n+      mut { w.write_char('m'); }\n+      maybe_mut { w.write_char('?'); }\n     }\n     enc_ty(w, cx, mt.ty);\n }\n fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n     alt st {\n-      ty::ty_nil. { w.write_char('n'); }\n-      ty::ty_bot. { w.write_char('z'); }\n-      ty::ty_bool. { w.write_char('b'); }\n+      ty::ty_nil { w.write_char('n'); }\n+      ty::ty_bot { w.write_char('z'); }\n+      ty::ty_bool { w.write_char('b'); }\n       ty::ty_int(t) {\n         alt t {\n-          ty_i. { w.write_char('i'); }\n-          ty_char. { w.write_char('c'); }\n-          ty_i8. { w.write_str(\"MB\"); }\n-          ty_i16. { w.write_str(\"MW\"); }\n-          ty_i32. { w.write_str(\"ML\"); }\n-          ty_i64. { w.write_str(\"MD\"); }\n+          ty_i { w.write_char('i'); }\n+          ty_char { w.write_char('c'); }\n+          ty_i8 { w.write_str(\"MB\"); }\n+          ty_i16 { w.write_str(\"MW\"); }\n+          ty_i32 { w.write_str(\"ML\"); }\n+          ty_i64 { w.write_str(\"MD\"); }\n         }\n       }\n       ty::ty_uint(t) {\n         alt t {\n-          ty_u. { w.write_char('u'); }\n-          ty_u8. { w.write_str(\"Mb\"); }\n-          ty_u16. { w.write_str(\"Mw\"); }\n-          ty_u32. { w.write_str(\"Ml\"); }\n-          ty_u64. { w.write_str(\"Md\"); }\n+          ty_u { w.write_char('u'); }\n+          ty_u8 { w.write_str(\"Mb\"); }\n+          ty_u16 { w.write_str(\"Mw\"); }\n+          ty_u32 { w.write_str(\"Ml\"); }\n+          ty_u64 { w.write_str(\"Md\"); }\n         }\n       }\n       ty::ty_float(t) {\n         alt t {\n-          ty_f. { w.write_char('l'); }\n-          ty_f32. { w.write_str(\"Mf\"); }\n-          ty_f64. { w.write_str(\"MF\"); }\n+          ty_f { w.write_char('l'); }\n+          ty_f32 { w.write_str(\"Mf\"); }\n+          ty_f64 { w.write_str(\"MF\"); }\n         }\n       }\n-      ty::ty_str. { w.write_char('S'); }\n+      ty::ty_str { w.write_char('S'); }\n       ty::ty_tag(def, tys) {\n         w.write_str(\"t[\");\n         w.write_str(cx.ds(def));\n@@ -178,11 +178,11 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n         w.write_char('|');\n         w.write_str(uint::str(id));\n       }\n-      ty::ty_type. { w.write_char('Y'); }\n-      ty::ty_send_type. { w.write_char('y'); }\n-      ty::ty_opaque_closure_ptr(ty::ck_block.) { w.write_str(\"C&\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_box.) { w.write_str(\"C@\"); }\n-      ty::ty_opaque_closure_ptr(ty::ck_uniq.) { w.write_str(\"C~\"); }\n+      ty::ty_type { w.write_char('Y'); }\n+      ty::ty_send_type { w.write_char('y'); }\n+      ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(\"C&\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_box) { w.write_str(\"C@\"); }\n+      ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(\"C~\"); }\n       ty::ty_constr(ty, cs) {\n         w.write_str(\"A[\");\n         enc_ty(w, cx, ty);\n@@ -201,23 +201,23 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n }\n fn enc_proto(w: io::writer, proto: proto) {\n     alt proto {\n-      proto_uniq. { w.write_str(\"f~\"); }\n-      proto_box. { w.write_str(\"f@\"); }\n-      proto_block. { w.write_str(\"f&\"); }\n-      proto_any. { w.write_str(\"f*\"); }\n-      proto_bare. { w.write_str(\"fn\"); }\n+      proto_uniq { w.write_str(\"f~\"); }\n+      proto_box { w.write_str(\"f@\"); }\n+      proto_block { w.write_str(\"f&\"); }\n+      proto_any { w.write_str(\"f*\"); }\n+      proto_bare { w.write_str(\"fn\"); }\n     }\n }\n \n fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n     w.write_char('[');\n     for arg: ty::arg in ft.inputs {\n         alt arg.mode {\n-          by_mut_ref. { w.write_char('&'); }\n-          by_move. { w.write_char('-'); }\n-          by_copy. { w.write_char('+'); }\n-          by_ref. { w.write_char('='); }\n-          by_val. { w.write_char('#'); }\n+          by_mut_ref { w.write_char('&'); }\n+          by_move { w.write_char('-'); }\n+          by_copy { w.write_char('+'); }\n+          by_ref { w.write_char('='); }\n+          by_val { w.write_char('#'); }\n         }\n         enc_ty(w, cx, arg.ty);\n     }\n@@ -231,7 +231,7 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n         enc_constr(w, cx, c);\n     }\n     alt ft.ret_style {\n-      noreturn. { w.write_char('!'); }\n+      noreturn { w.write_char('!'); }\n       _ { enc_ty(w, cx, ft.output); }\n     }\n }\n@@ -246,7 +246,7 @@ fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n     for a: @constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n-          carg_base. { w.write_char('*'); }\n+          carg_base { w.write_char('*'); }\n           carg_ident(i) { w.write_uint(i); }\n           carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n@@ -263,7 +263,7 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n     for a: @ty::ty_constr_arg in c.node.args {\n         if semi { w.write_char(';'); } else { semi = true; }\n         alt a.node {\n-          carg_base. { w.write_char('*'); }\n+          carg_base { w.write_char('*'); }\n           carg_ident(p) { w.write_str(path_to_str(p)); }\n           carg_lit(l) { w.write_str(lit_to_str(l)); }\n         }\n@@ -274,8 +274,8 @@ fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @[ty::param_bound]) {\n     for bound in *bs {\n         alt bound {\n-          ty::bound_send. { w.write_char('S'); }\n-          ty::bound_copy. { w.write_char('C'); }\n+          ty::bound_send { w.write_char('S'); }\n+          ty::bound_copy { w.write_char('C'); }\n           ty::bound_iface(tp) {\n             w.write_char('I');\n             enc_ty(w, cx, tp);"}, {"sha": "c799e9956b0a943496765fcbba749b3b7a5c9118", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -90,10 +90,10 @@ fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n     // be called multiple times.\n     let proto = ty::ty_fn_proto(cx.tcx, fty);\n     alt proto {\n-      ast::proto_block. | ast::proto_any. {\n+      ast::proto_block | ast::proto_any {\n         check_loop(*cx, sc) {|| v.visit_block(body, sc, v);}\n       }\n-      ast::proto_box. | ast::proto_uniq. | ast::proto_bare. {\n+      ast::proto_box | ast::proto_uniq | ast::proto_bare {\n         let sc = {bs: [], invalid: @mutable list::nil};\n         v.visit_block(body, sc, v);\n       }\n@@ -156,7 +156,7 @@ fn visit_block(cx: @ctx, b: ast::blk, sc: scope, v: vt<scope>) {\n                         check_lval(cx, init.expr, sc, v);\n                     }\n                   }\n-                  none. { }\n+                  none { }\n                 }\n             }\n           }\n@@ -197,9 +197,9 @@ fn add_bindings_for_let(cx: ctx, &bs: [binding], loc: @ast::local) {\n \n fn cant_copy(cx: ctx, b: binding) -> bool {\n     alt b.copied {\n-      not_allowed. { ret true; }\n-      copied. { ret false; }\n-      not_copied. {}\n+      not_allowed { ret true; }\n+      copied { ret false; }\n+      not_copied {}\n     }\n     let ty = ty::node_id_to_type(cx.tcx, b.node_id);\n     if ty::type_allows_implicit_copy(cx.tcx, ty) {\n@@ -240,8 +240,8 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                        local_id: 0u,\n                        unsafe_tys: unsafe_set(root.mut),\n                        mutable copied: alt arg_t.mode {\n-                         ast::by_move. | ast::by_copy. { copied }\n-                         ast::by_mut_ref. { not_allowed }\n+                         ast::by_move | ast::by_copy { copied }\n+                         ast::by_mut_ref { not_allowed }\n                          _ { not_copied }\n                        }}];\n         i += 1u;\n@@ -306,7 +306,7 @@ fn check_call(cx: ctx, sc: scope, f: @ast::expr, args: [@ast::expr])\n                         break;\n                     }\n                   }\n-                  none. { }\n+                  none { }\n                 }\n             }\n             i += 1u;\n@@ -335,7 +335,7 @@ fn check_alt(cx: ctx, input: @ast::expr, arms: [ast::arm], sc: scope,\n                 let canon_id = pat_id_map.get(proot.name);\n                 alt vec::find(binding_info, {|x| x.id == canon_id}) {\n                   some(s) { s.unsafe_tys += unsafe_set(proot.mut); }\n-                  none. {\n+                  none {\n                       binding_info += [\n                           {id: canon_id,\n                            mutable unsafe_tys: unsafe_set(proot.mut),\n@@ -466,8 +466,8 @@ fn test_scope(cx: ctx, sc: scope, b: binding, p: @ast::path) {\n     if !is_none(prob) && cant_copy(cx, b) {\n         let i = option::get(prob);\n         let msg = alt i.reason {\n-          overwritten. { \"overwriting \" + ast_util::path_name(i.path) }\n-          val_taken. { \"taking the value of \" + ast_util::path_name(i.path) }\n+          overwritten { \"overwriting \" + ast_util::path_name(i.path) }\n+          val_taken { \"taking the value of \" + ast_util::path_name(i.path) }\n         };\n         err(cx, i.sp, msg + \" will invalidate reference \" +\n             ast_util::path_name(p) + \", which is still used\");\n@@ -523,7 +523,7 @@ fn ty_can_unsafely_include(cx: ctx, needle: unsafe_ty, haystack: ty::t,\n             for t in ts { if helper(tcx, needle, t, mut) { ret true; } }\n             ret false;\n           }\n-          ty::ty_fn({proto: ast::proto_bare., _}) { ret false; }\n+          ty::ty_fn({proto: ast::proto_bare, _}) { ret false; }\n           // These may contain anything.\n           ty::ty_fn(_) | ty::ty_iface(_, _) { ret true; }\n           // A type param may include everything, but can only be\n@@ -557,13 +557,13 @@ fn local_id_of_node(cx: ctx, id: node_id) -> uint {\n fn copy_is_expensive(tcx: ty::ctxt, ty: ty::t) -> bool {\n     fn score_ty(tcx: ty::ctxt, ty: ty::t) -> uint {\n         ret alt ty::struct(tcx, ty) {\n-          ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int(_) |\n-          ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type. | ty::ty_native(_) |\n+          ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) |\n+          ty::ty_uint(_) | ty::ty_float(_) | ty::ty_type | ty::ty_native(_) |\n           ty::ty_ptr(_) { 1u }\n           ty::ty_box(_) | ty::ty_iface(_, _) { 3u }\n           ty::ty_constr(t, _) | ty::ty_res(_, t, _) { score_ty(tcx, t) }\n           ty::ty_fn(_) | ty::ty_native_fn(_, _) { 4u }\n-          ty::ty_str. | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n+          ty::ty_str | ty::ty_vec(_) | ty::ty_param(_, _) { 50u }\n           ty::ty_uniq(mt) { 1u + score_ty(tcx, mt.ty) }\n           ty::ty_tag(_, ts) | ty::ty_tup(ts) {\n             let sum = 0u;\n@@ -590,7 +590,7 @@ fn pattern_roots(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat)\n     fn walk(tcx: ty::ctxt, mut: option::t<unsafe_ty>, pat: @ast::pat,\n             &set: [pattern_root]) {\n         alt normalize_pat(tcx, pat).node {\n-          ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) {}\n+          ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) {}\n           ast::pat_ident(nm, sub) {\n             set += [{id: pat.id, name: path_to_ident(nm), mut: mut,\n                         span: pat.span}];\n@@ -648,7 +648,7 @@ fn find_invalid(id: node_id, lst: list<@invalid>)\n     let cur = lst;\n     while true {\n         alt cur {\n-          list::nil. { break; }\n+          list::nil { break; }\n           list::cons(head, tail) {\n             if head.node_id == id { ret some(head); }\n             cur = *tail;"}, {"sha": "9fb600d41c7b77be4398352a6fbaf14f030b82d4", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -75,11 +75,11 @@ fn check_capture_clause(tcx: ty::ctxt,\n     };\n \n     alt fn_proto {\n-      ast::proto_any. | ast::proto_block. {\n+      ast::proto_any | ast::proto_block {\n         check_block_captures(cap_clause.copies);\n         check_block_captures(cap_clause.moves);\n       }\n-      ast::proto_bare. | ast::proto_box. | ast::proto_uniq. {\n+      ast::proto_bare | ast::proto_box | ast::proto_uniq {\n         vec::iter(cap_clause.copies, check_capture_item);\n         vec::iter(cap_clause.moves, check_capture_item);\n         vec::iter(cap_clause.moves, check_not_upvar);\n@@ -113,15 +113,15 @@ fn compute_capture_vars(tcx: ty::ctxt,\n     }\n \n     let implicit_mode = alt fn_proto {\n-      ast::proto_any. | ast::proto_block. { cap_ref }\n-      ast::proto_bare. | ast::proto_box. | ast::proto_uniq. { cap_copy }\n+      ast::proto_any | ast::proto_block { cap_ref }\n+      ast::proto_bare | ast::proto_box | ast::proto_uniq { cap_copy }\n     };\n \n     vec::iter(*freevars) { |fvar|\n         let fvar_def_id = ast_util::def_id_of_def(fvar.def).node;\n         alt cap_map.find(fvar_def_id) {\n           option::some(_) { /* was explicitly named, do nothing */ }\n-          option::none. {\n+          option::none {\n             cap_map.insert(fvar_def_id, {def:fvar.def, mode:implicit_mode});\n           }\n         }"}, {"sha": "15b4a074b3722825524b2dc88f2f242752bc4f20", "filename": "src/comp/middle/check_alt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_alt.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -73,7 +73,7 @@ fn pattern_supersedes(tcx: ty::ctxt, a: @pat, b: @pat) -> bool {\n \n     alt a.node {\n       pat_ident(_, some(p)) { pattern_supersedes(tcx, p, b) }\n-      pat_wild. | pat_ident(_, none.) { true }\n+      pat_wild | pat_ident(_, none) { true }\n       pat_lit(la) {\n         alt b.node {\n           pat_lit(lb) { lit_expr_eq(la, lb) }\n@@ -142,7 +142,7 @@ fn is_refutable(tcx: ty::ctxt, pat: @pat) -> bool {\n       pat_box(sub) | pat_uniq(sub) | pat_ident(_, some(sub)) {\n         is_refutable(tcx, sub)\n       }\n-      pat_wild. | pat_ident(_, none.) { false }\n+      pat_wild | pat_ident(_, none) { false }\n       pat_lit(_) { true }\n       pat_rec(fields, _) {\n         for field: field_pat in fields {"}, {"sha": "b623bfc1795fd539f89123a7a6c4d2858158da6e", "filename": "src/comp/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcheck_const.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -45,7 +45,7 @@ fn check_expr(sess: session, e: @expr, &&is_const: bool, v: visit::vt<bool>) {\n     if is_const {\n         alt e.node {\n           expr_unary(box(_), _) | expr_unary(uniq(_), _) |\n-          expr_unary(deref., _){\n+          expr_unary(deref, _){\n             sess.span_err(e.span,\n                           \"disallowed operator in constant expression\");\n             ret;"}, {"sha": "0a0259ec584aa1f8a3ed597c4dfc60d15106a786", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -160,7 +160,7 @@ fn create_compile_unit(cx: @crate_ctxt, full_path: str)\n     alt cached_metadata::<@metadata<compile_unit_md>>(cache, tg,\n                         {|md| md.data.path == full_path}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     let work_dir = cx.sess.working_dir;\n@@ -202,7 +202,7 @@ fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     alt cached_metadata::<@metadata<file_md>>(\n         cache, tg, {|md| md.data.path == full_path}) {\n         option::some(md) { ret md; }\n-        option::none. {}\n+        option::none {}\n     }\n \n     let fname = fs::basename(full_path);\n@@ -234,17 +234,17 @@ fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n         cache, tg,\n         {|md| start == md.data.start && end == md.data.end}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     let parent = alt cx.parent {\n-      trans_common::parent_none. { create_function(cx.fcx).node }\n+      trans_common::parent_none { create_function(cx.fcx).node }\n       trans_common::parent_some(bcx) { create_block(cx).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n       option::some(v) { vec::len(v) as int }\n-      option::none. { 0 }\n+      option::none { 0 }\n     };\n     let lldata = [lltag(tg),\n                   parent,\n@@ -270,30 +270,30 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| t == md.data.hash}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     let (name, (size, align), encoding) = alt ty.node {\n-      ast::ty_bool. {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n+      ast::ty_bool {(\"bool\", size_and_align_of::<bool>(), DW_ATE_boolean)}\n       ast::ty_int(m) { alt m {\n-        ast::ty_char. {(\"char\", size_and_align_of::<char>(), DW_ATE_unsigned)}\n-        ast::ty_i. {(\"int\", size_and_align_of::<int>(), DW_ATE_signed)}\n-        ast::ty_i8. {(\"i8\", size_and_align_of::<i8>(), DW_ATE_signed_char)}\n-        ast::ty_i16. {(\"i16\", size_and_align_of::<i16>(), DW_ATE_signed)}\n-        ast::ty_i32. {(\"i32\", size_and_align_of::<i32>(), DW_ATE_signed)}\n-        ast::ty_i64. {(\"i64\", size_and_align_of::<i64>(), DW_ATE_signed)}\n+        ast::ty_char {(\"char\", size_and_align_of::<char>(), DW_ATE_unsigned)}\n+        ast::ty_i {(\"int\", size_and_align_of::<int>(), DW_ATE_signed)}\n+        ast::ty_i8 {(\"i8\", size_and_align_of::<i8>(), DW_ATE_signed_char)}\n+        ast::ty_i16 {(\"i16\", size_and_align_of::<i16>(), DW_ATE_signed)}\n+        ast::ty_i32 {(\"i32\", size_and_align_of::<i32>(), DW_ATE_signed)}\n+        ast::ty_i64 {(\"i64\", size_and_align_of::<i64>(), DW_ATE_signed)}\n       }}\n       ast::ty_uint(m) { alt m {\n-        ast::ty_u. {(\"uint\", size_and_align_of::<uint>(), DW_ATE_unsigned)}\n-        ast::ty_u8. {(\"u8\", size_and_align_of::<u8>(), DW_ATE_unsigned_char)}\n-        ast::ty_u16. {(\"u16\", size_and_align_of::<u16>(), DW_ATE_unsigned)}\n-        ast::ty_u32. {(\"u32\", size_and_align_of::<u32>(), DW_ATE_unsigned)}\n-        ast::ty_u64. {(\"u64\", size_and_align_of::<u64>(), DW_ATE_unsigned)}\n+        ast::ty_u {(\"uint\", size_and_align_of::<uint>(), DW_ATE_unsigned)}\n+        ast::ty_u8 {(\"u8\", size_and_align_of::<u8>(), DW_ATE_unsigned_char)}\n+        ast::ty_u16 {(\"u16\", size_and_align_of::<u16>(), DW_ATE_unsigned)}\n+        ast::ty_u32 {(\"u32\", size_and_align_of::<u32>(), DW_ATE_unsigned)}\n+        ast::ty_u64 {(\"u64\", size_and_align_of::<u64>(), DW_ATE_unsigned)}\n       }}\n       ast::ty_float(m) { alt m {\n-        ast::ty_f. {(\"float\", size_and_align_of::<float>(), DW_ATE_float)}\n-        ast::ty_f32. {(\"f32\", size_and_align_of::<f32>(), DW_ATE_float)}\n-        ast::ty_f64. {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n+        ast::ty_f {(\"float\", size_and_align_of::<float>(), DW_ATE_float)}\n+        ast::ty_f32 {(\"f32\", size_and_align_of::<f32>(), DW_ATE_float)}\n+        ast::ty_f64 {(\"f64\", size_and_align_of::<f64>(), DW_ATE_float)}\n       }}\n     };\n \n@@ -325,7 +325,7 @@ fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }*/\n     let (size, align) = size_and_align_of::<ctypes::intptr_t>();\n     let fname = filename_from_span(cx, span);\n@@ -418,7 +418,7 @@ fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| ty::hash_ty(outer) == ty::hash_ty(md.data.hash)}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }*/\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n@@ -492,24 +492,24 @@ fn create_vec(cx: @crate_ctxt, vec_t: ty::t, elem_t: ty::t, vec_ty: @ast::ty)\n \n fn member_size_and_align(ty: @ast::ty) -> (int, int) {\n     alt ty.node {\n-      ast::ty_bool. { size_and_align_of::<bool>() }\n+      ast::ty_bool { size_and_align_of::<bool>() }\n       ast::ty_int(m) { alt m {\n-        ast::ty_char. { size_and_align_of::<char>() }\n-        ast::ty_i. { size_and_align_of::<int>() }\n-        ast::ty_i8. { size_and_align_of::<i8>() }\n-        ast::ty_i16. { size_and_align_of::<i16>() }\n-        ast::ty_i32. { size_and_align_of::<i32>() }\n+        ast::ty_char { size_and_align_of::<char>() }\n+        ast::ty_i { size_and_align_of::<int>() }\n+        ast::ty_i8 { size_and_align_of::<i8>() }\n+        ast::ty_i16 { size_and_align_of::<i16>() }\n+        ast::ty_i32 { size_and_align_of::<i32>() }\n       }}\n       ast::ty_uint(m) { alt m {\n-        ast::ty_u. { size_and_align_of::<uint>() }\n-        ast::ty_u8. { size_and_align_of::<i8>() }\n-        ast::ty_u16. { size_and_align_of::<u16>() }\n-        ast::ty_u32. { size_and_align_of::<u32>() }\n+        ast::ty_u { size_and_align_of::<uint>() }\n+        ast::ty_u8 { size_and_align_of::<i8>() }\n+        ast::ty_u16 { size_and_align_of::<u16>() }\n+        ast::ty_u32 { size_and_align_of::<u32>() }\n       }}\n       ast::ty_float(m) { alt m {\n-        ast::ty_f. { size_and_align_of::<float>() }\n-        ast::ty_f32. { size_and_align_of::<f32>() }\n-        ast::ty_f64. { size_and_align_of::<f64>() }\n+        ast::ty_f { size_and_align_of::<float>() }\n+        ast::ty_f32 { size_and_align_of::<f32>() }\n+        ast::ty_f64 { size_and_align_of::<f64>() }\n       }}\n       ast::ty_box(_) | ast::ty_uniq(_) {\n         size_and_align_of::<ctypes::uintptr_t>()\n@@ -534,14 +534,14 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     alt cached_metadata::<@metadata<tydesc_md>>(\n         cache, tg, {|md| t == md.data.hash}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }*/\n \n     fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: codemap::span) -> @ast::ty {\n         let ty = alt ty::struct(ccx_tcx(cx), t) {\n-          ty::ty_nil. { ast::ty_nil }\n-          ty::ty_bot. { ast::ty_bot }\n-          ty::ty_bool. { ast::ty_bool }\n+          ty::ty_nil { ast::ty_nil }\n+          ty::ty_bot { ast::ty_bot }\n+          ty::ty_bool { ast::ty_bool }\n           ty::ty_int(t) { ast::ty_int(t) }\n           ty::ty_float(t) { ast::ty_float(t) }\n           ty::ty_uint(t) { ast::ty_uint(t) }\n@@ -627,7 +627,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     alt cached_metadata::<@metadata<local_var_md>>(\n         cache, tg, {|md| md.data.id == local.node.id}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     let name = path_to_ident(alt pat_util::normalize_pat(bcx_tcx(bcx),\n@@ -640,7 +640,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      trans_common::parent_none. { create_function(bcx.fcx).node }\n+      trans_common::parent_none { create_function(bcx.fcx).node }\n       trans_common::parent_some(_) { create_block(bcx).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n@@ -650,7 +650,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n \n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       option::some(local_mem(v)) { v }\n-      option::none. {\n+      option::none {\n         alt bcx.fcx.lllocals.get(local.node.pat.id) {\n           local_imm(v) { v }\n         }\n@@ -671,7 +671,7 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     alt cached_metadata::<@metadata<argument_md>>(\n         cache, ArgVariableTag, {|md| md.data.id == arg.id}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     /*let arg_n = alt cx.ast_map.get(arg.id) {\n@@ -759,7 +759,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n         cache, SubprogramTag, {|md| md.data.path == path &&\n                                     /*md.data.path == ??*/ true}) {\n       option::some(md) { ret md; }\n-      option::none. {}\n+      option::none {}\n     }\n \n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n@@ -769,7 +769,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     let mangled = cx.item_symbols.get(key);\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         alt ret_ty.node {\n-          ast::ty_nil. { llnull() }\n+          ast::ty_nil { llnull() }\n           _ { create_ty(cx, ty::node_id_to_type(ccx_tcx(cx), id),\n                         ret_ty).node }\n         }"}, {"sha": "79ded67a2a99c3451e1f78f681bcbeb1f914c170", "filename": "src/comp/middle/fn_usage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ffn_usage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffn_usage.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -19,8 +19,8 @@ fn fn_usage_expr(expr: @ast::expr,\n       ast::expr_path(path) {\n         if !ctx.unsafe_fn_legal {\n             alt ctx.tcx.def_map.find(expr.id) {\n-              some(ast::def_fn(_, ast::unsafe_fn.)) |\n-              some(ast::def_native_fn(_, ast::unsafe_fn.)) {\n+              some(ast::def_fn(_, ast::unsafe_fn)) |\n+              some(ast::def_native_fn(_, ast::unsafe_fn)) {\n                 log(error, (\"expr=\", expr_to_str(expr)));\n                 ctx.tcx.sess.span_fatal(\n                     expr.span,\n@@ -33,7 +33,7 @@ fn fn_usage_expr(expr: @ast::expr,\n         if !ctx.generic_bare_fn_legal\n             && ty::expr_has_ty_params(ctx.tcx, expr) {\n             alt ty::struct(ctx.tcx, ty::expr_ty(ctx.tcx, expr)) {\n-              ty::ty_fn({proto: ast::proto_bare., _}) {\n+              ty::ty_fn({proto: ast::proto_bare, _}) {\n                 ctx.tcx.sess.span_fatal(\n                     expr.span,\n                     \"generic bare functions can only be called or bound\");"}, {"sha": "cce5b3973b8e4c73c5ab31ff1838dbb7cce61c8b", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -49,7 +49,7 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n               ast::expr_path(path) {\n                   let i = 0;\n                   alt def_map.find(expr.id) {\n-                    none. { fail (\"Not found: \" + path_to_str(path)) }\n+                    none { fail (\"Not found: \" + path_to_str(path)) }\n                     some(df) {\n                       let def = df;\n                       while i < depth {\n@@ -104,7 +104,7 @@ fn annotate_freevars(def_map: resolve::def_map, crate: @ast::crate) ->\n \n fn get_freevars(tcx: ty::ctxt, fid: ast::node_id) -> freevar_info {\n     alt tcx.freevars.find(fid) {\n-      none. { fail \"get_freevars: \" + int::str(fid) + \" has no freevars\"; }\n+      none { fail \"get_freevars: \" + int::str(fid) + \" has no freevars\"; }\n       some(d) { ret d; }\n     }\n }"}, {"sha": "f67ac128b5e7ab7fd5b97bbf1e177a557b67643d", "filename": "src/comp/middle/gc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fgc.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -51,7 +51,7 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n     let llvalptr = bld::PointerCast(bcx, llval, T_ptr(T_ptr(T_i8())));\n \n     alt td_r.kind {\n-      tk_derived. {\n+      tk_derived {\n         // It's a derived type descriptor. First, spill it.\n         let lltydescptr = trans::alloca(bcx, val_ty(lltydesc));\n \n@@ -81,11 +81,11 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n         bld::Call(llderivedtydescs, gcroot, [lltydescptr, lldestindex]);\n         bld::Call(bcx, gcroot, [llvalptr, llsrcindex]);\n       }\n-      tk_param. {\n+      tk_param {\n         bcx_tcx(cx).sess.bug(\"we should never be trying to root values \" +\n                                  \"of a type parameter\");\n       }\n-      tk_static. {\n+      tk_static {\n         // Static type descriptor.\n \n         let llstaticgcmeta =\n@@ -103,9 +103,9 @@ fn add_gc_root(cx: @block_ctxt, llval: ValueRef, ty: ty::t) -> @block_ctxt {\n \n fn type_is_gc_relevant(cx: ty::ctxt, ty: ty::t) -> bool {\n     alt ty::struct(cx, ty) {\n-      ty::ty_nil. | ty::ty_bot. | ty::ty_bool. | ty::ty_int(_) |\n-      ty::ty_float(_) | ty::ty_uint(_) | ty::ty_str. |\n-      ty::ty_type. | ty::ty_native(_) | ty::ty_ptr(_) | ty::ty_type. |\n+      ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) |\n+      ty::ty_float(_) | ty::ty_uint(_) | ty::ty_str |\n+      ty::ty_type | ty::ty_native(_) | ty::ty_ptr(_) | ty::ty_type. |\n       ty::ty_native(_) {\n         ret false;\n       }"}, {"sha": "600389b3058ff224ce2f386d104ecde74823d1cb", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -22,9 +22,9 @@ import driver::session::session;\n \n fn kind_to_str(k: kind) -> str {\n     alt k {\n-      kind_sendable. { \"sendable\" }\n-      kind_copyable. { \"copyable\" }\n-      kind_noncopyable. { \"noncopyable\" }\n+      kind_sendable { \"sendable\" }\n+      kind_copyable { \"copyable\" }\n+      kind_noncopyable { \"noncopyable\" }\n     }\n }\n \n@@ -61,10 +61,10 @@ fn with_appropriate_checker(cx: ctx, id: node_id,\n                             b: block(fn@(ctx, ty::t, sp: span))) {\n     let fty = ty::node_id_to_monotype(cx.tcx, id);\n     alt ty::ty_fn_proto(cx.tcx, fty) {\n-      proto_uniq. { b(check_send); }\n-      proto_box. { b(check_copy); }\n-      proto_bare. { b(check_none); }\n-      proto_any. | proto_block. { /* no check needed */ }\n+      proto_uniq { b(check_send); }\n+      proto_box { b(check_copy); }\n+      proto_bare { b(check_none); }\n+      proto_any | proto_block { /* no check needed */ }\n     }\n }\n \n@@ -135,7 +135,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_ret(some(ex)) { maybe_copy(cx, ex); }\n       expr_copy(expr) { check_copy_ex(cx, expr, false); }\n       // Vector add copies.\n-      expr_binary(add., ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n+      expr_binary(add, ls, rs) { maybe_copy(cx, ls); maybe_copy(cx, rs); }\n       expr_rec(fields, def) {\n         for field in fields { maybe_copy(cx, field.node.expr); }\n         alt def {\n@@ -163,7 +163,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n       expr_call(f, args, _) {\n         let i = 0u;\n         for arg_t in ty::ty_fn_args(cx.tcx, ty::expr_ty(cx.tcx, f)) {\n-            alt arg_t.mode { by_copy. { maybe_copy(cx, args[i]); } _ {} }\n+            alt arg_t.mode { by_copy { maybe_copy(cx, args[i]); } _ {} }\n             i += 1u;\n         }\n       }\n@@ -186,7 +186,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n                 i += 1u;\n             }\n           }\n-          none. {}\n+          none {}\n         }\n       }\n       expr_ternary(_, a, b) { maybe_copy(cx, a); maybe_copy(cx, b); }\n@@ -203,7 +203,7 @@ fn check_stmt(stmt: @stmt, cx: ctx, v: visit::vt<ctx>) {\n       stmt_decl(@{node: decl_local(locals), _}, _) {\n         for (_, local) in locals {\n             alt local.node.init {\n-              some({op: init_assign., expr}) { maybe_copy(cx, expr); }\n+              some({op: init_assign, expr}) { maybe_copy(cx, expr); }\n               _ {}\n             }\n         }"}, {"sha": "c5c7c5448317bf8b807aa4153ec6c8b8882949c8", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -80,7 +80,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         visit::visit_expr_opt(oexpr, cx, v);\n         leave_fn(cx);\n       }\n-      expr_break. { add_block_exit(cx, loop); }\n+      expr_break { add_block_exit(cx, loop); }\n       expr_while(_, _) | expr_do_while(_, _) {\n         visit_block(loop, cx) {|| visit::visit_expr(ex, cx, v);}\n       }\n@@ -160,7 +160,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n               }\n               _ {\n                 alt arg_ts[i].mode {\n-                  by_mut_ref. { clear_if_path(cx, arg, v, false); }\n+                  by_mut_ref { clear_if_path(cx, arg, v, false); }\n                   _ { v.visit_expr(arg, cx, v); }\n                 }\n               }\n@@ -179,12 +179,12 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     let fty = ty::node_id_to_type(cx.tcx, id);\n     let proto = ty::ty_fn_proto(cx.tcx, fty);\n     alt proto {\n-      proto_any. | proto_block. {\n+      proto_any | proto_block {\n         visit_block(func, cx, {||\n             visit::visit_fn(fk, decl, body, sp, id, cx, v);\n         });\n       }\n-      proto_box. | proto_uniq. | proto_bare. {\n+      proto_box | proto_uniq | proto_bare {\n         alt cx.tcx.freevars.find(id) {\n           some(vars) {\n             for v in *vars {\n@@ -283,8 +283,8 @@ fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n fn clear_def_if_path(cx: ctx, d: def, to: bool)\n     -> option<node_id> {\n     alt d {\n-      def_local(def_id, let_copy.) | def_arg(def_id, by_copy.) |\n-      def_arg(def_id, by_move.) {\n+      def_local(def_id, let_copy) | def_arg(def_id, by_copy) |\n+      def_arg(def_id, by_move) {\n         clear_in_current(cx, def_id.node, to);\n         some(def_id.node)\n       }"}, {"sha": "d67a03d4a53b3c88667a584b213a23bc8403c476", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -75,7 +75,7 @@ fn expr_root(tcx: ty::ctxt, ex: @expr, autoderef: bool) ->\n                        kind: index,\n                        outer_t: auto_unbox.t}];\n               }\n-              ty::ty_str. {\n+              ty::ty_str {\n                 ds += [@{mut: false, kind: index, outer_t: auto_unbox.t}];\n               }\n             }\n@@ -125,9 +125,9 @@ tag msg { msg_assign; msg_move_out; msg_mut_ref; }\n \n fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span, alt msg {\n-      msg_assign. { \"assigning to \" + name }\n-      msg_move_out. { \"moving out of \" + name }\n-      msg_mut_ref. { \"passing \" + name + \" by mutable reference\" }\n+      msg_assign { \"assigning to \" + name }\n+      msg_move_out { \"moving out of \" + name }\n+      msg_mut_ref { \"passing \" + name + \" by mutable reference\" }\n     });\n }\n \n@@ -140,7 +140,7 @@ fn visit_decl(cx: @ctx, d: @decl, &&e: (), v: visit::vt<()>) {\n               some(init) {\n                 if init.op == init_move { check_move_rhs(cx, init.expr); }\n               }\n-              none. { }\n+              none { }\n             }\n         }\n       }\n@@ -224,8 +224,8 @@ fn check_call(cx: @ctx, f: @expr, args: [@expr]) {\n     let i = 0u;\n     for arg_t: ty::arg in arg_ts {\n         alt arg_t.mode {\n-          by_mut_ref. { check_lval(cx, args[i], msg_mut_ref); }\n-          by_move. { check_lval(cx, args[i], msg_move_out); }\n+          by_mut_ref { check_lval(cx, args[i], msg_mut_ref); }\n+          by_move { check_lval(cx, args[i], msg_move_out); }\n           _ {}\n         }\n         i += 1u;\n@@ -239,15 +239,15 @@ fn check_bind(cx: @ctx, f: @expr, args: [option::t<@expr>]) {\n         alt arg {\n           some(expr) {\n             alt (alt arg_ts[i].mode {\n-              by_mut_ref. { some(\"by mutable reference\") }\n-              by_move. { some(\"by move\") }\n+              by_mut_ref { some(\"by mutable reference\") }\n+              by_move { some(\"by move\") }\n               _ { none }\n             }) {\n               some(name) {\n                 cx.tcx.sess.span_err(\n                     expr.span, \"can not bind an argument passed \" + name);\n               }\n-              none. {}\n+              none {}\n             }\n           }\n           _ {}\n@@ -262,19 +262,19 @@ fn is_immutable_def(cx: @ctx, def: def) -> option::t<str> {\n       def_use(_) {\n         some(\"static item\")\n       }\n-      def_arg(_, by_ref.) | def_arg(_, by_val.) |\n-      def_arg(_, mode_infer.) { some(\"argument\") }\n+      def_arg(_, by_ref) | def_arg(_, by_val) |\n+      def_arg(_, mode_infer) { some(\"argument\") }\n       def_self(_) { some(\"self argument\") }\n       def_upvar(_, inner, node_id) {\n         let ty = ty::node_id_to_monotype(cx.tcx, node_id);\n         let proto = ty::ty_fn_proto(cx.tcx, ty);\n         ret alt proto {\n-          proto_any. | proto_block. { is_immutable_def(cx, *inner) }\n+          proto_any | proto_block { is_immutable_def(cx, *inner) }\n           _ { some(\"upvar\") }\n         };\n       }\n       def_binding(_) { some(\"binding\") }\n-      def_local(_, let_ref.) { some(\"by-reference binding\") }\n+      def_local(_, let_ref) { some(\"by-reference binding\") }\n       _ { none }\n     }\n }"}, {"sha": "b949dce004dcfe923f998a00e9a5187583a0f295", "filename": "src/comp/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fpat_util.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -16,8 +16,8 @@ fn normalize_pat_def_map(dm: resolve::def_map, p: @pat) -> @pat {\n   // have to do it the hard way b/c ast fold doesn't pass around\n   // node IDs. bother.\n   alt p.node {\n-      pat_wild. { p }\n-      pat_ident(_, none.) { normalize_one(dm, p) }\n+      pat_wild { p }\n+      pat_ident(_, none) { normalize_one(dm, p) }\n       pat_ident(q, some(r)) {\n         @{node: pat_ident(q, some(normalize_pat_def_map(dm, r)))\n             with *p}\n@@ -58,7 +58,7 @@ fn normalize_one(dm: resolve::def_map, p: @pat) -> @pat {\n               _ { p }\n           }\n         }\n-        none. { p }\n+        none { p }\n     }\n }\n \n@@ -93,14 +93,14 @@ fn pat_id_map(tcx: ty::ctxt, pat: @pat) -> pat_id_map {\n // Could return a constrained type in order to express that (future work)\n fn pat_bindings(pat: @pat, it: block(@pat)) {\n   alt pat.node {\n-      pat_ident(_, option::none.) { it(pat); }\n+      pat_ident(_, option::none) { it(pat); }\n       pat_ident(_, option::some(sub)) { it(pat); pat_bindings(sub, it); }\n       pat_tag(_, sub) { for p in sub { pat_bindings(p, it); } }\n       pat_rec(fields, _) { for f in fields { pat_bindings(f.pat, it); } }\n       pat_tup(elts) { for elt in elts { pat_bindings(elt, it); } }\n       pat_box(sub) { pat_bindings(sub, it); }\n       pat_uniq(sub) { pat_bindings(sub, it); }\n-      pat_wild. | pat_lit(_) | pat_range(_, _) { }\n+      pat_wild | pat_lit(_) | pat_range(_, _) { }\n     }\n }\n \n@@ -112,7 +112,7 @@ fn pat_binding_ids(pat: @pat) -> [node_id] {\n \n fn path_to_ident(p: @path) -> ident {\n     alt vec::last(p.node.idents) {\n-        none. { // sigh\n+        none { // sigh\n           fail \"Malformed path\"; }\n       some(i) { ret i; }\n     }"}, {"sha": "487ea5366884276d9c599c03e09af3d7d4ba4011", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -71,8 +71,8 @@ fn new_ext_hash() -> ext_hash {\n         ret str::hash(v.ident) + util::common::hash_def(v.did) +\n                 alt v.ns {\n                   ns_val(_) { 1u }\n-                  ns_type. { 2u }\n-                  ns_module. { 3u }\n+                  ns_type { 2u }\n+                  ns_module { 3u }\n                 };\n     }\n     fn eq(v1: key, v2: key) -> bool {\n@@ -88,8 +88,8 @@ fn new_exp_hash() -> exp_map {\n         ret str::hash(v.path) +\n                 alt v.ns {\n                   ns_val(_) { 1u }\n-                  ns_type. { 2u }\n-                  ns_module. { 3u }\n+                  ns_type { 2u }\n+                  ns_module { 3u }\n                 };\n     }\n     fn eq(v1: key, v2: key) -> bool {\n@@ -286,11 +286,11 @@ fn map_crate(e: @env, c: @ast::crate) {\n                   }\n                   scope_block(b, _, _) {\n                     let globs = alt e.block_map.find(b.node.id) {\n-                      some(globs) { globs + [glob] } none. { [glob] }\n+                      some(globs) { globs + [glob] } none { [glob] }\n                     };\n                     e.block_map.insert(b.node.id, globs);\n                   }\n-                  scope_crate. {\n+                  scope_crate {\n                     e.mod_map.get(ast::crate_node_id).glob_imports += [glob];\n                   }\n                 }\n@@ -422,7 +422,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           }\n           /* Here we determine whether a given pat_ident binds a new\n            variable a refers to a nullary tag. */\n-          ast::pat_ident(p, none.) {\n+          ast::pat_ident(p, none) {\n               let fnd = lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n                                     ns_val(ns_a_tag));\n               alt fnd {\n@@ -504,8 +504,8 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n       visit::fk_method(_, tps) { scope_bare_fn(decl, id, tps) }\n-      visit::fk_anon(ast::proto_bare.) { scope_bare_fn(decl, id, []) }\n-      visit::fk_anon(_) | visit::fk_fn_block. { scope_fn_expr(decl, id, []) }\n+      visit::fk_anon(ast::proto_bare) { scope_bare_fn(decl, id, []) }\n+      visit::fk_anon(_) | visit::fk_fn_block { scope_fn_expr(decl, id, []) }\n     };\n \n     visit::visit_fn(fk, decl, body, sp, id, cons(scope, @sc), v);\n@@ -557,7 +557,7 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n }\n \n // This is only for irrefutable patterns (e.g. ones that appear in a let)\n-// So if x occurs, and x is already known to be a tag, that's always an error.\n+// So if x occurs, and x is already known to be a tag, that's always an error\n fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n     // Check whether the given local has the same name as a tag that's\n     // in scope\n@@ -616,7 +616,7 @@ fn resolve_constr(e: @env, c: @ast::constr, sc: scopes, _v: vt<scopes>) {\n                            ns_val(ns_any_value));\n     if option::is_some(new_def) {\n         alt option::get(new_def) {\n-          ast::def_fn(pred_id, ast::pure_fn.) {\n+          ast::def_fn(pred_id, ast::pure_fn) {\n             e.def_map.insert(c.node.id, ast::def_fn(pred_id, ast::pure_fn));\n           }\n           _ {\n@@ -675,7 +675,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n           cons(scope_block(b, _, _), _) {\n             lst(id, b.node.view_items)\n           }\n-          cons(scope_crate., _) {\n+          cons(scope_crate, _) {\n             lst(id,\n                 option::get(e.mod_map.get(ast::crate_node_id).m).view_items)\n           }\n@@ -693,7 +693,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                  {|ns| lookup_in_scope(e, sc, sp, end_id, ns) }, []);\n     } else {\n         alt lookup_in_scope(e, sc, sp, ids[0], ns_module) {\n-          none. {\n+          none {\n             unresolved_err(e, in_scope(sc), sp, ids[0], ns_name(ns_module));\n           }\n           some(dcur_) {\n@@ -710,7 +710,7 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n                     dcur = alt lookup_in_mod(e, dcur, sp, ids[i], ns_module,\n                                              outside) {\n                       some(dcur) { dcur }\n-                      none. {\n+                      none {\n                         unresolved_err(e, in_mod(dcur), sp, ids[i],\n                                        ns_name(ns_module));\n                         break;\n@@ -738,14 +738,14 @@ fn resolve_import(e: env, defid: ast::def_id, name: ast::ident,\n // Utilities\n fn ns_name(ns: namespace) -> str {\n     alt ns {\n-      ns_type. { \"typename\" }\n+      ns_type { \"typename\" }\n       ns_val(v) {\n           alt (v) {\n-              ns_any_value. { \"name\" }\n-              ns_a_tag.     { \"tag\" }\n+              ns_any_value { \"name\" }\n+              ns_a_tag     { \"tag\" }\n           }\n       }\n-      ns_module. { ret \"modulename\" }\n+      ns_module { ret \"modulename\" }\n     }\n }\n \n@@ -758,7 +758,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             alt sc {\n               cons(cur, rest) {\n                 alt cur {\n-                  scope_crate. | scope_bare_fn(_, _, _) |\n+                  scope_crate | scope_bare_fn(_, _, _) |\n                   scope_fn_expr(_, _, _) |\n                   scope_item(@{node: ast::item_mod(_), _}) {\n                     ret some(cur);\n@@ -835,7 +835,7 @@ fn lookup_path_strict(e: env, sc: scopes, sp: span, pth: ast::path_,\n fn lookup_in_scope_strict(e: env, sc: scopes, sp: span, name: ident,\n                           ns: namespace) -> option::t<def> {\n     alt lookup_in_scope(e, sc, sp, name, ns) {\n-      none. {\n+      none {\n         unresolved_err(e, in_scope(sc), sp, name, ns_name(ns));\n         ret none;\n       }\n@@ -884,7 +884,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n        option::t<def> {\n         alt s {\n-          scope_crate. {\n+          scope_crate {\n             ret lookup_in_local_mod(e, ast::crate_node_id, sp,\n                                     name, ns, inside);\n           }\n@@ -953,7 +953,7 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n     let sc = sc;\n     while true {\n         alt copy sc {\n-          nil. { ret none::<def>; }\n+          nil { ret none::<def>; }\n           cons(hd, tl) {\n             let fnd = in_scope(e, sp, name, hd, ns);\n             if !is_none(fnd) {\n@@ -962,15 +962,15 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                 if left_fn && local || left_fn_level2 && self_scope\n                    || scope_is_fn(hd) && left_fn && def_is_ty_arg(df) {\n                     let msg = alt ns {\n-                      ns_type. {\n+                      ns_type {\n                         \"attempt to use a type argument out of scope\"\n                       }\n                       ns_val(v) {\n                           alt(v) {\n                             /* If we were looking for a tag, at this point\n                                we know it's bound to a non-tag value, and\n                                we can return none instead of failing */\n-                            ns_a_tag. { ret none; }\n+                            ns_a_tag { ret none; }\n                             _ { \"attempted dynamic environment-capture\" }\n                           }\n                       }\n@@ -1009,7 +1009,7 @@ fn lookup_in_ty_params(e: env, name: ident, ty_params: [ast::ty_param])\n     let n = 0u;\n     for tp: ast::ty_param in ty_params {\n         if str::eq(tp.ident, name) && alt e.current_tp {\n-            some(cur) { n < cur } none. { true }\n+            some(cur) { n < cur } none { true }\n         } { ret some(ast::def_ty_param(local_def(tp.id), n)); }\n         n += 1u;\n     }\n@@ -1031,15 +1031,15 @@ fn lookup_in_fn(e: env, name: ident, decl: ast::fn_decl,\n                 ty_params: [ast::ty_param],\n                 ns: namespace) -> option::t<def> {\n     alt ns {\n-      ns_val(ns_any_value.) {\n+      ns_val(ns_any_value) {\n         for a: ast::arg in decl.inputs {\n             if str::eq(a.ident, name) {\n                 ret some(ast::def_arg(local_def(a.id), a.mode));\n             }\n         }\n         ret none::<def>;\n       }\n-      ns_type. { ret lookup_in_ty_params(e, name, ty_params); }\n+      ns_type { ret lookup_in_ty_params(e, name, ty_params); }\n       _ { ret none::<def>; }\n     }\n }\n@@ -1155,10 +1155,10 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       }\n       ast::item_res(_, _, _, _, ctor_id) {\n         alt ns {\n-          ns_val(ns_any_value.) {\n+          ns_val(ns_any_value) {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n           }\n-          ns_type. { ret some(ast::def_ty(local_def(i.id))); }\n+          ns_type { ret some(ast::def_ty(local_def(i.id))); }\n           _ { }\n         }\n       }\n@@ -1170,7 +1170,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n fn lookup_in_mod_strict(e: env, m: def, sp: span, name: ident,\n                         ns: namespace, dr: dir) -> option::t<def> {\n     alt lookup_in_mod(e, m, sp, name, ns, dr) {\n-      none. {\n+      none {\n         unresolved_err(e, in_mod(m), sp, name, ns_name(ns));\n         ret none;\n       }\n@@ -1231,8 +1231,8 @@ fn lookup_import(e: env, defid: def_id, ns: namespace) -> option::t<def> {\n         if e.used_imports.track {\n             e.used_imports.data += [defid.node];\n         }\n-        ret alt ns { ns_val(_) { val } ns_type. { typ }\n-                     ns_module. { md } };\n+        ret alt ns { ns_val(_) { val } ns_type { typ }\n+                     ns_module { md } };\n       }\n     }\n }\n@@ -1254,12 +1254,12 @@ fn lookup_in_local_mod(e: env, node_id: node_id, sp: span, id: ident,\n         ret none::<def>; // name is not visible\n     }\n     alt info.index.find(id) {\n-      none. { }\n+      none { }\n       some(lst_) {\n         let lst = lst_;\n         while true {\n             alt lst {\n-              nil. { break; }\n+              nil { break; }\n               cons(hd, tl) {\n                 let found = lookup_in_mie(e, hd, ns);\n                 if !is_none(found) { ret found; }\n@@ -1284,7 +1284,7 @@ fn lookup_in_globs(e: env, globs: [glob_imp_def], sp: span, id: ident,\n         }\n         alt lookup_in_mod(e, def.def, sp, name, ns, dr) {\n           some(d) { option::some({def: d, item: def.item}) }\n-          none. { none }\n+          none { none }\n         }\n     }\n     let matches = vec::filter_map(copy globs,\n@@ -1326,8 +1326,8 @@ fn lookup_glob_in_mod(e: env, info: @indexed_mod, sp: span, id: ident,\n       glob_resolved(val, typ, md) {\n         ret alt wanted_ns {\n                 ns_val(_) { val }\n-                ns_type. { typ }\n-                ns_module. { md }\n+                ns_type { typ }\n+                ns_module { md }\n         };\n       }\n     }\n@@ -1357,7 +1357,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n       }\n       mie_native_item(native_item) {\n         alt native_item.node {\n-          ast::native_item_ty. {\n+          ast::native_item_ty {\n             if ns == ns_type {\n                 ret some(ast::def_native_ty(local_def(native_item.id)));\n             }\n@@ -1380,7 +1380,7 @@ fn lookup_in_mie(e: env, mie: mod_index_entry, ns: namespace) ->\n fn add_to_index(index: hashmap<ident, list<mod_index_entry>>, id: ident,\n                 ent: mod_index_entry) {\n     alt index.find(id) {\n-      none. { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n+      none { index.insert(id, cons(ent, @nil::<mod_index_entry>)); }\n       some(prev) { index.insert(id, cons(ent, @prev)); }\n     }\n }\n@@ -1471,7 +1471,7 @@ fn ns_for_def(d: def) -> namespace {\n // a tag\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n     alt actual {\n-      ns_val(ns_a_tag.) {\n+      ns_val(ns_a_tag) {\n         alt wanted {\n           ns_val(_) { true }\n           _ { false }\n@@ -1556,7 +1556,7 @@ fn check_mod_name(e: env, name: ident, entries: list<mod_index_entry>) {\n             }\n             entries = *rest;\n           }\n-          nil. { break; }\n+          nil { break; }\n         }\n     }\n }\n@@ -1798,7 +1798,7 @@ fn check_exports(e: @env) {\n                 }\n             }\n           }\n-          none. { }\n+          none { }\n         }\n     };\n }\n@@ -1892,7 +1892,7 @@ fn find_impls_in_mod(e: env, m: def, &impls: [@_impl],\n         let cached;\n         alt e.impl_cache.find(defid) {\n           some(v) { cached = v; }\n-          none. {\n+          none {\n             cached = if defid.crate == ast::local_crate {\n                 let tmp = [];\n                 for i in option::get(e.mod_map.get(defid.node).m).items {"}, {"sha": "39835854fea7af4681d18a2a3e267bbed7057cc3", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -313,44 +313,44 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n     let s = [];\n \n     alt ty::struct(ccx.tcx, t) {\n-      ty::ty_nil. | ty::ty_bool. | ty::ty_uint(ast::ty_u8.) |\n-      ty::ty_bot. { s += [shape_u8]; }\n-      ty::ty_int(ast::ty_i.) { s += [s_int(ccx.tcx)]; }\n-      ty::ty_float(ast::ty_f.) { s += [s_float(ccx.tcx)]; }\n-      ty::ty_uint(ast::ty_u.) | ty::ty_ptr(_) |\n+      ty::ty_nil | ty::ty_bool | ty::ty_uint(ast::ty_u8) |\n+      ty::ty_bot { s += [shape_u8]; }\n+      ty::ty_int(ast::ty_i) { s += [s_int(ccx.tcx)]; }\n+      ty::ty_float(ast::ty_f) { s += [s_float(ccx.tcx)]; }\n+      ty::ty_uint(ast::ty_u) | ty::ty_ptr(_) |\n       ty::ty_native(_) { s += [s_uint(ccx.tcx)]; }\n-      ty::ty_type. { s += [s_tydesc(ccx.tcx)]; }\n-      ty::ty_send_type. { s += [s_send_tydesc(ccx.tcx)]; }\n-      ty::ty_int(ast::ty_i8.) { s += [shape_i8]; }\n-      ty::ty_uint(ast::ty_u16.) { s += [shape_u16]; }\n-      ty::ty_int(ast::ty_i16.) { s += [shape_i16]; }\n-      ty::ty_uint(ast::ty_u32.) { s += [shape_u32]; }\n-      ty::ty_int(ast::ty_i32.) | ty::ty_int(ast::ty_char.) {s += [shape_i32];}\n-      ty::ty_uint(ast::ty_u64.) { s += [shape_u64]; }\n-      ty::ty_int(ast::ty_i64.) { s += [shape_i64]; }\n-      ty::ty_float(ast::ty_f32.) { s += [shape_f32]; }\n-      ty::ty_float(ast::ty_f64.) { s += [shape_f64]; }\n-      ty::ty_str. {\n+      ty::ty_type { s += [s_tydesc(ccx.tcx)]; }\n+      ty::ty_send_type { s += [s_send_tydesc(ccx.tcx)]; }\n+      ty::ty_int(ast::ty_i8) { s += [shape_i8]; }\n+      ty::ty_uint(ast::ty_u16) { s += [shape_u16]; }\n+      ty::ty_int(ast::ty_i16) { s += [shape_i16]; }\n+      ty::ty_uint(ast::ty_u32) { s += [shape_u32]; }\n+      ty::ty_int(ast::ty_i32) | ty::ty_int(ast::ty_char) {s += [shape_i32];}\n+      ty::ty_uint(ast::ty_u64) { s += [shape_u64]; }\n+      ty::ty_int(ast::ty_i64) { s += [shape_i64]; }\n+      ty::ty_float(ast::ty_f32) { s += [shape_f32]; }\n+      ty::ty_float(ast::ty_f64) { s += [shape_f64]; }\n+      ty::ty_str {\n         s += [shape_vec];\n         add_bool(s, true); // type is POD\n         let unit_ty = ty::mk_mach_uint(ccx.tcx, ast::ty_u8);\n         add_substr(s, shape_of(ccx, unit_ty, ty_param_map));\n       }\n       ty::ty_tag(did, tps) {\n         alt tag_kind(ccx, did) {\n-          tk_unit. {\n+          tk_unit {\n             // FIXME: For now we do this.\n             s += [s_variant_tag_t(ccx.tcx)];\n           }\n-          tk_enum. { s += [s_variant_tag_t(ccx.tcx)]; }\n-          tk_complex. {\n+          tk_enum { s += [s_variant_tag_t(ccx.tcx)]; }\n+          tk_complex {\n             s += [shape_tag];\n \n             let sub = [];\n \n             let id;\n             alt ccx.shape_cx.tag_id_to_index.find(did) {\n-              none. {\n+              none {\n                 id = ccx.shape_cx.next_tag_id;\n                 ccx.shape_cx.tag_id_to_index.insert(did, id);\n                 ccx.shape_cx.tag_order += [did];\n@@ -423,19 +423,19 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t, ty_param_map: [uint]) -> [u8] {\n         // Find the type parameter in the parameter list.\n         alt vec::position(n, ty_param_map) {\n           some(i) { s += [shape_var, i as u8]; }\n-          none. { fail \"ty param not found in ty_param_map\"; }\n+          none { fail \"ty param not found in ty_param_map\"; }\n         }\n       }\n-      ty::ty_fn({proto: ast::proto_box., _}) {\n+      ty::ty_fn({proto: ast::proto_box, _}) {\n         s += [shape_box_fn];\n       }\n-      ty::ty_fn({proto: ast::proto_uniq., _}) {\n+      ty::ty_fn({proto: ast::proto_uniq, _}) {\n         s += [shape_uniq_fn];\n       }\n-      ty::ty_fn({proto: ast::proto_block., _}) {\n+      ty::ty_fn({proto: ast::proto_block, _}) {\n         s += [shape_stack_fn];\n       }\n-      ty::ty_fn({proto: ast::proto_bare., _}) {\n+      ty::ty_fn({proto: ast::proto_bare, _}) {\n         s += [shape_bare_fn];\n       }\n       ty::ty_opaque_closure_ptr(_) {"}, {"sha": "825a76f32b12e06edd7ad595ef870427e9231a14", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 151, "deletions": 151, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -126,15 +126,15 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n     if cx.lltypes.contains_key(t) { ret cx.lltypes.get(t); }\n     let llty = alt ty::struct(cx.tcx, t) {\n       ty::ty_native(_) { T_ptr(T_i8()) }\n-      ty::ty_nil. { T_nil() }\n-      ty::ty_bot. {\n+      ty::ty_nil { T_nil() }\n+      ty::ty_bot {\n         T_nil() /* ...I guess? */\n       }\n-      ty::ty_bool. { T_bool() }\n+      ty::ty_bool { T_bool() }\n       ty::ty_int(t) { T_int_ty(cx, t) }\n       ty::ty_uint(t) { T_uint_ty(cx, t) }\n       ty::ty_float(t) { T_float_ty(cx, t) }\n-      ty::ty_str. { T_ptr(T_vec(cx, T_i8())) }\n+      ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n       ty::ty_tag(did, _) { type_of_tag(cx, sp, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n@@ -188,7 +188,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         std::util::unreachable()\n       }\n       ty::ty_param(_, _) { T_typaram(cx.tn) }\n-      ty::ty_send_type. | ty::ty_type. { T_ptr(cx.tydesc_type) }\n+      ty::ty_send_type | ty::ty_type { T_ptr(cx.tydesc_type) }\n       ty::ty_tup(elts) {\n         let tys = [];\n         for elt in elts {\n@@ -442,7 +442,7 @@ fn dynastack_alloca(cx: @block_ctxt, t: TypeRef, n: ValueRef, ty: ty::t) ->\n     let bcx = cx;\n     let dy_cx = new_raw_block_ctxt(cx.fcx, cx.fcx.lldynamicallocas);\n     alt bcx_fcx(cx).llobstacktoken {\n-      none. {\n+      none {\n         bcx_fcx(cx).llobstacktoken =\n             some(mk_obstack_token(bcx_ccx(cx), cx.fcx));\n       }\n@@ -935,7 +935,7 @@ fn get_derived_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n             ret rslt(cx, info.lltydesc);\n         }\n       }\n-      none. {/* fall through */ }\n+      none {/* fall through */ }\n     }\n \n     bcx_ccx(cx).stats.n_derived_tydescs += 1u;\n@@ -1015,7 +1015,7 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n                                           uint::str(id));\n         }\n       }\n-      none. {/* fall through */ }\n+      none {/* fall through */ }\n     }\n \n     // Does it contain a type param? If so, generate a derived tydesc.\n@@ -1033,7 +1033,7 @@ fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     alt bcx_ccx(cx).tydescs.find(t) {\n       some(info) { ret info; }\n-      none. {\n+      none {\n         bcx_ccx(cx).stats.n_static_tydescs += 1u;\n         let info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params);\n         bcx_ccx(cx).tydescs.insert(t, info);\n@@ -1199,22 +1199,22 @@ fn emit_tydescs(ccx: @crate_ctxt) {\n         let ti = val;\n         let take_glue =\n             alt ti.take_glue {\n-              none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let drop_glue =\n             alt ti.drop_glue {\n-              none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let free_glue =\n             alt ti.free_glue {\n-              none. { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n+              none { ccx.stats.n_null_glues += 1u; C_null(glue_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n         let cmp_glue =\n             alt ti.cmp_glue {\n-              none. { ccx.stats.n_null_glues += 1u; C_null(cmp_fn_ty) }\n+              none { ccx.stats.n_null_glues += 1u; C_null(cmp_fn_ty) }\n               some(v) { ccx.stats.n_real_glues += 1u; v }\n             };\n \n@@ -1264,12 +1264,12 @@ fn make_take_glue(cx: @block_ctxt, v: ValueRef, t: ty::t) {\n         Store(r.bcx, r.val, v);\n         r.bcx\n       }\n-      ty::ty_vec(_) | ty::ty_str. {\n+      ty::ty_vec(_) | ty::ty_str {\n         let r = tvec::duplicate(bcx, Load(bcx, v), t);\n         Store(r.bcx, r.val, v);\n         r.bcx\n       }\n-      ty::ty_send_type. {\n+      ty::ty_send_type {\n         // sendable type descriptors are basically unique pointers,\n         // they must be cloned when copied:\n         let r = Load(bcx, v);\n@@ -1328,7 +1328,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n         let v = PointerCast(bcx, v, type_of_1(bcx, t));\n         trans_uniq::make_free_glue(bcx, v, t)\n       }\n-      ty::ty_vec(_) | ty::ty_str. {\n+      ty::ty_vec(_) | ty::ty_str {\n         tvec::make_free_glue(bcx, PointerCast(bcx, v, type_of_1(bcx, t)), t)\n       }\n       ty::ty_iface(_, _) {\n@@ -1345,7 +1345,7 @@ fn make_free_glue(bcx: @block_ctxt, v: ValueRef, t: ty::t) {\n                               abi::tydesc_field_drop_glue, ti);\n         trans_free_if_not_gc(bcx, b)\n       }\n-      ty::ty_send_type. {\n+      ty::ty_send_type {\n         // sendable type descriptors are basically unique pointers,\n         // they must be freed.\n         let ccx = bcx_ccx(bcx);\n@@ -1372,7 +1372,7 @@ fn make_drop_glue(bcx: @block_ctxt, v0: ValueRef, t: ty::t) {\n           ty::ty_box(_) | ty::ty_iface(_, _) {\n               decr_refcnt_maybe_free(bcx, Load(bcx, v0), t)\n           }\n-          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. | ty::ty_send_type. {\n+          ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str | ty::ty_send_type {\n             free_ty(bcx, Load(bcx, v0), t)\n           }\n           ty::ty_res(did, inner, tps) {\n@@ -1478,12 +1478,12 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n     let f = bind compare_scalar_values(cx, lhs, rhs, _, op);\n \n     alt ty::struct(bcx_tcx(cx), t) {\n-      ty::ty_nil. { ret rslt(cx, f(nil_type)); }\n-      ty::ty_bool. | ty::ty_ptr(_) { ret rslt(cx, f(unsigned_int)); }\n+      ty::ty_nil { ret rslt(cx, f(nil_type)); }\n+      ty::ty_bool | ty::ty_ptr(_) { ret rslt(cx, f(unsigned_int)); }\n       ty::ty_int(_) { ret rslt(cx, f(signed_int)); }\n       ty::ty_uint(_) { ret rslt(cx, f(unsigned_int)); }\n       ty::ty_float(_) { ret rslt(cx, f(floating_point)); }\n-      ty::ty_type. {\n+      ty::ty_type {\n         ret rslt(trans_fail(cx, none,\n                             \"attempt to compare values of type type\"),\n                  C_nil());\n@@ -1506,44 +1506,44 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n fn compare_scalar_values(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n                          nt: scalar_type, op: ast::binop) -> ValueRef {\n     alt nt {\n-      nil_type. {\n+      nil_type {\n         // We don't need to do actual comparisons for nil.\n         // () == () holds but () < () does not.\n         alt op {\n-          ast::eq. | ast::le. | ast::ge. { ret C_bool(true); }\n-          ast::ne. | ast::lt. | ast::gt. { ret C_bool(false); }\n+          ast::eq | ast::le | ast::ge { ret C_bool(true); }\n+          ast::ne | ast::lt | ast::gt { ret C_bool(false); }\n         }\n       }\n-      floating_point. {\n+      floating_point {\n         let cmp = alt op {\n-          ast::eq. { lib::llvm::LLVMRealOEQ }\n-          ast::ne. { lib::llvm::LLVMRealUNE }\n-          ast::lt. { lib::llvm::LLVMRealOLT }\n-          ast::le. { lib::llvm::LLVMRealOLE }\n-          ast::gt. { lib::llvm::LLVMRealOGT }\n-          ast::ge. { lib::llvm::LLVMRealOGE }\n+          ast::eq { lib::llvm::LLVMRealOEQ }\n+          ast::ne { lib::llvm::LLVMRealUNE }\n+          ast::lt { lib::llvm::LLVMRealOLT }\n+          ast::le { lib::llvm::LLVMRealOLE }\n+          ast::gt { lib::llvm::LLVMRealOGT }\n+          ast::ge { lib::llvm::LLVMRealOGE }\n         };\n         ret FCmp(cx, cmp, lhs, rhs);\n       }\n-      signed_int. {\n+      signed_int {\n         let cmp = alt op {\n-          ast::eq. { lib::llvm::LLVMIntEQ }\n-          ast::ne. { lib::llvm::LLVMIntNE }\n-          ast::lt. { lib::llvm::LLVMIntSLT }\n-          ast::le. { lib::llvm::LLVMIntSLE }\n-          ast::gt. { lib::llvm::LLVMIntSGT }\n-          ast::ge. { lib::llvm::LLVMIntSGE }\n+          ast::eq { lib::llvm::LLVMIntEQ }\n+          ast::ne { lib::llvm::LLVMIntNE }\n+          ast::lt { lib::llvm::LLVMIntSLT }\n+          ast::le { lib::llvm::LLVMIntSLE }\n+          ast::gt { lib::llvm::LLVMIntSGT }\n+          ast::ge { lib::llvm::LLVMIntSGE }\n         };\n         ret ICmp(cx, cmp, lhs, rhs);\n       }\n-      unsigned_int. {\n+      unsigned_int {\n         let cmp = alt op {\n-          ast::eq. { lib::llvm::LLVMIntEQ }\n-          ast::ne. { lib::llvm::LLVMIntNE }\n-          ast::lt. { lib::llvm::LLVMIntULT }\n-          ast::le. { lib::llvm::LLVMIntULE }\n-          ast::gt. { lib::llvm::LLVMIntUGT }\n-          ast::ge. { lib::llvm::LLVMIntUGE }\n+          ast::eq { lib::llvm::LLVMIntEQ }\n+          ast::ne { lib::llvm::LLVMIntNE }\n+          ast::lt { lib::llvm::LLVMIntULT }\n+          ast::le { lib::llvm::LLVMIntULE }\n+          ast::gt { lib::llvm::LLVMIntUGT }\n+          ast::ge { lib::llvm::LLVMIntUGE }\n         };\n         ret ICmp(cx, cmp, lhs, rhs);\n       }\n@@ -1697,12 +1697,12 @@ fn lazily_emit_all_generic_info_tydesc_glues(cx: @block_ctxt,\n fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                            static_ti: option::t<@tydesc_info>) {\n     alt static_ti {\n-      none. { }\n+      none { }\n       some(ti) {\n         if field == abi::tydesc_field_take_glue {\n             alt ti.take_glue {\n               some(_) { }\n-              none. {\n+              none {\n                 #debug(\"+++ lazily_emit_tydesc_glue TAKE %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n                 let lcx = cx.fcx.lcx;\n@@ -1720,7 +1720,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n         } else if field == abi::tydesc_field_drop_glue {\n             alt ti.drop_glue {\n               some(_) { }\n-              none. {\n+              none {\n                 #debug(\"+++ lazily_emit_tydesc_glue DROP %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n                 let lcx = cx.fcx.lcx;\n@@ -1738,7 +1738,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n         } else if field == abi::tydesc_field_free_glue {\n             alt ti.free_glue {\n               some(_) { }\n-              none. {\n+              none {\n                 #debug(\"+++ lazily_emit_tydesc_glue FREE %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n                 let lcx = cx.fcx.lcx;\n@@ -1756,7 +1756,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n         } else if field == abi::tydesc_field_cmp_glue {\n             alt ti.cmp_glue {\n               some(_) { }\n-              none. {\n+              none {\n                 #debug(\"+++ lazily_emit_tydesc_glue CMP %s\",\n                        ty_to_str(bcx_tcx(cx), ti.ty));\n                 ti.cmp_glue = some(bcx_ccx(cx).upcalls.cmp_type);\n@@ -1775,7 +1775,7 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n \n     let static_glue_fn = none;\n     alt static_ti {\n-      none. {/* no-op */ }\n+      none {/* no-op */ }\n       some(sti) {\n         if field == abi::tydesc_field_take_glue {\n             static_glue_fn = sti.take_glue;\n@@ -1794,7 +1794,7 @@ fn call_tydesc_glue_full(cx: @block_ctxt, v: ValueRef, tydesc: ValueRef,\n \n     let llfn;\n     alt static_glue_fn {\n-      none. {\n+      none {\n         let llfnptr = GEPi(cx, tydesc, [0, field]);\n         llfn = Load(cx, llfnptr);\n       }\n@@ -1840,7 +1840,7 @@ fn call_cmp_glue(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n     let llfn;\n     alt ti {\n-      none. {\n+      none {\n         let llfnptr =\n             GEPi(bcx, lltydesc, [0, abi::tydesc_field_cmp_glue]);\n         llfn = Load(bcx, llfnptr);\n@@ -1870,7 +1870,7 @@ fn drop_ty(cx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n \n fn drop_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> @block_ctxt {\n     alt ty::struct(bcx_tcx(bcx), t) {\n-      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str. { free_ty(bcx, v, t) }\n+      ty::ty_uniq(_) | ty::ty_vec(_) | ty::ty_str { free_ty(bcx, v, t) }\n       ty::ty_box(_) | ty::ty_iface(_, _) { decr_refcnt_maybe_free(bcx, v, t) }\n     }\n }\n@@ -1884,7 +1884,7 @@ fn take_ty_immediate(bcx: @block_ctxt, v: ValueRef, t: ty::t) -> result {\n         check trans_uniq::type_is_unique_box(bcx, t);\n         trans_uniq::duplicate(bcx, v, t)\n       }\n-      ty::ty_str. | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n+      ty::ty_str | ty::ty_vec(_) { tvec::duplicate(bcx, v, t) }\n       _ { rslt(bcx, v) }\n     }\n }\n@@ -2046,7 +2046,7 @@ fn trans_crate_lit(cx: @crate_ctxt, lit: ast::lit) -> ValueRef {\n       ast::lit_uint(u, t) { C_integral(T_uint_ty(cx, t), u, False) }\n       ast::lit_float(fs, t) { C_floating(fs, T_float_ty(cx, t)) }\n       ast::lit_bool(b) { C_bool(b) }\n-      ast::lit_nil. { C_nil() }\n+      ast::lit_nil { C_nil() }\n       ast::lit_str(s) {\n         cx.sess.span_unimpl(lit.span, \"unique string in this context\");\n       }\n@@ -2083,11 +2083,11 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n     if dest == ignore { ret trans_expr(bcx, e, ignore); }\n     let e_ty = ty::expr_ty(bcx_tcx(bcx), e);\n     alt op {\n-      ast::not. {\n+      ast::not {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n         ret store_in_dest(bcx, Not(bcx, val), dest);\n       }\n-      ast::neg. {\n+      ast::neg {\n         let {bcx, val} = trans_temp_expr(bcx, e);\n         let neg = if ty::type_is_fp(bcx_tcx(bcx), e_ty) {\n             FNeg(bcx, val)\n@@ -2099,7 +2099,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         add_clean_free(bcx, box, false);\n         // Cast the body type to the type of the value. This is needed to\n         // make tags work, since tags have a different LLVM type depending\n-        // on whether they're boxed or not.\n+        // on whether they're boxed or not\n         let ccx = bcx_ccx(bcx);\n         if check type_has_static_size(ccx, e_ty) {\n             let e_sp = e.span;\n@@ -2113,7 +2113,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n       ast::uniq(_) {\n         ret trans_uniq::trans_uniq(bcx, e, id, dest);\n       }\n-      ast::deref. {\n+      ast::deref {\n         bcx_ccx(bcx).sess.bug(\"deref expressions should have been \\\n                                translated using trans_lval(), not \\\n                                trans_unary()\");\n@@ -2131,17 +2131,17 @@ fn trans_compare(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n     // Determine the operation we need.\n     let llop;\n     alt op {\n-      ast::eq. | ast::ne. { llop = C_u8(abi::cmp_glue_op_eq); }\n-      ast::lt. | ast::ge. { llop = C_u8(abi::cmp_glue_op_lt); }\n-      ast::le. | ast::gt. { llop = C_u8(abi::cmp_glue_op_le); }\n+      ast::eq | ast::ne { llop = C_u8(abi::cmp_glue_op_eq); }\n+      ast::lt | ast::ge { llop = C_u8(abi::cmp_glue_op_lt); }\n+      ast::le | ast::gt { llop = C_u8(abi::cmp_glue_op_le); }\n     }\n \n     let rs = call_cmp_glue(cx, lhs, rhs, rhs_t, llop);\n \n     // Invert the result if necessary.\n     alt op {\n-      ast::eq. | ast::lt. | ast::le. { ret rslt(rs.bcx, rs.val); }\n-      ast::ne. | ast::ge. | ast::gt. {\n+      ast::eq | ast::lt | ast::le { ret rslt(rs.bcx, rs.val); }\n+      ast::ne | ast::ge | ast::gt {\n         ret rslt(rs.bcx, Not(rs.bcx, rs.val));\n       }\n     }\n@@ -2161,36 +2161,36 @@ fn trans_eager_binop(cx: @block_ctxt, op: ast::binop, lhs: ValueRef,\n         ret tvec::trans_add(cx, intype, lhs, rhs, dest);\n     }\n     let cx = cx, val = alt op {\n-      ast::add. {\n+      ast::add {\n         if is_float { FAdd(cx, lhs, rhs) }\n         else { Add(cx, lhs, rhs) }\n       }\n-      ast::subtract. {\n+      ast::subtract {\n         if is_float { FSub(cx, lhs, rhs) }\n         else { Sub(cx, lhs, rhs) }\n       }\n-      ast::mul. {\n+      ast::mul {\n         if is_float { FMul(cx, lhs, rhs) }\n         else { Mul(cx, lhs, rhs) }\n       }\n-      ast::div. {\n+      ast::div {\n         if is_float { FDiv(cx, lhs, rhs) }\n         else if ty::type_is_signed(bcx_tcx(cx), intype) {\n             SDiv(cx, lhs, rhs)\n         } else { UDiv(cx, lhs, rhs) }\n       }\n-      ast::rem. {\n+      ast::rem {\n         if is_float { FRem(cx, lhs, rhs) }\n         else if ty::type_is_signed(bcx_tcx(cx), intype) {\n             SRem(cx, lhs, rhs)\n         } else { URem(cx, lhs, rhs) }\n       }\n-      ast::bitor. { Or(cx, lhs, rhs) }\n-      ast::bitand. { And(cx, lhs, rhs) }\n-      ast::bitxor. { Xor(cx, lhs, rhs) }\n-      ast::lsl. { Shl(cx, lhs, rhs) }\n-      ast::lsr. { LShr(cx, lhs, rhs) }\n-      ast::asr. { AShr(cx, lhs, rhs) }\n+      ast::bitor { Or(cx, lhs, rhs) }\n+      ast::bitand { And(cx, lhs, rhs) }\n+      ast::bitxor { Xor(cx, lhs, rhs) }\n+      ast::lsl { Shl(cx, lhs, rhs) }\n+      ast::lsr { LShr(cx, lhs, rhs) }\n+      ast::asr { AShr(cx, lhs, rhs) }\n       _ {\n         let cmpr = trans_compare(cx, op, lhs, lhs_t, rhs, rhs_t);\n         cx = cmpr.bcx;\n@@ -2222,7 +2222,7 @@ fn trans_assign_op(bcx: @block_ctxt, op: ast::binop, dst: @ast::expr,\n     let {bcx, val: rhs_val} = trans_temp_expr(lhs_res.bcx, src);\n     if ty::type_is_sequence(tcx, t) {\n         alt op {\n-          ast::add. {\n+          ast::add {\n             ret tvec::trans_append(bcx, t, lhs_res.val, rhs_val);\n           }\n           _ { }\n@@ -2283,7 +2283,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n \n fn trans_lazy_binop(bcx: @block_ctxt, op: ast::binop, a: @ast::expr,\n                     b: @ast::expr, dest: dest) -> @block_ctxt {\n-    let is_and = alt op { ast::and. { true } ast::or. { false } };\n+    let is_and = alt op { ast::and { true } ast::or { false } };\n     let lhs_res = trans_temp_expr(bcx, a);\n     if lhs_res.bcx.unreachable { ret lhs_res.bcx; }\n     let rhs_cx = new_scope_block_ctxt(lhs_res.bcx, \"rhs\");\n@@ -2316,7 +2316,7 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n                 dest: dest) -> @block_ctxt {\n     // First couple cases are lazy:\n     alt op {\n-      ast::and. | ast::or. {\n+      ast::and | ast::or {\n         ret trans_lazy_binop(cx, op, a, b, dest);\n       }\n       _ {\n@@ -2381,7 +2381,7 @@ fn join_returns(parent_cx: @block_ctxt, in_cxs: [@block_ctxt],\n // Used to put an immediate value in a dest.\n fn store_in_dest(bcx: @block_ctxt, val: ValueRef, dest: dest) -> @block_ctxt {\n     alt dest {\n-      ignore. {}\n+      ignore {}\n       by_val(cell) { *cell = val; }\n       save_in(addr) { Store(bcx, val, addr); }\n     }\n@@ -2578,7 +2578,7 @@ fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n fn lookup_discriminant(lcx: @local_ctxt, vid: ast::def_id) -> ValueRef {\n     let ccx = lcx.ccx;\n     alt ccx.discrims.find(vid) {\n-      none. {\n+      none {\n         // It's an external discriminant that we haven't seen yet.\n         assert (vid.crate != ast::local_crate);\n         let sym = csearch::get_symbol(lcx.ccx.sess.cstore, vid);\n@@ -2788,7 +2788,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n       ast::expr_index(base, idx) {\n         ret trans_index(cx, e.span, base, idx, e.id);\n       }\n-      ast::expr_unary(ast::deref., base) {\n+      ast::expr_unary(ast::deref, base) {\n         let ccx = bcx_ccx(cx);\n         let sub = trans_temp_expr(cx, base);\n         let t = ty::expr_ty(ccx.tcx, base);\n@@ -2826,11 +2826,11 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n fn maybe_add_env(bcx: @block_ctxt, c: lval_maybe_callee)\n     -> (lval_kind, ValueRef) {\n     alt c.env {\n-      is_closure. { (c.kind, c.val) }\n+      is_closure { (c.kind, c.val) }\n       self_env(_) | dict_env(_, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n-      null_env. {\n+      null_env {\n         let llfnty = llvm::LLVMGetElementType(val_ty(c.val));\n         (temporary, create_real_fn_pair(bcx, llfnty, c.val,\n                                         null_env_ptr(bcx)))\n@@ -2849,7 +2849,7 @@ fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n         add_clean_temp(bcx, space.val, ty);\n         ret {bcx: bcx, val: space.val, kind: temporary};\n       }\n-      none. {\n+      none {\n         let (kind, val) = maybe_add_env(c.bcx, c);\n         ret {bcx: c.bcx, val: val, kind: kind};\n       }\n@@ -2915,41 +2915,41 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n \n     let newval =\n         alt {in: k_in, out: k_out} {\n-          {in: integral., out: integral.} {\n+          {in: integral, out: integral.} {\n             int_cast(e_res.bcx, ll_t_out, ll_t_in, e_res.val, s_in)\n           }\n-          {in: float., out: float.} {\n+          {in: float, out: float.} {\n             float_cast(e_res.bcx, ll_t_out, ll_t_in, e_res.val)\n           }\n-          {in: integral., out: float.} {\n+          {in: integral, out: float} {\n             if s_in {\n                 SIToFP(e_res.bcx, e_res.val, ll_t_out)\n             } else { UIToFP(e_res.bcx, e_res.val, ll_t_out) }\n           }\n-          {in: float., out: integral.} {\n+          {in: float, out: integral} {\n             if ty::type_is_signed(ccx.tcx, t_out) {\n                 FPToSI(e_res.bcx, e_res.val, ll_t_out)\n             } else { FPToUI(e_res.bcx, e_res.val, ll_t_out) }\n           }\n-          {in: integral., out: pointer.} {\n+          {in: integral, out: pointer} {\n             IntToPtr(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: pointer., out: integral.} {\n+          {in: pointer, out: integral} {\n             PtrToInt(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: pointer., out: pointer.} {\n+          {in: pointer, out: pointer.} {\n             PointerCast(e_res.bcx, e_res.val, ll_t_out)\n           }\n-          {in: tag_., out: integral.} | {in: tag_., out: float.} {\n+          {in: tag_, out: integral} | {in: tag_., out: float} {\n             let cx = e_res.bcx;\n             let lltagty = T_opaque_tag_ptr(ccx);\n             let av_tag = PointerCast(cx, e_res.val, lltagty);\n             let lldiscrim_a_ptr = GEPi(cx, av_tag, [0, 0]);\n             let lldiscrim_a = Load(cx, lldiscrim_a_ptr);\n             alt k_out {\n-              integral. {int_cast(e_res.bcx, ll_t_out,\n+              integral {int_cast(e_res.bcx, ll_t_out,\n                                   val_ty(lldiscrim_a), lldiscrim_a, true)}\n-              float. {SIToFP(e_res.bcx, lldiscrim_a, ll_t_out)}\n+              float {SIToFP(e_res.bcx, lldiscrim_a, ll_t_out)}\n             }\n           }\n           _ { ccx.sess.bug(\"Translating unsupported cast.\") }\n@@ -3081,7 +3081,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n     }\n     // Arg 0: Output pointer.\n     let llretslot = alt dest {\n-      ignore. {\n+      ignore {\n         if ty::type_is_nil(tcx, retty) {\n             llvm::LLVMGetUndef(T_ptr(T_nil()))\n         } else {\n@@ -3153,12 +3153,12 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     let faddr = f_res.val;\n     let llenv, dict_param = none;\n     alt f_res.env {\n-      null_env. {\n+      null_env {\n         llenv = llvm::LLVMGetUndef(T_opaque_cbox_ptr(bcx_ccx(cx)));\n       }\n       self_env(e) { llenv = e; }\n       dict_env(dict, e) { llenv = e; dict_param = some(dict); }\n-      is_closure. {\n+      is_closure {\n         // It's a closure. Have to fetch the elements\n         if f_res.kind == owned {\n             faddr = load_if_immediate(bcx, faddr, fn_expr_ty);\n@@ -3186,7 +3186,7 @@ fn trans_call(in_cx: @block_ctxt, f: @ast::expr,\n     bcx = invoke_full(bcx, faddr, llargs, args_res.to_zero,\n                       args_res.to_revoke);\n     alt dest {\n-      ignore. {\n+      ignore {\n         if llvm::LLVMIsUndef(llretslot) != lib::llvm::True {\n             bcx = drop_ty(bcx, llretslot, ret_ty);\n         }\n@@ -3271,7 +3271,7 @@ fn get_landing_pad(bcx: @block_ctxt,\n             } else {\n                 scope_bcx = alt scope_bcx.parent {\n                   parent_some(b) { b }\n-                  parent_none. {\n+                  parent_none {\n                     ret scope_bcx;\n                   }\n                 };\n@@ -3316,7 +3316,7 @@ fn trans_landing_pad(bcx: @block_ctxt,\n         bcx = trans_block_cleanups(bcx, scope_cx);\n         scope_cx = alt scope_cx.parent {\n           parent_some(b) { b }\n-          parent_none. { break; }\n+          parent_none { break; }\n         };\n     }\n \n@@ -3330,7 +3330,7 @@ fn trans_tup(bcx: @block_ctxt, elts: [@ast::expr], id: ast::node_id,\n     let t = node_id_type(bcx.fcx.lcx.ccx, id);\n     let bcx = bcx;\n     let addr = alt dest {\n-      ignore. {\n+      ignore {\n         for ex in elts { bcx = trans_expr(bcx, ex, ignore); }\n         ret bcx;\n       }\n@@ -3355,7 +3355,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n     let t = node_id_type(bcx_ccx(bcx), id);\n     let bcx = bcx;\n     let addr = alt dest {\n-      ignore. {\n+      ignore {\n         for fld in fields {\n             bcx = trans_expr(bcx, fld.node.expr, ignore);\n         }\n@@ -3390,7 +3390,7 @@ fn trans_rec(bcx: @block_ctxt, fields: [ast::field],\n             i += 1;\n         }\n       }\n-      none. {}\n+      none {}\n     };\n \n     // Now revoke the cleanups as we pass responsibility for the data\n@@ -3527,11 +3527,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       }\n \n       // These return nothing\n-      ast::expr_break. {\n+      ast::expr_break {\n         assert dest == ignore;\n         ret trans_break(e.span, bcx);\n       }\n-      ast::expr_cont. {\n+      ast::expr_cont {\n         assert dest == ignore;\n         ret trans_cont(e.span, bcx);\n       }\n@@ -3657,7 +3657,7 @@ fn lval_to_dps(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       save_in(loc) {\n         bcx = store_temp_expr(bcx, INIT, loc, lv, ty, last_use);\n       }\n-      ignore. {}\n+      ignore {}\n     }\n     ret bcx;\n }\n@@ -3805,7 +3805,7 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n         V_filename = C_cstr(bcx_ccx(bcx), loc.filename);\n         V_line = loc.line as int;\n       }\n-      none. { V_filename = C_cstr(bcx_ccx(bcx), \"<runtime>\"); V_line = 0; }\n+      none { V_filename = C_cstr(bcx_ccx(bcx), \"<runtime>\"); V_line = 0; }\n     }\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));\n     V_filename = PointerCast(bcx, V_filename, T_ptr(T_i8()));\n@@ -3837,7 +3837,7 @@ fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n           _ {\n             alt cleanup_cx.parent {\n               parent_some(cx) { cleanup_cx = cx; }\n-              parent_none. {\n+              parent_none {\n                 bcx_ccx(bcx).sess.span_fatal\n                     (sp, if to_end { \"Break\" } else { \"Cont\" } +\n                      \" outside a loop\");\n@@ -3871,7 +3871,7 @@ fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n         bcx = trans_block_cleanups(bcx, cleanup_cx);\n         alt cleanup_cx.parent {\n           parent_some(b) { cleanup_cx = b; }\n-          parent_none. { more_cleanups = false; }\n+          parent_none { more_cleanups = false; }\n         }\n     }\n     build_return(bcx);\n@@ -3894,7 +3894,7 @@ fn init_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let llptr = alt bcx.fcx.lllocals.find(local.node.id) {\n       some(local_mem(v)) { v }\n       // This is a local that is kept immediate\n-      none. {\n+      none {\n         let initexpr = alt local.node.init { some({expr, _}) { expr } };\n         let {bcx, val, kind} = trans_temp_lval(bcx, initexpr);\n         if kind != temporary {\n@@ -3929,8 +3929,8 @@ fn init_ref_local(bcx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let init_expr = option::get(local.node.init).expr;\n     let {bcx, val, kind} = trans_lval(bcx, init_expr);\n     alt kind {\n-      owned_imm. { val = do_spill_noroot(bcx, val); }\n-      owned. {}\n+      owned_imm { val = do_spill_noroot(bcx, val); }\n+      owned {}\n     }\n     ret trans_alt::bind_irrefutable_pat(bcx, local.node.pat, val, false);\n }\n@@ -4096,7 +4096,7 @@ fn trans_fn_cleanups(fcx: @fn_ctxt, cx: @block_ctxt) {\n         let lltoken = lltoken_; // satisfy alias checker\n         Call(cx, fcx_ccx(fcx).upcalls.dynastack_free, [lltoken]);\n       }\n-      none. {/* nothing to do */ }\n+      none {/* nothing to do */ }\n     }\n }\n \n@@ -4181,21 +4181,21 @@ fn alloc_local(cx: @block_ctxt, local: @ast::local) -> @block_ctxt {\n     let t = node_id_type(bcx_ccx(cx), local.node.id);\n     let p = normalize_pat(bcx_tcx(cx), local.node.pat);\n     let is_simple = alt p.node {\n-      ast::pat_ident(_, none.) { true } _ { false }\n+      ast::pat_ident(_, none) { true } _ { false }\n     };\n     // Do not allocate space for locals that can be kept immediate.\n     let ccx = bcx_ccx(cx);\n     if is_simple && !ccx.mut_map.contains_key(local.node.pat.id) &&\n        !ccx.last_uses.contains_key(local.node.pat.id) &&\n        ty::type_is_immediate(ccx.tcx, t) {\n         alt local.node.init {\n-          some({op: ast::init_assign., _}) { ret cx; }\n+          some({op: ast::init_assign, _}) { ret cx; }\n           _ {}\n         }\n     }\n     let r = alloc_ty(cx, t);\n     alt p.node {\n-      ast::pat_ident(pth, none.) {\n+      ast::pat_ident(pth, none) {\n         if bcx_ccx(cx).sess.opts.debuginfo {\n             let _: () = str::as_buf(path_to_ident(pth), {|buf|\n                 llvm::LLVMSetValueName(r.val, buf)\n@@ -4326,7 +4326,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n       impl_self(tt) {\n         cx.llself = some({v: cx.llenv, t: tt});\n       }\n-      no_self. {}\n+      no_self {}\n     }\n     for tp in ty_params {\n         let lltydesc = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n@@ -4338,7 +4338,7 @@ fn create_llargs_for_fn_args(cx: @fn_ctxt, ty_self: self_arg,\n                 let dict = llvm::LLVMGetParam(cx.llfn, arg_n as c_uint);\n                 arg_n += 1u;\n                 dicts = some(alt dicts {\n-                    none. { [dict] }\n+                    none { [dict] }\n                     some(ds) { ds + [dict] }\n                 });\n               }\n@@ -4368,9 +4368,9 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n         let id = args[arg_n].id;\n         let argval = alt fcx.llargs.get(id) { local_mem(v) { v } };\n         alt arg.mode {\n-          ast::by_mut_ref. { }\n-          ast::by_move. | ast::by_copy. { add_clean(bcx, argval, arg.ty); }\n-          ast::by_val. {\n+          ast::by_mut_ref { }\n+          ast::by_move | ast::by_copy { add_clean(bcx, argval, arg.ty); }\n+          ast::by_val {\n             if !ty::type_is_immediate(bcx_tcx(bcx), arg.ty) {\n                 let {bcx: cx, val: alloc} = alloc_ty(bcx, arg.ty);\n                 bcx = cx;\n@@ -4380,7 +4380,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n                 fcx.llargs.insert(id, local_imm(argval));\n             }\n           }\n-          ast::by_ref. {}\n+          ast::by_ref {}\n         }\n         if fcx_ccx(fcx).sess.opts.extra_debuginfo {\n             debuginfo::create_arg(bcx, args[arg_n]);\n@@ -4607,42 +4607,42 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         let is_float = ty::type_is_fp(ccx_tcx(cx), ty);\n         let signed = ty::type_is_signed(ccx_tcx(cx), ty);\n         ret alt b {\n-          ast::add.    {\n+          ast::add    {\n             if is_float { llvm::LLVMConstFAdd(te1, te2) }\n             else        { llvm::LLVMConstAdd(te1, te2) }\n           }\n-          ast::subtract. {\n+          ast::subtract {\n             if is_float { llvm::LLVMConstFSub(te1, te2) }\n             else        { llvm::LLVMConstSub(te1, te2) }\n           }\n-          ast::mul.    {\n+          ast::mul    {\n             if is_float { llvm::LLVMConstFMul(te1, te2) }\n             else        { llvm::LLVMConstMul(te1, te2) }\n           }\n-          ast::div.    {\n+          ast::div    {\n             if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n             else if signed { llvm::LLVMConstSDiv(te1, te2) }\n             else           { llvm::LLVMConstUDiv(te1, te2) }\n           }\n-          ast::rem.    {\n+          ast::rem    {\n             if is_float    { llvm::LLVMConstFRem(te1, te2) }\n             else if signed { llvm::LLVMConstSRem(te1, te2) }\n             else           { llvm::LLVMConstURem(te1, te2) }\n           }\n-          ast::and.    |\n-          ast::or.     { cx.sess.span_unimpl(e.span, \"binop logic\"); }\n-          ast::bitxor. { llvm::LLVMConstXor(te1, te2) }\n-          ast::bitand. { llvm::LLVMConstAnd(te1, te2) }\n-          ast::bitor.  { llvm::LLVMConstOr(te1, te2) }\n-          ast::lsl.    { llvm::LLVMConstShl(te1, te2) }\n-          ast::lsr.    { llvm::LLVMConstLShr(te1, te2) }\n-          ast::asr.    { llvm::LLVMConstAShr(te1, te2) }\n-          ast::eq.     |\n-          ast::lt.     |\n-          ast::le.     |\n-          ast::ne.     |\n-          ast::ge.     |\n-          ast::gt.     { cx.sess.span_unimpl(e.span, \"binop comparator\"); }\n+          ast::and    |\n+          ast::or     { cx.sess.span_unimpl(e.span, \"binop logic\"); }\n+          ast::bitxor { llvm::LLVMConstXor(te1, te2) }\n+          ast::bitand { llvm::LLVMConstAnd(te1, te2) }\n+          ast::bitor  { llvm::LLVMConstOr(te1, te2) }\n+          ast::lsl    { llvm::LLVMConstShl(te1, te2) }\n+          ast::lsr    { llvm::LLVMConstLShr(te1, te2) }\n+          ast::asr    { llvm::LLVMConstAShr(te1, te2) }\n+          ast::eq     |\n+          ast::lt     |\n+          ast::le     |\n+          ast::ne     |\n+          ast::ge     |\n+          ast::gt     { cx.sess.span_unimpl(e.span, \"binop comparator\"); }\n         }\n       }\n       ast::expr_unary(u, e) {\n@@ -4652,10 +4652,10 @@ fn trans_const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n         ret alt u {\n           ast::box(_)  |\n           ast::uniq(_) |\n-          ast::deref.  { cx.sess.span_bug(e.span,\n+          ast::deref  { cx.sess.span_bug(e.span,\n                            \"bad unop type in trans_const_expr\"); }\n-          ast::not.    { llvm::LLVMConstNot(te) }\n-          ast::neg.    {\n+          ast::not    { llvm::LLVMConstNot(te) }\n+          ast::neg    {\n             if is_float { llvm::LLVMConstFNeg(te) }\n             else        { llvm::LLVMConstNeg(te) }\n           }\n@@ -4848,7 +4848,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n \n     for native_item in native_mod.items {\n       alt native_item.node {\n-        ast::native_item_ty. {}\n+        ast::native_item_ty {}\n         ast::native_item_fn(fn_decl, tps) {\n           let span = native_item.span;\n           let id = native_item.id;\n@@ -4860,7 +4860,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n                             vec::len(tps), llshimfn, llwrapfn);\n             }\n \n-            none. {\n+            none {\n               ccx.sess.span_fatal(\n                   native_item.span,\n                   \"unbound function item in trans_native_mod\");\n@@ -4933,7 +4933,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n     }\n }\n \n-// Translate a module.  Doing this amounts to translating the items in the\n+// Translate a module. Doing this amounts to translating the items in the\n // module; there ends up being no artifact (aside from linkage names) of\n // separate modules in the compiled program.  That's because modules exist\n // only as a convenience for humans working with the code, to organize names\n@@ -5084,7 +5084,7 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     let native_item =\n         alt cx.ast_map.find(id) { some(ast_map::node_native_item(i)) { i } };\n     alt native_item.node {\n-      ast::native_item_ty. {\n+      ast::native_item_ty {\n         cx.sess.bug(\"register_native_fn(): native fn isn't \\\n                         actually a fn\");\n       }\n@@ -5113,7 +5113,7 @@ fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n \n fn link_name(i: @ast::native_item) -> str {\n     alt attr::get_meta_item_value_str_by_name(i.attrs, \"link_name\") {\n-      none. { ret i.ident; }\n+      none { ret i.ident; }\n       option::some(ln) { ret ln; }\n     }\n }\n@@ -5130,7 +5130,7 @@ fn collect_native_item(ccx: @crate_ctxt,\n         let node_type = node_id_type(ccx, id);\n         let fn_abi =\n             alt attr::get_meta_item_value_str_by_name(i.attrs, \"abi\") {\n-            option::none. {\n+            option::none {\n                 // if abi isn't specified for this function, inherit from\n                   // its enclosing native module\n                   option::get(*abi)"}, {"sha": "cef43dc25e563b0367cb9b644c3a46b02ddd4c75", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -129,15 +129,15 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n                 vec::slice(br.pats, col + 1u, vec::len(br.pats));\n             let new_br = @{pats: pats,\n                            bound: alt br.pats[col].node {\n-                             ast::pat_ident(name, none.) {\n+                             ast::pat_ident(name, none) {\n                                  br.bound + [{ident: path_to_ident(name),\n                                               val: val}]\n                              }\n                              _ { br.bound }\n                            } with *br};\n             result += [new_br];\n           }\n-          none. { }\n+          none { }\n         }\n     }\n     ret result;\n@@ -146,8 +146,8 @@ fn enter_match(m: match, col: uint, val: ValueRef, e: enter_pat) -> match {\n fn enter_default(m: match, col: uint, val: ValueRef) -> match {\n     fn matches_always(p: @ast::pat) -> bool {\n         alt p.node {\n-                ast::pat_wild. | ast::pat_rec(_, _) |\n-                ast::pat_ident(_, none.) | ast::pat_tup(_) { true }\n+                ast::pat_wild | ast::pat_rec(_, _) |\n+                ast::pat_ident(_, none) | ast::pat_tup(_) { true }\n                 _ { false }\n         }\n     }\n@@ -508,7 +508,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     }\n     let else_cx =\n         alt kind {\n-          no_branch. | single. { bcx }\n+          no_branch | single { bcx }\n           _ { new_sub_block_ctxt(bcx, \"match_else\") }\n         };\n     let sw;\n@@ -525,8 +525,8 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n     for opt: opt in opts {\n         let opt_cx = new_sub_block_ctxt(bcx, \"match_case\");\n         alt kind {\n-          single. { Br(bcx, opt_cx.llbb); }\n-          switch. {\n+          single { Br(bcx, opt_cx.llbb); }\n+          switch {\n             let res = trans_opt(bcx, opt);\n             alt res {\n               single_result(r) {\n@@ -535,7 +535,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n               }\n             }\n           }\n-          compare. {\n+          compare {\n             let compare_cx = new_scope_block_ctxt(bcx, \"compare_scope\");\n             Br(bcx, compare_cx.llbb);\n             bcx = compare_cx;\n@@ -603,7 +603,7 @@ fn make_phi_bindings(bcx: @block_ctxt, map: [exit_node],\n             if ex.to as uint == our_block {\n                 alt assoc(name, ex.bound) {\n                   some(val) { llbbs += [ex.from]; vals += [val]; }\n-                  none. { }\n+                  none { }\n                 }\n             }\n         }\n@@ -767,7 +767,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n         let val = Load(bcx, val);\n         bcx = bind_irrefutable_pat(bcx, inner, val, true);\n       }\n-      ast::pat_wild. | ast::pat_lit(_) | ast::pat_range(_, _) { }\n+      ast::pat_wild | ast::pat_lit(_) | ast::pat_range(_, _) { }\n     }\n     ret bcx;\n }"}, {"sha": "66002c899799eacb6d4e3cdf2dfd55fd74fe9fbe", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -137,8 +137,8 @@ fn ev_to_str(ccx: @crate_ctxt, ev: environment_value) -> str {\n \n fn mk_tydesc_ty(tcx: ty::ctxt, ck: ty::closure_kind) -> ty::t {\n     ret alt ck {\n-      ty::ck_block. | ty::ck_box. { ty::mk_type(tcx) }\n-      ty::ck_uniq. { ty::mk_send_type(tcx) }\n+      ty::ck_block | ty::ck_box { ty::mk_type(tcx) }\n+      ty::ck_uniq { ty::mk_send_type(tcx) }\n     };\n }\n \n@@ -237,15 +237,15 @@ fn allocate_cbox(bcx: @block_ctxt,\n     // Allocate the box:\n     let temp_cleanups = [];\n     let (bcx, box, rc) = alt ck {\n-      ty::ck_box. {\n+      ty::ck_box {\n         let (bcx, box) = alloc_in_heap(bcx, false, temp_cleanups);\n         (bcx, box, 1)\n       }\n-      ty::ck_uniq. {\n+      ty::ck_uniq {\n         let (bcx, box) = alloc_in_heap(bcx, true, temp_cleanups);\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n-      ty::ck_block. {\n+      ty::ck_block {\n         let {bcx, val: box} = trans::alloc_ty(bcx, cbox_ty);\n         (bcx, box, 0x12345678) // use arbitrary value for debugging\n       }\n@@ -289,10 +289,10 @@ fn store_environment(\n                           ck: ty::closure_kind,\n                           td: ValueRef) -> ValueRef {\n         ret alt ck {\n-          ty::ck_block. | ty::ck_box. {\n+          ty::ck_block | ty::ck_box {\n             td\n           }\n-          ty::ck_uniq. {\n+          ty::ck_uniq {\n             Call(bcx, bcx_ccx(bcx).upcalls.create_shared_type_desc, [td])\n           }\n         };\n@@ -311,7 +311,7 @@ fn store_environment(\n \n     // store data tydesc.\n     alt ck {\n-      ty::ck_box. | ty::ck_uniq. {\n+      ty::ck_box | ty::ck_uniq {\n         let bound_tydesc = GEPi(bcx, llbox, [0, abi::cbox_elt_tydesc]);\n         let ti = none;\n \n@@ -324,7 +324,7 @@ fn store_environment(\n         let td = maybe_clone_tydesc(bcx, ck, closure_td.val);\n         Store(bcx, td, bound_tydesc);\n       }\n-      ty::ck_block. { /* skip this for blocks, not really relevant */ }\n+      ty::ck_block { /* skip this for blocks, not really relevant */ }\n     }\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n@@ -371,28 +371,28 @@ fn store_environment(\n             add_clean_temp_mem(bcx, bound_data, bound_tys[i]);\n             temp_cleanups += [bound_data];\n           }\n-          env_copy(val, ty, owned.) {\n+          env_copy(val, ty, owned) {\n             let val1 = load_if_immediate(bcx, val, ty);\n             bcx = trans::copy_val(bcx, INIT, bound_data, val1, ty);\n           }\n-          env_copy(val, ty, owned_imm.) {\n+          env_copy(val, ty, owned_imm) {\n             bcx = trans::copy_val(bcx, INIT, bound_data, val, ty);\n           }\n-          env_copy(_, _, temporary.) {\n+          env_copy(_, _, temporary) {\n             fail \"Cannot capture temporary upvar\";\n           }\n           env_move(val, ty, kind) {\n             let src = {bcx:bcx, val:val, kind:kind};\n             bcx = move_val(bcx, INIT, bound_data, src, ty);\n           }\n-          env_ref(val, ty, owned.) {\n+          env_ref(val, ty, owned) {\n             Store(bcx, val, bound_data);\n           }\n-          env_ref(val, ty, owned_imm.) {\n+          env_ref(val, ty, owned_imm) {\n             let addr = do_spill_noroot(bcx, val);\n             Store(bcx, addr, bound_data);\n           }\n-          env_ref(_, _, temporary.) {\n+          env_ref(_, _, temporary) {\n             fail \"Cannot capture temporary upvar\";\n           }\n         }\n@@ -489,8 +489,8 @@ fn load_environment(enclosing_cx: @block_ctxt,\n             bcx = upvarptr.bcx;\n             let llupvarptr = upvarptr.val;\n             alt ck {\n-              ty::ck_block. { llupvarptr = Load(bcx, llupvarptr); }\n-              ty::ck_uniq. | ty::ck_box. { }\n+              ty::ck_block { llupvarptr = Load(bcx, llupvarptr); }\n+              ty::ck_uniq | ty::ck_box { }\n             }\n             let def_id = ast_util::def_id_of_def(cap_var.def);\n             fcx.llupvars.insert(def_id.node, llupvarptr);\n@@ -528,11 +528,11 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     };\n \n     let closure = alt proto {\n-      ast::proto_any. { fail \"proto_any cannot appear in an expr\"; }\n-      ast::proto_block. { trans_closure_env(ty::ck_block) }\n-      ast::proto_box. { trans_closure_env(ty::ck_box) }\n-      ast::proto_uniq. { trans_closure_env(ty::ck_uniq) }\n-      ast::proto_bare. {\n+      ast::proto_any { fail \"proto_any cannot appear in an expr\"; }\n+      ast::proto_block { trans_closure_env(ty::ck_block) }\n+      ast::proto_box { trans_closure_env(ty::ck_box) }\n+      ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n+      ast::proto_bare {\n         let closure = C_null(T_opaque_cbox_ptr(ccx));\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n                       id, {|_fcx|});\n@@ -556,7 +556,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n                 dest: dest) -> @block_ctxt {\n     let bound: [@ast::expr] = [];\n     for argopt: option::t<@ast::expr> in args {\n-        alt argopt { none. { } some(e) { bound += [e]; } }\n+        alt argopt { none { } some(e) { bound += [e]; } }\n     }\n     let bcx = f_res.bcx;\n     if dest == ignore {\n@@ -566,7 +566,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Figure out which tydescs we need to pass, if any.\n     let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n-      none. { (outgoing_fty, [], @[]) }\n+      none { (outgoing_fty, [], @[]) }\n       some(ginfo) {\n         let tds = [], orig = 0u;\n         vec::iter2(ginfo.tydescs, *ginfo.param_bounds) {|td, bounds|\n@@ -596,7 +596,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         ret memmove_ty(bcx, get_dest_addr(dest), lv.val, pair_ty);\n     }\n     let closure = alt f_res.env {\n-      null_env. { none }\n+      null_env { none }\n       _ { let (_, cl) = maybe_add_env(cx, f_res); some(cl) }\n     };\n \n@@ -616,7 +616,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         let src_loc = PointerCast(bcx, cl, llclosurety);\n         ([env_copy(src_loc, pair_ty, owned)], none)\n       }\n-      none. { ([], some(f_res.val)) }\n+      none { ([], some(f_res.val)) }\n     };\n \n     // Actually construct the closure\n@@ -668,11 +668,11 @@ fn make_fn_glue(\n     };\n \n     ret alt ty::struct(tcx, t) {\n-      ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare., _}) { bcx }\n-      ty::ty_fn({proto: ast::proto_block., _}) { bcx }\n-      ty::ty_fn({proto: ast::proto_any., _}) { bcx }\n-      ty::ty_fn({proto: ast::proto_uniq., _}) { fn_env(ty::ck_uniq) }\n-      ty::ty_fn({proto: ast::proto_box., _}) { fn_env(ty::ck_box) }\n+      ty::ty_native_fn(_, _) | ty::ty_fn({proto: ast::proto_bare, _}) { bcx }\n+      ty::ty_fn({proto: ast::proto_block, _}) { bcx }\n+      ty::ty_fn({proto: ast::proto_any, _}) { bcx }\n+      ty::ty_fn({proto: ast::proto_uniq, _}) { fn_env(ty::ck_uniq) }\n+      ty::ty_fn({proto: ast::proto_box, _}) { fn_env(ty::ck_box) }\n       _ { fail \"make_fn_glue invoked on non-function type\" }\n     };\n }\n@@ -684,9 +684,9 @@ fn make_opaque_cbox_take_glue(\n     -> @block_ctxt {\n     // Easy cases:\n     alt ck {\n-      ty::ck_block. { ret bcx; }\n-      ty::ck_box. { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n-      ty::ck_uniq. { /* hard case: */ }\n+      ty::ck_block { ret bcx; }\n+      ty::ck_box { ret incr_refcnt_of_boxed(bcx, Load(bcx, cboxptr)); }\n+      ty::ck_uniq { /* hard case: */ }\n     }\n \n     // Hard case, a deep copy:\n@@ -722,12 +722,12 @@ fn make_opaque_cbox_drop_glue(\n     cboxptr: ValueRef)     // ptr to the opaque closure\n     -> @block_ctxt {\n     alt ck {\n-      ty::ck_block. { bcx }\n-      ty::ck_box. {\n+      ty::ck_block { bcx }\n+      ty::ck_box {\n         decr_refcnt_maybe_free(bcx, Load(bcx, cboxptr),\n                                ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n       }\n-      ty::ck_uniq. {\n+      ty::ck_uniq {\n         free_ty(bcx, Load(bcx, cboxptr),\n                 ty::mk_opaque_closure_ptr(bcx_tcx(bcx), ck))\n       }\n@@ -740,8 +740,8 @@ fn make_opaque_cbox_free_glue(\n     cbox: ValueRef)     // ptr to the opaque closure\n     -> @block_ctxt {\n     alt ck {\n-      ty::ck_block. { ret bcx; }\n-      ty::ck_box. | ty::ck_uniq. { /* hard cases: */ }\n+      ty::ck_block { ret bcx; }\n+      ty::ck_box | ty::ck_uniq { /* hard cases: */ }\n     }\n \n     let ccx = bcx_ccx(bcx);\n@@ -768,11 +768,11 @@ fn make_opaque_cbox_free_glue(\n \n         // Free the ty descr (if necc) and the box itself\n         alt ck {\n-          ty::ck_block. { fail \"Impossible.\"; }\n-          ty::ck_box. {\n+          ty::ck_block { fail \"Impossible\"; }\n+          ty::ck_box {\n             trans_free_if_not_gc(bcx, cbox)\n           }\n-          ty::ck_uniq. {\n+          ty::ck_uniq {\n             let bcx = free_ty(bcx, tydesc, mk_tydesc_ty(tcx, ck));\n             trans_shared_free(bcx, cbox)\n           }\n@@ -858,7 +858,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n       some(fptr) {\n         (fptr, llvm::LLVMGetUndef(T_opaque_cbox_ptr(ccx)), 0)\n       }\n-      none. {\n+      none {\n         // Silly check\n         check type_is_tup_like(bcx, cbox_ty);\n         let {bcx: cx, val: pair} =\n@@ -915,7 +915,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n                 llargs += [dict];\n                 off += 1;\n                 dicts = some(alt dicts {\n-                  none. { [dict] }\n+                  none { [dict] }\n                   some(ds) { ds + [dict] }\n                 });\n               }\n@@ -961,7 +961,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n           }\n \n           // Arg will be provided when the thunk is invoked.\n-          none. {\n+          none {\n             let arg: ValueRef = llvm::LLVMGetParam(llthunk, a as c_uint);\n             if ty::type_contains_params(cx.ccx.tcx, out_arg.ty) {\n                 arg = PointerCast(bcx, arg, llout_arg_ty);"}, {"sha": "db1e615804f309c999ffd15a43a321ac2cabbaaf", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -33,7 +33,7 @@ fn new_namegen() -> namegen {\n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n \n tag tydesc_kind {\n-    tk_static; // Static (monomorphic) type descriptor.\n+    tk_static; // Static (monomorphic) type descriptor\n     tk_param; // Type parameter.\n     tk_derived; // Derived from a typaram or another derived tydesc.\n }\n@@ -335,7 +335,7 @@ tag block_kind {\n \n \n     // A scope block is a basic block created by translating a block { ... }\n-    // the the source language.  Since these blocks create variable scope, any\n+    // in the source language.  Since these blocks create variable scope, any\n     // variables created in them that are still live at the end of the block\n     // must be dropped and cleaned up when the block ends.\n     SCOPE_BLOCK;\n@@ -422,7 +422,7 @@ fn find_scope_cx(cx: @block_ctxt) -> @block_ctxt {\n     if cx.kind != NON_SCOPE_BLOCK { ret cx; }\n     alt cx.parent {\n       parent_some(b) { ret find_scope_cx(b); }\n-      parent_none. {\n+      parent_none {\n         cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \" +\n                                     \"called on parentless block_ctxt\");\n       }\n@@ -491,30 +491,30 @@ fn T_int(targ_cfg: @session::config) -> TypeRef {\n \n fn T_int_ty(cx: @crate_ctxt, t: ast::int_ty) -> TypeRef {\n     alt t {\n-      ast::ty_i. { cx.int_type }\n-      ast::ty_char. { T_char() }\n-      ast::ty_i8. { T_i8() }\n-      ast::ty_i16. { T_i16() }\n-      ast::ty_i32. { T_i32() }\n-      ast::ty_i64. { T_i64() }\n+      ast::ty_i { cx.int_type }\n+      ast::ty_char { T_char() }\n+      ast::ty_i8 { T_i8() }\n+      ast::ty_i16 { T_i16() }\n+      ast::ty_i32 { T_i32() }\n+      ast::ty_i64 { T_i64() }\n     }\n }\n \n fn T_uint_ty(cx: @crate_ctxt, t: ast::uint_ty) -> TypeRef {\n     alt t {\n-      ast::ty_u. { cx.int_type }\n-      ast::ty_u8. { T_i8() }\n-      ast::ty_u16. { T_i16() }\n-      ast::ty_u32. { T_i32() }\n-      ast::ty_u64. { T_i64() }\n+      ast::ty_u { cx.int_type }\n+      ast::ty_u8 { T_i8() }\n+      ast::ty_u16 { T_i16() }\n+      ast::ty_u32 { T_i32() }\n+      ast::ty_u64 { T_i64() }\n     }\n }\n \n fn T_float_ty(cx: @crate_ctxt, t: ast::float_ty) -> TypeRef {\n     alt t {\n-      ast::ty_f. { cx.float_type }\n-      ast::ty_f32. { T_f32() }\n-      ast::ty_f64. { T_f64() }\n+      ast::ty_f { cx.float_type }\n+      ast::ty_f32 { T_f32() }\n+      ast::ty_f64 { T_f64() }\n     }\n }\n "}, {"sha": "9a0430481a4a0faea0be408e41ac239f1ecbbf96", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -341,7 +341,7 @@ fn get_static_dict(bcx: @block_ctxt, origin: typeck::dict_origin)\n     let id = dict_id(ccx.tcx, origin);\n     alt ccx.dicts.find(id) {\n       some(d) { ret d; }\n-      none. {}\n+      none {}\n     }\n     let ptrs = C_struct(get_dict_ptrs(bcx, origin).ptrs);\n     let name = ccx.names(\"dict\");"}, {"sha": "feccfc413bfe925c7a8e67f5ded04afc7248096d", "filename": "src/comp/middle/trans_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_vec.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -153,7 +153,7 @@ fn trans_append(cx: @block_ctxt, vec_ty: ty::t, lhsptr: ValueRef,\n         (PointerCast(cx, lhsptr, T_ptr(T_ptr(ccx.opaque_vec_type))),\n          PointerCast(cx, rhs, T_ptr(ccx.opaque_vec_type)));\n     let strings = alt ty::struct(bcx_tcx(cx), vec_ty) {\n-      ty::ty_str. { true }\n+      ty::ty_str { true }\n       ty::ty_vec(_) { false }\n     };\n \n@@ -221,7 +221,7 @@ fn trans_add(bcx: @block_ctxt, vec_ty: ty::t, lhs: ValueRef,\n              rhs: ValueRef, dest: dest) -> @block_ctxt {\n     let ccx = bcx_ccx(bcx);\n     let strings = alt ty::struct(bcx_tcx(bcx), vec_ty) {\n-      ty::ty_str. { true }\n+      ty::ty_str { true }\n       ty::ty_vec(_) { false }\n     };\n     let unit_ty = ty::sequence_element_type(bcx_tcx(bcx), vec_ty);"}, {"sha": "f3862e3d20f50fee994f00e507f5cafc3494e174", "filename": "src/comp/middle/tstate/ann.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fann.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -240,7 +240,7 @@ fn implies(a: t, b: t) -> bool {\n }\n \n fn trit_str(t: trit) -> str {\n-    alt t { dont_care. { \"?\" } ttrue. { \"1\" } tfalse. { \"0\" } }\n+    alt t { dont_care { \"?\" } ttrue { \"1\" } tfalse { \"0\" } }\n }\n //\n // Local Variables:"}, {"sha": "04469cda4eb60a49b746e0960dce64824614039a", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -41,7 +41,7 @@ fn comma_str(args: [@constr_arg_use]) -> str {\n     for a: @constr_arg_use in args {\n         if comma { rslt += \", \"; } else { comma = true; }\n         alt a.node {\n-          carg_base. { rslt += \"*\"; }\n+          carg_base { rslt += \"*\"; }\n           carg_ident(i) { rslt += i.ident; }\n           carg_lit(l) { rslt += lit_to_str(l); }\n         }\n@@ -69,7 +69,7 @@ fn tritv_to_str(fcx: fn_ctxt, v: tritv::t) -> str {\n     let comma = false;\n     for p: norm_constraint in constraints(fcx) {\n         alt tritv_get(v, p.bit_num) {\n-          dont_care. { }\n+          dont_care { }\n           tt {\n             s +=\n                 if comma { \", \" } else { comma = true; \"\" } +\n@@ -310,7 +310,7 @@ fn get_ts_ann(ccx: crate_ctxt, i: node_id) -> option::t<ts_ann> {\n /********* utils ********/\n fn node_id_to_ts_ann(ccx: crate_ctxt, id: node_id) -> ts_ann {\n     alt get_ts_ann(ccx, id) {\n-      none. {\n+      none {\n         #error(\"node_id_to_ts_ann: no ts_ann for node_id %d\", id);\n         fail;\n       }\n@@ -507,7 +507,7 @@ fn constraints_expr(cx: ty::ctxt, e: @expr) -> [@ty::constr] {\n \n fn node_id_to_def_strict(cx: ty::ctxt, id: node_id) -> def {\n     alt cx.def_map.find(id) {\n-      none. {\n+      none {\n         #error(\"node_id_to_def: node_id %d has no def\", id);\n         fail;\n       }\n@@ -565,7 +565,7 @@ fn match_args(fcx: fn_ctxt, occs: @mutable [pred_args],\n \n fn def_id_for_constr(tcx: ty::ctxt, t: node_id) -> def_id {\n     alt tcx.def_map.find(t) {\n-      none. {\n+      none {\n         tcx.sess.bug(\"node_id_for_constr: bad node_id \" + int::str(t));\n       }\n       some(def_fn(i, _)) { ret i; }\n@@ -658,7 +658,7 @@ fn substitute_arg(cx: ty::ctxt, actuals: [@expr], a: @constr_arg) ->\n             cx.sess.span_fatal(a.span, \"Constraint argument out of bounds\");\n         }\n       }\n-      carg_base. { ret @respan(a.span, carg_base); }\n+      carg_base { ret @respan(a.span, carg_base); }\n       carg_lit(l) { ret @respan(a.span, carg_lit(l)); }\n     }\n }\n@@ -675,7 +675,7 @@ fn pred_args_matches(pattern: [constr_arg_general_<inst>], desc: pred_args) ->\n               _ { ret false; }\n             }\n           }\n-          carg_base. { if n != carg_base { ret false; } }\n+          carg_base { if n != carg_base { ret false; } }\n           carg_lit(l) {\n             alt n {\n               carg_lit(m) { if !lit_eq(l, m) { ret false; } }\n@@ -741,7 +741,7 @@ fn insts_to_str(stuff: [constr_arg_general_<inst>]) -> str {\n             \" \" +\n                 alt i {\n                   carg_ident(p) { p.ident }\n-                  carg_base. { \"*\" }\n+                  carg_base { \"*\" }\n                   carg_lit(_) { \"[lit]\" }\n                 } + \" \";\n     }\n@@ -794,7 +794,7 @@ fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n                                     \"local_node_id_to_def_id: id \\\n                isn't a local\");\n       }\n-      none. {\n+      none {\n         // should really be bug. span_bug()?\n         fcx.ccx.tcx.sess.span_fatal(sp,\n                                     \"local_node_id_to_def_id: id \\\n@@ -848,8 +848,8 @@ fn copy_in_poststate_two(fcx: fn_ctxt, src_post: poststate,\n                          ty: oper_type) {\n     let subst;\n     alt ty {\n-      oper_swap. { subst = [{from: dest, to: src}, {from: src, to: dest}]; }\n-      oper_assign_op. {\n+      oper_swap { subst = [{from: dest, to: src}, {from: src, to: dest}]; }\n+      oper_assign_op {\n         ret; // Don't do any propagation\n       }\n       _ { subst = [{from: src, to: dest}]; }\n@@ -1003,7 +1003,7 @@ fn vec_contains(v: @mutable [node_id], i: node_id) -> bool {\n }\n \n fn op_to_oper_ty(io: init_op) -> oper_type {\n-    alt io { init_move. { oper_move } _ { oper_assign } }\n+    alt io { init_move { oper_move } _ { oper_assign } }\n }\n \n // default function visitor\n@@ -1021,7 +1021,7 @@ fn args_to_constr_args(tcx: ty::ctxt, args: [arg],\n         actuals +=\n             [@respan(a.span,\n                      alt a.node {\n-                       carg_base. { carg_base }\n+                       carg_base { carg_base }\n                        carg_ident(i) {\n                          if i < num_args {\n                              carg_ident({ident: args[i].ident,\n@@ -1090,7 +1090,7 @@ fn callee_modes(fcx: fn_ctxt, callee: node_id) -> [ty::mode] {\n \n fn callee_arg_init_ops(fcx: fn_ctxt, callee: node_id) -> [init_op] {\n     fn mode_to_op(m: ty::mode) -> init_op {\n-        alt m { by_move. { init_move } _ { init_assign } }\n+        alt m { by_move { init_move } _ { init_assign } }\n     }\n     vec::map(callee_modes(fcx, callee), mode_to_op)\n }"}, {"sha": "f9209d60c16ced51f5762098500c0d7247a0db4d", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -48,7 +48,7 @@ fn promises_(n: uint, p: poststate) -> bool { ret tritv_get(p, n) == ttrue; }\n \n // v \"happens after\" u\n fn seq_trit(u: trit, v: trit) -> trit {\n-    alt v { ttrue. { ttrue } tfalse. { tfalse } dont_care. { u } }\n+    alt v { ttrue { ttrue } tfalse { tfalse } dont_care { u } }\n }\n \n // idea: q \"happens after\" p -- so if something is"}, {"sha": "200aef3b6dba2b629a919f2bd09200279f21c1ff", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -84,7 +84,7 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n               }\n             }\n           }\n-          none. {\n+          none {\n             let rslt: @mutable [pred_args] =\n                 @mutable [respan(c.span, {args: args, bit_num: next})];\n             tbl.insert(d_id, cpred(p, rslt));"}, {"sha": "5b7322fbb160caaf6fd44d4ccf01b7b86c899e2e", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -132,9 +132,9 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt maybe_alt {\n-      none. {\n+      none {\n         alt chck {\n-          if_check. {\n+          if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             gen(fcx, antec.id, c.node);\n           }\n@@ -166,7 +166,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n         /* Be sure to set the bit for the check condition here,\n          so that it's *not* set in the alternative. */\n         alt chck {\n-          if_check. {\n+          if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             gen(fcx, antec.id, c.node);\n           }\n@@ -219,14 +219,14 @@ fn handle_update(fcx: fn_ctxt, parent: @expr, lhs: @expr, rhs: @expr,\n         let tmp = tritv_clone(post);\n \n         alt ty {\n-          oper_move. {\n+          oper_move {\n             if is_path(rhs) { forget_in_postcond(fcx, parent.id, rhs.id); }\n           }\n-          oper_swap. {\n+          oper_swap {\n             forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n             forget_in_postcond_still_init(fcx, parent.id, rhs.id);\n           }\n-          oper_assign. {\n+          oper_assign {\n             forget_in_postcond_still_init(fcx, parent.id, lhs.id);\n           }\n           _ {\n@@ -336,7 +336,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n \n         /* if this is a failing call, its postcondition sets everything */\n         alt controlflow_expr(fcx.ccx, operator) {\n-          noreturn. { set_postcond_false(fcx.ccx, e.id); }\n+          noreturn { set_postcond_false(fcx.ccx, e.id); }\n           _ { }\n         }\n       }\n@@ -374,7 +374,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       }\n       expr_rec(fields, maybe_base) {\n         let es = field_exprs(fields);\n-        alt maybe_base { none. {/* no-op */ } some(b) { es += [b]; } }\n+        alt maybe_base { none {/* no-op */ } some(b) { es += [b]; } }\n         find_pre_post_exprs(fcx, es, e.id);\n       }\n       expr_tup(elts) { find_pre_post_exprs(fcx, elts, e.id); }\n@@ -395,7 +395,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_lit(_) { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_ret(maybe_val) {\n         alt maybe_val {\n-          none. {\n+          none {\n             clear_precond(fcx.ccx, e.id);\n             set_postcond_false(fcx.ccx, e.id);\n           }\n@@ -503,7 +503,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_fail(maybe_val) {\n         let prestate;\n         alt maybe_val {\n-          none. { prestate = empty_prestate(num_local_vars); }\n+          none { prestate = empty_prestate(num_local_vars); }\n           some(fail_val) {\n             find_pre_post_expr(fcx, fail_val);\n             prestate = expr_precond(fcx.ccx, fail_val);\n@@ -542,7 +542,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         let i = 0;\n         for expr_opt: option::t<@expr> in maybe_args {\n             alt expr_opt {\n-              none. {/* no-op */ }\n+              none {/* no-op */ }\n               some(expr) { modes += [cmodes[i]]; args += [expr]; }\n             }\n             i += 1;\n@@ -551,8 +551,8 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n         forget_args_moved_in(fcx, e, modes, args);\n         find_pre_post_exprs(fcx, args, e.id);\n       }\n-      expr_break. { clear_pp(expr_pp(fcx.ccx, e)); }\n-      expr_cont. { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_break { clear_pp(expr_pp(fcx.ccx, e)); }\n+      expr_cont { clear_pp(expr_pp(fcx.ccx, e)); }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n     }\n }\n@@ -601,7 +601,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                                               node: an_init.expr.id},\n                                              op_to_oper_ty(an_init.op));\n                           }\n-                          none. { }\n+                          none { }\n                         }\n                         gen(fcx, id, ninit(pat.id, ident));\n                     };\n@@ -631,7 +631,7 @@ fn find_pre_post_stmt(fcx: fn_ctxt, s: stmt) {\n                     copy_pre_post_(fcx.ccx, id, prev_pp.precondition,\n                                    prev_pp.postcondition);\n                   }\n-                  none. {\n+                  none {\n                     pat_bindings(alocal.node.pat) {|p|\n                         clear_pp(node_id_to_ts_ann(fcx.ccx, p.id).conditions);\n                     };\n@@ -689,7 +689,7 @@ fn find_pre_post_block(fcx: fn_ctxt, b: blk) {\n     let pps: [pre_and_post] = [];\n     for s: @stmt in b.node.stmts { pps += [stmt_pp(fcx.ccx, *s)]; }\n     alt b.node.expr {\n-      none. {/* no-op */ }\n+      none {/* no-op */ }\n       some(e) { pps += [expr_pp(fcx.ccx, e)]; }\n     }\n \n@@ -721,7 +721,7 @@ fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n     // Treat the tail expression as a return statement\n     alt body.node.expr {\n       some(tailexpr) { set_postcond_false(fcx.ccx, tailexpr.id); }\n-      none. {/* fallthrough */ }\n+      none {/* fallthrough */ }\n     }\n }\n "}, {"sha": "6256ea11b3f05dd4ac774ac561adb0d69fe9152c", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -15,7 +15,7 @@ import driver::session::session;\n \n fn forbid_upvar(fcx: fn_ctxt, rhs_id: node_id, sp: span, t: oper_type) {\n     alt t {\n-      oper_move. {\n+      oper_move {\n         alt local_node_id_to_def(fcx, rhs_id) {\n           some(def_upvar(_, _, _)) {\n             fcx.ccx.tcx.sess.span_err(sp,\n@@ -94,7 +94,7 @@ fn find_pre_post_state_sub(fcx: fn_ctxt, pres: prestate, e: @expr,\n \n     let post = tritv_clone(expr_poststate(fcx.ccx, e));\n     alt c {\n-      none. { }\n+      none { }\n       some(c1) { set_in_poststate_(bit_num(fcx, c1), post); }\n     }\n \n@@ -123,11 +123,11 @@ fn find_pre_post_state_two(fcx: fn_ctxt, pres: prestate, lhs: @expr,\n         let tmp = tritv_clone(post);\n \n         alt ty {\n-          oper_move. {\n+          oper_move {\n             if is_path(rhs) { forget_in_poststate(fcx, post, rhs.id); }\n             forget_in_poststate_still_init(fcx, post, lhs.id);\n           }\n-          oper_swap. {\n+          oper_swap {\n             forget_in_poststate_still_init(fcx, post, lhs.id);\n             forget_in_poststate_still_init(fcx, post, rhs.id);\n           }\n@@ -187,7 +187,7 @@ fn find_pre_post_state_exprs(fcx: fn_ctxt, pres: prestate, id: node_id,\n     let changed = rs.changed | set_prestate_ann(fcx.ccx, id, pres);\n     /* if this is a failing call, it sets everything as initialized */\n     alt cf {\n-      noreturn. {\n+      noreturn {\n         let post = false_postcond(num_constraints(fcx.enclosing));\n         changed |= set_poststate_ann(fcx.ccx, id, post);\n       }\n@@ -265,9 +265,9 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n     */\n \n     alt maybe_alt {\n-      none. {\n+      none {\n         alt chk {\n-          if_check. {\n+          if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             let conseq_prestate = tritv_clone(expr_poststate(fcx.ccx, antec));\n             tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n@@ -292,7 +292,7 @@ fn join_then_else(fcx: fn_ctxt, antec: @expr, conseq: blk,\n \n         let conseq_prestate = expr_poststate(fcx.ccx, antec);\n         alt chk {\n-          if_check. {\n+          if_check {\n             let c: sp_constr = expr_to_constr(fcx.ccx.tcx, antec);\n             conseq_prestate = tritv_clone(conseq_prestate);\n             tritv_set(bit_num(fcx, c.node), conseq_prestate, ttrue);\n@@ -360,7 +360,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         let i = 0;\n         for a_opt: option::t<@expr> in maybe_args {\n             alt a_opt {\n-              none. {/* no-op */ }\n+              none {/* no-op */ }\n               some(a) { ops += [callee_ops[i]]; args += [a]; }\n             }\n             i += 1;\n@@ -390,7 +390,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n                                                     vec::len(fields)),\n                                       field_exprs(fields), return_val);\n         alt maybe_base {\n-          none. {/* do nothing */ }\n+          none {/* do nothing */ }\n           some(base) {\n             changed |=\n                 find_pre_post_state_expr(fcx, pres, base) |\n@@ -431,7 +431,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         set_poststate_ann(fcx.ccx, e.id, post);\n \n         alt maybe_ret_val {\n-          none. {/* do nothing */ }\n+          none {/* do nothing */ }\n           some(ret_val) {\n             changed |= find_pre_post_state_expr(fcx, pres, ret_val);\n           }\n@@ -586,13 +586,13 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n         woo! */\n         let post = false_postcond(num_constrs);\n         alt fcx.enclosing.cf {\n-          noreturn. { kill_poststate_(fcx, ninit(fcx.id, fcx.name), post); }\n+          noreturn { kill_poststate_(fcx, ninit(fcx.id, fcx.name), post); }\n           _ { }\n         }\n         ret set_prestate_ann(fcx.ccx, e.id, pres) |\n                 set_poststate_ann(fcx.ccx, e.id, post) |\n                 alt maybe_fail_val {\n-                  none. { false }\n+                  none { false }\n                   some(fail_val) {\n                     find_pre_post_state_expr(fcx, pres, fail_val)\n                   }\n@@ -609,8 +609,8 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       expr_if_check(p, conseq, maybe_alt) {\n         ret join_then_else(fcx, p, conseq, maybe_alt, e.id, if_check, pres);\n       }\n-      expr_break. { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_cont. { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_break { ret pure_exp(fcx.ccx, e.id, pres); }\n+      expr_cont { ret pure_exp(fcx.ccx, e.id, pres); }\n     }\n }\n \n@@ -704,7 +704,7 @@ fn find_pre_post_state_block(fcx: fn_ctxt, pres0: prestate, b: blk) -> bool {\n     }\n     let post = pres;\n     alt b.node.expr {\n-      none. { }\n+      none { }\n       some(e) {\n         changed |= find_pre_post_state_expr(fcx, pres, e);\n         post = expr_poststate(fcx.ccx, e);\n@@ -767,7 +767,7 @@ fn find_pre_post_state_fn(fcx: fn_ctxt,\n             set_poststate_ann(fcx.ccx, f_body.node.id, post);\n         }\n       }\n-      none. {/* fallthrough */ }\n+      none {/* fallthrough */ }\n     }\n \n     /*"}, {"sha": "6a7504de5c33a3e3ab5f31bb2338a8ec2eac3f5d", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -49,25 +49,25 @@ fn trit_minus(a: trit, b: trit) -> trit {\n          0 - anything else - 0\n      */\n     alt a {\n-      dont_care. { dont_care }\n-      ttrue. {\n+      dont_care { dont_care }\n+      ttrue {\n         alt b {\n-          ttrue. { dont_care }\n-          tfalse. { ttrue }\n+          ttrue { dont_care }\n+          tfalse { ttrue }\n \n \n \n \n           /* internally contradictory, but\n              I guess it'll get flagged? */\n-          dont_care. {\n+          dont_care {\n             ttrue\n           }\n         }\n       }\n-      tfalse. {\n+      tfalse {\n         alt b {\n-          ttrue. { tfalse }\n+          ttrue { tfalse }\n \n \n \n@@ -83,11 +83,11 @@ fn trit_minus(a: trit, b: trit) -> trit {\n \n fn trit_or(a: trit, b: trit) -> trit {\n     alt a {\n-      dont_care. { b }\n-      ttrue. { ttrue }\n-      tfalse. {\n+      dont_care { b }\n+      ttrue { ttrue }\n+      tfalse {\n         alt b {\n-          ttrue. { dont_care }\n+          ttrue { dont_care }\n \n \n \n@@ -108,21 +108,21 @@ fn trit_or(a: trit, b: trit) -> trit {\n // (we consider a constraint false until proven true), too.\n fn trit_and(a: trit, b: trit) -> trit {\n     alt a {\n-      dont_care. { b }\n+      dont_care { b }\n \n \n \n \n       // also seems wrong for case b = ttrue\n-      ttrue. {\n+      ttrue {\n         alt b {\n-          dont_care. { ttrue }\n+          dont_care { ttrue }\n \n \n \n \n           // ??? Seems wrong\n-          ttrue. {\n+          ttrue {\n             ttrue\n           }\n \n@@ -135,7 +135,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n           // (Rationale: it's always safe to assume that\n           // a var is uninitialized or that a constraint\n           // needs to be re-established)\n-          tfalse. {\n+          tfalse {\n             tfalse\n           }\n         }\n@@ -147,7 +147,7 @@ fn trit_and(a: trit, b: trit) -> trit {\n \n       // Rationale: if it's uninit on one path,\n       // we can consider it as uninit on all paths\n-      tfalse. {\n+      tfalse {\n         tfalse\n       }\n     }\n@@ -214,12 +214,12 @@ fn tritv_get(v: t, i: uint) -> trit {\n fn tritv_set(i: uint, v: t, t: trit) -> bool {\n     let old = tritv_get(v, i);\n     alt t {\n-      dont_care. {\n+      dont_care {\n         bitv::set(v.uncertain, i, true);\n         bitv::set(v.val, i, false);\n       }\n-      ttrue. { bitv::set(v.uncertain, i, false); bitv::set(v.val, i, true); }\n-      tfalse. {\n+      ttrue { bitv::set(v.uncertain, i, false); bitv::set(v.val, i, true); }\n+      tfalse {\n         bitv::set(v.uncertain, i, false);\n         bitv::set(v.val, i, false);\n       }\n@@ -273,9 +273,9 @@ fn to_vec(v: t) -> [uint] {\n     while i < v.nbits {\n         rslt +=\n             [alt tritv_get(v, i) {\n-               dont_care. { 2u }\n-               ttrue. { 1u }\n-               tfalse. { 0u }\n+               dont_care { 2u }\n+               ttrue { 1u }\n+               tfalse { 0u }\n              }];\n         i += 1u;\n     }\n@@ -288,9 +288,9 @@ fn to_str(v: t) -> str {\n     while i < v.nbits {\n         rs +=\n             alt tritv_get(v, i) {\n-              dont_care. { \"?\" }\n-              ttrue. { \"1\" }\n-              tfalse. { \"0\" }\n+              dont_care { \"?\" }\n+              ttrue { \"1\" }\n+              tfalse { \"0\" }\n             };\n         i += 1u;\n     }"}, {"sha": "b376af652aa2436da45aba7853f3c591b0d2cf56", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -313,10 +313,10 @@ fn param_bounds_to_kind(bounds: param_bounds) -> kind {\n     let kind = kind_noncopyable;\n     for bound in *bounds {\n         alt bound {\n-          bound_copy. {\n+          bound_copy {\n             if kind != kind_sendable { kind = kind_copyable; }\n           }\n-          bound_send. { kind = kind_sendable; }\n+          bound_send { kind = kind_sendable; }\n           _ {}\n         }\n     }\n@@ -468,8 +468,8 @@ fn mk_raw_ty(cx: ctxt, st: sty) -> @raw_t {\n         derive_flags_t(cx, has_params, has_vars, tt);\n     }\n     alt st {\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_str | ty_send_type | ty_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n@@ -535,30 +535,30 @@ fn mk_uint(_cx: ctxt) -> t { ret idx_uint; }\n \n fn mk_mach_int(_cx: ctxt, tm: ast::int_ty) -> t {\n     alt tm {\n-      ast::ty_i. { ret idx_int; }\n-      ast::ty_char. { ret idx_char; }\n-      ast::ty_i8. { ret idx_i8; }\n-      ast::ty_i16. { ret idx_i16; }\n-      ast::ty_i32. { ret idx_i32; }\n-      ast::ty_i64. { ret idx_i64; }\n+      ast::ty_i { ret idx_int; }\n+      ast::ty_char { ret idx_char; }\n+      ast::ty_i8 { ret idx_i8; }\n+      ast::ty_i16 { ret idx_i16; }\n+      ast::ty_i32 { ret idx_i32; }\n+      ast::ty_i64 { ret idx_i64; }\n     }\n }\n \n fn mk_mach_uint(_cx: ctxt, tm: ast::uint_ty) -> t {\n     alt tm {\n-      ast::ty_u. { ret idx_uint; }\n-      ast::ty_u8. { ret idx_u8; }\n-      ast::ty_u16. { ret idx_u16; }\n-      ast::ty_u32. { ret idx_u32; }\n-      ast::ty_u64. { ret idx_u64; }\n+      ast::ty_u { ret idx_uint; }\n+      ast::ty_u8 { ret idx_u8; }\n+      ast::ty_u16 { ret idx_u16; }\n+      ast::ty_u32 { ret idx_u32; }\n+      ast::ty_u64 { ret idx_u64; }\n     }\n }\n \n fn mk_mach_float(_cx: ctxt, tm: ast::float_ty) -> t {\n     alt tm {\n-      ast::ty_f. { ret idx_float; }\n-      ast::ty_f32. { ret idx_f32; }\n-      ast::ty_f64. { ret idx_f64; }\n+      ast::ty_f { ret idx_float; }\n+      ast::ty_f32 { ret idx_f32; }\n+      ast::ty_f64 { ret idx_f64; }\n     }\n }\n \n@@ -659,9 +659,9 @@ pure fn mach_struct(cx: ctxt, cfg: @session::config, typ: t) -> sty {\n // Converts s to its machine type equivalent\n pure fn mach_sty(cfg: @session::config, s: sty) -> sty {\n     alt s {\n-      ty_int(ast::ty_i.) { ty_int(cfg.int_type) }\n-      ty_uint(ast::ty_u.) { ty_uint(cfg.uint_type) }\n-      ty_float(ast::ty_f.) { ty_float(cfg.float_type) }\n+      ty_int(ast::ty_i) { ty_int(cfg.int_type) }\n+      ty_uint(ast::ty_u) { ty_uint(cfg.uint_type) }\n+      ty_float(ast::ty_f) { ty_float(cfg.float_type) }\n       s { s }\n     }\n }\n@@ -679,8 +679,8 @@ type ty_walk = fn@(t);\n \n fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     alt struct(cx, ty) {\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_str | ty_send_type | ty_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n@@ -728,8 +728,8 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n       fm_general(_) {/* no fast path */ }\n     }\n     alt interner::get(*cx.ts, ty).struct {\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str. | ty_send_type. | ty_type. | ty_native(_) |\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_str | ty_send_type | ty_type | ty_native(_) |\n       ty_opaque_closure_ptr(_) {\n         /* no-op */\n       }\n@@ -813,15 +813,15 @@ fn fold_ty(cx: ctxt, fld: fold_mode, ty_0: t) -> t {\n // Type utilities\n \n fn type_is_nil(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_nil. { ret true; } _ { ret false; } }\n+    alt struct(cx, ty) { ty_nil { ret true; } _ { ret false; } }\n }\n \n fn type_is_bot(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_bot. { ret true; } _ { ret false; } }\n+    alt struct(cx, ty) { ty_bot { ret true; } _ { ret false; } }\n }\n \n fn type_is_bool(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_bool. { ret true; } _ { ret false; } }\n+    alt struct(cx, ty) { ty_bool { ret true; } _ { ret false; } }\n }\n \n fn type_is_structural(cx: ctxt, ty: t) -> bool {\n@@ -838,19 +838,19 @@ fn type_is_copyable(cx: ctxt, ty: t) -> bool {\n \n fn type_is_sequence(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_str. { ret true; }\n+      ty_str { ret true; }\n       ty_vec(_) { ret true; }\n       _ { ret false; }\n     }\n }\n \n fn type_is_str(cx: ctxt, ty: t) -> bool {\n-    alt struct(cx, ty) { ty_str. { ret true; } _ { ret false; } }\n+    alt struct(cx, ty) { ty_str { ret true; } _ { ret false; } }\n }\n \n fn sequence_element_type(cx: ctxt, ty: t) -> t {\n     alt struct(cx, ty) {\n-      ty_str. { ret mk_mach_uint(cx, ast::ty_u8); }\n+      ty_str { ret mk_mach_uint(cx, ast::ty_u8); }\n       ty_vec(mt) { ret mt.ty; }\n       _ { cx.sess.bug(\"sequence_element_type called on non-sequence value\"); }\n     }\n@@ -907,7 +907,7 @@ pure fn type_is_unsafe_ptr(cx: ctxt, ty: t) -> bool {\n pure fn type_is_vec(cx: ctxt, ty: t) -> bool {\n     ret alt struct(cx, ty) {\n           ty_vec(_) { true }\n-          ty_str. { true }\n+          ty_str { true }\n           _ { false }\n         };\n }\n@@ -916,15 +916,15 @@ pure fn type_is_unique(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n       ty_uniq(_) { ret true; }\n       ty_vec(_) { true }\n-      ty_str. { true }\n+      ty_str { true }\n       _ { ret false; }\n     }\n }\n \n pure fn type_is_scalar(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_nil. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { true }\n+      ty_nil | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_send_type | ty_type | ty_native(_) | ty_ptr(_) { true }\n       _ { false }\n     }\n }\n@@ -938,14 +938,14 @@ fn type_is_immediate(cx: ctxt, ty: t) -> bool {\n fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     alt cx.needs_drop_cache.find(ty) {\n       some(result) { ret result; }\n-      none. {/* fall through */ }\n+      none {/* fall through */ }\n     }\n \n     let accum = false;\n     let result = alt struct(cx, ty) {\n       // scalar types\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_type. | ty_native(_) | ty_ptr(_) { false }\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_type | ty_native(_) | ty_ptr(_) { false }\n       ty_rec(flds) {\n         for f in flds { if type_needs_drop(cx, f.mt.ty) { accum = true; } }\n         accum\n@@ -980,35 +980,35 @@ tag kind { kind_sendable; kind_copyable; kind_noncopyable; }\n // future.\n pure fn kind_can_be_copied(k: kind) -> bool {\n     ret alt k {\n-      kind_sendable. { true }\n-      kind_copyable. { true }\n-      kind_noncopyable. { false }\n+      kind_sendable { true }\n+      kind_copyable { true }\n+      kind_noncopyable { false }\n     };\n }\n \n pure fn kind_can_be_sent(k: kind) -> bool {\n     ret alt k {\n-      kind_sendable. { true }\n-      kind_copyable. { false }\n-      kind_noncopyable. { false }\n+      kind_sendable { true }\n+      kind_copyable { false }\n+      kind_noncopyable { false }\n     };\n }\n \n fn proto_kind(p: proto) -> kind {\n     alt p {\n-      ast::proto_any. { kind_noncopyable }\n-      ast::proto_block. { kind_noncopyable }\n-      ast::proto_box. { kind_copyable }\n-      ast::proto_uniq. { kind_sendable }\n-      ast::proto_bare. { kind_sendable }\n+      ast::proto_any { kind_noncopyable }\n+      ast::proto_block { kind_noncopyable }\n+      ast::proto_box { kind_copyable }\n+      ast::proto_uniq { kind_sendable }\n+      ast::proto_bare { kind_sendable }\n     }\n }\n \n fn kind_lteq(a: kind, b: kind) -> bool {\n     alt a {\n-      kind_noncopyable. { true }\n-      kind_copyable. { b != kind_noncopyable }\n-      kind_sendable. { b == kind_sendable }\n+      kind_noncopyable { true }\n+      kind_copyable { b != kind_noncopyable }\n+      kind_sendable { b == kind_sendable }\n     }\n }\n \n@@ -1019,22 +1019,22 @@ fn lower_kind(a: kind, b: kind) -> kind {\n fn type_kind(cx: ctxt, ty: t) -> kind {\n     alt cx.kind_cache.find(ty) {\n       some(result) { ret result; }\n-      none. {/* fall through */ }\n+      none {/* fall through */ }\n     }\n \n     // Insert a default in case we loop back on self recursively.\n     cx.kind_cache.insert(ty, kind_sendable);\n \n     let result = alt struct(cx, ty) {\n       // Scalar and unique types are sendable\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_uint(_) | ty_float(_) |\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n       ty_native(_) | ty_ptr(_) |\n-      ty_send_type. | ty_str. | ty_native_fn(_, _) { kind_sendable }\n-      ty_type. { kind_copyable }\n+      ty_send_type | ty_str | ty_native_fn(_, _) { kind_sendable }\n+      ty_type { kind_copyable }\n       ty_fn(f) { proto_kind(f.proto) }\n-      ty_opaque_closure_ptr(ck_block.) { kind_noncopyable }\n-      ty_opaque_closure_ptr(ck_box.) { kind_copyable }\n-      ty_opaque_closure_ptr(ck_uniq.) { kind_sendable }\n+      ty_opaque_closure_ptr(ck_block) { kind_noncopyable }\n+      ty_opaque_closure_ptr(ck_box) { kind_copyable }\n+      ty_opaque_closure_ptr(ck_uniq) { kind_sendable }\n       // Those with refcounts-to-inner raise pinned to shared,\n       // lower unique to shared. Therefore just set result to shared.\n       ty_box(_) | ty_iface(_, _) { kind_copyable }\n@@ -1164,15 +1164,15 @@ fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n         ret alt sty {\n           ty_uniq(_) { ret true; }\n           ty_vec(_) { true }\n-          ty_str. { true }\n+          ty_str { true }\n           _ { ret false; }\n         };\n     });\n }\n \n fn type_is_integral(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n-      ty_int(_) | ty_uint(_) | ty_bool. { true }\n+      ty_int(_) | ty_uint(_) | ty_bool { true }\n       _ { false }\n     }\n }\n@@ -1201,10 +1201,10 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n     let result = true;\n     alt struct(cx, ty) {\n       // Scalar types\n-      ty_nil. | ty_bot. | ty_bool. | ty_int(_) | ty_float(_) | ty_uint(_) |\n-      ty_send_type. | ty_type. | ty_native(_) | ty_ptr(_) { result = true; }\n+      ty_nil | ty_bot | ty_bool | ty_int(_) | ty_float(_) | ty_uint(_) |\n+      ty_send_type | ty_type | ty_native(_) | ty_ptr(_) { result = true; }\n       // Boxed types\n-      ty_str. | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n+      ty_str | ty_box(_) | ty_uniq(_) | ty_vec(_) | ty_fn(_) |\n       ty_native_fn(_, _) | ty_iface(_, _) { result = false; }\n       // Structural types\n       ty_tag(did, tps) {\n@@ -1334,7 +1334,7 @@ fn hash_type_structure(st: sty) -> uint {\n         let h = id;\n         for a: @ty_constr_arg in args {\n             alt a.node {\n-              carg_base. { h += h << 5u; }\n+              carg_base { h += h << 5u; }\n               carg_lit(_) {\n                 // FIXME\n                 fail \"lit args not implemented yet\";\n@@ -1355,23 +1355,23 @@ fn hash_type_structure(st: sty) -> uint {\n         ret h;\n     }\n     alt st {\n-      ty_nil. { 0u } ty_bool. { 1u }\n+      ty_nil { 0u } ty_bool { 1u }\n       ty_int(t) {\n         alt t {\n-          ast::ty_i. { 2u } ast::ty_char. { 3u } ast::ty_i8. { 4u }\n-          ast::ty_i16. { 5u } ast::ty_i32. { 6u } ast::ty_i64. { 7u }\n+          ast::ty_i { 2u } ast::ty_char { 3u } ast::ty_i8 { 4u }\n+          ast::ty_i16 { 5u } ast::ty_i32 { 6u } ast::ty_i64 { 7u }\n         }\n       }\n       ty_uint(t) {\n         alt t {\n-          ast::ty_u. { 8u } ast::ty_u8. { 9u } ast::ty_u16. { 10u }\n-          ast::ty_u32. { 11u } ast::ty_u64. { 12u }\n+          ast::ty_u { 8u } ast::ty_u8 { 9u } ast::ty_u16 { 10u }\n+          ast::ty_u32 { 11u } ast::ty_u64 { 12u }\n         }\n       }\n       ty_float(t) {\n-        alt t { ast::ty_f. { 13u } ast::ty_f32. { 14u } ast::ty_f64. { 15u } }\n+        alt t { ast::ty_f { 13u } ast::ty_f32 { 14u } ast::ty_f64 { 15u } }\n       }\n-      ty_str. { ret 17u; }\n+      ty_str { ret 17u; }\n       ty_tag(did, tys) {\n         let h = hash_def(18u, did);\n         for typ: t in tys { h += (h << 5u) + typ; }\n@@ -1391,9 +1391,9 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_native_fn(args, rty) { ret hash_fn(28u, args, rty); }\n       ty_var(v) { ret hash_uint(30u, v as uint); }\n       ty_param(pid, _) { ret hash_uint(31u, pid); }\n-      ty_type. { ret 32u; }\n+      ty_type { ret 32u; }\n       ty_native(did) { ret hash_def(33u, did); }\n-      ty_bot. { ret 34u; }\n+      ty_bot { ret 34u; }\n       ty_ptr(mt) { ret hash_subty(35u, mt.ty); }\n       ty_res(did, sub, tps) {\n         let h = hash_subty(hash_def(18u, did), sub);\n@@ -1405,16 +1405,16 @@ fn hash_type_structure(st: sty) -> uint {\n         ret h;\n       }\n       ty_uniq(mt) { ret hash_subty(37u, mt.ty); }\n-      ty_send_type. { ret 38u; }\n+      ty_send_type { ret 38u; }\n       ty_named(t, name) { (str::hash(*name) << 5u) + hash_subty(39u, t) }\n       ty_iface(did, tys) {\n         let h = hash_def(40u, did);\n         for typ: t in tys { h = hash_subty(h, typ); }\n         ret h;\n       }\n-      ty_opaque_closure_ptr(ck_block.) { ret 41u; }\n-      ty_opaque_closure_ptr(ck_box.) { ret 42u; }\n-      ty_opaque_closure_ptr(ck_uniq.) { ret 43u; }\n+      ty_opaque_closure_ptr(ck_block) { ret 41u; }\n+      ty_opaque_closure_ptr(ck_box) { ret 42u; }\n+      ty_opaque_closure_ptr(ck_uniq) { ret 43u; }\n     }\n }\n \n@@ -1425,8 +1425,8 @@ fn arg_eq<T>(eq: block(T, T) -> bool,\n              b: @sp_constr_arg<T>)\n    -> bool {\n     alt a.node {\n-      ast::carg_base. {\n-        alt b.node { ast::carg_base. { ret true; } _ { ret false; } }\n+      ast::carg_base {\n+        alt b.node { ast::carg_base { ret true; } _ { ret false; } }\n       }\n       ast::carg_ident(s) {\n         alt b.node { ast::carg_ident(t) { ret eq(s, t); } _ { ret false; } }\n@@ -1469,7 +1469,7 @@ fn node_id_to_ty_param_substs_opt_and_ty(cx: ctxt, id: ast::node_id) ->\n    ty_param_substs_opt_and_ty {\n     // Pull out the node type table.\n     alt smallintmap::find(*cx.node_types, id as uint) {\n-      none. {\n+      none {\n         cx.sess.bug(\"node_id_to_ty_param_substs_opt_and_ty() called on \" +\n                         \"an untyped node (\" + int::to_str(id, 10u) +\n                         \")\");\n@@ -1484,7 +1484,7 @@ fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n \n fn node_id_to_type_params(cx: ctxt, id: ast::node_id) -> [t] {\n     alt node_id_to_ty_param_substs_opt_and_ty(cx, id).substs {\n-      none. { ret []; }\n+      none { ret []; }\n       some(tps) { ret tps; }\n     }\n }\n@@ -1494,19 +1494,19 @@ fn node_id_has_type_params(cx: ctxt, id: ast::node_id) -> bool {\n }\n \n \n-// Returns a type with type parameter substitutions performed if applicable.\n+// Returns a type with type parameter substitutions performed if applicable\n fn ty_param_substs_opt_and_ty_to_monotype(cx: ctxt,\n                                           tpot: ty_param_substs_opt_and_ty) ->\n    t {\n     alt tpot.substs {\n-      none. { ret tpot.ty; }\n+      none { ret tpot.ty; }\n       some(tps) { ret substitute_type_params(cx, tps, tpot.ty); }\n     }\n }\n \n \n // Returns the type of an annotation, with type parameter substitutions\n-// performed if applicable.\n+// performed if applicable\n fn node_id_to_monotype(cx: ctxt, id: ast::node_id) -> t {\n     let tpot = node_id_to_ty_param_substs_opt_and_ty(cx, id);\n     ret ty_param_substs_opt_and_ty_to_monotype(cx, tpot);\n@@ -1643,7 +1643,7 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n     alt e.node {\n       ast::expr_path(_) | ast::expr_index(_, _) |\n-      ast::expr_unary(ast::deref., _) { true }\n+      ast::expr_unary(ast::deref, _) { true }\n       ast::expr_field(base, ident, _) { !method_map.contains_key(e.id) }\n       _ { false }\n     }\n@@ -1771,15 +1771,15 @@ mod unify {\n \n \n         alt smallintmap::find(vb.types, root_a) {\n-          none. {\n+          none {\n             alt smallintmap::find(vb.types, root_b) {\n-              none. { ufind::union(vb.sets, set_a, set_b); ret unres_ok; }\n+              none { ufind::union(vb.sets, set_a, set_b); ret unres_ok; }\n               some(t_b) { replace_type(vb, t_b); ret unres_ok; }\n             }\n           }\n           some(t_a) {\n             alt smallintmap::find(vb.types, root_b) {\n-              none. { replace_type(vb, t_a); ret unres_ok; }\n+              none { replace_type(vb, t_a); ret unres_ok; }\n               some(t_b) {\n                 alt unify_step(cx, t_a, t_b, variance) {\n                   ures_ok(t_c) { replace_type(vb, t_c); ret unres_ok; }\n@@ -1818,7 +1818,7 @@ mod unify {\n               rs { ret rs; }\n             }\n           }\n-          none. {/* fall through */ }\n+          none {/* fall through */ }\n         }\n         smallintmap::insert::<t>(vb.types, root, result_type);\n         ret ures_ok(typ);\n@@ -1866,8 +1866,8 @@ mod unify {\n         for a: @ty_constr_arg in expected.node.args {\n             actual = actual_constr.node.args[i];\n             alt a.node {\n-              carg_base. {\n-                alt actual.node { carg_base. { } _ { ret err_res; } }\n+              carg_base {\n+                alt actual.node { carg_base { } _ { ret err_res; } }\n               }\n               carg_lit(l) {\n                 alt actual.node {\n@@ -1895,7 +1895,7 @@ mod unify {\n         // If you're unifying on something mutable then we have to\n         // be invariant on the inner type\n         let newvariance = alt expected {\n-          ast::mut. {\n+          ast::mut {\n             variance_transform(variance, invariant)\n           }\n           _ {\n@@ -1929,19 +1929,19 @@ mod unify {\n         // subtype).\n         fn sub_proto(p_sub: ast::proto, p_sup: ast::proto) -> bool {\n             ret alt (p_sub, p_sup) {\n-              (_, ast::proto_any.) { true }\n-              (_, ast::proto_block.) { true } /* NDM temporary */\n-              (ast::proto_bare., _) { true }\n+              (_, ast::proto_any) { true }\n+              (_, ast::proto_block) { true } /* NDM temporary */\n+              (ast::proto_bare, _) { true }\n \n               // Equal prototypes are always subprotos:\n               (_, _) { p_sub == p_sup }\n             };\n         }\n \n         ret alt variance {\n-          invariant. if e_proto == a_proto { none }\n-          covariant. if sub_proto(a_proto, e_proto) { none }\n-          contravariant. if sub_proto(e_proto, a_proto) { none }\n+          invariant if e_proto == a_proto { none }\n+          covariant if sub_proto(a_proto, e_proto) { none }\n+          contravariant if sub_proto(e_proto, a_proto) { none }\n           _ { some(ures_err(terr_mismatch)) }\n         };\n     }\n@@ -1981,7 +1981,7 @@ mod unify {\n         -> result {\n         alt unify_fn_proto(e_f.proto, a_f.proto, variance) {\n           some(err) { ret err; }\n-          none. { /* fall through */ }\n+          none { /* fall through */ }\n         }\n \n         if a_f.ret_style != ast::noreturn && a_f.ret_style != e_f.ret_style {\n@@ -2032,7 +2032,7 @@ mod unify {\n             if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n             let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find::<t>(vb.types, root_id) {\n-              none. { ret fix_err(vid); }\n+              none { ret fix_err(vid); }\n               some(rt) { ret fix_ok(rt); }\n             }\n           }\n@@ -2058,25 +2058,25 @@ mod unify {\n     // read the paper (yet).\n     fn variance_transform(a: variance, b: variance) -> variance {\n         alt a {\n-          covariant. {\n+          covariant {\n             alt b {\n-              covariant. { covariant }\n-              contravariant. { contravariant }\n-              invariant. { invariant }\n+              covariant { covariant }\n+              contravariant { contravariant }\n+              invariant { invariant }\n             }\n           }\n-          contravariant. {\n+          contravariant {\n             alt b {\n-              covariant. { contravariant }\n-              contravariant. { covariant }\n-              invariant. { invariant }\n+              covariant { contravariant }\n+              contravariant { covariant }\n+              invariant { invariant }\n             }\n           }\n-          invariant. {\n+          invariant {\n             alt b {\n-              covariant. { invariant }\n-              contravariant. { invariant }\n-              invariant. { invariant }\n+              covariant { invariant }\n+              contravariant { invariant }\n+              invariant { invariant }\n             }\n           }\n         }\n@@ -2108,7 +2108,7 @@ mod unify {\n         if expected == actual { ret ures_ok(expected); }\n \n         // Stage 1: Handle the cases in which one side or another is a type\n-        // variable.\n+        // variable\n \n         alt struct(cx.tcx, actual) {\n           // If the RHS is a variable type, then just do the\n@@ -2119,7 +2119,7 @@ mod unify {\n               ty::ty_var(expected_id) {\n                 let expected_n = expected_id as uint;\n                 alt union(cx, expected_n, actual_n, variance) {\n-                  unres_ok. {/* fall through */ }\n+                  unres_ok {/* fall through */ }\n                   unres_err(t_e) { ret ures_err(t_e); }\n                 }\n               }\n@@ -2152,17 +2152,17 @@ mod unify {\n         // Stage 2: Handle all other cases.\n \n         alt struct(cx.tcx, actual) {\n-          ty::ty_bot. { ret ures_ok(expected); }\n+          ty::ty_bot { ret ures_ok(expected); }\n           _ {/* fall through */ }\n         }\n         alt struct(cx.tcx, expected) {\n-          ty::ty_nil. { ret struct_cmp(cx, expected, actual); }\n+          ty::ty_nil { ret struct_cmp(cx, expected, actual); }\n           // _|_ unifies with anything\n-          ty::ty_bot. {\n+          ty::ty_bot {\n             ret ures_ok(actual);\n           }\n-          ty::ty_bool. | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n-          ty::ty_str. | ty::ty_type. | ty::ty_send_type. {\n+          ty::ty_bool | ty::ty_int(_) | ty_uint(_) | ty_float(_) |\n+          ty::ty_str | ty::ty_type | ty::ty_send_type {\n             ret struct_cmp(cx, expected, actual);\n           }\n           ty::ty_native(ex_id) {\n@@ -2216,7 +2216,7 @@ mod unify {\n               ty::ty_box(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n-                  none. { ret ures_err(terr_box_mutability); }\n+                  none { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n@@ -2237,7 +2237,7 @@ mod unify {\n               ty::ty_uniq(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n-                  none. { ret ures_err(terr_box_mutability); }\n+                  none { ret ures_err(terr_box_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n@@ -2258,7 +2258,7 @@ mod unify {\n               ty::ty_vec(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n-                  none. { ret ures_err(terr_vec_mutability); }\n+                  none { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n@@ -2279,7 +2279,7 @@ mod unify {\n               ty::ty_ptr(actual_mt) {\n                 let (mutt, var) = alt unify_mut(\n                     expected_mt.mut, actual_mt.mut, variance) {\n-                  none. { ret ures_err(terr_vec_mutability); }\n+                  none { ret ures_err(terr_vec_mutability); }\n                   some(mv) { mv }\n                 };\n                 let result = unify_step(\n@@ -2344,7 +2344,7 @@ mod unify {\n                     let (mutt, var) = alt unify_mut(\n                         expected_field.mt.mut, actual_field.mt.mut, variance)\n                         {\n-                      none. { ret ures_err(terr_record_mutability); }\n+                      none { ret ures_err(terr_record_mutability); }\n                       some(mv) { mv }\n                     };\n                     if !str::eq(expected_field.ident, actual_field.ident) {\n@@ -2462,7 +2462,7 @@ mod unify {\n             }\n             let typespec;\n             alt smallintmap::find::<t>(vb.types, i) {\n-              none. { typespec = \"\"; }\n+              none { typespec = \"\"; }\n               some(typ) { typespec = \" =\" + ty_to_str(tcx, typ); }\n             }\n             #error(\"set %u:%s%s\", i, typespec, sets);\n@@ -2486,7 +2486,7 @@ mod unify {\n             }\n             let root_id = ufind::find(vb.sets, vid as uint);\n             alt smallintmap::find::<t>(vb.types, root_id) {\n-              none. { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n+              none { *unresolved = some(vid); ret ty::mk_var(tcx, vid); }\n               some(rt) {\n                 if occurs_check_fails(tcx, sp, vid, rt) {\n                     // Return the type unchanged, so we can error out\n@@ -2505,7 +2505,7 @@ mod unify {\n                     typ);\n         let ur = *unresolved;\n         alt ur {\n-          none. { ret fix_ok(rty); }\n+          none { ret fix_ok(rty); }\n           some(var_id) { ret fix_err(var_id); }\n         }\n     }\n@@ -2514,7 +2514,7 @@ mod unify {\n         if vid as uint >= ufind::set_count(vb.sets) { ret fix_err(vid); }\n         let root_id = ufind::find(vb.sets, vid as uint);\n         alt smallintmap::find::<t>(vb.types, root_id) {\n-          none. { ret fix_err(vid); }\n+          none { ret fix_err(vid); }\n           some(rt) { ret fixup_vars(tcx, sp, vb, rt); }\n         }\n     }\n@@ -2529,19 +2529,19 @@ fn same_type(cx: ctxt, a: t, b: t) -> bool {\n \n fn type_err_to_str(err: ty::type_err) -> str {\n     alt err {\n-      terr_mismatch. { ret \"types differ\"; }\n+      terr_mismatch { ret \"types differ\"; }\n       terr_ret_style_mismatch(expect, actual) {\n         fn to_str(s: ast::ret_style) -> str {\n             alt s {\n-              ast::noreturn. { \"non-returning\" }\n+              ast::noreturn { \"non-returning\" }\n               ast::return_val. { \"return-by-value\" }\n             }\n         }\n         ret to_str(actual) + \" function found where \" + to_str(expect) +\n             \" function was expected\";\n       }\n-      terr_box_mutability. { ret \"boxed values differ in mutability\"; }\n-      terr_vec_mutability. { ret \"vectors differ in mutability\"; }\n+      terr_box_mutability { ret \"boxed values differ in mutability\"; }\n+      terr_vec_mutability { ret \"vectors differ in mutability\"; }\n       terr_tuple_size(e_sz, a_sz) {\n         ret \"expected a tuple with \" + uint::to_str(e_sz, 10u) +\n                 \" elements but found one with \" + uint::to_str(a_sz, 10u) +\n@@ -2552,12 +2552,12 @@ fn type_err_to_str(err: ty::type_err) -> str {\n                 \" fields but found one with \" + uint::to_str(a_sz, 10u) +\n                 \" fields\";\n       }\n-      terr_record_mutability. { ret \"record elements differ in mutability\"; }\n+      terr_record_mutability { ret \"record elements differ in mutability\"; }\n       terr_record_fields(e_fld, a_fld) {\n         ret \"expected a record with field '\" + e_fld +\n                 \"' but found one with field '\" + a_fld + \"'\";\n       }\n-      terr_arg_count. { ret \"incorrect number of function parameters\"; }\n+      terr_arg_count { ret \"incorrect number of function parameters\"; }\n       terr_mode_mismatch(e_mode, a_mode) {\n         ret \"expected argument mode \" + mode_str(e_mode) + \" but found \" +\n                 mode_str(a_mode);\n@@ -2701,7 +2701,7 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     }\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n-      none. {\n+      none {\n         let tyt = csearch::get_type(cx, did);\n         cx.tcache.insert(did, tyt);\n         ret tyt;\n@@ -2735,40 +2735,40 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n \n     fn opcat(op: ast::binop) -> int {\n         alt op {\n-          ast::add. { opcat_add }\n-          ast::subtract. { opcat_sub }\n-          ast::mul. { opcat_mult }\n-          ast::div. { opcat_mult }\n-          ast::rem. { opcat_mult }\n-          ast::and. { opcat_logic }\n-          ast::or. { opcat_logic }\n-          ast::bitxor. { opcat_bit }\n-          ast::bitand. { opcat_bit }\n-          ast::bitor. { opcat_bit }\n-          ast::lsl. { opcat_shift }\n-          ast::lsr. { opcat_shift }\n-          ast::asr. { opcat_shift }\n-          ast::eq. { opcat_eq }\n-          ast::ne. { opcat_eq }\n-          ast::lt. { opcat_rel }\n-          ast::le. { opcat_rel }\n-          ast::ge. { opcat_rel }\n-          ast::gt. { opcat_rel }\n+          ast::add { opcat_add }\n+          ast::subtract { opcat_sub }\n+          ast::mul { opcat_mult }\n+          ast::div { opcat_mult }\n+          ast::rem { opcat_mult }\n+          ast::and { opcat_logic }\n+          ast::or { opcat_logic }\n+          ast::bitxor { opcat_bit }\n+          ast::bitand { opcat_bit }\n+          ast::bitor { opcat_bit }\n+          ast::lsl { opcat_shift }\n+          ast::lsr { opcat_shift }\n+          ast::asr { opcat_shift }\n+          ast::eq { opcat_eq }\n+          ast::ne { opcat_eq }\n+          ast::lt { opcat_rel }\n+          ast::le { opcat_rel }\n+          ast::ge { opcat_rel }\n+          ast::gt { opcat_rel }\n         }\n     }\n \n     fn tycat(cx: ctxt, ty: t) -> int {\n         alt struct(cx, ty) {\n-          ty_bool. { tycat_bool }\n+          ty_bool { tycat_bool }\n           ty_int(_) { tycat_int }\n           ty_uint(_) { tycat_int }\n           ty_float(_) { tycat_float }\n-          ty_str. { tycat_str }\n+          ty_str { tycat_str }\n           ty_vec(_) { tycat_vec }\n           ty_rec(_) { tycat_struct }\n           ty_tup(_) { tycat_struct }\n           ty_tag(_, _) { tycat_struct }\n-          ty_bot. { tycat_bot }\n+          ty_bot { tycat_bot }\n           _ { tycat_other }\n         }\n     }\n@@ -2798,7 +2798,7 @@ fn is_binopable(cx: ctxt, ty: t, op: ast::binop) -> bool {\n fn ast_constr_to_constr<T>(tcx: ty::ctxt, c: @ast::constr_general<T>) ->\n    @ty::constr_general<T> {\n     alt tcx.def_map.find(c.node.id) {\n-      some(ast::def_fn(pred_id, ast::pure_fn.)) {\n+      some(ast::def_fn(pred_id, ast::pure_fn)) {\n         ret @ast_util::respan(c.span,\n                               {path: c.node.path,\n                                args: c.node.args,"}, {"sha": "ea64d5f3f11950387817c63723f19a456cdb4451", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -218,7 +218,7 @@ fn type_is_c_like_enum(fcx: @fn_ctxt, sp: span, typ: ty::t) -> bool {\n fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n                            ty: ty::t) -> ast::mode {\n     alt m {\n-      ast::mode_infer. {\n+      ast::mode_infer {\n         alt ty::struct(tcx, ty) {\n             ty::ty_var(_) { ast::mode_infer }\n             _ {\n@@ -237,8 +237,8 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n         -> ty::ty_param_bounds_and_ty {\n         alt mode {\n-          m_check. | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n-          m_collect. {\n+          m_check | m_check_tyvar(_) { ty::lookup_item_type(tcx, id) }\n+          m_collect {\n             if id.crate != ast::local_crate { csearch::get_type(tcx, id) }\n             else {\n                 alt tcx.items.find(id.node) {\n@@ -260,13 +260,13 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     }\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n-      some(none.) {\n+      some(none) {\n         tcx.sess.span_fatal(ast_ty.span,\n                             \"illegal recursive type \\\n                               insert a tag in the cycle, \\\n                               if this is desired)\");\n       }\n-      none. { }\n+      none { }\n     } /* go on */\n \n     tcx.ast_ty_to_ty_cache.insert(ast_ty, none::<ty::t>);\n@@ -299,13 +299,13 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     }\n     let typ;\n     alt ast_ty.node {\n-      ast::ty_nil. { typ = ty::mk_nil(tcx); }\n-      ast::ty_bot. { typ = ty::mk_bot(tcx); }\n-      ast::ty_bool. { typ = ty::mk_bool(tcx); }\n+      ast::ty_nil { typ = ty::mk_nil(tcx); }\n+      ast::ty_bot { typ = ty::mk_bot(tcx); }\n+      ast::ty_bool { typ = ty::mk_bool(tcx); }\n       ast::ty_int(it) { typ = ty::mk_mach_int(tcx, it); }\n       ast::ty_uint(uit) { typ = ty::mk_mach_uint(tcx, uit); }\n       ast::ty_float(ft) { typ = ty::mk_mach_float(tcx, ft); }\n-      ast::ty_str. { typ = ty::mk_str(tcx); }\n+      ast::ty_str { typ = ty::mk_str(tcx); }\n       ast::ty_box(mt) {\n         typ = ty::mk_box(tcx, ast_mt_to_mt(tcx, mode, mt));\n       }\n@@ -385,7 +385,7 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n       ast::item_ty(t, tps) {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n-          none. { }\n+          none { }\n         }\n         // Tell ast_ty_to_ty() that we want to perform a recursive\n         // call to resolve any named types.\n@@ -434,10 +434,10 @@ fn ty_of_native_item(tcx: ty::ctxt, mode: mode, it: @ast::native_item)\n         ret ty_of_native_fn_decl(tcx, mode, fn_decl, params,\n                                  ast_util::local_def(it.id));\n       }\n-      ast::native_item_ty. {\n+      ast::native_item_ty {\n         alt tcx.tcache.find(local_def(it.id)) {\n           some(tpt) { ret tpt; }\n-          none. { }\n+          none { }\n         }\n         let t = ty::mk_native(tcx, ast_util::local_def(it.id));\n         let t = ty::mk_named(tcx, t, @it.ident);\n@@ -491,12 +491,12 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n     for param in params {\n         result += [alt tcx.ty_param_bounds.find(param.id) {\n           some(bs) { bs }\n-          none. {\n+          none {\n             let bounds = [];\n             for b in *param.bounds {\n                 bounds += [alt b {\n-                  ast::bound_send. { ty::bound_send }\n-                  ast::bound_copy. { ty::bound_copy }\n+                  ast::bound_send { ty::bound_send }\n+                  ast::bound_copy { ty::bound_copy }\n                   ast::bound_iface(t) {\n                     let ity = ast_ty_to_ty(tcx, mode, t);\n                     alt ty::struct(tcx, ity) {\n@@ -545,7 +545,7 @@ fn ast_ty_to_ty_crate_infer(ccx: @crate_ctxt, &&ast_ty: @ast::ty) ->\n }\n \n \n-// Functions that write types into the node type table.\n+// Functions that write types into the node type table\n mod write {\n     fn inner(ntt: node_type_table, node_id: ast::node_id,\n              tpot: ty_param_substs_opt_and_ty) {\n@@ -713,7 +713,7 @@ mod collect {\n                             compare_impl_method(cx.tcx, t.span, m,\n                                                 vec::len(tps), if_m, tys);\n                           }\n-                          none. {\n+                          none {\n                             cx.tcx.sess.span_err(t.span, \"missing method `\" +\n                                                  if_m.ident + \"`\");\n                           }\n@@ -773,7 +773,7 @@ mod collect {\n         // table.\n         let tpt = ty_of_native_item(cx.tcx, m_collect, i);\n         alt i.node {\n-          ast::native_item_ty. {\n+          ast::native_item_ty {\n             // FIXME: Native types have no annotation. Should they? --pcw\n           }\n           ast::native_item_fn(_, _) {\n@@ -975,17 +975,17 @@ mod writeback {\n         let new_ty =\n             alt resolve_type_vars_in_type(fcx, sp, tpot.ty) {\n               some(t) { t }\n-              none. { wbcx.success = false; ret }\n+              none { wbcx.success = false; ret }\n             };\n         let new_substs_opt;\n         alt tpot.substs {\n-          none. { new_substs_opt = none; }\n+          none { new_substs_opt = none; }\n           some(substs) {\n             let new_substs: [ty::t] = [];\n             for subst: ty::t in substs {\n                 alt resolve_type_vars_in_type(fcx, sp, subst) {\n                   some(t) { new_substs += [t]; }\n-                  none. { wbcx.success = false; ret; }\n+                  none { wbcx.success = false; ret; }\n                 }\n             }\n             new_substs_opt = some(new_substs);\n@@ -1095,7 +1095,7 @@ fn gather_locals(ccx: @crate_ctxt,\n                  old_fcx: option::t<@fn_ctxt>) -> gather_result {\n     let {vb: vb, locals: locals, nvi: nvi} =\n         alt old_fcx {\n-          none. {\n+          none {\n             {vb: ty::unify::mk_var_bindings(),\n              locals: new_int_hash::<int>(),\n              nvi: @mutable 0}\n@@ -1113,7 +1113,7 @@ fn gather_locals(ccx: @crate_ctxt,\n             let var_id = next_var_id();\n             locals.insert(nid, var_id);\n             alt ty_opt {\n-              none. {/* nothing to do */ }\n+              none {/* nothing to do */ }\n               some(typ) {\n                 ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n                                  ty::unify::in_bindings(vb), tcx);\n@@ -1171,7 +1171,7 @@ fn check_lit(ccx: @crate_ctxt, lit: @ast::lit) -> ty::t {\n       ast::lit_int(_, t) { ty::mk_mach_int(ccx.tcx, t) }\n       ast::lit_uint(_, t) { ty::mk_mach_uint(ccx.tcx, t) }\n       ast::lit_float(_, t) { ty::mk_mach_float(ccx.tcx, t) }\n-      ast::lit_nil. { ty::mk_nil(ccx.tcx) }\n+      ast::lit_nil { ty::mk_nil(ccx.tcx) }\n       ast::lit_bool(_) { ty::mk_bool(ccx.tcx) }\n     }\n }\n@@ -1185,7 +1185,7 @@ fn valid_range_bounds(from: @ast::expr, to: @ast::expr) -> bool {\n fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n              expected: ty::t) {\n     alt normalize_pat(fcx.ccx.tcx, pat).node {\n-      ast::pat_wild. {\n+      ast::pat_wild {\n           alt structure_of(fcx, pat.span, expected) {\n                   ty::ty_tag(_, expected_tps) {\n                       let path_tpt = {substs: some(expected_tps),\n@@ -1337,7 +1337,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         for f: ast::field_pat in fields {\n             alt vec::find(ex_fields, bind matches(f.ident, _)) {\n               some(field) { check_pat(fcx, map, f.pat, field.mt.ty); }\n-              none. {\n+              none {\n                 fcx.ccx.tcx.sess.span_fatal(pat.span,\n                                             #fmt[\"mismatched types: did not \\\n                                            expect a record with a field `%s`\",\n@@ -1402,7 +1402,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n \n fn require_unsafe(sess: session, f_purity: ast::purity, sp: span) {\n     alt f_purity {\n-      ast::unsafe_fn. { ret; }\n+      ast::unsafe_fn { ret; }\n       _ {\n         sess.span_err(\n             sp,\n@@ -1413,9 +1413,9 @@ fn require_unsafe(sess: session, f_purity: ast::purity, sp: span) {\n \n fn require_impure(sess: session, f_purity: ast::purity, sp: span) {\n     alt f_purity {\n-      ast::unsafe_fn. { ret; }\n-      ast::impure_fn. { ret; }\n-      ast::pure_fn. {\n+      ast::unsafe_fn { ret; }\n+      ast::impure_fn { ret; }\n+      ast::pure_fn {\n         sess.span_err(sp, \"Found impure expression in pure function decl\");\n       }\n     }\n@@ -1424,11 +1424,11 @@ fn require_impure(sess: session, f_purity: ast::purity, sp: span) {\n fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n                      callee: @ast::expr, sp: span) {\n     alt caller_purity {\n-      ast::unsafe_fn. { ret; }\n-      ast::impure_fn. {\n+      ast::unsafe_fn { ret; }\n+      ast::impure_fn {\n         alt ccx.tcx.def_map.find(callee.id) {\n-          some(ast::def_fn(_, ast::unsafe_fn.)) |\n-          some(ast::def_native_fn(_, ast::unsafe_fn.)) {\n+          some(ast::def_fn(_, ast::unsafe_fn)) |\n+          some(ast::def_native_fn(_, ast::unsafe_fn)) {\n             ccx.tcx.sess.span_err(\n                 sp,\n                 \"safe function calls function marked unsafe\");\n@@ -1438,10 +1438,10 @@ fn require_pure_call(ccx: @crate_ctxt, caller_purity: ast::purity,\n         }\n         ret;\n       }\n-      ast::pure_fn. {\n+      ast::pure_fn {\n         alt ccx.tcx.def_map.find(callee.id) {\n-          some(ast::def_fn(_, ast::pure_fn.)) |\n-          some(ast::def_native_fn(_, ast::pure_fn.)) |\n+          some(ast::def_fn(_, ast::pure_fn)) |\n+          some(ast::def_native_fn(_, ast::pure_fn)) |\n           some(ast::def_variant(_, _)) { ret; }\n           _ {\n             ccx.tcx.sess.span_err\n@@ -1677,7 +1677,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                                         arg_tys[i].ty);\n                         }\n                       }\n-                      none. { }\n+                      none { }\n                     }\n                     i += 1u;\n                 }\n@@ -1772,7 +1772,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 };\n                 (if_t, thn_bot & els_bot)\n               }\n-              none. {\n+              none {\n                 check_block_no_value(fcx, thn);\n                 (ty::mk_nil(fcx.ccx.tcx), false)\n               }\n@@ -1814,12 +1814,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n \n         let t =\n             alt binop {\n-              ast::eq. { ty::mk_bool(tcx) }\n-              ast::lt. { ty::mk_bool(tcx) }\n-              ast::le. { ty::mk_bool(tcx) }\n-              ast::ne. { ty::mk_bool(tcx) }\n-              ast::ge. { ty::mk_bool(tcx) }\n-              ast::gt. { ty::mk_bool(tcx) }\n+              ast::eq { ty::mk_bool(tcx) }\n+              ast::lt { ty::mk_bool(tcx) }\n+              ast::le { ty::mk_bool(tcx) }\n+              ast::ne { ty::mk_bool(tcx) }\n+              ast::ge { ty::mk_bool(tcx) }\n+              ast::gt { ty::mk_bool(tcx) }\n               _ { lhs_t }\n             };\n         write::ty_only_fixup(fcx, id, t);\n@@ -1832,7 +1832,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           ast::uniq(mut) {\n             oper_t = ty::mk_uniq(tcx, {ty: oper_t, mut: mut});\n           }\n-          ast::deref. {\n+          ast::deref {\n             alt structure_of(fcx, expr.span, oper_t) {\n               ty::ty_box(inner) { oper_t = inner.ty; }\n               ty::ty_uniq(inner) { oper_t = inner.ty; }\n@@ -1861,7 +1861,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               }\n             }\n           }\n-          ast::not. {\n+          ast::not {\n             if !type_is_integral(fcx, oper.span, oper_t) &&\n                    structure_of(fcx, oper.span, oper_t) != ty::ty_bool {\n                 tcx.sess.span_err(expr.span,\n@@ -1870,7 +1870,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                                        ty_to_str(tcx, oper_t)]);\n             }\n           }\n-          ast::neg. {\n+          ast::neg {\n             oper_t = structurally_resolved_type(fcx, oper.span, oper_t);\n             if !(ty::type_is_integral(tcx, oper_t) ||\n                      ty::type_is_fp(tcx, oper_t)) {\n@@ -1892,7 +1892,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             write::ty_fixup(fcx, id, path_tpot);\n         } else {\n             // The definition doesn't take type parameters. If the programmer\n-            // supplied some, that's an error.\n+            // supplied some, that's an error\n             if vec::len::<@ast::ty>(pth.node.types) > 0u {\n                 tcx.sess.span_fatal(expr.span,\n                                     \"this kind of value does not \\\n@@ -1905,17 +1905,17 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_fail(expr_opt) {\n         bot = true;\n         alt expr_opt {\n-          none. {/* do nothing */ }\n+          none {/* do nothing */ }\n           some(e) { check_expr_with(fcx, e, ty::mk_str(tcx)); }\n         }\n         write::bot_ty(tcx, id);\n       }\n-      ast::expr_break. { write::bot_ty(tcx, id); bot = true; }\n-      ast::expr_cont. { write::bot_ty(tcx, id); bot = true; }\n+      ast::expr_break { write::bot_ty(tcx, id); bot = true; }\n+      ast::expr_cont { write::bot_ty(tcx, id); bot = true; }\n       ast::expr_ret(expr_opt) {\n         bot = true;\n         alt expr_opt {\n-          none. {\n+          none {\n             let nil = ty::mk_nil(tcx);\n             if !are_compatible(fcx, fcx.ret_ty, nil) {\n                 tcx.sess.span_err(expr.span,\n@@ -1989,7 +1989,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let ety = expr_ty(tcx, seq);\n         alt structure_of(fcx, expr.span, ety) {\n           ty::ty_vec(vec_elt_ty) { elt_ty = vec_elt_ty.ty; }\n-          ty::ty_str. { elt_ty = ty::mk_mach_uint(tcx, ast::ty_u8); }\n+          ty::ty_str { elt_ty = ty::mk_mach_uint(tcx, ast::ty_u8); }\n           _ {\n             tcx.sess.span_fatal(expr.span,\n                                 \"mismatched types: expected vector or string \"\n@@ -2026,7 +2026,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         for arm: ast::arm in arms {\n             alt arm.guard {\n               some(e) { check_expr_with(fcx, e, ty::mk_bool(tcx)); }\n-              none. { }\n+              none { }\n             }\n             if !check_block(fcx, arm.body) { arm_non_bot = true; }\n             let bty = block_ty(tcx, arm.body);\n@@ -2065,7 +2065,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let typ =\n             alt b.node.expr {\n               some(expr) { expr_ty(tcx, expr) }\n-              none. { ty::mk_nil(tcx) }\n+              none { ty::mk_nil(tcx) }\n             };\n         write::ty_only_fixup(fcx, id, typ);\n       }\n@@ -2103,7 +2103,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         while i < vec::len(args) {\n             alt args[i] {\n               some(_) {/* no-op */ }\n-              none. { out_args += [arg_tys[i]]; }\n+              none { out_args += [arg_tys[i]]; }\n             }\n             i += 1u;\n         }\n@@ -2112,7 +2112,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         fn lower_bound_proto(proto: ast::proto) -> ast::proto {\n             // FIXME: This is right for bare fns, possibly not others\n             alt proto {\n-              ast::proto_bare. { ast::proto_box }\n+              ast::proto_bare { ast::proto_box }\n               _ { proto }\n             }\n         }\n@@ -2176,7 +2176,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {\n-        alt base { none. {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n+        alt base { none {/* no-op */ } some(b_0) { check_expr(fcx, b_0); } }\n         let fields_t: [spanned<field>] = [];\n         for f: ast::field in fields {\n             bot |= check_expr(fcx, f.node.expr);\n@@ -2189,7 +2189,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                         {ident: f.node.ident, mt: expr_mt})];\n         }\n         alt base {\n-          none. {\n+          none {\n             fn get_node(f: spanned<field>) -> field { f.node }\n             let typ = ty::mk_rec(tcx, vec::map(fields_t, get_node));\n             write::ty_only_fixup(fcx, id, typ);\n@@ -2279,7 +2279,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                 }\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n-              none. {\n+              none {\n                 let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n                                 no method implementation was found\",\n@@ -2303,7 +2303,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n           ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n-          ty::ty_str. {\n+          ty::ty_str {\n             let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n@@ -2427,7 +2427,7 @@ fn check_block(fcx0: @fn_ctxt, blk: ast::blk) -> bool {\n         bot |= check_stmt(fcx, s);\n     }\n     alt blk.node.expr {\n-      none. { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n+      none { write::nil_ty(fcx.ccx.tcx, blk.node.id); }\n       some(e) {\n         if bot && !warned {\n             fcx.ccx.tcx.sess.span_warn(e.span, \"unreachable expression\");\n@@ -2490,7 +2490,7 @@ fn check_tag_variants(ccx: @crate_ctxt, _sp: span, vs: [ast::variant],\n             // FIXME: issue #1417\n             // Also, check_expr (from check_const pass) doesn't guarantee that\n             // the expression in an form that eval_const_expr can handle, so\n-            // we may still get an internal compiler error.\n+            // we may still get an internal compiler error\n             alt syntax::ast_util::eval_const_expr(e) {\n               syntax::ast_util::const_int(val) {\n                 disr_val = val as int;\n@@ -2530,7 +2530,7 @@ fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n         alt operator.node {\n           ast::expr_path(oper_name) {\n             alt fcx.ccx.tcx.def_map.find(operator.id) {\n-              some(ast::def_fn(_, ast::pure_fn.)) {\n+              some(ast::def_fn(_, ast::pure_fn)) {\n                 // do nothing\n               }\n               _ {\n@@ -2577,7 +2577,7 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n                  that's my justification.\n                  */\n                  @alt a.node {\n-                    ast::carg_base. {\n+                    ast::carg_base {\n                       fcx.ccx.tcx.sess.span_bug(a.span,\n                                                 \"check_constraints:\\\n                     unexpected carg_base\");\n@@ -2630,7 +2630,7 @@ fn check_fn(ccx: @crate_ctxt,\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n     let purity = alt old_fcx {\n-      none. { decl.purity }\n+      none { decl.purity }\n       some(f) { assert decl.purity == ast::impure_fn; f.purity }\n     };\n \n@@ -2656,7 +2656,7 @@ fn check_fn(ccx: @crate_ctxt,\n         let tail_expr_ty = expr_ty(ccx.tcx, tail_expr);\n         demand::simple(fcx, tail_expr.span, fcx.ret_ty, tail_expr_ty);\n       }\n-      none. { }\n+      none { }\n     }\n \n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n@@ -2684,12 +2684,12 @@ fn check_native_fn(ccx: @crate_ctxt, decl: ast::fn_decl) {\n     let tys = vec::map(decl.inputs) {|a| a.ty };\n     for ty in (tys + [decl.output]) {\n         alt ty.node {\n-          ast::ty_int(ast::ty_i.) {\n+          ast::ty_int(ast::ty_i) {\n             ccx.tcx.sess.span_warn(\n                 ty.span, \"found rust type `int` in native module, while \" +\n                          \"ctypes::c_int or ctypes::long should be used\");\n           }\n-          ast::ty_uint(ast::ty_u.) {\n+          ast::ty_uint(ast::ty_u) {\n             ccx.tcx.sess.span_warn(\n                 ty.span, \"found rust type `uint` in native module, while \" +\n                          \"ctypes::c_uint or ctypes::ulong should be used\");\n@@ -2733,7 +2733,7 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n       ty::ty_vec(mt) {\n         if mt.mut != ast::imm { ret false; }\n         alt ty::struct(tcx, mt.ty) {\n-          ty::ty_str. { ret true; }\n+          ty::ty_str { ret true; }\n           _ { ret false; }\n         }\n       }\n@@ -2744,7 +2744,7 @@ fn arg_is_argv_ty(tcx: ty::ctxt, a: ty::arg) -> bool {\n fn check_main_fn_ty(tcx: ty::ctxt, main_id: ast::node_id) {\n     let main_t = ty::node_id_to_monotype(tcx, main_id);\n     alt ty::struct(tcx, main_t) {\n-      ty::ty_fn({proto: ast::proto_bare., inputs, output,\n+      ty::ty_fn({proto: ast::proto_bare, inputs, output,\n                  ret_style: ast::return_val., constraints}) {\n         let ok = vec::len(constraints) == 0u;\n         ok &= ty::type_is_nil(tcx, output);\n@@ -2771,7 +2771,7 @@ fn check_for_main_fn(tcx: ty::ctxt, crate: @ast::crate) {\n     if !tcx.sess.building_library {\n         alt tcx.sess.main_fn {\n           some(id) { check_main_fn_ty(tcx, id); }\n-          none. { tcx.sess.span_err(crate.span, \"main function not found\"); }\n+          none { tcx.sess.span_err(crate.span, \"main function not found\"); }\n         }\n     }\n }"}, {"sha": "7449d8a53f82e151679cfc08e1256b2dc8de483c", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -129,8 +129,8 @@ tag proto {\n \n pure fn is_blockish(p: ast::proto) -> bool {\n     alt p {\n-      proto_any. | proto_block. { true }\n-      proto_bare. | proto_uniq. | proto_box. { false }\n+      proto_any | proto_block { true }\n+      proto_bare | proto_uniq | proto_box { false }\n     }\n }\n "}, {"sha": "6e8de806348ee9698f8514030dd8457077fd034b", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -35,39 +35,39 @@ fn def_id_of_def(d: def) -> def_id {\n \n fn binop_to_str(op: binop) -> str {\n     alt op {\n-      add. { ret \"+\"; }\n-      subtract. { ret \"-\"; }\n-      mul. { ret \"*\"; }\n-      div. { ret \"/\"; }\n-      rem. { ret \"%\"; }\n-      and. { ret \"&&\"; }\n-      or. { ret \"||\"; }\n-      bitxor. { ret \"^\"; }\n-      bitand. { ret \"&\"; }\n-      bitor. { ret \"|\"; }\n-      lsl. { ret \"<<\"; }\n-      lsr. { ret \">>\"; }\n-      asr. { ret \">>>\"; }\n-      eq. { ret \"==\"; }\n-      lt. { ret \"<\"; }\n-      le. { ret \"<=\"; }\n-      ne. { ret \"!=\"; }\n-      ge. { ret \">=\"; }\n-      gt. { ret \">\"; }\n+      add { ret \"+\"; }\n+      subtract { ret \"-\"; }\n+      mul { ret \"*\"; }\n+      div { ret \"/\"; }\n+      rem { ret \"%\"; }\n+      and { ret \"&&\"; }\n+      or { ret \"||\"; }\n+      bitxor { ret \"^\"; }\n+      bitand { ret \"&\"; }\n+      bitor { ret \"|\"; }\n+      lsl { ret \"<<\"; }\n+      lsr { ret \">>\"; }\n+      asr { ret \">>>\"; }\n+      eq { ret \"==\"; }\n+      lt { ret \"<\"; }\n+      le { ret \"<=\"; }\n+      ne { ret \"!=\"; }\n+      ge { ret \">=\"; }\n+      gt { ret \">\"; }\n     }\n }\n \n pure fn lazy_binop(b: binop) -> bool {\n-    alt b { and. { true } or. { true } _ { false } }\n+    alt b { and { true } or { true } _ { false } }\n }\n \n fn unop_to_str(op: unop) -> str {\n     alt op {\n       box(mt) { if mt == mut { ret \"@mutable \"; } ret \"@\"; }\n       uniq(mt) { if mt == mut { ret \"~mutable \"; } ret \"~\"; }\n-      deref. { ret \"*\"; }\n-      not. { ret \"!\"; }\n-      neg. { ret \"-\"; }\n+      deref { ret \"*\"; }\n+      not { ret \"!\"; }\n+      neg { ret \"-\"; }\n     }\n }\n \n@@ -77,38 +77,38 @@ fn is_path(e: @expr) -> bool {\n \n fn int_ty_to_str(t: int_ty) -> str {\n     alt t {\n-      ty_i. { \"\" } ty_i8. { \"i8\" } ty_i16. { \"i16\" }\n-      ty_i32. { \"i32\" } ty_i64. { \"i64\" }\n+      ty_i { \"\" } ty_i8 { \"i8\" } ty_i16 { \"i16\" }\n+      ty_i32 { \"i32\" } ty_i64 { \"i64\" }\n     }\n }\n \n fn int_ty_max(t: int_ty) -> u64 {\n     alt t {\n-      ty_i8. { 0x80u64 }\n-      ty_i16. { 0x800u64 }\n-      ty_char. | ty_i32. { 0x80000000u64 }\n-      ty_i64. { 0x8000000000000000u64 }\n+      ty_i8 { 0x80u64 }\n+      ty_i16 { 0x800u64 }\n+      ty_char | ty_i32 { 0x80000000u64 }\n+      ty_i64 { 0x8000000000000000u64 }\n     }\n }\n \n fn uint_ty_to_str(t: uint_ty) -> str {\n     alt t {\n-      ty_u. { \"u\" } ty_u8. { \"u8\" } ty_u16. { \"u16\" }\n-      ty_u32. { \"u32\" } ty_u64. { \"u64\" }\n+      ty_u { \"u\" } ty_u8 { \"u8\" } ty_u16 { \"u16\" }\n+      ty_u32 { \"u32\" } ty_u64 { \"u64\" }\n     }\n }\n \n fn uint_ty_max(t: uint_ty) -> u64 {\n     alt t {\n-      ty_u8. { 0xffu64 }\n-      ty_u16. { 0xffffu64 }\n-      ty_u32. { 0xffffffffu64 }\n-      ty_u64. { 0xffffffffffffffffu64 }\n+      ty_u8 { 0xffu64 }\n+      ty_u16 { 0xffffu64 }\n+      ty_u32 { 0xffffffffu64 }\n+      ty_u64 { 0xffffffffffffffffu64 }\n     }\n }\n \n fn float_ty_to_str(t: float_ty) -> str {\n-    alt t { ty_f. { \"\" } ty_f32. { \"f32\" } ty_f64. { \"f64\" } }\n+    alt t { ty_f { \"\" } ty_f32 { \"f32\" } ty_f64 { \"f64\" } }\n }\n \n fn is_exported(i: ident, m: _mod) -> bool {\n@@ -212,14 +212,14 @@ tag const_val {\n fn eval_const_expr(e: @expr) -> const_val {\n     fn fromb(b: bool) -> const_val { const_int(b as i64) }\n     alt e.node {\n-      expr_unary(neg., inner) {\n+      expr_unary(neg, inner) {\n         alt eval_const_expr(inner) {\n           const_float(f) { const_float(-f) }\n           const_int(i) { const_int(-i) }\n           const_uint(i) { const_uint(-i) }\n         }\n       }\n-      expr_unary(not., inner) {\n+      expr_unary(not, inner) {\n         alt eval_const_expr(inner) {\n           const_int(i) { const_int(!i) }\n           const_uint(i) { const_uint(!i) }\n@@ -229,33 +229,33 @@ fn eval_const_expr(e: @expr) -> const_val {\n         alt (eval_const_expr(a), eval_const_expr(b)) {\n           (const_float(a), const_float(b)) {\n             alt op {\n-              add. { const_float(a + b) } subtract. { const_float(a - b) }\n-              mul. { const_float(a * b) } div. { const_float(a / b) }\n-              rem. { const_float(a % b) } eq. { fromb(a == b) }\n-              lt. { fromb(a < b) } le. { fromb(a <= b) } ne. { fromb(a != b) }\n-              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+              add { const_float(a + b) } subtract { const_float(a - b) }\n+              mul { const_float(a * b) } div { const_float(a / b) }\n+              rem { const_float(a % b) } eq { fromb(a == b) }\n+              lt { fromb(a < b) } le { fromb(a <= b) } ne { fromb(a != b) }\n+              ge { fromb(a >= b) } gt { fromb(a > b) }\n             }\n           }\n           (const_int(a), const_int(b)) {\n             alt op {\n-              add. { const_int(a + b) } subtract. { const_int(a - b) }\n-              mul. { const_int(a * b) } div. { const_int(a / b) }\n-              rem. { const_int(a % b) } and. | bitand. { const_int(a & b) }\n-              or. | bitor. { const_int(a | b) } bitxor. { const_int(a ^ b) }\n-              eq. { fromb(a == b) } lt. { fromb(a < b) }\n-              le. { fromb(a <= b) } ne. { fromb(a != b) }\n-              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+              add { const_int(a + b) } subtract { const_int(a - b) }\n+              mul { const_int(a * b) } div { const_int(a / b) }\n+              rem { const_int(a % b) } and | bitand { const_int(a & b) }\n+              or | bitor { const_int(a | b) } bitxor { const_int(a ^ b) }\n+              eq { fromb(a == b) } lt { fromb(a < b) }\n+              le { fromb(a <= b) } ne { fromb(a != b) }\n+              ge { fromb(a >= b) } gt { fromb(a > b) }\n             }\n           }\n           (const_uint(a), const_uint(b)) {\n             alt op {\n-              add. { const_uint(a + b) } subtract. { const_uint(a - b) }\n-              mul. { const_uint(a * b) } div. { const_uint(a / b) }\n-              rem. { const_uint(a % b) } and. | bitand. { const_uint(a & b) }\n-              or. | bitor. { const_uint(a | b) } bitxor. { const_uint(a ^ b) }\n-              eq. { fromb(a == b) } lt. { fromb(a < b) }\n-              le. { fromb(a <= b) } ne. { fromb(a != b) }\n-              ge. { fromb(a >= b) } gt. { fromb(a > b) }\n+              add { const_uint(a + b) } subtract { const_uint(a - b) }\n+              mul { const_uint(a * b) } div { const_uint(a / b) }\n+              rem { const_uint(a % b) } and | bitand { const_uint(a & b) }\n+              or | bitor { const_uint(a | b) } bitxor { const_uint(a ^ b) }\n+              eq { fromb(a == b) } lt { fromb(a < b) }\n+              le { fromb(a <= b) } ne { fromb(a != b) }\n+              ge { fromb(a >= b) } gt { fromb(a > b) }\n             }\n           }\n         }\n@@ -270,7 +270,7 @@ fn lit_to_const(lit: @lit) -> const_val {\n       lit_int(n, _) { const_int(n) }\n       lit_uint(n, _) { const_uint(n) }\n       lit_float(n, _) { const_float(float::from_str(n)) }\n-      lit_nil. { const_int(0i64) }\n+      lit_nil { const_int(0i64) }\n       lit_bool(b) { const_int(b as i64) }\n     }\n }"}, {"sha": "3bedf018eb711c708d253d6b716e3c82864bbe00", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -86,7 +86,7 @@ fn span_to_str(sp: span, cm: codemap) -> str {\n                      \"-\"\n                  } else { lo.filename }, lo.line, lo.col, hi.line, hi.col];\n         alt cur.expanded_from {\n-          os_none. { break; }\n+          os_none { break; }\n           os_some(new_sp) {\n             cur = *new_sp;\n             prev_file = some(lo.filename);"}, {"sha": "e5d80c3f314fe9c898963ef5936e7802baa308c0", "filename": "src/comp/syntax/ext/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fenv.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -26,7 +26,7 @@ fn expand_syntax_ext(cx: ext_ctxt, sp: codemap::span, arg: @ast::expr,\n \n     let var = expr_to_str(cx, args[0], \"#env requires a string\");\n     alt generic_os::getenv(var) {\n-      option::none. { ret make_new_str(cx, sp, \"\"); }\n+      option::none { ret make_new_str(cx, sp, \"\"); }\n       option::some(s) { ret make_new_str(cx, sp, s); }\n     }\n }"}, {"sha": "09748a3168ef0f348b5e627a5098143e63ea9281", "filename": "src/comp/syntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fexpand.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -19,7 +19,7 @@ fn expand_expr(exts: hashmap<str, syntax_extension>, cx: ext_ctxt, e: expr_,\n                 assert (vec::len(pth.node.idents) > 0u);\n                 let extname = pth.node.idents[0];\n                 alt exts.find(extname) {\n-                  none. {\n+                  none {\n                     cx.span_fatal(pth.span,\n                                   #fmt[\"macro undefined: '%s'\", extname])\n                   }"}, {"sha": "5b57923e3088bdddb4f7c164eefcecd0fd2450b1", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -112,11 +112,11 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             for f: flag in flags {\n                 let fstr;\n                 alt f {\n-                  flag_left_justify. { fstr = \"flag_left_justify\"; }\n-                  flag_left_zero_pad. { fstr = \"flag_left_zero_pad\"; }\n-                  flag_space_for_sign. { fstr = \"flag_space_for_sign\"; }\n-                  flag_sign_always. { fstr = \"flag_sign_always\"; }\n-                  flag_alternate. { fstr = \"flag_alternate\"; }\n+                  flag_left_justify { fstr = \"flag_left_justify\"; }\n+                  flag_left_zero_pad { fstr = \"flag_left_zero_pad\"; }\n+                  flag_space_for_sign { fstr = \"flag_space_for_sign\"; }\n+                  flag_sign_always { fstr = \"flag_sign_always\"; }\n+                  flag_alternate { fstr = \"flag_alternate\"; }\n                 }\n                 flagexprs += [make_rt_path_expr(cx, sp, fstr)];\n             }\n@@ -131,7 +131,7 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         }\n         fn make_count(cx: ext_ctxt, sp: span, cnt: count) -> @ast::expr {\n             alt cnt {\n-              count_implied. {\n+              count_implied {\n                 ret make_rt_path_expr(cx, sp, \"count_implied\");\n               }\n               count_is(c) {\n@@ -148,12 +148,12 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             alt t {\n               ty_hex(c) {\n                 alt c {\n-                  case_upper. { rt_type = \"ty_hex_upper\"; }\n-                  case_lower. { rt_type = \"ty_hex_lower\"; }\n+                  case_upper { rt_type = \"ty_hex_upper\"; }\n+                  case_lower { rt_type = \"ty_hex_lower\"; }\n                 }\n               }\n-              ty_bits. { rt_type = \"ty_bits\"; }\n-              ty_octal. { rt_type = \"ty_octal\"; }\n+              ty_bits { rt_type = \"ty_bits\"; }\n+              ty_octal { rt_type = \"ty_octal\"; }\n               _ { rt_type = \"ty_default\"; }\n             }\n             ret make_rt_path_expr(cx, sp, rt_type);\n@@ -189,65 +189,65 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         fn is_signed_type(cnv: conv) -> bool {\n             alt cnv.ty {\n               ty_int(s) {\n-                alt s { signed. { ret true; } unsigned. { ret false; } }\n+                alt s { signed { ret true; } unsigned { ret false; } }\n               }\n-              ty_float. { ret true; }\n+              ty_float { ret true; }\n               _ { ret false; }\n             }\n         }\n         let unsupported = \"conversion not supported in #fmt string\";\n         alt cnv.param {\n-          option::none. { }\n+          option::none { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         for f: flag in cnv.flags {\n             alt f {\n-              flag_left_justify. { }\n-              flag_sign_always. {\n+              flag_left_justify { }\n+              flag_sign_always {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   \"+ flag only valid in \" +\n                                       \"signed #fmt conversion\");\n                 }\n               }\n-              flag_space_for_sign. {\n+              flag_space_for_sign {\n                 if !is_signed_type(cnv) {\n                     cx.span_fatal(sp,\n                                   \"space flag only valid in \" +\n                                       \"signed #fmt conversions\");\n                 }\n               }\n-              flag_left_zero_pad. { }\n+              flag_left_zero_pad { }\n               _ { cx.span_unimpl(sp, unsupported); }\n             }\n         }\n         alt cnv.width {\n-          count_implied. { }\n+          count_implied { }\n           count_is(_) { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.precision {\n-          count_implied. { }\n+          count_implied { }\n           count_is(_) { }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n         alt cnv.ty {\n-          ty_str. { ret make_conv_call(cx, arg.span, \"str\", cnv, arg); }\n+          ty_str { ret make_conv_call(cx, arg.span, \"str\", cnv, arg); }\n           ty_int(sign) {\n             alt sign {\n-              signed. { ret make_conv_call(cx, arg.span, \"int\", cnv, arg); }\n-              unsigned. {\n+              signed { ret make_conv_call(cx, arg.span, \"int\", cnv, arg); }\n+              unsigned {\n                 ret make_conv_call(cx, arg.span, \"uint\", cnv, arg);\n               }\n             }\n           }\n-          ty_bool. { ret make_conv_call(cx, arg.span, \"bool\", cnv, arg); }\n-          ty_char. { ret make_conv_call(cx, arg.span, \"char\", cnv, arg); }\n+          ty_bool { ret make_conv_call(cx, arg.span, \"bool\", cnv, arg); }\n+          ty_char { ret make_conv_call(cx, arg.span, \"char\", cnv, arg); }\n           ty_hex(_) { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_bits. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_octal. { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n-          ty_float. { ret make_conv_call(cx, arg.span, \"float\", cnv, arg); }\n-          ty_poly. { ret make_conv_call(cx, arg.span, \"poly\", cnv, arg); }\n+          ty_bits { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n+          ty_octal { ret make_conv_call(cx, arg.span, \"uint\", cnv, arg); }\n+          ty_float { ret make_conv_call(cx, arg.span, \"float\", cnv, arg); }\n+          ty_poly { ret make_conv_call(cx, arg.span, \"poly\", cnv, arg); }\n           _ { cx.span_unimpl(sp, unsupported); }\n         }\n     }\n@@ -258,11 +258,11 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n         }\n         for f: flag in c.flags {\n             alt f {\n-              flag_left_justify. { #debug(\"flag: left justify\"); }\n-              flag_left_zero_pad. { #debug(\"flag: left zero pad\"); }\n-              flag_space_for_sign. { #debug(\"flag: left space pad\"); }\n-              flag_sign_always. { #debug(\"flag: sign always\"); }\n-              flag_alternate. { #debug(\"flag: alternate\"); }\n+              flag_left_justify { #debug(\"flag: left justify\"); }\n+              flag_left_zero_pad { #debug(\"flag: left zero pad\"); }\n+              flag_space_for_sign { #debug(\"flag: left space pad\"); }\n+              flag_sign_always { #debug(\"flag: sign always\"); }\n+              flag_alternate { #debug(\"flag: alternate\"); }\n             }\n         }\n         alt c.width {\n@@ -272,8 +272,8 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             log(debug,\n                      \"width: count is param \" + int::to_str(i, 10u));\n           }\n-          count_is_next_param. { #debug(\"width: count is next param\"); }\n-          count_implied. { #debug(\"width: count is implied\"); }\n+          count_is_next_param { #debug(\"width: count is next param\"); }\n+          count_implied { #debug(\"width: count is implied\"); }\n         }\n         alt c.precision {\n           count_is(i) { log(debug,\n@@ -282,29 +282,29 @@ fn pieces_to_expr(cx: ext_ctxt, sp: span, pieces: [piece], args: [@ast::expr])\n             log(debug,\n                      \"prec: count is param \" + int::to_str(i, 10u));\n           }\n-          count_is_next_param. { #debug(\"prec: count is next param\"); }\n-          count_implied. { #debug(\"prec: count is implied\"); }\n+          count_is_next_param { #debug(\"prec: count is next param\"); }\n+          count_implied { #debug(\"prec: count is implied\"); }\n         }\n         alt c.ty {\n-          ty_bool. { #debug(\"type: bool\"); }\n-          ty_str. { #debug(\"type: str\"); }\n-          ty_char. { #debug(\"type: char\"); }\n+          ty_bool { #debug(\"type: bool\"); }\n+          ty_str { #debug(\"type: str\"); }\n+          ty_char { #debug(\"type: char\"); }\n           ty_int(s) {\n             alt s {\n-              signed. { #debug(\"type: signed\"); }\n-              unsigned. { #debug(\"type: unsigned\"); }\n+              signed { #debug(\"type: signed\"); }\n+              unsigned { #debug(\"type: unsigned\"); }\n             }\n           }\n-          ty_bits. { #debug(\"type: bits\"); }\n+          ty_bits { #debug(\"type: bits\"); }\n           ty_hex(cs) {\n             alt cs {\n-              case_upper. { #debug(\"type: uhex\"); }\n-              case_lower. { #debug(\"type: lhex\"); }\n+              case_upper { #debug(\"type: uhex\"); }\n+              case_lower { #debug(\"type: lhex\"); }\n             }\n           }\n-          ty_octal. { #debug(\"type: octal\"); }\n-          ty_float. { #debug(\"type: float\"); }\n-          ty_poly. { #debug(\"type: poly\"); }\n+          ty_octal { #debug(\"type: octal\"); }\n+          ty_float { #debug(\"type: float\"); }\n+          ty_poly { #debug(\"type: poly\"); }\n         }\n     }\n     let fmt_sp = args[0].span;"}, {"sha": "a71bb650f3ccfd3b801b59c86f050d282b5b105d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -60,7 +60,7 @@ fn match_error(cx: ext_ctxt, m: matchable, expected: str) -> ! {\n         cx.span_fatal(x.span,\n                       \"this argument is a block, expected \" + expected);\n       }\n-      match_exact. { cx.bug(\"what is a match_exact doing in a bindings?\"); }\n+      match_exact { cx.bug(\"what is a match_exact doing in a bindings?\"); }\n     }\n }\n \n@@ -81,7 +81,7 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n         alt elt.node {\n           expr_mac(m) {\n             alt m.node {\n-              ast::mac_ellipsis. {\n+              ast::mac_ellipsis {\n                 if res != none {\n                     cx.span_fatal(m.span, \"only one ellipsis allowed\");\n                 }\n@@ -99,15 +99,15 @@ fn elts_to_ell(cx: ext_ctxt, elts: [@expr]) ->\n     }\n     ret alt res {\n           some(val) { val }\n-          none. { {pre: elts, rep: none, post: []} }\n+          none { {pre: elts, rep: none, post: []} }\n         }\n }\n \n fn option_flatten_map<T: copy, U: copy>(f: fn@(T) -> option::t<U>, v: [T]) ->\n    option::t<[U]> {\n     let res = [];\n     for elem: T in v {\n-        alt f(elem) { none. { ret none; } some(fv) { res += [fv]; } }\n+        alt f(elem) { none { ret none; } some(fv) { res += [fv]; } }\n     }\n     ret some(res);\n }\n@@ -117,7 +117,7 @@ fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n       leaf(x) { ret f(x); }\n       seq(ads, span) {\n         alt option_flatten_map(bind a_d_map(_, f), *ads) {\n-          none. { ret none; }\n+          none { ret none; }\n           some(ts) { ret some(seq(@ts, span)); }\n         }\n       }\n@@ -127,7 +127,7 @@ fn a_d_map(ad: arb_depth<matchable>, f: selector) -> match_result {\n fn compose_sels(s1: selector, s2: selector) -> selector {\n     fn scomp(s1: selector, s2: selector, m: matchable) -> match_result {\n         ret alt s1(m) {\n-              none. { none }\n+              none { none }\n               some(matches) { a_d_map(matches, s2) }\n             }\n     }\n@@ -168,12 +168,12 @@ fn use_selectors_to_bind(b: binders, e: @expr) -> option::t<bindings> {\n     let res = new_str_hash::<arb_depth<matchable>>();\n     //need to do this first, to check vec lengths.\n     for sel: selector in b.literal_ast_matchers {\n-        alt sel(match_expr(e)) { none. { ret none; } _ { } }\n+        alt sel(match_expr(e)) { none { ret none; } _ { } }\n     }\n     let never_mind: bool = false;\n     b.real_binders.items {|key, val|\n         alt val(match_expr(e)) {\n-          none. { never_mind = true; }\n+          none { never_mind = true; }\n           some(mtc) { res.insert(key, mtc); }\n         }\n     };\n@@ -226,7 +226,7 @@ fn follow(m: arb_depth<matchable>, idx_path: @mutable [uint]) ->\n fn follow_for_trans(cx: ext_ctxt, mmaybe: option::t<arb_depth<matchable>>,\n                     idx_path: @mutable [uint]) -> option::t<matchable> {\n     alt mmaybe {\n-      none. { ret none }\n+      none { ret none }\n       some(m) {\n         ret alt follow(m, idx_path) {\n               seq(_, sp) {\n@@ -267,7 +267,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n       {pre: pre, rep: repeat_me_maybe, post: post} {\n         let res = vec::map(pre, recur);\n         alt repeat_me_maybe {\n-          none. { }\n+          none { }\n           some(repeat_me) {\n             let repeat: option::t<{rep_count: uint, name: ident}> = none;\n             /* we need to walk over all the free vars in lockstep, except for\n@@ -278,7 +278,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                   leaf(_) { }\n                   seq(ms, _) {\n                     alt repeat {\n-                      none. {\n+                      none {\n                         repeat = some({rep_count: vec::len(*ms), name: fv});\n                       }\n                       some({rep_count: old_len, name: old_name}) {\n@@ -296,7 +296,7 @@ fn transcribe_exprs(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                 }\n             };\n             alt repeat {\n-              none. {\n+              none {\n                 cx.span_fatal(repeat_me.span,\n                               \"'...' surrounds an expression without any\" +\n                                   \" repeating syntax variables\");\n@@ -328,7 +328,7 @@ fn transcribe_ident(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n     ret alt follow_for_trans(cx, b.find(i), idx_path) {\n           some(match_ident(a_id)) { a_id.node }\n           some(m) { match_error(cx, m, \"an identifier\") }\n-          none. { i }\n+          none { i }\n         }\n }\n \n@@ -343,7 +343,7 @@ fn transcribe_path(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n           }\n           some(match_path(a_pth)) { a_pth.node }\n           some(m) { match_error(cx, m, \"a path\") }\n-          none. { p }\n+          none { p }\n         }\n }\n \n@@ -368,7 +368,7 @@ fn transcribe_expr(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n               some(match_path(a_pth)) { expr_path(a_pth) }\n               some(match_expr(a_exp)) { a_exp.node }\n               some(m) { match_error(cx, m, \"an expression\") }\n-              none. { orig(e, fld) }\n+              none { orig(e, fld) }\n             }\n           }\n           _ { orig(e, fld) }\n@@ -385,10 +385,10 @@ fn transcribe_type(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n                 alt follow_for_trans(cx, b.find(id), idx_path) {\n                   some(match_ty(ty)) { ty.node }\n                   some(m) { match_error(cx, m, \"a type\") }\n-                  none. { orig(t, fld) }\n+                  none { orig(t, fld) }\n                 }\n               }\n-              none. { orig(t, fld) }\n+              none { orig(t, fld) }\n             }\n           }\n           _ { orig(t, fld) }\n@@ -415,10 +415,10 @@ fn transcribe_block(cx: ext_ctxt, b: bindings, idx_path: @mutable [uint],\n               some(m) {\n                 match_error(cx, m, \"a block\")\n               }\n-              none. { orig(blk, fld) }\n+              none { orig(blk, fld) }\n             }\n           }\n-          none. { orig(blk, fld) }\n+          none { orig(blk, fld) }\n         }\n }\n \n@@ -447,7 +447,7 @@ fn p_t_s_rec(cx: ext_ctxt, m: matchable, s: selector, b: binders) {\n                                    \"matching after `...` not yet supported\");\n                 }\n               }\n-              {pre: pre, rep: none., post: post} {\n+              {pre: pre, rep: none, post: post} {\n                 if post != [] {\n                     cx.bug(\"elts_to_ell provided an invalid result\");\n                 }\n@@ -491,7 +491,7 @@ fn specialize_match(m: matchable) -> matchable {\n               expr_path(pth) {\n                 alt path_to_ident(pth) {\n                   some(id) { match_ident(respan(pth.span, id)) }\n-                  none. { match_path(pth) }\n+                  none { match_path(pth) }\n                 }\n               }\n               _ { m }\n@@ -516,7 +516,7 @@ fn p_t_s_r_path(cx: ext_ctxt, p: @path, s: selector, b: binders) {\n         }\n         b.real_binders.insert(p_id, compose_sels(s, bind select(cx, _)));\n       }\n-      none. { }\n+      none { }\n     }\n }\n \n@@ -526,7 +526,7 @@ fn block_to_ident(blk: blk_) -> option::t<ident> {\n           some(expr) {\n             alt expr.node { expr_path(pth) { path_to_ident(pth) } _ { none } }\n           }\n-          none. { none }\n+          none { none }\n         }\n }\n \n@@ -544,7 +544,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n         cx.span_fatal(sp, \"destructuring \" + syn + \" is not yet supported\");\n     }\n     alt mac.node {\n-      ast::mac_ellipsis. { cx.span_fatal(mac.span, \"misused `...`\"); }\n+      ast::mac_ellipsis { cx.span_fatal(mac.span, \"misused `...`\"); }\n       ast::mac_invoc(_, _, _) { no_des(cx, mac.span, \"macro calls\"); }\n       ast::mac_embed_type(ty) {\n         alt ty.node {\n@@ -561,7 +561,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n                 let final_step = bind select_pt_1(cx, _, select_pt_2);\n                 b.real_binders.insert(id, compose_sels(s, final_step));\n               }\n-              none. { no_des(cx, pth.span, \"under `#<>`\"); }\n+              none { no_des(cx, pth.span, \"under `#<>`\"); }\n             }\n           }\n           _ { no_des(cx, ty.span, \"under `#<>`\"); }\n@@ -581,7 +581,7 @@ fn p_t_s_r_mac(cx: ext_ctxt, mac: ast::mac, s: selector, b: binders) {\n             let final_step = bind select_pt_1(cx, _, select_pt_2);\n             b.real_binders.insert(id, compose_sels(s, final_step));\n           }\n-          none. { no_des(cx, blk.span, \"under `#{}`\"); }\n+          none { no_des(cx, blk.span, \"under `#{}`\"); }\n         }\n       }\n     }\n@@ -693,7 +693,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n                     alt path_to_ident(pth) {\n                       some(id) {\n                         alt macro_name {\n-                          none. { macro_name = some(id); }\n+                          none { macro_name = some(id); }\n                           some(other_id) {\n                             if id != other_id {\n                                 cx.span_fatal(pth.span,\n@@ -703,7 +703,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n                           }\n                         }\n                       }\n-                      none. {\n+                      none {\n                         cx.span_fatal(pth.span,\n                                       \"macro name must not be a path\");\n                       }\n@@ -735,7 +735,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n     ret {ident:\n              alt macro_name {\n                some(id) { id }\n-               none. {\n+               none {\n                  cx.span_fatal(sp,\n                                \"macro definition must have \" +\n                                    \"at least one clause\")\n@@ -748,7 +748,7 @@ fn add_new_extension(cx: ext_ctxt, sp: span, arg: @expr,\n         for c: @clause in clauses {\n             alt use_selectors_to_bind(c.params, arg) {\n               some(bindings) { ret transcribe(cx, bindings, c.body); }\n-              none. { cont; }\n+              none { cont; }\n             }\n         }\n         cx.span_fatal(sp, \"no clauses match macro invocation\");"}, {"sha": "980950cf545ef052198698379840f67ceffb7124", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -137,7 +137,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n                }\n                mac_embed_type(ty) { mac_embed_type(fld.fold_ty(ty)) }\n                mac_embed_block(blk) { mac_embed_block(fld.fold_block(blk)) }\n-               mac_ellipsis. { mac_ellipsis }\n+               mac_ellipsis { mac_ellipsis }\n              },\n          span: m.span};\n }\n@@ -189,7 +189,7 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n           attrs: vec::map(ni.attrs, fold_attribute),\n           node:\n               alt ni.node {\n-                native_item_ty. { native_item_ty }\n+                native_item_ty { native_item_ty }\n                 native_item_fn(fdec, typms) {\n                   native_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n@@ -273,7 +273,7 @@ fn noop_fold_arm(a: arm, fld: ast_fold) -> arm {\n \n fn noop_fold_pat(p: pat_, fld: ast_fold) -> pat_ {\n     ret alt p {\n-          pat_wild. { p }\n+          pat_wild { p }\n           pat_ident(pth, sub) {\n             pat_ident(fld.fold_path(pth), option::map(sub, fld.fold_pat))\n           }\n@@ -391,7 +391,7 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           }\n           expr_path(pth) { expr_path(fld.fold_path(pth)) }\n           expr_fail(e) { expr_fail(option::map(e, fld.fold_expr)) }\n-          expr_break. | expr_cont. { e }\n+          expr_break | expr_cont { e }\n           expr_ret(e) { expr_ret(option::map(e, fld.fold_expr)) }\n           expr_be(e) { expr_be(fld.fold_expr(e)) }\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n@@ -434,7 +434,7 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n     let args = vec::map(v.args, fold_variant_arg);\n     let de = alt v.disr_expr {\n       some(e) {some(fld.fold_expr(e))}\n-      none. {none}\n+      none {none}\n     };\n     ret {name: v.name, args: args, id: v.id,\n          disr_expr: de};"}, {"sha": "897cfe03e09d3c6e82ce1ac7cea72539db509d21", "filename": "src/comp/syntax/parse/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Feval.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -58,7 +58,7 @@ fn parse_companion_mod(cx: ctx, prefix: str, suffix: option::t<str>)\n     fn companion_file(prefix: str, suffix: option::t<str>) -> str {\n         ret alt suffix {\n           option::some(s) { fs::connect(prefix, s) }\n-          option::none. { prefix }\n+          option::none { prefix }\n         } + \".rs\";\n     }\n \n@@ -93,7 +93,7 @@ fn cdir_path_opt(id: str, attrs: [ast::attribute]) -> str {\n       some(d) {\n         ret d;\n       }\n-      none. { ret id; }\n+      none { ret id; }\n     }\n }\n "}, {"sha": "176e70cc65a9e8669f96c355b384b7ebaec15e00", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -240,7 +240,7 @@ fn scan_number(c: char, rdr: reader) -> token::token {\n         is_float = true;\n         num_str += s;\n       }\n-      none. {}\n+      none {}\n     }\n     if rdr.curr == 'f' {\n         rdr.bump();"}, {"sha": "7515a393ee9e90ec742cfe8e0553da6d1a836fca", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -489,7 +489,7 @@ fn parse_ty(p: parser, colons_before_params: bool) -> @ast::ty {\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n-          ast::proto_bare. { p.warn(\"fn is deprecated, use native fn\"); }\n+          ast::proto_bare { p.warn(\"fn is deprecated, use native fn\"); }\n           _ { /* fallthrough */ }\n         }\n         t = parse_ty_fn(proto, p);\n@@ -625,7 +625,7 @@ fn lit_from_token(p: parser, tok: token::token) -> ast::lit_ {\n       token::LIT_UINT(u, ut) { ast::lit_uint(u, ut) }\n       token::LIT_FLOAT(s, ft) { ast::lit_float(p.get_str(s), ft) }\n       token::LIT_STR(s) { ast::lit_str(p.get_str(s)) }\n-      token::LPAREN. { expect(p, token::RPAREN); ast::lit_nil }\n+      token::LPAREN { expect(p, token::RPAREN); ast::lit_nil }\n       _ { unexpected(p, tok); }\n     }\n }\n@@ -703,7 +703,7 @@ fn mk_mac_expr(p: parser, lo: uint, hi: uint, m: ast::mac_) -> @ast::expr {\n }\n \n fn is_bar(t: token::token) -> bool {\n-    alt t { token::BINOP(token::OR.) | token::OROR. { true } _ { false } }\n+    alt t { token::BINOP(token::OR) | token::OROR { true } _ { false } }\n }\n \n fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n@@ -797,8 +797,8 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n     } else if eat_word(p, \"fn\") {\n         let proto = parse_fn_ty_proto(p);\n         alt proto {\n-          ast::proto_bare. { p.fatal(\"fn expr are deprecated, use fn@\"); }\n-          ast::proto_any. { p.fatal(\"fn* cannot be used in an expression\"); }\n+          ast::proto_bare { p.fatal(\"fn expr are deprecated, use fn@\"); }\n+          ast::proto_any { p.fatal(\"fn* cannot be used in an expression\"); }\n           _ { /* fallthrough */ }\n         }\n         ret pexpr(parse_fn_expr(p, proto));\n@@ -836,7 +836,7 @@ fn parse_bottom_expr(p: parser) -> pexpr {\n         let e = parse_expr_res(p, RESTRICT_NO_CALL_EXPRS);\n         fn parse_expr_opt(p: parser) -> option::t<@ast::expr> {\n             alt p.token {\n-              token::UNDERSCORE. { p.bump(); ret none; }\n+              token::UNDERSCORE { p.bump(); ret none; }\n               _ { ret some(parse_expr(p)); }\n             }\n         }\n@@ -971,7 +971,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n     while !expr_is_complete(p, e) {\n         alt p.token {\n           // expr(...)\n-          token::LPAREN. if permits_call(p) {\n+          token::LPAREN if permits_call(p) {\n             let es = parse_seq(token::LPAREN, token::RPAREN,\n                                seq_sep(token::COMMA), parse_expr, p);\n             hi = es.span.hi;\n@@ -980,7 +980,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n           }\n \n           // expr {|| ... }\n-          token::LBRACE. if is_bar(p.look_ahead(1u)) && permits_call(p) {\n+          token::LBRACE if is_bar(p.look_ahead(1u)) && permits_call(p) {\n             p.bump();\n             let blk = parse_fn_block_expr(p);\n             alt e.node {\n@@ -996,7 +996,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n           }\n \n           // expr[...]\n-          token::LBRACKET. {\n+          token::LBRACKET {\n             p.bump();\n             let ix = parse_expr(p);\n             hi = ix.span.hi;\n@@ -1005,7 +1005,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n           }\n \n           // expr.f\n-          token::DOT. {\n+          token::DOT {\n             p.bump();\n             alt p.token {\n               token::IDENT(i, _) {\n@@ -1037,21 +1037,21 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n \n     let ex;\n     alt p.token {\n-      token::NOT. {\n+      token::NOT {\n         p.bump();\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         ex = ast::expr_unary(ast::not, e);\n       }\n       token::BINOP(b) {\n         alt b {\n-          token::MINUS. {\n+          token::MINUS {\n             p.bump();\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n             ex = ast::expr_unary(ast::neg, e);\n           }\n-          token::STAR. {\n+          token::STAR {\n             p.bump();\n             let e = to_expr(parse_prefix_expr(p));\n             hi = e.span.hi;\n@@ -1060,14 +1060,14 @@ fn parse_prefix_expr(p: parser) -> pexpr {\n           _ { ret parse_dot_or_call_expr(p); }\n         }\n       }\n-      token::AT. {\n+      token::AT {\n         p.bump();\n         let m = parse_mutability(p);\n         let e = to_expr(parse_prefix_expr(p));\n         hi = e.span.hi;\n         ex = ast::expr_unary(ast::box(m), e);\n       }\n-      token::TILDE. {\n+      token::TILDE {\n         p.bump();\n         let m = parse_mutability(p);\n         let e = to_expr(parse_prefix_expr(p));\n@@ -1157,7 +1157,7 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n     let lo = p.span.lo;\n     let lhs = parse_ternary(p);\n     alt p.token {\n-      token::EQ. {\n+      token::EQ {\n         p.bump();\n         let rhs = parse_expr(p);\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign(lhs, rhs));\n@@ -1167,26 +1167,26 @@ fn parse_assign_expr(p: parser) -> @ast::expr {\n         let rhs = parse_expr(p);\n         let aop = ast::add;\n         alt op {\n-          token::PLUS. { aop = ast::add; }\n-          token::MINUS. { aop = ast::subtract; }\n-          token::STAR. { aop = ast::mul; }\n-          token::SLASH. { aop = ast::div; }\n-          token::PERCENT. { aop = ast::rem; }\n-          token::CARET. { aop = ast::bitxor; }\n-          token::AND. { aop = ast::bitand; }\n-          token::OR. { aop = ast::bitor; }\n-          token::LSL. { aop = ast::lsl; }\n-          token::LSR. { aop = ast::lsr; }\n-          token::ASR. { aop = ast::asr; }\n+          token::PLUS { aop = ast::add; }\n+          token::MINUS { aop = ast::subtract; }\n+          token::STAR { aop = ast::mul; }\n+          token::SLASH { aop = ast::div; }\n+          token::PERCENT { aop = ast::rem; }\n+          token::CARET { aop = ast::bitxor; }\n+          token::AND { aop = ast::bitand; }\n+          token::OR { aop = ast::bitor; }\n+          token::LSL { aop = ast::lsl; }\n+          token::LSR { aop = ast::lsr; }\n+          token::ASR { aop = ast::asr; }\n         }\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_assign_op(aop, lhs, rhs));\n       }\n-      token::LARROW. {\n+      token::LARROW {\n         p.bump();\n         let rhs = parse_expr(p);\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_move(lhs, rhs));\n       }\n-      token::DARROW. {\n+      token::DARROW {\n         p.bump();\n         let rhs = parse_expr(p);\n         ret mk_expr(p, lo, rhs.span.hi, ast::expr_swap(lhs, rhs));\n@@ -1363,11 +1363,11 @@ fn parse_expr_res(p: parser, r: restriction) -> @ast::expr {\n \n fn parse_initializer(p: parser) -> option::t<ast::initializer> {\n     alt p.token {\n-      token::EQ. {\n+      token::EQ {\n         p.bump();\n         ret some({op: ast::init_assign, expr: parse_expr(p)});\n       }\n-      token::LARROW. {\n+      token::LARROW {\n         p.bump();\n         ret some({op: ast::init_move, expr: parse_expr(p)});\n       }\n@@ -1398,20 +1398,20 @@ fn parse_pat(p: parser) -> @ast::pat {\n     let hi = p.span.hi;\n     let pat;\n     alt p.token {\n-      token::UNDERSCORE. { p.bump(); pat = ast::pat_wild; }\n-      token::AT. {\n+      token::UNDERSCORE { p.bump(); pat = ast::pat_wild; }\n+      token::AT {\n         p.bump();\n         let sub = parse_pat(p);\n         pat = ast::pat_box(sub);\n         hi = sub.span.hi;\n       }\n-      token::TILDE. {\n+      token::TILDE {\n         p.bump();\n         let sub = parse_pat(p);\n         pat = ast::pat_uniq(sub);\n         hi = sub.span.hi;\n       }\n-      token::LBRACE. {\n+      token::LBRACE {\n         p.bump();\n         let fields = [];\n         let etc = false;\n@@ -1452,7 +1452,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n         p.bump();\n         pat = ast::pat_rec(fields, etc);\n       }\n-      token::LPAREN. {\n+      token::LPAREN {\n         p.bump();\n         if p.token == token::RPAREN {\n             hi = p.span.hi;\n@@ -1486,9 +1486,9 @@ fn parse_pat(p: parser) -> @ast::pat {\n         } else if is_plain_ident(p) &&\n                       alt p.look_ahead(1u) {\n                     // Take this out once the libraries change\n-                        token::DOT. |\n-                        token::LPAREN. | token::LBRACKET. |\n-                            token::LT. {\n+                        token::DOT |\n+                        token::LPAREN | token::LBRACKET |\n+                            token::LT {\n                           false\n                         }\n                         _ { true }\n@@ -1501,7 +1501,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n             hi = tag_path.span.hi;\n             let args: [@ast::pat];\n             alt p.token {\n-              token::LPAREN. {\n+              token::LPAREN {\n                 let a =\n                     parse_seq(token::LPAREN, token::RPAREN,\n                               seq_sep(token::COMMA), parse_pat, p);\n@@ -1565,7 +1565,7 @@ fn parse_stmt(p: parser, first_item_attrs: [ast::attribute]) -> @ast::stmt {\n     } else {\n         let item_attrs;\n         alt parse_outer_attrs_or_ext(p, first_item_attrs) {\n-          none. { item_attrs = []; }\n+          none { item_attrs = []; }\n           some(left(attrs)) { item_attrs = attrs; }\n           some(right(ext)) {\n             ret @spanned(lo, ext.span.hi, ast::stmt_expr(ext, p.get_id()));\n@@ -1692,7 +1692,7 @@ fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n \n     while p.token != token::RBRACE {\n         alt p.token {\n-          token::SEMI. {\n+          token::SEMI {\n             p.bump(); // empty\n           }\n           _ {\n@@ -1701,11 +1701,11 @@ fn parse_block_tail_(p: parser, lo: uint, s: ast::blk_check_mode,\n             alt stmt.node {\n               ast::stmt_expr(e, stmt_id) { // Expression without semicolon:\n                 alt p.token {\n-                  token::SEMI. {\n+                  token::SEMI {\n                     p.bump();\n                     stmts += [@{node: ast::stmt_semi(e, stmt_id) with *stmt}];\n                   }\n-                  token::RBRACE. {\n+                  token::RBRACE {\n                     expr = some(e);\n                   }\n                   t {\n@@ -1856,7 +1856,7 @@ fn parse_item_impl(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     } else { none };\n     let ident = alt ident {\n         some(name) { name }\n-        none. { expect_word(p, \"of\"); fail; }\n+        none { expect_word(p, \"of\"); fail; }\n     };\n     expect_word(p, \"for\");\n     let ty = parse_ty(p, false), meths = [];\n@@ -2059,7 +2059,7 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n             let vhi = p.span.hi;\n             let disr_expr = none;\n             alt p.token {\n-              token::LPAREN. {\n+              token::LPAREN {\n                 all_nullary = false;\n                 let arg_tys = parse_seq(token::LPAREN, token::RPAREN,\n                                         seq_sep(token::COMMA),\n@@ -2069,7 +2069,7 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n                 }\n                 vhi = arg_tys.span.hi;\n               }\n-              token::EQ. {\n+              token::EQ {\n                 have_disr = true;\n                 p.bump();\n                 disr_expr = some(parse_expr(p));\n@@ -2078,11 +2078,11 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n             }\n \n             alt p.token {\n-              token::SEMI. | token::COMMA. {\n+              token::SEMI | token::COMMA {\n                 p.bump();\n                 if p.token == token::RBRACE { done = true; }\n               }\n-              token::RBRACE. { done = true; }\n+              token::RBRACE { done = true; }\n               _ { /* fall through */ }\n             }\n \n@@ -2107,19 +2107,19 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n \n fn parse_fn_ty_proto(p: parser) -> ast::proto {\n     alt p.token {\n-      token::AT. {\n+      token::AT {\n         p.bump();\n         ast::proto_box\n       }\n-      token::TILDE. {\n+      token::TILDE {\n         p.bump();\n         ast::proto_uniq\n       }\n-      token::BINOP(token::AND.) {\n+      token::BINOP(token::AND) {\n         p.bump();\n         ast::proto_block\n       }\n-      token::BINOP(token::STAR.) {\n+      token::BINOP(token::STAR) {\n         p.bump(); // temporary: fn* for any closure\n         ast::proto_any\n       }\n@@ -2131,7 +2131,7 @@ fn parse_fn_ty_proto(p: parser) -> ast::proto {\n \n fn fn_expr_lookahead(tok: token::token) -> bool {\n     alt tok {\n-      token::LPAREN. | token::AT. | token::TILDE. | token::BINOP(_) {\n+      token::LPAREN | token::AT | token::TILDE | token::BINOP(_) {\n         true\n       }\n       _ {\n@@ -2255,13 +2255,13 @@ fn parse_meta_item(p: parser) -> @ast::meta_item {\n     let lo = p.span.lo;\n     let ident = parse_ident(p);\n     alt p.token {\n-      token::EQ. {\n+      token::EQ {\n         p.bump();\n         let lit = parse_lit(p);\n         let hi = p.span.hi;\n         ret @spanned(lo, hi, ast::meta_name_value(ident, lit));\n       }\n-      token::LPAREN. {\n+      token::LPAREN {\n         let inner_items = parse_meta_seq(p);\n         let hi = p.span.hi;\n         ret @spanned(lo, hi, ast::meta_list(ident, inner_items));\n@@ -2279,7 +2279,7 @@ fn parse_meta_seq(p: parser) -> [@ast::meta_item] {\n }\n \n fn parse_optional_meta(p: parser) -> [@ast::meta_item] {\n-    alt p.token { token::LPAREN. { ret parse_meta_seq(p); } _ { ret []; } }\n+    alt p.token { token::LPAREN { ret parse_meta_seq(p); } _ { ret []; } }\n }\n \n fn parse_use(p: parser) -> ast::view_item_ {\n@@ -2296,8 +2296,8 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n     let from_idents = option::none::<[ast::import_ident]>;\n     while true {\n         alt p.token {\n-          token::SEMI. { break; }\n-          token::MOD_SEP. {\n+          token::SEMI { break; }\n+          token::MOD_SEP {\n             if glob { p.fatal(\"cannot path into a glob\"); }\n             if option::is_some(from_idents) {\n                 p.fatal(\"cannot path into import list\");\n@@ -2314,7 +2314,7 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n \n \n           //the lexer can't tell the different kinds of stars apart ) :\n-          token::BINOP(token::STAR.) {\n+          token::BINOP(token::STAR) {\n             glob = true;\n             p.bump();\n           }\n@@ -2323,7 +2323,7 @@ fn parse_rest_import_name(p: parser, first: ast::ident,\n \n \n \n-          token::LBRACE. {\n+          token::LBRACE {\n             fn parse_import_ident(p: parser) -> ast::import_ident {\n                 let lo = p.span.lo;\n                 let ident = parse_ident(p);\n@@ -2388,7 +2388,7 @@ fn parse_import(p: parser) -> ast::view_item_ {\n       token::IDENT(i, _) {\n         p.bump();\n         alt p.token {\n-          token::EQ. {\n+          token::EQ {\n             p.bump();\n             ret parse_full_import_name(p, p.get_str(i));\n           }\n@@ -2523,13 +2523,13 @@ fn parse_crate_directive(p: parser, first_outer_attr: [ast::attribute]) ->\n         let id = parse_ident(p);\n         alt p.token {\n           // mod x = \"foo.rs\";\n-          token::SEMI. {\n+          token::SEMI {\n             let hi = p.span.hi;\n             p.bump();\n             ret spanned(lo, hi, ast::cdir_src_mod(id, outer_attrs));\n           }\n           // mod x = \"foo_dir\" { ...directives... }\n-          token::LBRACE. {\n+          token::LBRACE {\n             p.bump();\n             let inner_attrs = parse_inner_attrs_and_next(p);\n             let mod_attrs = outer_attrs + inner_attrs.inner;"}, {"sha": "e5dcc8b61f7fc5b5a03147c26a65c29e07d05d65", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -74,62 +74,62 @@ tag token {\n \n fn binop_to_str(o: binop) -> str {\n     alt o {\n-      PLUS. { ret \"+\"; }\n-      MINUS. { ret \"-\"; }\n-      STAR. { ret \"*\"; }\n-      SLASH. { ret \"/\"; }\n-      PERCENT. { ret \"%\"; }\n-      CARET. { ret \"^\"; }\n-      AND. { ret \"&\"; }\n-      OR. { ret \"|\"; }\n-      LSL. { ret \"<<\"; }\n-      LSR. { ret \">>\"; }\n-      ASR. { ret \">>>\"; }\n+      PLUS { ret \"+\"; }\n+      MINUS { ret \"-\"; }\n+      STAR { ret \"*\"; }\n+      SLASH { ret \"/\"; }\n+      PERCENT { ret \"%\"; }\n+      CARET { ret \"^\"; }\n+      AND { ret \"&\"; }\n+      OR { ret \"|\"; }\n+      LSL { ret \"<<\"; }\n+      LSR { ret \">>\"; }\n+      ASR { ret \">>>\"; }\n     }\n }\n \n fn to_str(r: reader, t: token) -> str {\n     alt t {\n-      EQ. { ret \"=\"; }\n-      LT. { ret \"<\"; }\n-      LE. { ret \"<=\"; }\n-      EQEQ. { ret \"==\"; }\n-      NE. { ret \"!=\"; }\n-      GE. { ret \">=\"; }\n-      GT. { ret \">\"; }\n-      NOT. { ret \"!\"; }\n-      TILDE. { ret \"~\"; }\n-      OROR. { ret \"||\"; }\n-      ANDAND. { ret \"&&\"; }\n+      EQ { ret \"=\"; }\n+      LT { ret \"<\"; }\n+      LE { ret \"<=\"; }\n+      EQEQ { ret \"==\"; }\n+      NE { ret \"!=\"; }\n+      GE { ret \">=\"; }\n+      GT { ret \">\"; }\n+      NOT { ret \"!\"; }\n+      TILDE { ret \"~\"; }\n+      OROR { ret \"||\"; }\n+      ANDAND { ret \"&&\"; }\n       BINOP(op) { ret binop_to_str(op); }\n       BINOPEQ(op) { ret binop_to_str(op) + \"=\"; }\n \n       /* Structural symbols */\n-      AT. {\n+      AT {\n         ret \"@\";\n       }\n-      DOT. { ret \".\"; }\n-      ELLIPSIS. { ret \"...\"; }\n-      COMMA. { ret \",\"; }\n-      SEMI. { ret \";\"; }\n-      COLON. { ret \":\"; }\n-      MOD_SEP. { ret \"::\"; }\n-      QUES. { ret \"?\"; }\n-      RARROW. { ret \"->\"; }\n-      LARROW. { ret \"<-\"; }\n-      DARROW. { ret \"<->\"; }\n-      LPAREN. { ret \"(\"; }\n-      RPAREN. { ret \")\"; }\n-      LBRACKET. { ret \"[\"; }\n-      RBRACKET. { ret \"]\"; }\n-      LBRACE. { ret \"{\"; }\n-      RBRACE. { ret \"}\"; }\n-      POUND. { ret \"#\"; }\n-      POUND_LBRACE. { ret \"#{\"; }\n-      POUND_LT. { ret \"#<\"; }\n+      DOT { ret \".\"; }\n+      ELLIPSIS { ret \"...\"; }\n+      COMMA { ret \",\"; }\n+      SEMI { ret \";\"; }\n+      COLON { ret \":\"; }\n+      MOD_SEP { ret \"::\"; }\n+      QUES { ret \"?\"; }\n+      RARROW { ret \"->\"; }\n+      LARROW { ret \"<-\"; }\n+      DARROW { ret \"<->\"; }\n+      LPAREN { ret \"(\"; }\n+      RPAREN { ret \")\"; }\n+      LBRACKET { ret \"[\"; }\n+      RBRACKET { ret \"]\"; }\n+      LBRACE { ret \"{\"; }\n+      RBRACE { ret \"}\"; }\n+      POUND { ret \"#\"; }\n+      POUND_LBRACE { ret \"#{\"; }\n+      POUND_LT { ret \"#<\"; }\n \n       /* Literals */\n-      LIT_INT(c, ast::ty_char.) {\n+      LIT_INT(c, ast::ty_char) {\n         // FIXME: escape.\n         let tmp = \"'\";\n         str::push_char(tmp, c as char);\n@@ -156,31 +156,31 @@ fn to_str(r: reader, t: token) -> str {\n         ret interner::get::<str>(*r.interner, s);\n       }\n       IDX(i) { ret \"_\" + int::to_str(i, 10u); }\n-      UNDERSCORE. { ret \"_\"; }\n+      UNDERSCORE { ret \"_\"; }\n       BRACEQUOTE(_) { ret \"<bracequote>\"; }\n-      EOF. { ret \"<eof>\"; }\n+      EOF { ret \"<eof>\"; }\n     }\n }\n \n \n pure fn can_begin_expr(t: token) -> bool {\n     alt t {\n-      LPAREN. { true }\n-      LBRACE. { true }\n-      LBRACKET. { true }\n+      LPAREN { true }\n+      LBRACE { true }\n+      LBRACKET { true }\n       IDENT(_, _) { true }\n-      UNDERSCORE. { true }\n-      TILDE. { true }\n+      UNDERSCORE { true }\n+      TILDE { true }\n       LIT_INT(_, _) { true }\n       LIT_UINT(_, _) { true }\n       LIT_FLOAT(_, _) { true }\n       LIT_STR(_) { true }\n-      POUND. { true }\n-      AT. { true }\n-      NOT. { true }\n-      BINOP(MINUS.) { true }\n-      BINOP(STAR.) { true }\n-      MOD_SEP. { true }\n+      POUND { true }\n+      AT { true }\n+      NOT { true }\n+      BINOP(MINUS) { true }\n+      BINOP(STAR) { true }\n+      MOD_SEP { true }\n       _ { false }\n     }\n }"}, {"sha": "455e9d916c99f4598edd9d660529d641a1561e7c", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -68,8 +68,8 @@ fn tok_str(t: token) -> str {\n       STRING(s, len) { ret #fmt[\"STR(%s,%d)\", s, len]; }\n       BREAK(_) { ret \"BREAK\"; }\n       BEGIN(_) { ret \"BEGIN\"; }\n-      END. { ret \"END\"; }\n-      EOF. { ret \"EOF\"; }\n+      END { ret \"END\"; }\n+      EOF { ret \"EOF\"; }\n     }\n }\n \n@@ -236,7 +236,7 @@ impl printer for printer {\n     fn pretty_print(t: token) {\n         #debug(\"pp [%u,%u]\", self.left, self.right);\n         alt t {\n-          EOF. {\n+          EOF {\n             if !self.scan_stack_empty {\n                 self.check_stack(0);\n                 self.advance_left(self.token[self.left],\n@@ -256,7 +256,7 @@ impl printer for printer {\n             self.size[self.right] = -self.right_total;\n             self.scan_push(self.right);\n           }\n-          END. {\n+          END {\n             if self.scan_stack_empty {\n                 #debug(\"pp END/print [%u,%u]\", self.left, self.right);\n                 self.print(t, 0);\n@@ -378,7 +378,7 @@ impl printer for printer {\n                     self.check_stack(k - 1);\n                 }\n               }\n-              END. {\n+              END {\n                 // paper says + not =, but that makes no sense.\n                 self.size[self.scan_pop()] = 1;\n                 self.check_stack(k + 1);\n@@ -428,25 +428,25 @@ impl printer for printer {\n                 self.print_stack += [{offset: 0, pbreak: fits}];\n             }\n           }\n-          END. {\n+          END {\n             #debug(\"print END -> pop END\");\n             assert (vec::len(self.print_stack) != 0u);\n             vec::pop(self.print_stack);\n           }\n           BREAK(b) {\n             let top = self.get_top();\n             alt top.pbreak {\n-              fits. {\n+              fits {\n                 #debug(\"print BREAK in fitting block\");\n                 self.space -= b.blank_space;\n                 self.indent(b.blank_space);\n               }\n-              broken(consistent.) {\n+              broken(consistent) {\n                 #debug(\"print BREAK in consistent block\");\n                 self.print_newline(top.offset + b.offset);\n                 self.space = self.margin - (top.offset + b.offset);\n               }\n-              broken(inconsistent.) {\n+              broken(inconsistent) {\n                 if L > self.space {\n                     #debug(\"print BREAK w/ newline in inconsistent\");\n                     self.print_newline(top.offset + b.offset);\n@@ -466,7 +466,7 @@ impl printer for printer {\n             self.space -= len;\n             self.write_str(s);\n           }\n-          EOF. {\n+          EOF {\n             // EOF should never get here.\n             fail;\n           }"}, {"sha": "ebf5484af35b7b934a5e32b0b36654e9ab1e4f4c", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -163,7 +163,7 @@ fn is_begin(s: ps) -> bool {\n }\n \n fn is_end(s: ps) -> bool {\n-    alt s.s.last_token() { pp::END. { true } _ { false } }\n+    alt s.s.last_token() { pp::END { true } _ { false } }\n }\n \n fn is_bol(s: ps) -> bool {\n@@ -251,25 +251,25 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n     maybe_print_comment(s, ty.span.lo);\n     ibox(s, 0u);\n     alt ty.node {\n-      ast::ty_nil. { word(s.s, \"()\"); }\n-      ast::ty_bool. { word(s.s, \"bool\"); }\n-      ast::ty_bot. { word(s.s, \"!\"); }\n-      ast::ty_int(ast::ty_i.) { word(s.s, \"int\"); }\n-      ast::ty_int(ast::ty_char.) { word(s.s, \"char\"); }\n+      ast::ty_nil { word(s.s, \"()\"); }\n+      ast::ty_bool { word(s.s, \"bool\"); }\n+      ast::ty_bot { word(s.s, \"!\"); }\n+      ast::ty_int(ast::ty_i) { word(s.s, \"int\"); }\n+      ast::ty_int(ast::ty_char) { word(s.s, \"char\"); }\n       ast::ty_int(t) { word(s.s, ast_util::int_ty_to_str(t)); }\n-      ast::ty_uint(ast::ty_u.) { word(s.s, \"uint\"); }\n+      ast::ty_uint(ast::ty_u) { word(s.s, \"uint\"); }\n       ast::ty_uint(t) { word(s.s, ast_util::uint_ty_to_str(t)); }\n-      ast::ty_float(ast::ty_f.) { word(s.s, \"float\"); }\n+      ast::ty_float(ast::ty_f) { word(s.s, \"float\"); }\n       ast::ty_float(t) { word(s.s, ast_util::float_ty_to_str(t)); }\n-      ast::ty_str. { word(s.s, \"str\"); }\n+      ast::ty_str { word(s.s, \"str\"); }\n       ast::ty_box(mt) { word(s.s, \"@\"); print_mt(s, mt); }\n       ast::ty_uniq(mt) { word(s.s, \"~\"); print_mt(s, mt); }\n       ast::ty_vec(mt) {\n         word(s.s, \"[\");\n         alt mt.mut {\n-          ast::mut. { word_space(s, \"mutable\"); }\n-          ast::maybe_mut. { word_space(s, \"const\"); }\n-          ast::imm. { }\n+          ast::mut { word_space(s, \"mutable\"); }\n+          ast::maybe_mut { word_space(s, \"const\"); }\n+          ast::imm { }\n         }\n         print_type(s, mt.ty);\n         word(s.s, \"]\");\n@@ -309,7 +309,7 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         print_ty_fn(s, some(proto), d, none, none);\n       }\n       ast::ty_path(path, _) { print_path(s, path, false); }\n-      ast::ty_type. { word(s.s, \"type\"); }\n+      ast::ty_type { word(s.s, \"type\"); }\n       ast::ty_constr(t, cs) {\n         print_type(s, t);\n         space(s.s);\n@@ -324,7 +324,7 @@ fn print_native_item(s: ps, item: @ast::native_item) {\n     maybe_print_comment(s, item.span.lo);\n     print_outer_attributes(s, item.attrs);\n     alt item.node {\n-      ast::native_item_ty. {\n+      ast::native_item_ty {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, \"type\");\n@@ -585,9 +585,9 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n     let ann_node = node_block(s, blk);\n     s.ann.pre(ann_node);\n     alt embedded {\n-      block_macro. { word(s.s, \"#{\"); end(s); }\n-      block_block_fn. { end(s); }\n-      block_normal. { bopen(s); }\n+      block_macro { word(s.s, \"#{\"); end(s); }\n+      block_block_fn { end(s); }\n+      block_normal { bopen(s); }\n     }\n \n     print_inner_attributes(s, attrs);\n@@ -612,7 +612,7 @@ fn print_possibly_embedded_block_(s: ps, blk: ast::blk, embedded: embed_type,\n // alt, do, & while unambiguously without being parenthesized\n fn print_maybe_parens_discrim(s: ps, e: @ast::expr) {\n     let disambig = alt e.node {\n-      ast::expr_ret(none.) | ast::expr_fail(none.) { true }\n+      ast::expr_ret(none) | ast::expr_fail(none) { true }\n       _ { false }\n     };\n     if disambig { popen(s); }\n@@ -683,7 +683,7 @@ fn print_mac(s: ps, m: ast::mac) {\n       ast::mac_embed_block(blk) {\n         print_possibly_embedded_block(s, blk, block_normal, indent_unit);\n       }\n-      ast::mac_ellipsis. { word(s.s, \"...\"); }\n+      ast::mac_ellipsis { word(s.s, \"...\"); }\n     }\n }\n \n@@ -834,7 +834,7 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n             space(s.s);\n             alt arm.guard {\n               some(e) { word_space(s, \"if\"); print_expr(s, e); space(s.s); }\n-              none. { }\n+              none { }\n             }\n             print_possibly_embedded_block(s, arm.body, block_normal,\n                                           alt_indent_unit);\n@@ -923,8 +923,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n           _ { }\n         }\n       }\n-      ast::expr_break. { word(s.s, \"break\"); }\n-      ast::expr_cont. { word(s.s, \"cont\"); }\n+      ast::expr_break { word(s.s, \"break\"); }\n+      ast::expr_cont { word(s.s, \"cont\"); }\n       ast::expr_ret(result) {\n         word(s.s, \"ret\");\n         alt result {\n@@ -1011,8 +1011,8 @@ fn print_decl(s: ps, decl: @ast::decl) {\n               some(init) {\n                 nbsp(s);\n                 alt init.op {\n-                  ast::init_assign. { word_space(s, \"=\"); }\n-                  ast::init_move. { word_space(s, \"<-\"); }\n+                  ast::init_assign { word_space(s, \"=\"); }\n+                  ast::init_move { word_space(s, \"<-\"); }\n                 }\n                 print_expr(s, init.expr);\n               }\n@@ -1058,7 +1058,7 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     /* Pat isn't normalized, but the beauty of it\n      is that it doesn't matter */\n     alt pat.node {\n-      ast::pat_wild. { word(s.s, \"_\"); }\n+      ast::pat_wild { word(s.s, \"_\"); }\n       ast::pat_ident(path, sub) {\n         print_path(s, path, true);\n         alt sub {\n@@ -1112,9 +1112,9 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: [ast::ty_param]) {\n     alt decl.purity {\n-      ast::impure_fn. { head(s, \"fn\"); }\n-      ast::unsafe_fn. { head(s, \"unsafe fn\"); }\n-      ast::pure_fn. { head(s, \"pure fn\"); }\n+      ast::impure_fn { head(s, \"fn\"); }\n+      ast::unsafe_fn { head(s, \"unsafe fn\"); }\n+      ast::pure_fn { head(s, \"pure fn\"); }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n@@ -1188,12 +1188,12 @@ fn print_fn_block_args(s: ps, decl: ast::fn_decl) {\n \n fn print_arg_mode(s: ps, m: ast::mode) {\n     alt m {\n-      ast::by_mut_ref. { word(s.s, \"&\"); }\n-      ast::by_move. { word(s.s, \"-\"); }\n-      ast::by_ref. { word(s.s, \"&&\"); }\n-      ast::by_val. { word(s.s, \"++\"); }\n-      ast::by_copy. { word(s.s, \"+\"); }\n-      ast::mode_infer. {}\n+      ast::by_mut_ref { word(s.s, \"&\"); }\n+      ast::by_move { word(s.s, \"-\"); }\n+      ast::by_ref { word(s.s, \"&&\"); }\n+      ast::by_val { word(s.s, \"++\"); }\n+      ast::by_copy { word(s.s, \"+\"); }\n+      ast::mode_infer {}\n     }\n }\n \n@@ -1203,8 +1203,8 @@ fn print_bounds(s: ps, bounds: @[ast::ty_param_bound]) {\n         for bound in *bounds {\n             nbsp(s);\n             alt bound {\n-              ast::bound_copy. { word(s.s, \"copy\"); }\n-              ast::bound_send. { word(s.s, \"send\"); }\n+              ast::bound_copy { word(s.s, \"copy\"); }\n+              ast::bound_send { word(s.s, \"send\"); }\n               ast::bound_iface(t) { print_type(s, t); }\n             }\n         }\n@@ -1335,9 +1335,9 @@ fn print_op_maybe_parens(s: ps, expr: @ast::expr, outer_prec: int) {\n \n fn print_mutability(s: ps, mut: ast::mutability) {\n     alt mut {\n-      ast::mut. { word_nbsp(s, \"mutable\"); }\n-      ast::maybe_mut. { word_nbsp(s, \"const\"); }\n-      ast::imm. {/* nothing */ }\n+      ast::mut { word_nbsp(s, \"mutable\"); }\n+      ast::maybe_mut { word_nbsp(s, \"const\"); }\n+      ast::imm {/* nothing */ }\n     }\n }\n \n@@ -1387,7 +1387,7 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let next = cmnt.pos + 1u;\n-        alt next_pos { none. { } some(p) { next = p; } }\n+        alt next_pos { none { } some(p) { next = p; } }\n         if span.hi < cmnt.pos && cmnt.pos < next &&\n                span_line.line == comment_line.line {\n             print_comment(s, cmnt);\n@@ -1427,7 +1427,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n     }\n     alt lit.node {\n       ast::lit_str(st) { print_string(s, st); }\n-      ast::lit_int(ch, ast::ty_char.) {\n+      ast::lit_int(ch, ast::ty_char) {\n         word(s.s, \"'\" + escape_str(str::from_char(ch as char), '\\'') + \"'\");\n       }\n       ast::lit_int(i, t) {\n@@ -1439,7 +1439,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n       ast::lit_float(f, t) {\n         word(s.s, f + ast_util::float_ty_to_str(t));\n       }\n-      ast::lit_nil. { word(s.s, \"()\"); }\n+      ast::lit_nil { word(s.s, \"()\"); }\n       ast::lit_bool(val) {\n         if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n       }\n@@ -1508,7 +1508,7 @@ fn print_comment(s: ps, cmnt: lexer::cmnt) {\n             end(s);\n         }\n       }\n-      lexer::blank_line. {\n+      lexer::blank_line {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n@@ -1585,7 +1585,7 @@ fn constr_args_to_str<T>(f: fn@(T) -> str, args: [@ast::sp_constr_arg<T>]) ->\n fn constr_arg_to_str<T>(f: fn@(T) -> str, c: ast::constr_arg_general_<T>) ->\n    str {\n     alt c {\n-      ast::carg_base. { ret \"*\"; }\n+      ast::carg_base { ret \"*\"; }\n       ast::carg_ident(i) { ret f(i); }\n       ast::carg_lit(l) { ret lit_to_str(l); }\n     }\n@@ -1635,18 +1635,18 @@ fn ast_fn_constrs_str(decl: ast::fn_decl, constrs: [@ast::constr]) -> str {\n \n fn opt_proto_to_str(opt_p: option<ast::proto>) -> str {\n     alt opt_p {\n-      none. { \"fn\" }\n+      none { \"fn\" }\n       some(p) { proto_to_str(p) }\n     }\n }\n \n fn proto_to_str(p: ast::proto) -> str {\n     ret alt p {\n-      ast::proto_bare. { \"native fn\" }\n-      ast::proto_any. { \"fn*\" }\n-      ast::proto_block. { \"fn&\" }\n-      ast::proto_uniq. { \"fn~\" }\n-      ast::proto_box. { \"fn@\" }\n+      ast::proto_bare { \"native fn\" }\n+      ast::proto_any { \"fn*\" }\n+      ast::proto_block { \"fn&\" }\n+      ast::proto_uniq { \"fn~\" }\n+      ast::proto_box { \"fn@\" }\n     };\n }\n \n@@ -1671,7 +1671,7 @@ fn ast_ty_constrs_str(constrs: [@ast::ty_constr]) -> str {\n \n fn ends_in_lit_int(ex: @ast::expr) -> bool {\n     alt ex.node {\n-      ast::expr_lit(@{node: ast::lit_int(_, ast::ty_i.), _}) { true }\n+      ast::expr_lit(@{node: ast::lit_int(_, ast::ty_i), _}) { true }\n       ast::expr_binary(_, _, sub) | ast::expr_unary(_, sub) |\n       ast::expr_ternary(_, _, sub) | ast::expr_move(_, sub) |\n       ast::expr_copy(sub) | ast::expr_assign(_, sub) | ast::expr_be(sub) |"}, {"sha": "a7d8431da79c2e3fb252c701de27426cf47e66e5", "filename": "src/comp/syntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Futil%2Finterner.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -20,7 +20,7 @@ fn mk<T: copy>(hasher: hashfn<T>, eqer: eqfn<T>) -> interner<T> {\n fn intern<T: copy>(itr: interner<T>, val: T) -> uint {\n     alt itr.map.find(val) {\n       some(idx) { ret idx; }\n-      none. {\n+      none {\n         let new_idx = vec::len::<T>(itr.vect);\n         itr.map.insert(val, new_idx);\n         itr.vect += [val];"}, {"sha": "bf544c099005a181843e116f72088d42a0d24778", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -26,14 +26,14 @@ tag fn_kind {\n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _) | fk_res(name, _) { name }\n-      fk_anon(_) | fk_fn_block. { \"anon\" }\n+      fk_anon(_) | fk_fn_block { \"anon\" }\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps) | fk_res(_, tps) { tps }\n-      fk_anon(_) | fk_fn_block. { [] }\n+      fk_anon(_) | fk_fn_block { [] }\n     }\n }\n \n@@ -101,7 +101,7 @@ fn visit_view_item<E>(_vi: @view_item, _e: E, _v: vt<E>) { }\n fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n     v.visit_pat(loc.node.pat, e, v);\n     v.visit_ty(loc.node.ty, e, v);\n-    alt loc.node.init { none. { } some(i) { v.visit_expr(i.expr, e, v); } }\n+    alt loc.node.init { none { } some(i) { v.visit_expr(i.expr, e, v); } }\n }\n \n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n@@ -165,7 +165,7 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         v.visit_ty(decl.output, e, v);\n       }\n       ty_path(p, _) { visit_path(p, e, v); }\n-      ty_type. {/* no-op */ }\n+      ty_type {/* no-op */ }\n       ty_constr(t, cs) {\n         v.visit_ty(t, e, v);\n         for tc: @spanned<constr_general_<@path, node_id>> in cs {\n@@ -212,7 +212,7 @@ fn visit_native_item<E>(ni: @native_item, e: E, v: vt<E>) {\n         v.visit_ty_params(tps, e, v);\n         visit_fn_decl(fd, e, v);\n       }\n-      native_item_ty. { }\n+      native_item_ty { }\n     }\n }\n \n@@ -266,7 +266,7 @@ fn visit_decl<E>(d: @decl, e: E, v: vt<E>) {\n }\n \n fn visit_expr_opt<E>(eo: option::t<@expr>, e: E, v: vt<E>) {\n-    alt eo { none. { } some(ex) { v.visit_expr(ex, e, v); } }\n+    alt eo { none { } some(ex) { v.visit_expr(ex, e, v); } }\n }\n \n fn visit_exprs<E>(exprs: [@expr], e: E, v: vt<E>) {\n@@ -278,7 +278,7 @@ fn visit_mac<E>(m: mac, e: E, v: vt<E>) {\n       ast::mac_invoc(pth, arg, body) { visit_expr(arg, e, v); }\n       ast::mac_embed_type(ty) { v.visit_ty(ty, e, v); }\n       ast::mac_embed_block(blk) { v.visit_block(blk, e, v); }\n-      ast::mac_ellipsis. { }\n+      ast::mac_ellipsis { }\n     }\n }\n \n@@ -350,8 +350,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_index(a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_path(p) { visit_path(p, e, v); }\n       expr_fail(eo) { visit_expr_opt(eo, e, v); }\n-      expr_break. { }\n-      expr_cont. { }\n+      expr_break { }\n+      expr_cont { }\n       expr_ret(eo) { visit_expr_opt(eo, e, v); }\n       expr_be(x) { v.visit_expr(x, e, v); }\n       expr_log(_, lv, x) {"}, {"sha": "172afa35fe91c702e3698ea5ed31baab4a26620e", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -73,8 +73,8 @@ fn has_nonlocal_exits(b: ast::blk) -> bool {\n     let has_exits = @mutable false;\n     fn visit_expr(flag: @mutable bool, e: @ast::expr) {\n         alt e.node {\n-          ast::expr_break. { *flag = true; }\n-          ast::expr_cont. { *flag = true; }\n+          ast::expr_break { *flag = true; }\n+          ast::expr_cont { *flag = true; }\n           _ { }\n         }\n     }"}, {"sha": "ece3f17e747db2c944c16f6d3c17e7d378233646", "filename": "src/comp/util/filesearch.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Ffilesearch.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -96,7 +96,7 @@ fn make_target_lib_path(sysroot: fs::path,\n fn get_default_sysroot() -> fs::path {\n     alt os::get_exe_path() {\n       option::some(p) { fs::normalize(fs::connect(p, \"..\")) }\n-      option::none. {\n+      option::none {\n         fail \"can't determine value for sysroot\";\n       }\n     }\n@@ -105,17 +105,17 @@ fn get_default_sysroot() -> fs::path {\n fn get_sysroot(maybe_sysroot: option::t<fs::path>) -> fs::path {\n     alt maybe_sysroot {\n       option::some(sr) { sr }\n-      option::none. { get_default_sysroot() }\n+      option::none { get_default_sysroot() }\n     }\n }\n \n fn get_cargo_root() -> result::t<fs::path, str> {\n     alt generic_os::getenv(\"CARGO_ROOT\") {\n         some(_p) { result::ok(_p) }\n-        none. {\n+        none {\n           alt fs::homedir() {\n             some(_q) { result::ok(fs::connect(_q, \".cargo\")) }\n-            none. { result::err(\"no CARGO_ROOT or home directory\") }\n+            none { result::err(\"no CARGO_ROOT or home directory\") }\n           }\n         }\n     }"}, {"sha": "093b9c49a7426630bbf8fca550962344a3c42a3e", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -10,11 +10,11 @@ import middle::ast_map;\n \n fn mode_str(m: ty::mode) -> str {\n     alt m {\n-      ast::by_ref. { \"&&\" }\n-      ast::by_val. { \"++\" }\n-      ast::by_mut_ref. { \"&\" }\n-      ast::by_move. { \"-\" }\n-      ast::by_copy. { \"+\" }\n+      ast::by_ref { \"&&\" }\n+      ast::by_val { \"++\" }\n+      ast::by_mut_ref { \"&\" }\n+      ast::by_move { \"-\" }\n+      ast::by_copy { \"+\" }\n       _ { \"\" }\n     }\n }\n@@ -23,10 +23,10 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {\n         let modestr = alt input.mode {\n-          ast::by_ref. {\n+          ast::by_ref {\n             ty::type_is_immediate(cx, input.ty) ? \"&&\" : \"\"\n           }\n-          ast::by_val. {\n+          ast::by_val {\n             ty::type_is_immediate(cx, input.ty) ? \"\" : \"++\"\n           }\n           _ { mode_str(input.mode) }\n@@ -46,7 +46,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n         if struct(cx, output) != ty_nil {\n             s += \" -> \";\n             alt cf {\n-              ast::noreturn. { s += \"!\"; }\n+              ast::noreturn { s += \"!\"; }\n               ast::return_val. { s += ty_to_str(cx, output); }\n             }\n         }\n@@ -63,9 +63,9 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn mt_to_str(cx: ctxt, m: mt) -> str {\n         let mstr;\n         alt m.mut {\n-          ast::mut. { mstr = \"mutable \"; }\n-          ast::imm. { mstr = \"\"; }\n-          ast::maybe_mut. { mstr = \"const \"; }\n+          ast::mut { mstr = \"mutable \"; }\n+          ast::imm { mstr = \"\"; }\n+          ast::maybe_mut { mstr = \"const \"; }\n         }\n         ret mstr + ty_to_str(cx, m.ty);\n     }\n@@ -86,22 +86,22 @@ fn ty_to_str(cx: ctxt, typ: t) -> str {\n     }\n     ret alt struct(cx, typ) {\n       ty_native(_) { \"native\" }\n-      ty_nil. { \"()\" }\n-      ty_bot. { \"_|_\" }\n-      ty_bool. { \"bool\" }\n-      ty_int(ast::ty_i.) { \"int\" }\n-      ty_int(ast::ty_char.) { \"char\" }\n+      ty_nil { \"()\" }\n+      ty_bot { \"_|_\" }\n+      ty_bool { \"bool\" }\n+      ty_int(ast::ty_i) { \"int\" }\n+      ty_int(ast::ty_char) { \"char\" }\n       ty_int(t) { ast_util::int_ty_to_str(t) }\n-      ty_uint(ast::ty_u.) { \"uint\" }\n+      ty_uint(ast::ty_u) { \"uint\" }\n       ty_uint(t) { ast_util::uint_ty_to_str(t) }\n-      ty_float(ast::ty_f.) { \"float\" }\n+      ty_float(ast::ty_f) { \"float\" }\n       ty_float(t) { ast_util::float_ty_to_str(t) }\n-      ty_str. { \"str\" }\n+      ty_str { \"str\" }\n       ty_box(tm) { \"@\" + mt_to_str(cx, tm) }\n       ty_uniq(tm) { \"~\" + mt_to_str(cx, tm) }\n       ty_ptr(tm) { \"*\" + mt_to_str(cx, tm) }\n       ty_vec(tm) { \"[\" + mt_to_str(cx, tm) + \"]\" }\n-      ty_type. { \"type\" }\n+      ty_type { \"type\" }\n       ty_rec(elems) {\n         let strs: [str] = [];\n         for fld: field in elems { strs += [field_to_str(cx, fld)]; }"}, {"sha": "1747147ea5107a8354ec78b7a43360b8f44fc753", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -85,7 +85,7 @@ fn log_config(config: config) {\n }\n \n fn opt_str(maybestr: option::t<str>) -> str {\n-    alt maybestr { option::some(s) { s } option::none. { \"(none)\" } }\n+    alt maybestr { option::some(s) { s } option::none { \"(none)\" } }\n }\n \n fn str_opt(maybestr: str) -> option::t<str> {\n@@ -104,10 +104,10 @@ fn str_mode(s: str) -> mode {\n \n fn mode_str(mode: mode) -> str {\n     alt mode {\n-      mode_compile_fail. { \"compile-fail\" }\n-      mode_run_fail. { \"run-fail\" }\n-      mode_run_pass. { \"run-pass\" }\n-      mode_pretty. { \"pretty\" }\n+      mode_compile_fail { \"compile-fail\" }\n+      mode_run_fail { \"run-fail\" }\n+      mode_run_pass { \"run-pass\" }\n+      mode_pretty { \"pretty\" }\n     }\n }\n \n@@ -124,7 +124,7 @@ fn test_opts(config: config) -> test::test_opts {\n     {filter:\n          alt config.filter {\n            option::some(s) { option::some(s) }\n-           option::none. { option::none }\n+           option::none { option::none }\n          },\n      run_ignored: config.run_ignored}\n }\n@@ -151,7 +151,7 @@ fn make_tests(cx: cx) -> tests_and_conv_fn {\n fn is_test(config: config, testfile: str) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n-        alt config.mode { mode_pretty. { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n+        alt config.mode { mode_pretty { [\".rs\"] } _ { [\".rc\", \".rs\"] } };\n     let invalid_prefixes = [\".\", \"#\", \"~\"];\n     let name = fs::basename(testfile);\n "}, {"sha": "cccce3e5f1be95a2a654e4b384d1852da34cd442", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -28,7 +28,7 @@ fn load_props(testfile: str) -> test_props {\n     iter_header(testfile) {|ln|\n         alt parse_error_pattern(ln) {\n           option::some(ep) { error_patterns += [ep]; }\n-          option::none. { }\n+          option::none { }\n         };\n \n         if option::is_none(compile_flags) {\n@@ -89,7 +89,7 @@ fn parse_compile_flags(line: str) -> option::t<str> {\n fn parse_pp_exact(line: str, testfile: str) -> option::t<str> {\n     alt parse_name_value_directive(line, \"pp-exact\") {\n       option::some(s) { option::some(s) }\n-      option::none. {\n+      option::none {\n         if parse_name_directive(line, \"pp-exact\") {\n             option::some(fs::basename(testfile))\n         } else {"}, {"sha": "c74f264f2b01ca734545b2fa81af4a34ee6d0074", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -119,7 +119,7 @@ fn worker(p: port<request>) {\n                      args: clone_vecu8str(args),\n                      respchan: respchan}\n                   }\n-                  stop. { ret }\n+                  stop { ret }\n                 }\n             };\n "}, {"sha": "73064d1adf5052f27c8ff5884ded6ca4e407f90d", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -24,10 +24,10 @@ fn run(cx: cx, -_testfile: [u8]) {\n     #debug(\"running %s\", testfile);\n     let props = load_props(testfile);\n     alt cx.config.mode {\n-      mode_compile_fail. { run_cfail_test(cx, props, testfile); }\n-      mode_run_fail. { run_rfail_test(cx, props, testfile); }\n-      mode_run_pass. { run_rpass_test(cx, props, testfile); }\n-      mode_pretty. { run_pretty_test(cx, props, testfile); }\n+      mode_compile_fail { run_cfail_test(cx, props, testfile); }\n+      mode_run_fail { run_rfail_test(cx, props, testfile); }\n+      mode_run_pass { run_rpass_test(cx, props, testfile); }\n+      mode_pretty { run_pretty_test(cx, props, testfile); }\n     }\n }\n \n@@ -96,7 +96,7 @@ fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n     } else { logv(cx.config, \"testing for converging pretty-printing\"); }\n \n     let rounds =\n-        alt props.pp_exact { option::some(_) { 1 } option::none. { 2 } };\n+        alt props.pp_exact { option::some(_) { 1 } option::none { 2 } };\n \n     let srcs = [result::get(io::read_whole_file_str(testfile))];\n \n@@ -120,7 +120,7 @@ fn run_pretty_test(cx: cx, props: test_props, testfile: str) {\n             let filepath = fs::connect(fs::dirname(testfile), file);\n             result::get(io::read_whole_file_str(filepath))\n           }\n-          option::none. { srcs[vec::len(srcs) - 2u] }\n+          option::none { srcs[vec::len(srcs) - 2u] }\n         };\n     let actual = srcs[vec::len(srcs) - 1u];\n \n@@ -326,7 +326,7 @@ fn make_run_args(config: config, _props: test_props, testfile: str) ->\n             let runtool =\n                 alt config.runtool {\n                   option::some(s) { option::some(s) }\n-                  option::none. { option::none }\n+                  option::none { option::none }\n                 };\n             split_maybe_args(runtool)\n         };\n@@ -351,7 +351,7 @@ fn split_maybe_args(argstr: option::t<str>) -> [str] {\n \n     alt argstr {\n       option::some(s) { rm_whitespace(str::split(s, ' ' as u8)) }\n-      option::none. { [] }\n+      option::none { [] }\n     }\n }\n "}, {"sha": "c18dad3b22a1001796f1392b9bab91b9cdf9ce02", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -12,7 +12,7 @@ fn make_new_path(path: str) -> str {\n       option::some(curr) {\n         #fmt[\"%s%s%s\", path, path_div(), curr]\n       }\n-      option::none. { path }\n+      option::none { path }\n     }\n }\n "}, {"sha": "be00d8153e6bc00fddf222bf29a587d8b6731286", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -61,7 +61,7 @@ pure fn safe_to_steal_expr(e: @ast::expr, tm: test_mode) -> bool {\n \n pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n     alt tm {\n-      tm_converge. {\n+      tm_converge {\n         alt e.node {\n           // If the fuzzer moves a block-ending-in-semicolon into callee position,\n           // the pretty-printer can't preserve this even by parenthesizing!!\n@@ -83,8 +83,8 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           ast::expr_assign(_, _) { false }\n           ast::expr_assign_op(_, _, _) { false }\n \n-          ast::expr_fail(option::none.) { false }\n-          ast::expr_ret(option::none.) { false }\n+          ast::expr_fail(option::none) { false }\n+          ast::expr_ret(option::none) { false }\n \n           // https://github.com/graydon/rust/issues/953\n           ast::expr_fail(option::some(_)) { false }\n@@ -102,7 +102,7 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           _ { true }\n         }\n       }\n-      tm_run. { true }\n+      tm_run { true }\n     }\n }\n \n@@ -166,7 +166,7 @@ fn safe_to_replace_expr(e: ast::expr_, _tm: test_mode) -> bool {\n fn safe_to_replace_ty(t: ast::ty_, _tm: test_mode) -> bool {\n     alt t {\n       ast::ty_infer. { false } // always implicit, always top level\n-      ast::ty_bot. { false }   // in source, can only appear as the out type of a function\n+      ast::ty_bot { false }   // in source, can only appear as the out type of a function\n       ast::ty_mac(_) { false }\n       _ { true }\n     }\n@@ -268,10 +268,10 @@ fn check_variants_T<T: copy>(\n                         io::string_reader(\"\"), _,\n                         pprust::no_ann()));\n                 alt cx.mode {\n-                  tm_converge. {\n+                  tm_converge {\n                     check_roundtrip_convergence(str3, 1u);\n                   }\n-                  tm_run. {\n+                  tm_run {\n                     let file_label = #fmt(\"rusttmp/%s_%s_%u_%u\", last_part(filename), thing_label, i, j);\n                     let safe_to_run = !(content_is_dangerous_to_run(str3) || has_raw_pointers(*crate2));\n                     check_whole_compiler(str3, file_label, safe_to_run);\n@@ -301,12 +301,12 @@ fn check_whole_compiler(code: str, suggested_filename_prefix: str, allow_running\n     let compile_result = check_compiling(filename);\n \n     let run_result = alt (compile_result, allow_running) {\n-      (passed., true) { check_running(suggested_filename_prefix) }\n+      (passed, true) { check_running(suggested_filename_prefix) }\n       (h, _) { h }\n     };\n \n     alt run_result {\n-      passed. | cleanly_rejected(_) | known_bug(_) {\n+      passed | cleanly_rejected(_) | known_bug(_) {\n         removeIfExists(suggested_filename_prefix);\n         removeIfExists(suggested_filename_prefix + \".rs\");\n         removeDirIfExists(suggested_filename_prefix + \".dSYM\");"}, {"sha": "3d7fa5ec3e8a74b29f00a465a6892f2ce3689a55", "filename": "src/libcore/char.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -95,7 +95,7 @@ pure fn is_alphanumeric(c: char) -> bool {\n pure fn to_digit(c: char) -> u8 unsafe {\n     alt maybe_digit(c) {\n       option::some(x) { x }\n-      option::none. { fail; }\n+      option::none { fail; }\n     }\n }\n "}, {"sha": "9e97c113359326052e675e0b26b8bd0242090dd8", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -120,7 +120,7 @@ mod ct {\n         if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n         let n = c - ('0' as u8) as uint;\n         ret alt peek_num(s, i + 1u, lim) {\n-              none. { some({num: n, next: i + 1u}) }\n+              none { some({num: n, next: i + 1u}) }\n               some(next) {\n                 let m = next.num;\n                 let j = next.next;\n@@ -148,7 +148,7 @@ mod ct {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n         ret alt num {\n-              none. { {param: none, next: i} }\n+              none { {param: none, next: i} }\n               some(t) {\n                 let n = t.num;\n                 let j = t.next;\n@@ -194,13 +194,13 @@ mod ct {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 alt param.param {\n-                  none. { {count: count_is_next_param, next: j} }\n+                  none { {count: count_is_next_param, next: j} }\n                   some(n) { {count: count_is_param(n), next: j} }\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 alt num {\n-                  none. { {count: count_implied, next: i} }\n+                  none { {count: count_implied, next: i} }\n                   some(num) {\n                     {count: count_is(num.num as int), next: num.next}\n                   }\n@@ -218,7 +218,7 @@ mod ct {\n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n                 alt count.count {\n-                  count_implied. { {count: count_is(0), next: count.next} }\n+                  count_implied { {count: count_is(0), next: count.next} }\n                   _ { count }\n                 }\n             } else { {count: count_implied, next: i} };\n@@ -300,11 +300,11 @@ mod rt {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n-              ty_default. { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n+              ty_default { uint_to_str_prec(u, 10u, prec) }\n+              ty_hex_lower { uint_to_str_prec(u, 16u, prec) }\n+              ty_hex_upper { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n+              ty_bits { uint_to_str_prec(u, 2u, prec) }\n+              ty_octal { uint_to_str_prec(u, 8u, prec) }\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n@@ -325,7 +325,7 @@ mod rt {\n         // FIXME: substr works on bytes, not chars!\n         let unpadded =\n             alt cv.precision {\n-              count_implied. { s }\n+              count_implied { s }\n               count_is(max) {\n                 if max as uint < str::char_len(s) {\n                     str::substr(s, 0u, max as uint)\n@@ -337,7 +337,7 @@ mod rt {\n     fn conv_float(cv: conv, f: float) -> str {\n         let (to_str, digits) = alt cv.precision {\n               count_is(c) { (float::to_str_exact, c as uint) }\n-              count_implied. { (float::to_str, 6u) }\n+              count_implied { (float::to_str, 6u) }\n         };\n         let s = to_str(f, digits);\n         if 0.0 <= f {\n@@ -381,7 +381,7 @@ mod rt {\n     fn get_int_precision(cv: conv) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n-              count_implied. { 1u }\n+              count_implied { 1u }\n             };\n     }\n \n@@ -395,7 +395,7 @@ mod rt {\n     fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n-          count_implied. { ret s; }\n+          count_implied { ret s; }\n           count_is(width) {\n             // FIXME: Maybe width should be uint\n \n@@ -413,15 +413,15 @@ mod rt {\n         let might_zero_pad = false;\n         let signed = false;\n         alt mode {\n-          pad_nozero. {\n+          pad_nozero {\n             // fallthrough\n \n           }\n-          pad_signed. { might_zero_pad = true; signed = true; }\n-          pad_unsigned. { might_zero_pad = true; }\n+          pad_signed { might_zero_pad = true; signed = true; }\n+          pad_unsigned { might_zero_pad = true; }\n         }\n         fn have_precision(cv: conv) -> bool {\n-            ret alt cv.precision { count_implied. { false } _ { true } };\n+            ret alt cv.precision { count_implied { false } _ { true } };\n         }\n         let zero_padding = false;\n         if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&"}, {"sha": "89d1171e1d6b1056db6761806df59b2fd232f367", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -31,13 +31,13 @@ Failure:\n Fails if the value equals `none`.\n */\n pure fn get<T: copy>(opt: t<T>) -> T {\n-    alt opt { some(x) { ret x; } none. { fail \"option none\"; } }\n+    alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n }\n \n /*\n */\n fn map<T, U: copy>(opt: t<T>, f: block(T) -> U) -> t<U> {\n-    alt opt { some(x) { some(f(x)) } none. { none } }\n+    alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n /*\n@@ -46,7 +46,7 @@ Function: is_none\n Returns true if the option equals none\n */\n pure fn is_none<T>(opt: t<T>) -> bool {\n-    alt opt { none. { true } some(_) { false } }\n+    alt opt { none { true } some(_) { false } }\n }\n \n /*\n@@ -62,7 +62,7 @@ Function: from_maybe\n Returns the contained value or a default\n */\n pure fn from_maybe<T: copy>(def: T, opt: t<T>) -> T {\n-    alt opt { some(x) { x } none. { def } }\n+    alt opt { some(x) { x } none { def } }\n }\n \n /*\n@@ -71,7 +71,7 @@ Function: maybe\n Applies a function to the contained value or returns a default\n */\n fn maybe<T, U: copy>(def: U, opt: t<T>, f: block(T) -> U) -> U {\n-    alt opt { none. { def } some(t) { f(t) } }\n+    alt opt { none { def } some(t) { f(t) } }\n }\n \n // FIXME: Can be defined in terms of the above when/if we have const bind.\n@@ -81,7 +81,7 @@ Function: may\n Performs an operation on the contained value or does nothing\n */\n fn may<T>(opt: t<T>, f: block(T)) {\n-    alt opt { none. {/* nothing */ } some(t) { f(t); } }\n+    alt opt { none {/* nothing */ } some(t) { f(t); } }\n }\n \n #[test]"}, {"sha": "e56153e54ecad10b62766c7f60fb48ecfa021a95", "filename": "src/libcore/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -369,8 +369,8 @@ fn try<T:send>(+f: fn~() -> T) -> result::t<T,()> {\n         unsupervise();\n         comm::send(ch, f());\n     }) {\n-      tr_success. { result::ok(comm::recv(p)) }\n-      tr_failure. { result::err(()) }\n+      tr_success { result::ok(comm::recv(p)) }\n+      tr_failure { result::err(()) }\n     }\n }\n \n@@ -405,7 +405,7 @@ mod tests {\n \n         let t = spawn_joinable {|| winner();};\n         alt join(t) {\n-          tr_success. {/* yay! */ }\n+          tr_success {/* yay! */ }\n           _ { fail \"invalid task status received\" }\n         }\n     }\n@@ -418,7 +418,7 @@ mod tests {\n \n         let t = spawn_joinable {|| failer();};\n         alt join(t) {\n-          tr_failure. {/* yay! */ }\n+          tr_failure {/* yay! */ }\n           _ { fail \"invalid task status received\" }\n         }\n     }"}, {"sha": "5bab771ab7d95fb6d66688cefc61808108f244e5", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -48,7 +48,7 @@ tag t<T> {\n \n resource dtor_res(dtor: option::t<fn@()>) {\n     alt dtor {\n-      option::none. { }\n+      option::none { }\n       option::some(f) { f(); }\n     }\n }"}, {"sha": "fafec1894146220b33abc2dd55f2b2f69289b8c7", "filename": "src/libstd/ebml.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -66,7 +66,7 @@ fn maybe_get_doc(d: doc, tg: uint) -> option::t<doc> {\n fn get_doc(d: doc, tg: uint) -> doc {\n     alt maybe_get_doc(d, tg) {\n       some(d) { ret d; }\n-      none. {\n+      none {\n         #error(\"failed to find block with tag %u\", tg);\n         fail;\n       }"}, {"sha": "a729fba905f43d975f055580f198c739c20b7e2c", "filename": "src/libstd/extfmt.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fextfmt.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -119,7 +119,7 @@ mod ct {\n         if !('0' as u8 <= c && c <= '9' as u8) { ret option::none; }\n         let n = c - ('0' as u8) as uint;\n         ret alt peek_num(s, i + 1u, lim) {\n-              none. { some({num: n, next: i + 1u}) }\n+              none { some({num: n, next: i + 1u}) }\n               some(next) {\n                 let m = next.num;\n                 let j = next.next;\n@@ -147,7 +147,7 @@ mod ct {\n         if i >= lim { ret {param: none, next: i}; }\n         let num = peek_num(s, i, lim);\n         ret alt num {\n-              none. { {param: none, next: i} }\n+              none { {param: none, next: i} }\n               some(t) {\n                 let n = t.num;\n                 let j = t.next;\n@@ -193,13 +193,13 @@ mod ct {\n                 let param = parse_parameter(s, i + 1u, lim);\n                 let j = param.next;\n                 alt param.param {\n-                  none. { {count: count_is_next_param, next: j} }\n+                  none { {count: count_is_next_param, next: j} }\n                   some(n) { {count: count_is_param(n), next: j} }\n                 }\n             } else {\n                 let num = peek_num(s, i, lim);\n                 alt num {\n-                  none. { {count: count_implied, next: i} }\n+                  none { {count: count_implied, next: i} }\n                   some(num) {\n                     {count: count_is(num.num as int), next: num.next}\n                   }\n@@ -217,7 +217,7 @@ mod ct {\n                 // If there were no digits specified, i.e. the precision\n                 // was \".\", then the precision is 0\n                 alt count.count {\n-                  count_implied. { {count: count_is(0), next: count.next} }\n+                  count_implied { {count: count_is(0), next: count.next} }\n                   _ { count }\n                 }\n             } else { {count: count_implied, next: i} };\n@@ -297,11 +297,11 @@ mod rt {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n-              ty_default. { uint_to_str_prec(u, 10u, prec) }\n-              ty_hex_lower. { uint_to_str_prec(u, 16u, prec) }\n-              ty_hex_upper. { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n-              ty_bits. { uint_to_str_prec(u, 2u, prec) }\n-              ty_octal. { uint_to_str_prec(u, 8u, prec) }\n+              ty_default { uint_to_str_prec(u, 10u, prec) }\n+              ty_hex_lower { uint_to_str_prec(u, 16u, prec) }\n+              ty_hex_upper { str::to_upper(uint_to_str_prec(u, 16u, prec)) }\n+              ty_bits { uint_to_str_prec(u, 2u, prec) }\n+              ty_octal { uint_to_str_prec(u, 8u, prec) }\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n@@ -322,7 +322,7 @@ mod rt {\n         // FIXME: substr works on bytes, not chars!\n         let unpadded =\n             alt cv.precision {\n-              count_implied. { s }\n+              count_implied { s }\n               count_is(max) {\n                 if max as uint < str::char_len(s) {\n                     str::substr(s, 0u, max as uint)\n@@ -334,7 +334,7 @@ mod rt {\n     fn conv_float(cv: conv, f: float) -> str {\n         let (to_str, digits) = alt cv.precision {\n               count_is(c) { (float::to_str_exact, c as uint) }\n-              count_implied. { (float::to_str, 6u) }\n+              count_implied { (float::to_str, 6u) }\n         };\n         let s = to_str(f, digits);\n         if 0.0 <= f {\n@@ -374,7 +374,7 @@ mod rt {\n     fn get_int_precision(cv: conv) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n-              count_implied. { 1u }\n+              count_implied { 1u }\n             };\n     }\n \n@@ -388,7 +388,7 @@ mod rt {\n     fn pad(cv: conv, s: str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n-          count_implied. { ret s; }\n+          count_implied { ret s; }\n           count_is(width) {\n             // FIXME: Maybe width should be uint\n \n@@ -406,15 +406,15 @@ mod rt {\n         let might_zero_pad = false;\n         let signed = false;\n         alt mode {\n-          pad_nozero. {\n+          pad_nozero {\n             // fallthrough\n \n           }\n-          pad_signed. { might_zero_pad = true; signed = true; }\n-          pad_unsigned. { might_zero_pad = true; }\n+          pad_signed { might_zero_pad = true; signed = true; }\n+          pad_unsigned { might_zero_pad = true; }\n         }\n         fn have_precision(cv: conv) -> bool {\n-            ret alt cv.precision { count_implied. { false } _ { true } };\n+            ret alt cv.precision { count_implied { false } _ { true } };\n         }\n         let zero_padding = false;\n         if might_zero_pad && have_flag(cv.flags, flag_left_zero_pad) &&"}, {"sha": "cbfca163c1838b417d7adcdfd511363ac31c1120", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -433,7 +433,7 @@ fn homedir() -> option<path> {\n                 secondary()\n             }\n         }\n-        none. {\n+        none {\n             secondary()\n         }\n     };"}, {"sha": "34a393b6a8e7540583bbb9355de8110111d806b1", "filename": "src/libstd/fun_treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ffun_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ffun_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffun_treemap.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -52,7 +52,7 @@ Insert a value into the map\n */\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) -> treemap<K, V> {\n     @alt m {\n-       @empty. { node(@k, @v, @empty, @empty) }\n+       @empty { node(@k, @v, @empty, @empty) }\n        @node(@kk, vv, left, right) {\n          if k < kk {\n              node(@kk, vv, insert(left, k, v), right)\n@@ -70,7 +70,7 @@ Find a value based on the key\n */\n fn find<K, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n-      empty. { none }\n+      empty { none }\n       node(@kk, @v, left, right) {\n         if k == kk {\n             some(v)\n@@ -86,7 +86,7 @@ Visit all pairs in the map in order.\n */\n fn traverse<K, V: copy>(m: treemap<K, V>, f: block(K, V)) {\n     alt *m {\n-      empty. { }\n+      empty { }\n       node(@k, @v, _, _) {\n         // copy v to make aliases work out\n         let v1 = v;"}, {"sha": "39b6de0e34fb31cd5da4136780a6af742412eade", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -255,24 +255,24 @@ fn getopts(args: [str], opts: [opt]) -> result {\n                 let optid;\n                 alt find_opt(opts, nm) {\n                   some(id) { optid = id; }\n-                  none. { ret err(unrecognized_option(name_str(nm))); }\n+                  none { ret err(unrecognized_option(name_str(nm))); }\n                 }\n                 alt opts[optid].hasarg {\n-                  no. {\n+                  no {\n                     if !option::is_none::<str>(i_arg) {\n                         ret err(unexpected_argument(name_str(nm)));\n                     }\n                     vals[optid] += [given];\n                   }\n-                  maybe. {\n+                  maybe {\n                     if !option::is_none::<str>(i_arg) {\n                         vals[optid] += [val(option::get(i_arg))];\n                     } else if name_pos < vec::len::<name>(names) ||\n                                   i + 1u == l || is_arg(args[i + 1u]) {\n                         vals[optid] += [given];\n                     } else { i += 1u; vals[optid] += [val(args[i])]; }\n                   }\n-                  yes. {\n+                  yes {\n                     if !option::is_none::<str>(i_arg) {\n                         vals[optid] += [val(option::get::<str>(i_arg))];\n                     } else if i + 1u == l {\n@@ -306,7 +306,7 @@ fn getopts(args: [str], opts: [opt]) -> result {\n fn opt_vals(m: match, nm: str) -> [optval] {\n     ret alt find_opt(m.opts, mkname(nm)) {\n           some(id) { m.vals[id] }\n-          none. { #error(\"No option '%s' defined\", nm); fail }\n+          none { #error(\"No option '%s' defined\", nm); fail }\n         };\n }\n "}, {"sha": "9a0cb10c8588933c9bf8748c6cbde8a7747652ff", "filename": "src/libstd/io.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -160,9 +160,9 @@ impl reader_util for reader {\n \n fn convert_whence(whence: seek_style) -> i32 {\n     ret alt whence {\n-      seek_set. { 0i32 }\n-      seek_cur. { 1i32 }\n-      seek_end. { 2i32 }\n+      seek_set { 0i32 }\n+      seek_cur { 1i32 }\n+      seek_end { 2i32 }\n     };\n }\n \n@@ -347,10 +347,10 @@ fn mk_file_writer(path: str, flags: [fileflag])\n         os::libc_constants::O_WRONLY | os::libc_constants::O_BINARY;\n     for f: fileflag in flags {\n         alt f {\n-          append. { fflags |= os::libc_constants::O_APPEND; }\n-          create. { fflags |= os::libc_constants::O_CREAT; }\n-          truncate. { fflags |= os::libc_constants::O_TRUNC; }\n-          none. { }\n+          append { fflags |= os::libc_constants::O_APPEND; }\n+          create { fflags |= os::libc_constants::O_CREAT; }\n+          truncate { fflags |= os::libc_constants::O_TRUNC; }\n+          none { }\n         }\n     }\n     let fd = str::as_buf(path, {|pathbuf|\n@@ -469,9 +469,9 @@ fn seek_in_buf(offset: int, pos: uint, len: uint, whence: seek_style) ->\n     let bpos = pos as int;\n     let blen = len as int;\n     alt whence {\n-      seek_set. { bpos = offset; }\n-      seek_cur. { bpos += offset; }\n-      seek_end. { bpos = blen + offset; }\n+      seek_set { bpos = offset; }\n+      seek_cur { bpos += offset; }\n+      seek_end { bpos = blen + offset; }\n     }\n     if bpos < 0 { bpos = 0; } else if bpos > blen { bpos = blen; }\n     ret bpos as uint;\n@@ -512,7 +512,7 @@ mod fsync {\n     // Resource of artifacts that need to fsync on destruction\n     resource res<t>(arg: arg<t>) {\n         alt arg.opt_level {\n-          option::none. { }\n+          option::none { }\n           option::some(level) {\n             // fail hard if not succesful\n             assert(arg.fsync_fn(arg.val, level) != -1);"}, {"sha": "03aef97857f3836944a227e13efe90ebb8b22a07", "filename": "src/libstd/list.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -67,9 +67,9 @@ fn find<T: copy, U: copy>(ls: list<T>, f: block(T) -> option::t<U>)\n     while true {\n         alt ls {\n           cons(hd, tl) {\n-            alt f(hd) { none. { ls = *tl; } some(rs) { ret some(rs); } }\n+            alt f(hd) { none { ls = *tl; } some(rs) { ret some(rs); } }\n           }\n-          nil. { break; }\n+          nil { break; }\n         }\n     }\n     ret none;\n@@ -85,7 +85,7 @@ fn has<T: copy>(ls: list<T>, elt: T) -> bool {\n     while true {\n         alt ls {\n           cons(hd, tl) { if elt == hd { ret true; } else { ls = *tl; } }\n-          nil. { break; }\n+          nil { break; }\n         }\n     }\n     ret false;\n@@ -98,7 +98,7 @@ Returns true if the list is empty.\n */\n pure fn is_empty<T: copy>(ls: list<T>) -> bool {\n     alt ls {\n-        nil. { true }\n+        nil { true }\n         _ { false }\n     }\n }\n@@ -131,7 +131,7 @@ Returns all but the first element of a list\n pure fn tail<T: copy>(ls: list<T>) : is_not_empty(ls) -> list<T> {\n     alt ls {\n         cons(_, tl) { ret *tl; }\n-        nil. { fail \"list empty\" }\n+        nil { fail \"list empty\" }\n     }\n }\n \n@@ -143,7 +143,7 @@ Returns the first element of a list\n pure fn head<T: copy>(ls: list<T>) : is_not_empty(ls) -> T {\n     alt ls {\n         cons(hd, _) { ret hd; }\n-        nil. { fail \"list empty\" }\n+        nil { fail \"list empty\" }\n     }\n }\n \n@@ -154,7 +154,7 @@ Appends one list to another\n */\n pure fn append<T: copy>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n-      nil. { ret m; }\n+      nil { ret m; }\n       cons(x, xs) { let rest = append(*xs, m); ret cons(x, @rest); }\n     }\n }\n@@ -175,11 +175,11 @@ fn iter<T>(l: list<T>, f: block(T)) {\n                 f(hd);\n                 cur = tl;\n               }\n-              nil. { break; }\n+              nil { break; }\n             }\n         }\n       }\n-      nil. {}\n+      nil {}\n     }\n }\n "}, {"sha": "9496f2febedc2adff05a977f6097419ebb4ceede", "filename": "src/libstd/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -137,7 +137,7 @@ mod chained {\n         let comp = 1u;   // for logging\n         while true {\n             alt e0.next {\n-              absent. {\n+              absent {\n                 #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                        comp, h, idx);\n                 ret not_found;\n@@ -162,7 +162,7 @@ mod chained {\n         tbl: t<K,V>, k: K, h: uint) -> search_result<K,V> {\n         let idx = h % vec::len(tbl.chains);\n         alt tbl.chains[idx] {\n-          absent. {\n+          absent {\n             #debug(\"search_tbl: absent, comp %u, hash %u, idx %u\",\n                    0u, h, idx);\n             ret not_found;\n@@ -183,7 +183,7 @@ mod chained {\n     fn insert<K: copy, V: copy>(tbl: t<K,V>, k: K, v: V) -> bool {\n         let hash = tbl.hasher(k);\n         alt search_tbl(tbl, k, hash) {\n-          not_found. {\n+          not_found {\n             tbl.size += 1u;\n             let idx = hash % vec::len(tbl.chains);\n             let old_chain = tbl.chains[idx];\n@@ -207,7 +207,7 @@ mod chained {\n \n     fn get<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found. {\n+          not_found {\n             ret core::option::none;\n           }\n \n@@ -223,7 +223,7 @@ mod chained {\n \n     fn remove<K: copy, V: copy>(tbl: t<K,V>, k: K) -> core::option::t<V> {\n         alt search_tbl(tbl, k, tbl.hasher(k)) {\n-          not_found. {\n+          not_found {\n             ret core::option::none;\n           }\n \n@@ -250,7 +250,7 @@ mod chained {\n         let chain = chain0;\n         while true {\n             alt chain {\n-              absent. { ret; }\n+              absent { ret; }\n               present(entry) {\n                 let next = entry.next;\n                 blk(entry); // may modify entry.next!\n@@ -569,7 +569,7 @@ mod tests {\n             let v = hm.remove(i);\n             alt v {\n               option::some(u) { assert (u == i * i); }\n-              option::none. { fail; }\n+              option::none { fail; }\n             }\n             i += 2u;\n         }"}, {"sha": "013e903f7e08824ad2da52f7c8b659db4d930a89", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -156,10 +156,10 @@ Concatenate two ropes\n  */\n fn append_rope(left: rope, right: rope) -> rope {\n    alt(left) {\n-     node::empty. { ret right; }\n+     node::empty { ret right; }\n      node::content(left_content) {\n        alt(right) {\n-         node::empty. { ret left; }\n+         node::empty { ret left; }\n      node::content(right_content) {\n            ret node::content(node::concat2(left_content, right_content));\n      }\n@@ -224,10 +224,10 @@ to rebalance your rope at some point, before using it for other purposes.\n  */\n fn bal(rope:rope) -> rope {\n     alt(rope) {\n-      node::empty. { ret rope }\n+      node::empty { ret rope }\n       node::content(x) {\n         alt(node::bal(x)) {\n-          option::none.   { rope }\n+          option::none   { rope }\n           option::some(y) { node::content(y) }\n         }\n       }\n@@ -255,7 +255,7 @@ valid positions in rope\n fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n     if char_len == 0u { ret node::empty; }\n     alt(rope) {\n-      node::empty. { fail }\n+      node::empty { fail }\n       node::content(node) {\n         if char_len > node::char_len(node) { fail }\n         else {\n@@ -281,7 +281,7 @@ valid positions in rope\n fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n     if byte_len == 0u { ret node::empty; }\n     alt(rope) {\n-      node::empty. { fail }\n+      node::empty { fail }\n       node::content(node) {\n         if byte_len > node::byte_len(node) { fail }\n         else {\n@@ -309,9 +309,9 @@ value if `left > right`\n */\n fn cmp(left: rope, right: rope) -> int {\n     alt((left, right)) {\n-      (node::empty., node::empty.) { ret 0; }\n-      (node::empty., _)     { ret -1;}\n-      (_, node::empty.)     { ret  1;}\n+      (node::empty, node::empty) { ret 0; }\n+      (node::empty, _)     { ret -1;}\n+      (_, node::empty)     { ret  1;}\n       (node::content(a), node::content(b)) {\n         ret node::cmp(a, b);\n       }\n@@ -421,7 +421,7 @@ that is if `it` returned `false` at any point.\n  */\n fn loop_chars(rope: rope, it: block(char) -> bool) -> bool {\n    alt(rope) {\n-      node::empty. { ret true }\n+      node::empty { ret true }\n       node::content(x) { ret node::loop_chars(x, it) }\n    }\n }\n@@ -432,7 +432,7 @@ Function: iter_chars\n Loop through a rope, char by char, until the end.\n \n Parameters:\n-rope - A rope to traverse. It may be empty.\n+rope - A rope to traverse. It may be empty\n it - A block to execute with each consecutive character of the rope.\n  */\n fn iter_chars(rope: rope, it: block(char)) {\n@@ -457,9 +457,9 @@ use `traverse`.\n \n Parameters:\n \n-rope - A rope to traverse. It may be empty.\n+rope - A rope to traverse. It may be empty\n it - A block to execute with each consecutive string component of the rope.\n-Return `true` to continue, `false` to stop.\n+Return `true` to continue, `false` to stop\n \n Returns:\n \n@@ -468,7 +468,7 @@ that is if `it` returned `false` at any point.\n  */\n fn loop_leaves(rope: rope, it: block(node::leaf) -> bool) -> bool{\n    alt(rope) {\n-      node::empty. { ret true }\n+      node::empty { ret true }\n       node::content(x) {ret node::loop_leaves(x, it)}\n    }\n }\n@@ -477,7 +477,7 @@ mod iterator {\n     mod leaf {\n         fn start(rope: rope) -> node::leaf_iterator::t {\n             alt(rope) {\n-              node::empty.     { ret node::leaf_iterator::empty() }\n+              node::empty     { ret node::leaf_iterator::empty() }\n               node::content(x) { ret node::leaf_iterator::start(x) }\n             }\n         }\n@@ -488,7 +488,7 @@ mod iterator {\n     mod char {\n         fn start(rope: rope) -> node::char_iterator::t {\n             alt(rope) {\n-              node::empty.   { ret node::char_iterator::empty() }\n+              node::empty   { ret node::char_iterator::empty() }\n               node::content(x) { ret node::char_iterator::start(x) }\n             }\n         }\n@@ -513,7 +513,7 @@ finding the leaf in which a character is contained.\n */\n fn height(rope: rope) -> uint {\n    alt(rope) {\n-      node::empty.    { ret 0u; }\n+      node::empty    { ret 0u; }\n       node::content(x) { ret node::height(x); }\n    }\n }\n@@ -529,7 +529,7 @@ fn height(rope: rope) -> uint {\n  */\n pure fn char_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty.           { ret 0u; }\n+     node::empty           { ret 0u; }\n      node::content(x)       { ret node::char_len(x) }\n    }\n }\n@@ -543,7 +543,7 @@ pure fn char_len(rope: rope) -> uint {\n  */\n pure fn byte_len(rope: rope) -> uint {\n    alt(rope) {\n-     node::empty.           { ret 0u; }\n+     node::empty           { ret 0u; }\n      node::content(x)       { ret node::byte_len(x) }\n    }\n }\n@@ -565,7 +565,7 @@ pure fn byte_len(rope: rope) -> uint {\n  */\n fn char_at(rope: rope, pos: uint) -> char {\n    alt(rope) {\n-      node::empty. { fail }\n+      node::empty { fail }\n       node::content(x) { ret node::char_at(x, pos) }\n    }\n }\n@@ -730,7 +730,7 @@ mod node {\n \n     If the slice is longer than `max_leaf_char_len`, it is logically split\n     between as many leaves as necessary. Regardless, the string itself\n-    is not copied.\n+    is not copied\n \n     Parameters:\n     byte_start - The byte offset where the slice of `str` starts.\n@@ -752,7 +752,7 @@ mod node {\n \n     If the slice is longer than `max_leaf_char_len`, it is logically split\n     between as many leaves as necessary. Regardless, the string itself\n-    is not copied.\n+    is not copied\n \n     byte_start - The byte offset where the slice of `str` starts.\n     byte_len   - The number of bytes from `str` to use.\n@@ -897,7 +897,7 @@ mod node {\n         let it = leaf_iterator::start(node);\n         while true {\n             alt(leaf_iterator::next(it)) {\n-              option::none. { break; }\n+              option::none { break; }\n               option::some(x) {\n                 //TODO: Replace with memcpy or something similar\n                 let local_buf: [u8] = unsafe::reinterpret_cast(*x.content);\n@@ -959,7 +959,7 @@ mod node {\n         let it = leaf_iterator::start(node);\n         while true {\n             alt (leaf_iterator::next(it)) {\n-              option::none.   { break; }\n+              option::none   { break; }\n               option::some(x) { forest += [mutable @leaf(x)]; }\n             }\n         }\n@@ -1117,7 +1117,7 @@ mod node {\n         let pos = 0u;\n         while result == 0 {\n             alt((char_iterator::next(ita), char_iterator::next(itb))) {\n-              (option::none., option::none.) {\n+              (option::none, option::none) {\n                 break;\n               }\n               (option::some(chara), option::some(charb)) {\n@@ -1152,7 +1152,7 @@ mod node {\n \n     rope - A node to traverse.\n     it - A block to execute with each consecutive leaf of the node.\n-    Return `true` to continue, `false` to stop.\n+    Return `true` to continue, `false` to stop\n \n     Returns:\n \n@@ -1277,11 +1277,11 @@ mod node {\n         fn next(it: t) -> option::t<char> {\n             while true {\n                 alt(get_current_or_next_leaf(it)) {\n-                  option::none. { ret option::none; }\n+                  option::none { ret option::none; }\n                   option::some(_) {\n                     let next_char = get_next_char_in_leaf(it);\n                     alt(next_char) {\n-                      option::none. {\n+                      option::none {\n                         cont;\n                       }\n                       option::some(_) {\n@@ -1297,10 +1297,10 @@ mod node {\n         fn get_current_or_next_leaf(it: t) -> option::t<leaf> {\n             alt(it.leaf) {\n               option::some(_) { ret it.leaf }\n-              option::none. {\n+              option::none {\n                 let next = leaf_iterator::next(it.leaf_iterator);\n                 alt(next) {\n-                  option::none. { ret option::none }\n+                  option::none { ret option::none }\n                   option::some(_) {\n                     it.leaf          = next;\n                     it.leaf_byte_pos = 0u;\n@@ -1313,7 +1313,7 @@ mod node {\n \n         fn get_next_char_in_leaf(it: t) -> option::t<char> {\n             alt(it.leaf) {\n-              option::none. { ret option::none }\n+              option::none { ret option::none }\n               option::some(aleaf) {\n                 if it.leaf_byte_pos >= aleaf.byte_len {\n                     //We are actually past the end of the leaf\n@@ -1338,7 +1338,7 @@ mod tests {\n     //Utility function, used for sanity check\n     fn rope_to_string(r: rope) -> str {\n         alt(r) {\n-          node::empty. { ret \"\" }\n+          node::empty { ret \"\" }\n           node::content(x) {\n             let str = @mutable \"\";\n             fn aux(str: @mutable str, node: @node::node) {\n@@ -1392,7 +1392,7 @@ mod tests {\n         let pos         = 0u;\n         while equal {\n             alt(node::char_iterator::next(rope_iter)) {\n-              option::none. {\n+              option::none {\n                 if string_iter < string_len {\n                     equal = false;\n                 } break; }\n@@ -1420,7 +1420,7 @@ mod tests {\n         let it  = iterator::char::start(r);\n         while true {\n             alt(node::char_iterator::next(it)) {\n-              option::none. { break; }\n+              option::none { break; }\n               option::some(_) { len += 1u; }\n             }\n         }"}, {"sha": "36c9e1281c238af04e249e4a78e939a8e7fa6ac8", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -38,7 +38,7 @@ fn insert<T: copy>(m: smallintmap<T>, key: uint, val: T) {\n Function: find\n \n Get the value for the specified key. If the key does not exist\n-in the map then returns none.\n+in the map then returns none\n */\n fn find<T: copy>(m: smallintmap<T>, key: uint) -> option::t<T> {\n     if key < vec::len::<option::t<T>>(m.v) { ret m.v[key]; }\n@@ -56,7 +56,7 @@ If the key does not exist in the map\n */\n fn get<T: copy>(m: smallintmap<T>, key: uint) -> T {\n     alt find(m, key) {\n-      none. { #error(\"smallintmap::get(): key not present\"); fail; }\n+      none { #error(\"smallintmap::get(): key not present\"); fail; }\n       some(v) { ret v; }\n     }\n }\n@@ -117,7 +117,7 @@ impl <V: copy> of map::map<uint, V> for smallintmap<V> {\n               some(elt) {\n                 it(idx, elt);\n               }\n-              none. { }\n+              none { }\n             }\n             idx += 1u;\n         }"}, {"sha": "eb9b977455dcb2af911d8f9e4dff7db2ac3117f5", "filename": "src/libstd/term.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fterm.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -72,7 +72,7 @@ fn color_supported() -> bool {\n             }\n             false\n           }\n-          option::none. { false }\n+          option::none { false }\n         };\n }\n "}, {"sha": "fbb87d93e857d1d3782b8cea9feaacb7b51e2b0e", "filename": "src/libstd/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -131,18 +131,18 @@ fn run_tests_console_<T: copy>(opts: test_opts, tests: [test_desc<T>],\n           te_wait(test) { st.out.write_str(#fmt[\"test %s ... \", test.name]); }\n           te_result(test, result) {\n             alt result {\n-              tr_ok. {\n+              tr_ok {\n                 st.passed += 1u;\n                 write_ok(st.out, st.use_color);\n                 st.out.write_line(\"\");\n               }\n-              tr_failed. {\n+              tr_failed {\n                 st.failed += 1u;\n                 write_failed(st.out, st.use_color);\n                 st.out.write_line(\"\");\n                 st.failures += [test];\n               }\n-              tr_ignored. {\n+              tr_ignored {\n                 st.ignored += 1u;\n                 write_ignored(st.out, st.use_color);\n                 st.out.write_line(\"\");\n@@ -260,7 +260,7 @@ fn filter_tests<T: copy>(opts: test_opts,\n         let filter_str =\n             alt opts.filter {\n           option::some(f) { f }\n-          option::none. { \"\" }\n+          option::none { \"\" }\n         };\n \n         fn filter_fn<T: copy>(test: test_desc<T>, filter_str: str) ->\n@@ -315,11 +315,11 @@ fn run_test<T: copy>(test: test_desc<T>,\n     ret {test: test,\n          wait: fn@() -> test_result {\n              alt task::join(test_task) {\n-               task::tr_success. {\n+               task::tr_success {\n                  if test.should_fail { tr_failed }\n                  else { tr_ok }\n                }\n-               task::tr_failure. {\n+               task::tr_failure {\n                  if test.should_fail { tr_ok }\n                  else { tr_failed }\n                }"}, {"sha": "14e9c30a83c95d77c2d6ba7ce25fe96c9adbf6ae", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -46,7 +46,7 @@ Insert a value into the map\n */\n fn insert<K: copy, V: copy>(m: treemap<K, V>, k: K, v: V) {\n     alt m {\n-      @empty. { *m = node(@k, @v, @mutable empty, @mutable empty); }\n+      @empty { *m = node(@k, @v, @mutable empty, @mutable empty); }\n       @node(@kk, _, _, _) {\n \n         // We have to name left and right individually, because\n@@ -65,7 +65,7 @@ Find a value based on the key\n */\n fn find<K: copy, V: copy>(m: treemap<K, V>, k: K) -> option<V> {\n     alt *m {\n-      empty. { none }\n+      empty { none }\n       node(@kk, @v, _, _) {\n         if k == kk {\n             some(v)\n@@ -85,7 +85,7 @@ Visit all pairs in the map in order.\n */\n fn traverse<K, V>(m: treemap<K, V>, f: block(K, V)) {\n     alt *m {\n-      empty. { }\n+      empty { }\n       node(k, v, _, _) {\n         let k1 = k, v1 = v;\n         alt *m { node(_, _, left, _) { traverse(left, f); } }"}, {"sha": "322e3bf40c27a83e021ce0c50cb0b0916f0d6bf0", "filename": "src/libstd/ufind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fufind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Flibstd%2Fufind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fufind.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -27,7 +27,7 @@ fn grow(ufnd: ufind, n: uint) {\n \n fn find(ufnd: ufind, n: uint) -> uint {\n     alt ufnd.nodes[n] {\n-      none. { ret n; }\n+      none { ret n; }\n       some(m) { let m_ = m; be find(ufnd, m_); }\n     }\n }"}, {"sha": "f952bb1a92f9261b44335f298f887e9425009cd6", "filename": "src/rustdoc/attr_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Frustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Frustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fattr_parser.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -157,21 +157,21 @@ fn parse_short_doc_or<T>(\n       some(meta) {\n         alt attr::get_meta_item_value_str(meta) {\n           some(desc) { handle_short(some(desc)) }\n-          none. {\n+          none {\n             alt attr::get_meta_item_list(meta) {\n               some(list) {\n                 let brief = attr::meta_item_value_from_list(list, \"brief\");\n                 let desc = attr::meta_item_value_from_list(list, \"desc\");\n                 parse_long(list, brief, desc)\n               }\n-              none. {\n+              none {\n                 handle_short(none)\n               }\n             }\n           }\n         }\n       }\n-      none. {\n+      none {\n         handle_short(none)\n       }\n     }\n@@ -213,7 +213,7 @@ fn parse_fn_long_doc(\n             }\n         }\n       }\n-      none. { [] }\n+      none { [] }\n     };\n \n     {"}, {"sha": "160576617d44f6f38ef93054c5089ec931b0f845", "filename": "src/rustdoc/gen.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Frustdoc%2Fgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Frustdoc%2Fgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Fgen.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -121,7 +121,7 @@ fn write_brief(\n         ctxt.w.write_line(brief);\n         ctxt.w.write_line(\"\");\n       }\n-      none. { }\n+      none { }\n     }\n }\n \n@@ -134,7 +134,7 @@ fn write_desc(\n             ctxt.w.write_line(desc);\n             ctxt.w.write_line(\"\");\n         }\n-        none. { }\n+        none { }\n     }\n }\n \n@@ -208,13 +208,13 @@ fn write_return(\n               some(d) {\n                 ctxt.w.write_line(d);\n               }\n-              none. { }\n+              none { }\n             }\n           }\n-          none. { fail \"unimplemented\"; }\n+          none { fail \"unimplemented\"; }\n         }\n       }\n-      none. { }\n+      none { }\n     }\n }\n "}, {"sha": "9c068c6c747a3171ed949c5b020a484cfb299b28", "filename": "src/test/bench/99bob-pattern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2F99bob-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2F99bob-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99bob-pattern.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -12,13 +12,13 @@ tag bottle { none; dual; single; multiple(int); }\n \n fn show(b: bottle) {\n     alt b {\n-      none. {\n+      none {\n         #debug(\"No more bottles of beer on the wall, \\\n                 no more bottles of beer,\");\n         #debug(\"Go to the store and buy some more, \\\n                 99 bottles of beer on the wall.\");\n       }\n-      single. {\n+      single {\n         #debug(\"1 bottle of beer on the wall, 1 bottle of beer,\");\n         #debug(\"Take one down and pass it around, \\\n                 no more bottles of beer on the wall.\");\n@@ -38,8 +38,8 @@ fn show(b: bottle) {\n \n fn next(b: bottle) -> bottle {\n     alt b {\n-      none. { ret none; }\n-      single. { ret none; }\n+      none { ret none; }\n+      single { ret none; }\n       dual. { ret single; }\n       multiple(3) { ret dual; }\n       multiple(n) { ret multiple(n - 1); }\n@@ -48,7 +48,7 @@ fn next(b: bottle) -> bottle {\n \n \n // Won't need this when tags can be compared with ==\n-fn more(b: bottle) -> bool { alt b { none. { ret false; } _ { ret true; } } }\n+fn more(b: bottle) -> bool { alt b { none { ret false; } _ { ret true; } } }\n \n fn main() {\n     let b: bottle = multiple(99);"}, {"sha": "4e72ef84907a2db29fa60d11f7103d6d2e890063", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -5,7 +5,7 @@ tag tree { nil; node(~tree, ~tree, int); }\n \n fn item_check(t: ~tree) -> int {\n     alt *t {\n-      nil. { ret 0; }\n+      nil { ret 0; }\n       node(left, right, item) {\n         ret item + item_check(left) - item_check(right);\n       }"}, {"sha": "6a23664f753803c8282619d5946425ecac4fe81b", "filename": "src/test/bench/task-perf-word-count-generic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count-generic.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -37,15 +37,15 @@ fn map(&&filename: [u8], emit: map_reduce::putter<[u8], int>) {\n     while true {\n         alt read_word(f) {\n           some(w) { emit(str::bytes(w), 1); }\n-          none. { break; }\n+          none { break; }\n         }\n     }\n }\n \n fn reduce(&&_word: [u8], get: map_reduce::getter<int>) {\n     let count = 0;\n \n-    while true { alt get() { some(_) { count += 1; } none. { break; } } }\n+    while true { alt get() { some(_) { count += 1; } none { break; } } }\n }\n \n mod map_reduce {\n@@ -97,7 +97,7 @@ mod map_reduce {\n             let c;\n             alt treemap::find(im, key) {\n               some(_c) { c = _c; }\n-              none. {\n+              none {\n                 let p = port();\n                 send(ctrl, find_reducer(key, chan(p)));\n                 c = recv(p);\n@@ -136,7 +136,7 @@ mod map_reduce {\n                     // #error(\"received %d\", v);\n                     ret some(v);\n                   }\n-                  done. {\n+                  done {\n                     // #error(\"all done\");\n                     is_done = true;\n                   }\n@@ -166,7 +166,7 @@ mod map_reduce {\n \n         while num_mappers > 0 {\n             alt recv(ctrl) {\n-              mapper_done. {\n+              mapper_done {\n                 // #error(\"received mapper terminated.\");\n                 num_mappers -= 1;\n               }\n@@ -179,7 +179,7 @@ mod map_reduce {\n                     // \"reusing existing reducer for \" + k);\n                     c = _c;\n                   }\n-                  none. {\n+                  none {\n                     // log(error, \"creating new reducer for \" + k);\n                     let p = port();\n                     let ch = chan(p);"}, {"sha": "02adfd610b08de92767dc4de3e31c2cdbd4d2e1d", "filename": "src/test/bench/task-perf-word-count.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-word-count.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -26,14 +26,14 @@ fn map(input: str, emit: map_reduce::putter) {\n \n \n     while true {\n-        alt read_word(f) { some(w) { emit(w, 1); } none. { break; } }\n+        alt read_word(f) { some(w) { emit(w, 1); } none { break; } }\n     }\n }\n \n fn reduce(_word: str, get: map_reduce::getter) {\n     let count = 0;\n \n-    while true { alt get() { some(_) { count += 1; } none. { break; } } }\n+    while true { alt get() { some(_) { count += 1; } none { break; } } }\n }\n \n mod map_reduce {\n@@ -78,7 +78,7 @@ mod map_reduce {\n               some(_c) {\n                 c = _c;\n               }\n-              none. {\n+              none {\n                 let p = port();\n                 send(ctrl, find_reducer(key, chan(p)));\n                 c = recv(p);\n@@ -112,7 +112,7 @@ mod map_reduce {\n                     // #error(\"received %d\", v);\n                     ret some(v);\n                   }\n-                  done. {\n+                  done {\n                     // #error(\"all done\");\n                     state.is_done = true;\n                   }\n@@ -141,7 +141,7 @@ mod map_reduce {\n \n         while num_mappers > 0 {\n             alt recv(ctrl) {\n-              mapper_done. {\n+              mapper_done {\n                 // #error(\"received mapper terminated.\");\n                 num_mappers -= 1;\n               }\n@@ -154,7 +154,7 @@ mod map_reduce {\n                     // \"reusing existing reducer for \" + k);\n                     c = _c;\n                   }\n-                  none. {\n+                  none {\n                     // log(error, \"creating new reducer for \" + k);\n                     let p = port();\n                     let ch = chan(p);"}, {"sha": "343a042dbc1ba41cd0e2a8d6ca601628ce5171e2", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -46,7 +46,7 @@ mod map_reduce {\n             let c;\n             alt im.find(key) {\n               some(_c) { c = _c }\n-              none. {\n+              none {\n                 let p = port();\n                 #error(\"sending find_reducer\");\n                 send(ctrl, find_reducer(str::bytes(key), chan(p)));\n@@ -78,12 +78,12 @@ mod map_reduce {\n \n         while num_mappers > 0 {\n             alt recv(ctrl) {\n-              mapper_done. { num_mappers -= 1; }\n+              mapper_done { num_mappers -= 1; }\n               find_reducer(k, cc) {\n                 let c;\n                 alt reducers.find(str::unsafe_from_bytes(k)) {\n                   some(_c) { c = _c; }\n-                  none. { c = 0; }\n+                  none { c = 0; }\n                 }\n                 send(cc, c);\n               }"}, {"sha": "c8704ab50a6266aa956199bff66ac678599ab962", "filename": "src/test/run-pass/iface-cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fiface-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fiface-cast.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -14,7 +14,7 @@ iface to_str {\n impl <T: to_str> of to_str for option<T> {\n     fn to_str() -> str {\n         alt self {\n-          none. { \"none\" }\n+          none { \"none\" }\n           some(t) { \"some(\" + t.to_str() + \")\" }\n         }\n     }"}, {"sha": "6081dc145fd6b5122a710ec5e5b464c86bba5e11", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -3,7 +3,7 @@ use std;\n import std::list::*;\n \n pure fn pure_length_go<T: copy>(ls: list<T>, acc: uint) -> uint {\n-    alt ls { nil. { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n+    alt ls { nil { acc } cons(_, tl) { pure_length_go(*tl, acc + 1u) } }\n }\n \n pure fn pure_length<T: copy>(ls: list<T>) -> uint { pure_length_go(ls, 0u) }"}, {"sha": "062f9c81a8b58e650b44371e9c5d7b1e93573b78", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04a2887f8791bb080b4e76a55949a7c1954dbb97/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=04a2887f8791bb080b4e76a55949a7c1954dbb97", "patch": "@@ -9,7 +9,7 @@ import std::list::*;\n // no syntax for specifying that f is pure.\n fn pure_foldl<T: copy, U: copy>(ls: list<T>, u: U, f: block(T, U) -> U) -> U {\n     alt ls {\n-        nil. { u }\n+        nil { u }\n         cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }\n     }\n }"}]}