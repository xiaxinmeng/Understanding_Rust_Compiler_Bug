{"sha": "3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmNmEzYjVlYmVjZTVmNmQzYjEwMTBiNjhhNWZkODY3NTY1OTMwOTg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-25T10:41:48Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2020-12-25T11:08:21Z"}, "message": "Implement lazy compilation in JIT mode\n\nLazy compilation has the potential to significantly improve the startup\ntime of a program. While functions have to be codegened when called, it\nis expected that a significant amount of all code is only required when\nan error occurs or only when the program is used in certain ways.\n\nThe basic approach is to first codegen a shim for each function. This\nshim calls the `__cg_clif_jit` function of cg_clif with a pointer to the\n`Instance` corresponding to the function for which it is a shim.\n`__cg_clif_jit` function then codegens this function and uses the hot\ncode swapping support of SimpleJIT to redirect future calls to the\nfunction to the real version. Finally it calls the newly codegened\nfunction.", "tree": {"sha": "b57a10461b73d921be7fbbab4ed2d6159b0b6c78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b57a10461b73d921be7fbbab4ed2d6159b0b6c78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "html_url": "https://github.com/rust-lang/rust/commit/3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b9b2532d262bf590b769a7cd2f32602b8925183", "url": "https://api.github.com/repos/rust-lang/rust/commits/0b9b2532d262bf590b769a7cd2f32602b8925183", "html_url": "https://github.com/rust-lang/rust/commit/0b9b2532d262bf590b769a7cd2f32602b8925183"}], "stats": {"total": 149, "additions": 138, "deletions": 11}, "files": [{"sha": "015bbdfed4648ee106cb18d47f2e7217d7f30cd9", "filename": "example/std_example.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -15,6 +15,8 @@ fn main() {\n     let stderr = ::std::io::stderr();\n     let mut stderr = stderr.lock();\n \n+    // FIXME support lazy jit when multi threading\n+    #[cfg(not(lazy_jit))]\n     std::thread::spawn(move || {\n         println!(\"Hello from another thread!\");\n     });"}, {"sha": "a61774f479ec7f9cb7ee3533042806ff61b21c05", "filename": "scripts/tests.sh", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/scripts%2Ftests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/scripts%2Ftests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/scripts%2Ftests.sh?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -16,6 +16,9 @@ function no_sysroot_tests() {\n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] mini_core_hello_world\"\n         CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] mini_core_hello_world\"\n+        CG_CLIF_JIT_ARGS=\"abc bcd\" $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/mini_core_hello_world.rs --cfg jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] mini_core_hello_world (skipped)\"\n     fi\n@@ -38,6 +41,9 @@ function base_sysroot_tests() {\n     if [[ \"$JIT_SUPPORTED\" = \"1\" ]]; then\n         echo \"[JIT] std_example\"\n         $MY_RUSTC -Cllvm-args=mode=jit -Cprefer-dynamic example/std_example.rs --target \"$HOST_TRIPLE\"\n+\n+        echo \"[JIT-lazy] std_example\"\n+        $MY_RUSTC -Cllvm-args=mode=jit-lazy -Cprefer-dynamic example/std_example.rs --cfg lazy_jit --target \"$HOST_TRIPLE\"\n     else\n         echo \"[JIT] std_example (skipped)\"\n     fi"}, {"sha": "bfa2076d3d9695592589148afd5339cf9287cdb9", "filename": "src/constant.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconstant.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -447,7 +447,8 @@ fn define_all_allocs(tcx: TyCtxt<'_>, module: &mut impl Module, cx: &mut Constan\n             data_ctx.write_data_addr(offset.bytes() as u32, global_value, addend as i64);\n         }\n \n-        module.define_data(data_id, &data_ctx).unwrap();\n+        // FIXME don't duplicate definitions in lazy jit mode\n+        let _ = module.define_data(data_id, &data_ctx);\n         cx.done.insert(data_id);\n     }\n "}, {"sha": "9a42c675cc14498a1955983ce99e799a382ea63d", "filename": "src/driver/jit.rs", "status": "modified", "additions": 122, "deletions": 7, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fdriver%2Fjit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fdriver%2Fjit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fjit.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -1,6 +1,7 @@\n //! The JIT driver uses [`cranelift_simplejit`] to JIT execute programs without writing any object\n //! files.\n \n+use std::cell::RefCell;\n use std::ffi::CString;\n use std::os::raw::{c_char, c_int};\n \n@@ -10,8 +11,13 @@ use rustc_middle::mir::mono::MonoItem;\n use cranelift_jit::{JITBuilder, JITModule};\n \n use crate::prelude::*;\n+use crate::{CodegenCx, CodegenMode};\n \n-pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n+thread_local! {\n+    pub static CURRENT_MODULE: RefCell<Option<JITModule>> = RefCell::new(None);\n+}\n+\n+pub(super) fn run_jit(tcx: TyCtxt<'_>, codegen_mode: CodegenMode) -> ! {\n     if !tcx.sess.opts.output_types.should_codegen() {\n         tcx.sess.fatal(\"JIT mode doesn't work with `cargo check`.\");\n     }\n@@ -40,6 +46,7 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n         crate::build_isa(tcx.sess),\n         cranelift_module::default_libcall_names(),\n     );\n+    jit_builder.hotswap(matches!(codegen_mode, CodegenMode::JitLazy));\n     jit_builder.symbols(imported_symbols);\n     let mut jit_module = JITModule::new(jit_builder);\n     assert_eq!(pointer_ty(tcx), jit_module.target_config().pointer_type());\n@@ -74,13 +81,17 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n         for (mono_item, (linkage, visibility)) in mono_items {\n             let linkage = crate::linkage::get_clif_linkage(mono_item, linkage, visibility);\n             match mono_item {\n-                MonoItem::Fn(inst) => {\n-                    cx.tcx.sess.time(\"codegen fn\", || {\n-                        crate::base::codegen_fn(&mut cx, inst, linkage)\n-                    });\n-                }\n+                MonoItem::Fn(inst) => match codegen_mode {\n+                    CodegenMode::Aot => unreachable!(),\n+                    CodegenMode::Jit => {\n+                        cx.tcx.sess.time(\"codegen fn\", || {\n+                            crate::base::codegen_fn(&mut cx, inst, linkage)\n+                        });\n+                    }\n+                    CodegenMode::JitLazy => codegen_shim(&mut cx, inst),\n+                },\n                 MonoItem::Static(def_id) => {\n-                    crate::constant::codegen_static(&mut cx.constants_cx, def_id)\n+                    crate::constant::codegen_static(&mut cx.constants_cx, def_id);\n                 }\n                 MonoItem::GlobalAsm(hir_id) => {\n                     let item = cx.tcx.hir().expect_item(hir_id);\n@@ -126,11 +137,50 @@ pub(super) fn run_jit(tcx: TyCtxt<'_>) -> ! {\n     // useful as some dynamic linkers use it as a marker to jump over.\n     argv.push(std::ptr::null());\n \n+    CURRENT_MODULE\n+        .with(|current_module| assert!(current_module.borrow_mut().replace(jit_module).is_none()));\n+\n     let ret = f(args.len() as c_int, argv.as_ptr());\n \n     std::process::exit(ret);\n }\n \n+#[no_mangle]\n+extern \"C\" fn __clif_jit_fn(instance_ptr: *const Instance<'static>) -> *const u8 {\n+    rustc_middle::ty::tls::with(|tcx| {\n+        // lift is used to ensure the correct lifetime for instance.\n+        let instance = tcx.lift(unsafe { *instance_ptr }).unwrap();\n+\n+        CURRENT_MODULE.with(|jit_module| {\n+            let mut jit_module = jit_module.borrow_mut();\n+            let jit_module = jit_module.as_mut().unwrap();\n+            let mut cx = crate::CodegenCx::new(tcx, jit_module, false, false);\n+\n+            let (name, sig) = crate::abi::get_function_name_and_sig(\n+                tcx,\n+                cx.module.isa().triple(),\n+                instance,\n+                true,\n+            );\n+            let func_id = cx\n+                .module\n+                .declare_function(&name, Linkage::Export, &sig)\n+                .unwrap();\n+            cx.module.prepare_for_function_redefine(func_id).unwrap();\n+\n+            tcx.sess.time(\"codegen fn\", || {\n+                crate::base::codegen_fn(&mut cx, instance, Linkage::Export)\n+            });\n+\n+            let (jit_module, global_asm, _debug_context, unwind_context) = cx.finalize();\n+            assert!(global_asm.is_empty());\n+            jit_module.finalize_definitions();\n+            std::mem::forget(unsafe { unwind_context.register_jit(&jit_module) });\n+            jit_module.get_finalized_function(func_id)\n+        })\n+    })\n+}\n+\n fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n     use rustc_middle::middle::dependency_format::Linkage;\n \n@@ -190,3 +240,68 @@ fn load_imported_symbols_for_jit(tcx: TyCtxt<'_>) -> Vec<(String, *const u8)> {\n \n     imported_symbols\n }\n+\n+pub(super) fn codegen_shim<'tcx>(cx: &mut CodegenCx<'tcx, impl Module>, inst: Instance<'tcx>) {\n+    let tcx = cx.tcx;\n+\n+    let pointer_type = cx.module.target_config().pointer_type();\n+\n+    let (name, sig) =\n+        crate::abi::get_function_name_and_sig(tcx, cx.module.isa().triple(), inst, true);\n+    let func_id = cx\n+        .module\n+        .declare_function(&name, Linkage::Export, &sig)\n+        .unwrap();\n+\n+    let instance_ptr = Box::into_raw(Box::new(inst));\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_function(\n+            \"__clif_jit_fn\",\n+            Linkage::Import,\n+            &Signature {\n+                call_conv: cx.module.target_config().default_call_conv,\n+                params: vec![AbiParam::new(pointer_type)],\n+                returns: vec![AbiParam::new(pointer_type)],\n+            },\n+        )\n+        .unwrap();\n+\n+    let mut trampoline = Function::with_name_signature(ExternalName::default(), sig.clone());\n+    let mut builder_ctx = FunctionBuilderContext::new();\n+    let mut trampoline_builder = FunctionBuilder::new(&mut trampoline, &mut builder_ctx);\n+\n+    let jit_fn = cx\n+        .module\n+        .declare_func_in_func(jit_fn, trampoline_builder.func);\n+    let sig_ref = trampoline_builder.func.import_signature(sig);\n+\n+    let entry_block = trampoline_builder.create_block();\n+    trampoline_builder.append_block_params_for_function_params(entry_block);\n+    let fn_args = trampoline_builder\n+        .func\n+        .dfg\n+        .block_params(entry_block)\n+        .to_vec();\n+\n+    trampoline_builder.switch_to_block(entry_block);\n+    let instance_ptr = trampoline_builder\n+        .ins()\n+        .iconst(pointer_type, instance_ptr as u64 as i64);\n+    let jitted_fn = trampoline_builder.ins().call(jit_fn, &[instance_ptr]);\n+    let jitted_fn = trampoline_builder.func.dfg.inst_results(jitted_fn)[0];\n+    let call_inst = trampoline_builder\n+        .ins()\n+        .call_indirect(sig_ref, jitted_fn, &fn_args);\n+    let ret_vals = trampoline_builder.func.dfg.inst_results(call_inst).to_vec();\n+    trampoline_builder.ins().return_(&ret_vals);\n+\n+    cx.module\n+        .define_function(\n+            func_id,\n+            &mut Context::for_function(trampoline),\n+            &mut cranelift_codegen::binemit::NullTrapSink {},\n+        )\n+        .unwrap();\n+}"}, {"sha": "9f4ea9a386551f88436198bf27214f7f6902f39a", "filename": "src/driver/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fdriver%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fdriver%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fmod.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn codegen_crate(\n \n     match config.codegen_mode {\n         CodegenMode::Aot => aot::run_aot(tcx, metadata, need_metadata_module),\n-        CodegenMode::Jit => {\n+        CodegenMode::Jit | CodegenMode::JitLazy => {\n             let is_executable = tcx\n                 .sess\n                 .crate_types()\n@@ -33,7 +33,7 @@ pub(crate) fn codegen_crate(\n             }\n \n             #[cfg(feature = \"jit\")]\n-            let _: ! = jit::run_jit(tcx);\n+            let _: ! = jit::run_jit(tcx, config.codegen_mode);\n \n             #[cfg(not(feature = \"jit\"))]\n             tcx.sess"}, {"sha": "6e4f3bf2898d827900ec449dafd08325ea77b886", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -177,6 +177,7 @@ impl<'tcx, M: Module> CodegenCx<'tcx, M> {\n pub enum CodegenMode {\n     Aot,\n     Jit,\n+    JitLazy,\n }\n \n impl Default for CodegenMode {\n@@ -192,6 +193,7 @@ impl FromStr for CodegenMode {\n         match s {\n             \"aot\" => Ok(CodegenMode::Aot),\n             \"jit\" => Ok(CodegenMode::Jit),\n+            \"jit-lazy\" => Ok(CodegenMode::JitLazy),\n             _ => Err(format!(\"Unknown codegen mode `{}`\", s)),\n         }\n     }"}, {"sha": "8f15586a9dc06b8c2444280a3d80509cefb36552", "filename": "src/vtable.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f6a3b5ebece5f6d3b1010b68a5fd86756593098/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=3f6a3b5ebece5f6d3b1010b68a5fd86756593098", "patch": "@@ -158,7 +158,8 @@ fn build_vtable<'tcx>(\n         )\n         .unwrap();\n \n-    fx.cx.module.define_data(data_id, &data_ctx).unwrap();\n+    // FIXME don't duplicate definitions in lazy jit mode\n+    let _ = fx.cx.module.define_data(data_id, &data_ctx);\n \n     data_id\n }"}]}