{"sha": "53cd573bc8d79393676783ec124e4a2000166956", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzY2Q1NzNiYzhkNzkzOTM2NzY3ODNlYzEyNGU0YTIwMDAxNjY5NTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-31T17:05:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-31T17:05:34Z"}, "message": "Auto merge of #30660 - nagisa:rollup, r=steveklabnik\n\n- Successful merges: #30365, #30565, #30590, #30630\n- Failed merges:", "tree": {"sha": "cfd21c5b780782c25d7577f67525febd08121936", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfd21c5b780782c25d7577f67525febd08121936"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53cd573bc8d79393676783ec124e4a2000166956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53cd573bc8d79393676783ec124e4a2000166956", "html_url": "https://github.com/rust-lang/rust/commit/53cd573bc8d79393676783ec124e4a2000166956", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53cd573bc8d79393676783ec124e4a2000166956/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b6a851db5142039a43b523c139154a20dfd7a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b6a851db5142039a43b523c139154a20dfd7a63", "html_url": "https://github.com/rust-lang/rust/commit/3b6a851db5142039a43b523c139154a20dfd7a63"}, {"sha": "7448f4861a8ee41b0a6d62b6bdaf623b3eeba453", "url": "https://api.github.com/repos/rust-lang/rust/commits/7448f4861a8ee41b0a6d62b6bdaf623b3eeba453", "html_url": "https://github.com/rust-lang/rust/commit/7448f4861a8ee41b0a6d62b6bdaf623b3eeba453"}], "stats": {"total": 1881, "additions": 1402, "deletions": 479}, "files": [{"sha": "5239086a6552ca26739e280736c4e0e3b37f6cd1", "filename": "mk/platform.mk", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -64,14 +64,18 @@ define DEF_GOOD_VALGRIND\n   ifeq ($(OSTYPE_$(1)),unknown-linux-gnu)\n     GOOD_VALGRIND_$(1) = 1\n   endif\n-  ifneq (,$(filter $(OSTYPE_$(1)),darwin freebsd))\n-    ifeq (HOST_$(1),x86_64)\n+  ifneq (,$(filter $(OSTYPE_$(1)),apple-darwin freebsd))\n+    ifeq ($(HOST_$(1)),x86_64)\n       GOOD_VALGRIND_$(1) = 1\n     endif\n   endif\n+  ifdef GOOD_VALGRIND_$(t)\n+    $$(info cfg: have good valgrind for $(t))\n+  else\n+    $$(info cfg: no good valgrind for $(t))\n+  endif\n endef\n $(foreach t,$(CFG_TARGET),$(eval $(call DEF_GOOD_VALGRIND,$(t))))\n-$(foreach t,$(CFG_TARGET),$(info cfg: good valgrind for $(t) is $(GOOD_VALGRIND_$(t))))\n \n ifneq ($(findstring linux,$(CFG_OSTYPE)),)\n   ifdef CFG_PERF"}, {"sha": "50e30caa2b34b0fa58700b81091da0fe28185b93", "filename": "src/etc/apple-darwin.supp", "status": "modified", "additions": 21, "deletions": 51, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Fetc%2Fapple-darwin.supp", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Fetc%2Fapple-darwin.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fapple-darwin.supp?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -1,17 +1,11 @@\n {\n    osx-frameworks.rs-fails-otherwise-1\n    Memcheck:Leak\n-   match-leak-kinds: possible\n+   match-leak-kinds: definite,possible\n    fun:malloc\n    ...\n    fun:__CFInitialize\n-   fun:_ZN16ImageLoaderMachO11doImageInitERKN11ImageLoader11LinkContextE\n-   fun:_ZN16ImageLoaderMachO16doInitializationERKN11ImageLoader11LinkContextE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader19processInitializersERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader15runInitializersERKNS_11LinkContextERNS_21InitializerTimingListE\n-   fun:_ZN4dyld24initializeMainExecutableEv\n+   ...\n }\n \n {\n@@ -22,23 +16,17 @@\n    ...\n    fun:__CFInitialize\n    fun:_ZN16ImageLoaderMachO11doImageInitERKN11ImageLoader11LinkContextE\n-   fun:_ZN16ImageLoaderMachO16doInitializationERKN11ImageLoader11LinkContextE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader19processInitializersERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n }\n \n {\n    osx-frameworks.rs-fails-otherwise-3\n    Memcheck:Leak\n    match-leak-kinds: possible\n    fun:realloc\n-   fun:_ZL12realizeClassP10objc_class\n-   fun:_ZL12realizeClassP10objc_class\n-   fun:_ZN13list_array_ttIm15protocol_list_tE11attachListsEPKPS0_j\n+   ...\n    fun:_read_images\n    fun:map_images_nolock\n-   fun:map_2_images\n+   ...\n    fun:_ZN4dyldL18notifyBatchPartialE17dyld_image_statesbPFPKcS0_jPK15dyld_image_infoE\n    fun:_ZN4dyld36registerImageStateBatchChangeHandlerE17dyld_image_statesPFPKcS0_jPK15dyld_image_infoE\n    fun:dyld_register_image_state_change_handler\n@@ -49,7 +37,7 @@\n {\n    osx-frameworks.rs-fails-otherwise-4\n    Memcheck:Leak\n-   match-leak-kinds: possible\n+   match-leak-kinds: definite,possible\n    fun:calloc\n    ...\n    fun:__CFInitialize\n@@ -61,45 +49,27 @@\n {\n    osx-frameworks.rs-fails-otherwise-5\n    Memcheck:Leak\n-   match-leak-kinds: definite\n-   fun:calloc\n+   match-leak-kinds: definite,possible\n+   fun:malloc_zone_malloc\n    ...\n    fun:__CFInitialize\n-   fun:_ZN16ImageLoaderMachO11doImageInitERKN11ImageLoader11LinkContextE\n-   fun:_ZN16ImageLoaderMachO16doInitializationERKN11ImageLoader11LinkContextE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-}\n-\n-{\n-   osx-frameworks.rs-fails-otherwise-6\n-   Memcheck:Leak\n-   match-leak-kinds: definite\n-   fun:malloc\n-   fun:strdup\n-   fun:_CFProcessPath\n-   fun:__CFInitialize\n-   fun:_ZN16ImageLoaderMachO11doImageInitERKN11ImageLoader11LinkContextE\n-   fun:_ZN16ImageLoaderMachO16doInitializationERKN11ImageLoader11LinkContextE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader19processInitializersERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader15runInitializersERKNS_11LinkContextERNS_21InitializerTimingListE\n-   fun:_ZN4dyld24initializeMainExecutableEv\n-   fun:_ZN4dyld5_mainEPK12macho_headermiPPKcS5_S5_Pm\n+   ...\n }\n \n {\n-   osx-frameworks.rs-fails-otherwise-7\n+   fails-since-xcode-7.2\n    Memcheck:Leak\n-   match-leak-kinds: definite\n+   match-leak-kinds: possible\n    fun:malloc_zone_malloc\n-   ...\n-   fun:__CFInitialize\n-   fun:_ZN16ImageLoaderMachO11doImageInitERKN11ImageLoader11LinkContextE\n-   fun:_ZN16ImageLoaderMachO16doInitializationERKN11ImageLoader11LinkContextE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader23recursiveInitializationERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader19processInitializersERKNS_11LinkContextEjRNS_21InitializerTimingListERNS_15UninitedUpwardsE\n-   fun:_ZN11ImageLoader15runInitializersERKNS_11LinkContextERNS_21InitializerTimingListE\n-   fun:_ZN4dyld24initializeMainExecutableEv\n+   fun:_objc_copyClassNamesForImage\n+   fun:_ZL9protocolsv\n+   fun:_Z9readClassP10objc_classbb\n+   fun:gc_init\n+   fun:_ZL33objc_initializeClassPair_internalP10objc_classPKcS0_S0_\n+   fun:layout_string_create\n+   fun:_ZL12realizeClassP10objc_class\n+   fun:_ZL22copySwiftV1MangledNamePKcb\n+   fun:_ZL22copySwiftV1MangledNamePKcb\n+   fun:_ZL22copySwiftV1MangledNamePKcb\n+   fun:_ZL22copySwiftV1MangledNamePKcb\n }"}, {"sha": "6e409af79aecfe48f4c49bcd8cc97ae1dbb110b6", "filename": "src/etc/x86.supp", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -12,7 +12,7 @@\n    fun:tlv_finalize\n    fun:_pthread_tsd_cleanup\n    fun:_pthread_exit\n-   fun:_pthread_body\n+   ...\n    fun:_pthread_start\n    fun:thread_start\n }\n@@ -24,7 +24,7 @@\n    fun:tlv_finalize\n    fun:_pthread_tsd_cleanup\n    fun:_pthread_exit\n-   fun:_pthread_body\n+   ...\n    fun:_pthread_start\n    fun:thread_start\n }\n@@ -36,7 +36,7 @@\n    fun:tlv_finalize\n    fun:_pthread_tsd_cleanup\n    fun:_pthread_exit\n-   fun:_pthread_body\n+   ...\n    fun:_pthread_start\n    fun:thread_start\n }\n@@ -48,7 +48,7 @@\n    fun:tlv_finalize\n    fun:_pthread_tsd_cleanup\n    fun:_pthread_exit\n-   fun:_pthread_body\n+   ...\n    fun:_pthread_start\n    fun:thread_start\n }"}, {"sha": "a5e8522623a2eaf6ae3c3c2238fedd692b03c1f8", "filename": "src/librbml/leb128.rs", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fleb128.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -0,0 +1,162 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[inline]\n+pub fn write_to_vec(vec: &mut Vec<u8>, position: &mut usize, byte: u8)\n+{\n+    if *position == vec.len() {\n+        vec.push(byte);\n+    } else {\n+        vec[*position] = byte;\n+    }\n+\n+    *position += 1;\n+}\n+\n+pub fn write_unsigned_leb128(out: &mut Vec<u8>,\n+                             start_position: usize,\n+                             mut value: u64)\n+                             -> usize {\n+    let mut position = start_position;\n+    loop\n+    {\n+        let mut byte = (value & 0x7F) as u8;\n+        value >>= 7;\n+        if value != 0 {\n+            byte |= 0x80;\n+        }\n+\n+        write_to_vec(out, &mut position, byte);\n+\n+        if value == 0 {\n+            break;\n+        }\n+    }\n+\n+    return position - start_position;\n+}\n+\n+pub fn read_unsigned_leb128(data: &[u8],\n+                            start_position: usize)\n+                            -> (u64, usize) {\n+    let mut result = 0;\n+    let mut shift = 0;\n+    let mut position = start_position;\n+    loop {\n+        let byte = data[position];\n+        position += 1;\n+        result |= ((byte & 0x7F) as u64) << shift;\n+        if (byte & 0x80) == 0 {\n+            break;\n+        }\n+        shift += 7;\n+    }\n+\n+    (result, position - start_position)\n+}\n+\n+\n+pub fn write_signed_leb128(out: &mut Vec<u8>,\n+                           start_position: usize,\n+                           mut value: i64) -> usize {\n+    let mut position = start_position;\n+\n+    loop {\n+        let mut byte = (value as u8) & 0x7f;\n+        value >>= 7;\n+        let more = !((((value == 0 ) && ((byte & 0x40) == 0)) ||\n+                      ((value == -1) && ((byte & 0x40) != 0))));\n+        if more {\n+            byte |= 0x80; // Mark this byte to show that more bytes will follow.\n+        }\n+\n+        write_to_vec(out, &mut position, byte);\n+\n+        if !more {\n+            break;\n+        }\n+    }\n+\n+    return position - start_position;\n+}\n+\n+pub fn read_signed_leb128(data: &[u8],\n+                          start_position: usize)\n+                          -> (i64, usize) {\n+    let mut result = 0;\n+    let mut shift = 0;\n+    let mut position = start_position;\n+    let mut byte;\n+\n+    loop {\n+        byte = data[position];\n+        position += 1;\n+        result |= ((byte & 0x7F) as i64) << shift;\n+        shift += 7;\n+\n+        if (byte & 0x80) == 0 {\n+            break;\n+        }\n+    }\n+\n+    if (shift < 64) && ((byte & 0x40) != 0) {\n+        /* sign extend */\n+        result |= -(1i64 << shift);\n+    }\n+\n+    (result, position - start_position)\n+}\n+\n+#[test]\n+fn test_unsigned_leb128() {\n+    let mut stream = Vec::with_capacity(10000);\n+\n+    for x in 0..62 {\n+        let pos = stream.len();\n+        let bytes_written = write_unsigned_leb128(&mut stream, pos, 3 << x);\n+        assert_eq!(stream.len(), pos + bytes_written);\n+    }\n+\n+    let mut position = 0;\n+    for x in 0..62 {\n+        let expected = 3 << x;\n+        let (actual, bytes_read) = read_unsigned_leb128(&stream, position);\n+        assert_eq!(expected, actual);\n+        position += bytes_read;\n+    }\n+    assert_eq!(stream.len(), position);\n+}\n+\n+#[test]\n+fn test_signed_leb128() {\n+    let mut values = Vec::new();\n+\n+    let mut i = -500;\n+    while i < 500 {\n+        values.push(i * 123457i64);\n+        i += 1;\n+    }\n+\n+    let mut stream = Vec::new();\n+\n+    for &x in &values {\n+        let pos = stream.len();\n+        let bytes_written = write_signed_leb128(&mut stream, pos, x);\n+        assert_eq!(stream.len(), pos + bytes_written);\n+    }\n+\n+    let mut pos = 0;\n+    for &x in &values {\n+        let (value, bytes_read) = read_signed_leb128(&mut stream, pos);\n+        pos += bytes_read;\n+        assert_eq!(x, value);\n+    }\n+    assert_eq!(pos, stream.len());\n+}"}, {"sha": "f3a1bbd7e26b832bd73e9aa8c9a0febaa5f44e07", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -128,10 +128,17 @@\n #![cfg_attr(test, feature(test))]\n \n extern crate serialize;\n+\n+#[cfg(test)]\n+extern crate serialize as rustc_serialize; // Used by RustcEncodable\n+\n #[macro_use] extern crate log;\n \n #[cfg(test)] extern crate test;\n \n+pub mod opaque;\n+pub mod leb128;\n+\n pub use self::EbmlEncoderTag::*;\n pub use self::Error::*;\n \n@@ -241,6 +248,7 @@ pub mod reader {\n \n     use serialize;\n \n+    use super::opaque;\n     use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32,\n         EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n@@ -621,18 +629,16 @@ pub mod reader {\n         }\n \n         pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n-            F: FnOnce(&mut Decoder, Doc) -> DecodeResult<R>,\n+            F: FnOnce(&mut opaque::Decoder, Doc) -> DecodeResult<R>,\n         {\n             let doc = try!(self.next_doc(EsOpaque));\n \n-            let (old_parent, old_pos) = (self.parent, self.pos);\n-            self.parent = doc;\n-            self.pos = doc.start;\n-\n-            let result = try!(op(self, doc));\n+            let result = {\n+                let mut opaque_decoder = opaque::Decoder::new(doc.data,\n+                                                              doc.start);\n+                try!(op(&mut opaque_decoder, doc))\n+            };\n \n-            self.parent = old_parent;\n-            self.pos = old_pos;\n             Ok(result)\n         }\n \n@@ -877,6 +883,7 @@ pub mod writer {\n     use std::io::prelude::*;\n     use std::io::{self, SeekFrom, Cursor};\n \n+    use super::opaque;\n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n         EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n@@ -1120,10 +1127,16 @@ pub mod writer {\n         }\n \n         pub fn emit_opaque<F>(&mut self, f: F) -> EncodeResult where\n-            F: FnOnce(&mut Encoder) -> EncodeResult,\n+            F: FnOnce(&mut opaque::Encoder) -> EncodeResult,\n         {\n             try!(self.start_tag(EsOpaque as usize));\n-            try!(f(self));\n+\n+            {\n+                let mut opaque_encoder = opaque::Encoder::new(self.writer);\n+                try!(f(&mut opaque_encoder));\n+            }\n+\n+            self.mark_stable_position();\n             self.end_tag()\n         }\n     }"}, {"sha": "64756090e8b48ee36518e8da871364be552a5919", "filename": "src/librbml/opaque.rs", "status": "added", "additions": 811, "deletions": 0, "changes": 811, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrbml%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fopaque.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -0,0 +1,811 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use Error as DecodeError;\n+use writer::EncodeResult;\n+use leb128::{read_signed_leb128, read_unsigned_leb128, write_signed_leb128,\n+             write_unsigned_leb128};\n+use std::io::{self, Write};\n+use serialize;\n+\n+//=-----------------------------------------------------------------------------\n+// Encoder\n+//=-----------------------------------------------------------------------------\n+\n+pub struct Encoder<'a> {\n+    pub cursor: &'a mut io::Cursor<Vec<u8>>,\n+}\n+\n+impl<'a> Encoder<'a> {\n+    pub fn new(cursor: &'a mut io::Cursor<Vec<u8>>) -> Encoder<'a> {\n+        Encoder {\n+            cursor: cursor\n+        }\n+    }\n+}\n+\n+\n+macro_rules! write_uleb128 {\n+    ($enc:expr, $value:expr) => {{\n+        let pos = $enc.cursor.position() as usize;\n+        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u64);\n+        $enc.cursor.set_position((pos + bytes_written) as u64);\n+        Ok(())\n+    }}\n+}\n+\n+macro_rules! write_sleb128 {\n+    ($enc:expr, $value:expr) => {{\n+        let pos = $enc.cursor.position() as usize;\n+        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i64);\n+        $enc.cursor.set_position((pos + bytes_written) as u64);\n+        Ok(())\n+    }}\n+}\n+\n+impl<'a> serialize::Encoder for Encoder<'a> {\n+    type Error = io::Error;\n+\n+    fn emit_nil(&mut self) -> EncodeResult {\n+        Ok(())\n+    }\n+\n+    fn emit_uint(&mut self, v: usize) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult {\n+        let _ = self.cursor.write_all(&[v]);\n+        Ok(())\n+    }\n+\n+    fn emit_int(&mut self, v: isize) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult {\n+        let as_u8: u8 = unsafe { ::std::mem::transmute(v) };\n+        let _ = self.cursor.write_all(&[as_u8]);\n+        Ok(())\n+    }\n+\n+    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n+        self.emit_u8(if v { 1 } else { 0 })\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+        let as_u64: u64 = unsafe { ::std::mem::transmute(v) };\n+        self.emit_u64(as_u64)\n+    }\n+\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult {\n+        let as_u32: u32 = unsafe { ::std::mem::transmute(v) };\n+        self.emit_u32(as_u32)\n+    }\n+\n+    fn emit_char(&mut self, v: char) -> EncodeResult {\n+        self.emit_u32(v as u32)\n+    }\n+\n+    fn emit_str(&mut self, v: &str) -> EncodeResult {\n+        try!(self.emit_uint(v.len()));\n+        let _ = self.cursor.write_all(v.as_bytes());\n+        Ok(())\n+    }\n+\n+    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult {\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant<F>(&mut self,\n+                            _v_name: &str,\n+                            v_id: usize,\n+                            _len: usize,\n+                            f: F) -> EncodeResult\n+        where F: FnOnce(&mut Self) -> EncodeResult\n+    {\n+        try!(self.emit_uint(v_id));\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant_arg<F>(&mut self, _: usize, f: F) -> EncodeResult where\n+            F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_enum_struct_variant<F>(&mut self,\n+                                       v_name: &str,\n+                                       v_id: usize,\n+                                       cnt: usize,\n+                                       f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_enum_variant(v_name, v_id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field<F>(&mut self,\n+                                         _: &str,\n+                                         idx: usize,\n+                                         f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+    fn emit_struct<F>(&mut self, _: &str, _len: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_struct_field<F>(&mut self, _name: &str, _: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_tuple<F>(&mut self, len: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_seq(len, f)\n+    }\n+\n+    fn emit_tuple_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_seq(len, f)\n+    }\n+\n+    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_enum(\"Option\", f)\n+    }\n+\n+    fn emit_option_none(&mut self) -> EncodeResult {\n+        self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n+    }\n+\n+    fn emit_option_some<F>(&mut self, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        self.emit_enum_variant(\"Some\", 1, 1, f)\n+    }\n+\n+    fn emit_seq<F>(&mut self, len: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        try!(self.emit_uint(len));\n+        f(self)\n+    }\n+\n+    fn emit_seq_elt<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_map<F>(&mut self, len: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        try!(self.emit_uint(len));\n+        f(self)\n+    }\n+\n+    fn emit_map_elt_key<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+\n+    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult where\n+        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n+    {\n+        f(self)\n+    }\n+}\n+\n+impl<'a> Encoder<'a> {\n+    pub fn position(&self) -> usize {\n+        self.cursor.position() as usize\n+    }\n+\n+    pub fn from_rbml<'b: 'c, 'c>(rbml: &'c mut ::writer::Encoder<'b>) -> Encoder<'c> {\n+        Encoder {\n+            cursor: rbml.writer\n+        }\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// Decoder\n+//=-----------------------------------------------------------------------------\n+\n+pub struct Decoder<'a> {\n+    pub data: &'a [u8],\n+    position: usize,\n+}\n+\n+impl<'a> Decoder<'a> {\n+    pub fn new(data: &'a [u8], position: usize) -> Decoder<'a> {\n+        Decoder {\n+            data: data,\n+            position: position\n+        }\n+    }\n+\n+    pub fn position(&self) -> usize {\n+        self.position\n+    }\n+\n+    pub fn advance(&mut self, bytes: usize) {\n+        self.position += bytes;\n+    }\n+}\n+\n+macro_rules! read_uleb128 {\n+    ($dec:expr, $t:ty) => ({\n+        let (value, bytes_read) = read_unsigned_leb128($dec.data, $dec.position);\n+        $dec.position += bytes_read;\n+        Ok(value as $t)\n+    })\n+}\n+\n+macro_rules! read_sleb128 {\n+    ($dec:expr, $t:ty) => ({\n+        let (value, bytes_read) = read_signed_leb128($dec.data, $dec.position);\n+        $dec.position += bytes_read;\n+        Ok(value as $t)\n+    })\n+}\n+\n+\n+impl<'a> serialize::Decoder for Decoder<'a> {\n+    type Error = DecodeError;\n+\n+    fn read_nil(&mut self) -> Result<(), Self::Error> {\n+        Ok(())\n+    }\n+\n+    fn read_u64(&mut self) -> Result<u64, Self::Error> {\n+        read_uleb128!(self, u64)\n+    }\n+\n+    fn read_u32(&mut self) -> Result<u32, Self::Error> {\n+        read_uleb128!(self, u32)\n+    }\n+\n+    fn read_u16(&mut self) -> Result<u16, Self::Error> {\n+        read_uleb128!(self, u16)\n+    }\n+\n+    fn read_u8(&mut self) -> Result<u8, Self::Error> {\n+        let value = self.data[self.position];\n+        self.position += 1;\n+        Ok(value)\n+    }\n+\n+    fn read_uint(&mut self) -> Result<usize, Self::Error> {\n+        read_uleb128!(self, usize)\n+    }\n+\n+    fn read_i64(&mut self) -> Result<i64, Self::Error> {\n+        read_sleb128!(self, i64)\n+    }\n+\n+    fn read_i32(&mut self) -> Result<i32, Self::Error> {\n+        read_sleb128!(self, i32)\n+    }\n+\n+    fn read_i16(&mut self) -> Result<i16, Self::Error> {\n+        read_sleb128!(self, i16)\n+    }\n+\n+    fn read_i8(&mut self) -> Result<i8, Self::Error> {\n+        let as_u8 = self.data[self.position];\n+        self.position += 1;\n+        unsafe {\n+            Ok(::std::mem::transmute(as_u8))\n+        }\n+    }\n+\n+    fn read_int(&mut self) -> Result<isize, Self::Error> {\n+        read_sleb128!(self, isize)\n+    }\n+\n+    fn read_bool(&mut self) -> Result<bool, Self::Error> {\n+        let value = try!(self.read_u8());\n+        Ok(value != 0)\n+    }\n+\n+    fn read_f64(&mut self) -> Result<f64, Self::Error> {\n+        let bits = try!(self.read_u64());\n+        Ok(unsafe { ::std::mem::transmute(bits) })\n+    }\n+\n+    fn read_f32(&mut self) -> Result<f32, Self::Error> {\n+        let bits = try!(self.read_u32());\n+        Ok(unsafe { ::std::mem::transmute(bits) })\n+    }\n+\n+    fn read_char(&mut self) -> Result<char, Self::Error> {\n+        let bits = try!(self.read_u32());\n+        Ok(::std::char::from_u32(bits).unwrap())\n+    }\n+\n+    fn read_str(&mut self) -> Result<String, Self::Error> {\n+        let len = try!(self.read_uint());\n+        let s = ::std::str::from_utf8(&self.data[self.position .. self.position + len]).unwrap();\n+        self.position += len;\n+        Ok(s.to_string())\n+    }\n+\n+    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_enum_variant<T, F>(&mut self,\n+                               _: &[&str],\n+                               mut f: F)\n+                               -> Result<T, Self::Error>\n+        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    {\n+        let disr = try!(self.read_uint());\n+        f(self, disr)\n+    }\n+\n+    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_enum_struct_variant<T, F>(&mut self,\n+                                      _: &[&str],\n+                                      mut f: F) -> Result<T, Self::Error>\n+        where F: FnMut(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    {\n+        let disr = try!(self.read_uint());\n+        f(self, disr)\n+    }\n+\n+    fn read_enum_struct_variant_field<T, F>(&mut self,\n+                                            _name: &str,\n+                                            _idx: usize,\n+                                            f: F)\n+                                            -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_struct<T, F>(&mut self, _name: &str, _: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_struct_field<T, F>(&mut self,\n+                               _name: &str,\n+                               _idx: usize, f: F)\n+                               -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_tuple<T, F>(&mut self, tuple_len: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        self.read_seq(move |d, len| {\n+            if len == tuple_len {\n+                f(d)\n+            } else {\n+                let err = format!(\"Invalid tuple length. Expected {}, found {}\",\n+                                   tuple_len,\n+                                   len);\n+                Err(DecodeError::Expected(err))\n+            }\n+        })\n+    }\n+\n+    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        self.read_seq_elt(idx, f)\n+    }\n+\n+    fn read_tuple_struct<T, F>(&mut self,\n+                               _name: &str,\n+                               len: usize, f: F)\n+                               -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        self.read_tuple(len, f)\n+    }\n+\n+    fn read_tuple_struct_arg<T, F>(&mut self,\n+                                   idx: usize,\n+                                   f: F)\n+                                   -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        self.read_tuple_arg(idx, f)\n+    }\n+\n+    fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error> where\n+        F: FnMut(&mut Decoder<'a>, bool) -> Result<T, Self::Error>,\n+    {\n+        self.read_enum(\"Option\", move |this| {\n+            this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| {\n+                match idx {\n+                    0 => f(this, false),\n+                    1 => f(this, true),\n+                    _ => {\n+                        let msg = format!(\"Invalid Option index: {}\", idx);\n+                        Err(DecodeError::Expected(msg))\n+                    }\n+                }\n+            })\n+        })\n+    }\n+\n+    fn read_seq<T, F>(&mut self, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    {\n+        let len = try!(self.read_uint());\n+        f(self, len)\n+    }\n+\n+    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_map<T, F>(&mut self, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>, usize) -> Result<T, Self::Error>,\n+    {\n+        let len = try!(self.read_uint());\n+        f(self, len)\n+    }\n+\n+    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error> where\n+        F: FnOnce(&mut Decoder<'a>) -> Result<T, Self::Error>,\n+    {\n+        f(self)\n+    }\n+\n+    fn error(&mut self, err: &str) -> Self::Error {\n+        DecodeError::ApplicationError(err.to_string())\n+    }\n+}\n+\n+\n+#[cfg(test)]\n+mod tests {\n+    use serialize::{Encodable, Decodable};\n+    use std::io::{Cursor};\n+    use std::fmt::Debug;\n+    use super::{Encoder, Decoder};\n+\n+    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+    struct Struct {\n+        a: (),\n+        b: u8,\n+        c: u16,\n+        d: u32,\n+        e: u64,\n+        f: usize,\n+\n+        g: i8,\n+        h: i16,\n+        i: i32,\n+        j: i64,\n+        k: isize,\n+\n+        l: char,\n+        m: String,\n+        n: f32,\n+        o: f64,\n+        p: bool,\n+        q: Option<u32>,\n+    }\n+\n+\n+    fn check_round_trip<T: Encodable+Decodable+PartialEq+Debug>(values: Vec<T>) {\n+        let mut cursor = Cursor::new(Vec::new());\n+\n+        for value in &values {\n+            let mut encoder = Encoder::new(&mut cursor);\n+            Encodable::encode(&value, &mut encoder).unwrap();\n+        }\n+\n+        let data = cursor.into_inner();\n+        let mut decoder = Decoder::new(&data[..], 0);\n+\n+        for value in values {\n+            let decoded = Decodable::decode(&mut decoder).unwrap();\n+            assert_eq!(value, decoded);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unit() {\n+        check_round_trip(vec![(), (), (), ()]);\n+    }\n+\n+    #[test]\n+    fn test_u8() {\n+        let mut vec = vec![];\n+        for i in ::std::u8::MIN .. ::std::u8::MAX {\n+            vec.push(i);\n+        }\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_u16() {\n+        for i in ::std::u16::MIN .. ::std::u16::MAX {\n+            check_round_trip(vec![1, 2, 3, i, i, i]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_u32() {\n+        check_round_trip(vec![1, 2, 3, ::std::u32::MIN, 0, 1, ::std::u32::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_u64() {\n+        check_round_trip(vec![1, 2, 3, ::std::u64::MIN, 0, 1, ::std::u64::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_usize() {\n+        check_round_trip(vec![1, 2, 3, ::std::usize::MIN, 0, 1, ::std::usize::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_i8() {\n+        let mut vec = vec![];\n+        for i in ::std::i8::MIN .. ::std::i8::MAX {\n+            vec.push(i);\n+        }\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_i16() {\n+        for i in ::std::i16::MIN .. ::std::i16::MAX {\n+            check_round_trip(vec![-1, 2, -3, i, i, i, 2]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_i32() {\n+        check_round_trip(vec![-1, 2, -3, ::std::i32::MIN, 0, 1, ::std::i32::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_i64() {\n+        check_round_trip(vec![-1, 2, -3, ::std::i64::MIN, 0, 1, ::std::i64::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_isize() {\n+        check_round_trip(vec![-1, 2, -3, ::std::isize::MIN, 0, 1, ::std::isize::MAX, 2, 1]);\n+    }\n+\n+    #[test]\n+    fn test_bool() {\n+        check_round_trip(vec![false, true, true, false, false]);\n+    }\n+\n+    #[test]\n+    fn test_f32() {\n+        let mut vec = vec![];\n+        for i in -100 .. 100 {\n+            vec.push( (i as f32) / 3.0 );\n+        }\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_f64() {\n+        let mut vec = vec![];\n+        for i in -100 .. 100 {\n+            vec.push( (i as f64) / 3.0 );\n+        }\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_char() {\n+        let vec = vec!['a', 'b', 'c', 'd', 'A', 'X', ' ', '#', '\u00d6', '\u00c4', '\u00b5', '\u20ac'];\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_string() {\n+        let vec = vec![\n+            \"abcbu\u00d6eiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpapmaebn\".to_string(),\n+            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmeabpnvapeapmaebn\".to_string(),\n+            \"abcbu\u00d6ganei\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpnvapeapmaebn\".to_string(),\n+            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5sbpmaebn\".to_string(),\n+            \"abcbu\u00d6ganeiov\u00c4name\u00dcavmp\u00dfvmea\u20ac\u00b5nvapeapmaebn\".to_string()];\n+\n+        check_round_trip(vec);\n+    }\n+\n+    #[test]\n+    fn test_option() {\n+        check_round_trip(vec![Some(-1i8)]);\n+        check_round_trip(vec![Some(-2i16)]);\n+        check_round_trip(vec![Some(-3i32)]);\n+        check_round_trip(vec![Some(-4i64)]);\n+        check_round_trip(vec![Some(-5isize)]);\n+\n+        let none_i8: Option<i8> = None;\n+        check_round_trip(vec![none_i8]);\n+\n+        let none_i16: Option<i16> = None;\n+        check_round_trip(vec![none_i16]);\n+\n+        let none_i32: Option<i32> = None;\n+        check_round_trip(vec![none_i32]);\n+\n+        let none_i64: Option<i64> = None;\n+        check_round_trip(vec![none_i64]);\n+\n+        let none_isize: Option<isize> = None;\n+        check_round_trip(vec![none_isize]);\n+    }\n+\n+    #[test]\n+    fn test_struct() {\n+        check_round_trip(vec![Struct {\n+            a: (),\n+            b: 10,\n+            c: 11,\n+            d: 12,\n+            e: 13,\n+            f: 14,\n+\n+            g: 15,\n+            h: 16,\n+            i: 17,\n+            j: 18,\n+            k: 19,\n+\n+            l: 'x',\n+            m: \"abc\".to_string(),\n+            n: 20.5,\n+            o: 21.5,\n+            p: false,\n+            q: None,\n+        }]);\n+\n+        check_round_trip(vec![Struct {\n+            a: (),\n+            b: 101,\n+            c: 111,\n+            d: 121,\n+            e: 131,\n+            f: 141,\n+\n+            g: -15,\n+            h: -16,\n+            i: -17,\n+            j: -18,\n+            k: -19,\n+\n+            l: 'y',\n+            m: \"def\".to_string(),\n+            n: -20.5,\n+            o: -21.5,\n+            p: true,\n+            q: Some(1234567),\n+        }]);\n+    }\n+\n+    #[derive(PartialEq, Clone, Debug, RustcEncodable, RustcDecodable)]\n+    enum Enum {\n+        Variant1,\n+        Variant2(usize, f32),\n+        Variant3 { a: i32, b: char, c: bool }\n+    }\n+\n+    #[test]\n+    fn test_enum() {\n+        check_round_trip(vec![Enum::Variant1,\n+                              Enum::Variant2(1, 2.5),\n+                              Enum::Variant3 { a: 3, b: 'b', c: false },\n+                              Enum::Variant3 { a: -4, b: 'f', c: true }]);\n+    }\n+\n+    #[test]\n+    fn test_sequence() {\n+        let mut vec = vec![];\n+        for i in -100i64 .. 100i64 {\n+            vec.push(i*100000);\n+        }\n+\n+        check_round_trip(vec![vec]);\n+    }\n+\n+    #[test]\n+    fn test_hash_map() {\n+        use std::collections::HashMap;\n+        let mut map = HashMap::new();\n+        for i in -100i64 .. 100i64 {\n+            map.insert(i*100000, i*10000);\n+        }\n+\n+        check_round_trip(vec![map]);\n+    }\n+\n+    #[test]\n+    fn test_tuples() {\n+        check_round_trip(vec![('x', (), false, 0.5f32)]);\n+        check_round_trip(vec![(9i8, 10u16, 1.5f64)]);\n+        check_round_trip(vec![(-12i16, 11u8, 12usize)]);\n+        check_round_trip(vec![(1234567isize, 100000000000000u64, 99999999999999i64)]);\n+        check_round_trip(vec![(String::new(), \"some string\".to_string())]);\n+    }\n+}"}, {"sha": "380f543f969f06b4c2a77dde7c27233957032325", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -432,8 +432,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n /// Note, however, that this only works for RBML-based encoding and decoding at\n /// the moment.\n pub mod tls {\n-    use rbml::writer::Encoder as RbmlEncoder;\n-    use rbml::reader::Decoder as RbmlDecoder;\n+    use rbml::opaque::Encoder as OpaqueEncoder;\n+    use rbml::opaque::Decoder as OpaqueDecoder;\n     use serialize;\n     use std::mem;\n     use middle::ty::{self, Ty};\n@@ -442,8 +442,8 @@ pub mod tls {\n \n     pub trait EncodingContext<'tcx> {\n         fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-        fn encode_ty(&self, rbml_w: &mut RbmlEncoder, t: Ty<'tcx>);\n-        fn encode_substs(&self, rbml_w: &mut RbmlEncoder, substs: &Substs<'tcx>);\n+        fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: Ty<'tcx>);\n+        fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>);\n     }\n \n     /// Marker type used for the scoped TLS slot.\n@@ -455,13 +455,13 @@ pub mod tls {\n \n     /// Execute f after pushing the given EncodingContext onto the TLS stack.\n     pub fn enter_encoding_context<'tcx, F, R>(ecx: &EncodingContext<'tcx>,\n-                                              rbml_w: &mut RbmlEncoder,\n+                                              encoder: &mut OpaqueEncoder,\n                                               f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut RbmlEncoder) -> R\n+        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R\n     {\n-        let tls_payload = (ecx as *const _, rbml_w as *mut _);\n+        let tls_payload = (ecx as *const _, encoder as *mut _);\n         let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_ENCODING.set(unsafe { &*tls_ptr }, || f(ecx, rbml_w))\n+        TLS_ENCODING.set(unsafe { &*tls_ptr }, || f(ecx, encoder))\n     }\n \n     /// Execute f with access to the thread-local encoding context and\n@@ -473,50 +473,50 @@ pub mod tls {\n     /// possible to construct cases where the EncodingContext is exchanged\n     /// while the same encoder is used, thus working with a wrong context.\n     pub fn with_encoding_context<'tcx, E, F, R>(encoder: &mut E, f: F) -> R\n-        where F: FnOnce(&EncodingContext<'tcx>, &mut RbmlEncoder) -> R,\n+        where F: FnOnce(&EncodingContext<'tcx>, &mut OpaqueEncoder) -> R,\n               E: serialize::Encoder\n     {\n         unsafe {\n-            unsafe_with_encoding_context(|ecx, rbml_w| {\n-                assert!(encoder as *mut _ as usize == rbml_w as *mut _ as usize);\n+            unsafe_with_encoding_context(|ecx, tls_encoder| {\n+                assert!(encoder as *mut _ as usize == tls_encoder as *mut _ as usize);\n \n                 let ecx: &EncodingContext<'tcx> = mem::transmute(ecx);\n \n-                f(ecx, rbml_w)\n+                f(ecx, tls_encoder)\n             })\n         }\n     }\n \n     /// Execute f with access to the thread-local encoding context and\n     /// rbml encoder.\n     pub unsafe fn unsafe_with_encoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&EncodingContext, &mut RbmlEncoder) -> R\n+        where F: FnOnce(&EncodingContext, &mut OpaqueEncoder) -> R\n     {\n         TLS_ENCODING.with(|tls| {\n             let tls_payload = (tls as *const TlsPayload)\n-                                   as *mut (&EncodingContext, &mut RbmlEncoder);\n+                                   as *mut (&EncodingContext, &mut OpaqueEncoder);\n             f((*tls_payload).0, (*tls_payload).1)\n         })\n     }\n \n     pub trait DecodingContext<'tcx> {\n         fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n-        fn decode_ty(&self, rbml_r: &mut RbmlDecoder) -> ty::Ty<'tcx>;\n-        fn decode_substs(&self, rbml_r: &mut RbmlDecoder) -> Substs<'tcx>;\n+        fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx>;\n+        fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx>;\n         fn translate_def_id(&self, def_id: DefId) -> DefId;\n     }\n \n     scoped_thread_local!(static TLS_DECODING: TlsPayload);\n \n     /// Execute f after pushing the given DecodingContext onto the TLS stack.\n     pub fn enter_decoding_context<'tcx, F, R>(dcx: &DecodingContext<'tcx>,\n-                                              rbml_r: &mut RbmlDecoder,\n+                                              decoder: &mut OpaqueDecoder,\n                                               f: F) -> R\n-        where F: FnOnce(&DecodingContext<'tcx>, &mut RbmlDecoder) -> R\n+        where F: FnOnce(&DecodingContext<'tcx>, &mut OpaqueDecoder) -> R\n     {\n-        let tls_payload = (dcx as *const _, rbml_r as *mut _);\n+        let tls_payload = (dcx as *const _, decoder as *mut _);\n         let tls_ptr = &tls_payload as *const _ as *const TlsPayload;\n-        TLS_DECODING.set(unsafe { &*tls_ptr }, || f(dcx, rbml_r))\n+        TLS_DECODING.set(unsafe { &*tls_ptr }, || f(dcx, decoder))\n     }\n \n     /// Execute f with access to the thread-local decoding context and\n@@ -530,28 +530,28 @@ pub mod tls {\n     pub fn with_decoding_context<'decoder, 'tcx, D, F, R>(d: &'decoder mut D, f: F) -> R\n         where D: serialize::Decoder,\n               F: FnOnce(&DecodingContext<'tcx>,\n-                        &mut RbmlDecoder) -> R,\n+                        &mut OpaqueDecoder) -> R,\n               'tcx: 'decoder\n     {\n         unsafe {\n-            unsafe_with_decoding_context(|dcx, rbml_r| {\n-                assert!((d as *mut _ as usize) == (rbml_r as *mut _ as usize));\n+            unsafe_with_decoding_context(|dcx, decoder| {\n+                assert!((d as *mut _ as usize) == (decoder as *mut _ as usize));\n \n                 let dcx: &DecodingContext<'tcx> = mem::transmute(dcx);\n \n-                f(dcx, rbml_r)\n+                f(dcx, decoder)\n             })\n         }\n     }\n \n     /// Execute f with access to the thread-local decoding context and\n     /// rbml decoder.\n     pub unsafe fn unsafe_with_decoding_context<F, R>(f: F) -> R\n-        where F: FnOnce(&DecodingContext, &mut RbmlDecoder) -> R\n+        where F: FnOnce(&DecodingContext, &mut OpaqueDecoder) -> R\n     {\n         TLS_DECODING.with(|tls| {\n             let tls_payload = (tls as *const TlsPayload)\n-                                   as *mut (&DecodingContext, &mut RbmlDecoder);\n+                                   as *mut (&DecodingContext, &mut OpaqueDecoder);\n             f((*tls_payload).0, (*tls_payload).1)\n         })\n     }"}, {"sha": "8c3bd3c4f8a5352851b919077ad90224bc70c425", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 61, "deletions": 75, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -292,7 +292,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n \n fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n     rbml_w.start_tag(c::tag_tree as usize);\n-    item.encode(rbml_w);\n+    rbml_w.emit_opaque(|this| item.encode(this));\n     rbml_w.end_tag();\n }\n \n@@ -361,8 +361,8 @@ fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n \n fn decode_ast(par_doc: rbml::Doc) -> InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as usize);\n-    let mut d = reader::Decoder::new(chi_doc);\n-    Decodable::decode(&mut d).unwrap()\n+    let mut rbml_r = reader::Decoder::new(chi_doc);\n+    rbml_r.read_opaque(|decoder, _| Decodable::decode(decoder)).unwrap()\n }\n \n // ______________________________________________________________________\n@@ -509,21 +509,6 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n // ______________________________________________________________________\n // Encoding and decoding the side tables\n \n-trait get_ty_str_ctxt<'tcx> {\n-    fn ty_str_ctxt<'a>(&'a self) -> tyencode::ctxt<'a, 'tcx>;\n-}\n-\n-impl<'a, 'tcx> get_ty_str_ctxt<'tcx> for e::EncodeContext<'a, 'tcx> {\n-    fn ty_str_ctxt<'b>(&'b self) -> tyencode::ctxt<'b, 'tcx> {\n-        tyencode::ctxt {\n-            diag: self.tcx.sess.diagnostic(),\n-            ds: e::def_to_string,\n-            tcx: self.tcx,\n-            abbrevs: &self.type_abbrevs\n-        }\n-    }\n-}\n-\n trait rbml_writer_helpers<'tcx> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region);\n     fn emit_ty<'a>(&mut self, ecx: &e::EncodeContext<'a, 'tcx>, ty: Ty<'tcx>);\n@@ -548,11 +533,15 @@ trait rbml_writer_helpers<'tcx> {\n \n impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n     fn emit_region(&mut self, ecx: &e::EncodeContext, r: ty::Region) {\n-        self.emit_opaque(|this| Ok(e::write_region(ecx, this, r)));\n+        self.emit_opaque(|this| Ok(tyencode::enc_region(&mut this.cursor,\n+                                                        &ecx.ty_str_ctxt(),\n+                                                        r)));\n     }\n \n     fn emit_ty<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, ty: Ty<'tcx>) {\n-        self.emit_opaque(|this| Ok(e::write_type(ecx, this, ty)));\n+        self.emit_opaque(|this| Ok(tyencode::enc_ty(&mut this.cursor,\n+                                                    &ecx.ty_str_ctxt(),\n+                                                    ty)));\n     }\n \n     fn emit_tys<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>, tys: &[Ty<'tcx>]) {\n@@ -561,27 +550,29 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n     fn emit_trait_ref<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           trait_ref: &ty::TraitRef<'tcx>) {\n-        self.emit_opaque(|this| Ok(e::write_trait_ref(ecx, this, trait_ref)));\n+        self.emit_opaque(|this| Ok(tyencode::enc_trait_ref(&mut this.cursor,\n+                                                           &ecx.ty_str_ctxt(),\n+                                                           *trait_ref)));\n     }\n \n     fn emit_predicate<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                           predicate: &ty::Predicate<'tcx>) {\n         self.emit_opaque(|this| {\n-            Ok(tyencode::enc_predicate(this,\n+            Ok(tyencode::enc_predicate(&mut this.cursor,\n                                        &ecx.ty_str_ctxt(),\n                                        predicate))\n         });\n     }\n \n     fn emit_existential_bounds<'b>(&mut self, ecx: &e::EncodeContext<'b,'tcx>,\n                                    bounds: &ty::ExistentialBounds<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(this,\n+        self.emit_opaque(|this| Ok(tyencode::enc_existential_bounds(&mut this.cursor,\n                                                                     &ecx.ty_str_ctxt(),\n                                                                     bounds)));\n     }\n \n     fn emit_builtin_bounds(&mut self, ecx: &e::EncodeContext, bounds: &ty::BuiltinBounds) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(this,\n+        self.emit_opaque(|this| Ok(tyencode::enc_builtin_bounds(&mut this.cursor,\n                                                                 &ecx.ty_str_ctxt(),\n                                                                 bounds)));\n     }\n@@ -608,9 +599,9 @@ impl<'a, 'tcx> rbml_writer_helpers<'tcx> for Encoder<'a> {\n \n     fn emit_substs<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n                        substs: &subst::Substs<'tcx>) {\n-        self.emit_opaque(|this| Ok(tyencode::enc_substs(this,\n-                                                           &ecx.ty_str_ctxt(),\n-                                                           substs)));\n+        self.emit_opaque(|this| Ok(tyencode::enc_substs(&mut this.cursor,\n+                                                        &ecx.ty_str_ctxt(),\n+                                                        substs)));\n     }\n \n     fn emit_auto_adjustment<'b>(&mut self, ecx: &e::EncodeContext<'b, 'tcx>,\n@@ -878,10 +869,6 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n                                    -> adjustment::AutoDerefRef<'tcx>;\n     fn read_autoref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n                             -> adjustment::AutoRef<'tcx>;\n-    fn convert_def_id(&mut self,\n-                      dcx: &DecodeContext,\n-                      did: DefId)\n-                      -> DefId;\n \n     // Versions of the type reading functions that don't need the full\n     // DecodeContext.\n@@ -933,12 +920,12 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_encoded<'b, 'c, F, R>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>, op: F) -> R\n         where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x,'tcx>) -> R\n     {\n-        return self.read_opaque(|this, doc| {\n+        return self.read_opaque(|_, doc| {\n             debug!(\"read_ty_encoded({})\", type_string(doc));\n             Ok(op(\n                 &mut tydecode::TyDecoder::with_doc(\n                     dcx.tcx, dcx.cdata.cnum, doc,\n-                    &mut |a| this.convert_def_id(dcx, a))))\n+                    &mut |d| convert_def_id(dcx, d))))\n         }).unwrap();\n \n         fn type_string(doc: rbml::Doc) -> String {\n@@ -989,9 +976,9 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n \n     fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                            -> subst::Substs<'tcx> {\n-        self.read_opaque(|this, doc| {\n+        self.read_opaque(|_, doc| {\n             Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n-                                             &mut |a| this.convert_def_id(dcx, a))\n+                                             &mut |d| convert_def_id(dcx, d))\n                .parse_substs())\n         }).unwrap()\n     }\n@@ -1097,47 +1084,46 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     {\n         Decodable::decode(self).unwrap()\n     }\n+}\n \n-    /// Converts a def-id that appears in a type.  The correct\n-    /// translation will depend on what kind of def-id this is.\n-    /// This is a subtle point: type definitions are not\n-    /// inlined into the current crate, so if the def-id names\n-    /// a nominal type or type alias, then it should be\n-    /// translated to refer to the source crate.\n-    ///\n-    /// However, *type parameters* are cloned along with the function\n-    /// they are attached to.  So we should translate those def-ids\n-    /// to refer to the new, cloned copy of the type parameter.\n-    /// We only see references to free type parameters in the body of\n-    /// an inlined function. In such cases, we need the def-id to\n-    /// be a local id so that the TypeContents code is able to lookup\n-    /// the relevant info in the ty_param_defs table.\n-    ///\n-    /// *Region parameters*, unfortunately, are another kettle of fish.\n-    /// In such cases, def_id's can appear in types to distinguish\n-    /// shadowed bound regions and so forth. It doesn't actually\n-    /// matter so much what we do to these, since regions are erased\n-    /// at trans time, but it's good to keep them consistent just in\n-    /// case. We translate them with `tr_def_id()` which will map\n-    /// the crate numbers back to the original source crate.\n-    ///\n-    /// Scopes will end up as being totally bogus. This can actually\n-    /// be fixed though.\n-    ///\n-    /// Unboxed closures are cloned along with the function being\n-    /// inlined, and all side tables use interned node IDs, so we\n-    /// translate their def IDs accordingly.\n-    ///\n-    /// It'd be really nice to refactor the type repr to not include\n-    /// def-ids so that all these distinctions were unnecessary.\n-    fn convert_def_id(&mut self,\n-                      dcx: &DecodeContext,\n-                      did: DefId)\n-                      -> DefId {\n-        let r = dcx.tr_def_id(did);\n-        debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n-        return r;\n-    }\n+// Converts a def-id that appears in a type.  The correct\n+// translation will depend on what kind of def-id this is.\n+// This is a subtle point: type definitions are not\n+// inlined into the current crate, so if the def-id names\n+// a nominal type or type alias, then it should be\n+// translated to refer to the source crate.\n+//\n+// However, *type parameters* are cloned along with the function\n+// they are attached to.  So we should translate those def-ids\n+// to refer to the new, cloned copy of the type parameter.\n+// We only see references to free type parameters in the body of\n+// an inlined function. In such cases, we need the def-id to\n+// be a local id so that the TypeContents code is able to lookup\n+// the relevant info in the ty_param_defs table.\n+//\n+// *Region parameters*, unfortunately, are another kettle of fish.\n+// In such cases, def_id's can appear in types to distinguish\n+// shadowed bound regions and so forth. It doesn't actually\n+// matter so much what we do to these, since regions are erased\n+// at trans time, but it's good to keep them consistent just in\n+// case. We translate them with `tr_def_id()` which will map\n+// the crate numbers back to the original source crate.\n+//\n+// Scopes will end up as being totally bogus. This can actually\n+// be fixed though.\n+//\n+// Unboxed closures are cloned along with the function being\n+// inlined, and all side tables use interned node IDs, so we\n+// translate their def IDs accordingly.\n+//\n+// It'd be really nice to refactor the type repr to not include\n+// def-ids so that all these distinctions were unnecessary.\n+fn convert_def_id(dcx: &DecodeContext,\n+                  did: DefId)\n+                  -> DefId {\n+    let r = dcx.tr_def_id(did);\n+    debug!(\"convert_def_id(did={:?})={:?}\", did, r);\n+    return r;\n }\n \n fn decode_side_tables(dcx: &DecodeContext,"}, {"sha": "54cccf087ebb61a0ec0c417317b784b2d9b25bf9", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -833,9 +833,11 @@ pub fn maybe_get_item_mir<'tcx>(cdata: Cmd,\n         };\n         let mut decoder = reader::Decoder::new(mir_doc);\n \n-        let mut mir = tls::enter_decoding_context(&dcx, &mut decoder, |_, decoder| {\n-            Decodable::decode(decoder).unwrap()\n-        });\n+        let mut mir = decoder.read_opaque(|opaque_decoder, _| {\n+            tls::enter_decoding_context(&dcx, opaque_decoder, |_, opaque_decoder| {\n+                Decodable::decode(opaque_decoder)\n+            })\n+        }).unwrap();\n \n         let mut def_id_and_span_translator = MirDefIdAndSpanTranslator {\n             crate_metadata: cdata,\n@@ -1643,7 +1645,9 @@ pub fn get_imported_filemaps(metadata: &[u8]) -> Vec<codemap::FileMap> {\n \n     reader::tagged_docs(cm_doc, tag_codemap_filemap).map(|filemap_doc| {\n         let mut decoder = reader::Decoder::new(filemap_doc);\n-        Decodable::decode(&mut decoder).unwrap()\n+        decoder.read_opaque(|opaque_decoder, _| {\n+            Decodable::decode(opaque_decoder)\n+        }).unwrap()\n     }).collect()\n }\n "}, {"sha": "26f32e207647fd0d4c948e285fb32fedbea49357", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 24, "deletions": 78, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -140,15 +140,9 @@ fn encode_trait_ref<'a, 'tcx>(rbml_w: &mut Encoder,\n                               ecx: &EncodeContext<'a, 'tcx>,\n                               trait_ref: ty::TraitRef<'tcx>,\n                               tag: usize) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-\n     rbml_w.start_tag(tag);\n-    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, trait_ref);\n+    tyencode::enc_trait_ref(rbml_w.writer, &ecx.ty_str_ctxt(), trait_ref);\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n }\n \n@@ -202,67 +196,28 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.wr_tagged_u64(tag_mod_child, id);\n }\n \n-pub fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                    rbml_w: &mut Encoder,\n-                                    closure_type: &ty::ClosureTy<'tcx>) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    tyencode::enc_closure_ty(rbml_w, ty_str_ctxt, closure_type);\n-}\n-\n-pub fn write_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n+fn write_closure_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             rbml_w: &mut Encoder,\n-                            typ: Ty<'tcx>) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    tyencode::enc_ty(rbml_w, ty_str_ctxt, typ);\n-}\n-\n-pub fn write_trait_ref<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n-                                 rbml_w: &mut Encoder,\n-                                trait_ref: &ty::TraitRef<'tcx>) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    tyencode::enc_trait_ref(rbml_w, ty_str_ctxt, *trait_ref);\n-}\n-\n-pub fn write_region(ecx: &EncodeContext,\n-                    rbml_w: &mut Encoder,\n-                    r: ty::Region) {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-    tyencode::enc_region(rbml_w, ty_str_ctxt, r);\n+                            closure_type: &ty::ClosureTy<'tcx>) {\n+    tyencode::enc_closure_ty(rbml_w.writer, &ecx.ty_str_ctxt(), closure_type);\n+    rbml_w.mark_stable_position();\n }\n \n fn encode_type<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                          rbml_w: &mut Encoder,\n                          typ: Ty<'tcx>) {\n     rbml_w.start_tag(tag_items_data_item_type);\n-    write_type(ecx, rbml_w, typ);\n+    tyencode::enc_ty(rbml_w.writer, &ecx.ty_str_ctxt(), typ);\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n }\n \n fn encode_region(ecx: &EncodeContext,\n                  rbml_w: &mut Encoder,\n                  r: ty::Region) {\n     rbml_w.start_tag(tag_items_data_region);\n-    write_region(ecx, rbml_w, r);\n+    tyencode::enc_region(rbml_w.writer, &ecx.ty_str_ctxt(), r);\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n }\n \n@@ -592,17 +547,10 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n {\n     rbml_w.start_tag(tag);\n \n-    // Type parameters\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-\n     for param in &generics.types {\n         rbml_w.start_tag(tag_type_param_def);\n-        tyencode::enc_type_param_def(rbml_w, ty_str_ctxt, param);\n+        tyencode::enc_type_param_def(rbml_w.writer, &ecx.ty_str_ctxt(), param);\n+        rbml_w.mark_stable_position();\n         rbml_w.end_tag();\n     }\n \n@@ -871,7 +819,11 @@ fn encode_mir(ecx: &EncodeContext, rbml_w: &mut Encoder, ii: InlinedItemRef) {\n \n     if let Some(mir) = ecx.mir_map.get(&id) {\n         rbml_w.start_tag(tag_mir as usize);\n-        Encodable::encode(mir, rbml_w).unwrap();\n+        rbml_w.emit_opaque(|opaque_encoder| {\n+            tls::enter_encoding_context(ecx, opaque_encoder, |_, opaque_encoder| {\n+                Encodable::encode(mir, opaque_encoder)\n+            })\n+        }).unwrap();\n         rbml_w.end_tag();\n     }\n }\n@@ -916,23 +868,17 @@ fn encode_xrefs<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                           rbml_w: &mut Encoder,\n                           xrefs: FnvHashMap<XRef<'tcx>, u32>)\n {\n-    let ty_str_ctxt = &tyencode::ctxt {\n-        diag: ecx.diag,\n-        ds: def_to_string,\n-        tcx: ecx.tcx,\n-        abbrevs: &ecx.type_abbrevs\n-    };\n-\n     let mut xref_positions = vec![0; xrefs.len()];\n     rbml_w.start_tag(tag_xref_data);\n     for (xref, id) in xrefs.into_iter() {\n         xref_positions[id as usize] = rbml_w.mark_stable_position() as u32;\n         match xref {\n             XRef::Predicate(p) => {\n-                tyencode::enc_predicate(rbml_w, ty_str_ctxt, &p)\n+                tyencode::enc_predicate(rbml_w.writer, &ecx.ty_str_ctxt(), &p)\n             }\n         }\n     }\n+    rbml_w.mark_stable_position();\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_xref_index);\n@@ -1750,7 +1696,9 @@ fn encode_codemap(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n         }\n \n         rbml_w.start_tag(tag_codemap_filemap);\n-        filemap.encode(rbml_w);\n+        rbml_w.emit_opaque(|opaque_encoder| {\n+            filemap.encode(opaque_encoder)\n+        }).unwrap();\n         rbml_w.end_tag();\n     }\n \n@@ -1961,9 +1909,7 @@ pub fn encode_metadata(parms: EncodeParams, krate: &hir::Crate) -> Vec<u8> {\n \n     {\n         let mut rbml_w = Encoder::new(&mut wr);\n-        tls::enter_encoding_context(&ecx, &mut rbml_w, |_, rbml_w| {\n-            encode_metadata_inner(rbml_w, &ecx, krate)\n-        });\n+        encode_metadata_inner(&mut rbml_w, &ecx, krate)\n     }\n \n     // RBML compacts the encoded bytes whenever appropriate,\n@@ -2132,7 +2078,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n // Get the encoded string for a type\n pub fn encoded_ty<'tcx>(tcx: &ty::ctxt<'tcx>, t: Ty<'tcx>) -> Vec<u8> {\n     let mut wr = Cursor::new(Vec::new());\n-    tyencode::enc_ty(&mut Encoder::new(&mut wr), &tyencode::ctxt {\n+    tyencode::enc_ty(&mut wr, &tyencode::ctxt {\n         diag: tcx.sess.diagnostic(),\n         ds: def_to_string,\n         tcx: tcx,"}, {"sha": "37e661c21e15a1383f12fe24b60fd93c3649b4bd", "filename": "src/librustc_metadata/tls_context.rs", "status": "modified", "additions": 12, "deletions": 19, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftls_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftls_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftls_context.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -11,8 +11,8 @@\n // This module provides implementations for the thread-local encoding and\n // decoding context traits in rustc::middle::cstore::tls.\n \n-use rbml::writer::Encoder as RbmlEncoder;\n-use rbml::reader::Decoder as RbmlDecoder;\n+use rbml::opaque::Encoder as OpaqueEncoder;\n+use rbml::opaque::Decoder as OpaqueDecoder;\n use rustc::middle::cstore::tls;\n use rustc::middle::def_id::DefId;\n use rustc::middle::subst::Substs;\n@@ -23,25 +23,18 @@ use encoder;\n use tydecode::TyDecoder;\n use tyencode;\n \n-\n impl<'a, 'tcx: 'a> tls::EncodingContext<'tcx> for encoder::EncodeContext<'a, 'tcx> {\n \n     fn tcx<'s>(&'s self) -> &'s ty::ctxt<'tcx> {\n         &self.tcx\n     }\n \n-    fn encode_ty(&self, rbml_w: &mut RbmlEncoder, t: ty::Ty<'tcx>) {\n-        encoder::write_type(self, rbml_w, t);\n+    fn encode_ty(&self, encoder: &mut OpaqueEncoder, t: ty::Ty<'tcx>) {\n+        tyencode::enc_ty(encoder.cursor, &self.ty_str_ctxt(), t);\n     }\n \n-    fn encode_substs(&self, rbml_w: &mut RbmlEncoder, substs: &Substs<'tcx>) {\n-        let ty_str_ctxt = &tyencode::ctxt {\n-            diag: self.diag,\n-            ds: encoder::def_to_string,\n-            tcx: self.tcx,\n-            abbrevs: &self.type_abbrevs\n-        };\n-        tyencode::enc_substs(rbml_w, ty_str_ctxt, substs);\n+    fn encode_substs(&self, encoder: &mut OpaqueEncoder, substs: &Substs<'tcx>) {\n+        tyencode::enc_substs(encoder.cursor, &self.ty_str_ctxt(), substs);\n     }\n }\n \n@@ -56,12 +49,12 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n         &self.tcx\n     }\n \n-    fn decode_ty(&self, rbml_r: &mut RbmlDecoder) -> ty::Ty<'tcx> {\n+    fn decode_ty(&self, decoder: &mut OpaqueDecoder) -> ty::Ty<'tcx> {\n         let def_id_convert = &mut |did| {\n             decoder::translate_def_id(self.crate_metadata, did)\n         };\n \n-        let starting_position = rbml_r.position();\n+        let starting_position = decoder.position();\n \n         let mut ty_decoder = TyDecoder::new(\n             self.crate_metadata.data.as_slice(),\n@@ -77,16 +70,16 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n         // We can just reuse the tydecode implementation for parsing types, but\n         // we have to make sure to leave the rbml reader at the position just\n         // after the type.\n-        rbml_r.advance(end_position - starting_position);\n+        decoder.advance(end_position - starting_position);\n         ty\n     }\n \n-    fn decode_substs(&self, rbml_r: &mut RbmlDecoder) -> Substs<'tcx> {\n+    fn decode_substs(&self, decoder: &mut OpaqueDecoder) -> Substs<'tcx> {\n         let def_id_convert = &mut |did| {\n             decoder::translate_def_id(self.crate_metadata, did)\n         };\n \n-        let starting_position = rbml_r.position();\n+        let starting_position = decoder.position();\n \n         let mut ty_decoder = TyDecoder::new(\n             self.crate_metadata.data.as_slice(),\n@@ -99,7 +92,7 @@ impl<'a, 'tcx: 'a> tls::DecodingContext<'tcx> for DecodingContext<'a, 'tcx> {\n \n         let end_position = ty_decoder.position();\n \n-        rbml_r.advance(end_position - starting_position);\n+        decoder.advance(end_position - starting_position);\n         substs\n     }\n "}, {"sha": "c7a5faed35cd01bbf5cce863536a2d773142f422", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -25,6 +25,7 @@ use middle::subst::VecPerParamSpace;\n use middle::ty::{self, ToPredicate, Ty, HasTypeFlags};\n \n use rbml;\n+use rbml::leb128;\n use std::str;\n use syntax::abi;\n use syntax::ast;\n@@ -103,9 +104,10 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n     }\n \n     fn parse_vuint(&mut self) -> usize {\n-        let res = rbml::reader::vuint_at(self.data, self.pos).unwrap();\n-        self.pos = res.next;\n-        res.val\n+        let (value, bytes_read) = leb128::read_unsigned_leb128(self.data,\n+                                                               self.pos);\n+        self.pos += bytes_read;\n+        value as usize\n     }\n \n     fn parse_name(&mut self, last: char) -> ast::Name {"}, {"sha": "f03c25d698feb927020b084d3af9f2a737b9198a", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 168, "deletions": 146, "changes": 314, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -31,9 +31,8 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::errors::Handler;\n \n-use rbml::writer::{self, Encoder};\n-\n-macro_rules! mywrite { ($w:expr, $($arg:tt)*) => ({ write!($w.writer, $($arg)*); }) }\n+use rbml::leb128;\n+use encoder;\n \n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a Handler,\n@@ -44,6 +43,17 @@ pub struct ctxt<'a, 'tcx: 'a> {\n     pub abbrevs: &'a abbrev_map<'tcx>\n }\n \n+impl<'a, 'tcx> encoder::EncodeContext<'a, 'tcx> {\n+    pub fn ty_str_ctxt<'b>(&'b self) -> ctxt<'b, 'tcx> {\n+        ctxt {\n+            diag: self.tcx.sess.diagnostic(),\n+            ds: encoder::def_to_string,\n+            tcx: self.tcx,\n+            abbrevs: &self.type_abbrevs\n+        }\n+    }\n+}\n+\n // Compact string representation for Ty values. API TyStr & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep.\n // Whatever format you choose should not contain pipe characters.\n@@ -53,125 +63,129 @@ pub struct ty_abbrev {\n \n pub type abbrev_map<'tcx> = RefCell<FnvHashMap<Ty<'tcx>, ty_abbrev>>;\n \n-pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n+pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n     match cx.abbrevs.borrow_mut().get(&t) {\n-        Some(a) => { w.writer.write_all(&a.s); return; }\n+        Some(a) => { w.write_all(&a.s); return; }\n         None => {}\n     }\n \n-    // type abbreviations needs a stable position\n-    let pos = w.mark_stable_position();\n+    let pos = w.position();\n \n     match t.sty {\n-        ty::TyBool => mywrite!(w, \"b\"),\n-        ty::TyChar => mywrite!(w, \"c\"),\n+        ty::TyBool => { write!(w, \"b\"); }\n+        ty::TyChar => { write!(w, \"c\"); }\n         ty::TyInt(t) => {\n             match t {\n-                ast::TyIs => mywrite!(w, \"is\"),\n-                ast::TyI8 => mywrite!(w, \"MB\"),\n-                ast::TyI16 => mywrite!(w, \"MW\"),\n-                ast::TyI32 => mywrite!(w, \"ML\"),\n-                ast::TyI64 => mywrite!(w, \"MD\")\n-            }\n+                ast::TyIs => write!(w, \"is\"),\n+                ast::TyI8 => write!(w, \"MB\"),\n+                ast::TyI16 => write!(w, \"MW\"),\n+                ast::TyI32 => write!(w, \"ML\"),\n+                ast::TyI64 => write!(w, \"MD\")\n+            };\n         }\n         ty::TyUint(t) => {\n             match t {\n-                ast::TyUs => mywrite!(w, \"us\"),\n-                ast::TyU8 => mywrite!(w, \"Mb\"),\n-                ast::TyU16 => mywrite!(w, \"Mw\"),\n-                ast::TyU32 => mywrite!(w, \"Ml\"),\n-                ast::TyU64 => mywrite!(w, \"Md\")\n-            }\n+                ast::TyUs => write!(w, \"us\"),\n+                ast::TyU8 => write!(w, \"Mb\"),\n+                ast::TyU16 => write!(w, \"Mw\"),\n+                ast::TyU32 => write!(w, \"Ml\"),\n+                ast::TyU64 => write!(w, \"Md\")\n+            };\n         }\n         ty::TyFloat(t) => {\n             match t {\n-                ast::TyF32 => mywrite!(w, \"Mf\"),\n-                ast::TyF64 => mywrite!(w, \"MF\"),\n-            }\n+                ast::TyF32 => write!(w, \"Mf\"),\n+                ast::TyF64 => write!(w, \"MF\"),\n+            };\n         }\n         ty::TyEnum(def, substs) => {\n-            mywrite!(w, \"t[{}|\", (cx.ds)(def.did));\n+            write!(w, \"t[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n         ty::TyTrait(box ty::TraitTy { ref principal,\n                                        ref bounds }) => {\n-            mywrite!(w, \"x[\");\n+            write!(w, \"x[\");\n             enc_trait_ref(w, cx, principal.0);\n             enc_existential_bounds(w, cx, bounds);\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n         ty::TyTuple(ref ts) => {\n-            mywrite!(w, \"T[\");\n+            write!(w, \"T[\");\n             for t in ts { enc_ty(w, cx, *t); }\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n-        ty::TyBox(typ) => { mywrite!(w, \"~\"); enc_ty(w, cx, typ); }\n-        ty::TyRawPtr(mt) => { mywrite!(w, \"*\"); enc_mt(w, cx, mt); }\n+        ty::TyBox(typ) => { write!(w, \"~\"); enc_ty(w, cx, typ); }\n+        ty::TyRawPtr(mt) => { write!(w, \"*\"); enc_mt(w, cx, mt); }\n         ty::TyRef(r, mt) => {\n-            mywrite!(w, \"&\");\n+            write!(w, \"&\");\n             enc_region(w, cx, *r);\n             enc_mt(w, cx, mt);\n         }\n         ty::TyArray(t, sz) => {\n-            mywrite!(w, \"V\");\n+            write!(w, \"V\");\n             enc_ty(w, cx, t);\n-            mywrite!(w, \"/{}|\", sz);\n+            write!(w, \"/{}|\", sz);\n         }\n         ty::TySlice(t) => {\n-            mywrite!(w, \"V\");\n+            write!(w, \"V\");\n             enc_ty(w, cx, t);\n-            mywrite!(w, \"/|\");\n+            write!(w, \"/|\");\n         }\n         ty::TyStr => {\n-            mywrite!(w, \"v\");\n+            write!(w, \"v\");\n         }\n         ty::TyBareFn(Some(def_id), f) => {\n-            mywrite!(w, \"F\");\n-            mywrite!(w, \"{}|\", (cx.ds)(def_id));\n+            write!(w, \"F\");\n+            write!(w, \"{}|\", (cx.ds)(def_id));\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyBareFn(None, f) => {\n-            mywrite!(w, \"G\");\n+            write!(w, \"G\");\n             enc_bare_fn_ty(w, cx, f);\n         }\n         ty::TyInfer(_) => {\n             cx.diag.bug(\"cannot encode inference variable types\");\n         }\n         ty::TyParam(ParamTy {space, idx, name}) => {\n-            mywrite!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name)\n+            write!(w, \"p[{}|{}|{}]\", idx, space.to_uint(), name);\n         }\n         ty::TyStruct(def, substs) => {\n-            mywrite!(w, \"a[{}|\", (cx.ds)(def.did));\n+            write!(w, \"a[{}|\", (cx.ds)(def.did));\n             enc_substs(w, cx, substs);\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n         ty::TyClosure(def, ref substs) => {\n-            mywrite!(w, \"k[{}|\", (cx.ds)(def));\n+            write!(w, \"k[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, &substs.func_substs);\n             for ty in &substs.upvar_tys {\n                 enc_ty(w, cx, ty);\n             }\n-            mywrite!(w, \".\");\n-            mywrite!(w, \"]\");\n+            write!(w, \".\");\n+            write!(w, \"]\");\n         }\n         ty::TyProjection(ref data) => {\n-            mywrite!(w, \"P[\");\n+            write!(w, \"P[\");\n             enc_trait_ref(w, cx, data.trait_ref);\n-            mywrite!(w, \"{}]\", data.item_name);\n+            write!(w, \"{}]\", data.item_name);\n         }\n         ty::TyError => {\n-            mywrite!(w, \"e\");\n+            write!(w, \"e\");\n         }\n     }\n \n-    let end = w.mark_stable_position();\n+    let end = w.position();\n     let len = end - pos;\n \n-    let buf: &mut [u8] = &mut [0; 16]; // vuint < 15 bytes\n-    let mut abbrev = Cursor::new(buf);\n+    let mut abbrev = Cursor::new(Vec::with_capacity(16));\n     abbrev.write_all(b\"#\");\n-    writer::write_vuint(&mut abbrev, pos as usize);\n+    {\n+        let start_position = abbrev.position() as usize;\n+        let bytes_written = leb128::write_unsigned_leb128(abbrev.get_mut(),\n+                                                          start_position,\n+                                                          pos);\n+        abbrev.set_position((start_position + bytes_written) as u64);\n+    }\n \n     cx.abbrevs.borrow_mut().insert(t, ty_abbrev {\n         s: if abbrev.position() < len {\n@@ -180,101 +194,105 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx>) {\n             // if the abbreviation is longer than the real type,\n             // don't use #-notation. However, insert it here so\n             // other won't have to `mark_stable_position`\n-            w.writer.get_ref()[pos as usize..end as usize].to_owned()\n+            w.get_ref()[pos as usize .. end as usize].to_owned()\n         }\n     });\n }\n \n-fn enc_mutability(w: &mut Encoder, mt: hir::Mutability) {\n+fn enc_mutability(w: &mut Cursor<Vec<u8>>, mt: hir::Mutability) {\n     match mt {\n         hir::MutImmutable => (),\n-        hir::MutMutable => mywrite!(w, \"m\"),\n-    }\n+        hir::MutMutable => {\n+            write!(w, \"m\");\n+        }\n+    };\n }\n \n-fn enc_mt<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+fn enc_mt<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                     mt: ty::TypeAndMut<'tcx>) {\n     enc_mutability(w, mt.mutbl);\n     enc_ty(w, cx, mt.ty);\n }\n \n-fn enc_opt<T, F>(w: &mut Encoder, t: Option<T>, enc_f: F) where\n-    F: FnOnce(&mut Encoder, T),\n+fn enc_opt<T, F>(w: &mut Cursor<Vec<u8>>, t: Option<T>, enc_f: F) where\n+    F: FnOnce(&mut Cursor<Vec<u8>>, T),\n {\n     match t {\n-        None => mywrite!(w, \"n\"),\n+        None => {\n+            write!(w, \"n\");\n+        }\n         Some(v) => {\n-            mywrite!(w, \"s\");\n+            write!(w, \"s\");\n             enc_f(w, v);\n         }\n     }\n }\n \n-fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Encoder,\n+fn enc_vec_per_param_space<'a, 'tcx, T, F>(w: &mut Cursor<Vec<u8>>,\n                                            cx: &ctxt<'a, 'tcx>,\n                                            v: &VecPerParamSpace<T>,\n                                            mut op: F) where\n-    F: FnMut(&mut Encoder, &ctxt<'a, 'tcx>, &T),\n+    F: FnMut(&mut Cursor<Vec<u8>>, &ctxt<'a, 'tcx>, &T),\n {\n     for &space in &subst::ParamSpace::all() {\n-        mywrite!(w, \"[\");\n+        write!(w, \"[\");\n         for t in v.get_slice(space) {\n             op(w, cx, t);\n         }\n-        mywrite!(w, \"]\");\n+        write!(w, \"]\");\n     }\n }\n \n-pub fn enc_substs<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_substs<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                             substs: &subst::Substs<'tcx>) {\n     enc_region_substs(w, cx, &substs.regions);\n     enc_vec_per_param_space(w, cx, &substs.types,\n                             |w, cx, &ty| enc_ty(w, cx, ty));\n }\n \n-fn enc_region_substs(w: &mut Encoder, cx: &ctxt, substs: &subst::RegionSubsts) {\n+fn enc_region_substs(w: &mut Cursor<Vec<u8>>, cx: &ctxt, substs: &subst::RegionSubsts) {\n     match *substs {\n         subst::ErasedRegions => {\n-            mywrite!(w, \"e\");\n+            write!(w, \"e\");\n         }\n         subst::NonerasedRegions(ref regions) => {\n-            mywrite!(w, \"n\");\n+            write!(w, \"n\");\n             enc_vec_per_param_space(w, cx, regions,\n                                     |w, cx, &r| enc_region(w, cx, r));\n         }\n     }\n }\n \n-pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n+pub fn enc_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n-            mywrite!(w, \"b[{}|\", id.depth);\n+            write!(w, \"b[{}|\", id.depth);\n             enc_bound_region(w, cx, br);\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n         ty::ReEarlyBound(ref data) => {\n-            mywrite!(w, \"B[{}|{}|{}]\",\n-                     data.space.to_uint(),\n-                     data.index,\n-                     data.name);\n+            write!(w, \"B[{}|{}|{}]\",\n+                   data.space.to_uint(),\n+                   data.index,\n+                   data.name);\n         }\n         ty::ReFree(ref fr) => {\n-            mywrite!(w, \"f[\");\n+            write!(w, \"f[\");\n             enc_scope(w, cx, fr.scope);\n-            mywrite!(w, \"|\");\n+            write!(w, \"|\");\n             enc_bound_region(w, cx, fr.bound_region);\n-            mywrite!(w, \"]\");\n+            write!(w, \"]\");\n         }\n         ty::ReScope(scope) => {\n-            mywrite!(w, \"s\");\n+            write!(w, \"s\");\n             enc_scope(w, cx, scope);\n-            mywrite!(w, \"|\");\n+            write!(w, \"|\");\n         }\n         ty::ReStatic => {\n-            mywrite!(w, \"t\");\n+            write!(w, \"t\");\n         }\n         ty::ReEmpty => {\n-            mywrite!(w, \"e\");\n+            write!(w, \"e\");\n         }\n         ty::ReVar(_) | ty::ReSkolemized(..) => {\n             // these should not crop up after typeck\n@@ -283,198 +301,202 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n     }\n }\n \n-fn enc_scope(w: &mut Encoder, cx: &ctxt, scope: region::CodeExtent) {\n+fn enc_scope(w: &mut Cursor<Vec<u8>>, cx: &ctxt, scope: region::CodeExtent) {\n     match cx.tcx.region_maps.code_extent_data(scope) {\n         region::CodeExtentData::CallSiteScope {\n-            fn_id, body_id } => mywrite!(w, \"C[{}|{}]\", fn_id, body_id),\n+            fn_id, body_id } => write!(w, \"C[{}|{}]\", fn_id, body_id),\n         region::CodeExtentData::ParameterScope {\n-            fn_id, body_id } => mywrite!(w, \"P[{}|{}]\", fn_id, body_id),\n-        region::CodeExtentData::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n+            fn_id, body_id } => write!(w, \"P[{}|{}]\", fn_id, body_id),\n+        region::CodeExtentData::Misc(node_id) => write!(w, \"M{}\", node_id),\n         region::CodeExtentData::Remainder(region::BlockRemainder {\n-            block: b, first_statement_index: i }) => mywrite!(w, \"B[{}|{}]\", b, i),\n-        region::CodeExtentData::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n-    }\n+            block: b, first_statement_index: i }) => write!(w, \"B[{}|{}]\", b, i),\n+        region::CodeExtentData::DestructionScope(node_id) => write!(w, \"D{}\", node_id),\n+    };\n }\n \n-fn enc_bound_region(w: &mut Encoder, cx: &ctxt, br: ty::BoundRegion) {\n+fn enc_bound_region(w: &mut Cursor<Vec<u8>>, cx: &ctxt, br: ty::BoundRegion) {\n     match br {\n         ty::BrAnon(idx) => {\n-            mywrite!(w, \"a{}|\", idx);\n+            write!(w, \"a{}|\", idx);\n         }\n         ty::BrNamed(d, name) => {\n-            mywrite!(w, \"[{}|{}]\",\n+            write!(w, \"[{}|{}]\",\n                      (cx.ds)(d),\n                      name);\n         }\n         ty::BrFresh(id) => {\n-            mywrite!(w, \"f{}|\", id);\n+            write!(w, \"f{}|\", id);\n         }\n         ty::BrEnv => {\n-            mywrite!(w, \"e|\");\n+            write!(w, \"e|\");\n         }\n     }\n }\n \n-pub fn enc_trait_ref<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_trait_ref<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                s: ty::TraitRef<'tcx>) {\n-    mywrite!(w, \"{}|\", (cx.ds)(s.def_id));\n+    write!(w, \"{}|\", (cx.ds)(s.def_id));\n     enc_substs(w, cx, s.substs);\n }\n \n-fn enc_unsafety(w: &mut Encoder, p: hir::Unsafety) {\n+fn enc_unsafety(w: &mut Cursor<Vec<u8>>, p: hir::Unsafety) {\n     match p {\n-        hir::Unsafety::Normal => mywrite!(w, \"n\"),\n-        hir::Unsafety::Unsafe => mywrite!(w, \"u\"),\n-    }\n+        hir::Unsafety::Normal => write!(w, \"n\"),\n+        hir::Unsafety::Unsafe => write!(w, \"u\"),\n+    };\n }\n \n-fn enc_abi(w: &mut Encoder, abi: Abi) {\n-    mywrite!(w, \"[\");\n-    mywrite!(w, \"{}\", abi.name());\n-    mywrite!(w, \"]\")\n+fn enc_abi(w: &mut Cursor<Vec<u8>>, abi: Abi) {\n+    write!(w, \"[\");\n+    write!(w, \"{}\", abi.name());\n+    write!(w, \"]\");\n }\n \n-pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_bare_fn_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::BareFnTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_abi(w, ft.abi);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n \n-pub fn enc_closure_ty<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_closure_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                 ft: &ty::ClosureTy<'tcx>) {\n     enc_unsafety(w, ft.unsafety);\n     enc_fn_sig(w, cx, &ft.sig);\n     enc_abi(w, ft.abi);\n }\n \n-fn enc_fn_sig<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+fn enc_fn_sig<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                         fsig: &ty::PolyFnSig<'tcx>) {\n-    mywrite!(w, \"[\");\n+    write!(w, \"[\");\n     for ty in &fsig.0.inputs {\n         enc_ty(w, cx, *ty);\n     }\n-    mywrite!(w, \"]\");\n+    write!(w, \"]\");\n     if fsig.0.variadic {\n-        mywrite!(w, \"V\");\n+        write!(w, \"V\");\n     } else {\n-        mywrite!(w, \"N\");\n+        write!(w, \"N\");\n     }\n     match fsig.0.output {\n         ty::FnConverging(result_type) => {\n             enc_ty(w, cx, result_type);\n         }\n         ty::FnDiverging => {\n-            mywrite!(w, \"z\");\n+            write!(w, \"z\");\n         }\n     }\n }\n \n-pub fn enc_builtin_bounds(w: &mut Encoder, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n+pub fn enc_builtin_bounds(w: &mut Cursor<Vec<u8>>, _cx: &ctxt, bs: &ty::BuiltinBounds) {\n     for bound in bs {\n         match bound {\n-            ty::BoundSend => mywrite!(w, \"S\"),\n-            ty::BoundSized => mywrite!(w, \"Z\"),\n-            ty::BoundCopy => mywrite!(w, \"P\"),\n-            ty::BoundSync => mywrite!(w, \"T\"),\n-        }\n+            ty::BoundSend => write!(w, \"S\"),\n+            ty::BoundSized => write!(w, \"Z\"),\n+            ty::BoundCopy => write!(w, \"P\"),\n+            ty::BoundSync => write!(w, \"T\"),\n+        };\n     }\n \n-    mywrite!(w, \".\");\n+    write!(w, \".\");\n }\n \n-pub fn enc_existential_bounds<'a,'tcx>(w: &mut Encoder,\n+pub fn enc_existential_bounds<'a,'tcx>(w: &mut Cursor<Vec<u8>>,\n                                        cx: &ctxt<'a,'tcx>,\n                                        bs: &ty::ExistentialBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n     enc_region(w, cx, bs.region_bound);\n \n     for tp in &bs.projection_bounds {\n-        mywrite!(w, \"P\");\n+        write!(w, \"P\");\n         enc_projection_predicate(w, cx, &tp.0);\n     }\n \n-    mywrite!(w, \".\");\n+    write!(w, \".\");\n }\n \n-pub fn enc_type_param_def<'a, 'tcx>(w: &mut Encoder, cx: &ctxt<'a, 'tcx>,\n+pub fn enc_type_param_def<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n-    mywrite!(w, \"{}:{}|{}|{}|{}|\",\n+    write!(w, \"{}:{}|{}|{}|{}|\",\n              v.name, (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index, (cx.ds)(v.default_def_id));\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }\n \n-pub fn enc_region_param_def(w: &mut Encoder, cx: &ctxt,\n+pub fn enc_region_param_def(w: &mut Cursor<Vec<u8>>, cx: &ctxt,\n                             v: &ty::RegionParameterDef) {\n-    mywrite!(w, \"{}:{}|{}|{}|\",\n+    write!(w, \"{}:{}|{}|{}|\",\n              v.name, (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n     for &r in &v.bounds {\n-        mywrite!(w, \"R\");\n+        write!(w, \"R\");\n         enc_region(w, cx, r);\n     }\n-    mywrite!(w, \".\");\n+    write!(w, \".\");\n }\n \n-fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Encoder,\n+fn enc_object_lifetime_default<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n                                          cx: &ctxt<'a, 'tcx>,\n                                          default: ty::ObjectLifetimeDefault)\n {\n     match default {\n-        ty::ObjectLifetimeDefault::Ambiguous => mywrite!(w, \"a\"),\n-        ty::ObjectLifetimeDefault::BaseDefault => mywrite!(w, \"b\"),\n+        ty::ObjectLifetimeDefault::Ambiguous => {\n+            write!(w, \"a\");\n+        }\n+        ty::ObjectLifetimeDefault::BaseDefault => {\n+            write!(w, \"b\");\n+        }\n         ty::ObjectLifetimeDefault::Specific(r) => {\n-            mywrite!(w, \"s\");\n+            write!(w, \"s\");\n             enc_region(w, cx, r);\n         }\n     }\n }\n \n-pub fn enc_predicate<'a, 'tcx>(w: &mut Encoder,\n+pub fn enc_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n                                cx: &ctxt<'a, 'tcx>,\n                                p: &ty::Predicate<'tcx>)\n {\n     match *p {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            mywrite!(w, \"t\");\n+            write!(w, \"t\");\n             enc_trait_ref(w, cx, trait_ref.0.trait_ref);\n         }\n         ty::Predicate::Equate(ty::Binder(ty::EquatePredicate(a, b))) => {\n-            mywrite!(w, \"e\");\n+            write!(w, \"e\");\n             enc_ty(w, cx, a);\n             enc_ty(w, cx, b);\n         }\n         ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            mywrite!(w, \"r\");\n+            write!(w, \"r\");\n             enc_region(w, cx, a);\n             enc_region(w, cx, b);\n         }\n         ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(a, b))) => {\n-            mywrite!(w, \"o\");\n+            write!(w, \"o\");\n             enc_ty(w, cx, a);\n             enc_region(w, cx, b);\n         }\n         ty::Predicate::Projection(ty::Binder(ref data)) => {\n-            mywrite!(w, \"p\");\n-            enc_projection_predicate(w, cx, data)\n+            write!(w, \"p\");\n+            enc_projection_predicate(w, cx, data);\n         }\n         ty::Predicate::WellFormed(data) => {\n-            mywrite!(w, \"w\");\n+            write!(w, \"w\");\n             enc_ty(w, cx, data);\n         }\n         ty::Predicate::ObjectSafe(trait_def_id) => {\n-            mywrite!(w, \"O{}|\", (cx.ds)(trait_def_id));\n+            write!(w, \"O{}|\", (cx.ds)(trait_def_id));\n         }\n     }\n }\n \n-fn enc_projection_predicate<'a, 'tcx>(w: &mut Encoder,\n+fn enc_projection_predicate<'a, 'tcx>(w: &mut Cursor<Vec<u8>>,\n                                       cx: &ctxt<'a, 'tcx>,\n                                       data: &ty::ProjectionPredicate<'tcx>) {\n     enc_trait_ref(w, cx, data.projection_ty.trait_ref);\n-    mywrite!(w, \"{}|\", data.projection_ty.item_name);\n+    write!(w, \"{}|\", data.projection_ty.item_name);\n     enc_ty(w, cx, data.ty);\n }"}, {"sha": "8347a03cda6f72318b879e8daae6dab3c2567c0c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -138,28 +138,25 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      -> BlockAnd<Vec<ArgDecl<'tcx>>>\n     {\n         self.in_scope(argument_extent, block, |this| {\n-            let arg_decls = {\n-                let implicit_arg_decls = implicit_arguments.into_iter()\n-                                                           .map(|ty| ArgDecl { ty: ty });\n-\n-                // to start, translate the argument patterns and collect the\n-                // argument types.\n-                let explicit_arg_decls =\n-                    explicit_arguments\n-                    .into_iter()\n-                    .enumerate()\n-                    .map(|(index, (ty, pattern))| {\n+            // to start, translate the argument patterns and collect the argument types.\n+            let implicits = implicit_arguments.into_iter().map(|ty| (ty, None));\n+            let explicits = explicit_arguments.into_iter().map(|(ty, pat)| (ty, Some(pat)));\n+            let arg_decls =\n+                implicits\n+                .chain(explicits)\n+                .enumerate()\n+                .map(|(index, (ty, pattern))| {\n+                    if let Some(pattern) = pattern {\n                         let lvalue = Lvalue::Arg(index as u32);\n                         let pattern = this.hir.irrefutable_pat(pattern);\n                         unpack!(block = this.lvalue_into_pattern(block,\n                                                                  argument_extent,\n                                                                  pattern,\n                                                                  &lvalue));\n-                        ArgDecl { ty: ty }\n-                    });\n-\n-                implicit_arg_decls.chain(explicit_arg_decls).collect()\n-            };\n+                    }\n+                    ArgDecl { ty: ty }\n+                })\n+                .collect();\n \n             // start the first basic block and translate the body\n             unpack!(block = this.ast_block(&Lvalue::ReturnPointer, block, ast_block));"}, {"sha": "4197f80cb5ea31282c959e17d89b09727b68b5be", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -44,6 +44,7 @@ use middle::pat_util::simple_name;\n use middle::subst::Substs;\n use middle::ty::{self, Ty, HasTypeFlags};\n use rustc::front::map as hir_map;\n+use rustc::util::common::time;\n use rustc_mir::mir_map::MirMap;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n use session::Session;\n@@ -3057,7 +3058,9 @@ pub fn trans_crate<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let reachable_symbol_ids = filter_reachable_ids(&shared_ccx);\n \n     // Translate the metadata.\n-    let metadata = write_metadata(&shared_ccx, krate, &reachable_symbol_ids, mir_map);\n+    let metadata = time(tcx.sess.time_passes(), \"write metadata\", || {\n+        write_metadata(&shared_ccx, krate, &reachable_symbol_ids, mir_map)\n+    });\n \n     if shared_ccx.sess().trans_stats() {\n         let stats = shared_ccx.stats();"}, {"sha": "fe7d29297a9608574f42e54babfc43fbdcf2ff37", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -31,7 +31,6 @@ use trans::{adt, closure, debuginfo, expr, inline, machine};\n use trans::base::{self, push_ctxt};\n use trans::common::{self, type_is_sized, ExprOrMethodCall, node_id_substs, C_nil, const_get_elt};\n use trans::common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n-use trans::common::C_floating_f64;\n use trans::common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};\n use trans::common::{type_is_fat_ptr, Field, C_vector, C_array, C_null, ExprId, MethodCallKey};\n use trans::declare;\n@@ -108,38 +107,6 @@ pub fn const_lit(cx: &CrateContext, e: &hir::Expr, lit: &ast::Lit)\n     }\n }\n \n-pub fn trans_constval<'blk, 'tcx>(bcx: common::Block<'blk, 'tcx>,\n-                                cv: &ConstVal,\n-                                ty: Ty<'tcx>,\n-                                param_substs: &'tcx Substs<'tcx>)\n-                                -> ValueRef\n-{\n-    let ccx = bcx.ccx();\n-    let llty = type_of::type_of(ccx, ty);\n-    match *cv {\n-        ConstVal::Float(v) => C_floating_f64(v, llty),\n-        ConstVal::Bool(v) => C_bool(ccx, v),\n-        ConstVal::Int(v) => C_integral(llty, v as u64, true),\n-        ConstVal::Uint(v) => C_integral(llty, v, false),\n-        ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n-        ConstVal::ByteStr(ref v) => addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n-        ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n-            let expr = bcx.tcx().map.expect_expr(id);\n-            match const_expr(ccx, expr, param_substs, None, TrueConst::Yes) {\n-                Ok((val, _)) => val,\n-                Err(e) => panic!(\"const eval failure: {}\", e.description()),\n-            }\n-        },\n-        ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n-            let expr = bcx.tcx().map.expect_expr(id);\n-            expr::trans(bcx, expr).datum.val\n-        },\n-        ConstVal::Function(_) => {\n-            unimplemented!()\n-        },\n-    }\n-}\n-\n pub fn ptrcast(val: ValueRef, ty: Type) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstPointerCast(val, ty.to_ref())"}, {"sha": "12839df87b159d4ce86e55535ada1679986caa67", "filename": "src/librustc_trans/trans/mir/constant.rs", "status": "modified", "additions": 39, "deletions": 3, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fconstant.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -9,11 +9,14 @@\n // except according to those terms.\n \n use back::abi;\n+use llvm::ValueRef;\n+use middle::subst::Substs;\n use middle::ty::{Ty, HasTypeFlags};\n use rustc::middle::const_eval::ConstVal;\n use rustc::mir::repr as mir;\n-use trans::consts;\n-use trans::common::{self, Block};\n+use trans::common::{self, Block, C_bool, C_bytes, C_floating_f64, C_integral, C_str_slice};\n+use trans::consts::{self, TrueConst};\n+use trans::{type_of, expr};\n \n \n use super::operand::{OperandRef, OperandValue};\n@@ -27,7 +30,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                           -> OperandRef<'tcx>\n     {\n         let ccx = bcx.ccx();\n-        let val = consts::trans_constval(bcx, cv, ty, bcx.fcx.param_substs);\n+        let val = self.trans_constval_inner(bcx, cv, ty, bcx.fcx.param_substs);\n         let val = if common::type_is_immediate(ccx, ty) {\n             OperandValue::Immediate(val)\n         } else if common::type_is_fat_ptr(bcx.tcx(), ty) {\n@@ -46,6 +49,39 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n+    /// Translate ConstVal into a bare LLVM ValueRef.\n+    fn trans_constval_inner(&mut self,\n+                            bcx: common::Block<'bcx, 'tcx>,\n+                            cv: &ConstVal,\n+                            ty: Ty<'tcx>,\n+                            param_substs: &'tcx Substs<'tcx>)\n+                            -> ValueRef\n+    {\n+        let ccx = bcx.ccx();\n+        let llty = type_of::type_of(ccx, ty);\n+        match *cv {\n+            ConstVal::Float(v) => C_floating_f64(v, llty),\n+            ConstVal::Bool(v) => C_bool(ccx, v),\n+            ConstVal::Int(v) => C_integral(llty, v as u64, true),\n+            ConstVal::Uint(v) => C_integral(llty, v, false),\n+            ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n+            ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n+            ConstVal::Struct(id) | ConstVal::Tuple(id) => {\n+                let expr = bcx.tcx().map.expect_expr(id);\n+                match consts::const_expr(ccx, expr, param_substs, None, TrueConst::Yes) {\n+                    Ok((val, _)) => val,\n+                    Err(e) => panic!(\"const eval failure: {}\", e.description()),\n+                }\n+            },\n+            ConstVal::Array(id, _) | ConstVal::Repeat(id, _) => {\n+                let expr = bcx.tcx().map.expect_expr(id);\n+                expr::trans(bcx, expr).datum.val\n+            },\n+            ConstVal::Function(did) =>\n+                self.trans_fn_ref(bcx, ty, param_substs, did).immediate()\n+        }\n+    }\n+\n     pub fn trans_constant(&mut self,\n                           bcx: Block<'bcx, 'tcx>,\n                           constant: &mir::Constant<'tcx>)"}, {"sha": "19236f2cd98a80302e463ffd5d9112ac111f42c4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -164,18 +164,15 @@ impl Eq for Span {}\n \n impl Encodable for Span {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        // Encode spans as a single u64 in order to cut down on tagging overhead\n-        // added by the RBML metadata encoding. The should be solved differently\n-        // altogether some time (FIXME #21482)\n-        s.emit_u64( (self.lo.0 as u64) | ((self.hi.0 as u64) << 32) )\n+        try!(s.emit_u32(self.lo.0));\n+        s.emit_u32(self.hi.0)\n     }\n }\n \n impl Decodable for Span {\n     fn decode<D: Decoder>(d: &mut D) -> Result<Span, D::Error> {\n-        let lo_hi: u64 = try! { d.read_u64() };\n-        let lo = BytePos(lo_hi as u32);\n-        let hi = BytePos((lo_hi >> 32) as u32);\n+        let lo = BytePos(try! { d.read_u32() });\n+        let hi = BytePos(try! { d.read_u32() });\n         Ok(mk_sp(lo, hi))\n     }\n }"}, {"sha": "632693dd728c33a8400f8b7e5c15ac605049c3aa", "filename": "src/test/run-pass-valgrind/exit-flushes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Ftest%2Frun-pass-valgrind%2Fexit-flushes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Ftest%2Frun-pass-valgrind%2Fexit-flushes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fexit-flushes.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// ignore-macos this needs valgrind 3.11 or higher; see\n+// https://github.com/rust-lang/rust/pull/30365#issuecomment-165763679\n+\n use std::env;\n use std::process::{exit, Command};\n "}, {"sha": "93953e3f58ae0f2f4d477f4948bf64d5f931afd2", "filename": "src/test/run-pass/mir_refs_correct.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/53cd573bc8d79393676783ec124e4a2000166956/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53cd573bc8d79393676783ec124e4a2000166956/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_refs_correct.rs?ref=53cd573bc8d79393676783ec124e4a2000166956", "patch": "@@ -68,6 +68,7 @@ enum CEnum {\n const C: u8 = 84;\n const C2: [u8; 5] = [42; 5];\n const C3: [u8; 3] = [42, 41, 40];\n+const C4: fn(u8) -> S = S;\n \n fn regular() -> u8 {\n     21\n@@ -198,6 +199,11 @@ fn t23() -> (CEnum, CEnum) {\n     (CEnum::A, CEnum::B)\n }\n \n+#[rustc_mir]\n+fn t24() -> fn(u8) -> S {\n+    C4\n+}\n+\n fn main(){\n     unsafe {\n         assert_eq!(t1()(), regular());\n@@ -240,5 +246,6 @@ fn main(){\n         assert_eq!(t21(), Unit);\n         assert_eq!(t22(), None);\n         assert_eq!(t23(), (CEnum::A, CEnum::B));\n+        assert_eq!(t24(), C4);\n     }\n }"}]}