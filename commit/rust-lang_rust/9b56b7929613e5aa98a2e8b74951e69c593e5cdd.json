{"sha": "9b56b7929613e5aa98a2e8b74951e69c593e5cdd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNTZiNzkyOTYxM2U1YWE5OGEyZThiNzQ5NTFlNjljNTkzZTVjZGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-18T02:40:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-18T02:40:24Z"}, "message": "rustc: Make some no-op take and drop glue for scalar types", "tree": {"sha": "a6b5c6a0404718c4b7d37be9482ca330f2a5b4a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6b5c6a0404718c4b7d37be9482ca330f2a5b4a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b56b7929613e5aa98a2e8b74951e69c593e5cdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b56b7929613e5aa98a2e8b74951e69c593e5cdd", "html_url": "https://github.com/rust-lang/rust/commit/9b56b7929613e5aa98a2e8b74951e69c593e5cdd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b56b7929613e5aa98a2e8b74951e69c593e5cdd/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab", "html_url": "https://github.com/rust-lang/rust/commit/01bcb1d10eac97d27b3324125f7d5f3e0045a7ab"}], "stats": {"total": 58, "additions": 34, "deletions": 24}, "files": [{"sha": "824f1e723536e7f3db3c56f45088f643d00003ef", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9b56b7929613e5aa98a2e8b74951e69c593e5cdd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b56b7929613e5aa98a2e8b74951e69c593e5cdd/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=9b56b7929613e5aa98a2e8b74951e69c593e5cdd", "patch": "@@ -49,7 +49,8 @@ state obj namegen(mutable int i) {\n type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n-                    vec[ValueRef] upcall_glues);\n+                    vec[ValueRef] upcall_glues,\n+                    ValueRef no_op_type_glue);\n \n tag arity { nullary; n_ary; }\n type tag_info = rec(type_handle th,\n@@ -2785,6 +2786,37 @@ fn check_module(ModuleRef llmod) {\n     // TODO: run the linter here also, once there are llvm-c bindings for it.\n }\n \n+fn make_no_op_type_glue(ModuleRef llmod) -> ValueRef {\n+    auto ty = T_fn(vec(T_taskptr(), T_ptr(T_i8())), T_void());\n+    auto fun = decl_fastcall_fn(llmod, \"_rust_no_op_type_glue\", ty);\n+    auto bb_name = _str.buf(\"_rust_no_op_type_glue_bb\");\n+    auto llbb = llvm.LLVMAppendBasicBlock(fun, bb_name);\n+    new_builder(llbb, \"builder\").RetVoid();\n+    ret fun;\n+}\n+\n+fn make_glues(ModuleRef llmod) -> @glue_fns {\n+    ret @rec(activate_glue = decl_glue(llmod, abi.activate_glue_name()),\n+             yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n+             /*\n+              * Note: the signature passed to decl_cdecl_fn here looks unusual\n+              * because it is. It corresponds neither to an upcall signature\n+              * nor a normal rust-ABI signature. In fact it is a fake\n+              * signature, that exists solely to acquire the task pointer as\n+              * an argument to the upcall. It so happens that the runtime sets\n+              * up the task pointer as the sole incoming argument to the frame\n+              * that we return into when returning to the exit task glue. So\n+              * this is the signature required to retrieve it.\n+              */\n+             exit_task_glue = decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n+                                            T_fn(vec(T_taskptr()), T_void())),\n+\n+             upcall_glues =\n+              _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n+                                     abi.n_upcall_glues as uint),\n+             no_op_type_glue = make_no_op_type_glue(llmod));\n+}\n+\n fn trans_crate(session.session sess, @ast.crate crate, str output) {\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n@@ -2798,29 +2830,7 @@ fn trans_crate(session.session sess, @ast.crate crate, str output) {\n \n     auto intrinsics = declare_intrinsics(llmod);\n \n-    auto glues = @rec(activate_glue = decl_glue(llmod,\n-                                                abi.activate_glue_name()),\n-                      yield_glue = decl_glue(llmod, abi.yield_glue_name()),\n-                      /*\n-                       * Note: the signature passed to decl_cdecl_fn here\n-                       * looks unusual because it is. It corresponds neither\n-                       * to an upcall signature nor a normal rust-ABI\n-                       * signature. In fact it is a fake signature, that\n-                       * exists solely to acquire the task pointer as an\n-                       * argument to the upcall. It so happens that the\n-                       * runtime sets up the task pointer as the sole incoming\n-                       * argument to the frame that we return into when\n-                       * returning to the exit task glue. So this is the\n-                       * signature required to retrieve it.\n-                       */\n-                      exit_task_glue =\n-                      decl_cdecl_fn(llmod, abi.exit_task_glue_name(),\n-                                    T_fn(vec(T_taskptr()), T_void())),\n-\n-                      upcall_glues =\n-                      _vec.init_fn[ValueRef](bind decl_upcall(llmod, _),\n-                                             abi.n_upcall_glues as uint));\n-\n+    auto glues = make_glues(llmod);\n     auto hasher = typeck.hash_ty;\n     auto eqer = typeck.eq_ty;\n     auto types = map.mk_hashmap[@typeck.ty,@ty_info](hasher, eqer);"}]}