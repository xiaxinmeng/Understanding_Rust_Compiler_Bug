{"sha": "0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMWI1ZThiYzAxMDYxZjU0NzE2MDA1ZmQ4ZWEzN2NjNDk5N2JmZDk=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-04T23:53:53Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2017-07-20T17:23:57Z"}, "message": "Move rule configs out of step", "tree": {"sha": "51c9b77a43f2534c3e8359cb9f2b7c73f765fa96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c9b77a43f2534c3e8359cb9f2b7c73f765fa96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "html_url": "https://github.com/rust-lang/rust/commit/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ae98ebfcb9ad5a5384fd229a6ee91315b02ca969", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae98ebfcb9ad5a5384fd229a6ee91315b02ca969", "html_url": "https://github.com/rust-lang/rust/commit/ae98ebfcb9ad5a5384fd229a6ee91315b02ca969"}], "stats": {"total": 738, "additions": 737, "deletions": 1}, "files": [{"sha": "5e553cf8d6fb8d5c5a226d715feb81bc071c1c21", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 231, "deletions": 0, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -81,6 +81,12 @@ fn try_run_quiet(build: &Build, cmd: &mut Command) {\n     }\n }\n \n+// rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n+//      .dep(|s| s.name(\"tool-linkchecker\").stage(0))\n+//      .dep(|s| s.name(\"default:doc\"))\n+//      .default(build.config.docs)\n+//      .host(true)\n+//      .run(move |s| check::linkcheck(build, s.target));\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n@@ -94,6 +100,11 @@ pub fn linkcheck(build: &Build, host: &str) {\n                         .arg(build.out.join(host).join(\"doc\")));\n }\n \n+// rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n+//      .dep(|s| s.name(\"tool-cargotest\").stage(0))\n+//      .dep(|s| s.name(\"librustc\"))\n+//      .host(true)\n+//      .run(move |s| check::cargotest(build, s.stage, s.target));\n /// Runs the `cargotest` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will check out a few Rust projects and run `cargo\n@@ -116,6 +127,10 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n                       .env(\"RUSTDOC\", build.rustdoc(&compiler)));\n }\n \n+//rules.test(\"check-cargo\", \"cargo\")\n+//     .dep(|s| s.name(\"tool-cargo\"))\n+//     .host(true)\n+//     .run(move |s| check::cargo(build, s.stage, s.target));\n /// Runs `cargo test` for `cargo` packaged with Rust.\n pub fn cargo(build: &Build, stage: u32, host: &str) {\n     let compiler = &Compiler::new(stage, host);\n@@ -160,6 +175,12 @@ fn path_for_cargo(build: &Build, compiler: &Compiler) -> OsString {\n     env::join_paths(iter::once(path).chain(env::split_paths(&old_path))).expect(\"\")\n }\n \n+//rules.test(\"check-tidy\", \"src/tools/tidy\")\n+//     .dep(|s| s.name(\"tool-tidy\").stage(0))\n+//     .default(true)\n+//     .host(true)\n+//     .only_build(true)\n+//     .run(move |s| check::tidy(build, s.target));\n /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` checks up on various bits and pieces of style and\n@@ -184,6 +205,104 @@ fn testdir(build: &Build, host: &str) -> PathBuf {\n     build.out.join(host).join(\"test\")\n }\n \n+//    // ========================================================================\n+//    // Test targets\n+//    //\n+//    // Various unit tests and tests suites we can run\n+//    {\n+//        let mut suite = |name, path, mode, dir| {\n+//            rules.test(name, path)\n+//                 .dep(|s| s.name(\"libtest\"))\n+//                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n+//                 .dep(|s| s.name(\"test-helpers\"))\n+//                 .dep(|s| s.name(\"remote-copy-libs\"))\n+//                 .default(mode != \"pretty\") // pretty tests don't run everywhere\n+//                 .run(move |s| {\n+//                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n+//                 });\n+//        };\n+//\n+//        suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n+//        suite(\"check-rpass\", \"src/test/run-pass\", \"run-pass\", \"run-pass\");\n+//        suite(\"check-cfail\", \"src/test/compile-fail\", \"compile-fail\", \"compile-fail\");\n+//        suite(\"check-pfail\", \"src/test/parse-fail\", \"parse-fail\", \"parse-fail\");\n+//        suite(\"check-rfail\", \"src/test/run-fail\", \"run-fail\", \"run-fail\");\n+//        suite(\"check-rpass-valgrind\", \"src/test/run-pass-valgrind\",\n+//              \"run-pass-valgrind\", \"run-pass-valgrind\");\n+//        suite(\"check-mir-opt\", \"src/test/mir-opt\", \"mir-opt\", \"mir-opt\");\n+//        if build.config.codegen_tests {\n+//            suite(\"check-codegen\", \"src/test/codegen\", \"codegen\", \"codegen\");\n+//        }\n+//        suite(\"check-codegen-units\", \"src/test/codegen-units\", \"codegen-units\",\n+//              \"codegen-units\");\n+//        suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n+//              \"incremental\");\n+//    }\n+//\n+//    if build.build.contains(\"msvc\") {\n+//        // nothing to do for debuginfo tests\n+//    } else {\n+//        rules.test(\"check-debuginfo-lldb\", \"src/test/debuginfo-lldb\")\n+//             .dep(|s| s.name(\"libtest\"))\n+//             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n+//             .dep(|s| s.name(\"test-helpers\"))\n+//             .dep(|s| s.name(\"debugger-scripts\"))\n+//             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+//                                         \"debuginfo-lldb\", \"debuginfo\"));\n+//        rules.test(\"check-debuginfo-gdb\", \"src/test/debuginfo-gdb\")\n+//             .dep(|s| s.name(\"libtest\"))\n+//             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n+//             .dep(|s| s.name(\"test-helpers\"))\n+//             .dep(|s| s.name(\"debugger-scripts\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n+//                                         \"debuginfo-gdb\", \"debuginfo\"));\n+//        let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n+//        rule.default(true);\n+//        if build.build.contains(\"apple\") {\n+//            rule.dep(|s| s.name(\"check-debuginfo-lldb\"));\n+//        } else {\n+//            rule.dep(|s| s.name(\"check-debuginfo-gdb\"));\n+//        }\n+//    }\n+//\n+//\n+//\n+//    {\n+//        let mut suite = |name, path, mode, dir| {\n+//            rules.test(name, path)\n+//                 .dep(|s| s.name(\"librustc\"))\n+//                 .dep(|s| s.name(\"test-helpers\"))\n+//                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n+//                 .default(mode != \"pretty\")\n+//                 .host(true)\n+//                 .run(move |s| {\n+//                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n+//                 });\n+//        };\n+//\n+//        suite(\"check-ui-full\", \"src/test/ui-fulldeps\", \"ui\", \"ui-fulldeps\");\n+//        suite(\"check-rpass-full\", \"src/test/run-pass-fulldeps\",\n+//              \"run-pass\", \"run-pass-fulldeps\");\n+//        suite(\"check-rfail-full\", \"src/test/run-fail-fulldeps\",\n+//              \"run-fail\", \"run-fail-fulldeps\");\n+//        suite(\"check-cfail-full\", \"src/test/compile-fail-fulldeps\",\n+//              \"compile-fail\", \"compile-fail-fulldeps\");\n+//        suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n+//        suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n+//        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+//        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+//              \"run-pass\");\n+//        suite(\"check-pretty-rfail\", \"src/test/run-fail/pretty\", \"pretty\",\n+//              \"run-fail\");\n+//        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind/pretty\", \"pretty\",\n+//              \"run-pass-valgrind\");\n+//        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps/pretty\",\n+//              \"pretty\", \"run-pass-fulldeps\");\n+//        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps/pretty\",\n+//              \"pretty\", \"run-fail-fulldeps\");\n+//    }\n+\n /// Executes the `compiletest` tool to run a suite of tests.\n ///\n /// Compiles all tests with `compiler` for `target` with the specified\n@@ -338,6 +457,11 @@ pub fn compiletest(build: &Build,\n     try_run(build, &mut cmd);\n }\n \n+// rules.test(\"check-docs\", \"src/doc\")\n+//     .dep(|s| s.name(\"libtest\"))\n+//     .default(true)\n+//     .host(true)\n+//     .run(move |s| check::docs(build, &s.compiler()));\n /// Run `rustdoc --test` for all documentation in `src/doc`.\n ///\n /// This will run all tests in our markdown documentation (e.g. the book)\n@@ -370,6 +494,12 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n     }\n }\n \n+//rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n+//     .dep(|s| s.name(\"libstd\"))\n+//     .dep(|s| s.name(\"tool-error-index\").host(s.host).stage(0))\n+//     .default(true)\n+//     .host(true)\n+//     .run(move |s| check::error_index(build, &s.compiler()));\n /// Run the error index generator tool to execute the tests located in the error\n /// index.\n ///\n@@ -420,6 +550,68 @@ fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     }\n }\n \n+//    for (krate, path, _default) in krates(\"std\") {\n+//        rules.test(&krate.test_step, path)\n+//             .dep(|s| s.name(\"libtest\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                        Mode::Libstd, TestKind::Test,\n+//                                        Some(&krate.name)));\n+//    }\n+//    rules.test(\"check-std-all\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"libtest\"))\n+//         .dep(|s| s.name(\"remote-copy-libs\"))\n+//         .default(true)\n+//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                    Mode::Libstd, TestKind::Test, None));\n+//\n+//    // std benchmarks\n+//    for (krate, path, _default) in krates(\"std\") {\n+//        rules.bench(&krate.bench_step, path)\n+//             .dep(|s| s.name(\"libtest\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                        Mode::Libstd, TestKind::Bench,\n+//                                        Some(&krate.name)));\n+//    }\n+//    rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"libtest\"))\n+//         .dep(|s| s.name(\"remote-copy-libs\"))\n+//         .default(true)\n+//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                    Mode::Libstd, TestKind::Bench, None));\n+//\n+//    for (krate, path, _default) in krates(\"test\") {\n+//        rules.test(&krate.test_step, path)\n+//             .dep(|s| s.name(\"libtest\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                        Mode::Libtest, TestKind::Test,\n+//                                        Some(&krate.name)));\n+//    }\n+//    rules.test(\"check-test-all\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"libtest\"))\n+//         .dep(|s| s.name(\"remote-copy-libs\"))\n+//         .default(true)\n+//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                    Mode::Libtest, TestKind::Test, None));\n+//    for (krate, path, _default) in krates(\"rustc-main\") {\n+//        rules.test(&krate.test_step, path)\n+//             .dep(|s| s.name(\"librustc\"))\n+//             .dep(|s| s.name(\"remote-copy-libs\"))\n+//             .host(true)\n+//             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                        Mode::Librustc, TestKind::Test,\n+//                                        Some(&krate.name)));\n+//    }\n+//    rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"librustc\"))\n+//         .dep(|s| s.name(\"remote-copy-libs\"))\n+//         .default(true)\n+//         .host(true)\n+//         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+//                                    Mode::Librustc, TestKind::Test, None));\n+\n /// Run all unit tests plus documentation tests for an entire crate DAG defined\n /// by a `Cargo.toml`\n ///\n@@ -596,6 +788,34 @@ fn find_tests(dir: &Path, target: &str) -> Vec<PathBuf> {\n     dst\n }\n \n+//    // Some test suites are run inside emulators or on remote devices, and most\n+//    // of our test binaries are linked dynamically which means we need to ship\n+//    // the standard library and such to the emulator ahead of time. This step\n+//    // represents this and is a dependency of all test suites.\n+//    //\n+//    // Most of the time this step is a noop (the `check::emulator_copy_libs`\n+//    // only does work if necessary). For some steps such as shipping data to\n+//    // QEMU we have to build our own tools so we've got conditional dependencies\n+//    // on those programs as well. Note that the remote test client is built for\n+//    // the build target (us) and the server is built for the target.\n+//    rules.test(\"remote-copy-libs\", \"path/to/nowhere\")\n+//         .dep(|s| s.name(\"libtest\"))\n+//         .dep(move |s| {\n+//             if build.remote_tested(s.target) {\n+//                s.name(\"tool-remote-test-client\").target(s.host).stage(0)\n+//             } else {\n+//                 Step::noop()\n+//             }\n+//         })\n+//         .dep(move |s| {\n+//             if build.remote_tested(s.target) {\n+//                s.name(\"tool-remote-test-server\")\n+//             } else {\n+//                 Step::noop()\n+//             }\n+//         })\n+//         .run(move |s| check::remote_copy_libs(build, &s.compiler(), s.target));\n+//\n pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n     if !build.remote_tested(target) {\n         return\n@@ -632,6 +852,11 @@ pub fn remote_copy_libs(build: &Build, compiler: &Compiler, target: &str) {\n     }\n }\n \n+//rules.test(\"check-distcheck\", \"distcheck\")\n+//     .dep(|s| s.name(\"dist-plain-source-tarball\"))\n+//     .dep(|s| s.name(\"dist-src\"))\n+//     .run(move |_| check::distcheck(build));\n+\n /// Run \"distcheck\", a 'make check' from a tarball\n pub fn distcheck(build: &Build) {\n     if build.build != \"x86_64-unknown-linux-gnu\" {\n@@ -684,6 +909,12 @@ pub fn distcheck(build: &Build) {\n                      .current_dir(&dir));\n }\n \n+//rules.test(\"check-bootstrap\", \"src/bootstrap\")\n+//     .default(true)\n+//     .host(true)\n+//     .only_build(true)\n+//     .run(move |_| check::bootstrap(build));\n+//\n /// Test the build system itself\n pub fn bootstrap(build: &Build) {\n     let mut cmd = Command::new(&build.initial_cargo);"}, {"sha": "4a972ebf8df9d9532f08abd3534863db01fd3ecd", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -32,6 +32,121 @@ use channel::GitInfo;\n use util::{exe, libdir, is_dylib, copy};\n use {Build, Compiler, Mode};\n \n+//    for (krate, path, _default) in krates(\"std\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"startup-objects\"))\n+//             .dep(move |s| s.name(\"rustc\").host(&build.build).target(s.host))\n+//             .run(move |s| compile::std(build, s.target, &s.compiler()));\n+//    }\n+//    for (krate, path, _default) in krates(\"test\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"libstd-link\"))\n+//             .run(move |s| compile::test(build, s.target, &s.compiler()));\n+//    }\n+//    for (krate, path, _default) in krates(\"rustc-main\") {\n+//        rules.build(&krate.build_step, path)\n+//             .dep(|s| s.name(\"libtest-link\"))\n+//             .dep(move |s| s.name(\"llvm\").host(&build.build).stage(0))\n+//             .dep(|s| s.name(\"may-run-build-script\"))\n+//             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n+//    }\n+//\n+//    // Crates which have build scripts need to rely on this rule to ensure that\n+//    // the necessary prerequisites for a build script are linked and located in\n+//    // place.\n+//    rules.build(\"may-run-build-script\", \"path/to/nowhere\")\n+//         .dep(move |s| {\n+//             s.name(\"libstd-link\")\n+//              .host(&build.build)\n+//              .target(&build.build)\n+//         });\n+\n+//    // ========================================================================\n+//    // Crate compilations\n+//    //\n+//    // Tools used during the build system but not shipped\n+//    // These rules are \"pseudo rules\" that don't actually do any work\n+//    // themselves, but represent a complete sysroot with the relevant compiler\n+//    // linked into place.\n+//    //\n+//    // That is, depending on \"libstd\" means that when the rule is completed then\n+//    // the `stage` sysroot for the compiler `host` will be available with a\n+//    // standard library built for `target` linked in place. Not all rules need\n+//    // the compiler itself to be available, just the standard library, so\n+//    // there's a distinction between the two.\n+//    rules.build(\"libstd\", \"src/libstd\")\n+//         .dep(|s| s.name(\"rustc\").target(s.host))\n+//         .dep(|s| s.name(\"libstd-link\"));\n+//    rules.build(\"libtest\", \"src/libtest\")\n+//         .dep(|s| s.name(\"libstd\"))\n+//         .dep(|s| s.name(\"libtest-link\"))\n+//         .default(true);\n+//    rules.build(\"librustc\", \"src/librustc\")\n+//         .dep(|s| s.name(\"libtest\"))\n+//         .dep(|s| s.name(\"librustc-link\"))\n+//         .host(true)\n+//         .default(true);\n+\n+// Helper method to define the rules to link a crate into its place in the\n+// sysroot.\n+//\n+// The logic here is a little subtle as there's a few cases to consider.\n+// Not all combinations of (stage, host, target) actually require something\n+// to be compiled, but rather libraries could get propagated from a\n+// different location. For example:\n+//\n+// * Any crate with a `host` that's not the build triple will not actually\n+//   compile something. A different `host` means that the build triple will\n+//   actually compile the libraries, and then we'll copy them over from the\n+//   build triple to the `host` directory.\n+//\n+// * Some crates aren't even compiled by the build triple, but may be copied\n+//   from previous stages. For example if we're not doing a full bootstrap\n+//   then we may just depend on the stage1 versions of libraries to be\n+//   available to get linked forward.\n+//\n+// * Finally, there are some cases, however, which do indeed comiple crates\n+//   and link them into place afterwards.\n+//\n+// The rule definition below mirrors these three cases. The `dep` method\n+// calculates the correct dependency which either comes from stage1, a\n+// different compiler, or from actually building the crate itself (the `dep`\n+// rule). The `run` rule then mirrors these three cases and links the cases\n+// forward into the compiler sysroot specified from the correct location.\n+fn crate_rule<'a, 'b>(build: &'a Build,\n+                        rules: &'b mut Rules<'a>,\n+                        krate: &'a str,\n+                        dep: &'a str,\n+                        link: fn(&Build, &Compiler, &Compiler, &str))\n+                        -> RuleBuilder<'a, 'b> {\n+    let mut rule = rules.build(&krate, \"path/to/nowhere\");\n+    rule.dep(move |s| {\n+            if build.force_use_stage1(&s.compiler(), s.target) {\n+                s.host(&build.build).stage(1)\n+            } else if s.host == build.build {\n+                s.name(dep)\n+            } else {\n+                s.host(&build.build)\n+            }\n+        })\n+        .run(move |s| {\n+            if build.force_use_stage1(&s.compiler(), s.target) {\n+                link(build,\n+                        &s.stage(1).host(&build.build).compiler(),\n+                        &s.compiler(),\n+                        s.target)\n+            } else if s.host == build.build {\n+                link(build, &s.compiler(), &s.compiler(), s.target)\n+            } else {\n+                link(build,\n+                        &s.host(&build.build).compiler(),\n+                        &s.compiler(),\n+                        s.target)\n+            }\n+        });\n+        rule\n+}\n+\n /// Build the standard library.\n ///\n /// This will build the standard library for a particular stage of the build\n@@ -93,6 +208,14 @@ pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n               &libstd_stamp(build, &compiler, target));\n }\n \n+\n+// crate_rule(build,\n+//            &mut rules,\n+//            \"libstd-link\",\n+//            \"build-crate-std\",\n+//            compile::std_link)\n+//     .dep(|s| s.name(\"startup-objects\"))\n+//     .dep(|s| s.name(\"create-sysroot\").target(s.host));\n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n /// Links those artifacts generated by `compiler` to a the `stage` compiler's\n@@ -147,6 +270,10 @@ fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n     }\n }\n \n+// rules.build(\"startup-objects\", \"src/rtstartup\")\n+//      .dep(|s| s.name(\"create-sysroot\").target(s.host))\n+//      .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n+\n /// Build and prepare startup objects like rsbegin.o and rsend.o\n ///\n /// These are primarily used on Windows right now for linking executables/dlls.\n@@ -209,6 +336,14 @@ pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n               &libtest_stamp(build, compiler, target));\n }\n \n+\n+// crate_rule(build,\n+//            &mut rules,\n+//            \"libtest-link\",\n+//            \"build-crate-test\",\n+//            compile::test_link)\n+//     .dep(|s| s.name(\"libstd-link\"));\n+\n /// Same as `std_link`, only for libtest\n pub fn test_link(build: &Build,\n                  compiler: &Compiler,\n@@ -303,6 +438,12 @@ pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n               &librustc_stamp(build, compiler, target));\n }\n \n+// crate_rule(build,\n+//            &mut rules,\n+//            \"librustc-link\",\n+//            \"build-crate-rustc-main\",\n+//            compile::rustc_link)\n+//     .dep(|s| s.name(\"libtest-link\"));\n /// Same as `std_link`, only for librustc\n pub fn rustc_link(build: &Build,\n                   compiler: &Compiler,\n@@ -342,12 +483,27 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n     PathBuf::from(out.trim())\n }\n \n+// rules.build(\"create-sysroot\", \"path/to/nowhere\")\n+//      .run(move |s| compile::create_sysroot(build, &s.compiler()));\n pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n     let sysroot = build.sysroot(compiler);\n     let _ = fs::remove_dir_all(&sysroot);\n     t!(fs::create_dir_all(&sysroot));\n }\n \n+// the compiler with no target libraries ready to go\n+// rules.build(\"rustc\", \"src/rustc\")\n+//      .dep(|s| s.name(\"create-sysroot\").target(s.host))\n+//      .dep(move |s| {\n+//          if s.stage == 0 {\n+//              Step::noop()\n+//          } else {\n+//              s.name(\"librustc\")\n+//               .host(&build.build)\n+//               .stage(s.stage - 1)\n+//          }\n+//      })\n+//      .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n@@ -418,6 +574,29 @@ fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     }\n }\n \n+//// ========================================================================\n+//// Build tools\n+////\n+//// Tools used during the build system but not shipped\n+//// \"pseudo rule\" which represents completely cleaning out the tools dir in\n+//// one stage. This needs to happen whenever a dependency changes (e.g.\n+//// libstd, libtest, librustc) and all of the tool compilations above will\n+//// be sequenced after this rule.\n+//rules.build(\"maybe-clean-tools\", \"path/to/nowhere\")\n+//     .after(\"librustc-tool\")\n+//     .after(\"libtest-tool\")\n+//     .after(\"libstd-tool\");\n+//\n+//rules.build(\"librustc-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"librustc\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Librustc));\n+//rules.build(\"libtest-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"libtest\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libtest));\n+//rules.build(\"libstd-tool\", \"path/to/nowhere\")\n+//     .dep(|s| s.name(\"libstd\"))\n+//     .run(move |s| compile::maybe_clean_tools(build, s.stage, s.target, Mode::Libstd));\n+//\n /// Build a tool in `src/tools`\n ///\n /// This will build the specified tool with the specified `host` compiler in\n@@ -435,6 +614,79 @@ pub fn maybe_clean_tools(build: &Build, stage: u32, target: &str, mode: Mode) {\n     build.clear_if_dirty(&out_dir, &stamp);\n }\n \n+\n+// rules.build(\"tool-rustbook\", \"src/tools/rustbook\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rustbook\"));\n+// rules.build(\"tool-error-index\", \"src/tools/error_index_generator\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"error_index_generator\"));\n+// rules.build(\"tool-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"unstable-book-gen\"));\n+// rules.build(\"tool-tidy\", \"src/tools/tidy\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"tidy\"));\n+// rules.build(\"tool-linkchecker\", \"src/tools/linkchecker\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"linkchecker\"));\n+// rules.build(\"tool-cargotest\", \"src/tools/cargotest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargotest\"));\n+// rules.build(\"tool-compiletest\", \"src/tools/compiletest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libtest-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"compiletest\"));\n+// rules.build(\"tool-build-manifest\", \"src/tools/build-manifest\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"build-manifest\"));\n+// rules.build(\"tool-remote-test-server\", \"src/tools/remote-test-server\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-server\"));\n+// rules.build(\"tool-remote-test-client\", \"src/tools/remote-test-client\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"remote-test-client\"));\n+// rules.build(\"tool-rust-installer\", \"src/tools/rust-installer\")\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rust-installer\"));\n+// rules.build(\"tool-cargo\", \"src/tools/cargo\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"maybe-clean-tools\"))\n+//      .dep(|s| s.name(\"libstd-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // Cargo depends on procedural macros, which requires a full host\n+//          // compiler to be available, so we need to depend on that.\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"cargo\"));\n+// rules.build(\"tool-rls\", \"src/tools/rls\")\n+//      .host(true)\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"librustc-tool\"))\n+//      .dep(|s| s.stage(0).host(s.target).name(\"openssl\"))\n+//      .dep(move |s| {\n+//          // rls, like cargo, uses procedural macros\n+//          s.name(\"librustc-link\")\n+//           .target(&build.build)\n+//           .host(&build.build)\n+//      })\n+//      .run(move |s| compile::tool(build, s.stage, s.target, \"rls\"));\n+//\n+\n /// Build a tool in `src/tools`\n ///\n /// This will build the specified tool with the specified `host` compiler in"}, {"sha": "2cf3ca73952ac36b42accd5e22d9309f035df926", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -18,6 +18,14 @@\n //! out to `rust-installer` still. This may one day be replaced with bits and\n //! pieces of `rustup.rs`!\n \n+// /// Helper to depend on a stage0 build-only rust-installer tool.\n+// fn tool_rust_installer<'a>(build: &'a Build, step: &Step<'a>) -> Step<'a> {\n+//     step.name(\"tool-rust-installer\")\n+//         .host(&build.build)\n+//         .target(&build.build)\n+//         .stage(0)\n+// }\n+\n use std::env;\n use std::fs::{self, File};\n use std::io::{Read, Write};\n@@ -53,6 +61,12 @@ fn rust_installer(build: &Build) -> Command {\n     build.tool_cmd(&Compiler::new(0, &build.build), \"rust-installer\")\n }\n \n+// rules.dist(\"dist-docs\", \"src/doc\")\n+//      .default(true)\n+//      .only_host_build(true)\n+//      .dep(|s| s.name(\"default:doc\"))\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::docs(build, s.stage, s.target));\n /// Builds the `rust-docs` installer component.\n ///\n /// Slurps up documentation from the `stage`'s `host`.\n@@ -222,6 +236,16 @@ fn make_win_dist(rust_root: &Path, plat_root: &Path, target_triple: &str, build:\n     }\n }\n \n+// rules.dist(\"dist-mingw\", \"path/to/nowhere\")\n+//      .default(true)\n+//      .only_host_build(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| {\n+//          if s.target.contains(\"pc-windows-gnu\") {\n+//              dist::mingw(build, s.target)\n+//          }\n+//      });\n+//\n /// Build the `rust-mingw` installer component.\n ///\n /// This contains all the bits and pieces to run the MinGW Windows targets\n@@ -254,6 +278,13 @@ pub fn mingw(build: &Build, host: &str) {\n     t!(fs::remove_dir_all(&image));\n }\n \n+// rules.dist(\"dist-rustc\", \"src/librustc\")\n+//      .dep(move |s| s.name(\"rustc\").host(&build.build))\n+//      .host(true)\n+//      .only_host_build(true)\n+//      .default(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::rustc(build, s.stage, s.target));\n /// Creates the `rustc` installer component.\n pub fn rustc(build: &Build, stage: u32, host: &str) {\n     println!(\"Dist rustc stage{} ({})\", stage, host);\n@@ -352,6 +383,9 @@ pub fn rustc(build: &Build, stage: u32, host: &str) {\n     }\n }\n \n+//rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n+//     .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n+//                                     s.target));\n /// Copies debugger scripts for `host` into the `sysroot` specified.\n pub fn debugger_scripts(build: &Build,\n                         sysroot: &Path,\n@@ -386,6 +420,21 @@ pub fn debugger_scripts(build: &Build,\n     }\n }\n \n+// rules.dist(\"dist-std\", \"src/libstd\")\n+//      .dep(move |s| {\n+//          // We want to package up as many target libraries as possible\n+//          // for the `rust-std` package, so if this is a host target we\n+//          // depend on librustc and otherwise we just depend on libtest.\n+//          if build.config.host.iter().any(|t| t == s.target) {\n+//              s.name(\"librustc-link\")\n+//          } else {\n+//              s.name(\"libtest-link\")\n+//          }\n+//      })\n+//      .default(true)\n+//      .only_host_build(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::std(build, &s.compiler(), s.target));\n /// Creates the `rust-std` installer component as compiled by `compiler` for the\n /// target `target`.\n pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n@@ -436,6 +485,12 @@ pub fn rust_src_installer(build: &Build) -> PathBuf {\n     distdir(build).join(&format!(\"{}.tar.gz\", name))\n }\n \n+// rules.dist(\"dist-analysis\", \"analysis\")\n+//      .default(build.config.extended)\n+//      .dep(|s| s.name(\"dist-std\"))\n+//      .only_host_build(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n /// Creates a tarball of save-analysis metadata, if available.\n pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n     assert!(build.config.extended);\n@@ -520,6 +575,13 @@ fn copy_src_dirs(build: &Build, src_dirs: &[&str], exclude_dirs: &[&str], dst_di\n     }\n }\n \n+// rules.dist(\"dist-src\", \"src\")\n+//      .default(true)\n+//      .host(true)\n+//      .only_build(true)\n+//      .only_host_build(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |_| dist::rust_src(build));\n /// Creates the `rust-src` installer component\n pub fn rust_src(build: &Build) {\n     println!(\"Dist src\");\n@@ -587,6 +649,13 @@ pub fn rust_src(build: &Build) {\n \n const CARGO_VENDOR_VERSION: &str = \"0.1.4\";\n \n+// rules.dist(\"dist-plain-source-tarball\", \"src\")\n+//      .default(build.config.rust_dist_src)\n+//      .host(true)\n+//      .only_build(true)\n+//      .only_host_build(true)\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |_| dist::plain_source_tarball(build));\n /// Creates the plain source tarball\n pub fn plain_source_tarball(build: &Build) {\n     println!(\"Create plain source tarball\");\n@@ -704,6 +773,12 @@ fn write_file(path: &Path, data: &[u8]) {\n     t!(vf.write_all(data));\n }\n \n+// rules.dist(\"dist-cargo\", \"cargo\")\n+//      .host(true)\n+//      .only_host_build(true)\n+//      .dep(|s| s.name(\"tool-cargo\"))\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::cargo(build, s.stage, s.target));\n pub fn cargo(build: &Build, stage: u32, target: &str) {\n     println!(\"Dist cargo stage{} ({})\", stage, target);\n     let compiler = Compiler::new(stage, &build.build);\n@@ -764,6 +839,12 @@ pub fn cargo(build: &Build, stage: u32, target: &str) {\n     build.run(&mut cmd);\n }\n \n+// rules.dist(\"dist-rls\", \"rls\")\n+//      .host(true)\n+//      .only_host_build(true)\n+//      .dep(|s| s.name(\"tool-rls\"))\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::rls(build, s.stage, s.target));\n pub fn rls(build: &Build, stage: u32, target: &str) {\n     assert!(build.config.extended);\n     println!(\"Dist RLS stage{} ({})\", stage, target);\n@@ -813,6 +894,20 @@ pub fn rls(build: &Build, stage: u32, target: &str) {\n     build.run(&mut cmd);\n }\n \n+// rules.dist(\"dist-extended\", \"extended\")\n+//      .default(build.config.extended)\n+//      .host(true)\n+//      .only_host_build(true)\n+//      .dep(|d| d.name(\"dist-std\"))\n+//      .dep(|d| d.name(\"dist-rustc\"))\n+//      .dep(|d| d.name(\"dist-mingw\"))\n+//      .dep(|d| d.name(\"dist-docs\"))\n+//      .dep(|d| d.name(\"dist-cargo\"))\n+//      .dep(|d| d.name(\"dist-rls\"))\n+//      .dep(|d| d.name(\"dist-analysis\"))\n+//      .dep(move |s| tool_rust_installer(build, s))\n+//      .run(move |s| dist::extended(build, s.stage, s.target));\n+\n /// Creates a combined installer for the specified target in the provided stage.\n pub fn extended(build: &Build, stage: u32, target: &str) {\n     println!(\"Dist extended stage{} ({})\", stage, target);\n@@ -1198,6 +1293,13 @@ fn add_env(build: &Build, cmd: &mut Command, target: &str) {\n     }\n }\n \n+// rules.dist(\"dist-sign\", \"hash-and-sign\")\n+//      .host(true)\n+//      .only_build(true)\n+//      .only_host_build(true)\n+//      .dep(move |s| s.name(\"tool-build-manifest\").target(&build.build).stage(0))\n+//      .run(move |_| dist::hash_and_sign(build));\n+//\n pub fn hash_and_sign(build: &Build) {\n     let compiler = Compiler::new(0, &build.build);\n     let mut cmd = build.tool_cmd(&compiler, \"build-manifest\");"}, {"sha": "432fdb6a3cb8c682de94af2a92c75cb109ced0c1", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -27,6 +27,24 @@ use {Build, Compiler, Mode};\n use util::{cp_r, symlink_dir};\n use build_helper::up_to_date;\n \n+// rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n+//      .dep(move |s| {\n+//          s.name(\"tool-rustbook\")\n+//           .host(&build.build)\n+//           .target(&build.build)\n+//           .stage(0)\n+//      })\n+//      .default(build.config.docs)\n+//      .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n+// rules.doc(\"doc-reference\", \"src/doc/reference\")\n+//      .dep(move |s| {\n+//          s.name(\"tool-rustbook\")\n+//           .host(&build.build)\n+//           .target(&build.build)\n+//           .stage(0)\n+//      })\n+//      .default(build.config.docs)\n+//      .run(move |s| doc::rustbook(build, s.target, \"reference\"));\n /// Invoke `rustbook` for `target` for the doc book `name`.\n ///\n /// This will not actually generate any documentation if the documentation has\n@@ -36,6 +54,21 @@ pub fn rustbook(build: &Build, target: &str, name: &str) {\n     rustbook_src(build, target, name, &src);\n }\n \n+//rules.doc(\"doc-unstable-book\", \"src/doc/unstable-book\")\n+//     .dep(move |s| {\n+//         s.name(\"tool-rustbook\")\n+//          .host(&build.build)\n+//          .target(&build.build)\n+//          .stage(0)\n+//     })\n+//     .dep(move |s| s.name(\"doc-unstable-book-gen\"))\n+//     .default(build.config.docs)\n+//     .run(move |s| doc::rustbook_src(build,\n+//                                     s.target,\n+//                                     \"unstable-book\",\n+//                                     &build.md_doc_out(s.target)));\n+\n+\n /// Invoke `rustbook` for `target` for the doc book `name` from the `src` path.\n ///\n /// This will not actually generate any documentation if the documentation has\n@@ -61,6 +94,15 @@ pub fn rustbook_src(build: &Build, target: &str, name: &str, src: &Path) {\n                    .arg(out));\n }\n \n+// rules.doc(\"doc-book\", \"src/doc/book\")\n+//      .dep(move |s| {\n+//          s.name(\"tool-rustbook\")\n+//           .host(&build.build)\n+//           .target(&build.build)\n+//           .stage(0)\n+//      })\n+//      .default(build.config.docs)\n+//      .run(move |s| doc::book(build, s.target, \"book\"));\n /// Build the book and associated stuff.\n ///\n /// We need to build:\n@@ -137,6 +179,15 @@ fn invoke_rustdoc(build: &Build, target: &str, markdown: &str) {\n     build.run(&mut cmd);\n }\n \n+// rules.doc(\"doc-standalone\", \"src/doc\")\n+//      .dep(move |s| {\n+//          s.name(\"rustc\")\n+//           .host(&build.build)\n+//           .target(&build.build)\n+//           .stage(0)\n+//      })\n+//      .default(build.config.docs)\n+//      .run(move |s| doc::standalone(build, s.target));\n /// Generates all standalone documentation as compiled by the rustdoc in `stage`\n /// for the `target` into `out`.\n ///\n@@ -209,6 +260,12 @@ pub fn standalone(build: &Build, target: &str) {\n     }\n }\n \n+// for (krate, path, default) in krates(\"std\") {\n+//     rules.doc(&krate.doc_step, path)\n+//          .dep(|s| s.name(\"libstd-link\"))\n+//          .default(default && build.config.docs)\n+//          .run(move |s| doc::std(build, s.stage, s.target));\n+// }\n /// Compile all standard library documentation.\n ///\n /// This will generate all documentation for the standard library and its\n@@ -268,6 +325,14 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     cp_r(&my_out, &out);\n }\n \n+// for (krate, path, default) in krates(\"test\") {\n+//     rules.doc(&krate.doc_step, path)\n+//          .dep(|s| s.name(\"libtest-link\"))\n+//          // Needed so rustdoc generates relative links to std.\n+//          .dep(|s| s.name(\"doc-crate-std\"))\n+//          .default(default && build.config.compiler_docs)\n+//          .run(move |s| doc::test(build, s.stage, s.target));\n+// }\n /// Compile all libtest documentation.\n ///\n /// This will generate all documentation for libtest and its dependencies. This\n@@ -298,6 +363,17 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     cp_r(&my_out, &out);\n }\n \n+\n+// for (krate, path, default) in krates(\"rustc-main\") {\n+//     rules.doc(&krate.doc_step, path)\n+//          .dep(|s| s.name(\"librustc-link\"))\n+//          // Needed so rustdoc generates relative links to std.\n+//          .dep(|s| s.name(\"doc-crate-std\"))\n+//          .host(true)\n+//          .default(default && build.config.docs)\n+//          .run(move |s| doc::rustc(build, s.stage, s.target));\n+// }\n+//\n /// Generate all compiler documentation.\n ///\n /// This will generate all documentation for the compiler libraries and their\n@@ -345,6 +421,13 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     cp_r(&my_out, &out);\n }\n \n+// rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n+//      .dep(move |s| s.name(\"tool-error-index\").target(&build.build).stage(0))\n+//      .dep(move |s| s.name(\"librustc-link\"))\n+//      .default(build.config.docs)\n+//      .host(true)\n+//      .run(move |s| doc::error_index(build, s.target));\n+\n /// Generates the HTML rendered error-index by running the\n /// `error_index_generator` tool.\n pub fn error_index(build: &Build, target: &str) {\n@@ -362,6 +445,18 @@ pub fn error_index(build: &Build, target: &str) {\n     build.run(&mut index);\n }\n \n+// rules.doc(\"doc-unstable-book-gen\", \"src/tools/unstable-book-gen\")\n+//      .dep(move |s| {\n+//          s.name(\"tool-unstable-book-gen\")\n+//           .host(&build.build)\n+//           .target(&build.build)\n+//           .stage(0)\n+//      })\n+//      .dep(move |s| s.name(\"libstd-link\"))\n+//      .default(build.config.docs)\n+//      .host(true)\n+//      .run(move |s| doc::unstable_book_gen(build, s.target));\n+\n pub fn unstable_book_gen(build: &Build, target: &str) {\n     println!(\"Generating unstable book md files ({})\", target);\n     let out = build.md_doc_out(target).join(\"unstable-book\");"}, {"sha": "638b0613bf2ccf6c5b50e340ccdf0d9809130752", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -148,3 +148,45 @@ fn add_destdir(path: &Path, destdir: &Option<PathBuf>) -> PathBuf {\n     }\n     ret\n }\n+/*\n+rules.install(\"install-docs\", \"src/doc\")\n+     .default(build.config.docs)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-docs\"))\n+     .run(move |s| install::Installer::new(build).install_docs(s.stage, s.target));\n+rules.install(\"install-std\", \"src/libstd\")\n+     .default(true)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-std\"))\n+     .run(move |s| install::Installer::new(build).install_std(s.stage));\n+rules.install(\"install-cargo\", \"cargo\")\n+     .default(build.config.extended)\n+     .host(true)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-cargo\"))\n+     .run(move |s| install::Installer::new(build).install_cargo(s.stage, s.target));\n+rules.install(\"install-rls\", \"rls\")\n+     .default(build.config.extended)\n+     .host(true)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-rls\"))\n+     .run(move |s| install::Installer::new(build).install_rls(s.stage, s.target));\n+rules.install(\"install-analysis\", \"analysis\")\n+     .default(build.config.extended)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-analysis\"))\n+     .run(move |s| install::Installer::new(build).install_analysis(s.stage, s.target));\n+rules.install(\"install-src\", \"src\")\n+     .default(build.config.extended)\n+     .host(true)\n+     .only_build(true)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-src\"))\n+     .run(move |s| install::Installer::new(build).install_src(s.stage));\n+rules.install(\"install-rustc\", \"src/librustc\")\n+     .default(true)\n+     .host(true)\n+     .only_host_build(true)\n+     .dep(|s| s.name(\"dist-rustc\"))\n+     .run(move |s| install::Installer::new(build).install_rustc(s.stage, s.target));\n+*/"}, {"sha": "e51bb5b65a9d77315b3eba23ea79772ba7e6f4c9", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -106,7 +106,6 @@ mod flags;\n mod install;\n mod native;\n mod sanity;\n-mod step;\n pub mod util;\n \n #[cfg(windows)]"}, {"sha": "d28060559aca5c4bb65b21c3bddb375af7669c80", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a1b5e8bc01061f54716005fd8ea37cc4997bfd9/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=0a1b5e8bc01061f54716005fd8ea37cc4997bfd9", "patch": "@@ -33,6 +33,16 @@ use Build;\n use util;\n use build_helper::up_to_date;\n \n+/ rules.build(\"llvm\", \"src/llvm\")\n+//      .host(true)\n+//      .dep(move |s| {\n+//          if s.target == build.build {\n+//              Step::noop()\n+//          } else {\n+//              s.target(&build.build)\n+//          }\n+//      })\n+//      .run(move |s| native::llvm(build, s.target));\n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {\n     // If we're using a custom LLVM bail out here, but we can only use a\n@@ -216,6 +226,8 @@ fn check_llvm_version(build: &Build, llvm_config: &Path) {\n     panic!(\"\\n\\nbad LLVM version: {}, need >=3.5\\n\\n\", version)\n }\n \n+//rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n+//     .run(move |s| native::test_helpers(build, s.target));\n /// Compiles the `rust_test_helpers.c` library which we used in various\n /// `run-pass` test suites for ABI testing.\n pub fn test_helpers(build: &Build, target: &str) {\n@@ -253,6 +265,9 @@ const OPENSSL_VERS: &'static str = \"1.0.2k\";\n const OPENSSL_SHA256: &'static str =\n     \"6b3977c61f2aedf0f96367dcfb5c6e578cf37e7b8d913b4ecb6643c3cb88d8c0\";\n \n+//rules.build(\"openssl\", \"path/to/nowhere\")\n+//     .run(move |s| native::openssl(build, s.target));\n+\n pub fn openssl(build: &Build, target: &str) {\n     let out = match build.openssl_dir(target) {\n         Some(dir) => dir,"}]}