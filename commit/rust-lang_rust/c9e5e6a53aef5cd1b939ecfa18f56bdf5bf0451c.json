{"sha": "c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZTVlNmE1M2FlZjVjZDFiOTM5ZWNmYTE4ZjU2YmRmNWJmMDQ1MWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T04:50:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-27T04:50:46Z"}, "message": "Auto merge of #77154 - fusion-engineering-forks:lazy-stdio, r=dtolnay\n\nRemove std::io::lazy::Lazy in favour of SyncOnceCell\n\nThe (internal) std::io::lazy::Lazy was used to lazily initialize the stdout and stdin buffers (and mutexes). It uses atexit() to register a destructor to flush the streams on exit, and mark the streams as 'closed'. Using the stream afterwards would result in a panic.\n\nStdout uses a LineWriter which contains a BufWriter that will flush the buffer on drop. This one is important to be executed during shutdown, to make sure no buffered output is lost. It also forbids access to stdout afterwards, since the buffer is already flushed and gone.\n\nStdin uses a BufReader, which does not implement Drop. It simply forgets any previously read data that was not read from the buffer yet. This means that in the case of stdin, the atexit() function's only effect is making stdin inaccessible to the program, such that later accesses result in a panic. This is uncessary, as it'd have been safe to access stdin during shutdown of the program.\n\n---\n\nThis change removes the entire io::lazy module in favour of SyncOnceCell. SyncOnceCell's fast path is much faster (a single atomic operation) than locking a sys_common::Mutex on every access like Lazy did.\n\nHowever, SyncOnceCell does not use atexit() to drop the contained object during shutdown.\n\nAs noted above, this is not a problem for stdin. It simply means stdin is now usable during shutdown.\n\nThe atexit() call for stdout is moved to the stdio module. Unlike the now-removed Lazy struct, SyncOnceCell does not have a 'gone and unusable' state that panics. Instead of adding this again, this simply replaces the buffer with one with zero capacity. This effectively flushes the old buffer *and* makes any writes afterwards pass through directly without touching a buffer, making print!() available during shutdown without panicking.\n\n---\n\nIn addition, because the contents of the SyncOnceCell are no longer dropped, we can now use `&'static` instead of `Arc` in `Stdout` and `Stdin`. This also saves two levels of indirection in `stdin()` and `stdout()`, since Lazy effectively stored a `Box<Arc<T>>`, and SyncOnceCell stores the `T` directly.", "tree": {"sha": "9c307037bc3918d17d1ab0093e3289534620963d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c307037bc3918d17d1ab0093e3289534620963d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "html_url": "https://github.com/rust-lang/rust/commit/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62fe055aba3ddac5e5d113920cf5fd80522104e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/62fe055aba3ddac5e5d113920cf5fd80522104e2", "html_url": "https://github.com/rust-lang/rust/commit/62fe055aba3ddac5e5d113920cf5fd80522104e2"}, {"sha": "6b8b9c4adbd7d8d53d730a3c01d154dec3bd179f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b8b9c4adbd7d8d53d730a3c01d154dec3bd179f", "html_url": "https://github.com/rust-lang/rust/commit/6b8b9c4adbd7d8d53d730a3c01d154dec3bd179f"}], "stats": {"total": 160, "additions": 60, "deletions": 100}, "files": [{"sha": "1968d498bbed4c588bd7e6dd2ad3acf83177920e", "filename": "library/std/src/io/lazy.rs", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/62fe055aba3ddac5e5d113920cf5fd80522104e2/library%2Fstd%2Fsrc%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62fe055aba3ddac5e5d113920cf5fd80522104e2/library%2Fstd%2Fsrc%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Flazy.rs?ref=62fe055aba3ddac5e5d113920cf5fd80522104e2", "patch": "@@ -1,63 +0,0 @@\n-use crate::cell::Cell;\n-use crate::ptr;\n-use crate::sync::Arc;\n-use crate::sys_common;\n-use crate::sys_common::mutex::Mutex;\n-\n-pub struct Lazy<T> {\n-    // We never call `lock.init()`, so it is UB to attempt to acquire this mutex reentrantly!\n-    lock: Mutex,\n-    ptr: Cell<*mut Arc<T>>,\n-}\n-\n-#[inline]\n-const fn done<T>() -> *mut Arc<T> {\n-    1_usize as *mut _\n-}\n-\n-unsafe impl<T> Sync for Lazy<T> {}\n-\n-impl<T> Lazy<T> {\n-    pub const fn new() -> Lazy<T> {\n-        Lazy { lock: Mutex::new(), ptr: Cell::new(ptr::null_mut()) }\n-    }\n-}\n-\n-impl<T: Send + Sync + 'static> Lazy<T> {\n-    /// Safety: `init` must not call `get` on the variable that is being\n-    /// initialized.\n-    pub unsafe fn get(&'static self, init: fn() -> Arc<T>) -> Option<Arc<T>> {\n-        let _guard = self.lock.lock();\n-        let ptr = self.ptr.get();\n-        if ptr.is_null() {\n-            Some(self.init(init))\n-        } else if ptr == done() {\n-            None\n-        } else {\n-            Some((*ptr).clone())\n-        }\n-    }\n-\n-    // Must only be called with `lock` held\n-    unsafe fn init(&'static self, init: fn() -> Arc<T>) -> Arc<T> {\n-        // If we successfully register an at exit handler, then we cache the\n-        // `Arc` allocation in our own internal box (it will get deallocated by\n-        // the at exit handler). Otherwise we just return the freshly allocated\n-        // `Arc`.\n-        let registered = sys_common::at_exit(move || {\n-            let ptr = {\n-                let _guard = self.lock.lock();\n-                self.ptr.replace(done())\n-            };\n-            drop(Box::from_raw(ptr))\n-        });\n-        // This could reentrantly call `init` again, which is a problem\n-        // because our `lock` allows reentrancy!\n-        // That's why `get` is unsafe and requires the caller to ensure no reentrancy happens.\n-        let ret = init();\n-        if registered.is_ok() {\n-            self.ptr.set(Box::into_raw(Box::new(ret.clone())));\n-        }\n-        ret\n-    }\n-}"}, {"sha": "d9d0380781925a85b4ed954e98bda58348009242", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "patch": "@@ -285,7 +285,6 @@ mod buffered;\n mod cursor;\n mod error;\n mod impls;\n-mod lazy;\n pub mod prelude;\n mod stdio;\n mod util;"}, {"sha": "61ccc6f13c8da871edec023f9a4d17b2e295e710", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 40, "deletions": 36, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "patch": "@@ -7,10 +7,11 @@ use crate::io::prelude::*;\n \n use crate::cell::RefCell;\n use crate::fmt;\n-use crate::io::lazy::Lazy;\n use crate::io::{self, BufReader, Initializer, IoSlice, IoSliceMut, LineWriter};\n-use crate::sync::{Arc, Mutex, MutexGuard, Once};\n+use crate::lazy::SyncOnceCell;\n+use crate::sync::{Mutex, MutexGuard};\n use crate::sys::stdio;\n+use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use crate::thread::LocalKey;\n \n@@ -217,7 +218,7 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n-    inner: Arc<Mutex<BufReader<StdinRaw>>>,\n+    inner: &'static Mutex<BufReader<StdinRaw>>,\n }\n \n /// A locked reference to the `Stdin` handle.\n@@ -292,15 +293,11 @@ pub struct StdinLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdin() -> Stdin {\n-    static INSTANCE: Lazy<Mutex<BufReader<StdinRaw>>> = Lazy::new();\n-    return Stdin {\n-        inner: unsafe { INSTANCE.get(stdin_init).expect(\"cannot access stdin during shutdown\") },\n-    };\n-\n-    fn stdin_init() -> Arc<Mutex<BufReader<StdinRaw>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stdin = stdin_raw();\n-        Arc::new(Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin)))\n+    static INSTANCE: SyncOnceCell<Mutex<BufReader<StdinRaw>>> = SyncOnceCell::new();\n+    Stdin {\n+        inner: INSTANCE.get_or_init(|| {\n+            Mutex::new(BufReader::with_capacity(stdio::STDIN_BUF_SIZE, stdin_raw()))\n+        }),\n     }\n }\n \n@@ -476,7 +473,7 @@ pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n     //        stdout (tty or not). Note that if this is not line buffered it\n     //        should also flush-on-panic or some form of flush-on-abort.\n-    inner: Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>>,\n+    inner: &'static ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>,\n }\n \n /// A locked reference to the `Stdout` handle.\n@@ -534,19 +531,27 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: Lazy<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = Lazy::new();\n-    return Stdout {\n-        inner: unsafe { INSTANCE.get(stdout_init).expect(\"cannot access stdout during shutdown\") },\n-    };\n-\n-    fn stdout_init() -> Arc<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> {\n-        // This must not reentrantly access `INSTANCE`\n-        let stdout = stdout_raw();\n-        unsafe {\n-            let ret = Arc::new(ReentrantMutex::new(RefCell::new(LineWriter::new(stdout))));\n-            ret.init();\n-            ret\n-        }\n+    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> =\n+        SyncOnceCell::new();\n+    Stdout {\n+        inner: INSTANCE.get_or_init(|| unsafe {\n+            let _ = sys_common::at_exit(|| {\n+                if let Some(instance) = INSTANCE.get() {\n+                    // Flush the data and disable buffering during shutdown\n+                    // by replacing the line writer by one with zero\n+                    // buffering capacity.\n+                    // We use try_lock() instead of lock(), because someone\n+                    // might have leaked a StdoutLock, which would\n+                    // otherwise cause a deadlock here.\n+                    if let Some(lock) = instance.try_lock() {\n+                        *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+                    }\n+                }\n+            });\n+            let r = ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())));\n+            r.init();\n+            r\n+        }),\n     }\n }\n \n@@ -741,16 +746,15 @@ pub fn stderr() -> Stderr {\n     //\n     // This has the added benefit of allowing `stderr` to be usable during\n     // process shutdown as well!\n-    static INSTANCE: ReentrantMutex<RefCell<StderrRaw>> =\n-        unsafe { ReentrantMutex::new(RefCell::new(stderr_raw())) };\n-\n-    // When accessing stderr we need one-time initialization of the reentrant\n-    // mutex. Afterwards we can just always use the now-filled-in `INSTANCE` value.\n-    static INIT: Once = Once::new();\n-    INIT.call_once(|| unsafe {\n-        INSTANCE.init();\n-    });\n-    Stderr { inner: &INSTANCE }\n+    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<StderrRaw>>> = SyncOnceCell::new();\n+\n+    Stderr {\n+        inner: INSTANCE.get_or_init(|| unsafe {\n+            let r = ReentrantMutex::new(RefCell::new(stderr_raw()));\n+            r.init();\n+            r\n+        }),\n+    }\n }\n \n impl Stderr {"}, {"sha": "a6cf812ca644eaf814d8dd73da597ee1cb5cbe91", "filename": "src/test/ui/stdout-during-shutdown.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/src%2Ftest%2Fui%2Fstdout-during-shutdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/src%2Ftest%2Fui%2Fstdout-during-shutdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstdout-during-shutdown.rs?ref=c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "patch": "@@ -0,0 +1,19 @@\n+// run-pass\n+// check-run-results\n+// ignore-emscripten\n+\n+// Emscripten doesn't flush its own stdout buffers on exit, which would fail\n+// this test. So this test is disabled on this platform.\n+// See https://emscripten.org/docs/getting_started/FAQ.html#what-does-exiting-the-runtime-mean-why-don-t-atexit-s-run\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    extern \"C\" fn bye() {\n+        print!(\", world!\");\n+    }\n+    unsafe { libc::atexit(bye) };\n+    print!(\"hello\");\n+}"}, {"sha": "30f51a3fba5274d53522d0f19748456974647b4f", "filename": "src/test/ui/stdout-during-shutdown.run.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/src%2Ftest%2Fui%2Fstdout-during-shutdown.run.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c/src%2Ftest%2Fui%2Fstdout-during-shutdown.run.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstdout-during-shutdown.run.stdout?ref=c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "patch": "@@ -0,0 +1 @@\n+hello, world!\n\\ No newline at end of file"}]}