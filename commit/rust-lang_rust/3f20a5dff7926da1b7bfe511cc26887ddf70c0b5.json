{"sha": "3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNmMjBhNWRmZjc5MjZkYTFiN2JmZTUxMWNjMjY4ODdkZGY3MGMwYjU=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-02-18T09:54:16Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-03-04T16:10:02Z"}, "message": "Optimize copying large ranges of undefmask blocks", "tree": {"sha": "6b5b7bce3cd6ae3f188cf139d52211a9734500b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b5b7bce3cd6ae3f188cf139d52211a9734500b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "html_url": "https://github.com/rust-lang/rust/commit/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9da8fc9c267c08cfdb8cf5b39da14f154d12939", "html_url": "https://github.com/rust-lang/rust/commit/a9da8fc9c267c08cfdb8cf5b39da14f154d12939"}], "stats": {"total": 67, "additions": 58, "deletions": 9}, "files": [{"sha": "06d5f27ccd74400c804cf33b1907540ad2e8844b", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 38, "deletions": 7, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "patch": "@@ -613,7 +613,6 @@ impl<Tag> DerefMut for Relocations<Tag> {\n ////////////////////////////////////////////////////////////////////////////////\n \n type Block = u64;\n-const BLOCK_SIZE: u64 = 64;\n \n #[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct UndefMask {\n@@ -624,6 +623,8 @@ pub struct UndefMask {\n impl_stable_hash_for!(struct mir::interpret::UndefMask{blocks, len});\n \n impl UndefMask {\n+    pub const BLOCK_SIZE: u64 = 64;\n+\n     pub fn new(size: Size) -> Self {\n         let mut m = UndefMask {\n             blocks: vec![],\n@@ -643,6 +644,7 @@ impl UndefMask {\n             return Err(self.len);\n         }\n \n+        // FIXME(oli-obk): optimize this for allocations larger than a block.\n         let idx = (start.bytes()..end.bytes())\n             .map(|i| Size::from_bytes(i))\n             .find(|&i| !self.get(i));\n@@ -662,8 +664,31 @@ impl UndefMask {\n     }\n \n     pub fn set_range_inbounds(&mut self, start: Size, end: Size, new_state: bool) {\n-        for i in start.bytes()..end.bytes() {\n-            self.set(Size::from_bytes(i), new_state);\n+        let (blocka, bita) = bit_index(start);\n+        let (blockb, bitb) = bit_index(end);\n+        if blocka == blockb {\n+            // within a single block\n+            for i in bita .. bitb {\n+                self.set_bit(blocka, i, new_state);\n+            }\n+            return;\n+        }\n+        // across block boundaries\n+        for i in bita .. Self::BLOCK_SIZE as usize {\n+            self.set_bit(blocka, i, new_state);\n+        }\n+        for i in 0 .. bitb {\n+            self.set_bit(blockb, i, new_state);\n+        }\n+        // fill in all the other blocks (much faster than one bit at a time)\n+        if new_state {\n+            for block in (blocka + 1) .. blockb {\n+                self.blocks[block] = 0xFFFF_FFFF_FFFF_FFFF;\n+            }\n+        } else {\n+            for block in (blocka + 1) .. blockb {\n+                self.blocks[block] = 0;\n+            }\n         }\n     }\n \n@@ -676,6 +701,11 @@ impl UndefMask {\n     #[inline]\n     pub fn set(&mut self, i: Size, new_state: bool) {\n         let (block, bit) = bit_index(i);\n+        self.set_bit(block, bit, new_state);\n+    }\n+\n+    #[inline]\n+    fn set_bit(&mut self, block: usize, bit: usize, new_state: bool) {\n         if new_state {\n             self.blocks[block] |= 1 << bit;\n         } else {\n@@ -684,11 +714,12 @@ impl UndefMask {\n     }\n \n     pub fn grow(&mut self, amount: Size, new_state: bool) {\n-        let unused_trailing_bits = self.blocks.len() as u64 * BLOCK_SIZE - self.len.bytes();\n+        let unused_trailing_bits = self.blocks.len() as u64 * Self::BLOCK_SIZE - self.len.bytes();\n         if amount.bytes() > unused_trailing_bits {\n-            let additional_blocks = amount.bytes() / BLOCK_SIZE + 1;\n+            let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`\n                 iter::repeat(0).take(additional_blocks as usize),\n             );\n         }\n@@ -701,8 +732,8 @@ impl UndefMask {\n #[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n-    let a = bits / BLOCK_SIZE;\n-    let b = bits % BLOCK_SIZE;\n+    let a = bits / UndefMask::BLOCK_SIZE;\n+    let b = bits % UndefMask::BLOCK_SIZE;\n     assert_eq!(a as usize as u64, a);\n     assert_eq!(b as usize as u64, b);\n     (a as usize, b as usize)"}, {"sha": "78668c5ad875eebe6da985e60652dc4237c2a8cc", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f20a5dff7926da1b7bfe511cc26887ddf70c0b5/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=3f20a5dff7926da1b7bfe511cc26887ddf70c0b5", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     EvalResult, Scalar, EvalErrorKind, AllocKind, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck,\n+    Machine, AllocMap, MayLeak, ErrorHandled, InboundsCheck, UndefMask,\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -785,10 +785,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n \n         let undef_mask = self.get(src.alloc_id)?.undef_mask.clone();\n+        let get = |i| undef_mask.get(src.offset + Size::from_bytes(i));\n         let dest_allocation = self.get_mut(dest.alloc_id)?;\n \n+        // an optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if size.bytes() * repeat > UndefMask::BLOCK_SIZE {\n+            let first = undef_mask.get(src.offset);\n+            // check that all bits are the same as the first bit\n+            // FIXME(oli-obk): consider making this a function on `UndefMask` and optimize it, too\n+            if (1..size.bytes()).all(|i| get(i) == first) {\n+                dest_allocation.undef_mask.set_range(\n+                    dest.offset,\n+                    dest.offset + size * repeat,\n+                    first,\n+                );\n+                return Ok(())\n+            }\n+        }\n+\n+        // the default path\n         for i in 0..size.bytes() {\n-            let defined = undef_mask.get(src.offset + Size::from_bytes(i));\n+            let defined = get(i);\n \n             for j in 0..repeat {\n                 dest_allocation.undef_mask.set("}]}