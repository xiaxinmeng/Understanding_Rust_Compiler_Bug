{"sha": "21913d0fdb848445a908021dbcd4c3accf2ca0a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxOTEzZDBmZGI4NDg0NDVhOTA4MDIxZGJjZDRjM2FjY2YyY2EwYTU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-09T11:58:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-09T11:58:48Z"}, "message": "Merge #7873 #7933\n\n7873: Consider unresolved qualifiers during flyimport r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/7679\r\n\r\nTakes unresolved qualifiers into account, providing better completions (or none, if the path is resolved or do not match).\r\n\r\nDoes not handle cases when both path qualifier and some trait has to be imported: there are many extra issues with those (such as overlapping imports, for instance) that will require large diffs to address.\r\n\r\nAlso does not do a fuzzy search on qualifier, that requires some adjustments in `import_map` for better queries and changes to the default replace range which also seems relatively big to include here.\r\n\r\n![qualifier_completion](https://user-images.githubusercontent.com/2690773/110040808-0af8dc00-7d4c-11eb-83db-65af94e843bb.gif)\r\n\n\n7933: Improve compilation speed r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "692581b2fcd0bcd7c382b593427dd39a47aa175c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/692581b2fcd0bcd7c382b593427dd39a47aa175c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21913d0fdb848445a908021dbcd4c3accf2ca0a5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgR2L4CRBK7hj4Ov3rIwAAdHIIAIJb6ARVMgAcaqd+x84HtL1m\naTcd6b3Wmv956ES69BUxwIZHXP20SKoXtCCDepDL/ZDetM/Uq03vo4cQfH5T98P6\nXbRI4oyN2ImX0Cc6Q9WLFEpxN1b4Dgvk9ZFwMuMnHKvLgnw7pE0fjo7yqI0Q1OU6\nZmOlA/QipHTwvwG4xE3QkFr5ZvQj0czFeb7kXTBktMIj+SbcUHCkbvJasCow1xZu\nv2wAUsQ0P6dbZD8jmRR6FvAAHivNMil5r7i6DbUPeo7E/987qOndlJ9I1HI64wlX\nKOiqGcmHTjLAGdjUD0HqPINTBRsUoH9C9FnHt481RxdcUpuR7oZPAq/qhPL8AvU=\n=3etZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 692581b2fcd0bcd7c382b593427dd39a47aa175c\nparent 5e0e5302d58cba5689e1a28c8e3b33f06a092546\nparent 778deb38fe7e1bac8833934224d26f44eb80a6cc\nparent 867fdf8f03a25862c122614688c38f5e26e08e1f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615291128 +0000\ncommitter GitHub <noreply@github.com> 1615291128 +0000\n\nMerge #7873 #7933\n\n7873: Consider unresolved qualifiers during flyimport r=matklad a=SomeoneToIgnore\n\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/7679\r\n\r\nTakes unresolved qualifiers into account, providing better completions (or none, if the path is resolved or do not match).\r\n\r\nDoes not handle cases when both path qualifier and some trait has to be imported: there are many extra issues with those (such as overlapping imports, for instance) that will require large diffs to address.\r\n\r\nAlso does not do a fuzzy search on qualifier, that requires some adjustments in `import_map` for better queries and changes to the default replace range which also seems relatively big to include here.\r\n\r\n![qualifier_completion](https://user-images.githubusercontent.com/2690773/110040808-0af8dc00-7d4c-11eb-83db-65af94e843bb.gif)\r\n\n\n7933: Improve compilation speed r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21913d0fdb848445a908021dbcd4c3accf2ca0a5", "html_url": "https://github.com/rust-lang/rust/commit/21913d0fdb848445a908021dbcd4c3accf2ca0a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21913d0fdb848445a908021dbcd4c3accf2ca0a5/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e0e5302d58cba5689e1a28c8e3b33f06a092546", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e0e5302d58cba5689e1a28c8e3b33f06a092546", "html_url": "https://github.com/rust-lang/rust/commit/5e0e5302d58cba5689e1a28c8e3b33f06a092546"}, {"sha": "778deb38fe7e1bac8833934224d26f44eb80a6cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/778deb38fe7e1bac8833934224d26f44eb80a6cc", "html_url": "https://github.com/rust-lang/rust/commit/778deb38fe7e1bac8833934224d26f44eb80a6cc"}, {"sha": "867fdf8f03a25862c122614688c38f5e26e08e1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/867fdf8f03a25862c122614688c38f5e26e08e1f", "html_url": "https://github.com/rust-lang/rust/commit/867fdf8f03a25862c122614688c38f5e26e08e1f"}], "stats": {"total": 1227, "additions": 847, "deletions": 380}, "files": [{"sha": "d5a3d9034c1476740cf34b1bd839a699390afc4c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1114,6 +1114,7 @@ pub enum AssocItem {\n     Const(Const),\n     TypeAlias(TypeAlias),\n }\n+#[derive(Debug)]\n pub enum AssocItemContainer {\n     Trait(Trait),\n     Impl(Impl),\n@@ -2136,6 +2137,16 @@ impl ScopeDef {\n     }\n }\n \n+impl From<ItemInNs> for ScopeDef {\n+    fn from(item: ItemInNs) -> Self {\n+        match item {\n+            ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n+            ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n+            ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n+        }\n+    }\n+}\n+\n pub trait HasVisibility {\n     fn visibility(&self, db: &dyn HirDatabase) -> Visibility;\n     fn is_visible_from(&self, db: &dyn HirDatabase, module: Module) -> bool {"}, {"sha": "f83ed65d5a6b58b9b593c6e8a18a3a68b589d152", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -478,7 +478,6 @@ impl Analysis {\n         position: FilePosition,\n         full_import_path: &str,\n         imported_name: String,\n-        import_for_trait_assoc_item: bool,\n     ) -> Cancelable<Vec<TextEdit>> {\n         Ok(self\n             .with_db(|db| {\n@@ -488,7 +487,6 @@ impl Analysis {\n                     position,\n                     full_import_path,\n                     imported_name,\n-                    import_for_trait_assoc_item,\n                 )\n             })?\n             .unwrap_or_default())"}, {"sha": "7caee8df04c464d70c9fab6f80ad50531f73e1a3", "filename": "crates/ide_assists/src/handlers/auto_import.rs", "status": "modified", "additions": 11, "deletions": 41, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1,7 +1,7 @@\n use ide_db::helpers::{\n     import_assets::{ImportAssets, ImportCandidate},\n     insert_use::{insert_use, ImportScope},\n-    mod_path_to_ast,\n+    item_name, mod_path_to_ast,\n };\n use syntax::{ast, AstNode, SyntaxNode};\n \n@@ -92,14 +92,19 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     let range = ctx.sema.original_range(&syntax_under_caret).range;\n     let group = import_group_message(import_assets.import_candidate());\n     let scope = ImportScope::find_insert_use_container(&syntax_under_caret, &ctx.sema)?;\n-    for (import, _) in proposed_imports {\n+    for import in proposed_imports {\n+        let name = match item_name(ctx.db(), import.original_item) {\n+            Some(name) => name,\n+            None => continue,\n+        };\n         acc.add_group(\n             &group,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{}`\", &import),\n+            format!(\"Import `{}`\", name),\n             range,\n             |builder| {\n-                let rewriter = insert_use(&scope, mod_path_to_ast(&import), ctx.config.insert_use);\n+                let rewriter =\n+                    insert_use(&scope, mod_path_to_ast(&import.import_path), ctx.config.insert_use);\n                 builder.rewrite(rewriter);\n             },\n         );\n@@ -125,10 +130,10 @@ fn import_group_message(import_candidate: &ImportCandidate) -> GroupLabel {\n     let name = match import_candidate {\n         ImportCandidate::Path(candidate) => format!(\"Import {}\", candidate.name.text()),\n         ImportCandidate::TraitAssocItem(candidate) => {\n-            format!(\"Import a trait for item {}\", candidate.name.text())\n+            format!(\"Import a trait for item {}\", candidate.assoc_item_name.text())\n         }\n         ImportCandidate::TraitMethod(candidate) => {\n-            format!(\"Import a trait for method {}\", candidate.name.text())\n+            format!(\"Import a trait for method {}\", candidate.assoc_item_name.text())\n         }\n     };\n     GroupLabel(name)\n@@ -220,41 +225,6 @@ mod tests {\n         );\n     }\n \n-    #[test]\n-    fn auto_imports_are_merged() {\n-        check_assist(\n-            auto_import,\n-            r\"\n-            use PubMod::PubStruct1;\n-\n-            struct Test {\n-                test: Pub$0Struct2<u8>,\n-            }\n-\n-            pub mod PubMod {\n-                pub struct PubStruct1;\n-                pub struct PubStruct2<T> {\n-                    _t: T,\n-                }\n-            }\n-            \",\n-            r\"\n-            use PubMod::{PubStruct1, PubStruct2};\n-\n-            struct Test {\n-                test: PubStruct2<u8>,\n-            }\n-\n-            pub mod PubMod {\n-                pub struct PubStruct1;\n-                pub struct PubStruct2<T> {\n-                    _t: T,\n-                }\n-            }\n-            \",\n-        );\n-    }\n-\n     #[test]\n     fn applicable_when_found_multiple_imports() {\n         check_assist("}, {"sha": "272874ae390a1d3539899f10f34b692476ccded5", "filename": "crates/ide_assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1,7 +1,10 @@\n use std::iter;\n \n use hir::AsAssocItem;\n-use ide_db::helpers::{import_assets::ImportCandidate, mod_path_to_ast};\n+use ide_db::helpers::{\n+    import_assets::{ImportCandidate, LocatedImport},\n+    item_name, mod_path_to_ast,\n+};\n use ide_db::RootDatabase;\n use syntax::{\n     ast,\n@@ -71,17 +74,17 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     };\n \n     let group_label = group_label(candidate);\n-    for (import, item) in proposed_imports {\n+    for import in proposed_imports {\n         acc.add_group(\n             &group_label,\n             AssistId(\"qualify_path\", AssistKind::QuickFix),\n-            label(candidate, &import),\n+            label(ctx.db(), candidate, &import),\n             range,\n             |builder| {\n                 qualify_candidate.qualify(\n                     |replace_with: String| builder.replace(range, replace_with),\n-                    import,\n-                    item,\n+                    &import.import_path,\n+                    import.item_to_import,\n                 )\n             },\n         );\n@@ -97,8 +100,13 @@ enum QualifyCandidate<'db> {\n }\n \n impl QualifyCandidate<'_> {\n-    fn qualify(&self, mut replacer: impl FnMut(String), import: hir::ModPath, item: hir::ItemInNs) {\n-        let import = mod_path_to_ast(&import);\n+    fn qualify(\n+        &self,\n+        mut replacer: impl FnMut(String),\n+        import: &hir::ModPath,\n+        item: hir::ItemInNs,\n+    ) {\n+        let import = mod_path_to_ast(import);\n         match self {\n             QualifyCandidate::QualifierStart(segment, generics) => {\n                 let generics = generics.as_ref().map_or_else(String::new, ToString::to_string);\n@@ -183,23 +191,29 @@ fn item_as_trait(db: &RootDatabase, item: hir::ItemInNs) -> Option<hir::Trait> {\n fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     let name = match candidate {\n         ImportCandidate::Path(it) => &it.name,\n-        ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => &it.name,\n+        ImportCandidate::TraitAssocItem(it) | ImportCandidate::TraitMethod(it) => {\n+            &it.assoc_item_name\n+        }\n     }\n     .text();\n     GroupLabel(format!(\"Qualify {}\", name))\n }\n \n-fn label(candidate: &ImportCandidate, import: &hir::ModPath) -> String {\n+fn label(db: &RootDatabase, candidate: &ImportCandidate, import: &LocatedImport) -> String {\n+    let display_path = match item_name(db, import.original_item) {\n+        Some(display_path) => display_path.to_string(),\n+        None => \"{unknown}\".to_string(),\n+    };\n     match candidate {\n         ImportCandidate::Path(candidate) => {\n             if candidate.qualifier.is_some() {\n-                format!(\"Qualify with `{}`\", &import)\n+                format!(\"Qualify with `{}`\", display_path)\n             } else {\n-                format!(\"Qualify as `{}`\", &import)\n+                format!(\"Qualify as `{}`\", display_path)\n             }\n         }\n-        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", &import),\n-        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", &import),\n+        ImportCandidate::TraitAssocItem(_) => format!(\"Qualify `{}`\", display_path),\n+        ImportCandidate::TraitMethod(_) => format!(\"Qualify with cast as `{}`\", display_path),\n     }\n }\n "}, {"sha": "88fe2fe90472ddb857e54d387ffdf8c3ea681037", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1,5 +1,6 @@\n+use hir::ModuleDef;\n use ide_db::helpers::mod_path_to_ast;\n-use ide_db::imports_locator;\n+use ide_db::items_locator;\n use itertools::Itertools;\n use syntax::{\n     ast::{self, make, AstNode, NameOwner},\n@@ -64,22 +65,20 @@ pub(crate) fn replace_derive_with_manual_impl(\n     let current_module = ctx.sema.scope(annotated_name.syntax()).module()?;\n     let current_crate = current_module.krate();\n \n-    let found_traits = imports_locator::find_exact_imports(\n-        &ctx.sema,\n-        current_crate,\n-        trait_token.text().to_string(),\n-    )\n-    .filter_map(|candidate: either::Either<hir::ModuleDef, hir::MacroDef>| match candidate {\n-        either::Either::Left(hir::ModuleDef::Trait(trait_)) => Some(trait_),\n-        _ => None,\n-    })\n-    .flat_map(|trait_| {\n-        current_module\n-            .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n-            .as_ref()\n-            .map(mod_path_to_ast)\n-            .zip(Some(trait_))\n-    });\n+    let found_traits =\n+        items_locator::with_exact_name(&ctx.sema, current_crate, trait_token.text().to_string())\n+            .into_iter()\n+            .filter_map(|item| match ModuleDef::from(item.as_module_def_id()?) {\n+                ModuleDef::Trait(trait_) => Some(trait_),\n+                _ => None,\n+            })\n+            .flat_map(|trait_| {\n+                current_module\n+                    .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+                    .as_ref()\n+                    .map(mod_path_to_ast)\n+                    .zip(Some(trait_))\n+            });\n \n     let mut no_traits_found = true;\n     for (trait_path, trait_) in found_traits.inspect(|_| no_traits_found = false) {"}, {"sha": "391a11c91c9e9ea9e157945d0a97769582195403", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 222, "deletions": 48, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -21,6 +21,46 @@\n //! ```\n //!\n //! Also completes associated items, that require trait imports.\n+//! If any unresolved and/or partially-qualified path predeces the input, it will be taken into account.\n+//! Currently, only the imports with their import path ending with the whole qialifier will be proposed\n+//! (no fuzzy matching for qualifier).\n+//!\n+//! ```\n+//! mod foo {\n+//!     pub mod bar {\n+//!         pub struct Item;\n+//!\n+//!         impl Item {\n+//!             pub const TEST_ASSOC: usize = 3;\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     bar::Item::TEST_A$0\n+//! }\n+//! ```\n+//! ->\n+//! ```\n+//! use foo::bar;\n+//!\n+//! mod foo {\n+//!     pub mod bar {\n+//!         pub struct Item;\n+//!\n+//!         impl Item {\n+//!             pub const TEST_ASSOC: usize = 3;\n+//!         }\n+//!     }\n+//! }\n+//!\n+//! fn main() {\n+//!     bar::Item::TEST_ASSOC\n+//! }\n+//! ```\n+//!\n+//! NOTE: currently, if an assoc item comes from a trait that's not currently imported and it also has an unresolved and/or partially-qualified path,\n+//! no imports will be proposed.\n //!\n //! .Fuzzy search details\n //!\n@@ -48,12 +88,12 @@\n //! Note that having this flag set to `true` does not guarantee that the feature is enabled: your client needs to have the corredponding\n //! capability enabled.\n \n-use hir::{AsAssocItem, ModPath, ScopeDef};\n+use hir::ModPath;\n use ide_db::helpers::{\n     import_assets::{ImportAssets, ImportCandidate},\n     insert_use::ImportScope,\n };\n-use rustc_hash::FxHashSet;\n+use itertools::Itertools;\n use syntax::{AstNode, SyntaxNode, T};\n \n use crate::{\n@@ -92,50 +132,26 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n         &ctx.sema,\n     )?;\n \n-    let scope_definitions = scope_definitions(ctx);\n-    let mut all_mod_paths = import_assets\n-        .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n-        .into_iter()\n-        .map(|(mod_path, item_in_ns)| {\n-            let scope_item = match item_in_ns {\n-                hir::ItemInNs::Types(id) => ScopeDef::ModuleDef(id.into()),\n-                hir::ItemInNs::Values(id) => ScopeDef::ModuleDef(id.into()),\n-                hir::ItemInNs::Macros(id) => ScopeDef::MacroDef(id.into()),\n-            };\n-            (mod_path, scope_item)\n-        })\n-        .filter(|(_, proposed_def)| !scope_definitions.contains(proposed_def))\n-        .collect::<Vec<_>>();\n-    all_mod_paths.sort_by_cached_key(|(mod_path, _)| {\n-        compute_fuzzy_completion_order_key(mod_path, &user_input_lowercased)\n-    });\n-\n-    acc.add_all(all_mod_paths.into_iter().filter_map(|(import_path, definition)| {\n-        let import_for_trait_assoc_item = match definition {\n-            ScopeDef::ModuleDef(module_def) => module_def\n-                .as_assoc_item(ctx.db)\n-                .and_then(|assoc| assoc.containing_trait(ctx.db))\n-                .is_some(),\n-            _ => false,\n-        };\n-        let import_edit = ImportEdit {\n-            import_path,\n-            import_scope: import_scope.clone(),\n-            import_for_trait_assoc_item,\n-        };\n-        render_resolution_with_import(RenderContext::new(ctx), import_edit, &definition)\n-    }));\n+    acc.add_all(\n+        import_assets\n+            .search_for_imports(&ctx.sema, ctx.config.insert_use.prefix_kind)\n+            .into_iter()\n+            .sorted_by_key(|located_import| {\n+                compute_fuzzy_completion_order_key(\n+                    &located_import.import_path,\n+                    &user_input_lowercased,\n+                )\n+            })\n+            .filter_map(|import| {\n+                render_resolution_with_import(\n+                    RenderContext::new(ctx),\n+                    ImportEdit { import, scope: import_scope.clone() },\n+                )\n+            }),\n+    );\n     Some(())\n }\n \n-fn scope_definitions(ctx: &CompletionContext) -> FxHashSet<ScopeDef> {\n-    let mut scope_definitions = FxHashSet::default();\n-    ctx.scope.process_all_names(&mut |_, scope_def| {\n-        scope_definitions.insert(scope_def);\n-    });\n-    scope_definitions\n-}\n-\n pub(crate) fn position_for_import<'a>(\n     ctx: &'a CompletionContext,\n     import_candidate: Option<&ImportCandidate>,\n@@ -160,23 +176,30 @@ fn import_assets(ctx: &CompletionContext, fuzzy_name: String) -> Option<ImportAs\n             current_module,\n             ctx.sema.type_of_expr(dot_receiver)?,\n             fuzzy_name,\n+            dot_receiver.syntax().clone(),\n         )\n     } else {\n         let fuzzy_name_length = fuzzy_name.len();\n+        let approximate_node = match current_module.definition_source(ctx.db).value {\n+            hir::ModuleSource::SourceFile(s) => s.syntax().clone(),\n+            hir::ModuleSource::Module(m) => m.syntax().clone(),\n+            hir::ModuleSource::BlockExpr(b) => b.syntax().clone(),\n+        };\n         let assets_for_path = ImportAssets::for_fuzzy_path(\n             current_module,\n             ctx.path_qual.clone(),\n             fuzzy_name,\n             &ctx.sema,\n-        );\n+            approximate_node,\n+        )?;\n \n-        if matches!(assets_for_path.as_ref()?.import_candidate(), ImportCandidate::Path(_))\n+        if matches!(assets_for_path.import_candidate(), ImportCandidate::Path(_))\n             && fuzzy_name_length < 2\n         {\n             cov_mark::hit!(ignore_short_input_for_path);\n             None\n         } else {\n-            assets_for_path\n+            Some(assets_for_path)\n         }\n     }\n }\n@@ -186,11 +209,11 @@ fn compute_fuzzy_completion_order_key(\n     user_input_lowercased: &str,\n ) -> usize {\n     cov_mark::hit!(certain_fuzzy_order_test);\n-    let proposed_import_name = match proposed_mod_path.segments().last() {\n+    let import_name = match proposed_mod_path.segments().last() {\n         Some(name) => name.to_string().to_lowercase(),\n         None => return usize::MAX,\n     };\n-    match proposed_import_name.match_indices(user_input_lowercased).next() {\n+    match import_name.match_indices(user_input_lowercased).next() {\n         Some((first_matching_index, _)) => first_matching_index,\n         None => usize::MAX,\n     }\n@@ -773,4 +796,155 @@ fn main() {\n }\"#,\n         );\n     }\n+\n+    #[test]\n+    fn unresolved_qualifier() {\n+        let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub mod baz {\n+            pub struct Item;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::baz::Ite$0\n+}\"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        st foo::bar::baz::Item\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"Item\",\n+            fixture,\n+            r#\"\n+        use foo::bar;\n+\n+        mod foo {\n+            pub mod bar {\n+                pub mod baz {\n+                    pub struct Item;\n+                }\n+            }\n+        }\n+\n+        fn main() {\n+            bar::baz::Item\n+        }\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_assoc_item_container() {\n+        let fixture = r#\"\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_A$0\n+}\"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        ct TEST_ASSOC (foo::Item)\n+        \"#]],\n+        );\n+\n+        check_edit(\n+            \"TEST_ASSOC\",\n+            fixture,\n+            r#\"\n+use foo::Item;\n+\n+mod foo {\n+    pub struct Item;\n+\n+    impl Item {\n+        pub const TEST_ASSOC: usize = 3;\n+    }\n+}\n+\n+fn main() {\n+    Item::TEST_ASSOC\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn unresolved_assoc_item_container_with_path() {\n+        let fixture = r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_A$0\n+}\"#;\n+\n+        check(\n+            fixture,\n+            expect![[r#\"\n+        ct TEST_ASSOC (foo::bar::Item)\n+    \"#]],\n+        );\n+\n+        check_edit(\n+            \"TEST_ASSOC\",\n+            fixture,\n+            r#\"\n+use foo::bar;\n+\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Item::TEST_ASSOC\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn fuzzy_unresolved_path() {\n+        check(\n+            r#\"\n+mod foo {\n+    pub mod bar {\n+        pub struct Item;\n+\n+        impl Item {\n+            pub const TEST_ASSOC: usize = 3;\n+        }\n+    }\n+}\n+\n+fn main() {\n+    bar::Ass$0\n+}\"#,\n+            expect![[]],\n+        )\n+    }\n }"}, {"sha": "9b039e3e5f0449c2aa6505e19f9e8b893be58548", "filename": "crates/ide_completion/src/item.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fitem.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -2,15 +2,16 @@\n \n use std::fmt;\n \n-use hir::{Documentation, ModPath, Mutability};\n+use hir::{Documentation, Mutability};\n use ide_db::{\n     helpers::{\n+        import_assets::LocatedImport,\n         insert_use::{self, ImportScope, InsertUseConfig},\n         mod_path_to_ast, SnippetCap,\n     },\n     SymbolKind,\n };\n-use stdx::{impl_from, never};\n+use stdx::{format_to, impl_from, never};\n use syntax::{algo, TextRange};\n use text_edit::TextEdit;\n \n@@ -272,9 +273,8 @@ impl CompletionItem {\n /// An extra import to add after the completion is applied.\n #[derive(Debug, Clone)]\n pub struct ImportEdit {\n-    pub import_path: ModPath,\n-    pub import_scope: ImportScope,\n-    pub import_for_trait_assoc_item: bool,\n+    pub import: LocatedImport,\n+    pub scope: ImportScope,\n }\n \n impl ImportEdit {\n@@ -284,7 +284,7 @@ impl ImportEdit {\n         let _p = profile::span(\"ImportEdit::to_text_edit\");\n \n         let rewriter =\n-            insert_use::insert_use(&self.import_scope, mod_path_to_ast(&self.import_path), cfg);\n+            insert_use::insert_use(&self.scope, mod_path_to_ast(&self.import.import_path), cfg);\n         let old_ast = rewriter.rewrite_root()?;\n         let mut import_insert = TextEdit::builder();\n         algo::diff(&old_ast, &rewriter.rewrite(&old_ast)).into_text_edit(&mut import_insert);\n@@ -322,20 +322,19 @@ impl Builder {\n         let mut lookup = self.lookup;\n         let mut insert_text = self.insert_text;\n \n-        if let Some(import_to_add) = self.import_to_add.as_ref() {\n-            if import_to_add.import_for_trait_assoc_item {\n-                lookup = lookup.or_else(|| Some(label.clone()));\n-                insert_text = insert_text.or_else(|| Some(label.clone()));\n-                label = format!(\"{} ({})\", label, import_to_add.import_path);\n+        if let Some(original_path) = self\n+            .import_to_add\n+            .as_ref()\n+            .and_then(|import_edit| import_edit.import.original_path.as_ref())\n+        {\n+            lookup = lookup.or_else(|| Some(label.clone()));\n+            insert_text = insert_text.or_else(|| Some(label.clone()));\n+\n+            let original_path_label = original_path.to_string();\n+            if original_path_label.ends_with(&label) {\n+                label = original_path_label;\n             } else {\n-                let mut import_path_without_last_segment = import_to_add.import_path.to_owned();\n-                let _ = import_path_without_last_segment.pop_segment();\n-\n-                if !import_path_without_last_segment.segments().is_empty() {\n-                    lookup = lookup.or_else(|| Some(label.clone()));\n-                    insert_text = insert_text.or_else(|| Some(label.clone()));\n-                    label = format!(\"{}::{}\", import_path_without_last_segment, label);\n-                }\n+                format_to!(label, \" ({})\", original_path)\n             }\n         }\n \n@@ -439,9 +438,3 @@ impl Builder {\n         self\n     }\n }\n-\n-impl<'a> Into<CompletionItem> for Builder {\n-    fn into(self) -> CompletionItem {\n-        self.build()\n-    }\n-}"}, {"sha": "a0c8c374d0d57b391e96385b2040f79e567da6d9", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -13,7 +13,9 @@ mod completions;\n \n use completions::flyimport::position_for_import;\n use ide_db::{\n-    base_db::FilePosition, helpers::insert_use::ImportScope, imports_locator, RootDatabase,\n+    base_db::FilePosition,\n+    helpers::{import_assets::LocatedImport, insert_use::ImportScope},\n+    items_locator, RootDatabase,\n };\n use text_edit::TextEdit;\n \n@@ -139,25 +141,27 @@ pub fn resolve_completion_edits(\n     position: FilePosition,\n     full_import_path: &str,\n     imported_name: String,\n-    import_for_trait_assoc_item: bool,\n ) -> Option<Vec<TextEdit>> {\n     let ctx = CompletionContext::new(db, position, config)?;\n     let position_for_import = position_for_import(&ctx, None)?;\n-    let import_scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n+    let scope = ImportScope::find_insert_use_container(position_for_import, &ctx.sema)?;\n \n     let current_module = ctx.sema.scope(position_for_import).module()?;\n     let current_crate = current_module.krate();\n \n-    let import_path = imports_locator::find_exact_imports(&ctx.sema, current_crate, imported_name)\n-        .filter_map(|candidate| {\n-            let item: hir::ItemInNs = candidate.either(Into::into, Into::into);\n-            current_module.find_use_path_prefixed(db, item, config.insert_use.prefix_kind)\n-        })\n-        .find(|mod_path| mod_path.to_string() == full_import_path)?;\n+    let (import_path, item_to_import) =\n+        items_locator::with_exact_name(&ctx.sema, current_crate, imported_name)\n+            .into_iter()\n+            .filter_map(|candidate| {\n+                current_module\n+                    .find_use_path_prefixed(db, candidate, config.insert_use.prefix_kind)\n+                    .zip(Some(candidate))\n+            })\n+            .find(|(mod_path, _)| mod_path.to_string() == full_import_path)?;\n+    let import =\n+        LocatedImport::new(import_path.clone(), item_to_import, item_to_import, Some(import_path));\n \n-    ImportEdit { import_path, import_scope, import_for_trait_assoc_item }\n-        .to_text_edit(config.insert_use)\n-        .map(|edit| vec![edit])\n+    ImportEdit { import, scope }.to_text_edit(config.insert_use).map(|edit| vec![edit])\n }\n \n #[cfg(test)]"}, {"sha": "fae5685e2270a944fe6f9941e9415abc228dddf5", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -13,7 +13,10 @@ mod builder_ext;\n use hir::{\n     AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type,\n };\n-use ide_db::{helpers::SnippetCap, RootDatabase, SymbolKind};\n+use ide_db::{\n+    helpers::{item_name, SnippetCap},\n+    RootDatabase, SymbolKind,\n+};\n use syntax::TextRange;\n \n use crate::{\n@@ -50,18 +53,20 @@ pub(crate) fn render_resolution<'a>(\n pub(crate) fn render_resolution_with_import<'a>(\n     ctx: RenderContext<'a>,\n     import_edit: ImportEdit,\n-    resolution: &ScopeDef,\n ) -> Option<CompletionItem> {\n+    let resolution = ScopeDef::from(import_edit.import.original_item);\n     let local_name = match resolution {\n         ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n         ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n         ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => import_edit.import_path.segments().last()?.to_string(),\n+        _ => item_name(ctx.db(), import_edit.import.original_item)?.to_string(),\n     };\n-    Render::new(ctx).render_resolution(local_name, Some(import_edit), resolution).map(|mut item| {\n-        item.completion_kind = CompletionKind::Magic;\n-        item\n-    })\n+    Render::new(ctx).render_resolution(local_name, Some(import_edit), &resolution).map(\n+        |mut item| {\n+            item.completion_kind = CompletionKind::Magic;\n+            item\n+        },\n+    )\n }\n \n /// Interface for data and methods required for items rendering."}, {"sha": "3c95d3cffa78d20f935f1338e3b10e3aaf9983c8", "filename": "crates/ide_db/src/helpers.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -2,11 +2,19 @@\n pub mod insert_use;\n pub mod import_assets;\n \n-use hir::{Crate, Enum, Module, ScopeDef, Semantics, Trait};\n+use hir::{Crate, Enum, ItemInNs, MacroDef, Module, ModuleDef, Name, ScopeDef, Semantics, Trait};\n use syntax::ast::{self, make};\n \n use crate::RootDatabase;\n \n+pub fn item_name(db: &RootDatabase, item: ItemInNs) -> Option<Name> {\n+    match item {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).name(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).name(db),\n+    }\n+}\n+\n /// Converts the mod path struct into its ast representation.\n pub fn mod_path_to_ast(path: &hir::ModPath) -> ast::Path {\n     let _p = profile::span(\"mod_path_to_ast\");"}, {"sha": "e03ccd35155a98269ee384239a557afc39b6f863", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 411, "deletions": 167, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1,19 +1,29 @@\n //! Look up accessible paths for items.\n-use either::Either;\n-use hir::{AsAssocItem, AssocItem, Crate, MacroDef, Module, ModuleDef, PrefixKind, Semantics};\n+use hir::{\n+    AsAssocItem, AssocItem, AssocItemContainer, Crate, ItemInNs, MacroDef, ModPath, Module,\n+    ModuleDef, PathResolution, PrefixKind, ScopeDef, Semantics, Type,\n+};\n+use itertools::Itertools;\n use rustc_hash::FxHashSet;\n-use syntax::{ast, AstNode};\n+use syntax::{ast, utils::path_to_string_stripping_turbo_fish, AstNode, SyntaxNode};\n \n use crate::{\n-    imports_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n+    items_locator::{self, AssocItemSearch, DEFAULT_QUERY_SEARCH_LIMIT},\n     RootDatabase,\n };\n \n+use super::item_name;\n+\n+/// A candidate for import, derived during various IDE activities:\n+/// * completion with imports on the fly proposals\n+/// * completion edit resolve requests\n+/// * assists\n+/// * etc.\n #[derive(Debug)]\n pub enum ImportCandidate {\n-    // A path, qualified (`std::collections::HashMap`) or not (`HashMap`).\n+    /// A path, qualified (`std::collections::HashMap`) or not (`HashMap`).\n     Path(PathImportCandidate),\n-    /// A trait associated function (with no self parameter) or associated constant.\n+    /// A trait associated function (with no self parameter) or an associated constant.\n     /// For 'test_mod::TestEnum::test_function', `ty` is the `test_mod::TestEnum` expression type\n     /// and `name` is the `test_function`\n     TraitAssocItem(TraitImportCandidate),\n@@ -23,21 +33,40 @@ pub enum ImportCandidate {\n     TraitMethod(TraitImportCandidate),\n }\n \n+/// A trait import needed for a given associated item access.\n+/// For `some::path::SomeStruct::ASSOC_`, contains the\n+/// type of `some::path::SomeStruct` and `ASSOC_` as the item name.\n #[derive(Debug)]\n pub struct TraitImportCandidate {\n-    pub receiver_ty: hir::Type,\n-    pub name: NameToImport,\n+    /// A type of the item that has the associated item accessed at.\n+    pub receiver_ty: Type,\n+    /// The associated item name that the trait to import should contain.\n+    pub assoc_item_name: NameToImport,\n }\n \n+/// Path import for a given name, qualified or not.\n #[derive(Debug)]\n pub struct PathImportCandidate {\n-    pub qualifier: Option<ast::Path>,\n+    /// Optional qualifier before name.\n+    pub qualifier: Option<FirstSegmentUnresolved>,\n+    /// The name the item (struct, trait, enum, etc.) should have.\n     pub name: NameToImport,\n }\n \n+/// A qualifier that has a first segment and it's unresolved.\n+#[derive(Debug)]\n+pub struct FirstSegmentUnresolved {\n+    fist_segment: ast::NameRef,\n+    full_qualifier: ast::Path,\n+}\n+\n+/// A name that will be used during item lookups.\n #[derive(Debug)]\n pub enum NameToImport {\n+    /// Requires items with names that exactly match the given string, case-sensitive.\n     Exact(String),\n+    /// Requires items with names that case-insensitively contain all letters from the string,\n+    /// in the same order, but not necessary adjacent.\n     Fuzzy(String),\n }\n \n@@ -50,221 +79,385 @@ impl NameToImport {\n     }\n }\n \n+/// A struct to find imports in the project, given a certain name (or its part) and the context.\n #[derive(Debug)]\n pub struct ImportAssets {\n     import_candidate: ImportCandidate,\n-    module_with_candidate: hir::Module,\n+    candidate_node: SyntaxNode,\n+    module_with_candidate: Module,\n }\n \n impl ImportAssets {\n     pub fn for_method_call(\n         method_call: &ast::MethodCallExpr,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n+        let candidate_node = method_call.syntax().clone();\n         Some(Self {\n             import_candidate: ImportCandidate::for_method_call(sema, method_call)?,\n-            module_with_candidate: sema.scope(method_call.syntax()).module()?,\n+            module_with_candidate: sema.scope(&candidate_node).module()?,\n+            candidate_node,\n         })\n     }\n \n     pub fn for_exact_path(\n         fully_qualified_path: &ast::Path,\n         sema: &Semantics<RootDatabase>,\n     ) -> Option<Self> {\n-        let syntax_under_caret = fully_qualified_path.syntax();\n-        if syntax_under_caret.ancestors().find_map(ast::Use::cast).is_some() {\n+        let candidate_node = fully_qualified_path.syntax().clone();\n+        if candidate_node.ancestors().find_map(ast::Use::cast).is_some() {\n             return None;\n         }\n         Some(Self {\n             import_candidate: ImportCandidate::for_regular_path(sema, fully_qualified_path)?,\n-            module_with_candidate: sema.scope(syntax_under_caret).module()?,\n+            module_with_candidate: sema.scope(&candidate_node).module()?,\n+            candidate_node,\n         })\n     }\n \n     pub fn for_fuzzy_path(\n-        module_with_path: Module,\n+        module_with_candidate: Module,\n         qualifier: Option<ast::Path>,\n         fuzzy_name: String,\n         sema: &Semantics<RootDatabase>,\n+        candidate_node: SyntaxNode,\n     ) -> Option<Self> {\n-        Some(match qualifier {\n-            Some(qualifier) => {\n-                let qualifier_resolution = sema.resolve_path(&qualifier)?;\n-                match qualifier_resolution {\n-                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => Self {\n-                        import_candidate: ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            receiver_ty: assoc_item_path.ty(sema.db),\n-                            name: NameToImport::Fuzzy(fuzzy_name),\n-                        }),\n-                        module_with_candidate: module_with_path,\n-                    },\n-                    _ => Self {\n-                        import_candidate: ImportCandidate::Path(PathImportCandidate {\n-                            qualifier: Some(qualifier),\n-                            name: NameToImport::Fuzzy(fuzzy_name),\n-                        }),\n-                        module_with_candidate: module_with_path,\n-                    },\n-                }\n-            }\n-            None => Self {\n-                import_candidate: ImportCandidate::Path(PathImportCandidate {\n-                    qualifier: None,\n-                    name: NameToImport::Fuzzy(fuzzy_name),\n-                }),\n-                module_with_candidate: module_with_path,\n-            },\n+        Some(Self {\n+            import_candidate: ImportCandidate::for_fuzzy_path(qualifier, fuzzy_name, sema)?,\n+            module_with_candidate,\n+            candidate_node,\n         })\n     }\n \n     pub fn for_fuzzy_method_call(\n         module_with_method_call: Module,\n-        receiver_ty: hir::Type,\n+        receiver_ty: Type,\n         fuzzy_method_name: String,\n+        candidate_node: SyntaxNode,\n     ) -> Option<Self> {\n         Some(Self {\n             import_candidate: ImportCandidate::TraitMethod(TraitImportCandidate {\n                 receiver_ty,\n-                name: NameToImport::Fuzzy(fuzzy_method_name),\n+                assoc_item_name: NameToImport::Fuzzy(fuzzy_method_name),\n             }),\n             module_with_candidate: module_with_method_call,\n+            candidate_node,\n         })\n     }\n }\n \n+/// An import (not necessary the only one) that corresponds a certain given [`PathImportCandidate`].\n+/// (the structure is not entirely correct, since there can be situations requiring two imports, see FIXME below for the details)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct LocatedImport {\n+    /// The path to use in the `use` statement for a given candidate to be imported.\n+    pub import_path: ModPath,\n+    /// An item that will be imported with the import path given.\n+    pub item_to_import: ItemInNs,\n+    /// The path import candidate, resolved.\n+    ///\n+    /// Not necessary matches the import:\n+    /// For any associated constant from the trait, we try to access as `some::path::SomeStruct::ASSOC_`\n+    /// the original item is the associated constant, but the import has to be a trait that\n+    /// defines this constant.\n+    pub original_item: ItemInNs,\n+    /// A path of the original item.\n+    pub original_path: Option<ModPath>,\n+}\n+\n+impl LocatedImport {\n+    pub fn new(\n+        import_path: ModPath,\n+        item_to_import: ItemInNs,\n+        original_item: ItemInNs,\n+        original_path: Option<ModPath>,\n+    ) -> Self {\n+        Self { import_path, item_to_import, original_item, original_path }\n+    }\n+}\n+\n impl ImportAssets {\n     pub fn import_candidate(&self) -> &ImportCandidate {\n         &self.import_candidate\n     }\n \n-    fn name_to_import(&self) -> &NameToImport {\n-        match &self.import_candidate {\n-            ImportCandidate::Path(candidate) => &candidate.name,\n-            ImportCandidate::TraitAssocItem(candidate)\n-            | ImportCandidate::TraitMethod(candidate) => &candidate.name,\n-        }\n-    }\n-\n     pub fn search_for_imports(\n         &self,\n         sema: &Semantics<RootDatabase>,\n         prefix_kind: PrefixKind,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n+    ) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_imports\");\n         self.search_for(sema, Some(prefix_kind))\n     }\n \n     /// This may return non-absolute paths if a part of the returned path is already imported into scope.\n-    pub fn search_for_relative_paths(\n-        &self,\n-        sema: &Semantics<RootDatabase>,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n+    pub fn search_for_relative_paths(&self, sema: &Semantics<RootDatabase>) -> Vec<LocatedImport> {\n         let _p = profile::span(\"import_assets::search_for_relative_paths\");\n         self.search_for(sema, None)\n     }\n \n     fn search_for(\n         &self,\n         sema: &Semantics<RootDatabase>,\n-        prefixed: Option<hir::PrefixKind>,\n-    ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n-        let current_crate = self.module_with_candidate.krate();\n-\n-        let unfiltered_imports = match self.name_to_import() {\n-            NameToImport::Exact(exact_name) => {\n-                imports_locator::find_exact_imports(sema, current_crate, exact_name.clone())\n-            }\n+        prefixed: Option<PrefixKind>,\n+    ) -> Vec<LocatedImport> {\n+        let items_with_candidate_name = match self.name_to_import() {\n+            NameToImport::Exact(exact_name) => items_locator::with_exact_name(\n+                sema,\n+                self.module_with_candidate.krate(),\n+                exact_name.clone(),\n+            ),\n             // FIXME: ideally, we should avoid using `fst` for seacrhing trait imports for assoc items:\n             // instead, we need to look up all trait impls for a certain struct and search through them only\n             // see https://github.com/rust-analyzer/rust-analyzer/pull/7293#issuecomment-761585032\n             // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n             // for the details\n             NameToImport::Fuzzy(fuzzy_name) => {\n-                let (assoc_item_search, limit) = match self.import_candidate {\n-                    ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n-                        (AssocItemSearch::AssocItemsOnly, None)\n-                    }\n-                    _ => (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT)),\n+                let (assoc_item_search, limit) = if self.import_candidate.is_trait_candidate() {\n+                    (AssocItemSearch::AssocItemsOnly, None)\n+                } else {\n+                    (AssocItemSearch::Include, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n                 };\n-                imports_locator::find_similar_imports(\n+\n+                items_locator::with_similar_name(\n                     sema,\n-                    current_crate,\n+                    self.module_with_candidate.krate(),\n                     fuzzy_name.clone(),\n                     assoc_item_search,\n                     limit,\n                 )\n             }\n         };\n \n-        let db = sema.db;\n-        let mut res =\n-            applicable_defs(self.import_candidate(), current_crate, db, unfiltered_imports)\n-                .filter_map(|candidate| {\n-                    let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n-\n-                    let item_to_search = match self.import_candidate {\n-                        ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_) => {\n-                            let canidate_trait = match candidate {\n-                                Either::Left(module_def) => {\n-                                    module_def.as_assoc_item(db)?.containing_trait(db)\n-                                }\n-                                _ => None,\n-                            }?;\n-                            ModuleDef::from(canidate_trait).into()\n-                        }\n-                        _ => item,\n-                    };\n-\n-                    if let Some(prefix_kind) = prefixed {\n-                        self.module_with_candidate.find_use_path_prefixed(\n-                            db,\n-                            item_to_search,\n-                            prefix_kind,\n-                        )\n-                    } else {\n-                        self.module_with_candidate.find_use_path(db, item_to_search)\n-                    }\n-                    .map(|path| (path, item))\n-                })\n-                .filter(|(use_path, _)| use_path.len() > 1)\n-                .collect::<Vec<_>>();\n-        res.sort_by_cached_key(|(path, _)| path.clone());\n-        res\n+        let scope_definitions = self.scope_definitions(sema);\n+        self.applicable_defs(sema.db, prefixed, items_with_candidate_name)\n+            .into_iter()\n+            .filter(|import| import.import_path.len() > 1)\n+            .filter(|import| !scope_definitions.contains(&ScopeDef::from(import.item_to_import)))\n+            .sorted_by_key(|import| import.import_path.clone())\n+            .collect()\n+    }\n+\n+    fn scope_definitions(&self, sema: &Semantics<RootDatabase>) -> FxHashSet<ScopeDef> {\n+        let mut scope_definitions = FxHashSet::default();\n+        sema.scope(&self.candidate_node).process_all_names(&mut |_, scope_def| {\n+            scope_definitions.insert(scope_def);\n+        });\n+        scope_definitions\n+    }\n+\n+    fn name_to_import(&self) -> &NameToImport {\n+        match &self.import_candidate {\n+            ImportCandidate::Path(candidate) => &candidate.name,\n+            ImportCandidate::TraitAssocItem(candidate)\n+            | ImportCandidate::TraitMethod(candidate) => &candidate.assoc_item_name,\n+        }\n+    }\n+\n+    fn applicable_defs(\n+        &self,\n+        db: &RootDatabase,\n+        prefixed: Option<PrefixKind>,\n+        items_with_candidate_name: FxHashSet<ItemInNs>,\n+    ) -> FxHashSet<LocatedImport> {\n+        let _p = profile::span(\"import_assets::applicable_defs\");\n+        let current_crate = self.module_with_candidate.krate();\n+\n+        let mod_path = |item| {\n+            get_mod_path(db, item_for_path_search(db, item)?, &self.module_with_candidate, prefixed)\n+        };\n+\n+        match &self.import_candidate {\n+            ImportCandidate::Path(path_candidate) => {\n+                path_applicable_imports(db, path_candidate, mod_path, items_with_candidate_name)\n+            }\n+            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_items(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                true,\n+                mod_path,\n+                items_with_candidate_name,\n+            ),\n+            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_items(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                false,\n+                mod_path,\n+                items_with_candidate_name,\n+            ),\n+        }\n     }\n }\n \n-fn applicable_defs<'a>(\n-    import_candidate: &ImportCandidate,\n-    current_crate: Crate,\n+fn path_applicable_imports(\n     db: &RootDatabase,\n-    unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n-    let receiver_ty = match import_candidate {\n-        ImportCandidate::Path(_) => return unfiltered_imports,\n-        ImportCandidate::TraitAssocItem(candidate) | ImportCandidate::TraitMethod(candidate) => {\n-            &candidate.receiver_ty\n+    path_candidate: &PathImportCandidate,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath> + Copy,\n+    items_with_candidate_name: FxHashSet<ItemInNs>,\n+) -> FxHashSet<LocatedImport> {\n+    let _p = profile::span(\"import_assets::path_applicable_imports\");\n+\n+    let (unresolved_first_segment, unresolved_qualifier) = match &path_candidate.qualifier {\n+        None => {\n+            return items_with_candidate_name\n+                .into_iter()\n+                .filter_map(|item| {\n+                    Some(LocatedImport::new(mod_path(item)?, item, item, mod_path(item)))\n+                })\n+                .collect();\n         }\n+        Some(first_segment_unresolved) => (\n+            first_segment_unresolved.fist_segment.to_string(),\n+            path_to_string_stripping_turbo_fish(&first_segment_unresolved.full_qualifier),\n+        ),\n     };\n \n+    items_with_candidate_name\n+        .into_iter()\n+        .filter_map(|item| {\n+            import_for_item(db, mod_path, &unresolved_first_segment, &unresolved_qualifier, item)\n+        })\n+        .collect()\n+}\n+\n+fn import_for_item(\n+    db: &RootDatabase,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n+    unresolved_first_segment: &str,\n+    unresolved_qualifier: &str,\n+    original_item: ItemInNs,\n+) -> Option<LocatedImport> {\n+    let _p = profile::span(\"import_assets::import_for_item\");\n+\n+    let original_item_candidate = item_for_path_search(db, original_item)?;\n+    let import_path_candidate = mod_path(original_item_candidate)?;\n+    let import_path_string = import_path_candidate.to_string();\n+\n+    let expected_import_end = if item_as_assoc(db, original_item).is_some() {\n+        unresolved_qualifier.to_string()\n+    } else {\n+        format!(\"{}::{}\", unresolved_qualifier, item_name(db, original_item)?)\n+    };\n+    if !import_path_string.contains(unresolved_first_segment)\n+        || !import_path_string.ends_with(&expected_import_end)\n+    {\n+        return None;\n+    }\n+\n+    let segment_import =\n+        find_import_for_segment(db, original_item_candidate, &unresolved_first_segment)?;\n+    let trait_item_to_import = item_as_assoc(db, original_item)\n+        .and_then(|assoc| assoc.containing_trait(db))\n+        .map(|trait_| ItemInNs::from(ModuleDef::from(trait_)));\n+    Some(match (segment_import == original_item_candidate, trait_item_to_import) {\n+        (true, Some(_)) => {\n+            // FIXME we should be able to import both the trait and the segment,\n+            // but it's unclear what to do with overlapping edits (merge imports?)\n+            // especially in case of lazy completion edit resolutions.\n+            return None;\n+        }\n+        (false, Some(trait_to_import)) => LocatedImport::new(\n+            mod_path(trait_to_import)?,\n+            trait_to_import,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+        (true, None) => LocatedImport::new(\n+            import_path_candidate,\n+            original_item_candidate,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+        (false, None) => LocatedImport::new(\n+            mod_path(segment_import)?,\n+            segment_import,\n+            original_item,\n+            mod_path(original_item),\n+        ),\n+    })\n+}\n+\n+fn item_for_path_search(db: &RootDatabase, item: ItemInNs) -> Option<ItemInNs> {\n+    Some(match item {\n+        ItemInNs::Types(_) | ItemInNs::Values(_) => match item_as_assoc(db, item) {\n+            Some(assoc_item) => match assoc_item.container(db) {\n+                AssocItemContainer::Trait(trait_) => ItemInNs::from(ModuleDef::from(trait_)),\n+                AssocItemContainer::Impl(impl_) => {\n+                    ItemInNs::from(ModuleDef::from(impl_.target_ty(db).as_adt()?))\n+                }\n+            },\n+            None => item,\n+        },\n+        ItemInNs::Macros(_) => item,\n+    })\n+}\n+\n+fn find_import_for_segment(\n+    db: &RootDatabase,\n+    original_item: ItemInNs,\n+    unresolved_first_segment: &str,\n+) -> Option<ItemInNs> {\n+    let segment_is_name = item_name(db, original_item)\n+        .map(|name| name.to_string() == unresolved_first_segment)\n+        .unwrap_or(false);\n+\n+    Some(if segment_is_name {\n+        original_item\n+    } else {\n+        let matching_module =\n+            module_with_segment_name(db, &unresolved_first_segment, original_item)?;\n+        ItemInNs::from(ModuleDef::from(matching_module))\n+    })\n+}\n+\n+fn module_with_segment_name(\n+    db: &RootDatabase,\n+    segment_name: &str,\n+    candidate: ItemInNs,\n+) -> Option<Module> {\n+    let mut current_module = match candidate {\n+        ItemInNs::Types(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Values(module_def_id) => ModuleDef::from(module_def_id).module(db),\n+        ItemInNs::Macros(macro_def_id) => MacroDef::from(macro_def_id).module(db),\n+    };\n+    while let Some(module) = current_module {\n+        if let Some(module_name) = module.name(db) {\n+            if module_name.to_string() == segment_name {\n+                return Some(module);\n+            }\n+        }\n+        current_module = module.parent(db);\n+    }\n+    None\n+}\n+\n+fn trait_applicable_items(\n+    db: &RootDatabase,\n+    current_crate: Crate,\n+    trait_candidate: &TraitImportCandidate,\n+    trait_assoc_item: bool,\n+    mod_path: impl Fn(ItemInNs) -> Option<ModPath>,\n+    items_with_candidate_name: FxHashSet<ItemInNs>,\n+) -> FxHashSet<LocatedImport> {\n+    let _p = profile::span(\"import_assets::trait_applicable_items\");\n     let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = unfiltered_imports\n-        .filter_map(|input| match input {\n-            Either::Left(module_def) => module_def.as_assoc_item(db),\n-            _ => None,\n-        })\n+    let trait_candidates = items_with_candidate_name\n+        .into_iter()\n+        .filter_map(|input| item_as_assoc(db, input))\n         .filter_map(|assoc| {\n             let assoc_item_trait = assoc.containing_trait(db)?;\n             required_assoc_items.insert(assoc);\n             Some(assoc_item_trait.into())\n         })\n         .collect();\n \n-    let mut applicable_defs = FxHashSet::default();\n+    let mut located_imports = FxHashSet::default();\n \n-    match import_candidate {\n-        ImportCandidate::Path(_) => unreachable!(),\n-        ImportCandidate::TraitAssocItem(_) => receiver_ty.iterate_path_candidates(\n+    if trait_assoc_item {\n+        trait_candidate.receiver_ty.iterate_path_candidates(\n             db,\n             current_crate,\n             &trait_candidates,\n@@ -276,34 +469,63 @@ fn applicable_defs<'a>(\n                             return None;\n                         }\n                     }\n-                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+\n+                    let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let original_item = assoc_to_item(assoc);\n+                    located_imports.insert(LocatedImport::new(\n+                        mod_path(item)?,\n+                        item,\n+                        original_item,\n+                        mod_path(original_item),\n+                    ));\n                 }\n                 None::<()>\n             },\n-        ),\n-        ImportCandidate::TraitMethod(_) => receiver_ty.iterate_method_candidates(\n+        )\n+    } else {\n+        trait_candidate.receiver_ty.iterate_method_candidates(\n             db,\n             current_crate,\n             &trait_candidates,\n             None,\n             |_, function| {\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n-                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                    let item = ItemInNs::from(ModuleDef::from(assoc.containing_trait(db)?));\n+                    let original_item = assoc_to_item(assoc);\n+                    located_imports.insert(LocatedImport::new(\n+                        mod_path(item)?,\n+                        item,\n+                        original_item,\n+                        mod_path(original_item),\n+                    ));\n                 }\n                 None::<()>\n             },\n-        ),\n+        )\n     };\n \n-    Box::new(applicable_defs.into_iter())\n+    located_imports\n }\n \n-fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {\n+fn assoc_to_item(assoc: AssocItem) -> ItemInNs {\n     match assoc {\n-        AssocItem::Function(f) => f.into(),\n-        AssocItem::Const(c) => c.into(),\n-        AssocItem::TypeAlias(t) => t.into(),\n+        AssocItem::Function(f) => ItemInNs::from(ModuleDef::from(f)),\n+        AssocItem::Const(c) => ItemInNs::from(ModuleDef::from(c)),\n+        AssocItem::TypeAlias(t) => ItemInNs::from(ModuleDef::from(t)),\n+    }\n+}\n+\n+fn get_mod_path(\n+    db: &RootDatabase,\n+    item_to_search: ItemInNs,\n+    module_with_candidate: &Module,\n+    prefixed: Option<PrefixKind>,\n+) -> Option<ModPath> {\n+    if let Some(prefix_kind) = prefixed {\n+        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind)\n+    } else {\n+        module_with_candidate.find_use_path(db, item_to_search)\n     }\n }\n \n@@ -316,7 +538,7 @@ impl ImportCandidate {\n             Some(_) => None,\n             None => Some(Self::TraitMethod(TraitImportCandidate {\n                 receiver_ty: sema.type_of_expr(&method_call.receiver()?)?,\n-                name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n+                assoc_item_name: NameToImport::Exact(method_call.name_ref()?.to_string()),\n             })),\n         }\n     }\n@@ -325,41 +547,63 @@ impl ImportCandidate {\n         if sema.resolve_path(path).is_some() {\n             return None;\n         }\n+        path_import_candidate(\n+            sema,\n+            path.qualifier(),\n+            NameToImport::Exact(path.segment()?.name_ref()?.to_string()),\n+        )\n+    }\n \n-        let segment = path.segment()?;\n-        let candidate = if let Some(qualifier) = path.qualifier() {\n-            let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n-            let qualifier_start_path =\n-                qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n-            if let Some(qualifier_start_resolution) = sema.resolve_path(&qualifier_start_path) {\n-                let qualifier_resolution = if qualifier_start_path == qualifier {\n-                    qualifier_start_resolution\n+    fn for_fuzzy_path(\n+        qualifier: Option<ast::Path>,\n+        fuzzy_name: String,\n+        sema: &Semantics<RootDatabase>,\n+    ) -> Option<Self> {\n+        path_import_candidate(sema, qualifier, NameToImport::Fuzzy(fuzzy_name))\n+    }\n+\n+    fn is_trait_candidate(&self) -> bool {\n+        matches!(self, ImportCandidate::TraitAssocItem(_) | ImportCandidate::TraitMethod(_))\n+    }\n+}\n+\n+fn path_import_candidate(\n+    sema: &Semantics<RootDatabase>,\n+    qualifier: Option<ast::Path>,\n+    name: NameToImport,\n+) -> Option<ImportCandidate> {\n+    Some(match qualifier {\n+        Some(qualifier) => match sema.resolve_path(&qualifier) {\n+            None => {\n+                let qualifier_start =\n+                    qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+                let qualifier_start_path =\n+                    qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+                if sema.resolve_path(&qualifier_start_path).is_none() {\n+                    ImportCandidate::Path(PathImportCandidate {\n+                        qualifier: Some(FirstSegmentUnresolved {\n+                            fist_segment: qualifier_start,\n+                            full_qualifier: qualifier,\n+                        }),\n+                        name,\n+                    })\n                 } else {\n-                    sema.resolve_path(&qualifier)?\n-                };\n-                match qualifier_resolution {\n-                    hir::PathResolution::Def(hir::ModuleDef::Adt(assoc_item_path)) => {\n-                        ImportCandidate::TraitAssocItem(TraitImportCandidate {\n-                            receiver_ty: assoc_item_path.ty(sema.db),\n-                            name: NameToImport::Exact(segment.name_ref()?.to_string()),\n-                        })\n-                    }\n-                    _ => return None,\n+                    return None;\n                 }\n-            } else {\n-                ImportCandidate::Path(PathImportCandidate {\n-                    qualifier: Some(qualifier),\n-                    name: NameToImport::Exact(qualifier_start.to_string()),\n+            }\n+            Some(PathResolution::Def(ModuleDef::Adt(assoc_item_path))) => {\n+                ImportCandidate::TraitAssocItem(TraitImportCandidate {\n+                    receiver_ty: assoc_item_path.ty(sema.db),\n+                    assoc_item_name: name,\n                 })\n             }\n-        } else {\n-            ImportCandidate::Path(PathImportCandidate {\n-                qualifier: None,\n-                name: NameToImport::Exact(\n-                    segment.syntax().descendants().find_map(ast::NameRef::cast)?.to_string(),\n-                ),\n-            })\n-        };\n-        Some(candidate)\n-    }\n+            Some(_) => return None,\n+        },\n+        None => ImportCandidate::Path(PathImportCandidate { qualifier: None, name }),\n+    })\n+}\n+\n+fn item_as_assoc(db: &RootDatabase, item: ItemInNs) -> Option<AssocItem> {\n+    item.as_module_def_id()\n+        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n }"}, {"sha": "8a7f029353745ce72147231acb7a7147ded3dc4e", "filename": "crates/ide_db/src/items_locator.rs", "status": "renamed", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Fitems_locator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fitems_locator.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -1,9 +1,10 @@\n //! This module contains an import search functionality that is provided to the assists module.\n //! Later, this should be moved away to a separate crate that is accessible from the assists module.\n \n+use either::Either;\n use hir::{\n     import_map::{self, ImportKind},\n-    AsAssocItem, Crate, MacroDef, ModuleDef, Semantics,\n+    AsAssocItem, Crate, ItemInNs, ModuleDef, Semantics,\n };\n use syntax::{ast, AstNode, SyntaxKind::NAME};\n \n@@ -12,47 +13,47 @@ use crate::{\n     symbol_index::{self, FileSymbol},\n     RootDatabase,\n };\n-use either::Either;\n use rustc_hash::FxHashSet;\n \n pub(crate) const DEFAULT_QUERY_SEARCH_LIMIT: usize = 40;\n \n-pub fn find_exact_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+pub fn with_exact_name(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n-    name_to_import: String,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>>> {\n+    exact_name: String,\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_exact_imports\");\n-    Box::new(find_imports(\n+    find_items(\n         sema,\n         krate,\n         {\n-            let mut local_query = symbol_index::Query::new(name_to_import.clone());\n+            let mut local_query = symbol_index::Query::new(exact_name.clone());\n             local_query.exact();\n             local_query.limit(DEFAULT_QUERY_SEARCH_LIMIT);\n             local_query\n         },\n-        import_map::Query::new(name_to_import)\n+        import_map::Query::new(exact_name)\n             .limit(DEFAULT_QUERY_SEARCH_LIMIT)\n             .name_only()\n             .search_mode(import_map::SearchMode::Equals)\n             .case_sensitive(),\n-    ))\n+    )\n }\n \n+#[derive(Debug)]\n pub enum AssocItemSearch {\n     Include,\n     Exclude,\n     AssocItemsOnly,\n }\n \n-pub fn find_similar_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+pub fn with_similar_name(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n     fuzzy_search_string: String,\n     assoc_item_search: AssocItemSearch,\n     limit: Option<usize>,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_similar_imports\");\n \n     let mut external_query = import_map::Query::new(fuzzy_search_string.clone())\n@@ -76,57 +77,59 @@ pub fn find_similar_imports<'a>(\n         local_query.limit(limit);\n     }\n \n-    let db = sema.db;\n-    Box::new(find_imports(sema, krate, local_query, external_query).filter(\n-        move |import_candidate| match assoc_item_search {\n+    find_items(sema, krate, local_query, external_query)\n+        .into_iter()\n+        .filter(move |&item| match assoc_item_search {\n             AssocItemSearch::Include => true,\n-            AssocItemSearch::Exclude => !is_assoc_item(import_candidate, db),\n-            AssocItemSearch::AssocItemsOnly => is_assoc_item(import_candidate, db),\n-        },\n-    ))\n+            AssocItemSearch::Exclude => !is_assoc_item(item, sema.db),\n+            AssocItemSearch::AssocItemsOnly => is_assoc_item(item, sema.db),\n+        })\n+        .collect()\n }\n \n-fn is_assoc_item(import_candidate: &Either<ModuleDef, MacroDef>, db: &RootDatabase) -> bool {\n-    match import_candidate {\n-        Either::Left(ModuleDef::Function(function)) => function.as_assoc_item(db).is_some(),\n-        Either::Left(ModuleDef::Const(const_)) => const_.as_assoc_item(db).is_some(),\n-        Either::Left(ModuleDef::TypeAlias(type_alias)) => type_alias.as_assoc_item(db).is_some(),\n-        _ => false,\n-    }\n+fn is_assoc_item(item: ItemInNs, db: &RootDatabase) -> bool {\n+    item.as_module_def_id()\n+        .and_then(|module_def_id| ModuleDef::from(module_def_id).as_assoc_item(db))\n+        .is_some()\n }\n \n-fn find_imports<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+fn find_items(\n+    sema: &Semantics<'_, RootDatabase>,\n     krate: Crate,\n     local_query: symbol_index::Query,\n     external_query: import_map::Query,\n-) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+) -> FxHashSet<ItemInNs> {\n     let _p = profile::span(\"find_similar_imports\");\n     let db = sema.db;\n \n     // Query dependencies first.\n-    let mut candidates: FxHashSet<_> =\n-        krate.query_external_importables(db, external_query).collect();\n+    let mut candidates = krate\n+        .query_external_importables(db, external_query)\n+        .map(|external_importable| match external_importable {\n+            Either::Left(module_def) => ItemInNs::from(module_def),\n+            Either::Right(macro_def) => ItemInNs::from(macro_def),\n+        })\n+        .collect::<FxHashSet<_>>();\n \n     // Query the local crate using the symbol index.\n     let local_results = symbol_index::crate_symbols(db, krate.into(), local_query);\n \n     candidates.extend(\n         local_results\n             .into_iter()\n-            .filter_map(|import_candidate| get_name_definition(sema, &import_candidate))\n+            .filter_map(|local_candidate| get_name_definition(sema, &local_candidate))\n             .filter_map(|name_definition_to_import| match name_definition_to_import {\n-                Definition::ModuleDef(module_def) => Some(Either::Left(module_def)),\n-                Definition::Macro(macro_def) => Some(Either::Right(macro_def)),\n+                Definition::ModuleDef(module_def) => Some(ItemInNs::from(module_def)),\n+                Definition::Macro(macro_def) => Some(ItemInNs::from(macro_def)),\n                 _ => None,\n             }),\n     );\n \n-    candidates.into_iter()\n+    candidates\n }\n \n-fn get_name_definition<'a>(\n-    sema: &Semantics<'a, RootDatabase>,\n+fn get_name_definition(\n+    sema: &Semantics<'_, RootDatabase>,\n     import_candidate: &FileSymbol,\n ) -> Option<Definition> {\n     let _p = profile::span(\"get_name_definition\");", "previous_filename": "crates/ide_db/src/imports_locator.rs"}, {"sha": "88ee4a87d51c4b9019a9270ee5ef841aea153481", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -8,7 +8,7 @@ pub mod line_index;\n pub mod symbol_index;\n pub mod defs;\n pub mod search;\n-pub mod imports_locator;\n+pub mod items_locator;\n pub mod source_change;\n pub mod ty_filter;\n pub mod traits;"}, {"sha": "2c4c339cb73152f06db3bdefb6e5c53f3abd62fa", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -697,7 +697,6 @@ pub(crate) fn handle_completion_resolve(\n             FilePosition { file_id, offset },\n             &resolve_data.full_import_path,\n             resolve_data.imported_name,\n-            resolve_data.import_for_trait_assoc_item,\n         )?\n         .into_iter()\n         .flat_map(|edit| edit.into_iter().map(|indel| to_proto::text_edit(&line_index, indel)))\n@@ -1525,7 +1524,6 @@ struct CompletionResolveData {\n     position: lsp_types::TextDocumentPositionParams,\n     full_import_path: String,\n     imported_name: String,\n-    import_for_trait_assoc_item: bool,\n }\n \n fn fill_resolve_data(\n@@ -1534,15 +1532,13 @@ fn fill_resolve_data(\n     position: &TextDocumentPositionParams,\n ) -> Option<()> {\n     let import_edit = item.import_to_add()?;\n-    let full_import_path = import_edit.import_path.to_string();\n-    let imported_name = import_edit.import_path.segments().last()?.to_string();\n+    let import_path = &import_edit.import.import_path;\n \n     *resolve_data = Some(\n         to_value(CompletionResolveData {\n             position: position.to_owned(),\n-            full_import_path,\n-            imported_name,\n-            import_for_trait_assoc_item: import_edit.import_for_trait_assoc_item,\n+            full_import_path: import_path.to_string(),\n+            imported_name: import_path.segments().last()?.to_string(),\n         })\n         .unwrap(),\n     );"}, {"sha": "33bde099bcc11cbcb9f8526447144af3043823f7", "filename": "crates/syntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2FCargo.toml?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -25,10 +25,10 @@ serde = { version = \"1.0.106\", features = [\"derive\"] }\n stdx = { path = \"../stdx\", version = \"0.0.0\" }\n text_edit = { path = \"../text_edit\", version = \"0.0.0\" }\n parser = { path = \"../parser\", version = \"0.0.0\" }\n-test_utils = { path = \"../test_utils\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n \n [dev-dependencies]\n+test_utils = { path = \"../test_utils\" }\n walkdir = \"2.3.1\"\n rayon = \"1\"\n expect-test = \"1.1\""}, {"sha": "70ba8adb487d4d3acb384df8a1df54a36cdcf43d", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -91,6 +91,10 @@ pub fn path_from_segments(\n     })\n }\n \n+pub fn path_from_text(text: &str) -> ast::Path {\n+    ast_from_text(&format!(\"fn main() {{ let test = {}; }}\", text))\n+}\n+\n pub fn glob_use_tree() -> ast::UseTree {\n     ast_from_text(\"use *;\")\n }"}, {"sha": "09e212e8c03aa90be8c771be84489d2172687716", "filename": "crates/syntax/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Flib.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -37,6 +37,7 @@ pub mod algo;\n pub mod ast;\n #[doc(hidden)]\n pub mod fuzz;\n+pub mod utils;\n \n use std::{marker::PhantomData, sync::Arc};\n "}, {"sha": "f4c02518b4c76a2ed708bac285872018bc2cc507", "filename": "crates/syntax/src/utils.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21913d0fdb848445a908021dbcd4c3accf2ca0a5/crates%2Fsyntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Futils.rs?ref=21913d0fdb848445a908021dbcd4c3accf2ca0a5", "patch": "@@ -0,0 +1,43 @@\n+//! A set of utils methods to reuse on other abstraction levels\n+\n+use itertools::Itertools;\n+\n+use crate::{ast, match_ast, AstNode};\n+\n+pub fn path_to_string_stripping_turbo_fish(path: &ast::Path) -> String {\n+    path.syntax()\n+        .children()\n+        .filter_map(|node| {\n+            match_ast! {\n+                match node {\n+                    ast::PathSegment(it) => {\n+                        Some(it.name_ref()?.to_string())\n+                    },\n+                    ast::Path(it) => {\n+                        Some(path_to_string_stripping_turbo_fish(&it))\n+                    },\n+                    _ => None,\n+                }\n+            }\n+        })\n+        .join(\"::\")\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::path_to_string_stripping_turbo_fish;\n+    use crate::ast::make;\n+\n+    #[test]\n+    fn turbofishes_are_stripped() {\n+        assert_eq!(\"Vec\", path_to_string_stripping_turbo_fish(&make::path_from_text(\"Vec::<i32>\")),);\n+        assert_eq!(\n+            \"Vec::new\",\n+            path_to_string_stripping_turbo_fish(&make::path_from_text(\"Vec::<i32>::new\")),\n+        );\n+        assert_eq!(\n+            \"Vec::new\",\n+            path_to_string_stripping_turbo_fish(&make::path_from_text(\"Vec::new()\")),\n+        );\n+    }\n+}"}]}