{"sha": "083c7a93beb2951465732b015afc7deb651a7ce5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4M2M3YTkzYmViMjk1MTQ2NTczMmIwMTVhZmM3ZGViNjUxYTdjZTU=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-06T03:51:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-06T03:51:40Z"}, "message": "Rollup merge of #41011 - CleanCut:bootstrap-help, r=alexcrichton\n\nOverhaul Bootstrap (x.py) Command-Line-Parsing & Help Output\n\nWhile working on #40417, I got frustrated with the behavior of x.py and the bootstrap binary it wraps, so I decided to do something about it.  This PR should improve documentation, make the command-line-parsing more flexible, and clean up some of the internals.  No command that worked before should stop working.  At least that's the theory. :-)\n\nThis should resolve at least #40920 and #38373.\n\nChanges:\n\n- No more manual args manipulation -- getopts used everywhere except the one place it's not possible.  As a result, options can be in any position, now, even before the subcommand.\n- The additional options for test, bench, and dist now appear in the help output.\n- No more single-letter variable bindings used internally for large scopes.\n- Don't output the time measurement when just invoking `x.py` or explicitly passing `-h` or `--help`\n- Logic is now much more linear.  We build strings up, and then print them.\n- Refer to subcommands as subcommands everywhere (some places we were saying \"command\")\n- Other minor stuff.\n\n@alexcrichton This is my first PR. Do I need to do something specific to request reviewers or anything?", "tree": {"sha": "7be5f9a396aef14fdcaf525e1749e85bceedf2f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7be5f9a396aef14fdcaf525e1749e85bceedf2f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/083c7a93beb2951465732b015afc7deb651a7ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/083c7a93beb2951465732b015afc7deb651a7ce5", "html_url": "https://github.com/rust-lang/rust/commit/083c7a93beb2951465732b015afc7deb651a7ce5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/083c7a93beb2951465732b015afc7deb651a7ce5/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a97a9d9d001cd8f0cda9ef4ef5c900ae7a961536", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97a9d9d001cd8f0cda9ef4ef5c900ae7a961536", "html_url": "https://github.com/rust-lang/rust/commit/a97a9d9d001cd8f0cda9ef4ef5c900ae7a961536"}, {"sha": "ea2bfae8694221c92857a0b3dd96f63a8a255db2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2bfae8694221c92857a0b3dd96f63a8a255db2", "html_url": "https://github.com/rust-lang/rust/commit/ea2bfae8694221c92857a0b3dd96f63a8a255db2"}], "stats": {"total": 304, "additions": 165, "deletions": 139}, "files": [{"sha": "0e5991a51bc8092ff7b25730247775cf0561475a", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=083c7a93beb2951465732b015afc7deb651a7ce5", "patch": "@@ -591,16 +591,19 @@ def bootstrap():\n \n def main():\n     start_time = time()\n+    help_triggered = ('-h' in sys.argv) or ('--help' in sys.argv) or (len(sys.argv) == 1)\n     try:\n         bootstrap()\n-        print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n+        if not help_triggered:\n+            print(\"Build completed successfully in %s\" % format_build_time(time() - start_time))\n     except (SystemExit, KeyboardInterrupt) as e:\n         if hasattr(e, 'code') and isinstance(e.code, int):\n             exit_code = e.code\n         else:\n             exit_code = 1\n             print(e)\n-        print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n+        if not help_triggered:\n+            print(\"Build completed unsuccessfully in %s\" % format_build_time(time() - start_time))\n         sys.exit(exit_code)\n \n if __name__ == '__main__':"}, {"sha": "a1466d68a135aa4950b13eb9771c182626c162a8", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 155, "deletions": 131, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=083c7a93beb2951465732b015afc7deb651a7ce5", "patch": "@@ -18,7 +18,7 @@ use std::fs;\n use std::path::PathBuf;\n use std::process;\n \n-use getopts::{Matches, Options};\n+use getopts::Options;\n \n use Build;\n use config::Config;\n@@ -75,7 +75,22 @@ pub enum Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n+        let mut extra_help = String::new();\n+        let mut subcommand_help = format!(\"\\\n+Usage: x.py <subcommand> [options] [<paths>...]\n+\n+Subcommands:\n+    build       Compile either the compiler or libraries\n+    test        Build and run some test suites\n+    bench       Build and run some benchmarks\n+    doc         Build documentation\n+    clean       Clean out build directories\n+    dist        Build and/or install distribution artifacts\n+\n+To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n+\n         let mut opts = Options::new();\n+        // Options common to all subcommands\n         opts.optflagmulti(\"v\", \"verbose\", \"use verbose output (-vv for very verbose)\");\n         opts.optflag(\"i\", \"incremental\", \"use incremental compilation\");\n         opts.optopt(\"\", \"config\", \"TOML configuration file for build\", \"FILE\");\n@@ -89,21 +104,83 @@ impl Flags {\n         opts.optopt(\"j\", \"jobs\", \"number of jobs to run in parallel\", \"JOBS\");\n         opts.optflag(\"h\", \"help\", \"print this help message\");\n \n-        let usage = |n, opts: &Options| -> ! {\n-            let command = args.get(0).map(|s| &**s);\n-            let brief = format!(\"Usage: x.py {} [options] [<args>...]\",\n-                                command.unwrap_or(\"<command>\"));\n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n+\n+        // We can't use getopt to parse the options until we have completed specifying which\n+        // options are valid, but under the current implementation, some options are conditional on\n+        // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n+        // complete the definition of the options.  Then we can use the getopt::Matches object from\n+        // there on out.\n+        let mut possible_subcommands = args.iter().collect::<Vec<_>>();\n+        possible_subcommands.retain(|&s|\n+                                           (s == \"build\")\n+                                        || (s == \"test\")\n+                                        || (s == \"bench\")\n+                                        || (s == \"doc\")\n+                                        || (s == \"clean\")\n+                                        || (s == \"dist\"));\n+        let subcommand = match possible_subcommands.first() {\n+            Some(s) => s,\n+            None => {\n+                // No subcommand -- show the general usage and subcommand help\n+                println!(\"{}\\n\", subcommand_help);\n+                process::exit(0);\n+            }\n+        };\n \n-            println!(\"{}\", opts.usage(&brief));\n-            match command {\n-                Some(\"build\") => {\n-                    println!(\"\\\n+        // Some subcommands get extra options\n+        match subcommand.as_str() {\n+            \"test\"  => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"bench\" => { opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\"); },\n+            \"dist\"  => { opts.optflag(\"\", \"install\", \"run installer as well\"); },\n+            _ => { },\n+        };\n+\n+        // Done specifying what options are possible, so do the getopts parsing\n+        let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n+            // Invalid argument/option format\n+            println!(\"\\n{}\\n\", e);\n+            usage(1, &opts, &subcommand_help, &extra_help);\n+        });\n+        // Extra sanity check to make sure we didn't hit this crazy corner case:\n+        //\n+        //     ./x.py --frobulate clean build\n+        //            ^-- option  ^     ^- actual subcommand\n+        //                        \\_ arg to option could be mistaken as subcommand\n+        let mut pass_sanity_check = true;\n+        match matches.free.get(0) {\n+            Some(check_subcommand) => {\n+                if &check_subcommand != subcommand {\n+                    pass_sanity_check = false;\n+                }\n+            },\n+            None => {\n+                pass_sanity_check = false;\n+            }\n+        }\n+        if !pass_sanity_check {\n+            println!(\"{}\\n\", subcommand_help);\n+            println!(\"Sorry, I couldn't figure out which subcommand you were trying to specify.\\n\\\n+                      You may need to move some options to after the subcommand.\\n\");\n+            process::exit(1);\n+        }\n+        // Extra help text for some commands\n+        match subcommand.as_str() {\n+            \"build\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories to\n-    the crates and/or artifacts to compile. For example:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n \n         ./x.py build src/libcore\n-        ./x.py build src/libproc_macro\n+        ./x.py build src/libcore src/libproc_macro\n         ./x.py build src/libstd --stage 1\n \n     If no arguments are passed then the complete artifacts for that stage are\n@@ -114,15 +191,13 @@ Arguments:\n \n     For a quick build with a usable compile, you can pass:\n \n-        ./x.py build --stage 1 src/libtest\n-\");\n-                }\n-\n-                Some(\"test\") => {\n-                    println!(\"\\\n+        ./x.py build --stage 1 src/libtest\");\n+            }\n+            \"test\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories to\n-    tests that should be compiled and run. For example:\n+    This subcommand accepts a number of paths to directories to tests that\n+    should be compiled and run. For example:\n \n         ./x.py test src/test/run-pass\n         ./x.py test src/libstd --test-args hash_map\n@@ -132,171 +207,120 @@ Arguments:\n     compiled and tested.\n \n         ./x.py test\n-        ./x.py test --stage 1\n-\");\n-                }\n-\n-                Some(\"doc\") => {\n-                    println!(\"\\\n+        ./x.py test --stage 1\");\n+            }\n+            \"doc\" => {\n+                subcommand_help.push_str(\"\\n\n Arguments:\n-    This subcommand accepts a number of positional arguments of directories of\n-    documentation to build. For example:\n+    This subcommand accepts a number of paths to directories of documentation\n+    to build. For example:\n \n         ./x.py doc src/doc/book\n         ./x.py doc src/doc/nomicon\n-        ./x.py doc src/libstd\n+        ./x.py doc src/doc/book src/libstd\n \n     If no arguments are passed then everything is documented:\n \n         ./x.py doc\n-        ./x.py doc --stage 1\n-\");\n-                }\n-\n-                _ => {}\n+        ./x.py doc --stage 1\");\n             }\n-\n-            if let Some(command) = command {\n-                if command == \"build\" ||\n-                   command == \"dist\" ||\n-                   command == \"doc\" ||\n-                   command == \"test\" ||\n-                   command == \"bench\" ||\n-                   command == \"clean\"  {\n-                    println!(\"Available invocations:\");\n-                    if args.iter().any(|a| a == \"-v\") {\n-                        let flags = Flags::parse(&[\"build\".to_string()]);\n-                        let mut config = Config::default();\n-                        config.build = flags.build.clone();\n-                        let mut build = Build::new(flags, config);\n-                        metadata::build(&mut build);\n-                        step::build_rules(&build).print_help(command);\n-                    } else {\n-                        println!(\"    ... elided, run `./x.py {} -h -v` to see\",\n-                                 command);\n-                    }\n-\n-                    println!(\"\");\n-                }\n-            }\n-\n-println!(\"\\\n-Subcommands:\n-    build       Compile either the compiler or libraries\n-    test        Build and run some test suites\n-    bench       Build and run some benchmarks\n-    doc         Build documentation\n-    clean       Clean out build directories\n-    dist        Build and/or install distribution artifacts\n-\n-To learn more about a subcommand, run `./x.py <command> -h`\n-\");\n-\n-            process::exit(n);\n+            _ => { }\n         };\n-        if args.len() == 0 {\n-            println!(\"a command must be passed\");\n-            usage(1, &opts);\n-        }\n-        let parse = |opts: &Options| {\n-            let m = opts.parse(&args[1..]).unwrap_or_else(|e| {\n-                println!(\"failed to parse options: {}\", e);\n-                usage(1, opts);\n-            });\n-            if m.opt_present(\"h\") {\n-                usage(0, opts);\n+        // Get any optional paths which occur after the subcommand\n+        let cwd = t!(env::current_dir());\n+        let paths = matches.free[1..].iter().map(|p| cwd.join(p)).collect::<Vec<_>>();\n+\n+\n+        // All subcommands can have an optional \"Available paths\" section\n+        if matches.opt_present(\"verbose\") {\n+            let flags = Flags::parse(&[\"build\".to_string()]);\n+            let mut config = Config::default();\n+            config.build = flags.build.clone();\n+            let mut build = Build::new(flags, config);\n+            metadata::build(&mut build);\n+            let maybe_rules_help = step::build_rules(&build).get_help(subcommand);\n+            if maybe_rules_help.is_some() {\n+                extra_help.push_str(maybe_rules_help.unwrap().as_str());\n             }\n-            return m\n-        };\n+        } else {\n+            extra_help.push_str(format!(\"Run `./x.py {} -h -v` to see a list of available paths.\",\n+                     subcommand).as_str());\n+        }\n \n-        let cwd = t!(env::current_dir());\n-        let remaining_as_path = |m: &Matches| {\n-            m.free.iter().map(|p| cwd.join(p)).collect::<Vec<_>>()\n-        };\n+        // User passed in -h/--help?\n+        if matches.opt_present(\"help\") {\n+            usage(0, &opts, &subcommand_help, &extra_help);\n+        }\n \n-        let m: Matches;\n-        let cmd = match &args[0][..] {\n+        let cmd = match subcommand.as_str() {\n             \"build\" => {\n-                m = parse(&opts);\n-                Subcommand::Build { paths: remaining_as_path(&m) }\n-            }\n-            \"doc\" => {\n-                m = parse(&opts);\n-                Subcommand::Doc { paths: remaining_as_path(&m) }\n+                Subcommand::Build { paths: paths }\n             }\n             \"test\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Test {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n             \"bench\" => {\n-                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n-                m = parse(&opts);\n                 Subcommand::Bench {\n-                    paths: remaining_as_path(&m),\n-                    test_args: m.opt_strs(\"test-args\"),\n+                    paths: paths,\n+                    test_args: matches.opt_strs(\"test-args\"),\n                 }\n             }\n+            \"doc\" => {\n+                Subcommand::Doc { paths: paths }\n+            }\n             \"clean\" => {\n-                m = parse(&opts);\n-                if m.free.len() > 0 {\n-                    println!(\"clean takes no arguments\");\n-                    usage(1, &opts);\n+                if paths.len() > 0 {\n+                    println!(\"\\nclean takes no arguments\\n\");\n+                    usage(1, &opts, &subcommand_help, &extra_help);\n                 }\n                 Subcommand::Clean\n             }\n             \"dist\" => {\n-                opts.optflag(\"\", \"install\", \"run installer as well\");\n-                m = parse(&opts);\n                 Subcommand::Dist {\n-                    paths: remaining_as_path(&m),\n-                    install: m.opt_present(\"install\"),\n+                    paths: paths,\n+                    install: matches.opt_present(\"install\"),\n                 }\n             }\n-            \"--help\" => usage(0, &opts),\n-            cmd => {\n-                println!(\"unknown command: {}\", cmd);\n-                usage(1, &opts);\n+            _ => {\n+                usage(1, &opts, &subcommand_help, &extra_help);\n             }\n         };\n \n \n-        let cfg_file = m.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n+        let cfg_file = matches.opt_str(\"config\").map(PathBuf::from).or_else(|| {\n             if fs::metadata(\"config.toml\").is_ok() {\n                 Some(PathBuf::from(\"config.toml\"))\n             } else {\n                 None\n             }\n         });\n \n-        let mut stage = m.opt_str(\"stage\").map(|j| j.parse().unwrap());\n-\n-        let incremental = m.opt_present(\"i\");\n+        let mut stage = matches.opt_str(\"stage\").map(|j| j.parse().unwrap());\n \n-        if incremental {\n+        if matches.opt_present(\"incremental\") {\n             if stage.is_none() {\n                 stage = Some(1);\n             }\n         }\n \n         Flags {\n-            verbose: m.opt_count(\"v\"),\n+            verbose: matches.opt_count(\"verbose\"),\n             stage: stage,\n-            on_fail: m.opt_str(\"on-fail\"),\n-            keep_stage: m.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n-            build: m.opt_str(\"build\").unwrap_or_else(|| {\n+            on_fail: matches.opt_str(\"on-fail\"),\n+            keep_stage: matches.opt_str(\"keep-stage\").map(|j| j.parse().unwrap()),\n+            build: matches.opt_str(\"build\").unwrap_or_else(|| {\n                 env::var(\"BUILD\").unwrap()\n             }),\n-            host: split(m.opt_strs(\"host\")),\n-            target: split(m.opt_strs(\"target\")),\n+            host: split(matches.opt_strs(\"host\")),\n+            target: split(matches.opt_strs(\"target\")),\n             config: cfg_file,\n-            src: m.opt_str(\"src\").map(PathBuf::from),\n-            jobs: m.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n+            src: matches.opt_str(\"src\").map(PathBuf::from),\n+            jobs: matches.opt_str(\"jobs\").map(|j| j.parse().unwrap()),\n             cmd: cmd,\n-            incremental: incremental,\n+            incremental: matches.opt_present(\"incremental\"),\n         }\n     }\n }"}, {"sha": "5560b5b0333c862b3c7b64bb23c00e7fcfb5f6c5", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/083c7a93beb2951465732b015afc7deb651a7ce5/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=083c7a93beb2951465732b015afc7deb651a7ce5", "patch": "@@ -978,26 +978,25 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n-    pub fn print_help(&self, command: &str) {\n+    pub fn get_help(&self, command: &str) -> Option<String> {\n         let kind = match command {\n             \"build\" => Kind::Build,\n             \"doc\" => Kind::Doc,\n             \"test\" => Kind::Test,\n             \"bench\" => Kind::Bench,\n             \"dist\" => Kind::Dist,\n-            _ => return,\n+            _ => return None,\n         };\n         let rules = self.rules.values().filter(|r| r.kind == kind);\n         let rules = rules.filter(|r| !r.path.contains(\"nowhere\"));\n         let mut rules = rules.collect::<Vec<_>>();\n         rules.sort_by_key(|r| r.path);\n \n-        println!(\"Available paths:\\n\");\n+        let mut help_string = String::from(\"Available paths:\\n\");\n         for rule in rules {\n-            print!(\"    ./x.py {} {}\", command, rule.path);\n-\n-            println!(\"\");\n+            help_string.push_str(format!(\"    ./x.py {} {}\\n\", command, rule.path).as_str());\n         }\n+        Some(help_string)\n     }\n \n     /// Construct the top-level build steps that we're going to be executing,"}]}