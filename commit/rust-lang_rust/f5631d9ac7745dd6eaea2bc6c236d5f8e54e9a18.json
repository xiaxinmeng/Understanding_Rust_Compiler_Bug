{"sha": "f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NjMxZDlhYzc3NDVkZDZlYWVhMmJjNmMyMzZkNWY4ZTU0ZTlhMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-24T18:58:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-03-24T18:58:12Z"}, "message": "Auto merge of #49337 - kennytm:rollup, r=kennytm\n\nRollup of 21 pull requests\n\n- Successful merges: #49046, #49076, #49089, #49120, #49121, #49122, #49162, #49193, #49194, #49203, #49229, #49235, #49254, #49268, #49273, #49274, #49290, #49312, #49314, #49318, #49299", "tree": {"sha": "db5927a083fccf48ef3cd9b3b9f5325114a944fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db5927a083fccf48ef3cd9b3b9f5325114a944fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "html_url": "https://github.com/rust-lang/rust/commit/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4aa80dd73df9708022cc383aad8da1dcf38d1df", "url": "https://api.github.com/repos/rust-lang/rust/commits/b4aa80dd73df9708022cc383aad8da1dcf38d1df", "html_url": "https://github.com/rust-lang/rust/commit/b4aa80dd73df9708022cc383aad8da1dcf38d1df"}, {"sha": "297a6e580d4057b665f866e4d37069583d12c8c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/297a6e580d4057b665f866e4d37069583d12c8c2", "html_url": "https://github.com/rust-lang/rust/commit/297a6e580d4057b665f866e4d37069583d12c8c2"}], "stats": {"total": 3539, "additions": 1010, "deletions": 2529}, "files": [{"sha": "9dd3002506e41cbe333d4cc8051dcf9d62071eb7", "filename": "config.toml.example", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -271,6 +271,9 @@\n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n \n+# Build rustc with experimental parallelization\n+#experimental-parallel-queries = false\n+\n # The default linker that will be hard-coded into the generated compiler for\n # targets that don't specify linker explicitly in their target specifications.\n # Note that this is not the linker used to link said compiler."}, {"sha": "371e505e9bed504874101c2e6000853b817efbde", "filename": "src/Cargo.lock", "status": "modified", "additions": 12, "deletions": 102, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,20 +1,3 @@\n-[[package]]\n-name = \"advapi32-sys\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"aho-corasick\"\n-version = \"0.5.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"aho-corasick\"\n version = \"0.6.4\"\n@@ -199,7 +182,7 @@ dependencies = [\n  \"git2-curl 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"glob 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"hex 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"home 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"ignore 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"jobserver 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -587,15 +570,6 @@ dependencies = [\n  \"num-traits 0.1.43 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"env_logger\"\n-version = \"0.3.5\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"env_logger\"\n version = \"0.5.5\"\n@@ -794,14 +768,12 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"home\"\n-version = \"0.3.0\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"userenv-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"winapi 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"winapi 0.3.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -1073,14 +1045,6 @@ dependencies = [\n  \"toml-query 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"memchr\"\n-version = \"0.1.11\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"libc 0.2.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"memchr\"\n version = \"2.0.1\"\n@@ -1339,13 +1303,13 @@ dependencies = [\n \n [[package]]\n name = \"racer\"\n-version = \"2.0.12\"\n+version = \"2.0.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"clap 2.31.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"lazy_static 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"log 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"env_logger 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_errors 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntex_syntax 0.52.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1412,18 +1376,6 @@ version = \"0.1.0\"\n name = \"reformat_with_range\"\n version = \"0.1.0\"\n \n-[[package]]\n-name = \"regex\"\n-version = \"0.1.80\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"regex\"\n version = \"0.2.7\"\n@@ -1436,11 +1388,6 @@ dependencies = [\n  \"utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"regex-syntax\"\n-version = \"0.3.9\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"regex-syntax\"\n version = \"0.5.0\"\n@@ -1481,7 +1428,7 @@ dependencies = [\n  \"lazy_static 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"racer 2.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rayon 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-analysis 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-blacklist 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1545,7 +1492,7 @@ name = \"rls-vfs\"\n version = \"0.4.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"racer 2.0.12 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"racer 2.0.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rls-span 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2114,11 +2061,6 @@ name = \"scoped-tls\"\n version = \"0.1.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"scopeguard\"\n-version = \"0.1.2\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"scopeguard\"\n version = \"0.3.3\"\n@@ -2436,23 +2378,6 @@ dependencies = [\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"thread-id\"\n-version = \"2.0.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"kernel32-sys 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"libc 0.2.39 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n-[[package]]\n-name = \"thread_local\"\n-version = \"0.2.7\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"thread_local\"\n version = \"0.3.5\"\n@@ -2603,11 +2528,6 @@ dependencies = [\n  \"winapi-build 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"utf8-ranges\"\n-version = \"0.1.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"utf8-ranges\"\n version = \"1.0.0\"\n@@ -2700,8 +2620,6 @@ version = \"0.3.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [metadata]\n-\"checksum advapi32-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e06588080cb19d0acb6739808aafa5f26bfb2ca015b2b6370028b44cf7cb8a9a\"\n-\"checksum aho-corasick 0.5.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ca972c2ea5f742bfce5687b9aef75506a764f61d37f8f649047846a9686ddb66\"\n \"checksum aho-corasick 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d6531d44de723825aa81398a6415283229725a00fa30713812ab9323faa82fc4\"\n \"checksum ansi_term 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n \"checksum ar 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"35c7a5669cb64f085739387e1308b74e6d44022464b7f1b63bbd4ceb6379ec31\"\n@@ -2741,7 +2659,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum ena 0.9.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f8b449f3b18c89d2dbe40548d2ee4fa58ea0a08b761992da6ecb9788e4688834\"\n \"checksum endian-type 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c34f04666d835ff5d62e058c3995147c06f42fe86ff053337632bca83e42702d\"\n \"checksum enum_primitive 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"be4551092f4d519593039259a9ed8daedf0da12e5109c5280338073eaeb81180\"\n-\"checksum env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"15abd780e45b3ea4f76b4e9a26ff4843258dd8a3eed2775a0e7368c2e7936c2f\"\n \"checksum env_logger 0.5.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f0628f04f7c26ebccf40d7fc2c1cf92236c05ec88cf2132641cc956812312f0f\"\n \"checksum error-chain 0.11.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ff511d5dc435d703f4971bc399647c9bc38e20cb41452e3b9feb4765419ed3f3\"\n \"checksum failure 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"934799b6c1de475a012a02dab0ace1ace43789ee4b99bcfbf1a2e3e8ced5de82\"\n@@ -2762,7 +2679,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum globset 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1e96ab92362c06811385ae9a34d2698e8a1160745e0c78fbb434a44c8de3fabc\"\n \"checksum handlebars 0.29.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fb04af2006ea09d985fef82b81e0eb25337e51b691c76403332378a53d521edc\"\n \"checksum hex 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"459d3cf58137bb02ad4adeef5036377ff59f066dbb82517b7192e3a5462a2abc\"\n-\"checksum home 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9f25ae61099d8f3fee8b483df0bd4ecccf4b2731897aad40d50eca1b641fe6db\"\n+\"checksum home 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8f94f6fbdc000a6eba0c8cf08632b2091bb59141d36ac321a2a96d6365e5e4dc\"\n \"checksum humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0484fda3e7007f2a4a0d9c3a703ca38c71c54c55602ce4660c419fd32e188c9e\"\n \"checksum idna 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"014b298351066f1512874135335d62a789ffe78a9974f94b43ed5621951eaf7d\"\n \"checksum if_chain 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"61bb90bdd39e3af69b0172dfc6130f6cd6332bf040fbb9bdd4401d37adbd48b8\"\n@@ -2788,7 +2705,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum lzma-sys 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c1b93b78f89e8737dac81837fc8f5521ac162abcba902e1a3db949d55346d1da\"\n \"checksum matches 0.1.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"100aabe6b8ff4e4a7e32c1c13523379802df0772b82466207ac25b013f193376\"\n \"checksum mdbook 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fef236caad7ba3b5b3944df946f19ab3e190bca53c111dd00fe05fa8d879f2fd\"\n-\"checksum memchr 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d8b629fb514376c675b98c1421e80b151d3817ac42d7c667717d282761418d20\"\n \"checksum memchr 2.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"796fba70e76612589ed2ce7f45282f5af869e0fdd7cc6199fa1aa1f1d591ba9d\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\"\n \"checksum miniz-sys 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)\" = \"609ce024854aeb19a0ef7567d348aaa5a746b32fb72e336df7fcc16869d7e2b4\"\n@@ -2817,16 +2733,14 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum quine-mc_cluskey 0.2.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"07589615d719a60c8dd8a4622e7946465dfef20d1a428f969e3443e7386d5f45\"\n \"checksum quote 0.3.15 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7a6e920b65c65f10b2ae65c831a81a073a89edd28c7cce89475bff467ab4167a\"\n \"checksum quote 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1eca14c727ad12702eb4b6bfb5a232287dcf8385cb8ca83a3eeaf6519c44c408\"\n-\"checksum racer 2.0.12 (registry+https://github.com/rust-lang/crates.io-index)\" = \"034f1c4528581c40a60e96875467c03315868084e08ff4ceb46a00f7be3b16b4\"\n+\"checksum racer 2.0.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"40d44bc30fc8d403b665286b2c9a83466ddbf69297668fb02b785c3e58eb8e0d\"\n \"checksum radix_trie 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"211c49b6a9995cac0fd1dd9ca60b42cf3a51e151a12eb954b3a9e75513426ee8\"\n \"checksum rand 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"eba5f8cb59cc50ed56be8880a5c7b496bfd9bd26394e176bc67884094145c2c5\"\n \"checksum rayon 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"485541959c8ecc49865526fe6c4de9653dd6e60d829d6edf0be228167b60372d\"\n \"checksum rayon-core 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9d24ad214285a7729b174ed6d3bcfcb80177807f959d95fafd5bfc5c4f201ac8\"\n \"checksum redox_syscall 0.1.37 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0d92eecebad22b767915e4d529f89f28ee96dbbf5a4810d2b844373f136417fd\"\n \"checksum redox_termios 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7e891cfe48e9100a70a3b6eb652fef28920c117d366339687bd5576160db0f76\"\n-\"checksum regex 0.1.80 (registry+https://github.com/rust-lang/crates.io-index)\" = \"4fd4ace6a8cf7860714a2c2280d6c1f7e6a413486c13298bbc86fd3da019402f\"\n \"checksum regex 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a62bf8bb734ab90b7f234b681b01af396e5d39b028906c210dc04fa1d5e9e5b3\"\n-\"checksum regex-syntax 0.3.9 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f9ec002c35e86791825ed294b50008eea9ddfc8def4420124fbc6b08db834957\"\n \"checksum regex-syntax 0.5.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48d7391e7e90e06eaf3aefbe4652464153ecfec64806f3bf77ffc59638a63e77\"\n \"checksum remove_dir_all 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b5d2f806b0fcdabd98acd380dc8daef485e22bcb7cddc811d1337967f2528cf5\"\n \"checksum rls-analysis 0.11.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fd4b9a3a3f2345854e39768e6425d1c893855da217183d1c0b3ff6f1664b6b6d\"\n@@ -2846,7 +2760,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum same-file 1.0.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cfb6eded0b06a0b512c8ddbcf04089138c9b4362c2f696f3c3d76039d68f3637\"\n \"checksum schannel 0.1.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"fbaffce35eb61c5b00846e73128b0cd62717e7c0ec46abbec132370d013975b4\"\n \"checksum scoped-tls 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8674d439c964889e2476f474a3bf198cc9e199e77499960893bac5de7e9218a4\"\n-\"checksum scopeguard 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"59a076157c1e2dc561d8de585151ee6965d910dd4dcb5dabb7ae3e83981a6c57\"\n \"checksum scopeguard 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"94258f53601af11e6a49f722422f6e3425c52b06245a5cf9bc09908b174f5e27\"\n \"checksum semver 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1d7eb9ef2c18661902cc47e535f9bc51b78acd254da71d375c2f6720d9a40403\"\n \"checksum semver-parser 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"388a1df253eca08550bef6c72392cfe7c30914bf41df5269b68cbd6ff8f570a3\"\n@@ -2875,8 +2788,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum termcolor 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"56c456352e44f9f91f774ddeeed27c1ec60a2455ed66d692059acfb1d731bda1\"\n \"checksum termion 1.5.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"689a3bdfaab439fd92bc87df5c4c78417d3cbe537487274e9b0b2dce76e92096\"\n \"checksum textwrap 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c0b59b6b4b44d867f1370ef1bd91bfb262bf07bf0ae65c202ea2fbc16153b693\"\n-\"checksum thread-id 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a9539db560102d1cef46b8b78ce737ff0bb64e7e18d35b2a5688f7d097d0ff03\"\n-\"checksum thread_local 0.2.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8576dbbfcaef9641452d5cf0df9b0e7eeab7694956dd33bb61515fb8f18cfdd5\"\n \"checksum thread_local 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"279ef31c19ededf577bfd12dfae728040a21f635b06a24cd670ff510edd38963\"\n \"checksum time 0.1.39 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a15375f1df02096fb3317256ce2cee6a1f42fc84ea5ad5fc8c421cfe40c73098\"\n \"checksum toml 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"736b60249cb25337bc196faa43ee12c705e426f3d55c214d73a4e7be06f92cb4\"\n@@ -2894,7 +2805,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum url 1.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"f808aadd8cfec6ef90e4a14eb46f24511824d1ac596b9682703c87056c8678b7\"\n \"checksum url_serde 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n \"checksum userenv-sys 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"71d28ea36bbd9192d75bd9fa9b39f96ddb986eaee824adae5d53b6e51919b2f3\"\n-\"checksum utf8-ranges 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1ca13c08c41c9c3e04224ed9ff80461d97e121589ff27c753a16cb10830ae0f\"\n \"checksum utf8-ranges 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"662fab6525a98beff2921d7f61a39e7d59e0b425ebc7d0d9e66d316e55124122\"\n \"checksum vcpkg 0.2.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9e0a7d8bed3178a8fb112199d466eeca9ed09a14ba8ad67718179b4fd5487d0b\"\n \"checksum vec_map 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"887b5b631c2ad01628bbbaa7dd4c869f80d3186688f8d0b6f58774fbe324988c\""}, {"sha": "eb23236638b13047942fb30fac78730003c515b4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -321,11 +321,13 @@ impl<'a> Builder<'a> {\n                 test::RunMake),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n-                doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n-                doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n-            Kind::Dist => describe!(dist::Docs, dist::Mingw, dist::Rustc, dist::DebuggerScripts,\n-                dist::Std, dist::Analysis, dist::Src, dist::PlainSourceTarball, dist::Cargo,\n-                dist::Rls, dist::Rustfmt, dist::Extended, dist::HashSign),\n+                doc::Standalone, doc::Std, doc::Test, doc::WhitelistedRustc, doc::Rustc,\n+                doc::ErrorIndex, doc::Nomicon, doc::Reference, doc::Rustdoc, doc::RustByExample,\n+                doc::CargoBook),\n+            Kind::Dist => describe!(dist::Docs, dist::RustcDocs, dist::Mingw, dist::Rustc,\n+                dist::DebuggerScripts, dist::Std, dist::Analysis, dist::Src,\n+                dist::PlainSourceTarball, dist::Cargo, dist::Rls, dist::Rustfmt, dist::Extended,\n+                dist::HashSign),\n             Kind::Install => describe!(install::Docs, install::Std, install::Cargo, install::Rls,\n                 install::Rustfmt, install::Analysis, install::Src, install::Rustc),\n         }"}, {"sha": "a9dccea827b6e17434dc0e02b2583b099c903e49", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -40,17 +40,18 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n-\n         let out_dir = build.stage_out(compiler, Mode::Libstd);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n         add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n     }\n@@ -86,19 +87,20 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, build.build);\n         let target = self.target;\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n-\n         let stage_out = builder.stage_out(compiler, Mode::Librustc);\n         build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n         add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n     }\n@@ -128,16 +130,18 @@ impl Step for Test {\n         let target = self.target;\n         let compiler = builder.compiler(0, build.build);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n                   true);\n+\n         let libdir = builder.sysroot_libdir(compiler, target);\n         add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n     }"}, {"sha": "fafa446338189084c0cee7b14a102a6ac756c4cf", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -93,10 +93,6 @@ impl Step for Std {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n-        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n-\n         if target.contains(\"musl\") {\n             let libdir = builder.sysroot_libdir(compiler, target);\n             copy_musl_third_party_objects(build, target, &libdir);\n@@ -106,6 +102,10 @@ impl Step for Std {\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libstd_stamp(build, compiler, target),\n@@ -360,13 +360,14 @@ impl Step for Test {\n             return;\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n-        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target);\n         let out_dir = build.stage_out(compiler, Mode::Libtest);\n         build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n         let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"build\");\n         test_cargo(build, &compiler, target, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n+                &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &libtest_stamp(build, compiler, target),\n@@ -482,16 +483,16 @@ impl Step for Rustc {\n             target: build.build,\n         });\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n-        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n-                 compiler.stage, &compiler.host, target);\n-\n         let stage_out = builder.stage_out(compiler, Mode::Librustc);\n         build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n         build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n \n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"build\");\n         rustc_cargo(build, &mut cargo);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Building stage{} compiler artifacts ({} -> {})\",\n+                 compiler.stage, &compiler.host, target);\n         run_cargo(build,\n                   &mut cargo,\n                   &librustc_stamp(build, compiler, target),\n@@ -634,8 +635,6 @@ impl Step for CodegenBackend {\n             .arg(build.src.join(\"src/librustc_trans/Cargo.toml\"));\n         rustc_cargo_env(build, &mut cargo);\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n-\n         match &*self.backend {\n             \"llvm\" | \"emscripten\" => {\n                 // Build LLVM for our target. This will implicitly build the\n@@ -685,6 +684,8 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = build.cargo_out(compiler, Mode::Librustc, target)\n             .join(\".tmp.stamp\");\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc_trans\", compiler.stage));\n         let files = run_cargo(build,\n                               cargo.arg(\"--features\").arg(features),\n                               &tmp_stamp,"}, {"sha": "a5c373d5d5e7729ad118615fc0395f33641f1e2c", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -44,6 +44,7 @@ def v(*args):\n o(\"docs\", \"build.docs\", \"build standard library documentation\")\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n+o(\"experimental-parallel-queries\", \"rust.experimental-parallel-queries\", \"build rustc with experimental parallelization\")\n o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"quiet-tests\", \"rust.quiet-tests\", \"enable quieter output when running tests\")"}, {"sha": "23b7b265a94bee5690e774586b366b1152d8980e", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 62, "deletions": 8, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -102,7 +102,7 @@ impl Step for Docs {\n \n         let dst = image.join(\"share/doc/rust/html\");\n         t!(fs::create_dir_all(&dst));\n-        let src = build.out.join(host).join(\"doc\");\n+        let src = build.doc_out(host);\n         cp_r(&src, &dst);\n \n         let mut cmd = rust_installer(builder);\n@@ -120,14 +120,69 @@ impl Step for Docs {\n         build.run(&mut cmd);\n         t!(fs::remove_dir_all(&image));\n \n-        // As part of this step, *also* copy the docs directory to a directory which\n-        // buildbot typically uploads.\n-        if host == build.build {\n-            let dst = distdir(build).join(\"doc\").join(build.rust_package_vers());\n-            t!(fs::create_dir_all(&dst));\n-            cp_r(&src, &dst);\n+        distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct RustcDocs {\n+    pub stage: u32,\n+    pub host: Interned<String>,\n+}\n+\n+impl Step for RustcDocs {\n+    type Output = PathBuf;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(RustcDocs {\n+            stage: run.builder.top_stage,\n+            host: run.target,\n+        });\n+    }\n+\n+    /// Builds the `rustc-docs` installer component.\n+    fn run(self, builder: &Builder) -> PathBuf {\n+        let build = builder.build;\n+        let host = self.host;\n+\n+        let name = pkgname(build, \"rustc-docs\");\n+\n+        println!(\"Dist compiler docs ({})\", host);\n+        if !build.config.compiler_docs {\n+            println!(\"\\tskipping - compiler docs disabled\");\n+            return distdir(build).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n+        builder.default_doc(None);\n+\n+        let image = tmpdir(build).join(format!(\"{}-{}-image\", name, host));\n+        let _ = fs::remove_dir_all(&image);\n+\n+        let dst = image.join(\"share/doc/rust/html\");\n+        t!(fs::create_dir_all(&dst));\n+        let src = build.compiler_doc_out(host);\n+        cp_r(&src, &dst);\n+\n+        let mut cmd = rust_installer(builder);\n+        cmd.arg(\"generate\")\n+           .arg(\"--product-name=Rustc-Documentation\")\n+           .arg(\"--rel-manifest-dir=rustlib\")\n+           .arg(\"--success-message=Rustc-documentation-is-installed.\")\n+           .arg(\"--image-dir\").arg(&image)\n+           .arg(\"--work-dir\").arg(&tmpdir(build))\n+           .arg(\"--output-dir\").arg(&distdir(build))\n+           .arg(format!(\"--package-name={}-{}\", name, host))\n+           .arg(\"--component-name=rustc-docs\")\n+           .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n+           .arg(\"--bulk-dirs=share/doc/rust/html\");\n+        build.run(&mut cmd);\n+        t!(fs::remove_dir_all(&image));\n+\n         distdir(build).join(format!(\"{}-{}.tar.gz\", name, host))\n     }\n }\n@@ -1186,7 +1241,6 @@ impl Step for Rustfmt {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        assert!(build.config.extended);\n \n         println!(\"Dist Rustfmt stage{} ({})\", stage, target);\n         let src = build.src.join(\"src/tools/rustfmt\");"}, {"sha": "44073a5b0757237bda2fe96abb1aa873e6432756", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 126, "deletions": 32, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -17,12 +17,13 @@\n //! Everything here is basically just a shim around calling either `rustbook` or\n //! `rustdoc`.\n \n+use std::collections::HashSet;\n use std::fs::{self, File};\n use std::io::prelude::*;\n use std::io;\n use std::path::{PathBuf, Path};\n \n-use Mode;\n+use {Build, Mode};\n use build_helper::up_to_date;\n \n use util::{cp_r, symlink_dir};\n@@ -483,21 +484,17 @@ impl Step for Std {\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"doc\");\n         compile::std_cargo(builder, &compiler, target, &mut cargo);\n \n-        // We don't want to build docs for internal std dependencies unless\n-        // in compiler-docs mode. When not in that mode, we whitelist the crates\n-        // for which docs must be built.\n-        if !build.config.compiler_docs {\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-                // Create all crate output directories first to make sure rustdoc uses\n-                // relative links.\n-                // FIXME: Cargo should probably do this itself.\n-                t!(fs::create_dir_all(out_dir.join(krate)));\n-            }\n+        // Keep a whitelist so we do not build internal stdlib crates, these will be\n+        // build by the rustc step later if enabled.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"alloc\", \"core\", \"std\", \"std_unicode\"] {\n+            cargo.arg(\"-p\").arg(krate);\n+            // Create all crate output directories first to make sure rustdoc uses\n+            // relative links.\n+            // FIXME: Cargo should probably do this itself.\n+            t!(fs::create_dir_all(out_dir.join(krate)));\n         }\n \n-\n         build.run(&mut cargo);\n         cp_r(&my_out, &out);\n     }\n@@ -564,12 +561,12 @@ impl Step for Test {\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Rustc {\n+pub struct WhitelistedRustc {\n     stage: u32,\n     target: Interned<String>,\n }\n \n-impl Step for Rustc {\n+impl Step for WhitelistedRustc {\n     type Output = ();\n     const DEFAULT: bool = true;\n     const ONLY_HOSTS: bool = true;\n@@ -580,21 +577,26 @@ impl Step for Rustc {\n     }\n \n     fn make_run(run: RunConfig) {\n-        run.builder.ensure(Rustc {\n+        run.builder.ensure(WhitelistedRustc {\n             stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n-    /// Generate all compiler documentation.\n+    /// Generate whitelisted compiler crate documentation.\n     ///\n-    /// This will generate all documentation for the compiler libraries and their\n-    /// dependencies. This is largely just a wrapper around `cargo doc`.\n+    /// This will generate all documentation for crates that are whitelisted\n+    /// to be included in the standard documentation. This documentation is\n+    /// included in the standard Rust documentation, so we should always\n+    /// document it and symlink to merge with the rest of the std and test\n+    /// documentation. We don't build other compiler documentation\n+    /// here as we want to be able to keep it separate from the standard\n+    /// documentation. This is largely just a wrapper around `cargo doc`.\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n         let stage = self.stage;\n         let target = self.target;\n-        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        println!(\"Documenting stage{} whitelisted compiler ({})\", stage, target);\n         let out = build.doc_out(target);\n         t!(fs::create_dir_all(&out));\n         let compiler = builder.compiler(stage, build.build);\n@@ -620,24 +622,116 @@ impl Step for Rustc {\n         let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n         compile::rustc_cargo(build, &mut cargo);\n \n-        if build.config.compiler_docs {\n-            // src/rustc/Cargo.toml contains a bin crate called rustc which\n-            // would otherwise overwrite the docs for the real rustc lib crate.\n-            cargo.arg(\"-p\").arg(\"rustc_driver\");\n-        } else {\n-            // Like with libstd above if compiler docs aren't enabled then we're not\n-            // documenting internal dependencies, so we have a whitelist.\n-            cargo.arg(\"--no-deps\");\n-            for krate in &[\"proc_macro\"] {\n-                cargo.arg(\"-p\").arg(krate);\n-            }\n+        // We don't want to build docs for internal compiler dependencies in this\n+        // step (there is another step for that). Therefore, we whitelist the crates\n+        // for which docs must be built.\n+        cargo.arg(\"--no-deps\");\n+        for krate in &[\"proc_macro\"] {\n+            cargo.arg(\"-p\").arg(krate);\n         }\n \n         build.run(&mut cargo);\n         cp_r(&my_out, &out);\n     }\n }\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct Rustc {\n+    stage: u32,\n+    target: Interned<String>,\n+}\n+\n+impl Step for Rustc {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        let builder = run.builder;\n+        run.krate(\"rustc-main\").default_condition(builder.build.config.docs)\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustc {\n+            stage: run.builder.top_stage,\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Generate compiler documentation.\n+    ///\n+    /// This will generate all documentation for compiler and dependencies.\n+    /// Compiler documentation is distributed separately, so we make sure\n+    /// we do not merge it with the other documentation from std, test and\n+    /// proc_macros. This is largely just a wrapper around `cargo doc`.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let stage = self.stage;\n+        let target = self.target;\n+        println!(\"Documenting stage{} compiler ({})\", stage, target);\n+        let out = build.compiler_doc_out(target);\n+        t!(fs::create_dir_all(&out));\n+        let compiler = builder.compiler(stage, build.build);\n+        let rustdoc = builder.rustdoc(compiler.host);\n+        let compiler = if build.force_use_stage1(compiler, target) {\n+            builder.compiler(1, compiler.host)\n+        } else {\n+            compiler\n+        };\n+\n+        if !build.config.compiler_docs {\n+            println!(\"\\tskipping - compiler docs disabled\");\n+            return;\n+        }\n+\n+        // Build libstd docs so that we generate relative links\n+        builder.ensure(Std { stage, target });\n+\n+        builder.ensure(compile::Rustc { compiler, target });\n+        let out_dir = build.stage_out(compiler, Mode::Librustc)\n+                           .join(target).join(\"doc\");\n+        // We do not symlink to the same shared folder that already contains std library\n+        // documentation from previous steps as we do not want to include that.\n+        build.clear_if_dirty(&out, &rustdoc);\n+        t!(symlink_dir_force(&out, &out_dir));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"doc\");\n+        compile::rustc_cargo(build, &mut cargo);\n+\n+        // Only include compiler crates, no dependencies of those, such as `libc`.\n+        cargo.arg(\"--no-deps\");\n+\n+        // Find dependencies for top level crates.\n+        let mut compiler_crates = HashSet::new();\n+        for root_crate in &[\"rustc\", \"rustc_driver\"] {\n+            let interned_root_crate = INTERNER.intern_str(root_crate);\n+            find_compiler_crates(&build, &interned_root_crate, &mut compiler_crates);\n+        }\n+\n+        for krate in &compiler_crates {\n+            cargo.arg(\"-p\").arg(krate);\n+        }\n+\n+        build.run(&mut cargo);\n+    }\n+}\n+\n+fn find_compiler_crates(\n+    build: &Build,\n+    name: &Interned<String>,\n+    crates: &mut HashSet<Interned<String>>\n+) {\n+    // Add current crate.\n+    crates.insert(*name);\n+\n+    // Look for dependencies.\n+    for dep in build.crates.get(name).unwrap().deps.iter() {\n+        if build.crates.get(dep).unwrap().is_local(build) {\n+            find_compiler_crates(build, dep, crates);\n+        }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct ErrorIndex {\n     target: Interned<String>,"}, {"sha": "b2c8ac24d72d8cd752482158d2ada042f8fff929", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -511,6 +511,11 @@ impl Build {\n         self.out.join(&*target).join(\"doc\")\n     }\n \n+    /// Output directory for all documentation for a target\n+    fn compiler_doc_out(&self, target: Interned<String>) -> PathBuf {\n+        self.out.join(&*target).join(\"compiler-doc\")\n+    }\n+\n     /// Output directory for some generated md crate documentation for a target (temporary)\n     fn md_doc_out(&self, target: Interned<String>) -> Interned<PathBuf> {\n         INTERNER.intern_path(self.out.join(&*target).join(\"md-doc\"))"}, {"sha": "76f1a4efbf014f3d240d33c58007dd81a3626672", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -530,8 +530,6 @@ impl Step for Tidy {\n     fn run(self, builder: &Builder) {\n         let build = builder.build;\n \n-        let _folder = build.fold_output(|| \"tidy\");\n-        println!(\"tidy check\");\n         let mut cmd = builder.tool_cmd(Tool::Tidy);\n         cmd.arg(build.src.join(\"src\"));\n         cmd.arg(&build.initial_cargo);\n@@ -541,6 +539,9 @@ impl Step for Tidy {\n         if build.config.quiet_tests {\n             cmd.arg(\"--quiet\");\n         }\n+\n+        let _folder = build.fold_output(|| \"tidy\");\n+        println!(\"tidy check\");\n         try_run(build, &mut cmd);\n     }\n \n@@ -841,9 +842,6 @@ impl Step for Compiletest {\n         builder.ensure(native::TestHelpers { target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n-        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n-                 suite, mode, &compiler.host, target);\n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n \n         // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -1003,6 +1001,9 @@ impl Step for Compiletest {\n \n         build.ci_env.force_coloring_in_ci(&mut cmd);\n \n+        let _folder = build.fold_output(|| format!(\"test_{}\", suite));\n+        println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+                 suite, mode, &compiler.host, target);\n         let _time = util::timeit();\n         try_run(build, &mut cmd);\n     }\n@@ -1147,20 +1148,21 @@ impl Step for ErrorIndex {\n \n         builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        let _folder = build.fold_output(|| \"test_error_index\");\n-        println!(\"Testing error-index stage{}\", compiler.stage);\n-\n         let dir = testdir(build, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let _time = util::timeit();\n-        build.run(builder.tool_cmd(Tool::ErrorIndex)\n-                    .arg(\"markdown\")\n-                    .arg(&output)\n-                    .env(\"CFG_BUILD\", &build.build)\n-                    .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir()));\n+        let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n+        tool.arg(\"markdown\")\n+            .arg(&output)\n+            .env(\"CFG_BUILD\", &build.build)\n+            .env(\"RUSTC_ERROR_METADATA_DST\", build.extended_error_dir());\n+\n \n+        let _folder = build.fold_output(|| \"test_error_index\");\n+        println!(\"Testing error-index stage{}\", compiler.stage);\n+        let _time = util::timeit();\n+        build.run(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n@@ -1405,11 +1407,6 @@ impl Step for Crate {\n             }\n             _ => panic!(\"can only test libraries\"),\n         };\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n-        });\n-        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n-                &compiler.host, target);\n \n         // Build up the base `cargo test` command.\n         //\n@@ -1441,8 +1438,6 @@ impl Step for Crate {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _time = util::timeit();\n-\n         if target.contains(\"emscripten\") {\n             cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target)),\n                       build.config.nodejs.as_ref().expect(\"nodejs not configured\"));\n@@ -1470,6 +1465,13 @@ impl Step for Crate {\n                       format!(\"{} run\",\n                               builder.tool_exe(Tool::RemoteTestClient).display()));\n         }\n+\n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-{}\", test_kind.subcommand(), compiler.stage, krate)\n+        });\n+        println!(\"{} {} stage{} ({} -> {})\", test_kind, krate, compiler.stage,\n+                &compiler.host, target);\n+        let _time = util::timeit();\n         try_run(build, &mut cargo);\n     }\n }\n@@ -1518,12 +1520,6 @@ impl Step for CrateRustdoc {\n                                                  target,\n                                                  test_kind.subcommand(),\n                                                  \"src/tools/rustdoc\");\n-        let _folder = build.fold_output(|| {\n-            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n-        });\n-        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n-                &compiler.host, target);\n-\n         if test_kind.subcommand() == \"test\" && !build.fail_fast {\n             cargo.arg(\"--no-fail-fast\");\n         }\n@@ -1537,6 +1533,11 @@ impl Step for CrateRustdoc {\n             cargo.arg(\"--quiet\");\n         }\n \n+        let _folder = build.fold_output(|| {\n+            format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage)\n+        });\n+        println!(\"{} rustdoc stage{} ({} -> {})\", test_kind, compiler.stage,\n+                &compiler.host, target);\n         let _time = util::timeit();\n \n         try_run(build, &mut cargo);"}, {"sha": "d308cecb2752144e4bf8fc8872595c7c23ef3498", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -112,11 +112,11 @@ impl Step for ToolBuild {\n             Mode::Tool => panic!(\"unexpected Mode::Tool for tool build\")\n         }\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n-        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n-\n         let mut cargo = prepare_tool_cargo(builder, compiler, target, \"build\", path);\n         cargo.arg(\"--features\").arg(self.extra_features.join(\" \"));\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n+        println!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target);\n         let is_expected = build.try_run(&mut cargo);\n         build.save_toolstate(tool, if is_expected {\n             ToolState::TestFail\n@@ -339,9 +339,6 @@ impl Step for Rustdoc {\n \n         builder.ensure(compile::Rustc { compiler: build_compiler, target });\n \n-        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n-        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n-\n         let mut cargo = prepare_tool_cargo(builder,\n                                            build_compiler,\n                                            target,\n@@ -352,7 +349,10 @@ impl Step for Rustdoc {\n         cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n              .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n \n+        let _folder = build.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n+        println!(\"Building rustdoc for stage{} ({})\", target_compiler.stage, target_compiler.host);\n         build.run(&mut cargo);\n+\n         // Cargo adds a number of paths to the dylib search path on windows, which results in\n         // the wrong rustdoc being executed. To avoid the conflicting rustdocs, we name the \"tool\"\n         // rustdoc a different name."}, {"sha": "28c97e8c6dbf9b70987ca9b64c5c49d272add3ea", "filename": "src/ci/docker/dist-x86_64-linux/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2FDockerfile?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -84,7 +84,8 @@ ENV HOSTS=x86_64-unknown-linux-gnu\n ENV RUST_CONFIGURE_ARGS \\\n       --enable-full-tools \\\n       --enable-sanitizers \\\n-      --enable-profiler\n+      --enable-profiler \\\n+      --enable-compiler-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n \n # This is the only builder which will create source tarballs"}, {"sha": "ff6ab1013b4c22352c7ef29673099d5ca2755663", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -16,6 +16,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV PARALLEL_CHECK 1\n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\"}, {"sha": "44eae0d1800472eb9eb16a2a979fbafaf8584a92", "filename": "src/ci/run.sh", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -74,6 +74,13 @@ fi\n # sccache server at the start of the build, but no need to worry if this fails.\n SCCACHE_IDLE_TIMEOUT=10800 sccache --start-server || true\n \n+if [ \"$PARALLEL_CHECK\" != \"\" ]; then\n+  $SRC/configure --enable-experimental-parallel-queries\n+  python2.7 ../x.py check\n+  rm -f config.toml\n+  rm -rf build\n+fi\n+\n travis_fold start configure\n travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS"}, {"sha": "b889e1e30c5e9953834aa9fa6c982bb28df46ac9", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1 +1 @@\n-Subproject commit 98921e9de849acdaeaed08cfad6758bb89769b7d\n+Subproject commit b889e1e30c5e9953834aa9fa6c982bb28df46ac9"}, {"sha": "6a8f0a27e9a58c55c89d07bc43a176fdae5e051c", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1 +1 @@\n-Subproject commit ad5ddd62c098d5b424151beda574ae7df2154df1\n+Subproject commit 6a8f0a27e9a58c55c89d07bc43a176fdae5e051c"}, {"sha": "76296346e97c3702974d3398fdb94af9e10111a2", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1 +1 @@\n-Subproject commit 254df654a9b75abf6ca08806535dbe1fad41be3f\n+Subproject commit 76296346e97c3702974d3398fdb94af9e10111a2"}, {"sha": "d5ec87eabe5733cc2348c7dada89fc67c086f391", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1 +1 @@\n-Subproject commit ebb28c95b2ea68b96eddb9e71aff4d32eacc74f0\n+Subproject commit d5ec87eabe5733cc2348c7dada89fc67c086f391"}, {"sha": "8e888de90a95149ecf786f9b62e8588114623547", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -36,11 +36,11 @@ fn main() {\n         return \"foo\"\n     };\n \n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Yielded(1) => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n-    match generator.resume() {\n+    match unsafe { generator.resume() } {\n         GeneratorState::Complete(\"foo\") => {}\n         _ => panic!(\"unexpected value from resume\"),\n     }\n@@ -69,9 +69,9 @@ fn main() {\n     };\n \n     println!(\"1\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"3\");\n-    generator.resume();\n+    unsafe { generator.resume() };\n     println!(\"5\");\n }\n ```\n@@ -92,7 +92,7 @@ The `Generator` trait in `std::ops` currently looks like:\n pub trait Generator {\n     type Yield;\n     type Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n ```\n \n@@ -175,8 +175,8 @@ fn main() {\n         return ret\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n \n@@ -200,7 +200,7 @@ fn main() {\n             type Yield = i32;\n             type Return = &'static str;\n \n-            fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n+            unsafe fn resume(&mut self) -> GeneratorState<i32, &'static str> {\n                 use std::mem;\n                 match mem::replace(self, __Generator::Done) {\n                     __Generator::Start(s) => {\n@@ -223,8 +223,8 @@ fn main() {\n         __Generator::Start(ret)\n     };\n \n-    generator.resume();\n-    generator.resume();\n+    unsafe { generator.resume() };\n+    unsafe { generator.resume() };\n }\n ```\n "}, {"sha": "bfd806f99e784ef38ab381caaee235b2b4227fd9", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -892,7 +892,7 @@ impl<T> Generator for Box<T>\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }"}, {"sha": "e253122ffd6b69e0dd79282d0f841bb94bd3aae6", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1576,15 +1576,14 @@ impl FromUtf8Error {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(from_utf8_error_as_bytes)]\n     /// // some invalid bytes, in a vector\n     /// let bytes = vec![0, 159];\n     ///\n     /// let value = String::from_utf8(bytes);\n     ///\n     /// assert_eq!(&[0, 159], value.unwrap_err().as_bytes());\n     /// ```\n-    #[unstable(feature = \"from_utf8_error_as_bytes\", reason = \"recently added\", issue = \"40895\")]\n+    #[stable(feature = \"from_utf8_error_as_bytes\", since = \"1.26.0\")]\n     pub fn as_bytes(&self) -> &[u8] {\n         &self.bytes[..]\n     }"}, {"sha": "d25f498b99efea68c8eb8462028f8cdda6ecd0e1", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -63,6 +63,11 @@\n /// This trait can be used with `#[derive]` if all fields are `Clone`. The `derive`d\n /// implementation of [`clone`] calls [`clone`] on each field.\n ///\n+/// ## Closures\n+///\n+/// Closure types automatically implement `Clone` if they capture no value from the environment\n+/// or if all such captured values implement `Clone` themselves.\n+///\n /// ## How can I implement `Clone`?\n ///\n /// Types that are [`Copy`] should have a trivial implementation of `Clone`. More formally:"}, {"sha": "62994ed15cc6daf708350cf146a249927d1b9ce5", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 66, "deletions": 6, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -406,6 +406,18 @@ impl<'a> Arguments<'a> {\n /// macro validates the format string at compile-time so usage of the [`write`]\n /// and [`format`] functions can be safely performed.\n ///\n+/// You can use the `Arguments<'a>` that [`format_args!`] returns in `Debug`\n+/// and `Display` contexts as seen below. The example also shows that `Debug`\n+/// and `Display` format to the same thing: the interpolated format string\n+/// in `format_args!`.\n+///\n+/// ```rust\n+/// let display = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// let debug = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+/// assert_eq!(\"1 foo 2\", display);\n+/// assert_eq!(display, debug);\n+/// ```\n+///\n /// [`format_args!`]: ../../std/macro.format_args.html\n /// [`format`]: ../../std/fmt/fn.format.html\n /// [`write`]: ../../std/fmt/fn.write.html\n@@ -1553,23 +1565,32 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::net::Ipv4Addr;\n     ///\n     /// struct Foo {\n     ///     bar: i32,\n     ///     baz: String,\n+    ///     addr: Ipv4Addr,\n     /// }\n     ///\n     /// impl fmt::Debug for Foo {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_struct(\"Foo\")\n     ///             .field(\"bar\", &self.bar)\n     ///             .field(\"baz\", &self.baz)\n+    ///             .field(\"addr\", &format_args!(\"{}\", self.addr))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo { bar: 10, baz: \"Hello World\" }\"\n-    /// println!(\"{:?}\", Foo { bar: 10, baz: \"Hello World\".to_string() });\n+    /// assert_eq!(\n+    ///     \"Foo { bar: 10, baz: \\\"Hello World\\\", addr: 127.0.0.1 }\",\n+    ///     format!(\"{:?}\", Foo {\n+    ///         bar: 10,\n+    ///         baz: \"Hello World\".to_string(),\n+    ///         addr: Ipv4Addr::new(127, 0, 0, 1),\n+    ///     })\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_struct<'b>(&'b mut self, name: &str) -> DebugStruct<'b, 'a> {\n@@ -1583,20 +1604,24 @@ impl<'a> Formatter<'a> {\n     ///\n     /// ```rust\n     /// use std::fmt;\n+    /// use std::marker::PhantomData;\n     ///\n-    /// struct Foo(i32, String);\n+    /// struct Foo<T>(i32, String, PhantomData<T>);\n     ///\n-    /// impl fmt::Debug for Foo {\n+    /// impl<T> fmt::Debug for Foo<T> {\n     ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n     ///         fmt.debug_tuple(\"Foo\")\n     ///             .field(&self.0)\n     ///             .field(&self.1)\n+    ///             .field(&format_args!(\"_\"))\n     ///             .finish()\n     ///     }\n     /// }\n     ///\n-    /// // prints \"Foo(10, \"Hello World\")\"\n-    /// println!(\"{:?}\", Foo(10, \"Hello World\".to_string()));\n+    /// assert_eq!(\n+    ///     \"Foo(10, \\\"Hello\\\", _)\",\n+    ///     format!(\"{:?}\", Foo(10, \"Hello\".to_string(), PhantomData::<u8>))\n+    /// );\n     /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_tuple<'b>(&'b mut self, name: &str) -> DebugTuple<'b, 'a> {\n@@ -1646,6 +1671,41 @@ impl<'a> Formatter<'a> {\n     /// // prints \"{10, 11}\"\n     /// println!(\"{:?}\", Foo(vec![10, 11]));\n     /// ```\n+    ///\n+    /// [`format_args!`]: ../../std/macro.format_args.html\n+    ///\n+    /// In this more complex example, we use [`format_args!`] and `.debug_set()`\n+    /// to build a list of match arms:\n+    ///\n+    /// ```rust\n+    /// use std::fmt;\n+    ///\n+    /// struct Arm<'a, L: 'a, R: 'a>(&'a (L, R));\n+    /// struct Table<'a, K: 'a, V: 'a>(&'a [(K, V)], V);\n+    ///\n+    /// impl<'a, L, R> fmt::Debug for Arm<'a, L, R>\n+    /// where\n+    ///     L: 'a + fmt::Debug, R: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         L::fmt(&(self.0).0, fmt)?;\n+    ///         fmt.write_str(\" => \")?;\n+    ///         R::fmt(&(self.0).1, fmt)\n+    ///     }\n+    /// }\n+    ///\n+    /// impl<'a, K, V> fmt::Debug for Table<'a, K, V>\n+    /// where\n+    ///     K: 'a + fmt::Debug, V: 'a + fmt::Debug\n+    /// {\n+    ///     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+    ///         fmt.debug_set()\n+    ///         .entries(self.0.iter().map(Arm))\n+    ///         .entry(&Arm(&(format_args!(\"_\"), &self.1)))\n+    ///         .finish()\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn debug_set<'b>(&'b mut self) -> DebugSet<'b, 'a> {\n         builders::debug_set_new(self)"}, {"sha": "7d0174a178abfb55a0b3c39498adfdbffea9559e", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -166,6 +166,11 @@ pub trait Unsize<T: ?Sized> {\n /// are allowed to access `x` after the assignment. Under the hood, both a copy and a move\n /// can result in bits being copied in memory, although this is sometimes optimized away.\n ///\n+/// ## Closures\n+///\n+/// Closure types automatically implement `Copy` if they capture no value from the environment\n+/// or if all such captured values implement `Copy` themselves.\n+///\n /// ## How can I implement `Copy`?\n ///\n /// There are two ways to implement `Copy` on your type. The simplest is to use `derive`:"}, {"sha": "4b70c5398be4f1e138cab935b7bc54cfed3d8b00", "filename": "src/libcore/ops/generator.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fops%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibcore%2Fops%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fgenerator.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -56,11 +56,11 @@ pub enum GeneratorState<Y, R> {\n ///         return \"foo\"\n ///     };\n ///\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Yielded(1) => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n-///     match generator.resume() {\n+///     match unsafe { generator.resume() } {\n ///         GeneratorState::Complete(\"foo\") => {}\n ///         _ => panic!(\"unexpected return from resume\"),\n ///     }\n@@ -98,6 +98,10 @@ pub trait Generator {\n     /// generator will continue executing until it either yields or returns, at\n     /// which point this function will return.\n     ///\n+    /// The function is unsafe because it can be used on an immovable generator.\n+    /// After such a call, the immovable generator must not move again, but\n+    /// this is not enforced by the compiler.\n+    ///\n     /// # Return value\n     ///\n     /// The `GeneratorState` enum returned from this function indicates what\n@@ -116,7 +120,7 @@ pub trait Generator {\n     /// been returned previously. While generator literals in the language are\n     /// guaranteed to panic on resuming after `Complete`, this is not guaranteed\n     /// for all implementations of the `Generator` trait.\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return>;\n }\n \n #[unstable(feature = \"generator_trait\", issue = \"43122\")]\n@@ -125,7 +129,7 @@ impl<'a, T> Generator for &'a mut T\n {\n     type Yield = T::Yield;\n     type Return = T::Return;\n-    fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n+    unsafe fn resume(&mut self) -> GeneratorState<Self::Yield, Self::Return> {\n         (**self).resume()\n     }\n }"}, {"sha": "81fa0374f549e903f5384737f1d000d6c4a8ba2d", "filename": "src/libgetopts/lib.rs", "status": "removed", "additions": 0, "deletions": 1622, "changes": 1622, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,1622 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple getopt alternative.\n-//!\n-//! Construct a vector of options, either by using `reqopt`, `optopt`, and `optflag`\n-//! or by building them from components yourself, and pass them to `getopts`,\n-//! along with a vector of actual arguments (not including `argv[0]`). You'll\n-//! either get a failure code back, or a match. You'll have to verify whether\n-//! the amount of 'free' arguments in the match is what you expect. Use `opt_*`\n-//! accessors to get argument values out of the matches object.\n-//!\n-//! Single-character options are expected to appear on the command line with a\n-//! single preceding dash; multiple-character options are expected to be\n-//! proceeded by two dashes. Options that expect an argument accept their\n-//! argument following either a space or an equals sign. Single-character\n-//! options don't require the space.\n-//!\n-//! # Example\n-//!\n-//! The following example shows simple command line parsing for an application\n-//! that requires an input file to be specified, accepts an optional output\n-//! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n-//!\n-//! ```{.rust}\n-//! #![feature(rustc_private)]\n-//!\n-//! extern crate getopts;\n-//! use getopts::{optopt,optflag,getopts,OptGroup,usage};\n-//! use std::env;\n-//!\n-//! fn do_work(inp: &str, out: Option<String>) {\n-//!     println!(\"{}\", inp);\n-//!     match out {\n-//!         Some(x) => println!(\"{}\", x),\n-//!         None => println!(\"No Output\"),\n-//!     }\n-//! }\n-//!\n-//! fn print_usage(program: &str, opts: &[OptGroup]) {\n-//!     let brief = format!(\"Usage: {} [options]\", program);\n-//!     print!(\"{}\", usage(&brief, opts));\n-//! }\n-//!\n-//! fn main() {\n-//!     let args: Vec<String> = env::args().collect();\n-//!\n-//!     let program = args[0].clone();\n-//!\n-//!     let opts = &[\n-//!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n-//!         optflag(\"h\", \"help\", \"print this help menu\")\n-//!     ];\n-//!     let matches = match getopts(&args[1..], opts) {\n-//!         Ok(m) => { m }\n-//!         Err(f) => { panic!(f.to_string()) }\n-//!     };\n-//!     if matches.opt_present(\"h\") {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     }\n-//!     let output = matches.opt_str(\"o\");\n-//!     let input = if !matches.free.is_empty() {\n-//!         matches.free[0].clone()\n-//!     } else {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     };\n-//!     do_work(&input, output);\n-//! }\n-//! ```\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-\n-#![deny(missing_docs)]\n-#![deny(warnings)]\n-\n-use self::Name::*;\n-use self::HasArg::*;\n-use self::Occur::*;\n-use self::Fail::*;\n-use self::Optval::*;\n-use self::SplitWithinState::*;\n-use self::Whitespace::*;\n-use self::LengthLimit::*;\n-\n-use std::fmt;\n-use std::iter::repeat;\n-use std::result;\n-\n-/// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Name {\n-    /// A string representing the long name of an option.\n-    /// For example: \"help\"\n-    Long(String),\n-    /// A char representing the short name of an option.\n-    /// For example: 'h'\n-    Short(char),\n-}\n-\n-/// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum HasArg {\n-    /// The option requires an argument.\n-    Yes,\n-    /// The option takes no argument.\n-    No,\n-    /// The option argument is optional.\n-    Maybe,\n-}\n-\n-/// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum Occur {\n-    /// The option occurs once.\n-    Req,\n-    /// The option occurs at most once.\n-    Optional,\n-    /// The option occurs zero or more times.\n-    Multi,\n-}\n-\n-/// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Opt {\n-    /// Name of the option\n-    pub name: Name,\n-    /// Whether it has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-    /// Which options it aliases\n-    pub aliases: Vec<Opt>,\n-}\n-\n-/// One group of options, e.g., both `-h` and `--help`, along with\n-/// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct OptGroup {\n-    /// Short name of the option, e.g. `h` for a `-h` option\n-    pub short_name: String,\n-    /// Long name of the option, e.g. `help` for a `--help` option\n-    pub long_name: String,\n-    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n-    pub hint: String,\n-    /// Description for usage help text\n-    pub desc: String,\n-    /// Whether option has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-}\n-\n-/// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum Optval {\n-    Val(String),\n-    Given,\n-}\n-\n-/// The result of checking command line arguments. Contains a vector\n-/// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Matches {\n-    /// Options that matched\n-    opts: Vec<Opt>,\n-    /// Values of the Options that matched\n-    vals: Vec<Vec<Optval>>,\n-    /// Free string fragments\n-    pub free: Vec<String>,\n-}\n-\n-/// The type returned when the command line does not conform to the\n-/// expected format. Use the `Debug` implementation to output detailed\n-/// information.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Fail {\n-    /// The option requires an argument but none was passed.\n-    ArgumentMissing(String),\n-    /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(String),\n-    /// A required option is not present.\n-    OptionMissing(String),\n-    /// A single occurrence option is being used multiple times.\n-    OptionDuplicated(String),\n-    /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(String),\n-}\n-\n-/// The type of failure that occurred.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[allow(missing_docs)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n-/// The result of parsing a command line with a set of options.\n-pub type Result = result::Result<Matches, Fail>;\n-\n-impl Name {\n-    fn from_str(nm: &str) -> Name {\n-        if nm.len() == 1 {\n-            Short(nm.chars().next().unwrap())\n-        } else {\n-            Long(nm.to_owned())\n-        }\n-    }\n-\n-    fn to_string(&self) -> String {\n-        match *self {\n-            Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned(),\n-        }\n-    }\n-}\n-\n-impl OptGroup {\n-    /// Translate OptGroup into Opt.\n-    /// (Both short and long names correspond to different Opts).\n-    pub fn long_to_short(&self) -> Opt {\n-        let OptGroup {\n-            short_name,\n-            long_name,\n-            hasarg,\n-            occur,\n-            ..\n-        } = (*self).clone();\n-\n-        match (short_name.len(), long_name.len()) {\n-            (0, 0) => panic!(\"this long-format option was given no name\"),\n-            (0, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, 0) => {\n-                Opt {\n-                    name: Short(short_name.chars().next().unwrap()),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: vec![Opt {\n-                                      name: Short(short_name.chars().next().unwrap()),\n-                                      hasarg,\n-                                      occur,\n-                                      aliases: Vec::new(),\n-                                  }],\n-                }\n-            }\n-            _ => panic!(\"something is wrong with the long-form opt\"),\n-        }\n-    }\n-}\n-\n-impl Matches {\n-    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[..], Name::from_str(nm)) {\n-            Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm),\n-        }\n-    }\n-\n-    fn opt_val(&self, nm: &str) -> Option<Optval> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            Some(vals[0].clone())\n-        }\n-    }\n-\n-    /// Returns true if an option was matched.\n-    pub fn opt_present(&self, nm: &str) -> bool {\n-        !self.opt_vals(nm).is_empty()\n-    }\n-\n-    /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> usize {\n-        self.opt_vals(nm).len()\n-    }\n-\n-    /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names {\n-            match find_opt(&self.opts, Name::from_str(&**nm)) {\n-                Some(id) if !self.vals[id].is_empty() => return true,\n-                _ => (),\n-            };\n-        }\n-        false\n-    }\n-\n-    /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names {\n-            if let Some(Val(ref s)) = self.opt_val(&nm[..]) {\n-                  return Some(s.clone())\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a vector of the arguments provided to all matches of the given\n-    /// option.\n-    ///\n-    /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n-        let mut acc: Vec<String> = Vec::new();\n-        let r = self.opt_vals(nm);\n-        for v in &r {\n-            match *v {\n-                Val(ref s) => acc.push((*s).clone()),\n-                _ => (),\n-            }\n-        }\n-        acc\n-    }\n-\n-    /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            return None::<String>;\n-        }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n-            _ => None,\n-        }\n-    }\n-\n-\n-    /// Returns the matching string, a default, or none.\n-    ///\n-    /// Returns none if the option was not present, `def` if the option was\n-    /// present but no argument was provided, and the argument if the option was\n-    /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            match vals[0] {\n-                Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned()),\n-            }\n-        }\n-    }\n-}\n-\n-fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg.as_bytes()[0] == b'-'\n-}\n-\n-fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n-    // Search main options.\n-    let pos = opts.iter().position(|opt| opt.name == nm);\n-    if pos.is_some() {\n-        return pos;\n-    }\n-\n-    // Search in aliases.\n-    for candidate in opts {\n-        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n-            return opts.iter().position(|opt| opt.name == candidate.name);\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Create a long option that is required and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Req,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional and does not take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that can occur more than once and does not\n-/// take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an optional argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Maybe,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional, takes an argument, and may occur\n-/// multiple times.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a generic option group, stating all parameters explicitly\n-pub fn opt(short_name: &str,\n-           long_name: &str,\n-           desc: &str,\n-           hint: &str,\n-           hasarg: HasArg,\n-           occur: Occur)\n-           -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg,\n-        occur,\n-    }\n-}\n-\n-impl fmt::Display for Fail {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n-            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n-            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n-            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n-            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n-        }\n-    }\n-}\n-\n-/// Parse command line arguments according to the provided options.\n-///\n-/// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n-/// `opt_str`, etc. to interrogate results.\n-/// # Panics\n-///\n-/// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail` to display\n-/// information about it.\n-pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n-    let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n-    let n_opts = opts.len();\n-\n-    fn f(_x: usize) -> Vec<Optval> {\n-        Vec::new()\n-    }\n-\n-    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n-    let mut free: Vec<String> = Vec::new();\n-    let l = args.len();\n-    let mut i = 0;\n-    while i < l {\n-        let cur = args[i].clone();\n-        let curlen = cur.len();\n-        if !is_arg(&cur[..]) {\n-            free.push(cur);\n-        } else if cur == \"--\" {\n-            let mut j = i + 1;\n-            while j < l {\n-                free.push(args[j].clone());\n-                j += 1;\n-            }\n-            break;\n-        } else {\n-            let mut names;\n-            let mut i_arg = None;\n-            if cur.as_bytes()[1] == b'-' {\n-                let tail = &cur[2..curlen];\n-                let tail_eq: Vec<&str> = tail.splitn(2, '=').collect();\n-                if tail_eq.len() <= 1 {\n-                    names = vec![Long(tail.to_owned())];\n-                } else {\n-                    names = vec![Long(tail_eq[0].to_owned())];\n-                    i_arg = Some(tail_eq[1].to_owned());\n-                }\n-            } else {\n-                let mut j = 1;\n-                names = Vec::new();\n-                while j < curlen {\n-                    let ch = cur[j..].chars().next().unwrap();\n-                    let opt = Short(ch);\n-\n-                    // In a series of potential options (eg. -aheJ), if we\n-                    // see one which takes an argument, we assume all\n-                    // subsequent characters make up the argument. This\n-                    // allows options such as -L/usr/local/lib/foo to be\n-                    // interpreted correctly\n-\n-                    let opt_id = match find_opt(&opts, opt.clone()) {\n-                        Some(id) => id,\n-                        None => return Err(UnrecognizedOption(opt.to_string())),\n-                    };\n-\n-                    names.push(opt);\n-\n-                    let arg_follows = match opts[opt_id].hasarg {\n-                        Yes | Maybe => true,\n-                        No => false,\n-                    };\n-\n-                    let next = j + ch.len_utf8();\n-                    if arg_follows && next < curlen {\n-                        i_arg = Some((&cur[next..curlen]).to_owned());\n-                        break;\n-                    }\n-\n-                    j = next;\n-                }\n-            }\n-            let mut name_pos = 0;\n-            for nm in &names {\n-                name_pos += 1;\n-                let optid = match find_opt(&opts, (*nm).clone()) {\n-                    Some(id) => id,\n-                    None => return Err(UnrecognizedOption(nm.to_string())),\n-                };\n-                match opts[optid].hasarg {\n-                    No => {\n-                        if name_pos == names.len() && !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(nm.to_string()));\n-                        }\n-                        let v = &mut vals[optid];\n-                        v.push(Given);\n-                    }\n-                    Maybe => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val((i_arg.clone()).unwrap()));\n-                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n-                            let v = &mut vals[optid];\n-                            v.push(Given);\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                    Yes => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val(i_arg.clone().unwrap()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(nm.to_string()));\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        i += 1;\n-    }\n-    for i in 0..n_opts {\n-        let n = vals[i].len();\n-        let occ = opts[i].occur;\n-        if occ == Req && n == 0 {\n-            return Err(OptionMissing(opts[i].name.to_string()));\n-        }\n-        if occ != Multi && n > 1 {\n-            return Err(OptionDuplicated(opts[i].name.to_string()));\n-        }\n-    }\n-    Ok(Matches {\n-        opts,\n-        vals,\n-        free,\n-    })\n-}\n-\n-/// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n-\n-    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n-\n-    let rows = opts.iter().map(|optref| {\n-        let OptGroup{short_name,\n-                     long_name,\n-                     hint,\n-                     desc,\n-                     hasarg,\n-                     ..} = (*optref).clone();\n-\n-        let mut row = repeat(\" \").take(4).collect::<String>();\n-\n-        // short option\n-        match short_name.len() {\n-            0 => {}\n-            1 => {\n-                row.push('-');\n-                row.push_str(&short_name[..]);\n-                row.push(' ');\n-            }\n-            _ => panic!(\"the short name should only be 1 ascii char long\"),\n-        }\n-\n-        // long option\n-        match long_name.len() {\n-            0 => {}\n-            _ => {\n-                row.push_str(\"--\");\n-                row.push_str(&long_name[..]);\n-                row.push(' ');\n-            }\n-        }\n-\n-        // arg\n-        match hasarg {\n-            No => {}\n-            Yes => row.push_str(&hint[..]),\n-            Maybe => {\n-                row.push('[');\n-                row.push_str(&hint[..]);\n-                row.push(']');\n-            }\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // here we just need to indent the start of the description\n-        let rowlen = row.chars().count();\n-        if rowlen < 24 {\n-            for _ in 0..24 - rowlen {\n-                row.push(' ');\n-            }\n-        } else {\n-            row.push_str(&desc_sep[..]);\n-        }\n-\n-        // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = String::new();\n-        for word in desc.split_whitespace() {\n-            desc_normalized_whitespace.push_str(word);\n-            desc_normalized_whitespace.push(' ');\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n-            desc_rows.push(substr.to_owned());\n-            true\n-        });\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // wrapped description\n-        row.push_str(&desc_rows.join(&desc_sep[..]));\n-\n-        row\n-    });\n-\n-    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n-            brief,\n-            rows.collect::<Vec<String>>().join(\"\\n\"))\n-}\n-\n-fn format_option(opt: &OptGroup) -> String {\n-    let mut line = String::new();\n-\n-    if opt.occur != Req {\n-        line.push('[');\n-    }\n-\n-    // Use short_name is possible, but fallback to long_name.\n-    if !opt.short_name.is_empty() {\n-        line.push('-');\n-        line.push_str(&opt.short_name[..]);\n-    } else {\n-        line.push_str(\"--\");\n-        line.push_str(&opt.long_name[..]);\n-    }\n-\n-    if opt.hasarg != No {\n-        line.push(' ');\n-        if opt.hasarg == Maybe {\n-            line.push('[');\n-        }\n-        line.push_str(&opt.hint[..]);\n-        if opt.hasarg == Maybe {\n-            line.push(']');\n-        }\n-    }\n-\n-    if opt.occur != Req {\n-        line.push(']');\n-    }\n-    if opt.occur == Multi {\n-        line.push_str(\"..\");\n-    }\n-\n-    line\n-}\n-\n-/// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n-    let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(&opts.iter()\n-                       .map(format_option)\n-                       .collect::<Vec<String>>()\n-                       .join(\" \")[..]);\n-    line\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SplitWithinState {\n-    A, // leading whitespace, initial state\n-    B, // words\n-    C, // internal and trailing whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum Whitespace {\n-    Ws, // current char is whitespace\n-    Cr, // current char is not whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum LengthLimit {\n-    UnderLim, // current char makes current substring still fit in limit\n-    OverLim, // current char makes current substring no longer fit in limit\n-}\n-\n-\n-/// Splits a string into substrings with possibly internal whitespace,\n-/// each of them at most `lim` bytes long. The substrings have leading and trailing\n-/// whitespace removed, and are only cut at whitespace boundaries.\n-///\n-/// Note: Function was moved here from `std::str` because this module is the only place that\n-/// uses it, and because it was too specific for a general string function.\n-///\n-/// # Panics\n-///\n-/// Panics during iteration if the string contains a non-whitespace\n-/// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n-    where F: FnMut(&str) -> bool\n-{\n-    // Just for fun, let's write this as a state machine:\n-\n-    let mut slice_start = 0;\n-    let mut last_start = 0;\n-    let mut last_end = 0;\n-    let mut state = A;\n-    let mut fake_i = ss.len();\n-    let mut lim = lim;\n-\n-    let mut cont = true;\n-\n-    // if the limit is larger than the string, lower it to save cycles\n-    if lim >= fake_i {\n-        lim = fake_i;\n-    }\n-\n-    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() {\n-            Ws\n-        } else {\n-            Cr\n-        };\n-        let limit = if (i - slice_start + 1) <= lim {\n-            UnderLim\n-        } else {\n-            OverLim\n-        };\n-\n-        state = match (state, whitespace, limit) {\n-            (A, Ws, _) => A,\n-            (A, Cr, _) => {\n-                slice_start = i;\n-                last_start = i;\n-                B\n-            }\n-\n-            (B, Cr, UnderLim) => B,\n-            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n-                panic!(\"word starting with {} longer than limit!\",\n-                       &ss[last_start..i + 1])\n-            }\n-            (B, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = last_start;\n-                B\n-            }\n-            (B, Ws, UnderLim) => {\n-                last_end = i;\n-                C\n-            }\n-            (B, Ws, OverLim) => {\n-                last_end = i;\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-\n-            (C, Cr, UnderLim) => {\n-                last_start = i;\n-                B\n-            }\n-            (C, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = i;\n-                last_start = i;\n-                last_end = i;\n-                B\n-            }\n-            (C, Ws, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-            (C, Ws, UnderLim) => C,\n-        };\n-\n-        *cont\n-    };\n-\n-    ss.char_indices().all(|x| machine(&mut cont, x));\n-\n-    // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont &&\n-          match state {\n-        B | C => true,\n-        A => false,\n-    } {\n-        machine(&mut cont, (fake_i, ' '));\n-        fake_i += 1;\n-    }\n-    cont\n-}\n-\n-#[test]\n-fn test_split_within() {\n-    fn t(s: &str, i: usize, u: &[String]) {\n-        let mut v = Vec::new();\n-        each_split_within(s, i, |s| {\n-            v.push(s.to_string());\n-            true\n-        });\n-        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n-    }\n-    t(\"\", 0, &[]);\n-    t(\"\", 15, &[]);\n-    t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      15,\n-      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      ::std::usize::MAX,\n-      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use std::result::Result::{Err, Ok};\n-    use std::result;\n-\n-    // Tests for reqopt\n-    #[test]\n-    fn test_reqopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (long arg)\");\n-            }\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (short arg)\");\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optopt\n-    #[test]\n-    fn test_optopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflag\n-    #[test]\n-    fn test_optflag() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_long_arg() {\n-        let args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(UnexpectedArgument(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_multi() {\n-        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_short_arg() {\n-        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                // The next variable after the flag is just a free argument\n-\n-                assert!(m.free[0] == \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflagmulti\n-    #[test]\n-    fn test_optflagmulti_short1() {\n-        let args = vec![\"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2a() {\n-        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2b() {\n-        let args = vec![\"-vv\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long1() {\n-        let args = vec![\"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long2() {\n-        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_mix() {\n-        let args = vec![\"--verbose\".to_string(),\n-                        \"-v\".to_string(),\n-                        \"-vv\".to_string(),\n-                        \"verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 4);\n-                assert_eq!(m.opt_count(\"v\"), 4);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optmulti\n-    #[test]\n-    fn test_optmulti() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-                let pair = m.opt_strs(\"test\");\n-                assert!(pair[0] == \"20\");\n-                assert!(pair[1] == \"30\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unrecognized_option() {\n-        let long_args = vec![\"--untest\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-u\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_combined() {\n-        let args = vec![\"prog\".to_string(),\n-                        \"free1\".to_string(),\n-                        \"-s\".to_string(),\n-                        \"20\".to_string(),\n-                        \"free2\".to_string(),\n-                        \"--flag\".to_string(),\n-                        \"--long=30\".to_string(),\n-                        \"-f\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"40\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"50\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-A B\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-60 70\".to_string()];\n-        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-                        optflag(\"\", \"flag\", \"a flag\"),\n-                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-                        optflag(\"f\", \"\", \"another flag\"),\n-                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.free[0] == \"prog\");\n-                assert!(m.free[1] == \"free1\");\n-                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-                assert!(m.free[2] == \"free2\");\n-                assert!((m.opt_present(\"flag\")));\n-                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-                assert!((m.opt_present(\"f\")));\n-                let pair = m.opt_strs(\"m\");\n-                assert!(pair[0] == \"40\");\n-                assert!(pair[1] == \"50\");\n-                let pair = m.opt_strs(\"n\");\n-                assert!(pair[0] == \"-A B\");\n-                assert!(pair[1] == \"-60 70\");\n-                assert!((!m.opt_present(\"notpresent\")));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_multi() {\n-        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n-\n-        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n-        let matches_single = &match getopts(&args_single, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&[]));\n-\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-\n-        let args_both = vec![\"-e\".to_string(),\n-                             \"foo\".to_string(),\n-                             \"--encrypt\".to_string(),\n-                             \"foo\".to_string()];\n-        let matches_both = &match getopts(&args_both, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&[]));\n-\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_nospace() {\n-        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n-        assert!(matches.opts_present(&[\"M\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n-\n-    }\n-\n-    #[test]\n-    fn test_nospace_conflict() {\n-        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n-        assert!(matches.opts_present(&[\"v\".to_string()]));\n-        assert_eq!(3, matches.opt_count(\"v\"));\n-    }\n-\n-    #[test]\n-    fn test_long_to_short() {\n-        let mut short = Opt {\n-            name: Name::Long(\"banana\".to_string()),\n-            hasarg: HasArg::Yes,\n-            occur: Occur::Req,\n-            aliases: Vec::new(),\n-        };\n-        short.aliases = vec![Opt {\n-                                 name: Name::Short('b'),\n-                                 hasarg: HasArg::Yes,\n-                                 occur: Occur::Req,\n-                                 aliases: Vec::new(),\n-                             }];\n-        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n-\n-        assert!(verbose.long_to_short() == short);\n-    }\n-\n-    #[test]\n-    fn test_aliases_long_and_short() {\n-        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n-\n-        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n-\n-        let matches = getopts(&args, &opts).unwrap();\n-        assert_eq!(3, matches.opt_count(\"a\"));\n-        assert_eq!(3, matches.opt_count(\"apple\"));\n-    }\n-\n-    #[test]\n-    fn test_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -b --banana VAL     Desc\n-    -a --012345678901234567890123456789 VAL\n-                        Desc\n-    -k --kiwi           Desc\n-    -p [VAL]            Desc\n-    -l VAL              Desc\n-\";\n-\n-        let generated_usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_usage_description_wrapping() {\n-        // indentation should be 24 spaces\n-        // lines wrap after 78: or rather descriptions wrap after 54\n-\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"kiwi\",\n-                                     // 54\n-                                     \"This is a long description which won't be wrapped..+..\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This is a long description which _will_ be wrapped..+..\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --kiwi           This is a long description which won't be wrapped..+..\n-    -a --apple          This is a long description which _will_ be\n-                        wrapped..+..\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"k\\u{2013}w\\u{2013}\",\n-                                     \"The word kiwi is normally spelled with two i's\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n-                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n-                                      some parts of Europe.\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --k\u2013w\u2013           The word kiwi is normally spelled with two i's\n-    -a --apple          This \u201cdescription\u201d has some characters that could\n-                        confuse the line wrapping; an apple costs 0.51\u20ac in\n-                        some parts of Europe.\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_short_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n-        let generated_usage = short_usage(\"fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_args_with_equals() {\n-        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string()];\n-        let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n-                        optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e)\n-        };\n-        assert_eq!(matches.opts_str(&[\"o\".to_string()]).unwrap(), \"A=B\");\n-        assert_eq!(matches.opts_str(&[\"t\".to_string()]).unwrap(), \"C=D\");\n-    }\n-}"}, {"sha": "42cda6a05a1a78e986d94f0af2686982911f721f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -617,8 +617,6 @@ define_dep_nodes!( <'tcx>\n     [input] MissingExternCrateItem(CrateNum),\n     [input] UsedCrateSource(CrateNum),\n     [input] PostorderCnums,\n-    [] HasCloneClosures(CrateNum),\n-    [] HasCopyClosures(CrateNum),\n \n     // This query is not expected to have inputs -- as a result, it's\n     // not a good candidate for \"replay\" because it's essentially a"}, {"sha": "e22e2b557039483b10e51e58f2a6c9f28f3b23c3", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1764,12 +1764,12 @@ The `main` function was incorrectly declared.\n Erroneous code example:\n \n ```compile_fail,E0580\n-fn main() -> i32 { // error: main function has wrong type\n-    0\n+fn main(x: i32) { // error: main function has wrong type\n+    println!(\"{}\", x);\n }\n ```\n \n-The `main` function prototype should never take arguments or return type.\n+The `main` function prototype should never take arguments.\n Example:\n \n ```"}, {"sha": "a759ce59cb644b553067ced78165198284ca2662", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -45,7 +45,7 @@\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n-#![feature(copy_closures, clone_closures)]\n+#![cfg_attr(stage0, feature(copy_closures, clone_closures))]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(dyn_trait)]"}, {"sha": "f41765b642d969e77e51de4952934073582ca9c7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1208,6 +1208,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"set the MIR optimization level (0-3, default: 1)\"),\n     mutable_noalias: bool = (false, parse_bool, [UNTRACKED],\n           \"emit noalias metadata for mutable references\"),\n+    arg_align_attributes: bool = (false, parse_bool, [UNTRACKED],\n+          \"emit align metadata for reference arguments\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: String = (String::from(\"mir_dump\"), parse_string, [UNTRACKED],"}, {"sha": "e640cc315c44d2fa4b6e2d0902cb692b6e114ea3", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -595,20 +595,23 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                          trait_ref.to_predicate(), post_message)\n                             }));\n \n+                        let explanation =\n+                            if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n+                                \"consider using `()`, or a `Result`\".to_owned()\n+                            } else {\n+                                format!(\"{}the trait `{}` is not implemented for `{}`\",\n+                                        pre_message,\n+                                        trait_ref,\n+                                        trait_ref.self_ty())\n+                            };\n+\n                         if let Some(ref s) = label {\n                             // If it has a custom \"#[rustc_on_unimplemented]\"\n                             // error message, let's display it as the label!\n                             err.span_label(span, s.as_str());\n-                            err.help(&format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                              pre_message,\n-                                              trait_ref,\n-                                              trait_ref.self_ty()));\n+                            err.help(&explanation);\n                         } else {\n-                            err.span_label(span,\n-                                           &*format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                                     pre_message,\n-                                                     trait_ref,\n-                                                     trait_ref.self_ty()));\n+                            err.span_label(span, explanation);\n                         }\n                         if let Some(ref s) = note {\n                             // If it has a custom \"#[rustc_on_unimplemented]\" note, let's display it"}, {"sha": "11daa96134c59c909a56dc10ddad709482d4e8a1", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -2086,14 +2086,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n             ty::TyClosure(def_id, substs) => {\n                 let trait_id = obligation.predicate.def_id();\n-                let copy_closures =\n-                    Some(trait_id) == self.tcx().lang_items().copy_trait() &&\n-                    self.tcx().has_copy_closures(def_id.krate);\n-                let clone_closures =\n-                    Some(trait_id) == self.tcx().lang_items().clone_trait() &&\n-                    self.tcx().has_clone_closures(def_id.krate);\n-\n-                if copy_closures || clone_closures {\n+                let is_copy_trait = Some(trait_id) == self.tcx().lang_items().copy_trait();\n+                let is_clone_trait = Some(trait_id) == self.tcx().lang_items().clone_trait();\n+                if is_copy_trait || is_clone_trait {\n                     Where(ty::Binder(substs.upvar_tys(def_id, self.tcx()).collect()))\n                 } else {\n                     Never"}, {"sha": "fdda2286da03b00332fa51d21031581bd16699b9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -2562,14 +2562,6 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         assert_eq!(cnum, LOCAL_CRATE);\n         tcx.output_filenames.clone()\n     };\n-    providers.has_copy_closures = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.features().copy_closures\n-    };\n-    providers.has_clone_closures = |tcx, cnum| {\n-        assert_eq!(cnum, LOCAL_CRATE);\n-        tcx.features().clone_closures\n-    };\n     providers.features_query = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);\n         Lrc::new(tcx.sess.features_untracked().clone())"}, {"sha": "bb9467305e335ee3e51c5308e570bfd60fece727", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -610,24 +610,12 @@ impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::has_clone_closures<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if the crate has enabled `Clone` closures\")\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n     fn describe(tcx: TyCtxt, key: ty::PolyTraitRef<'tcx> ) -> String {\n         format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::has_copy_closures<'tcx> {\n-    fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n-        format!(\"seeing if the crate has enabled `Copy` closures\")\n-    }\n-}\n-\n impl<'tcx> QueryDescription<'tcx> for queries::features_query<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up enabled feature gates\")"}, {"sha": "2bfb68703292382a888e6551b656f5ff007bbe2f", "filename": "src/librustc/ty/maps/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fmod.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -387,9 +387,6 @@ define_maps! { <'tcx>\n     [] fn output_filenames: output_filenames_node(CrateNum)\n         -> Arc<OutputFilenames>,\n \n-    [] fn has_copy_closures: HasCopyClosures(CrateNum) -> bool,\n-    [] fn has_clone_closures: HasCloneClosures(CrateNum) -> bool,\n-\n     // Erases regions from `ty` to yield a new type.\n     // Normally you would just use `tcx.erase_regions(&value)`,\n     // however, which uses this query as a kind of cache."}, {"sha": "50a19526ba8c4528a74821cf7fc261df50534c14", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -920,8 +920,6 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         }\n         DepKind::UsedCrateSource => { force!(used_crate_source, krate!()); }\n         DepKind::PostorderCnums => { force!(postorder_cnums, LOCAL_CRATE); }\n-        DepKind::HasCloneClosures => { force!(has_clone_closures, krate!()); }\n-        DepKind::HasCopyClosures => { force!(has_copy_closures, krate!()); }\n \n         DepKind::Freevars => { force!(freevars, def_id!()); }\n         DepKind::MaybeUnusedTraitImport => {"}, {"sha": "b9bcbccb30ef37c16ef613b9687a6582a382a966", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -63,6 +63,7 @@ use rustc_resolve as resolve;\n use rustc_save_analysis as save;\n use rustc_save_analysis::DumpHandler;\n use rustc_data_structures::sync::Lrc;\n+use rustc_data_structures::OnDrop;\n use rustc::session::{self, config, Session, build_session, CompileResult};\n use rustc::session::CompileIncomplete;\n use rustc::session::config::{Input, PrintRequest, ErrorOutputType};\n@@ -515,30 +516,35 @@ fn run_compiler_impl<'a>(args: &[String],\n     target_features::add_configuration(&mut cfg, &sess, &*trans);\n     sess.parse_sess.config = cfg;\n \n-    let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n-\n-    let cstore = CStore::new(trans.metadata_loader());\n-\n-    do_or_return!(callbacks.late_callback(&*trans,\n-                                          &matches,\n-                                          &sess,\n-                                          &cstore,\n-                                          &input,\n-                                          &odir,\n-                                          &ofile), Some(sess));\n-\n-    let control = callbacks.build_controller(&sess, &matches);\n-\n-    (driver::compile_input(trans,\n-                           &sess,\n-                           &cstore,\n-                           &input_file_path,\n-                           &input,\n-                           &odir,\n-                           &ofile,\n-                           Some(plugins),\n-                           &control),\n-     Some(sess))\n+    let result = {\n+        let plugins = sess.opts.debugging_opts.extra_plugins.clone();\n+\n+        let cstore = CStore::new(trans.metadata_loader());\n+\n+        do_or_return!(callbacks.late_callback(&*trans,\n+                                              &matches,\n+                                              &sess,\n+                                              &cstore,\n+                                              &input,\n+                                              &odir,\n+                                              &ofile), Some(sess));\n+\n+        let _sess_abort_error = OnDrop(|| sess.diagnostic().print_error_count());\n+\n+        let control = callbacks.build_controller(&sess, &matches);\n+\n+        driver::compile_input(trans,\n+                              &sess,\n+                              &cstore,\n+                              &input_file_path,\n+                              &input,\n+                              &odir,\n+                              &ofile,\n+                              Some(plugins),\n+                              &control)\n+    };\n+\n+    (result, Some(sess))\n }\n \n // Extract output directory and file from matches."}, {"sha": "dcbea793ba6a3e72e2e68414c6220f56d8314de3", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -558,21 +558,15 @@ impl Handler {\n     pub fn has_errors(&self) -> bool {\n         self.err_count() > 0\n     }\n-    pub fn abort_if_errors(&self) {\n-        let s;\n-        match self.err_count() {\n-            0 => {\n-                if let Some(bug) = self.delayed_span_bug.borrow_mut().take() {\n-                    DiagnosticBuilder::new_diagnostic(self, bug).emit();\n-                }\n-                return;\n-            }\n-            1 => s = \"aborting due to previous error\".to_string(),\n-            _ => {\n-                s = format!(\"aborting due to {} previous errors\", self.err_count());\n-            }\n-        }\n-        let err = self.fatal(&s);\n+\n+    pub fn print_error_count(&self) {\n+        let s = match self.err_count() {\n+            0 => return,\n+            1 => \"aborting due to previous error\".to_string(),\n+            _ => format!(\"aborting due to {} previous errors\", self.err_count())\n+        };\n+\n+        let _ = self.fatal(&s);\n \n         let can_show_explain = self.emitter.borrow().should_show_explain();\n         let are_there_diagnostics = !self.tracked_diagnostic_codes.borrow().is_empty();\n@@ -603,8 +597,16 @@ impl Handler {\n                 }\n             }\n         }\n+    }\n \n-        err.raise();\n+    pub fn abort_if_errors(&self) {\n+        if self.err_count() == 0 {\n+            if let Some(bug) = self.delayed_span_bug.borrow_mut().take() {\n+                DiagnosticBuilder::new_diagnostic(self, bug).emit();\n+            }\n+            return;\n+        }\n+        FatalError.raise();\n     }\n     pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n         if lvl == Warning && !self.flags.can_emit_warnings {"}, {"sha": "8765d9d8c2bed801be9dbc4aca1819aa06452f76", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -226,16 +226,6 @@ impl CrateMetadata {\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-     pub fn has_copy_closures(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_feature_attr(&attrs, \"copy_closures\")\n-    }\n-\n-    pub fn has_clone_closures(&self, sess: &Session) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n-        attr::contains_feature_attr(&attrs, \"clone_closures\")\n-    }\n-\n     pub fn panic_strategy(&self) -> PanicStrategy {\n         self.root.panic_strategy.clone()\n     }"}, {"sha": "5fd8ebaa9b4a6d3b4a32b399b61767db816b5b98", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -255,9 +255,6 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Lrc::new(cdata.source.clone()) }\n \n-    has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n-    has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n-\n     exported_symbols => {\n         let cnum = cdata.cnum;\n         assert!(cnum != LOCAL_CRATE);"}, {"sha": "e938d5c1a97fe4e9d1ff6e0ad4c44e9b448ddd0a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -14,7 +14,8 @@ use cstore::{self, CrateMetadata, MetadataBlob, NativeLibrary, ForeignModule};\n use schema::*;\n \n use rustc_data_structures::sync::{Lrc, ReadGuard};\n-use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n+use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash,\n+                      DisambiguatedDefPathData};\n use rustc::hir;\n use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n                             ExternBodyNestedBodies};\n@@ -1125,7 +1126,23 @@ impl<'a, 'tcx> CrateMetadata {\n \n     #[inline]\n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.def_path_table.def_key(index)\n+        if !self.is_proc_macro(index) {\n+            self.def_path_table.def_key(index)\n+        } else {\n+            // FIXME(#49271) - It would be better if the DefIds were consistent\n+            //                 with the DefPathTable, but for proc-macro crates\n+            //                 they aren't.\n+            let name = self.proc_macros\n+                           .as_ref()\n+                           .unwrap()[index.to_proc_macro_index()].0;\n+            DefKey {\n+                parent: Some(CRATE_DEF_INDEX),\n+                disambiguated_data: DisambiguatedDefPathData {\n+                    data: DefPathData::MacroDef(name.as_str()),\n+                    disambiguator: 0,\n+                }\n+            }\n+        }\n     }\n \n     // Returns the path leading to the thing with this `id`."}, {"sha": "4f36c3888b961fe75711a18696cc083645ee52b3", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -2247,7 +2247,7 @@ let mut b = || {\n     yield (); // ...is still in scope here, when the yield occurs.\n     println!(\"{}\", a);\n };\n-b.resume();\n+unsafe { b.resume() };\n ```\n \n At present, it is not permitted to have a yield that occurs while a\n@@ -2265,7 +2265,7 @@ let mut b = || {\n     yield ();\n     println!(\"{}\", a);\n };\n-b.resume();\n+unsafe { b.resume() };\n ```\n \n This is a very simple case, of course. In more complex cases, we may\n@@ -2283,7 +2283,7 @@ let mut b = || {\n     yield x; // ...when this yield occurs.\n   }\n };\n-b.resume();\n+unsafe { b.resume() };\n ```\n \n Such cases can sometimes be resolved by iterating \"by value\" (or using\n@@ -2298,7 +2298,7 @@ let mut b = || {\n     yield x; // <-- Now yield is OK.\n   }\n };\n-b.resume();\n+unsafe { b.resume() };\n ```\n \n If taking ownership is not an option, using indices can work too:\n@@ -2314,7 +2314,7 @@ let mut b = || {\n     yield x; // <-- Now yield is OK.\n   }\n };\n-b.resume();\n+unsafe { b.resume() };\n \n // (*) -- Unfortunately, these temporaries are currently required.\n // See <https://github.com/rust-lang/rust/issues/43122>."}, {"sha": "b8bfcd756cd231d711c9c5880e6af8a2947e9c0c", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,22 +1,23 @@\n-use std::collections::HashSet;\n use std::fmt::Write;\n \n use rustc::hir::def_id::DefId;\n+use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::middle::const_val::{ConstVal, ErrKind};\n use rustc::mir;\n use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::maps::TyCtxtAt;\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::middle::const_val::FrameInfo;\n use syntax::codemap::{self, Span};\n use syntax::ast::Mutability;\n use rustc::mir::interpret::{\n     GlobalId, Value, Pointer, PrimVal, PrimValKind,\n     EvalError, EvalResult, EvalErrorKind, MemoryPointer,\n };\n+use std::mem;\n \n use super::{Place, PlaceExtra, Memory,\n             HasMemory, MemoryKind,\n@@ -71,12 +72,12 @@ pub struct Frame<'mir, 'tcx: 'mir> {\n     pub return_place: Place,\n \n     /// The list of locals for this stack frame, stored in order as\n-    /// `[arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n+    /// `[return_ptr, arguments..., variables..., temporaries...]`. The locals are stored as `Option<Value>`s.\n     /// `None` represents a local that is currently dead, while a live local\n     /// can either directly contain `PrimVal` or refer to some part of an `Allocation`.\n     ///\n     /// Before being initialized, arguments are `Value::ByVal(PrimVal::Undef)` and other locals are `None`.\n-    pub locals: Vec<Option<Value>>,\n+    pub locals: IndexVec<mir::Local, Option<Value>>,\n \n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n@@ -383,39 +384,29 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     ) -> EvalResult<'tcx> {\n         ::log_settings::settings().indentation += 1;\n \n-        /// Return the set of locals that have a storage annotation anywhere\n-        fn collect_storage_annotations<'mir, 'tcx>(mir: &'mir mir::Mir<'tcx>) -> HashSet<mir::Local> {\n-            use rustc::mir::StatementKind::*;\n-\n-            let mut set = HashSet::new();\n-            for block in mir.basic_blocks() {\n-                for stmt in block.statements.iter() {\n-                    match stmt.kind {\n-                        StorageLive(local) |\n-                        StorageDead(local) => {\n-                            set.insert(local);\n+        let locals = if mir.local_decls.len() > 1 {\n+            let mut locals = IndexVec::from_elem(Some(Value::ByVal(PrimVal::Undef)), &mir.local_decls);\n+            match self.tcx.describe_def(instance.def_id()) {\n+                // statics and constants don't have `Storage*` statements, no need to look for them\n+                Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n+                _ => {\n+                    trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n+                    for block in mir.basic_blocks() {\n+                        for stmt in block.statements.iter() {\n+                            use rustc::mir::StatementKind::{StorageDead, StorageLive};\n+                            match stmt.kind {\n+                                StorageLive(local) |\n+                                StorageDead(local) => locals[local] = None,\n+                                _ => {}\n+                            }\n                         }\n-                        _ => {}\n                     }\n-                }\n-            }\n-            set\n-        }\n-\n-        // Subtract 1 because `local_decls` includes the ReturnMemoryPointer, but we don't store a local\n-        // `Value` for that.\n-        let num_locals = mir.local_decls.len() - 1;\n-\n-        let locals = {\n-            let annotated_locals = collect_storage_annotations(mir);\n-            let mut locals = vec![None; num_locals];\n-            for i in 0..num_locals {\n-                let local = mir::Local::new(i + 1);\n-                if !annotated_locals.contains(&local) {\n-                    locals[i] = Some(Value::ByVal(PrimVal::Undef));\n-                }\n+                },\n             }\n             locals\n+        } else {\n+            // don't allocate at all for trivial constants\n+            IndexVec::new()\n         };\n \n         self.stack.push(Frame {\n@@ -973,8 +964,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n         let new_place = match place {\n             Place::Local { frame, local } => {\n-                // -1 since we don't store the return value\n-                match self.stack[frame].locals[local.index() - 1] {\n+                match self.stack[frame].locals[local] {\n                     None => return err!(DeadLocal),\n                     Some(Value::ByRef(ptr, align)) => {\n                         Place::Ptr {\n@@ -988,7 +978,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                         let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n                         let layout = self.layout_of(ty)?;\n                         let ptr = self.alloc_ptr(ty)?;\n-                        self.stack[frame].locals[local.index() - 1] =\n+                        self.stack[frame].locals[local] =\n                             Some(Value::ByRef(ptr.into(), layout.align)); // it stays live\n                         let place = Place::from_ptr(ptr, layout.align);\n                         self.write_value(ValTy { value: val, ty }, place)?;\n@@ -1702,13 +1692,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n     pub fn get_local(&self, local: mir::Local) -> EvalResult<'tcx, Value> {\n-        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        self.locals[local.index() - 1].ok_or(EvalErrorKind::DeadLocal.into())\n+        self.locals[local].ok_or(EvalErrorKind::DeadLocal.into())\n     }\n \n     fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n-        // Subtract 1 because we don't store a value for the ReturnPointer, the local with index 0.\n-        match self.locals[local.index() - 1] {\n+        match self.locals[local] {\n             None => err!(DeadLocal),\n             Some(ref mut local) => {\n                 *local = value;\n@@ -1717,20 +1705,17 @@ impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n         }\n     }\n \n-    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn storage_live(&mut self, local: mir::Local) -> Option<Value> {\n         trace!(\"{:?} is now live\", local);\n \n-        let old = self.locals[local.index() - 1];\n-        self.locals[local.index() - 1] = Some(Value::ByVal(PrimVal::Undef)); // StorageLive *always* kills the value that's currently stored\n-        return Ok(old);\n+        // StorageLive *always* kills the value that's currently stored\n+        mem::replace(&mut self.locals[local], Some(Value::ByVal(PrimVal::Undef)))\n     }\n \n     /// Returns the old value of the local\n-    pub fn storage_dead(&mut self, local: mir::Local) -> EvalResult<'tcx, Option<Value>> {\n+    pub fn storage_dead(&mut self, local: mir::Local) -> Option<Value> {\n         trace!(\"{:?} is now dead\", local);\n \n-        let old = self.locals[local.index() - 1];\n-        self.locals[local.index() - 1] = None;\n-        return Ok(old);\n+        self.locals[local].take()\n     }\n }"}, {"sha": "4026f52e9620dd3a6cc2691c19a51fe083a6fb68", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,12 +1,13 @@\n use byteorder::{ReadBytesExt, WriteBytesExt, LittleEndian, BigEndian};\n-use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n+use std::collections::{btree_map, BTreeMap, VecDeque};\n use std::{ptr, io};\n \n use rustc::ty::Instance;\n use rustc::ty::maps::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout};\n use syntax::ast::Mutability;\n \n+use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use rustc::mir::interpret::{MemoryPointer, AllocId, Allocation, AccessKind, UndefMask, Value, Pointer,\n                             EvalResult, PrimVal, EvalErrorKind};\n \n@@ -33,15 +34,15 @@ pub struct Memory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     pub data: M::MemoryData,\n \n     /// Helps guarantee that stack allocations aren't deallocated via `rust_deallocate`\n-    alloc_kind: HashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n+    alloc_kind: FxHashMap<AllocId, MemoryKind<M::MemoryKinds>>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n-    alloc_map: HashMap<AllocId, Allocation>,\n+    alloc_map: FxHashMap<AllocId, Allocation>,\n \n     /// Actual memory allocations (arbitrary bytes, may contain pointers into other allocations).\n     ///\n     /// Stores statics while they are being processed, before they are interned and thus frozen\n-    uninitialized_statics: HashMap<AllocId, Allocation>,\n+    uninitialized_statics: FxHashMap<AllocId, Allocation>,\n \n     /// The current stack frame.  Used to check accesses against locks.\n     pub cur_frame: usize,\n@@ -53,9 +54,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'a, 'tcx, 'tcx>, data: M::MemoryData) -> Self {\n         Memory {\n             data,\n-            alloc_kind: HashMap::new(),\n-            alloc_map: HashMap::new(),\n-            uninitialized_statics: HashMap::new(),\n+            alloc_kind: FxHashMap::default(),\n+            alloc_map: FxHashMap::default(),\n+            uninitialized_statics: FxHashMap::default(),\n             tcx,\n             cur_frame: usize::max_value(),\n         }\n@@ -338,7 +339,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n         let mut allocs_to_print = VecDeque::from(allocs);\n-        let mut allocs_seen = HashSet::new();\n+        let mut allocs_seen = FxHashSet::default();\n \n         while let Some(id) = allocs_to_print.pop_front() {\n             let mut msg = format!(\"Alloc {:<5} \", format!(\"{}:\", id));"}, {"sha": "a22572ec687c3cf05a90177aa0b41d96cb585143", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -69,13 +69,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             // Mark locals as alive\n             StorageLive(local) => {\n-                let old_val = self.frame_mut().storage_live(local)?;\n+                let old_val = self.frame_mut().storage_live(local);\n                 self.deallocate_local(old_val)?;\n             }\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.frame_mut().storage_dead(local)?;\n+                let old_val = self.frame_mut().storage_dead(local);\n                 self.deallocate_local(old_val)?;\n             }\n "}, {"sha": "31af7c21857947853b7d7d8a0227c3572116c360", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -126,21 +126,13 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 &AggregateKind::Array(..) |\n                 &AggregateKind::Tuple |\n                 &AggregateKind::Adt(..) => {}\n-                &AggregateKind::Closure(def_id, _) => {\n+                &AggregateKind::Closure(def_id, _) |\n+                &AggregateKind::Generator(def_id, _, _) => {\n                     let UnsafetyCheckResult {\n                         violations, unsafe_blocks\n                     } = self.tcx.unsafety_check_result(def_id);\n                     self.register_violations(&violations, &unsafe_blocks);\n                 }\n-                &AggregateKind::Generator(def_id, _, interior) => {\n-                    let UnsafetyCheckResult {\n-                        violations, unsafe_blocks\n-                    } = self.tcx.unsafety_check_result(def_id);\n-                    self.register_violations(&violations, &unsafe_blocks);\n-                    if !interior.movable {\n-                        self.require_unsafe(\"construction of immovable generator\")\n-                    }\n-                }\n             }\n         }\n         self.super_rvalue(rvalue, location);"}, {"sha": "203e273c98eaafdc2a9afaa174a1e2e65226d81c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -779,7 +779,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n \n                     // HACK(eddyb) LLVM inserts `llvm.assume` calls when inlining functions\n                     // with align attributes, and those calls later block optimizations.\n-                    if !is_return {\n+                    if !is_return && !cx.tcx.sess.opts.debugging_opts.arg_align_attributes {\n                         attrs.pointee_align = None;\n                     }\n "}, {"sha": "0e93277983f8d9fa8400190d15d8c511cd48069b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -27,6 +27,7 @@ use std::slice;\n use require_c_abi_if_variadic;\n use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n+use errors::FatalError;\n \n use std::iter;\n use syntax::{abi, ast};\n@@ -337,7 +338,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             Def::Trait(trait_def_id) => trait_def_id,\n             Def::TraitAlias(alias_def_id) => alias_def_id,\n             Def::Err => {\n-                self.tcx().sess.fatal(\"cannot continue compilation due to previous error\");\n+                FatalError.raise();\n             }\n             _ => unreachable!(),\n         }"}, {"sha": "f820b0ba16b3004a864d4f0f5354e14960699fb1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1130,25 +1130,23 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n     }\n     fcx.demand_suptype(span, ret_ty, actual_return_ty);\n \n-    if fcx.tcx.features().termination_trait {\n-        // If the termination trait language item is activated, check that the main return type\n-        // implements the termination trait.\n-        if let Some(term_id) = fcx.tcx.lang_items().termination() {\n-            if let Some((id, _)) = *fcx.tcx.sess.entry_fn.borrow() {\n-                if id == fn_id {\n-                    match fcx.sess().entry_type.get() {\n-                        Some(config::EntryMain) => {\n-                            let substs = fcx.tcx.mk_substs(iter::once(Kind::from(ret_ty)));\n-                            let trait_ref = ty::TraitRef::new(term_id, substs);\n-                            let cause = traits::ObligationCause::new(\n-                                span, fn_id, ObligationCauseCode::MainFunctionType);\n-\n-                            inherited.register_predicate(\n-                                traits::Obligation::new(\n-                                    cause, param_env, trait_ref.to_predicate()));\n-                        },\n-                        _ => {},\n-                    }\n+    // Check that the main return type implements the termination trait.\n+    if let Some(term_id) = fcx.tcx.lang_items().termination() {\n+        if let Some((id, _)) = *fcx.tcx.sess.entry_fn.borrow() {\n+            if id == fn_id {\n+                match fcx.sess().entry_type.get() {\n+                    Some(config::EntryMain) => {\n+                        let substs = fcx.tcx.mk_substs(iter::once(Kind::from(ret_ty)));\n+                        let trait_ref = ty::TraitRef::new(term_id, substs);\n+                        let return_ty_span = decl.output.span();\n+                        let cause = traits::ObligationCause::new(\n+                            return_ty_span, fn_id, ObligationCauseCode::MainFunctionType);\n+\n+                        inherited.register_predicate(\n+                            traits::Obligation::new(\n+                                cause, param_env, trait_ref.to_predicate()));\n+                    },\n+                    _ => {},\n                 }\n             }\n         }"}, {"sha": "5a7de6b56b5000586c41b63d1e97ee4ea1434503", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -76,7 +76,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n-#![feature(copy_closures, clone_closures)]\n+#![cfg_attr(stage0, feature(copy_closures, clone_closures))]\n #![feature(crate_visibility_modifier)]\n #![feature(from_ref)]\n #![feature(match_default_bindings)]\n@@ -208,8 +208,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n \n             let actual = tcx.fn_sig(main_def_id);\n-            let expected_return_type = if tcx.lang_items().termination().is_some()\n-                && tcx.features().termination_trait {\n+            let expected_return_type = if tcx.lang_items().termination().is_some() {\n                 // we take the return type of the given main function, the real check is done\n                 // in `check_fn`\n                 actual.output().skip_binder()"}, {"sha": "6c6c067f95189ab4ce608a8f8454708f4e7222d3", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -49,6 +49,13 @@\n \n     var themesWidth = null;\n \n+    if (!String.prototype.startsWith) {\n+        String.prototype.startsWith = function(searchString, position) {\n+            position = position || 0;\n+            return this.indexOf(searchString, position) === position;\n+        };\n+    }\n+\n     function hasClass(elem, className) {\n         if (elem && className && elem.className) {\n             var elemClass = elem.className;"}, {"sha": "ceb019bc95b4c3588cadf9803914284989aae7c6", "filename": "src/libstd/f32.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff32.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -780,7 +780,7 @@ impl f32 {\n         unsafe { cmath::atanf(self) }\n     }\n \n-    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n+    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n     ///\n     /// * `x = 0`, `y = 0`: `0`\n     /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n@@ -791,12 +791,13 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let pi = f32::consts::PI;\n-    /// // All angles from horizontal right (+x)\n-    /// // 45 deg counter-clockwise\n+    /// // Positive angles measured counter-clockwise\n+    /// // from positive x axis\n+    /// // -pi/4 radians (45 deg clockwise)\n     /// let x1 = 3.0f32;\n     /// let y1 = -3.0f32;\n     ///\n-    /// // 135 deg clockwise\n+    /// // 3pi/4 radians (135 deg counter-clockwise)\n     /// let x2 = -3.0f32;\n     /// let y2 = 3.0f32;\n     ///"}, {"sha": "97adf108b73b0be4f6a2970b56011d29195836a7", "filename": "src/libstd/f64.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ff64.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -716,7 +716,7 @@ impl f64 {\n         unsafe { cmath::atan(self) }\n     }\n \n-    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`).\n+    /// Computes the four quadrant arctangent of `self` (`y`) and `other` (`x`) in radians.\n     ///\n     /// * `x = 0`, `y = 0`: `0`\n     /// * `x >= 0`: `arctan(y/x)` -> `[-pi/2, pi/2]`\n@@ -727,12 +727,13 @@ impl f64 {\n     /// use std::f64;\n     ///\n     /// let pi = f64::consts::PI;\n-    /// // All angles from horizontal right (+x)\n-    /// // 45 deg counter-clockwise\n+    /// // Positive angles measured counter-clockwise\n+    /// // from positive x axis\n+    /// // -pi/4 radians (45 deg clockwise)\n     /// let x1 = 3.0_f64;\n     /// let y1 = -3.0_f64;\n     ///\n-    /// // 135 deg clockwise\n+    /// // 3pi/4 radians (135 deg counter-clockwise)\n     /// let x2 = -3.0_f64;\n     /// let y2 = 3.0_f64;\n     ///"}, {"sha": "5caa703ee97e39e39de31cebd90b6b3b6ebad7a8", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -906,7 +906,13 @@ impl Metadata {\n         FileType(self.0.file_type())\n     }\n \n-    /// Returns whether this metadata is for a directory.\n+    /// Returns whether this metadata is for a directory. The\n+    /// result is mutually exclusive to the result of\n+    /// [`is_file`], and will be false for symlink metadata\n+    /// obtained from [`symlink_metadata`].\n+    ///\n+    /// [`is_file`]: struct.Metadata.html#method.is_file\n+    /// [`symlink_metadata`]: fn.symlink_metadata.html\n     ///\n     /// # Examples\n     ///\n@@ -923,7 +929,13 @@ impl Metadata {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_dir(&self) -> bool { self.file_type().is_dir() }\n \n-    /// Returns whether this metadata is for a regular file.\n+    /// Returns whether this metadata is for a regular file. The\n+    /// result is mutually exclusive to the result of\n+    /// [`is_dir`], and will be false for symlink metadata\n+    /// obtained from [`symlink_metadata`].\n+    ///\n+    /// [`is_dir`]: struct.Metadata.html#method.is_dir\n+    /// [`symlink_metadata`]: fn.symlink_metadata.html\n     ///\n     /// # Examples\n     ///\n@@ -1148,7 +1160,13 @@ impl Permissions {\n }\n \n impl FileType {\n-    /// Test whether this file type represents a directory.\n+    /// Test whether this file type represents a directory. The\n+    /// result is mutually exclusive to the results of\n+    /// [`is_file`] and [`is_symlink`]; only zero or one of these\n+    /// tests may pass.\n+    ///\n+    /// [`is_file`]: struct.FileType.html#method.is_file\n+    /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n     ///\n     /// # Examples\n     ///\n@@ -1167,6 +1185,12 @@ impl FileType {\n     pub fn is_dir(&self) -> bool { self.0.is_dir() }\n \n     /// Test whether this file type represents a regular file.\n+    /// The result is  mutually exclusive to the results of\n+    /// [`is_dir`] and [`is_symlink`]; only zero or one of these\n+    /// tests may pass.\n+    ///\n+    /// [`is_dir`]: struct.FileType.html#method.is_dir\n+    /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n     ///\n     /// # Examples\n     ///\n@@ -1185,6 +1209,9 @@ impl FileType {\n     pub fn is_file(&self) -> bool { self.0.is_file() }\n \n     /// Test whether this file type represents a symbolic link.\n+    /// The result is mutually exclusive to the results of\n+    /// [`is_dir`] and [`is_file`]; only zero or one of these\n+    /// tests may pass.\n     ///\n     /// The underlying [`Metadata`] struct needs to be retrieved\n     /// with the [`fs::symlink_metadata`] function and not the\n@@ -1195,6 +1222,8 @@ impl FileType {\n     /// [`Metadata`]: struct.Metadata.html\n     /// [`fs::metadata`]: fn.metadata.html\n     /// [`fs::symlink_metadata`]: fn.symlink_metadata.html\n+    /// [`is_dir`]: struct.FileType.html#method.is_dir\n+    /// [`is_file`]: struct.FileType.html#method.is_file\n     /// [`is_symlink`]: struct.FileType.html#method.is_symlink\n     ///\n     /// # Examples"}, {"sha": "0b06c5d4d656e03ad5d5d898ae7a8c0096dfc4f8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -308,7 +308,6 @@\n #![feature(str_char)]\n #![feature(str_internals)]\n #![feature(str_utf16)]\n-#![feature(termination_trait)]\n #![feature(test, rustc_private)]\n #![feature(thread_local)]\n #![feature(toowned_clone_into)]\n@@ -325,6 +324,7 @@\n #![cfg_attr(test, feature(update_panic_count))]\n #![cfg_attr(windows, feature(used))]\n #![cfg_attr(stage0, feature(never_type))]\n+#![cfg_attr(stage0, feature(termination_trait))]\n \n #![default_lib_allocator]\n "}, {"sha": "47609f17221ef5dd9ce17cb07dfaf9e2b4dc2c4a", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -335,6 +335,18 @@ pub mod builtin {\n     /// proxied through this one.  `format_args!`, unlike its derived macros, avoids\n     /// heap allocations.\n     ///\n+    /// You can use the [`fmt::Arguments`] value that `format_args!` returns\n+    /// in `Debug` and `Display` contexts as seen below. The example also shows\n+    /// that `Debug` and `Display` format to the same thing: the interpolated\n+    /// format string in `format_args!`.\n+    ///\n+    /// ```rust\n+    /// let display = format!(\"{:?}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// let debug = format!(\"{}\", format_args!(\"{} foo {:?}\", 1, 2));\n+    /// assert_eq!(\"1 foo 2\", display);\n+    /// assert_eq!(display, debug);\n+    /// ```\n+    ///\n     /// For more information, see the documentation in [`std::fmt`].\n     ///\n     /// [`Display`]: ../std/fmt/trait.Display.html"}, {"sha": "c877bf6aa35cdb1734ea9ebeb881fa5fba69650a", "filename": "src/libstd/process.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1442,8 +1442,9 @@ pub fn id() -> u32 {\n /// a successful execution. In case of a failure, `libc::EXIT_FAILURE` is returned.\n #[cfg_attr(not(test), lang = \"termination\")]\n #[unstable(feature = \"termination_trait_lib\", issue = \"43301\")]\n-#[rustc_on_unimplemented =\n-  \"`main` can only return types that implement {Termination}, not `{Self}`\"]\n+#[rustc_on_unimplemented(\n+  message=\"`main` has invalid return type `{Self}`\",\n+  label=\"`main` can only return types that implement {Termination}\")]\n pub trait Termination {\n     /// Is called to get the representation of the value as status code.\n     /// This status code is returned to the operating system."}, {"sha": "e69dace0c705194d9277665c717c0714a6300bfa", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -391,10 +391,6 @@ declare_features! (\n     // Future-proofing enums/structs with #[non_exhaustive] attribute (RFC 2008)\n     (active, non_exhaustive, \"1.22.0\", Some(44109), None),\n \n-    // Copy/Clone closures (RFC 2132)\n-    (active, clone_closures, \"1.22.0\", Some(44490), None),\n-    (active, copy_closures, \"1.22.0\", Some(44490), None),\n-\n     // allow `'_` placeholder lifetimes\n     (active, underscore_lifetimes, \"1.22.0\", Some(44524), None),\n \n@@ -428,8 +424,8 @@ declare_features! (\n     // `foo.rs` as an alternative to `foo/mod.rs`\n     (active, non_modrs_mods, \"1.24.0\", Some(44660), None),\n \n-    // Termination trait in main (RFC 1937)\n-    (active, termination_trait, \"1.24.0\", Some(43301), None),\n+    // Termination trait in tests (RFC 1937)\n+    (active, termination_trait_test, \"1.24.0\", Some(48854), None),\n \n     // Allows use of the :lifetime macro fragment specifier\n     (active, macro_lifetime_matcher, \"1.24.0\", Some(46895), None),\n@@ -565,6 +561,11 @@ declare_features! (\n     (accepted, inclusive_range_syntax, \"1.26.0\", Some(28237), None),\n     // allow `..=` in patterns (RFC 1192)\n     (accepted, dotdoteq_in_patterns, \"1.26.0\", Some(28237), None),\n+    // Termination trait in main (RFC 1937)\n+    (accepted, termination_trait, \"1.26.0\", Some(43301), None),\n+    // Copy/Clone closures (RFC 2132)\n+    (accepted, clone_closures, \"1.26.0\", Some(44490), None),\n+    (accepted, copy_closures, \"1.26.0\", Some(44490), None),\n );\n \n // If you change this, please modify src/doc/unstable-book as well. You must\n@@ -1885,8 +1886,6 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n struct FeatureChecker {\n     proc_macro: Option<Span>,\n     custom_attribute: Option<Span>,\n-    copy_closures: Option<Span>,\n-    clone_closures: Option<Span>,\n }\n \n impl FeatureChecker {\n@@ -1902,14 +1901,6 @@ impl FeatureChecker {\n         if features.custom_attribute {\n             self.custom_attribute = self.custom_attribute.or(Some(span));\n         }\n-\n-        if features.copy_closures {\n-            self.copy_closures = self.copy_closures.or(Some(span));\n-        }\n-\n-        if features.clone_closures {\n-            self.clone_closures = self.clone_closures.or(Some(span));\n-        }\n     }\n \n     fn check(self, handler: &Handler) {\n@@ -1921,15 +1912,6 @@ impl FeatureChecker {\n \n             FatalError.raise();\n         }\n-\n-        if let (Some(span), None) = (self.copy_closures, self.clone_closures) {\n-            handler.struct_span_err(span, \"`#![feature(copy_closures)]` can only be used with \\\n-                                           `#![feature(clone_closures)]`\")\n-                  .span_note(span, \"`#![feature(copy_closures)]` declared here\")\n-                  .emit();\n-\n-            FatalError.raise();\n-        }\n     }\n }\n "}, {"sha": "98e2528d30f242ad4551b5adcb2630a2e0957800", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -3675,7 +3675,13 @@ impl<'a> Parser<'a> {\n                 if self.token != token::CloseDelim(token::Brace) {\n                     let token_str = self.this_token_to_string();\n                     let mut err = self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\", token_str));\n-                    err.span_label(self.span, \"expected `}`\");\n+                    if self.token == token::Comma { // Issue #49257\n+                        err.span_label(self.span,\n+                                       \"`..` must be in the last position, \\\n+                                        and cannot have a trailing comma\");\n+                    } else {\n+                        err.span_label(self.span, \"expected `}`\");\n+                    }\n                     return Err(err);\n                 }\n                 etc = true;"}, {"sha": "6c01171d1003e95424b5bb7f526752fb56deb0eb", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -332,7 +332,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n             ast::ItemKind::Fn(ref decl, _, _, _, ref generics, _) => {\n                 // If the termination trait is active, the compiler will check that the output\n                 // type implements the `Termination` trait as `libtest` enforces that.\n-                let output_matches = if cx.features.termination_trait {\n+                let output_matches = if cx.features.termination_trait_test {\n                     true\n                 } else {\n                     let no_output = match decl.output {\n@@ -359,7 +359,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n         match has_test_signature(cx, i) {\n             Yes => true,\n             No => {\n-                if cx.features.termination_trait {\n+                if cx.features.termination_trait_test {\n                     diag.span_err(i.span, \"functions used as tests can not have any arguments\");\n                 } else {\n                     diag.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n@@ -388,7 +388,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n                 // If the termination trait is active, the compiler will check that the output\n                 // type implements the `Termination` trait as `libtest` enforces that.\n-                let output_matches = if cx.features.termination_trait {\n+                let output_matches = if cx.features.termination_trait_test {\n                     true\n                 } else {\n                     let no_output = match decl.output {\n@@ -416,7 +416,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n     if has_bench_attr && !has_bench_signature {\n         let diag = cx.span_diagnostic;\n \n-        if cx.features.termination_trait {\n+        if cx.features.termination_trait_test {\n             diag.span_err(i.span, \"functions used as benches must have signature \\\n                                    `fn(&mut Bencher) -> impl Termination`\");\n         } else {"}, {"sha": "89235d897bde6bc218e2e95766506cd598d38fd7", "filename": "src/libtest/formatters/json.rs", "status": "modified", "additions": 19, "deletions": 30, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -36,17 +36,12 @@ impl<T: Write> JsonFormatter<T> {\n         if let Some(extras) = extra {\n             self.write_message(&*format!(\n                 r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n-                ty,\n-                name,\n-                evt,\n-                extras\n+                ty, name, evt, extras\n             ))\n         } else {\n             self.write_message(&*format!(\n                 r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n-                ty,\n-                name,\n-                evt\n+                ty, name, evt\n             ))\n         }\n     }\n@@ -89,14 +84,12 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n                 self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n             }\n \n-            TrFailedMsg(ref m) => {\n-                self.write_event(\n-                    \"test\",\n-                    desc.name.as_slice(),\n-                    \"failed\",\n-                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n-                )\n-            }\n+            TrFailedMsg(ref m) => self.write_event(\n+                \"test\",\n+                desc.name.as_slice(),\n+                \"failed\",\n+                Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+            ),\n \n             TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n \n@@ -116,13 +109,10 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n \n                 let line = format!(\n                     \"{{ \\\"type\\\": \\\"bench\\\", \\\n-                                \\\"name\\\": \\\"{}\\\", \\\n-                                \\\"median\\\": {}, \\\n-                                \\\"deviation\\\": {}{} }}\",\n-                    desc.name,\n-                    median,\n-                    deviation,\n-                    mbps\n+                     \\\"name\\\": \\\"{}\\\", \\\n+                     \\\"median\\\": {}, \\\n+                     \\\"deviation\\\": {}{} }}\",\n+                    desc.name, median, deviation, mbps\n                 );\n \n                 self.write_message(&*line)\n@@ -138,16 +128,15 @@ impl<T: Write> OutputFormatter for JsonFormatter<T> {\n     }\n \n     fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n-\n         self.write_message(&*format!(\n             \"{{ \\\"type\\\": \\\"suite\\\", \\\n-            \\\"event\\\": \\\"{}\\\", \\\n-            \\\"passed\\\": {}, \\\n-            \\\"failed\\\": {}, \\\n-            \\\"allowed_fail\\\": {}, \\\n-            \\\"ignored\\\": {}, \\\n-            \\\"measured\\\": {}, \\\n-            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+             \\\"event\\\": \\\"{}\\\", \\\n+             \\\"passed\\\": {}, \\\n+             \\\"failed\\\": {}, \\\n+             \\\"allowed_fail\\\": {}, \\\n+             \\\"ignored\\\": {}, \\\n+             \\\"measured\\\": {}, \\\n+             \\\"filtered_out\\\": \\\"{}\\\" }}\",\n             if state.failed == 0 { \"ok\" } else { \"failed\" },\n             state.passed,\n             state.failed + state.allowed_fail,"}, {"sha": "8e5fa00b5f27d6ebdded792cc7d072fe7ec8ea68", "filename": "src/libtest/formatters/pretty.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -196,8 +196,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n \n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name,\n-            TEST_WARN_TIMEOUT_S\n+            desc.name, TEST_WARN_TIMEOUT_S\n         ))\n     }\n \n@@ -232,11 +231,7 @@ impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n         } else {\n             format!(\n                 \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n             )\n         };\n "}, {"sha": "85286027d69210d49c4c399508d7a0bddb2d6392", "filename": "src/libtest/formatters/terse.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -195,8 +195,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n     fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n         self.write_plain(&format!(\n             \"test {} has been running for over {} seconds\\n\",\n-            desc.name,\n-            TEST_WARN_TIMEOUT_S\n+            desc.name, TEST_WARN_TIMEOUT_S\n         ))\n     }\n \n@@ -231,11 +230,7 @@ impl<T: Write> OutputFormatter for TerseFormatter<T> {\n         } else {\n             format!(\n                 \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                state.passed,\n-                state.failed,\n-                state.ignored,\n-                state.measured,\n-                state.filtered_out\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n             )\n         };\n "}, {"sha": "b8be1aeff174278244bca9fcfebc509c1fecb3f7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 145, "deletions": 180, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -30,10 +30,8 @@\n #![unstable(feature = \"test\", issue = \"27812\")]\n #![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       test(attr(deny(warnings))))]\n+       html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![deny(warnings)]\n-\n #![feature(asm)]\n #![feature(fnbox)]\n #![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc))]\n@@ -43,10 +41,10 @@\n #![feature(termination_trait_lib)]\n \n extern crate getopts;\n-extern crate term;\n #[cfg(any(unix, target_os = \"cloudabi\"))]\n extern crate libc;\n extern crate panic_unwind;\n+extern crate term;\n \n pub use self::TestFn::*;\n pub use self::ColorConfig::*;\n@@ -72,7 +70,7 @@ use std::process::Termination;\n use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n-use std::time::{Instant, Duration};\n+use std::time::{Duration, Instant};\n use std::borrow::Cow;\n use std::process;\n \n@@ -81,16 +79,16 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n \n // to be used by rustc to compile tests in libtest\n pub mod test {\n-    pub use {Bencher, TestName, TestResult, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n-             TrFailedMsg, TrIgnored, TrOk, Metric, MetricMap, StaticTestFn, StaticTestName,\n-             DynTestName, DynTestFn, assert_test_result, run_test, test_main, test_main_static,\n-             filter_tests, parse_opts, StaticBenchFn, ShouldPanic, Options};\n+    pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n+             TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n \n pub mod stats;\n mod formatters;\n \n-use formatters::{OutputFormatter, PrettyFormatter, TerseFormatter, JsonFormatter};\n+use formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -255,7 +253,9 @@ pub struct Options {\n \n impl Options {\n     pub fn new() -> Options {\n-        Options { display_output: false }\n+        Options {\n+            display_output: false,\n+        }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n@@ -272,7 +272,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n         Some(Err(msg)) => {\n             eprintln!(\"error: {}\", msg);\n             process::exit(101);\n-        },\n+        }\n         None => return,\n     };\n \n@@ -289,7 +289,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n             Err(e) => {\n                 eprintln!(\"error: io error when listing tests: {:?}\", e);\n                 process::exit(101);\n-            },\n+            }\n         }\n     }\n }\n@@ -306,18 +306,14 @@ pub fn test_main_static(tests: &[TestDescAndFn]) {\n     let owned_tests = tests\n         .iter()\n         .map(|t| match t.testfn {\n-            StaticTestFn(f) => {\n-                TestDescAndFn {\n-                    testfn: StaticTestFn(f),\n-                    desc: t.desc.clone(),\n-                }\n-            }\n-            StaticBenchFn(f) => {\n-                TestDescAndFn {\n-                    testfn: StaticBenchFn(f),\n-                    desc: t.desc.clone(),\n-                }\n-            }\n+            StaticTestFn(f) => TestDescAndFn {\n+                testfn: StaticTestFn(f),\n+                desc: t.desc.clone(),\n+            },\n+            StaticBenchFn(f) => TestDescAndFn {\n+                testfn: StaticBenchFn(f),\n+                desc: t.desc.clone(),\n+            },\n             _ => panic!(\"non-static tests passed to test::test_main_static\"),\n         })\n         .collect();\n@@ -397,34 +393,34 @@ fn optgroups() -> getopts::Options {\n             \"\",\n             \"logfile\",\n             \"Write logs to the specified file instead \\\n-                                of stdout\",\n+             of stdout\",\n             \"PATH\",\n         )\n         .optflag(\n             \"\",\n             \"nocapture\",\n             \"don't capture stdout/stderr of each \\\n-                                   task, allow printing directly\",\n+             task, allow printing directly\",\n         )\n         .optopt(\n             \"\",\n             \"test-threads\",\n             \"Number of threads used for running tests \\\n-                                     in parallel\",\n+             in parallel\",\n             \"n_threads\",\n         )\n         .optmulti(\n             \"\",\n             \"skip\",\n             \"Skip tests whose names contain FILTER (this flag can \\\n-                               be used multiple times)\",\n+             be used multiple times)\",\n             \"FILTER\",\n         )\n         .optflag(\n             \"q\",\n             \"quiet\",\n             \"Display one character per test instead of one line. \\\n-                                Alias to --format=terse\",\n+             Alias to --format=terse\",\n         )\n         .optflag(\n             \"\",\n@@ -516,8 +512,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     if let Some(opt) = matches.opt_str(\"Z\") {\n         if !is_nightly() {\n             return Some(Err(\n-                \"the option `Z` is only accepted on the nightly compiler\"\n-                    .into(),\n+                \"the option `Z` is only accepted on the nightly compiler\".into(),\n             ));\n         }\n \n@@ -562,19 +557,17 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     }\n \n     let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) => {\n-            match n_str.parse::<usize>() {\n-                Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n-                Ok(n) => Some(n),\n-                Err(e) => {\n-                    return Some(Err(format!(\n-                        \"argument for --test-threads must be a number > 0 \\\n-                                             (error: {})\",\n-                        e\n-                    )))\n-                }\n+        Some(n_str) => match n_str.parse::<usize>() {\n+            Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n+            Ok(n) => Some(n),\n+            Err(e) => {\n+                return Some(Err(format!(\n+                    \"argument for --test-threads must be a number > 0 \\\n+                     (error: {})\",\n+                    e\n+                )))\n             }\n-        }\n+        },\n         None => None,\n     };\n \n@@ -586,7 +579,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(v) => {\n             return Some(Err(format!(\n                 \"argument for --color must be auto, always, or never (was \\\n-                                     {})\",\n+                 {})\",\n                 v\n             )))\n         }\n@@ -599,8 +592,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"json\") => {\n             if !allow_unstable {\n                 return Some(Err(\n-                    \"The \\\"json\\\" format is only accepted on the nightly compiler\"\n-                        .into(),\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n                 ));\n             }\n             OutputFormat::Json\n@@ -609,7 +601,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(v) => {\n             return Some(Err(format!(\n                 \"argument for --format must be pretty, terse, or json (was \\\n-                                     {})\",\n+                 {})\",\n                 v\n             )))\n         }\n@@ -811,8 +803,7 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n                 ntest += 1;\n                 \"test\"\n             }\n-            StaticBenchFn(..) |\n-            DynBenchFn(..) => {\n+            StaticBenchFn(..) | DynBenchFn(..) => {\n                 nbench += 1;\n                 \"benchmark\"\n             }\n@@ -834,7 +825,8 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n             writeln!(output, \"\")?;\n         }\n \n-        writeln!(output,\n+        writeln!(\n+            output,\n             \"{}, {}\",\n             plural(ntest, \"test\"),\n             plural(nbench, \"benchmark\")\n@@ -851,7 +843,6 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         st: &mut ConsoleTestState,\n         out: &mut OutputFormatter,\n     ) -> io::Result<()> {\n-\n         match (*event).clone() {\n             TeFiltered(ref filtered_tests) => {\n                 st.total = filtered_tests.len();\n@@ -989,8 +980,7 @@ fn use_color(opts: &TestOpts) -> bool {\n     }\n }\n \n-#[cfg(any(target_os = \"cloudabi\",\n-          target_os = \"redox\",\n+#[cfg(any(target_os = \"cloudabi\", target_os = \"redox\",\n           all(target_arch = \"wasm32\", not(target_os = \"emscripten\"))))]\n fn stdout_isatty() -> bool {\n     // FIXME: Implement isatty on Redox\n@@ -1089,10 +1079,12 @@ where\n         let now = Instant::now();\n         let timed_out = running_tests\n             .iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout {\n-                Some(desc.clone())\n-            } else {\n-                None\n+            .filter_map(|(desc, timeout)| {\n+                if &now >= timeout {\n+                    Some(desc.clone())\n+                } else {\n+                    None\n+                }\n             })\n             .collect();\n         for test in &timed_out {\n@@ -1174,12 +1166,10 @@ fn get_concurrency() -> usize {\n             let opt_n: Option<usize> = s.parse().ok();\n             match opt_n {\n                 Some(n) if n > 0 => n,\n-                _ => {\n-                    panic!(\n-                        \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n-                        s\n-                    )\n-                }\n+                _ => panic!(\n+                    \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                    s\n+                ),\n             }\n         }\n         Err(..) => num_cpus(),\n@@ -1223,20 +1213,15 @@ fn get_concurrency() -> usize {\n         1\n     }\n \n-    #[cfg(any(target_os = \"android\",\n-              target_os = \"cloudabi\",\n-              target_os = \"emscripten\",\n-              target_os = \"fuchsia\",\n-              target_os = \"ios\",\n-              target_os = \"linux\",\n-              target_os = \"macos\",\n-              target_os = \"solaris\"))]\n+    #[cfg(any(target_os = \"android\", target_os = \"cloudabi\", target_os = \"emscripten\",\n+              target_os = \"fuchsia\", target_os = \"ios\", target_os = \"linux\",\n+              target_os = \"macos\", target_os = \"solaris\"))]\n     fn num_cpus() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n     #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"bitrig\",\n-                target_os = \"netbsd\"))]\n+              target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n         use std::ptr;\n \n@@ -1308,26 +1293,28 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     // Remove tests that don't match the test filter\n     filtered = match opts.filter {\n         None => filtered,\n-        Some(ref filter) => {\n-            filtered\n-                .into_iter()\n-                .filter(|test| if opts.filter_exact {\n+        Some(ref filter) => filtered\n+            .into_iter()\n+            .filter(|test| {\n+                if opts.filter_exact {\n                     test.desc.name.as_slice() == &filter[..]\n                 } else {\n                     test.desc.name.as_slice().contains(&filter[..])\n-                })\n-                .collect()\n-        }\n+                }\n+            })\n+            .collect(),\n     };\n \n     // Skip tests that match any of the skip filters\n     filtered = filtered\n         .into_iter()\n         .filter(|t| {\n-            !opts.skip.iter().any(|sf| if opts.filter_exact {\n-                t.desc.name.as_slice() == &sf[..]\n-            } else {\n-                t.desc.name.as_slice().contains(&sf[..])\n+            !opts.skip.iter().any(|sf| {\n+                if opts.filter_exact {\n+                    t.desc.name.as_slice() == &sf[..]\n+                } else {\n+                    t.desc.name.as_slice().contains(&sf[..])\n+                }\n             })\n         })\n         .collect();\n@@ -1354,31 +1341,23 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     };\n \n     // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| {\n-        t1.desc.name.as_slice().cmp(t2.desc.name.as_slice())\n-    });\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n \n     filtered\n }\n \n pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     // convert benchmarks to tests, if we're not benchmarking them\n-    tests.into_iter().map(|x| {\n-        let testfn = match x.testfn {\n-            DynBenchFn(bench) => {\n-                DynTestFn(Box::new(move || {\n-                    bench::run_once(|b| {\n-                        __rust_begin_short_backtrace(|| bench.run(b))\n-                    })\n-                }))\n-            }\n-            StaticBenchFn(benchfn) => {\n-                DynTestFn(Box::new(move || {\n-                    bench::run_once(|b| {\n-                        __rust_begin_short_backtrace(|| benchfn(b))\n-                    })\n-                }))\n-            }\n+    tests\n+        .into_iter()\n+        .map(|x| {\n+            let testfn = match x.testfn {\n+                DynBenchFn(bench) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n+                })),\n+                StaticBenchFn(benchfn) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n+                })),\n                 f => f,\n             };\n             TestDescAndFn {\n@@ -1395,22 +1374,22 @@ pub fn run_test(\n     test: TestDescAndFn,\n     monitor_ch: Sender<MonitorMsg>,\n ) {\n-\n     let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") &&\n-        !cfg!(target_os = \"emscripten\") &&\n-        desc.should_panic != ShouldPanic::No;\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") && !cfg!(target_os = \"emscripten\")\n+        && desc.should_panic != ShouldPanic::No;\n \n     if force_ignore || desc.ignore || ignore_because_panic_abort {\n         monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n         return;\n     }\n \n-    fn run_test_inner(desc: TestDesc,\n-                      monitor_ch: Sender<MonitorMsg>,\n-                      nocapture: bool,\n-                      testfn: Box<FnBox() + Send>) {\n+    fn run_test_inner(\n+        desc: TestDesc,\n+        monitor_ch: Sender<MonitorMsg>,\n+        nocapture: bool,\n+        testfn: Box<FnBox() + Send>,\n+    ) {\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let data2 = data.clone();\n@@ -1440,7 +1419,6 @@ pub fn run_test(\n                 .unwrap();\n         };\n \n-\n         // If the platform is single-threaded we're just going to run\n         // the test synchronously, regardless of the concurrency\n         // level.\n@@ -1455,27 +1433,25 @@ pub fn run_test(\n \n     match testfn {\n         DynBenchFn(bencher) => {\n-            ::bench::benchmark(desc,\n-                                monitor_ch,\n-                                opts.nocapture,\n-                                |harness| bencher.run(harness));\n+            ::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                bencher.run(harness)\n+            });\n         }\n         StaticBenchFn(benchfn) => {\n-            ::bench::benchmark(desc,\n-                                monitor_ch,\n-                                opts.nocapture,\n-                                |harness| (benchfn.clone())(harness));\n+            ::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                (benchfn.clone())(harness)\n+            });\n         }\n         DynTestFn(f) => {\n-            let cb = move || {\n-                __rust_begin_short_backtrace(f)\n-            };\n+            let cb = move || __rust_begin_short_backtrace(f);\n             run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n         }\n-        StaticTestFn(f) => {\n-            run_test_inner(desc, monitor_ch, opts.nocapture,\n-                           Box::new(move || __rust_begin_short_backtrace(f)))\n-        }\n+        StaticTestFn(f) => run_test_inner(\n+            desc,\n+            monitor_ch,\n+            opts.nocapture,\n+            Box::new(move || __rust_begin_short_backtrace(f)),\n+        ),\n     }\n }\n \n@@ -1487,8 +1463,7 @@ fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n \n fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> TestResult {\n     match (&desc.should_panic, task_result) {\n-        (&ShouldPanic::No, Ok(())) |\n-        (&ShouldPanic::Yes, Err(_)) => TrOk,\n+        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n         (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n             if err.downcast_ref::<String>()\n                 .map(|e| &**e)\n@@ -1545,7 +1520,6 @@ impl MetricMap {\n     }\n }\n \n-\n // Benchmarking\n \n /// A function that is opaque to the optimizer, to allow benchmarks to\n@@ -1566,7 +1540,6 @@ pub fn black_box<T>(dummy: T) -> T {\n     dummy\n }\n \n-\n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n     pub fn iter<T, F>(&mut self, mut inner: F)\n@@ -1605,7 +1578,6 @@ where\n     return ns_from_dur(start.elapsed());\n }\n \n-\n pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n where\n     F: FnMut() -> T,\n@@ -1649,8 +1621,8 @@ where\n \n         // If we've run for 100ms and seem to have converged to a\n         // stable median.\n-        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n-            summ.median - summ5.median < summ5.median_abs_dev\n+        if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0\n+            && summ.median - summ5.median < summ5.median_abs_dev\n         {\n             return summ5;\n         }\n@@ -1680,7 +1652,7 @@ pub mod bench {\n     use std::io;\n     use std::sync::{Arc, Mutex};\n     use stats;\n-    use super::{Bencher, BenchSamples, BenchMode, Sink, MonitorMsg, TestDesc, Sender, TestResult};\n+    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n \n     pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n     where\n@@ -1711,7 +1683,8 @@ pub mod bench {\n             io::set_panic(panicio);\n         };\n \n-        let test_result = match result { //bs.bench(f) {\n+        let test_result = match result {\n+            //bs.bench(f) {\n             Ok(Some(ns_iter_summ)) => {\n                 let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n                 let mb_s = bs.bytes * 1000 / ns_iter;\n@@ -1732,9 +1705,7 @@ pub mod bench {\n                 };\n                 TestResult::TrBench(bs)\n             }\n-            Err(_) => {\n-                TestResult::TrFailed\n-            }\n+            Err(_) => TestResult::TrFailed,\n         };\n \n         let stdout = data.lock().unwrap().to_vec();\n@@ -1756,9 +1727,9 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{TrFailed, TrFailedMsg, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc,\n-               TestDescAndFn, TestOpts, run_test, MetricMap, StaticTestName, DynTestName,\n-               DynTestFn, ShouldPanic};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n+               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+               TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n@@ -1904,25 +1875,26 @@ mod tests {\n         opts.run_tests = true;\n         opts.run_ignored = true;\n \n-        let tests =\n-            vec![TestDescAndFn {\n-                             desc: TestDesc {\n-                                 name: StaticTestName(\"1\"),\n-                                 ignore: true,\n-                                 should_panic: ShouldPanic::No,\n-                                 allow_fail: false,\n-                             },\n-                             testfn: DynTestFn(Box::new(move || {})),\n-                         },\n-                         TestDescAndFn {\n-                             desc: TestDesc {\n-                                 name: StaticTestName(\"2\"),\n-                                 ignore: false,\n-                                 should_panic: ShouldPanic::No,\n-                                 allow_fail: false,\n-                             },\n-                             testfn: DynTestFn(Box::new(move || {})),\n-                         }];\n+        let tests = vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ];\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n@@ -1935,17 +1907,16 @@ mod tests {\n         fn tests() -> Vec<TestDescAndFn> {\n             vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n                 .into_iter()\n-                .map(|name| {\n-                    TestDescAndFn {\n-                        desc: TestDesc {\n-                            name: StaticTestName(name),\n-                            ignore: false,\n-                            should_panic: ShouldPanic::No,\n-                            allow_fail: false,\n-                        },\n-                        testfn: DynTestFn(Box::new(move || {}))\n-                    }\n-                }).collect()\n+                .map(|name| TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: StaticTestName(name),\n+                        ignore: false,\n+                        should_panic: ShouldPanic::No,\n+                        allow_fail: false,\n+                    },\n+                    testfn: DynTestFn(Box::new(move || {})),\n+                })\n+                .collect()\n         }\n \n         let substr = filter_tests(\n@@ -2127,10 +2098,7 @@ mod tests {\n             allow_fail: false,\n         };\n \n-        ::bench::benchmark(desc,\n-                            tx,\n-                            true,\n-                            f);\n+        ::bench::benchmark(desc, tx, true, f);\n         rx.recv().unwrap();\n     }\n \n@@ -2149,10 +2117,7 @@ mod tests {\n             allow_fail: false,\n         };\n \n-        ::bench::benchmark(desc,\n-                            tx,\n-                            true,\n-                            f);\n+        ::bench::benchmark(desc, tx, true, f);\n         rx.recv().unwrap();\n     }\n }"}, {"sha": "ddb5dcf2a1cd3a2d8ee7acf416542f3d10cf1919", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -279,7 +279,6 @@ impl Stats for [f64] {\n     }\n }\n \n-\n // Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n // linear interpolation. If samples are not sorted, return nonsensical value.\n fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n@@ -304,7 +303,6 @@ fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n     lo + (hi - lo) * d\n }\n \n-\n /// Winsorize a set of samples, replacing values above the `100-pct` percentile\n /// and below the `pct` percentile with those percentiles themselves. This is a\n /// way of minimizing the effect of outliers, at the cost of biasing the sample.\n@@ -338,15 +336,18 @@ mod tests {\n     use std::io;\n \n     macro_rules! assert_approx_eq {\n-        ($a:expr, $b:expr) => ({\n+        ($a: expr, $b: expr) => {{\n             let (a, b) = (&$a, &$b);\n-            assert!((*a - *b).abs() < 1.0e-6,\n-                    \"{} is not approximately equal to {}\", *a, *b);\n-        })\n+            assert!(\n+                (*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\",\n+                *a,\n+                *b\n+            );\n+        }};\n     }\n \n     fn check(samples: &[f64], summ: &Summary) {\n-\n         let summ2 = Summary::new(samples);\n \n         let mut w = io::sink();\n@@ -911,14 +912,18 @@ mod bench {\n \n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| { [1e20f64, 1.5f64, -1e20f64].sum(); })\n+        b.iter(|| {\n+            [1e20f64, 1.5f64, -1e20f64].sum();\n+        })\n     }\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n         let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n \n-        b.iter(|| { v.sum(); })\n+        b.iter(|| {\n+            v.sum();\n+        })\n     }\n \n     #[bench]"}, {"sha": "4af7e94671627c67e216ebff9e5c1620ad31fded", "filename": "src/test/compile-fail/feature-gate-termination_trait_test.rs", "status": "renamed", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Ffeature-gate-termination_trait_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Ffeature-gate-termination_trait_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-termination_trait_test.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() {\n-    let a = 5;\n-    let hello = || {\n-        println!(\"Hello {}\", a);\n-    };\n+// compile-flags: --test\n \n-    let b = hello;\n-    let c = hello; //~ ERROR use of moved value: `hello` [E0382]\n+fn main() {}\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() -> Result<(), ()> {\n+    //~^ ERROR functions used as tests must have signature fn() -> ()\n+        Ok(())\n+    }\n }", "previous_filename": "src/test/ui/feature-gate-copy-closures.rs"}, {"sha": "967cb3610ca5f261081c155237a9f284c79949df", "filename": "src/test/compile-fail/not-clone-closure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Fnot-clone-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Fnot-clone-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-clone-closure.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,8 +10,6 @@\n \n // Check that closures do not implement `Clone` if their environment is not `Clone`.\n \n-#![feature(clone_closures)]\n-\n struct S(i32);\n \n fn main() {"}, {"sha": "10567c5c961a212d20b04252743d8f76899bb17a", "filename": "src/test/compile-fail/not-copy-closure.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Fnot-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Fnot-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-copy-closure.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,9 +10,6 @@\n \n // Check that closures do not implement `Copy` if their environment is not `Copy`.\n \n-#![feature(copy_closures)]\n-#![feature(clone_closures)]\n-\n fn main() {\n     let mut a = 5;\n     let hello = || {"}, {"sha": "0e6ddf7c92f1a3629af50350f79e02ef4716faba", "filename": "src/test/compile-fail/rfc-1937-termination-trait/termination-trait-main-i32.rs", "status": "renamed", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-main-i32.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn main() -> i32 { //~ ERROR main function has wrong type [E0580]\n+fn main() -> i32 {\n+//~^ ERROR `main` has invalid return type `i32`\n+//~| NOTE `main` can only return types that implement std::process::Termination\n+//~| HELP consider using `()`, or a `Result`\n     0\n }", "previous_filename": "src/test/compile-fail/feature-gate-termination_trait.rs"}, {"sha": "b5f5472b492902f94eaecdf16b1b8a50ada303da", "filename": "src/test/compile-fail/rfc-1937-termination-trait/termination-trait-not-satisfied.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frfc-1937-termination-trait%2Ftermination-trait-not-satisfied.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n-\n struct ReturnType {}\n \n-fn main() -> ReturnType { //~ ERROR `ReturnType: std::process::Termination` is not satisfied\n+fn main() -> ReturnType { //~ ERROR `main` has invalid return type `ReturnType`\n     ReturnType {}\n }"}, {"sha": "863de85af88fbee024d7f4df8f35c284ec796915", "filename": "src/test/run-fail/rfc-1937-termination-trait/termination-trait-for-never.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-never.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n-\n // error-pattern:oh, dear\n \n fn main() -> ! {"}, {"sha": "0c6cb4de9567d8955d8ef2f618e4cc383d7fec05", "filename": "src/test/run-fail/rfc-1937-termination-trait/termination-trait-for-result-box-error_err.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_err.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -11,8 +11,6 @@\n // must-compile-successfully\n // failure-status: 1\n \n-#![feature(termination_trait)]\n-\n use std::io::{Error, ErrorKind};\n \n fn main() -> Result<(), Box<Error>> {"}, {"sha": "0fe3711d8d32e1196ea85b135de25117bb93c04b", "filename": "src/test/run-pass/clone-closure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fclone-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fclone-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-closure.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,8 +10,6 @@\n \n // Check that closures implement `Clone`.\n \n-#![feature(clone_closures)]\n-\n #[derive(Clone)]\n struct S(i32);\n "}, {"sha": "a211d6fc3a385972092b174ac44ce1d2ec6d58a2", "filename": "src/test/run-pass/copy-closure.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fcopy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fcopy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcopy-closure.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,9 +10,6 @@\n \n // Check that closures implement `Copy`.\n \n-#![feature(copy_closures)]\n-#![feature(clone_closures)]\n-\n fn call<T, F: FnOnce() -> T>(f: F) -> T { f() }\n \n fn main() {"}, {"sha": "765fb06e5f3a4c713da5014788d33eb0fbb9666c", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -179,7 +179,7 @@ fn generator(a: &Allocator, run_count: usize) {\n          );\n     };\n     for _ in 0..run_count {\n-        gen.resume();\n+        unsafe { gen.resume(); }\n     }\n }\n "}, {"sha": "3d39c46186be32bf10f578639f372ee96ecc03de", "filename": "src/test/run-pass/generator/conditional-drop.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fconditional-drop.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -42,9 +42,9 @@ fn t1() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    a.resume();\n+    unsafe { a.resume() };\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n-    a.resume();\n+    unsafe { a.resume() };\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n }\n \n@@ -58,8 +58,8 @@ fn t2() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    a.resume();\n+    unsafe { a.resume() };\n     assert_eq!(A.load(Ordering::SeqCst), n);\n-    a.resume();\n+    unsafe { a.resume() };\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n }"}, {"sha": "09971410e556d051ffe7d4b93f2c7e719aa8bf5e", "filename": "src/test/run-pass/generator/control-flow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fcontrol-flow.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -16,7 +16,7 @@ fn finish<T>(mut amt: usize, mut t: T) -> T::Return\n     where T: Generator<Yield = ()>\n {\n     loop {\n-        match t.resume() {\n+        match unsafe { t.resume() } {\n             GeneratorState::Yielded(()) => amt = amt.checked_sub(1).unwrap(),\n             GeneratorState::Complete(ret) => {\n                 assert_eq!(amt, 0);"}, {"sha": "ef4dc24472e61b08892f2668be1a06688b19b726", "filename": "src/test/run-pass/generator/drop-env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fdrop-env.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -37,7 +37,7 @@ fn t1() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    drop(foo.resume());\n+    drop(unsafe { foo.resume() });\n     assert_eq!(A.load(Ordering::SeqCst), n);\n     drop(foo);\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n@@ -50,7 +50,7 @@ fn t2() {\n     };\n \n     let n = A.load(Ordering::SeqCst);\n-    drop(foo.resume());\n+    drop(unsafe { foo.resume() });\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);\n     drop(foo);\n     assert_eq!(A.load(Ordering::SeqCst), n + 1);"}, {"sha": "8ce4fc6affab38c3856e10d698fc3241935f9223", "filename": "src/test/run-pass/generator/issue-44197.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fissue-44197.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -35,6 +35,8 @@ fn bar2(baz: String) -> impl Generator<Yield = String, Return = ()> {\n }\n \n fn main() {\n-    assert_eq!(bar(String::new()).resume(), GeneratorState::Yielded(String::new()));\n-    assert_eq!(bar2(String::new()).resume(), GeneratorState::Complete(()));\n+    unsafe {\n+        assert_eq!(bar(String::new()).resume(), GeneratorState::Yielded(String::new()));\n+        assert_eq!(bar2(String::new()).resume(), GeneratorState::Complete(()));\n+    }\n }"}, {"sha": "654b18928c07796bf7ee42bfe4cd81169511b5c0", "filename": "src/test/run-pass/generator/iterator-count.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fiterator-count.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -14,11 +14,13 @@ use std::ops::{GeneratorState, Generator};\n \n struct W<T>(T);\n \n+// This impl isn't safe in general, but the generator used in this test is movable\n+// so it won't cause problems.\n impl<T: Generator<Return = ()>> Iterator for W<T> {\n     type Item = T::Yield;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        match self.0.resume() {\n+        match unsafe { self.0.resume() } {\n             GeneratorState::Complete(..) => None,\n             GeneratorState::Yielded(v) => Some(v),\n         }"}, {"sha": "28e7da232ce09d38fbbc84ec293b4ccdf6ec8203", "filename": "src/test/run-pass/generator/live-upvar-across-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Flive-upvar-across-yield.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     let mut a = || {\n         b(yield);\n     };\n-    a.resume();\n+    unsafe { a.resume() };\n }"}, {"sha": "29808da85a7a9064ee9648b0d0ddcd3d05ba8e9d", "filename": "src/test/run-pass/generator/nested_generators.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fnested_generators.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -20,7 +20,7 @@ fn main() {\n             yield 2;\n         };\n \n-        match sub_generator.resume() {\n+        match unsafe { sub_generator.resume() } {\n             GeneratorState::Yielded(x) => {\n                 yield x;\n             }"}, {"sha": "3d7b60ab6b90132ee3d5e17c0d04f05ec0cf6b67", "filename": "src/test/run-pass/generator/panic-drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-drops.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -42,7 +42,7 @@ fn main() {\n \n     assert_eq!(A.load(Ordering::SeqCst), 0);\n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        foo.resume()\n+        unsafe { foo.resume() }\n     }));\n     assert!(res.is_err());\n     assert_eq!(A.load(Ordering::SeqCst), 1);\n@@ -57,7 +57,7 @@ fn main() {\n \n     assert_eq!(A.load(Ordering::SeqCst), 1);\n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        foo.resume()\n+        unsafe { foo.resume() }\n     }));\n     assert!(res.is_err());\n     assert_eq!(A.load(Ordering::SeqCst), 1);"}, {"sha": "ace5cdde51d85f726c2e17f65c46686d5b5074ba", "filename": "src/test/run-pass/generator/panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fpanic-safe.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -24,13 +24,13 @@ fn main() {\n     };\n \n     let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        foo.resume()\n+        unsafe { foo.resume() }\n     }));\n     assert!(res.is_err());\n \n     for _ in 0..10 {\n         let res = panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-            foo.resume()\n+            unsafe { foo.resume() }\n         }));\n         assert!(res.is_err());\n     }"}, {"sha": "06e7615d26191b3fe6aa403062af5c9f7ffd2d67", "filename": "src/test/run-pass/generator/resume-after-return.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fresume-after-return.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -23,12 +23,12 @@ fn main() {\n         yield;\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n \n-    match panic::catch_unwind(move || foo.resume()) {\n+    match panic::catch_unwind(move || unsafe { foo.resume() }) {\n         Ok(_) => panic!(\"generator successfully resumed\"),\n         Err(_) => {}\n     }"}, {"sha": "7395c8484c169acd16d937e1ea81ff1748860aa5", "filename": "src/test/run-pass/generator/smoke.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fsmoke.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -24,7 +24,7 @@ fn simple() {\n         }\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -40,7 +40,7 @@ fn return_capture() {\n         a\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -52,11 +52,11 @@ fn simple_yield() {\n         yield;\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Yielded(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -69,11 +69,11 @@ fn yield_capture() {\n         yield b;\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Yielded(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -86,11 +86,11 @@ fn simple_yield_value() {\n         return String::from(\"foo\")\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Yielded(ref s) if *s == \"bar\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -104,11 +104,11 @@ fn return_after_yield() {\n         return a\n     };\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Yielded(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(ref s) if *s == \"foo\" => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n@@ -156,11 +156,11 @@ fn send_and_sync() {\n fn send_over_threads() {\n     let mut foo = || { yield };\n     thread::spawn(move || {\n-        match foo.resume() {\n+        match unsafe { foo.resume() } {\n             GeneratorState::Yielded(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n-        match foo.resume() {\n+        match unsafe { foo.resume() } {\n             GeneratorState::Complete(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n@@ -169,11 +169,11 @@ fn send_over_threads() {\n     let a = String::from(\"a\");\n     let mut foo = || { yield a };\n     thread::spawn(move || {\n-        match foo.resume() {\n+        match unsafe { foo.resume() } {\n             GeneratorState::Yielded(ref s) if *s == \"a\" => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }\n-        match foo.resume() {\n+        match unsafe { foo.resume() } {\n             GeneratorState::Complete(()) => {}\n             s => panic!(\"bad state: {:?}\", s),\n         }"}, {"sha": "ebc070eee09c1c7874d67c81fe414aa450e2d420", "filename": "src/test/run-pass/generator/static-generators.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fstatic-generators.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -13,14 +13,14 @@\n use std::ops::{Generator, GeneratorState};\n \n fn main() {\n-    let mut generator = unsafe {\n-        static || {\n-            let a = true;\n-            let b = &a;\n-            yield;\n-            assert_eq!(b as *const _, &a as *const _);\n-        }\n+    let mut generator = static || {\n+        let a = true;\n+        let b = &a;\n+        yield;\n+        assert_eq!(b as *const _, &a as *const _);\n     };\n-    assert_eq!(generator.resume(), GeneratorState::Yielded(()));\n-    assert_eq!(generator.resume(), GeneratorState::Complete(()));\n+    unsafe {\n+        assert_eq!(generator.resume(), GeneratorState::Yielded(()));\n+        assert_eq!(generator.resume(), GeneratorState::Complete(()));\n+    }\n }"}, {"sha": "8eeb013314499e882b2c75c94af79ab70d9216bb", "filename": "src/test/run-pass/generator/xcrate-reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate-reachable.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -17,5 +17,5 @@ extern crate xcrate_reachable as foo;\n use std::ops::Generator;\n \n fn main() {\n-    foo::foo().resume();\n+    unsafe { foo::foo().resume(); }\n }"}, {"sha": "04791d51356772e52b93679abad2ce06f0717360", "filename": "src/test/run-pass/generator/xcrate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgenerator%2Fxcrate.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -19,18 +19,18 @@ use std::ops::{GeneratorState, Generator};\n fn main() {\n     let mut foo = xcrate::foo();\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n \n     let mut foo = xcrate::bar(3);\n \n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Yielded(3) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }\n-    match foo.resume() {\n+    match unsafe { foo.resume() } {\n         GeneratorState::Complete(()) => {}\n         s => panic!(\"bad state: {:?}\", s),\n     }"}, {"sha": "046d27a9f0fe55586ed5f82a1533900e04e6b1ec", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-empty.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-empty.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,6 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n-\n fn main() {}"}, {"sha": "4aa7d8c3a77d2fd594538bc4c8bcc776893aec6b", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-exitcode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-exitcode.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n #![feature(process_exitcode_placeholder)]\n \n use std::process::ExitCode;"}, {"sha": "33686ed0b8fa23b5dcbf8a038a23fbfebf815da9", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-result-box-error_ok.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result-box-error_ok.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n-\n use std::io::Error;\n \n fn main() -> Result<(), Box<Error>> {"}, {"sha": "1c87e31e763e9f9bee733e568431872dcf599dee", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-for-result.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-for-result.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(termination_trait)]\n-\n use std::io::Error;\n \n fn main() -> Result<(), Error> {"}, {"sha": "11997eb6917287cb82abe42033d9f87a12f543d4", "filename": "src/test/run-pass/rfc-1937-termination-trait/termination-trait-in-test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frfc-1937-termination-trait%2Ftermination-trait-in-test.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,7 +10,7 @@\n \n // compile-flags: --test\n \n-#![feature(termination_trait)]\n+#![feature(termination_trait_test)]\n #![feature(test)]\n \n extern crate test;"}, {"sha": "0278256994120983eb1ec8b64a9a97be5a65aa55", "filename": "src/test/ui-fulldeps/custom-derive/issue-36935.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fcustom-derive%2Fissue-36935.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -6,3 +6,5 @@ LL | #[derive(Foo, Bar)] //~ ERROR proc-macro derive panicked\n    |\n    = help: message: lolnope\n \n+error: aborting due to previous error\n+"}, {"sha": "30ad53f9041f0b294e62e189285aefb175516e84", "filename": "src/test/ui-fulldeps/proc-macro/load-panic.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fproc-macro%2Fload-panic.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -6,3 +6,5 @@ LL | #[derive(A)]\n    |\n    = help: message: nope!\n \n+error: aborting due to previous error\n+"}, {"sha": "e247e86fbcb2281ecf67e9aa5bad6b73617a321e", "filename": "src/test/ui/codemap_tests/two_files.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Ftwo_files.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -4,5 +4,6 @@ error[E0404]: expected trait, found type alias `Bar`\n LL | impl Bar for Baz { } //~ ERROR expected trait, found type alias\n    |      ^^^ type aliases cannot be used for traits\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "a64595fbb40200f66c6b0eaa33400203f6109ab8", "filename": "src/test/ui/cross-file-errors/main.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcross-file-errors%2Fmain.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -9,3 +9,5 @@ LL |         _\n LL |     underscore!();\n    |     -------------- in this macro invocation\n \n+error: aborting due to previous error\n+"}, {"sha": "265a688df99105896dda747ad4428dcd1c7f1dff", "filename": "src/test/ui/did_you_mean/recursion_limit_macro.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_macro.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -9,3 +9,5 @@ LL |     recurse!(0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9);\n    |\n    = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n \n+error: aborting due to previous error\n+"}, {"sha": "afb748bedbe0f8c89579b7878122f7d97d2e718a", "filename": "src/test/ui/error-codes/E0404.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0404.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,5 +10,6 @@ error[E0404]: expected trait, found struct `Foo`\n LL | fn baz<T: Foo>(_: T) {} //~ ERROR E0404\n    |           ^^^ not a trait\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "27190af1c6c11b4e8ececd0fc1c7834d1cdd33a2", "filename": "src/test/ui/error-codes/E0405.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ferror-codes%2FE0405.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ferror-codes%2FE0405.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0405.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -4,5 +4,6 @@ error[E0405]: cannot find trait `SomeTrait` in this scope\n LL | impl SomeTrait for Foo {} //~ ERROR E0405\n    |      ^^^^^^^^^ not found in this scope\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "a15153ea7bf0ab947bbd0b04b0288bfc4899ef1d", "filename": "src/test/ui/feature-gate-clone-closures.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.rs?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[derive(Clone)]\n-struct S(i32);\n-\n-fn main() {\n-    let a = S(5);\n-    let hello = move || {\n-        println!(\"Hello {}\", a.0);\n-    };\n-\n-    let hello = hello.clone(); //~ ERROR no method named `clone` found for type\n-}"}, {"sha": "7038a76380d6b9663d9239eb4956007911125aa1", "filename": "src/test/ui/feature-gate-clone-closures.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-clone-closures.stderr?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,11 +0,0 @@\n-error[E0599]: no method named `clone` found for type `[closure@$DIR/feature-gate-clone-closures.rs:16:17: 18:6 a:_]` in the current scope\n-  --> $DIR/feature-gate-clone-closures.rs:20:23\n-   |\n-LL |     let hello = hello.clone(); //~ ERROR no method named `clone` found for type\n-   |                       ^^^^^\n-   |\n-   = note: hello is a function, perhaps you wish to call it\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0599`."}, {"sha": "e72680b69eaea12fe1b996b359de5b7668f72063", "filename": "src/test/ui/feature-gate-copy-closures.stderr", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-copy-closures.stderr?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,13 +0,0 @@\n-error[E0382]: use of moved value: `hello`\n-  --> $DIR/feature-gate-copy-closures.rs:18:9\n-   |\n-LL |     let b = hello;\n-   |         - value moved here\n-LL |     let c = hello; //~ ERROR use of moved value: `hello` [E0382]\n-   |         ^ value used here after move\n-   |\n-   = note: move occurs because `hello` has type `[closure@$DIR/feature-gate-copy-closures.rs:13:17: 15:6 a:&i32]`, which does not implement the `Copy` trait\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0382`."}, {"sha": "a2c1dedff385ad9640c66ebfcf2efda04cfd4445", "filename": "src/test/ui/feature-gate-fn_must_use-cap-lints-allow.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use-cap-lints-allow.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -4,3 +4,5 @@ error: compilation successful\n LL | fn main() {} //~ ERROR compilation successful\n    | ^^^^^^^^^^^^\n \n+error: aborting due to previous error\n+"}, {"sha": "431c57abd2653ce6c87bc5fe93a1302e5dca5ff6", "filename": "src/test/ui/feature-gate-fn_must_use.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-fn_must_use.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -20,3 +20,5 @@ error: compilation successful\n LL | fn main() {} //~ ERROR compilation successful\n    | ^^^^^^^^^^^^\n \n+error: aborting due to previous error\n+"}, {"sha": "0beed62798710e9710efff7af3c438e1b0f6e0bf", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-builtin-attrs.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-builtin-attrs.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1316,3 +1316,5 @@ LL | |     println!(\"Hello World\");\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "802c5d9384d7575f4264652d949fa924a9ae4123", "filename": "src/test/ui/feature-gate/issue-43106-gating-of-deprecated.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-deprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-deprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fissue-43106-gating-of-deprecated.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -6,3 +6,5 @@ LL | |     println!(\"Hello World\");\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "e56927d81823131b1e38e66cbff0394b743489fe", "filename": "src/test/ui/generator/borrowing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -15,7 +15,7 @@ use std::ops::Generator;\n fn main() {\n     let _b = {\n         let a = 3;\n-        (|| yield &a).resume()\n+        unsafe { (|| yield &a).resume() }\n         //~^ ERROR: `a` does not live long enough\n     };\n "}, {"sha": "45d950b5aef646f9c24710e3159aa1fc1061a8ad", "filename": "src/test/ui/generator/borrowing.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fborrowing.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,10 +1,10 @@\n error[E0597]: `a` does not live long enough\n-  --> $DIR/borrowing.rs:18:20\n+  --> $DIR/borrowing.rs:18:29\n    |\n-LL |         (|| yield &a).resume()\n-   |          --        ^ borrowed value does not live long enough\n-   |          |\n-   |          capture occurs here\n+LL |         unsafe { (|| yield &a).resume() }\n+   |                   --        ^ borrowed value does not live long enough\n+   |                   |\n+   |                   capture occurs here\n LL |         //~^ ERROR: `a` does not live long enough\n LL |     };\n    |     - borrowed value only lives until here"}, {"sha": "b2240fb225f58dd51045fd28580627e2d1bff70d", "filename": "src/test/ui/generator/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fdropck.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -23,6 +23,6 @@ fn main() {\n         let _d = ref_.take(); //~ ERROR `ref_` does not live long enough\n         yield;\n     };\n-    gen.resume();\n+    unsafe { gen.resume(); }\n     // drops the RefCell and then the Ref, leading to use-after-free\n }"}, {"sha": "a1c8ca77e41e8bf34ff228ae6c5470f98be8167a", "filename": "src/test/ui/generator/sized-yield.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -17,5 +17,5 @@ fn main() {\n    let mut gen = move || { //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n        yield s[..];\n    };\n-   gen.resume(); //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n+   unsafe { gen.resume(); } //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n }"}, {"sha": "957fac172c2588dd071245ec89e53b1bd7b5e1cd", "filename": "src/test/ui/generator/sized-yield.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fsized-yield.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -11,10 +11,10 @@ LL | |    };\n    = note: the yield type of a generator must have a statically known size\n \n error[E0277]: the trait bound `str: std::marker::Sized` is not satisfied\n-  --> $DIR/sized-yield.rs:20:8\n+  --> $DIR/sized-yield.rs:20:17\n    |\n-LL |    gen.resume(); //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n-   |        ^^^^^^ `str` does not have a constant size known at compile-time\n+LL |    unsafe { gen.resume(); } //~ ERROR the trait bound `str: std::marker::Sized` is not satisfied\n+   |                 ^^^^^^ `str` does not have a constant size known at compile-time\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `str`\n "}, {"sha": "45acbf50931bc5234863f8bd59304072786d74eb", "filename": "src/test/ui/generator/unsafe-immovable.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.rs?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(generators)]\n-\n-fn main() {\n-    static || { //~ ERROR: construction of immovable generator requires unsafe\n-        yield;\n-    };\n-}"}, {"sha": "b2add55613d547d1bf7646f244452e18bf83ec2d", "filename": "src/test/ui/generator/unsafe-immovable.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b4aa80dd73df9708022cc383aad8da1dcf38d1df/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funsafe-immovable.stderr?ref=b4aa80dd73df9708022cc383aad8da1dcf38d1df", "patch": "@@ -1,11 +0,0 @@\n-error[E0133]: construction of immovable generator requires unsafe function or block\n-  --> $DIR/unsafe-immovable.rs:14:5\n-   |\n-LL | /     static || { //~ ERROR: construction of immovable generator requires unsafe\n-LL | |         yield;\n-LL | |     };\n-   | |_____^ construction of immovable generator\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0133`."}, {"sha": "b8a67a0e7b65d7a788a9667e15cb48a6e8c22796", "filename": "src/test/ui/generator/yield-while-iterating.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-iterating.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -43,7 +43,7 @@ fn yield_during_iter_borrowed_slice_2() {\n     println!(\"{:?}\", x);\n }\n \n-fn yield_during_iter_borrowed_slice_3() {\n+unsafe fn yield_during_iter_borrowed_slice_3() {\n     // OK to take a mutable ref to `x` and yield\n     // up pointers from it:\n     let mut x = vec![22_i32];\n@@ -55,7 +55,7 @@ fn yield_during_iter_borrowed_slice_3() {\n     b.resume();\n }\n \n-fn yield_during_iter_borrowed_slice_4() {\n+unsafe fn yield_during_iter_borrowed_slice_4() {\n     // ...but not OK to do that while reading\n     // from `x` too\n     let mut x = vec![22_i32];\n@@ -68,7 +68,7 @@ fn yield_during_iter_borrowed_slice_4() {\n     b.resume();\n }\n \n-fn yield_during_range_iter() {\n+unsafe fn yield_during_range_iter() {\n     // Should be OK.\n     let mut b = || {\n         let v = vec![1,2,3];"}, {"sha": "3dc2650a2ecbf5e649f009af80cc347957e00cb2", "filename": "src/test/ui/generator/yield-while-local-borrowed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-local-borrowed.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -15,7 +15,7 @@\n use std::ops::{GeneratorState, Generator};\n use std::cell::Cell;\n \n-fn borrow_local_inline() {\n+unsafe fn borrow_local_inline() {\n     // Not OK to yield with a borrow of a temporary.\n     //\n     // (This error occurs because the region shows up in the type of\n@@ -30,7 +30,7 @@ fn borrow_local_inline() {\n     b.resume();\n }\n \n-fn borrow_local_inline_done() {\n+unsafe fn borrow_local_inline_done() {\n     // No error here -- `a` is not in scope at the point of `yield`.\n     let mut b = move || {\n         {\n@@ -41,7 +41,7 @@ fn borrow_local_inline_done() {\n     b.resume();\n }\n \n-fn borrow_local() {\n+unsafe fn borrow_local() {\n     // Not OK to yield with a borrow of a temporary.\n     //\n     // (This error occurs because the region shows up in the type of"}, {"sha": "573dd4377bb2c170629b05d169358f40e464aee3", "filename": "src/test/ui/generator/yield-while-ref-reborrowed.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fyield-while-ref-reborrowed.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -13,7 +13,7 @@\n use std::ops::{GeneratorState, Generator};\n use std::cell::Cell;\n \n-fn reborrow_shared_ref(x: &i32) {\n+unsafe fn reborrow_shared_ref(x: &i32) {\n     // This is OK -- we have a borrow live over the yield, but it's of\n     // data that outlives the generator.\n     let mut b = move || {\n@@ -24,7 +24,7 @@ fn reborrow_shared_ref(x: &i32) {\n     b.resume();\n }\n \n-fn reborrow_mutable_ref(x: &mut i32) {\n+unsafe fn reborrow_mutable_ref(x: &mut i32) {\n     // This is OK -- we have a borrow live over the yield, but it's of\n     // data that outlives the generator.\n     let mut b = move || {\n@@ -35,7 +35,7 @@ fn reborrow_mutable_ref(x: &mut i32) {\n     b.resume();\n }\n \n-fn reborrow_mutable_ref_2(x: &mut i32) {\n+unsafe fn reborrow_mutable_ref_2(x: &mut i32) {\n     // ...but not OK to go on using `x`.\n     let mut b = || {\n         let a = &mut *x;"}, {"sha": "3cc0bebe816550a369aeb042a48adaec757cf39e", "filename": "src/test/ui/impl-trait/universal_wrong_bounds.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funiversal_wrong_bounds.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -24,5 +24,7 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use std::fmt::Debug;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to 3 previous errors\n \n+Some errors occurred: E0405, E0425.\n+For more information about an error, try `rustc --explain E0405`."}, {"sha": "aeb465b2ab2337ecc2fc9f5632b3d3850bf17bb7", "filename": "src/test/ui/issue-22644.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-22644.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -89,3 +89,5 @@ error: expected type, found `4`\n LL |     println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n    |                            ^ expecting a type here because of type ascription\n \n+error: aborting due to 9 previous errors\n+"}, {"sha": "de7c11732e4a39e029c9df88134f2ba062f4da30", "filename": "src/test/ui/issue-44406.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-44406.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-44406.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-44406.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -13,3 +13,5 @@ LL |         bar(baz: $rest)\n LL |     foo!(true); //~ ERROR expected type, found keyword\n    |          ^^^^ expecting a type here because of type ascription\n \n+error: aborting due to 2 previous errors\n+"}, {"sha": "a319849223740c47cc6f06982fcdb738e53f1745", "filename": "src/test/ui/issue-49257.rs", "status": "renamed", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-49257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-49257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures)]\n+// Test for #49257:\n+// emits good diagnostics for `..` pattern fragments not in the last position.\n \n-fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n+#![allow(unused)]\n+\n+struct Point { x: u8, y: u8 }\n \n fn main() {\n-    let f = to_fn_once(move|| ());\n-    f();\n-    f(); //~ ERROR use of moved value\n+    let p = Point { x: 0, y: 0 };\n+    let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n+    //~| ERROR pattern does not mention fields `x`, `y`\n }", "previous_filename": "src/test/compile-fail/unboxed-closer-non-implicit-copyable.rs"}, {"sha": "fec990764bb1427ea4ffd49ff237de8282d4cf96", "filename": "src/test/ui/issue-49257.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-49257.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fissue-49257.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -0,0 +1,15 @@\n+error: expected `}`, found `,`\n+  --> $DIR/issue-49257.rs:20:19\n+   |\n+LL |     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n+   |                   ^ `..` must be in the last position, and cannot have a trailing comma\n+\n+error[E0027]: pattern does not mention fields `x`, `y`\n+  --> $DIR/issue-49257.rs:20:9\n+   |\n+LL |     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n+   |         ^^^^^^^^^^^^^^^ missing fields `x`, `y`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0027`."}, {"sha": "d484061ef9661d6590030eef376f1ead540432c3", "filename": "src/test/ui/lint-output-format-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Flint-output-format-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Flint-output-format-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint-output-format-2.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -22,3 +22,5 @@ LL | |     let _y = bar();\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "830270a99d1123a9845ba4dc5be3f3e1e1f360f8", "filename": "src/test/ui/loops-reject-duplicate-labels-2.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-duplicate-labels-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-duplicate-labels-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops-reject-duplicate-labels-2.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -70,3 +70,5 @@ LL | |     foo();\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "a71f98b812a8c136b6b9dea934367e7de6784bb1", "filename": "src/test/ui/loops-reject-duplicate-labels.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-duplicate-labels.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-duplicate-labels.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops-reject-duplicate-labels.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -73,3 +73,5 @@ LL | |     foo();\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "af524d5b01766e283937f36b9227509420acf6a1", "filename": "src/test/ui/loops-reject-labels-shadowing-lifetimes.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-labels-shadowing-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-labels-shadowing-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops-reject-labels-shadowing-lifetimes.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -108,3 +108,5 @@ LL | |     foo();\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "999cfb9cc3c6b62b83825531f4e9bb7d96930030", "filename": "src/test/ui/loops-reject-lifetime-shadowing-label.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-lifetime-shadowing-label.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Floops-reject-lifetime-shadowing-label.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Floops-reject-lifetime-shadowing-label.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -14,3 +14,5 @@ LL | |     foo();\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "b3e67fb2607cdb568a2110e907076e46fb62337d", "filename": "src/test/ui/macro-context.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacro-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacro-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacro-context.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -43,3 +43,5 @@ LL |     () => ( i ; typeof );   //~ ERROR expected expression, found reserved k\n LL |     m!();\n    |     ----- in this macro invocation\n \n+error: aborting due to 4 previous errors\n+"}, {"sha": "0f9f0607c5bf2247e7d8f333210eb2b7c68eeb3f", "filename": "src/test/ui/macros/macro_path_as_generic_bound.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro_path_as_generic_bound.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -4,5 +4,6 @@ error[E0433]: failed to resolve. Use of undeclared type or module `m`\n LL | foo!(m::m2::A); //~ ERROR failed to resolve\n    |      ^ Use of undeclared type or module `m`\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "a9ffef8ef80907d596238b804b765e21639bb7e8", "filename": "src/test/ui/macros/trace_faulty_macros.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Ftrace_faulty_macros.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -45,3 +45,5 @@ LL |     my_recursive_macro!();\n    = note: expanding `my_recursive_macro! {  }`\n    = note: to `my_recursive_macro ! (  ) ;`\n \n+error: aborting due to 2 previous errors\n+"}, {"sha": "ddf1cfe406f7c3033e22c1951eadf21adc5fa9cd", "filename": "src/test/ui/raw_string.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fraw_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fraw_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fraw_string.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -6,3 +6,5 @@ LL |     let x = r##\"lol\"#;\n    |\n    = note: this raw string should be terminated with `\"##`\n \n+error: aborting due to previous error\n+"}, {"sha": "3edfa33d80a02b9526d8163c2951991eba8d5fd1", "filename": "src/test/ui/resolve/issue-21221-1.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-1.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -45,5 +45,7 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use std::ops::Div;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to 4 previous errors\n \n+Some errors occurred: E0405, E0412.\n+For more information about an error, try `rustc --explain E0405`."}, {"sha": "e11fe9ac4cf119982d10b370125832f04ae87bc3", "filename": "src/test/ui/resolve/issue-21221-2.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-2.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,5 +8,6 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use foo::bar::T;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "f406cd6e35fcfb1ea9c605f42671c8e206207a14", "filename": "src/test/ui/resolve/issue-21221-3.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-3.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,5 +8,6 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use issue_21221_3::outer::OuterTrait;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "c0a7f1734f49ccfdf8953673a3746029a70c8b46", "filename": "src/test/ui/resolve/issue-21221-4.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-21221-4.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,5 +8,6 @@ help: possible candidate is found in another module, you can import it into scop\n LL | use issue_21221_4::T;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0405`."}, {"sha": "3627c09b28fd9dac873e23b298065ae20d3cc91c", "filename": "src/test/ui/resolve/issue-3907.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-3907.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,5 +8,6 @@ help: possible better candidate is found in another module, you can import it in\n LL | use issue_3907::Foo;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0404`."}, {"sha": "353a0b1c3d9d09f322af8900053f4d643b2f95be", "filename": "src/test/ui/resolve/issue-5035.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-5035.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -13,5 +13,7 @@ LL | impl K for isize {} //~ ERROR expected trait, found type alias `K`\n    |      did you mean `I`?\n    |      type aliases cannot be used for traits\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to 2 previous errors\n \n+Some errors occurred: E0404, E0432.\n+For more information about an error, try `rustc --explain E0404`."}, {"sha": "f32c5e9b2c6bd2e2f5214315d6dd3271340de899", "filename": "src/test/ui/resolve/unboxed-closure-sugar-nonexistent-trait.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Funboxed-closure-sugar-nonexistent-trait.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -10,5 +10,7 @@ error[E0404]: expected trait, found type alias `Typedef`\n LL | fn g<F:Typedef(isize) -> isize>(x: F) {}\n    |        ^^^^^^^^^^^^^^^^^^^^^^^ type aliases cannot be used for traits\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to 2 previous errors\n \n+Some errors occurred: E0404, E0405.\n+For more information about an error, try `rustc --explain E0404`."}, {"sha": "425f51ca2fb5498dea17498877f5002b815a82c6", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-main-wrong-type.rs", "status": "renamed", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -7,9 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(termination_trait)]\n \n-fn main() -> char {\n-//~^ ERROR: the trait bound `char: std::process::Termination` is not satisfied\n+fn main() -> char { //~ ERROR\n     ' '\n }", "previous_filename": "src/test/compile-fail/rfc-1937-termination-trait/termination-trait-main-wrong-type.rs"}, {"sha": "5109d9275c58b573b0eeac5f46380e7e4b983406", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-main-wrong-type.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-main-wrong-type.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: `main` has invalid return type `char`\n+  --> $DIR/termination-trait-main-wrong-type.rs:11:14\n+   |\n+LL | fn main() -> char { //~ ERROR\n+   |              ^^^^ `main` can only return types that implement std::process::Termination\n+   |\n+   = help: consider using `()`, or a `Result`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/rfc1598-generic-associated-types/generic-associated-types-where.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc1598-generic-associated-types%2Fgeneric-associated-types-where.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -1,2 +0,0 @@\n-error: cannot continue compilation due to previous error\n-"}, {"sha": "e8227971691e947d46e1684554fdf5926c4ef5e8", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.rs?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -58,7 +58,10 @@ fn test6() {\n \n fn test7() {\n     fn foo<F>(_: F) where F: FnMut(Box<FnMut(isize)>, isize) {}\n-    let mut f = |g: Box<FnMut(isize)>, b: isize| {};\n+    let s = String::new();  // Capture to make f !Copy\n+    let mut f = move |g: Box<FnMut(isize)>, b: isize| {\n+        let _ = s.len();\n+    };\n     f(Box::new(|a| {\n         foo(f);\n         //~^ ERROR cannot move `f` into closure because it is borrowed"}, {"sha": "2e7e1e0744141f474a848eaa1098b8ebdee82061", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -28,19 +28,19 @@ LL |     f.f.call_mut(())\n    |     ^^^ cannot borrow as mutable\n \n error[E0504]: cannot move `f` into closure because it is borrowed\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:63:13\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:66:13\n    |\n LL |     f(Box::new(|a| {\n    |     - borrow of `f` occurs here\n LL |         foo(f);\n    |             ^ move into closure occurs here\n \n error[E0507]: cannot move out of captured outer variable in an `FnMut` closure\n-  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:63:13\n+  --> $DIR/borrowck-call-is-borrow-issue-12224.rs:66:13\n    |\n-LL |     let mut f = |g: Box<FnMut(isize)>, b: isize| {};\n+LL |     let mut f = move |g: Box<FnMut(isize)>, b: isize| {\n    |         ----- captured outer variable\n-LL |     f(Box::new(|a| {\n+...\n LL |         foo(f);\n    |             ^ cannot move out of captured outer variable in an `FnMut` closure\n "}, {"sha": "b496a1a76c017424252b586fa89452001f6cfb0a", "filename": "src/test/ui/span/issue-24690.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-24690.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -36,3 +36,5 @@ LL | |     println!(\"{}\", theTwo);\n LL | | }\n    | |_^\n \n+error: aborting due to previous error\n+"}, {"sha": "1dd45bb1e5efe3c764209f2e3aeeb34fb480ed61", "filename": "src/test/ui/span/issue-35987.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-35987.stderr?ref=f5631d9ac7745dd6eaea2bc6c236d5f8e54e9a18", "patch": "@@ -8,5 +8,6 @@ help: possible better candidate is found in another module, you can import it in\n LL | use std::ops::Add;\n    |\n \n-error: cannot continue compilation due to previous error\n+error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0404`."}]}