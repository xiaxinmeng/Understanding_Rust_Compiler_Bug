{"sha": "18ccd0190ee6ef4a6e1bb9d737e515b872009711", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Y2NkMDE5MGVlNmVmNGE2ZTFiYjlkNzM3ZTUxNWI4NzIwMDk3MTE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-13T02:49:47Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-13T02:49:47Z"}, "message": "Rebasing", "tree": {"sha": "975ea2d02abb8da3ad0222684606c6e2b2c4e1ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/975ea2d02abb8da3ad0222684606c6e2b2c4e1ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18ccd0190ee6ef4a6e1bb9d737e515b872009711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18ccd0190ee6ef4a6e1bb9d737e515b872009711", "html_url": "https://github.com/rust-lang/rust/commit/18ccd0190ee6ef4a6e1bb9d737e515b872009711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18ccd0190ee6ef4a6e1bb9d737e515b872009711/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f30d9e7c973d7bee78f8d16aa623f679c37bcae", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f30d9e7c973d7bee78f8d16aa623f679c37bcae", "html_url": "https://github.com/rust-lang/rust/commit/6f30d9e7c973d7bee78f8d16aa623f679c37bcae"}], "stats": {"total": 872, "additions": 504, "deletions": 368}, "files": [{"sha": "890c39ebabb71e24f01dea7e7132956ea016568c", "filename": "src/chains.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -574,7 +574,8 @@ fn rewrite_method_call(\n     let (lo, type_str) = if types.is_empty() {\n         (args[0].span.hi, String::new())\n     } else {\n-        let type_list: Vec<_> = try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n+        let type_list: Vec<_> =\n+            try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n         let type_str = if context.config.spaces_within_angle_brackets() && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))"}, {"sha": "80c89a3a91bd28c5a019a48f11a58b2aaab6a8c2", "filename": "src/expr.rs", "status": "modified", "additions": 82, "deletions": 62, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -281,7 +281,9 @@ fn format_expr(\n             Some(format!(\n                 \"{}{}\",\n                 \"do catch \",\n-                try_opt!(block.rewrite(&context, Shape::legacy(budget, shape.indent)))\n+                try_opt!(\n+                    block.rewrite(&context, Shape::legacy(budget, shape.indent))\n+                )\n             ))\n         }\n     };\n@@ -1428,9 +1430,11 @@ impl Rewrite for ast::Arm {\n             if contains_skip(attrs) {\n                 return None;\n             }\n-            format!(\"{}\\n{}\",\n-                    try_opt!(attrs.rewrite(context, shape)),\n-                    shape.indent.to_string(context.config))\n+            format!(\n+                \"{}\\n{}\",\n+                try_opt!(attrs.rewrite(context, shape)),\n+                shape.indent.to_string(context.config)\n+            )\n         } else {\n             String::new()\n         };\n@@ -1515,11 +1519,11 @@ impl Rewrite for ast::Arm {\n             };\n \n             match rewrite {\n-                Some(ref body_str) if (!body_str.contains('\\n') &&\n-                                           body_str.len() <= arm_shape.width) ||\n-                                          !context.config.wrap_match_arms() ||\n-                                          (extend && first_line_width(body_str) <= arm_shape.width) ||\n-                                          is_block => {\n+                Some(ref body_str)\n+                    if (!body_str.contains('\\n') && body_str.len() <= arm_shape.width) ||\n+                           !context.config.wrap_match_arms() ||\n+                           (extend && first_line_width(body_str) <= arm_shape.width) ||\n+                           is_block => {\n                     let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n                         _ => \" \",\n@@ -1610,28 +1614,33 @@ fn rewrite_guard(\n     if let Some(ref guard) = *guard {\n         // First try to fit the guard string on the same line as the pattern.\n         // 4 = ` if `, 5 = ` => {`\n-        if let Some(cond_shape) = shape\n-               .shrink_left(pattern_width + 4)\n-               .and_then(|s| s.sub_width(5)) {\n-            if let Some(cond_str) = guard\n-                   .rewrite(context, cond_shape)\n-                   .and_then(|s| s.rewrite(context, cond_shape)) {\n+        if let Some(cond_shape) = shape.shrink_left(pattern_width + 4).and_then(\n+            |s| s.sub_width(5),\n+        )\n+        {\n+            if let Some(cond_str) = guard.rewrite(context, cond_shape).and_then(|s| {\n+                s.rewrite(context, cond_shape)\n+            })\n+            {\n                 return Some(format!(\" if {}\", cond_str));\n             }\n         }\n \n         // Not enough space to put the guard after the pattern, try a newline.\n         // 3 == `if `\n-        if let Some(cond_shape) = Shape::indented(shape.indent.block_indent(context.config) + 3,\n-                                                  context.config)\n-               .sub_width(3) {\n+        if let Some(cond_shape) = Shape::indented(\n+            shape.indent.block_indent(context.config) + 3,\n+            context.config,\n+        ).sub_width(3)\n+        {\n             if let Some(cond_str) = guard.rewrite(context, cond_shape) {\n-                return Some(format!(\"\\n{}if {}\",\n-                                    shape\n-                                        .indent\n-                                        .block_indent(context.config)\n-                                        .to_string(context.config),\n-                                    cond_str));\n+                return Some(format!(\n+                    \"\\n{}if {}\",\n+                    shape.indent.block_indent(context.config).to_string(\n+                        context.config,\n+                    ),\n+                    cond_str\n+                ));\n             }\n         }\n \n@@ -1826,26 +1835,28 @@ fn rewrite_call_inner(\n     let span_lo = context.codemap.span_after(span, \"(\");\n     let args_span = mk_sp(span_lo, span.hi);\n \n-    let (extendable, list_str) = rewrite_call_args(context,\n-                                                   args,\n-                                                   args_span,\n-                                                   nested_shape,\n-                                                   one_line_width,\n-                                                   force_trailing_comma)\n-        .or_else(|| if context.use_block_indent() {\n-                     rewrite_call_args(context,\n-                                       args,\n-                                       args_span,\n-                                       Shape::indented(shape\n-                                                           .block()\n-                                                           .indent\n-                                                           .block_indent(context.config),\n-                                                       context.config),\n-                                       0,\n-                                       force_trailing_comma)\n-                 } else {\n-                     None\n-                 })\n+    let (extendable, list_str) = rewrite_call_args(\n+        context,\n+        args,\n+        args_span,\n+        nested_shape,\n+        one_line_width,\n+        force_trailing_comma,\n+    ).or_else(|| if context.use_block_indent() {\n+        rewrite_call_args(\n+            context,\n+            args,\n+            args_span,\n+            Shape::indented(\n+                shape.block().indent.block_indent(context.config),\n+                context.config,\n+            ),\n+            0,\n+            force_trailing_comma,\n+        )\n+    } else {\n+        None\n+    })\n         .ok_or(Ordering::Less)?;\n \n     if !context.use_block_indent() && need_block_indent(&list_str, nested_shape) && !extendable {\n@@ -1861,12 +1872,20 @@ fn rewrite_call_inner(\n         );\n     }\n \n-    let args_shape = shape\n-        .sub_width(last_line_width(&callee_str))\n-        .ok_or(Ordering::Less)?;\n-    Ok(format!(\"{}{}\",\n-               callee_str,\n-               wrap_args_with_parens(context, &list_str, extendable, args_shape, nested_shape)))\n+    let args_shape = shape.sub_width(last_line_width(&callee_str)).ok_or(\n+        Ordering::Less,\n+    )?;\n+    Ok(format!(\n+        \"{}{}\",\n+        callee_str,\n+        wrap_args_with_parens(\n+            context,\n+            &list_str,\n+            extendable,\n+            args_shape,\n+            nested_shape,\n+        )\n+    ))\n }\n \n fn need_block_indent(s: &str, shape: Shape) -> bool {\n@@ -2056,15 +2075,17 @@ fn paren_overhead(context: &RewriteContext) -> usize {\n     }\n }\n \n-fn wrap_args_with_parens(context: &RewriteContext,\n-                         args_str: &str,\n-                         is_extendable: bool,\n-                         shape: Shape,\n-                         nested_shape: Shape)\n-                         -> String {\n+fn wrap_args_with_parens(\n+    context: &RewriteContext,\n+    args_str: &str,\n+    is_extendable: bool,\n+    shape: Shape,\n+    nested_shape: Shape,\n+) -> String {\n     if !context.use_block_indent() ||\n-       (context.inside_macro && !args_str.contains('\\n') &&\n-        args_str.len() + paren_overhead(context) <= shape.width) || is_extendable {\n+        (context.inside_macro && !args_str.contains('\\n') &&\n+             args_str.len() + paren_overhead(context) <= shape.width) || is_extendable\n+    {\n         if context.config.spaces_within_parens() && args_str.len() > 0 {\n             format!(\"( {} )\", args_str)\n         } else {\n@@ -2166,10 +2187,9 @@ fn rewrite_struct_lit<'a>(\n         return Some(format!(\"{} {{}}\", path_str));\n     }\n \n-    let field_iter = fields\n-        .into_iter()\n-        .map(StructLitField::Regular)\n-        .chain(base.into_iter().map(StructLitField::Base));\n+    let field_iter = fields.into_iter().map(StructLitField::Regular).chain(\n+        base.into_iter().map(StructLitField::Base),\n+    );\n \n     // Foo { a: Foo } - indent is +3, width is -5.\n     let (h_shape, v_shape) = try_opt!(struct_lit_shape(shape, context, path_str.len() + 3, 2));"}, {"sha": "156528301be301ffc4683672813a9ac82260be03", "filename": "src/items.rs", "status": "modified", "additions": 193, "deletions": 130, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -550,11 +550,12 @@ impl<'a> FmtVisitor<'a> {\n     }\n }\n \n-pub fn format_impl(context: &RewriteContext,\n-                   item: &ast::Item,\n-                   offset: Indent,\n-                   where_span_end: Option<BytePos>)\n-                   -> Option<String> {\n+pub fn format_impl(\n+    context: &RewriteContext,\n+    item: &ast::Item,\n+    offset: Indent,\n+    where_span_end: Option<BytePos>,\n+) -> Option<String> {\n     if let ast::ItemKind::Impl(_, _, _, ref generics, _, _, ref items) = item.node {\n         let mut result = String::new();\n         let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n@@ -569,18 +570,26 @@ pub fn format_impl(context: &RewriteContext,\n                 .checked_sub(last_line_width(&result))\n                 .unwrap_or(0)\n         };\n-        let where_clause_str = try_opt!(rewrite_where_clause(context,\n-                                                             &generics.where_clause,\n-                                                             context.config.item_brace_style(),\n-                                                             Shape::legacy(where_budget,\n-                                                                           offset.block_only()),\n-                                                             context.config.where_density(),\n-                                                             \"{\",\n-                                                             false,\n-                                                             last_line_width(&ref_and_type) == 1,\n-                                                             where_span_end));\n-\n-        if try_opt!(is_impl_single_line(context, &items, &result, &where_clause_str, &item)) {\n+        let where_clause_str = try_opt!(rewrite_where_clause(\n+            context,\n+            &generics.where_clause,\n+            context.config.item_brace_style(),\n+            Shape::legacy(where_budget, offset.block_only()),\n+            context.config.where_density(),\n+            \"{\",\n+            false,\n+            last_line_width(&ref_and_type) == 1,\n+            where_span_end,\n+        ));\n+\n+        if try_opt!(is_impl_single_line(\n+            context,\n+            &items,\n+            &result,\n+            &where_clause_str,\n+            &item,\n+        ))\n+        {\n             result.push_str(&where_clause_str);\n             if where_clause_str.contains('\\n') {\n                 let white_space = offset.to_string(context.config);\n@@ -670,10 +679,11 @@ fn is_impl_single_line(\n     )\n }\n \n-fn format_impl_ref_and_type(context: &RewriteContext,\n-                            item: &ast::Item,\n-                            offset: Indent)\n-                            -> Option<String> {\n+fn format_impl_ref_and_type(\n+    context: &RewriteContext,\n+    item: &ast::Item,\n+    offset: Indent,\n+) -> Option<String> {\n     if let ast::ItemKind::Impl(unsafety,\n                             polarity,\n                             _,\n@@ -693,12 +703,18 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             Some(ref tr) => tr.path.span.lo,\n             None => self_ty.span.lo,\n         };\n-        let shape = generics_shape_from_config(context.config,\n-                                               Shape::indented(offset + last_line_width(&result),\n-                                                               context.config),\n-                                               0);\n-        let generics_str =\n-            try_opt!(rewrite_generics_inner(context, generics, shape, shape.width, mk_sp(lo, hi)));\n+        let shape = generics_shape_from_config(\n+            context.config,\n+            Shape::indented(offset + last_line_width(&result), context.config),\n+            0,\n+        );\n+        let generics_str = try_opt!(rewrite_generics_inner(\n+            context,\n+            generics,\n+            shape,\n+            shape.width,\n+            mk_sp(lo, hi),\n+        ));\n \n         let polarity_str = if polarity == ast::ImplPolarity::Negative {\n             \"!\"\n@@ -709,24 +725,34 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         if let Some(ref trait_ref) = *trait_ref {\n             let result_len = result.len();\n             if let Some(trait_ref_str) =\n-                rewrite_trait_ref(context,\n-                                  &trait_ref,\n-                                  offset,\n-                                  &generics_str,\n-                                  true,\n-                                  polarity_str,\n-                                  result_len) {\n+                rewrite_trait_ref(\n+                    context,\n+                    &trait_ref,\n+                    offset,\n+                    &generics_str,\n+                    true,\n+                    polarity_str,\n+                    result_len,\n+                )\n+            {\n                 result.push_str(&trait_ref_str);\n             } else {\n-                let generics_str =\n-                    try_opt!(rewrite_generics_inner(context, generics, shape, 0, mk_sp(lo, hi)));\n-                result.push_str(&try_opt!(rewrite_trait_ref(context,\n-                                                            &trait_ref,\n-                                                            offset,\n-                                                            &generics_str,\n-                                                            false,\n-                                                            polarity_str,\n-                                                            result_len)));\n+                let generics_str = try_opt!(rewrite_generics_inner(\n+                    context,\n+                    generics,\n+                    shape,\n+                    0,\n+                    mk_sp(lo, hi),\n+                ));\n+                result.push_str(&try_opt!(rewrite_trait_ref(\n+                    context,\n+                    &trait_ref,\n+                    offset,\n+                    &generics_str,\n+                    false,\n+                    polarity_str,\n+                    result_len,\n+                )));\n             }\n         } else {\n             result.push_str(&generics_str);\n@@ -777,59 +803,71 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n             Style::Legacy => new_line_offset + trait_ref_overhead,\n             Style::Rfc => new_line_offset,\n         };\n-        result.push_str(&*try_opt!(self_ty.rewrite(context, Shape::legacy(budget, type_offset))));\n+        result.push_str(&*try_opt!(self_ty.rewrite(\n+            context,\n+            Shape::legacy(budget, type_offset),\n+        )));\n         Some(result)\n     } else {\n         unreachable!();\n     }\n }\n \n-fn rewrite_trait_ref(context: &RewriteContext,\n-                     trait_ref: &ast::TraitRef,\n-                     offset: Indent,\n-                     generics_str: &str,\n-                     retry: bool,\n-                     polarity_str: &str,\n-                     result_len: usize)\n-                     -> Option<String> {\n+fn rewrite_trait_ref(\n+    context: &RewriteContext,\n+    trait_ref: &ast::TraitRef,\n+    offset: Indent,\n+    generics_str: &str,\n+    retry: bool,\n+    polarity_str: &str,\n+    result_len: usize,\n+) -> Option<String> {\n     // 1 = space between generics and trait_ref\n     let used_space = 1 + polarity_str.len() +\n-                     if generics_str.contains('\\n') {\n-                         last_line_width(&generics_str)\n-                     } else {\n-                         result_len + generics_str.len()\n-                     };\n+        if generics_str.contains('\\n') {\n+            last_line_width(&generics_str)\n+        } else {\n+            result_len + generics_str.len()\n+        };\n     let shape = Shape::indented(offset + used_space, context.config);\n     if let Some(trait_ref_str) = trait_ref.rewrite(context, shape) {\n         if !(retry && trait_ref_str.contains('\\n')) {\n-            return Some(format!(\"{} {}{}\", generics_str, polarity_str, &trait_ref_str));\n+            return Some(format!(\n+                \"{} {}{}\",\n+                generics_str,\n+                polarity_str,\n+                &trait_ref_str\n+            ));\n         }\n     }\n     // We could not make enough space for trait_ref, so put it on new line.\n     if !retry {\n         let offset = offset.block_indent(context.config);\n         let shape = Shape::indented(offset, context.config);\n         let trait_ref_str = try_opt!(trait_ref.rewrite(context, shape));\n-        Some(format!(\"{}\\n{}{}{}\",\n-                     generics_str,\n-                     &offset.to_string(context.config),\n-                     polarity_str,\n-                     &trait_ref_str))\n+        Some(format!(\n+            \"{}\\n{}{}{}\",\n+            generics_str,\n+            &offset.to_string(context.config),\n+            polarity_str,\n+            &trait_ref_str\n+        ))\n     } else {\n         None\n     }\n }\n \n-pub fn format_struct(context: &RewriteContext,\n-                     item_name: &str,\n-                     ident: ast::Ident,\n-                     vis: &ast::Visibility,\n-                     struct_def: &ast::VariantData,\n-                     generics: Option<&ast::Generics>,\n-                     span: Span,\n-                     offset: Indent,\n-                     one_line_width: Option<usize>)\n-                     -> Option<String> {\n+pub fn format_struct(\n+    context: &RewriteContext,\n+    item_name: &str,\n+    ident: ast::Ident,\n+    vis: &ast::Visibility,\n+    struct_def: &ast::VariantData,\n+    generics: Option<&ast::Generics>,\n+    span: Span,\n+    offset: Indent,\n+    one_line_width: Option<usize>,\n+) -> Option<String> {\n     match *struct_def {\n         ast::VariantData::Unit(..) => Some(format_unit_struct(item_name, ident, vis)),\n         ast::VariantData::Tuple(ref fields, _) => {\n@@ -877,8 +915,12 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let body_lo = context.codemap.span_after(item.span, \"{\");\n \n         let shape = Shape::indented(offset + last_line_width(&result), context.config);\n-        let generics_str =\n-            try_opt!(rewrite_generics(context, generics, shape, mk_sp(item.span.lo, body_lo)));\n+        let generics_str = try_opt!(rewrite_generics(\n+            context,\n+            generics,\n+            shape,\n+            mk_sp(item.span.lo, body_lo),\n+        ));\n         result.push_str(&generics_str);\n \n         let trait_bound_str = try_opt!(rewrite_trait_bounds(\n@@ -1534,10 +1576,12 @@ pub fn rewrite_associated_type(\n     let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n         let shape = Shape::legacy(context.config.max_width(), indent);\n         let bounds: &[_] = ty_param_bounds;\n-        let bound_str = try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                                     .collect::<Option<Vec<_>>>());\n+        let bound_str = try_opt!(\n+            bounds\n+                .iter()\n+                .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                .collect::<Option<Vec<_>>>()\n+        );\n         if bounds.len() > 0 {\n             format!(\": {}\", join_bounds(context, shape, &bound_str))\n         } else {\n@@ -2269,7 +2313,8 @@ fn compute_budgets_for_args(\n             // 4 = \"() {\".len()\n             let multi_line_overhead = indent.width() + result.len() +\n                 if newline_brace { 2 } else { 4 };\n-            let multi_line_budget = try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n+            let multi_line_budget =\n+                try_opt!(context.config.max_width().checked_sub(multi_line_overhead));\n \n             return Some((\n                 one_line_budget,\n@@ -2295,22 +2340,24 @@ fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n     }\n }\n \n-fn rewrite_generics(context: &RewriteContext,\n-                    generics: &ast::Generics,\n-                    shape: Shape,\n-                    span: Span)\n-                    -> Option<String> {\n+fn rewrite_generics(\n+    context: &RewriteContext,\n+    generics: &ast::Generics,\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n     let shape = generics_shape_from_config(context.config, shape, 0);\n     rewrite_generics_inner(context, generics, shape, shape.width, span)\n         .or_else(|| rewrite_generics_inner(context, generics, shape, 0, span))\n }\n \n-fn rewrite_generics_inner(context: &RewriteContext,\n-                          generics: &ast::Generics,\n-                          shape: Shape,\n-                          one_line_width: usize,\n-                          span: Span)\n-                          -> Option<String> {\n+fn rewrite_generics_inner(\n+    context: &RewriteContext,\n+    generics: &ast::Generics,\n+    shape: Shape,\n+    one_line_width: usize,\n+    span: Span,\n+) -> Option<String> {\n     // FIXME: convert bounds to where clauses where they get too big or if\n     // there is a where clause at all.\n     let lifetimes: &[_] = &generics.lifetimes;\n@@ -2334,15 +2381,17 @@ fn rewrite_generics_inner(context: &RewriteContext,\n     });\n     let ty_spans = tys.iter().map(span_for_ty_param);\n \n-    let items = itemize_list(context.codemap,\n-                             lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n-                             \">\",\n-                             |&(sp, _)| sp.lo,\n-                             |&(sp, _)| sp.hi,\n-                             // FIXME: don't clone\n-                             |&(_, ref str)| str.clone(),\n-                             context.codemap.span_after(span, \"<\"),\n-                             span.hi);\n+    let items = itemize_list(\n+        context.codemap,\n+        lt_spans.chain(ty_spans).zip(lt_strs.chain(ty_strs)),\n+        \">\",\n+        |&(sp, _)| sp.lo,\n+        |&(sp, _)| sp.hi,\n+        // FIXME: don't clone\n+        |&(_, ref str)| str.clone(),\n+        context.codemap.span_after(span, \"<\"),\n+        span.hi,\n+    );\n     format_generics_item_list(context, items, shape, one_line_width)\n }\n \n@@ -2357,12 +2406,14 @@ pub fn generics_shape_from_config(config: &Config, shape: Shape, offset: usize)\n     }\n }\n \n-pub fn format_generics_item_list<I>(context: &RewriteContext,\n-                                    items: I,\n-                                    shape: Shape,\n-                                    one_line_budget: usize)\n-                                    -> Option<String>\n-    where I: Iterator<Item = ListItem>\n+pub fn format_generics_item_list<I>(\n+    context: &RewriteContext,\n+    items: I,\n+    shape: Shape,\n+    one_line_budget: usize,\n+) -> Option<String>\n+where\n+    I: Iterator<Item = ListItem>,\n {\n     let item_vec = items.collect::<Vec<_>>();\n \n@@ -2381,21 +2432,29 @@ pub fn format_generics_item_list<I>(context: &RewriteContext,\n \n     let list_str = try_opt!(write_list(&item_vec, &fmt));\n \n-    Some(wrap_generics_with_angle_brackets(context, &list_str, shape.indent))\n+    Some(wrap_generics_with_angle_brackets(\n+        context,\n+        &list_str,\n+        shape.indent,\n+    ))\n }\n \n-pub fn wrap_generics_with_angle_brackets(context: &RewriteContext,\n-                                         list_str: &str,\n-                                         list_offset: Indent)\n-                                         -> String {\n+pub fn wrap_generics_with_angle_brackets(\n+    context: &RewriteContext,\n+    list_str: &str,\n+    list_offset: Indent,\n+) -> String {\n     if context.config.generics_indent() == IndentStyle::Block &&\n-       (list_str.contains('\\n') || list_str.ends_with(',')) {\n-        format!(\"<\\n{}{}\\n{}>\",\n-                list_offset.to_string(context.config),\n-                list_str,\n-                list_offset\n-                    .block_unindent(context.config)\n-                    .to_string(context.config))\n+        (list_str.contains('\\n') || list_str.ends_with(','))\n+    {\n+        format!(\n+            \"<\\n{}{}\\n{}>\",\n+            list_offset.to_string(context.config),\n+            list_str,\n+            list_offset.block_unindent(context.config).to_string(\n+                context.config,\n+            )\n+        )\n     } else if context.config.spaces_within_angle_brackets() {\n         format!(\"< {} >\", list_str)\n     } else {\n@@ -2413,10 +2472,12 @@ fn rewrite_trait_bounds(\n     if bounds.is_empty() {\n         return Some(String::new());\n     }\n-    let bound_str = try_opt!(bounds\n-                                 .iter()\n-                                 .map(|ty_bound| ty_bound.rewrite(&context, shape))\n-                                 .collect::<Option<Vec<_>>>());\n+    let bound_str = try_opt!(\n+        bounds\n+            .iter()\n+            .map(|ty_bound| ty_bound.rewrite(&context, shape))\n+            .collect::<Option<Vec<_>>>()\n+    );\n     Some(format!(\": {}\", join_bounds(context, shape, &bound_str)))\n }\n \n@@ -2446,14 +2507,16 @@ fn rewrite_where_clause_rfc_style(\n     let len = where_clause.predicates.len();\n     let end_of_preds = span_for_where_pred(&where_clause.predicates[len - 1]).hi;\n     let span_end = span_end.unwrap_or(end_of_preds);\n-    let items = itemize_list(context.codemap,\n-                             where_clause.predicates.iter(),\n-                             terminator,\n-                             |pred| span_for_where_pred(pred).lo,\n-                             |pred| span_for_where_pred(pred).hi,\n-                             |pred| pred.rewrite(context, shape),\n-                             span_start,\n-                             span_end);\n+    let items = itemize_list(\n+        context.codemap,\n+        where_clause.predicates.iter(),\n+        terminator,\n+        |pred| span_for_where_pred(pred).lo,\n+        |pred| span_for_where_pred(pred).hi,\n+        |pred| pred.rewrite(context, shape),\n+        span_start,\n+        span_end,\n+    );\n     let comma_tactic = if suppress_comma {\n         SeparatorTactic::Never\n     } else {"}, {"sha": "2aa477ccafa44a37a5ad49930224ec52f6277c0b", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -468,8 +468,10 @@ where\n         }\n         // Reset the error count.\n         if parse_session.span_diagnostic.has_errors() {\n-            let silent_emitter = Box::new(EmitterWriter::new(Box::new(Vec::new()),\n-                                                             Some(codemap.clone())));\n+            let silent_emitter = Box::new(EmitterWriter::new(\n+                Box::new(Vec::new()),\n+                Some(codemap.clone()),\n+            ));\n             parse_session.span_diagnostic = Handler::with_emitter(true, false, silent_emitter);\n         }\n     }"}, {"sha": "24bd10e24a0b0d0883cc5e0ee7fad3918fe912b4", "filename": "src/lists.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -555,20 +555,20 @@ pub fn struct_lit_shape(\n     prefix_width: usize,\n     suffix_width: usize,\n ) -> Option<(Option<Shape>, Shape)> {\n-    let v_shape =\n-        match context.config.struct_lit_style() {\n-            IndentStyle::Visual => {\n-                try_opt!(try_opt!(shape.visual_indent(0).shrink_left(prefix_width))\n-                         .sub_width(suffix_width))\n-            }\n-            IndentStyle::Block => {\n-                let shape = shape.block_indent(context.config.tab_spaces());\n-                Shape {\n-                    width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n-                    ..shape\n-                }\n+    let v_shape = match context.config.struct_lit_style() {\n+        IndentStyle::Visual => {\n+            try_opt!(\n+                try_opt!(shape.visual_indent(0).shrink_left(prefix_width)).sub_width(suffix_width)\n+            )\n+        }\n+        IndentStyle::Block => {\n+            let shape = shape.block_indent(context.config.tab_spaces());\n+            Shape {\n+                width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n+                ..shape\n             }\n-        };\n+        }\n+    };\n     let h_shape = shape.sub_width(prefix_width + suffix_width);\n     Some((h_shape, v_shape))\n }"}, {"sha": "25290ceaf0e0e001b9413a1a06c7bfdaa9443243", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -81,7 +81,8 @@ impl Rewrite for Pat {\n                 rewrite_path(context, PathContext::Expr, q_self.as_ref(), path, shape)\n             }\n             PatKind::TupleStruct(ref path, ref pat_vec, dotdot_pos) => {\n-                let path_str = try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n+                let path_str =\n+                    try_opt!(rewrite_path(context, PathContext::Expr, None, path, shape));\n                 rewrite_tuple_pat(\n                     pat_vec,\n                     dotdot_pos,"}, {"sha": "6c20c18ca475a0e2732d3a9bc25b20b59393a233", "filename": "src/string.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -42,12 +42,10 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n \n     // `cur_start` is the position in `orig` of the start of the current line.\n     let mut cur_start = 0;\n-    let mut result = String::with_capacity(\n-        stripped_str\n-            .len()\n-            .checked_next_power_of_two()\n-            .unwrap_or(usize::max_value()),\n-    );\n+    let mut result =\n+        String::with_capacity(stripped_str.len().checked_next_power_of_two().unwrap_or(\n+            usize::max_value(),\n+        ));\n     result.push_str(fmt.opener);\n \n     let ender_length = fmt.line_end.len();"}, {"sha": "5e57ce790a75f2f69778bd7b24770ae71ec67cf3", "filename": "src/types.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -226,18 +226,22 @@ fn rewrite_segment(\n \n                 let generics_shape =\n                     generics_shape_from_config(context.config, shape, separator.len());\n-                let items = itemize_list(context.codemap,\n-                                         param_list.into_iter(),\n-                                         \">\",\n-                                         |param| param.get_span().lo,\n-                                         |param| param.get_span().hi,\n-                                         |seg| seg.rewrite(context, generics_shape),\n-                                         list_lo,\n-                                         span_hi);\n-                let generics_str = try_opt!(format_generics_item_list(context,\n-                                                                      items,\n-                                                                      generics_shape,\n-                                                                      generics_shape.width));\n+                let items = itemize_list(\n+                    context.codemap,\n+                    param_list.into_iter(),\n+                    \">\",\n+                    |param| param.get_span().lo,\n+                    |param| param.get_span().hi,\n+                    |seg| seg.rewrite(context, generics_shape),\n+                    list_lo,\n+                    span_hi,\n+                );\n+                let generics_str = try_opt!(format_generics_item_list(\n+                    context,\n+                    items,\n+                    generics_shape,\n+                    generics_shape.width,\n+                ));\n \n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n@@ -307,9 +311,9 @@ where\n         context.codemap,\n         // FIXME Would be nice to avoid this allocation,\n         // but I couldn't get the types to work out.\n-        inputs\n-            .map(|i| ArgumentKind::Regular(Box::new(i)))\n-            .chain(variadic_arg),\n+        inputs.map(|i| ArgumentKind::Regular(Box::new(i))).chain(\n+            variadic_arg,\n+        ),\n         \")\",\n         |arg| match *arg {\n             ArgumentKind::Regular(ref ty) => ty.span().lo,\n@@ -387,11 +391,12 @@ impl Rewrite for ast::WherePredicate {\n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n                     let ty_shape = try_opt!(shape.block_left(used_width));\n-                    let bounds: Vec<_> =\n-                        try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                                     .collect());\n+                    let bounds: Vec<_> = try_opt!(\n+                        bounds\n+                            .iter()\n+                            .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                            .collect()\n+                    );\n                     let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n@@ -411,11 +416,12 @@ impl Rewrite for ast::WherePredicate {\n                         Style::Legacy => try_opt!(shape.block_left(used_width)),\n                         Style::Rfc => shape.block_indent(context.config.tab_spaces()),\n                     };\n-                    let bounds: Vec<_> =\n-                        try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n-                                     .collect());\n+                    let bounds: Vec<_> = try_opt!(\n+                        bounds\n+                            .iter()\n+                            .map(|ty_bound| ty_bound.rewrite(context, ty_shape))\n+                            .collect()\n+                    );\n                     let bounds_str = join_bounds(context, ty_shape, &bounds);\n \n                     format!(\"{}{}{}\", type_str, colon, bounds_str)\n@@ -482,10 +488,12 @@ where\n         );\n         let colon = type_bound_colon(context);\n         let overhead = last_line_width(&result) + colon.len();\n-        let result = format!(\"{}{}{}\",\n-                             result,\n-                             colon,\n-                             join_bounds(context, try_opt!(shape.sub_width(overhead)), &appendix));\n+        let result = format!(\n+            \"{}{}{}\",\n+            result,\n+            colon,\n+            join_bounds(context, try_opt!(shape.sub_width(overhead)), &appendix)\n+        );\n         wrap_str(result, context.config.max_width(), shape)\n     }\n }\n@@ -540,10 +548,12 @@ impl Rewrite for ast::TyParam {\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n             result.push_str(type_bound_colon(context));\n-            let strs: Vec<_> = try_opt!(self.bounds\n-                                            .iter()\n-                                            .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                                            .collect());\n+            let strs: Vec<_> = try_opt!(\n+                self.bounds\n+                    .iter()\n+                    .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                    .collect()\n+            );\n             result.push_str(&join_bounds(context, shape, &strs));\n         }\n         if let Some(ref def) = self.default {"}, {"sha": "056ded71daae6de81521e4cfecd13fbde1eb78a6", "filename": "tests/target/big-impl.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fbig-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fbig-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fbig-impl.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -1,24 +1,27 @@\n // #1357\n impl<'a, Select, From, Distinct, Where, Order, Limit, Offset, Groupby, DB> InternalBoxedDsl<'a, DB>\n     for SelectStatement<Select, From, Distinct, Where, Order, Limit, Offset, GroupBy>\n-    where DB: Backend,\n-          Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n-          Distinct: QueryFragment<DB> + 'a,\n-          Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n-          Order: QueryFragment<DB> + 'a,\n-          Limit: QueryFragment<DB> + 'a,\n-          Offset: QueryFragment<DB> + 'a\n+where\n+    DB: Backend,\n+    Select: QueryFragment<DB> + SelectableExpression<From> + 'a,\n+    Distinct: QueryFragment<DB> + 'a,\n+    Where: Into<Option<Box<QueryFragment<DB> + 'a>>>,\n+    Order: QueryFragment<DB> + 'a,\n+    Limit: QueryFragment<DB> + 'a,\n+    Offset: QueryFragment<DB> + 'a,\n {\n     type Output = BoxedSelectStatement<'a, Select::SqlTypeForSelect, From, DB>;\n \n     fn internal_into_boxed(self) -> Self::Output {\n-        BoxedSelectStatement::new(Box::new(self.select),\n-                                  self.from,\n-                                  Box::new(self.distinct),\n-                                  self.where_clause.into(),\n-                                  Box::new(self.order),\n-                                  Box::new(self.limit),\n-                                  Box::new(self.offset))\n+        BoxedSelectStatement::new(\n+            Box::new(self.select),\n+            self.from,\n+            Box::new(self.distinct),\n+            self.where_clause.into(),\n+            Box::new(self.order),\n+            Box::new(self.limit),\n+            Box::new(self.offset),\n+        )\n     }\n }\n \n@@ -31,32 +34,39 @@ impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessiv\n     for Bar {\n     fn foo() {}\n }\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n-                                            ExcessivelyLongGenericName,\n-                                            AnotherExcessivelyLongGenericName> for Bar {\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar {\n     fn foo() {}\n }\n impl<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName> Foo\n-    for Bar<ExcessivelyLongGenericName,\n-            ExcessivelyLongGenericName,\n-            AnotherExcessivelyLongGenericName> {\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n     fn foo() {}\n }\n impl Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n-    for Bar<ExcessivelyLongGenericName,\n-            ExcessivelyLongGenericName,\n-            AnotherExcessivelyLongGenericName> {\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n     fn foo() {}\n }\n-impl<ExcessivelyLongGenericName,\n-     ExcessivelyLongGenericName,\n-     AnotherExcessivelyLongGenericName> Foo<ExcessivelyLongGenericName,\n-                                            ExcessivelyLongGenericName,\n-                                            AnotherExcessivelyLongGenericName>\n-    for Bar<ExcessivelyLongGenericName,\n-            ExcessivelyLongGenericName,\n-            AnotherExcessivelyLongGenericName> {\n+impl<\n+    ExcessivelyLongGenericName,\n+    ExcessivelyLongGenericName,\n+    AnotherExcessivelyLongGenericName,\n+> Foo<ExcessivelyLongGenericName, ExcessivelyLongGenericName, AnotherExcessivelyLongGenericName>\n+    for Bar<\n+        ExcessivelyLongGenericName,\n+        ExcessivelyLongGenericName,\n+        AnotherExcessivelyLongGenericName,\n+    > {\n     fn foo() {}\n }"}, {"sha": "0950a716fde71fdfa0f853b32f54f1c286470065", "filename": "tests/target/configs-generics_indent-block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fconfigs-generics_indent-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fconfigs-generics_indent-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-generics_indent-block.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -9,7 +9,8 @@ fn lorem<\n     Adipiscing: Eq = usize,\n     Consectetur: Eq = usize,\n     Elit: Eq = usize,\n->(ipsum: Ipsum,\n+>(\n+    ipsum: Ipsum,\n     dolor: Dolor,\n     sit: Sit,\n     amet: Amet,"}, {"sha": "102c1449627d9e3e17fc900cc58ac7253fa59cc0", "filename": "tests/target/fn-simple.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ffn-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ffn-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn-simple.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -8,8 +8,10 @@ fn simple(\n     fn op(\n         x: Typ,\n         key: &[u8],\n-        upd: Box<Fn(Option<&memcache::Item>)\n-                    -> (memcache::Status, Result<memcache::Item, Option<String>>)>,\n+        upd: Box<\n+            Fn(Option<&memcache::Item>)\n+               -> (memcache::Status, Result<memcache::Item, Option<String>>),\n+        >,\n     ) -> MapResult {\n     }\n \n@@ -33,14 +35,14 @@ fn weird_comment(\n fn generic<T>(arg: T) -> &SomeType\n where\n     T: Fn(// First arg\n-          A,\n-          // Second argument\n-          B,\n-          C,\n-          D,\n-          // pre comment\n-          E /* last comment */)\n-          -> &SomeType,\n+       A,\n+       // Second argument\n+       B,\n+       C,\n+       D,\n+       // pre comment\n+       E /* last comment */)\n+       -> &SomeType,\n {\n     arg(a, b, c, d, e)\n }"}, {"sha": "c8102fe3b54081bd279a009a1634e69209e71b37", "filename": "tests/target/fn.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ffn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ffn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffn.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -55,7 +55,7 @@ pub fn render<\n     N: Clone + 'a,\n     E: Clone + 'a,\n     G: Labeller<'a, N, E> + GraphWalk<'a, N, E>,\n-    W: Write\n+    W: Write,\n >(\n     g: &'a G,\n     w: &mut W,\n@@ -101,7 +101,10 @@ fn foo(a: i32) -> i32 {\n \n fn ______________________baz(\n     a: i32,\n-) -> *mut ::std::option::Option<extern \"C\" fn(arg1: i32, _____________________a: i32, arg3: i32) -> ()> {\n+) -> *mut ::std::option::Option<\n+    extern \"C\" fn(arg1: i32, _____________________a: i32, arg3: i32)\n+                  -> (),\n+> {\n }\n \n pub fn check_path<'a, 'tcx>("}, {"sha": "42d3875ad19af84c13246dcc828cb77e43bb7e3a", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -58,14 +58,14 @@ fn main() {\n \tfn generic<T>(arg: T) -> &SomeType\n \twhere\n \t\tT: Fn(// First arg\n-\t\t      A,\n-\t\t      // Second argument\n-\t\t      B,\n-\t\t      C,\n-\t\t      D,\n-\t\t      // pre comment\n-\t\t      E /* last comment */)\n-\t\t      -> &SomeType,\n+\t\t   A,\n+\t\t   // Second argument\n+\t\t   B,\n+\t\t   C,\n+\t\t   D,\n+\t\t   // pre comment\n+\t\t   E /* last comment */)\n+\t\t   -> &SomeType,\n \t{\n \t\targ(a, b, c, d, e)\n \t}"}, {"sha": "54fe361bb4e7c3ee24b27d2cc349440813f3ca14", "filename": "tests/target/issue-510.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fissue-510.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fissue-510.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-510.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -5,24 +5,23 @@ impl ISizeAndMarginsComputer for AbsoluteNonReplaced {\n         input: &ISizeConstraintInput,\n     ) -> ISizeConstraintSolution {\n \n-        let (inline_start, inline_size, margin_inline_start, margin_inline_end) =\n-            match (\n-                inline_startssssssxxxxxxsssssxxxxxxxxxssssssxxx,\n-                inline_startssssssxxxxxxsssssxxxxxxxxxssssssxxx,\n-            ) {\n-                (MaybeAuto::Auto, MaybeAuto::Auto, MaybeAuto::Auto) => {\n-                    let margin_start = inline_start_margin.specified_or_zero();\n-                    let margin_end = inline_end_margin.specified_or_zero();\n-                    // Now it is the same situation as inline-start Specified and inline-end\n-                    // and inline-size Auto.\n-                    //\n-                    // Set inline-end to zero to calculate inline-size.\n-                    let inline_size = block.get_shrink_to_fit_inline_size(\n-                        available_inline_size - (margin_start + margin_end),\n-                    );\n-                    (Au(0), inline_size, margin_start, margin_end)\n-                }\n-            };\n+        let (inline_start, inline_size, margin_inline_start, margin_inline_end) = match (\n+            inline_startssssssxxxxxxsssssxxxxxxxxxssssssxxx,\n+            inline_startssssssxxxxxxsssssxxxxxxxxxssssssxxx,\n+        ) {\n+            (MaybeAuto::Auto, MaybeAuto::Auto, MaybeAuto::Auto) => {\n+                let margin_start = inline_start_margin.specified_or_zero();\n+                let margin_end = inline_end_margin.specified_or_zero();\n+                // Now it is the same situation as inline-start Specified and inline-end\n+                // and inline-size Auto.\n+                //\n+                // Set inline-end to zero to calculate inline-size.\n+                let inline_size = block.get_shrink_to_fit_inline_size(\n+                    available_inline_size - (margin_start + margin_end),\n+                );\n+                (Au(0), inline_size, margin_start, margin_end)\n+            }\n+        };\n \n         let (inline_start, inline_size, margin_inline_start, margin_inline_end) =\n             match (inline_start, inline_end, computed_inline_size) {"}, {"sha": "6f4e3a8de2198857de237941c9a7f29d48ee6865", "filename": "tests/target/long-match-arms-brace-newline.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Flong-match-arms-brace-newline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Flong-match-arms-brace-newline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Flong-match-arms-brace-newline.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -5,12 +5,8 @@\n fn main() {\n     match x\n     {\n-        aaaaaaaa::Bbbbb::Ccccccccccccc(_, Some(ref x)) if x ==\n-                                                              \"aaaaaaaaaaa \\\n-                                                               aaaaaaa aaaaaa\" =>\n-        {\n-            Ok(())\n-        }\n+        aaaaaaaa::Bbbbb::Ccccccccccccc(_, Some(ref x))\n+            if x == \"aaaaaaaaaaa aaaaaaa aaaaaa\" => Ok(()),\n         _ => Err(x),\n     }\n }"}, {"sha": "35b97094535420690c618048645734f6a39a4864", "filename": "tests/target/match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -323,7 +323,8 @@ fn guards() {\n                                                                           barrrrrrrrrrrr => {}\n         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n             if fooooooooooooooooooooo &&\n-               (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb || cccccccccccccccccccccccccccccccccccccccc) => {\n+                   (bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb || cccccccccccccccccccccccccccccccccccccccc) => {\n+            {}\n         }\n     }\n }"}, {"sha": "49d0520a5d1a42cf5f7104a31051164b8fa7f294", "filename": "tests/target/multiple.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fmultiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fmultiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmultiple.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -40,7 +40,7 @@ where\n \n fn baz<\n     'a: 'b, // comment on 'a\n-    T: SomsssssssssssssssssssssssssssssssssssssssssssssssssssssseType /* comment on T */\n+    T: SomsssssssssssssssssssssssssssssssssssssssssssssssssssssseType, /* comment on T */\n >(\n     a: A,\n     b: B, // comment on b\n@@ -164,11 +164,11 @@ fn deconstruct()\n fn deconstruct(\n     foo: Bar,\n ) -> (SocketAddr,\n-                                    Method,\n-                                    Headers,\n-                                    RequestUri,\n-                                    HttpVersion,\n-                                    AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) {\n+      Method,\n+      Headers,\n+      RequestUri,\n+      HttpVersion,\n+      AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA) {\n }\n \n #[rustfmt_skip]"}, {"sha": "9b48dd9a470b6d483c259b853ae0a03c802c524a", "filename": "tests/target/paths.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fpaths.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -1,18 +1,18 @@\n // rustfmt-normalize_comments: true\n \n fn main() {\n-    let constellation_chan = Constellation::<layout::layout_task::LayoutTask,\n-                                             script::script_task::ScriptTask>::start(\n-        compositor_proxy,\n-        resource_task,\n-        image_cache_task,\n-        font_cache_task,\n-        time_profiler_chan,\n-        mem_profiler_chan,\n-        devtools_chan,\n-        storage_task,\n-        supports_clipboard,\n-    );\n+    let constellation_chan =\n+        Constellation::<layout::layout_task::LayoutTask, script::script_task::ScriptTask>::start(\n+            compositor_proxy,\n+            resource_task,\n+            image_cache_task,\n+            font_cache_task,\n+            time_profiler_chan,\n+            mem_profiler_chan,\n+            devtools_chan,\n+            storage_task,\n+            supports_clipboard,\n+        );\n \n     Quux::<ParamOne /* Comment 1 */, ParamTwo /* Comment 2 */>::some_func();\n "}, {"sha": "fc92d379a52ec3e4bcaac2e3a9b723ca88adc44e", "filename": "tests/target/string-lit.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fstring-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Fstring-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fstring-lit.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -25,10 +25,9 @@ formatting\"#;\n \n     filename.replace(\" \", \"\\\\\");\n \n-    let xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx =\n-        funktion(\n-            \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\",\n-        );\n+    let xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx = funktion(\n+        \"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy\",\n+    );\n \n     let unicode = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n     let unicode2 = \"L\u00f6we \u8001\u864e L\u00e9opard\";"}, {"sha": "c5e6b9525b49b6a4ba11154ea0d05b2f46246e75", "filename": "tests/target/trailing_commas.rs", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftrailing_commas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftrailing_commas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftrailing_commas.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -11,7 +11,12 @@ fn main() {\n     }\n }\n \n-fn f<S, T>(x: T, y: S) -> T\n+fn f<\n+    S, T,\n+>(\n+    x: T,\n+    y: S,\n+) -> T\n where\n     T: P,\n     S: Q,\n@@ -31,45 +36,66 @@ where\n     }\n }\n \n-struct Pair<S, T>\n-where\n+struct Pair<\n+    S, T,\n+> where\n     T: P,\n     S: P + Q,\n {\n     a: T,\n     b: S,\n }\n \n-struct TupPair<S, T>(S, T)\n+struct TupPair<\n+    S, T,\n+>(S, T)\n where\n     T: P,\n     S: P + Q;\n \n-enum E<S, T>\n-where\n+enum E<\n+    S, T,\n+> where\n     S: P,\n     T: P,\n {\n     A { a: T, },\n }\n \n-type Double<T> where\n+type Double<\n+    T,\n+> where\n     T: P,\n-    T: Q = Pair<T, T>;\n+    T: Q = Pair<\n+    T, T,\n+>;\n \n extern \"C\" {\n-    fn f<S, T>(x: T, y: S) -> T\n+    fn f<\n+        S, T,\n+    >(\n+        x: T,\n+        y: S,\n+    ) -> T\n     where\n         T: P,\n         S: Q;\n }\n \n-trait Q<S, T>\n-where\n+trait Q<\n+    S, T,\n+> where\n     T: P,\n     S: R,\n {\n-    fn f<U, V>(self, x: T, y: S, z: U) -> Self\n+    fn f<\n+        U, V,\n+    >(\n+        self,\n+        x: T,\n+        y: S,\n+        z: U,\n+    ) -> Self\n     where\n         U: P,\n         V: P;"}, {"sha": "772cb251f5743bca14c4b003152c2af2568a1f66", "filename": "tests/target/tuple.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftuple.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -65,7 +65,9 @@ fn issue775() {\n                 (\n                     \"b\".to_string(),\n                     Array(vec![\n-                        mk_object(&[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]),\n+                        mk_object(\n+                            &[(\"c\".to_string(), String(\"\\x0c\\r\".to_string()))]\n+                        ),\n                         mk_object(&[(\"d\".to_string(), String(\"\".to_string()))]),\n                     ]),\n                 ),"}, {"sha": "cd40f65d6e1ad618cdd1fbc1ea6b93a8aa2742d9", "filename": "tests/target/type_alias.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18ccd0190ee6ef4a6e1bb9d737e515b872009711/tests%2Ftarget%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ftype_alias.rs?ref=18ccd0190ee6ef4a6e1bb9d737e515b872009711", "patch": "@@ -3,9 +3,11 @@\n type PrivateTest<'a, I> = (Box<Parser<Input = I, Output = char> + 'a>,\n                            Box<Parser<Input = I, Output = char> + 'a>);\n \n-pub type PublicTest<'a, I, O> = Result<Vec<MyLongType>,\n-                                       Box<Parser<Input = I, Output = char> + 'a>,\n-                                       Box<Parser<Input = I, Output = char> + 'a>>;\n+pub type PublicTest<'a, I, O> = Result<\n+    Vec<MyLongType>,\n+    Box<Parser<Input = I, Output = char> + 'a>,\n+    Box<Parser<Input = I, Output = char> + 'a>,\n+>;\n \n pub type LongGenericListTest<\n     'a,\n@@ -17,7 +19,7 @@ pub type LongGenericListTest<\n     LONGPARAMETERNAME,\n     A,\n     B,\n-    C\n+    C,\n > = Option<Vec<MyType>>;\n \n pub type Exactly100CharsTest<'a, 'b, 'c, 'd, LONGPARAMETERNAME, LONGPARAMETERNAME, A, B> = Vec<i32>;\n@@ -37,13 +39,13 @@ pub type GenericsFitButNotEqualTest<\n     LONGPARAMETERNAME,\n     A1,\n     B,\n-    C\n+    C,\n > = Vec<i32>;\n \n pub type CommentTest<\n     // Lifetime\n     'a, // Type\n-    T\n+    T,\n > = ();\n \n "}]}