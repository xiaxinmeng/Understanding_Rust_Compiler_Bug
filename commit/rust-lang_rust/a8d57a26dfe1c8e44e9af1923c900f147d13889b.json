{"sha": "a8d57a26dfe1c8e44e9af1923c900f147d13889b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDU3YTI2ZGZlMWM4ZTQ0ZTlhZjE5MjNjOTAwZjE0N2QxMzg4OWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-02-27T23:53:36Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-02-28T05:04:05Z"}, "message": "Fix bytepos_to_file_charpos.\n\nMake bytepos_to_charpos relative to the start of the filemap rather than its previous behaviour which was to be realtive to the start of the codemap, but ignoring multi-byte chars in earlier filemaps. Rename to bytepos_to_file_charpos. Add tests for multi-byte chars.", "tree": {"sha": "6b251a76724c67aa0f3b7770f2138bea34bdf033", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b251a76724c67aa0f3b7770f2138bea34bdf033"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d57a26dfe1c8e44e9af1923c900f147d13889b", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d57a26dfe1c8e44e9af1923c900f147d13889b", "html_url": "https://github.com/rust-lang/rust/commit/a8d57a26dfe1c8e44e9af1923c900f147d13889b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d57a26dfe1c8e44e9af1923c900f147d13889b/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53a3f281158bf584361ad63400ba0b4a88472b23", "url": "https://api.github.com/repos/rust-lang/rust/commits/53a3f281158bf584361ad63400ba0b4a88472b23", "html_url": "https://github.com/rust-lang/rust/commit/53a3f281158bf584361ad63400ba0b4a88472b23"}], "stats": {"total": 62, "additions": 52, "deletions": 10}, "files": [{"sha": "7b70e14e802e254291ffc78277e803d19ffb0b5b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 52, "deletions": 10, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a8d57a26dfe1c8e44e9af1923c900f147d13889b/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d57a26dfe1c8e44e9af1923c900f147d13889b/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=a8d57a26dfe1c8e44e9af1923c900f147d13889b", "patch": "@@ -420,10 +420,10 @@ impl CodeMap {\n     fn lookup_pos(&self, pos: BytePos) -> Loc {\n         let FileMapAndLine {fm: f, line: a} = self.lookup_line(pos);\n         let line = a + 1u; // Line numbers start at 1\n-        let chpos = self.bytepos_to_charpos(pos);\n+        let chpos = self.bytepos_to_file_charpos(pos);\n         let lines = f.lines.borrow();\n         let linebpos = lines.get()[a];\n-        let linechpos = self.bytepos_to_charpos(linebpos);\n+        let linechpos = self.bytepos_to_file_charpos(linebpos);\n         debug!(\"codemap: byte pos {:?} is on the line at byte pos {:?}\",\n                pos, linebpos);\n         debug!(\"codemap: char pos {:?} is on the line at char pos {:?}\",\n@@ -446,8 +446,8 @@ impl CodeMap {\n         return FileMapAndBytePos {fm: fm, pos: offset};\n     }\n \n-    // Converts an absolute BytePos to a CharPos relative to the codemap.\n-    fn bytepos_to_charpos(&self, bpos: BytePos) -> CharPos {\n+    // Converts an absolute BytePos to a CharPos relative to the filemap.\n+    fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n         debug!(\"codemap: converting {:?} to char pos\", bpos);\n         let idx = self.lookup_filemap_idx(bpos);\n         let files = self.files.borrow();\n@@ -471,7 +471,8 @@ impl CodeMap {\n             }\n         }\n \n-        CharPos(bpos.to_uint() - total_extra_bytes)\n+        assert!(map.start_pos.to_uint() + total_extra_bytes <= bpos.to_uint());\n+        CharPos(bpos.to_uint() - map.start_pos.to_uint() - total_extra_bytes)\n     }\n }\n \n@@ -501,7 +502,7 @@ mod test {\n         fm.next_line(BytePos(2));\n     }\n \n-    fn init_code_map() ->CodeMap {\n+    fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new();\n         let fm1 = cm.new_filemap(~\"blork.rs\",~\"first line.\\nsecond line\");\n         let fm2 = cm.new_filemap(~\"empty.rs\",~\"\");\n@@ -532,14 +533,14 @@ mod test {\n \n     #[test]\n     fn t4() {\n-        // Test bytepos_to_charpos\n+        // Test bytepos_to_file_charpos\n         let cm = init_code_map();\n \n-        let cp1 = cm.bytepos_to_charpos(BytePos(22));\n+        let cp1 = cm.bytepos_to_file_charpos(BytePos(22));\n         assert_eq!(cp1, CharPos(22));\n \n-        let cp2 = cm.bytepos_to_charpos(BytePos(23));\n-        assert_eq!(cp2, CharPos(23));\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(23));\n+        assert_eq!(cp2, CharPos(0));\n     }\n \n     #[test]\n@@ -557,4 +558,45 @@ mod test {\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n+\n+    fn init_code_map_mbc() -> CodeMap {\n+        let cm = CodeMap::new();\n+        // \u20ac is a three byte utf8 char.\n+        let fm1 = cm.new_filemap(~\"blork.rs\",~\"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\");\n+        let fm2 = cm.new_filemap(~\"blork2.rs\",~\"first line\u20ac\u20ac.\\n\u20ac second line\");\n+\n+        fm1.next_line(BytePos(0));\n+        fm1.next_line(BytePos(22));\n+        fm2.next_line(BytePos(39));\n+        fm2.next_line(BytePos(57));\n+\n+        fm1.record_multibyte_char(BytePos(3), 3);\n+        fm1.record_multibyte_char(BytePos(9), 3);\n+        fm1.record_multibyte_char(BytePos(12), 3);\n+        fm1.record_multibyte_char(BytePos(15), 3);\n+        fm1.record_multibyte_char(BytePos(18), 3);\n+        fm2.record_multibyte_char(BytePos(49), 3);\n+        fm2.record_multibyte_char(BytePos(52), 3);\n+        fm2.record_multibyte_char(BytePos(57), 3);\n+\n+        cm\n+    }\n+\n+    #[test]\n+    fn t6() {\n+        // Test bytepos_to_file_charpos in the presence of multi-byte chars\n+        let cm = init_code_map_mbc();\n+\n+        let cp1 = cm.bytepos_to_file_charpos(BytePos(3));\n+        assert_eq!(cp1, CharPos(3));\n+\n+        let cp2 = cm.bytepos_to_file_charpos(BytePos(6));\n+        assert_eq!(cp2, CharPos(4));\n+\n+        let cp3 = cm.bytepos_to_file_charpos(BytePos(55));\n+        assert_eq!(cp3, CharPos(12));\n+\n+        let cp4 = cm.bytepos_to_file_charpos(BytePos(60));\n+        assert_eq!(cp4, CharPos(15));\n+    }\n }"}]}