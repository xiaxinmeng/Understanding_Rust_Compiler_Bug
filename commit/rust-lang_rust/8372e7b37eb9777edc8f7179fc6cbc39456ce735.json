{"sha": "8372e7b37eb9777edc8f7179fc6cbc39456ce735", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzNzJlN2IzN2ViOTc3N2VkYzhmNzE3OWZjNmNiYzM5NDU2Y2U3MzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-30T02:11:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-30T02:11:59Z"}, "message": "Auto merge of #50783 - pnkfelix:issue-27282-match-borrows-its-input-take-three, r=nikomatsakis\n\nevery match arm reads the match's borrowed input\n\nThis PR changes the `match` codegen under NLL (and just NLL, at least for now) to make the following adjustments:\n * It adds a `-Z disable-ast-check-for-mutation-in-guard` which, as described, turns off the naive (conservative but also not 100% sound) check for mutation in guards of match arms.\n * We now borrow the match input at the outset and emit a special `ReadForMatch` statement (that, according to the *static* semantics, reads that borrowed match input) at the start of each match arm. The intent here is to catch cases where the match guard mutates the match input, either via an independent borrow or via `ref mut` borrows in that arm's pattern.\n * In order to ensure that `ref mut` borrows do not actually conflict with the emitted `ReadForMatch` statements, I expanded the two-phase-borrow system slightly, and also changed the MIR code gen so that under NLL, when there is a guard on a match arm, then each pattern variable ends up having *three* temporaries associated with it:\n   1. The first temporary will hold the substructure being matched; this is what we will move the (substructural) value into *if* the guard succeeds.\n   2. The second temporary also corresponds to the same value as the first, but we are just constructing this temporarily for use during the scope of the guard; it is unaliased and its sole referrer is the third temporary.\n   3. The third temporary is a reference to the second temporary.\n   * (This sounds complicated, I know, but its actually *simpler* than what I was doing before and had checked into the repo, which was to sometimes construct the final value and then take a reference to it before evaluating the guard. See also PR #49870.)\n\nFix #27282\n\nThis also provides a path towards resolving #24535 aka rust-lang/rfcs#1006, at least once the `-Z disable-ast-check-for-mutation-in-guard` is just turned on by default (under NLL, that is. It is not sound under AST-borrowck).\n * But I did not want to make `#![feature(nll)]` imply that as part of this PR; that seemed like too drastic a change to me.", "tree": {"sha": "e98eddebdd5679b3a73a5716cc7cd240d1203a7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e98eddebdd5679b3a73a5716cc7cd240d1203a7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8372e7b37eb9777edc8f7179fc6cbc39456ce735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8372e7b37eb9777edc8f7179fc6cbc39456ce735", "html_url": "https://github.com/rust-lang/rust/commit/8372e7b37eb9777edc8f7179fc6cbc39456ce735", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8372e7b37eb9777edc8f7179fc6cbc39456ce735/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467", "html_url": "https://github.com/rust-lang/rust/commit/ec99b220fe0b0741edd6c9d6e05e4d0d2733a467"}, {"sha": "9d5cdc958db3ee832dbdb781358442fddd51d6ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d5cdc958db3ee832dbdb781358442fddd51d6ee", "html_url": "https://github.com/rust-lang/rust/commit/9d5cdc958db3ee832dbdb781358442fddd51d6ee"}], "stats": {"total": 1025, "additions": 790, "deletions": 235}, "files": [{"sha": "e77d38de582642585911fd518fcb23b373734f16", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -241,6 +241,9 @@ for mir::StatementKind<'gcx> {\n                 place.hash_stable(hcx, hasher);\n                 rvalue.hash_stable(hcx, hasher);\n             }\n+            mir::StatementKind::ReadForMatch(ref place) => {\n+                place.hash_stable(hcx, hasher);\n+            }\n             mir::StatementKind::SetDiscriminant { ref place, variant_index } => {\n                 place.hash_stable(hcx, hasher);\n                 variant_index.hash_stable(hcx, hasher);"}, {"sha": "a94e5e793b470efa700d0112cfc52cfd722ab24c", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -1225,6 +1225,10 @@ pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n     Assign(Place<'tcx>, Rvalue<'tcx>),\n \n+    /// This represents all the reading that a pattern match may do\n+    /// (e.g. inspecting constants and discriminant values).\n+    ReadForMatch(Place<'tcx>),\n+\n     /// Write the discriminant for a variant to the enum Place.\n     SetDiscriminant { place: Place<'tcx>, variant_index: usize },\n \n@@ -1327,6 +1331,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n+            ReadForMatch(ref place) => write!(fmt, \"ReadForMatch({:?})\", place),\n             // (reuse lifetime rendering policy from ppaux.)\n             EndRegion(ref ce) => write!(fmt, \"EndRegion({})\", ty::ReScope(*ce)),\n             Validate(ref op, ref places) => write!(fmt, \"Validate({:?}, {:?})\", op, places),\n@@ -2212,6 +2217,7 @@ BraceStructTypeFoldableImpl! {\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n         (StatementKind::Assign)(a, b),\n+        (StatementKind::ReadForMatch)(place),\n         (StatementKind::SetDiscriminant) { place, variant_index },\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),"}, {"sha": "9dd1432167a9044115052025e0cdc4e71b7f53b5", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -355,6 +355,11 @@ macro_rules! make_mir_visitor {\n                                           ref $($mutability)* rvalue) => {\n                         self.visit_assign(block, place, rvalue, location);\n                     }\n+                    StatementKind::ReadForMatch(ref $($mutability)* place) => {\n+                        self.visit_place(place,\n+                                         PlaceContext::Inspect,\n+                                         location);\n+                    }\n                     StatementKind::EndRegion(_) => {}\n                     StatementKind::Validate(_, ref $($mutability)* places) => {\n                         for operand in places {"}, {"sha": "35538e5d02a23b9cc390da69e33983cf32051933", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -1290,16 +1290,22 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         useful for profiling / PGO.\"),\n     relro_level: Option<RelroLevel> = (None, parse_relro_level, [TRACKED],\n         \"choose which RELRO level to use\"),\n+    disable_ast_check_for_mutation_in_guard: bool = (false, parse_bool, [UNTRACKED],\n+        \"skip AST-based mutation-in-guard check (mir-borrowck provides more precise check)\"),\n     nll_subminimal_causes: bool = (false, parse_bool, [UNTRACKED],\n         \"when tracking region error causes, accept subminimal results for faster execution.\"),\n     nll_facts: bool = (false, parse_bool, [UNTRACKED],\n                        \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n+    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n+        \"in match codegen, do not include ReadForMatch statements (used by mir-borrowck)\"),\n     polonius: bool = (false, parse_bool, [UNTRACKED],\n         \"enable polonius-based borrow-checker\"),\n     codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n+    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "68f55b4993301fed0391b2246730d29878916c76", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -1344,12 +1344,31 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.on_disk_query_result_cache.serialize(self.global_tcx(), encoder)\n     }\n \n+    /// If true, we should use a naive AST walk to determine if match\n+    /// guard could perform bad mutations (or mutable-borrows).\n+    pub fn check_for_mutation_in_guard_via_ast_walk(self) -> bool {\n+        !self.sess.opts.debugging_opts.disable_ast_check_for_mutation_in_guard\n+    }\n+\n     /// If true, we should use the MIR-based borrowck (we may *also* use\n     /// the AST-based borrowck).\n     pub fn use_mir_borrowck(self) -> bool {\n         self.borrowck_mode().use_mir()\n     }\n \n+    /// If true, make MIR codegen for `match` emit a temp that holds a\n+    /// borrow of the input to the match expression.\n+    pub fn generate_borrow_of_any_match_input(&self) -> bool {\n+        self.emit_read_for_match()\n+    }\n+\n+    /// If true, make MIR codegen for `match` emit ReadForMatch\n+    /// statements (which simulate the maximal effect of executing the\n+    /// patterns in a match arm).\n+    pub fn emit_read_for_match(&self) -> bool {\n+        self.use_mir_borrowck() && !self.sess.opts.debugging_opts.nll_dont_emit_read_for_match\n+    }\n+\n     /// If true, pattern variables for use in guards on match arms\n     /// will be bound as references to the data, and occurrences of\n     /// those variables in the guard expression will implicitly"}, {"sha": "c0cce297ef6a98263db3e01b2a8ccaf8b03cc4d9", "filename": "src/librustc_codegen_llvm/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fstatement.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -82,6 +82,7 @@ impl<'a, 'tcx> FunctionCx<'a, 'tcx> {\n                 asm::codegen_inline_asm(&bx, asm, outputs, input_vals);\n                 bx\n             }\n+            mir::StatementKind::ReadForMatch(_) |\n             mir::StatementKind::EndRegion(_) |\n             mir::StatementKind::Validate(..) |\n             mir::StatementKind::UserAssertTy(..) |"}, {"sha": "3d6f49c3772264032914b83c2fbfe4805a69c0a0", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -53,14 +53,25 @@ impl<'tcx> Index<BorrowIndex> for BorrowSet<'tcx> {\n     }\n }\n \n+/// Every two-phase borrow has *exactly one* use (or else it is not a\n+/// proper two-phase borrow under our current definition). However, not\n+/// all uses are actually ones that activate the reservation.. In\n+/// particular, a shared borrow of a `&mut` does not activate the\n+/// reservation.\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+crate enum TwoPhaseUse {\n+    MutActivate,\n+    SharedUse,\n+}\n+\n #[derive(Debug)]\n crate struct BorrowData<'tcx> {\n     /// Location where the borrow reservation starts.\n     /// In many cases, this will be equal to the activation location but not always.\n     crate reserve_location: Location,\n     /// Location where the borrow is activated. None if this is not a\n     /// 2-phase borrow.\n-    crate activation_location: Option<Location>,\n+    crate activation_location: Option<(TwoPhaseUse, Location)>,\n     /// What kind of borrow this is\n     crate kind: mir::BorrowKind,\n     /// The region for which this borrow is live\n@@ -215,17 +226,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n                 Some(&borrow_index) => {\n                     let borrow_data = &mut self.idx_vec[borrow_index];\n \n-                    // Watch out: the use of TMP in the borrow\n-                    // itself doesn't count as an\n-                    // activation. =)\n+                    // Watch out: the use of TMP in the borrow itself\n+                    // doesn't count as an activation. =)\n                     if borrow_data.reserve_location == location && context == PlaceContext::Store {\n                         return;\n                     }\n \n                     if let Some(other_activation) = borrow_data.activation_location {\n                         span_bug!(\n                             self.mir.source_info(location).span,\n-                            \"found two activations for 2-phase borrow temporary {:?}: \\\n+                            \"found two uses for 2-phase borrow temporary {:?}: \\\n                              {:?} and {:?}\",\n                             temp,\n                             location,\n@@ -235,11 +245,25 @@ impl<'a, 'gcx, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'gcx, 'tcx> {\n \n                     // Otherwise, this is the unique later use\n                     // that we expect.\n-                    borrow_data.activation_location = Some(location);\n-                    self.activation_map\n-                        .entry(location)\n-                        .or_insert(Vec::new())\n-                        .push(borrow_index);\n+\n+                    let two_phase_use;\n+\n+                    match context {\n+                        // The use of TMP in a shared borrow does not\n+                        // count as an actual activation.\n+                        PlaceContext::Borrow { kind: mir::BorrowKind::Shared, .. } => {\n+                            two_phase_use = TwoPhaseUse::SharedUse;\n+                        }\n+                        _ => {\n+                            two_phase_use = TwoPhaseUse::MutActivate;\n+                            self.activation_map\n+                                .entry(location)\n+                                .or_insert(Vec::new())\n+                                .push(borrow_index);\n+                        }\n+                    }\n+\n+                    borrow_data.activation_location = Some((two_phase_use, location));\n                 }\n \n                 None => {}"}, {"sha": "20eb084e1a17b425429e9f98024c3e583bbbff26", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -423,6 +423,14 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n                     flow_state,\n                 );\n             }\n+            StatementKind::ReadForMatch(ref place) => {\n+                self.access_place(ContextKind::ReadForMatch.new(location),\n+                                  (place, span),\n+                                  (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                                  LocalMutationIsAllowed::No,\n+                                  flow_state,\n+                                  );\n+            }\n             StatementKind::SetDiscriminant {\n                 ref place,\n                 variant_index: _,\n@@ -1689,14 +1697,16 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         );\n         let mut error_reported = false;\n         match kind {\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Unique))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Unique)) => {\n-                if let Err(_place_err) = self.is_mutable(place, LocalMutationIsAllowed::Yes) {\n-                    span_bug!(span, \"&unique borrow for {:?} should not fail\", place);\n-                }\n-            }\n-            Reservation(WriteKind::MutableBorrow(BorrowKind::Mut { .. }))\n-            | Write(WriteKind::MutableBorrow(BorrowKind::Mut { .. })) => {\n+            Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n+            | Reservation(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. }))\n+            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Unique))\n+            | Write(WriteKind::MutableBorrow(borrow_kind @ BorrowKind::Mut { .. })) =>\n+            {\n+                let is_local_mutation_allowed = match borrow_kind {\n+                    BorrowKind::Unique => LocalMutationIsAllowed::Yes,\n+                    BorrowKind::Mut { .. } => is_local_mutation_allowed,\n+                    BorrowKind::Shared => unreachable!(),\n+                };\n                 match self.is_mutable(place, is_local_mutation_allowed) {\n                     Ok(root_place) => self.add_used_mut(root_place, flow_state),\n                     Err(place_err) => {\n@@ -2090,6 +2100,7 @@ enum ContextKind {\n     CallDest,\n     Assert,\n     Yield,\n+    ReadForMatch,\n     StorageDead,\n }\n "}, {"sha": "46026cdc9412121ecef012b186f858f41f1226c6", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -93,6 +93,14 @@ impl<'cg, 'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cg, 'cx, 'tc\n                     JustWrite\n                 );\n             }\n+            StatementKind::ReadForMatch(ref place) => {\n+                self.access_place(\n+                    ContextKind::ReadForMatch.new(location),\n+                    place,\n+                    (Deep, Read(ReadKind::Borrow(BorrowKind::Shared))),\n+                    LocalMutationIsAllowed::No,\n+                );\n+            }\n             StatementKind::SetDiscriminant {\n                 ref place,\n                 variant_index: _,"}, {"sha": "04f5024b76946602cd2341f393ac30ba921fe7eb", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -836,7 +836,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::StorageLive(_)\n+            StatementKind::ReadForMatch(_)\n+            | StatementKind::StorageLive(_)\n             | StatementKind::StorageDead(_)\n             | StatementKind::InlineAsm { .. }\n             | StatementKind::EndRegion(_)"}, {"sha": "4871d427d0767bc7bc6ebd2caddbb4ce8210f703", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -12,7 +12,7 @@\n /// allowed to be split into separate Reservation and\n /// Activation phases.\n use borrow_check::ArtificialField;\n-use borrow_check::borrow_set::{BorrowSet, BorrowData};\n+use borrow_check::borrow_set::{BorrowSet, BorrowData, TwoPhaseUse};\n use borrow_check::{Context, Overlap};\n use borrow_check::{ShallowOrDeep, Deep, Shallow};\n use dataflow::indexes::BorrowIndex;\n@@ -431,10 +431,13 @@ pub(super) fn is_active<'tcx>(\n ) -> bool {\n     debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n \n-    // If this is not a 2-phase borrow, it is always active.\n     let activation_location = match borrow_data.activation_location {\n-        Some(v) => v,\n+        // If this is not a 2-phase borrow, it is always active.\n         None => return true,\n+        // And if the unique 2-phase use is not an activation, then it is *never* active.\n+        Some((TwoPhaseUse::SharedUse, _)) => return false,\n+        // Otherwise, we derive info from the activation point `v`:\n+        Some((TwoPhaseUse::MutActivate, v)) => v,\n     };\n \n     // Otherwise, it is active for every location *except* in between"}, {"sha": "964841e7a9ed4c1d8ae29f0bdbeb54862e57a6e4", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -11,7 +11,7 @@\n //! See docs in build/expr/mod.rs\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n-use build::ForGuard::{OutsideGuard, WithinGuard};\n+use build::ForGuard::{OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::expr::category::Category;\n use hair::*;\n use rustc::mir::*;\n@@ -88,10 +88,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             ExprKind::VarRef { id } => {\n                 let place = if this.is_bound_var_in_guard(id) {\n-                    let index = this.var_local_id(id, WithinGuard);\n                     if this.hir.tcx().all_pat_vars_are_implicit_refs_within_guards() {\n+                        let index = this.var_local_id(id, RefWithinGuard);\n                         Place::Local(index).deref()\n                     } else {\n+                        let index = this.var_local_id(id, ValWithinGuard);\n                         Place::Local(index)\n                     }\n                 } else {"}, {"sha": "a3c7bcfbd0bef6eb77bba30d9c2ac07aced400f7", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 151, "deletions": 82, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -15,7 +15,7 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n-use build::ForGuard::{self, OutsideGuard, WithinGuard};\n+use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n use rustc::ty::{self, Ty};\n@@ -43,6 +43,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       discriminant: ExprRef<'tcx>,\n                       arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()> {\n+        let tcx = self.hir.tcx();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n         // Matching on a `discriminant_place` with an uninhabited type doesn't\n@@ -55,12 +56,33 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n         // of `discriminant_place`, specifically by applying `Rvalue::Discriminant`\n         // (which will work regardless of type) and storing the result in a temp.\n+        //\n+        // NOTE: Under NLL, the above issue should no longer occur because it\n+        // injects a borrow of the matched input, which should have the same effect\n+        // as eddyb's hack. Once NLL is the default, we can remove the hack.\n+\n         let dummy_source_info = self.source_info(span);\n         let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n-        let dummy_ty = dummy_access.ty(&self.local_decls, self.hir.tcx());\n+        let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n         let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n         self.cfg.push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n \n+        let source_info = self.source_info(span);\n+        let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n+            // The region is unknown at this point; we rely on NLL\n+            // inference to find an appropriate one. Therefore you can\n+            // only use this when NLL is turned on.\n+            assert!(tcx.use_mir_borrowck());\n+            let borrowed_input =\n+                Rvalue::Ref(tcx.types.re_empty, BorrowKind::Shared, discriminant_place.clone());\n+            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n+            let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n+            self.cfg.push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n+            Some(borrowed_input_temp)\n+        } else {\n+            None\n+        };\n+\n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n                         .map(|_| self.cfg.start_new_block())\n@@ -99,6 +121,44 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n                 .map(|((arm_index, pattern, guard),\n                        (pre_binding_block, next_candidate_pre_binding_block))| {\n+\n+                    if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n+                                                        borrowed_input_temp.clone()) {\n+                        // inject a fake read of the borrowed input at\n+                        // the start of each arm's pattern testing\n+                        // code.\n+                        //\n+                        // This should ensure that you cannot change\n+                        // the variant for an enum while you are in\n+                        // the midst of matching on it.\n+\n+                        self.cfg.push(*pre_binding_block, Statement {\n+                            source_info,\n+                            kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n+                        });\n+                    }\n+\n+                    // One might ask: why not build up the match pair such that it\n+                    // matches via `borrowed_input_temp.deref()` instead of\n+                    // using the `discriminant_place` directly, as it is doing here?\n+                    //\n+                    // The basic answer is that if you do that, then you end up with\n+                    // accceses to a shared borrow of the input and that conflicts with\n+                    // any arms that look like e.g.\n+                    //\n+                    // match Some(&4) {\n+                    //     ref mut foo => {\n+                    //         ... /* mutate `foo` in arm body */ ...\n+                    //     }\n+                    // }\n+                    //\n+                    // (Perhaps we could further revise the MIR\n+                    //  construction here so that it only does a\n+                    //  shared borrow at the outset and delays doing\n+                    //  the mutable borrow until after the pattern is\n+                    //  matched *and* the guard (if any) for the arm\n+                    //  has been run.)\n+\n                     Candidate {\n                         span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],\n@@ -229,7 +289,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         // now apply the bindings, which will also declare the variables\n-        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+        self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n \n         block.unit()\n     }\n@@ -870,22 +930,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         //      (because all we have is the places associated with the\n         //      match input itself; it is up to us to create a place\n         //      holding a `&` or `&mut` that we can then borrow).\n-        //\n-        //    * Therefore, when the binding is by-reference, we\n-        //      *eagerly* introduce the binding for the arm body\n-        //      (`tmp2`) and then borrow it (`tmp1`).\n-        //\n-        //    * This is documented with \"NOTE tricky business\" below.\n-        //\n-        // FIXME The distinction in how `tmp2` is initialized is\n-        // currently encoded in a pretty awkward fashion; namely, by\n-        // passing a boolean to bind_matched_candidate_for_arm_body\n-        // indicating whether all of the by-ref bindings were already\n-        // initialized.\n-        //\n-        // * Also: pnkfelix thinks \"laziness\" is natural; but since\n-        //   MIR-borrowck did not complain with earlier (universally\n-        //   eager) MIR codegen, laziness might not be *necessary*.\n \n         let autoref = self.hir.tcx().all_pat_vars_are_implicit_refs_within_guards();\n         if let Some(guard) = candidate.guard {\n@@ -899,7 +943,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 debug!(\"Entering guard building context: {:?}\", guard_frame);\n                 self.guard_context.push(guard_frame);\n             } else {\n-                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             }\n \n             // the block to branch to if the guard fails; if there is no\n@@ -913,14 +957,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             let false_edge_block = self.cfg.start_new_block();\n+\n+            // We want to ensure that the matched candidates are bound\n+            // after we have confirmed this candidate *and* any\n+            // associated guard; Binding them on `block` is too soon,\n+            // because that would be before we've checked the result\n+            // from the guard.\n+            //\n+            // But binding them on `arm_block` is *too late*, because\n+            // then all of the candidates for a single arm would be\n+            // bound in the same place, that would cause a case like:\n+            //\n+            // ```rust\n+            // match (30, 2) {\n+            //     (mut x, 1) | (2, mut x) if { true } => { ... }\n+            //     ...                                 // ^^^^^^^ (this is `arm_block`)\n+            // }\n+            // ```\n+            //\n+            // would yield a `arm_block` something like:\n+            //\n+            // ```\n+            // StorageLive(_4);        // _4 is `x`\n+            // _4 = &mut (_1.0: i32);  // this is handling `(mut x, 1)` case\n+            // _4 = &mut (_1.1: i32);  // this is handling `(2, mut x)` case\n+            // ```\n+            //\n+            // and that is clearly not correct.\n+            let post_guard_block = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n-                               TerminatorKind::if_(self.hir.tcx(), cond, arm_block,\n-                                   false_edge_block));\n+                               TerminatorKind::if_(self.hir.tcx(), cond, post_guard_block,\n+                                                   false_edge_block));\n \n-            let otherwise = self.cfg.start_new_block();\n             if autoref {\n-                self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, true);\n+                self.bind_matched_candidate_for_arm_body(post_guard_block, &candidate.bindings);\n             }\n+\n+            self.cfg.terminate(post_guard_block, source_info,\n+                               TerminatorKind::Goto { target: arm_block });\n+\n+            let otherwise = self.cfg.start_new_block();\n+\n             self.cfg.terminate(false_edge_block, source_info,\n                                TerminatorKind::FalseEdges {\n                                    real_target: otherwise,\n@@ -929,13 +1006,18 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                });\n             Some(otherwise)\n         } else {\n-            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings, false);\n+            // (Here, it is not too early to bind the matched\n+            // candidate on `block`, because there is no guard result\n+            // that we have to inspect before we bind them.)\n+            self.bind_matched_candidate_for_arm_body(block, &candidate.bindings);\n             self.cfg.terminate(block, candidate_source_info,\n                                TerminatorKind::Goto { target: arm_block });\n             None\n         }\n     }\n \n+    // Only called when all_pat_vars_are_implicit_refs_within_guards,\n+    // and thus all code/comments assume we are in that context.\n     fn bind_matched_candidate_for_guard(&mut self,\n                                         block: BasicBlock,\n                                         bindings: &[Binding<'tcx>]) {\n@@ -948,81 +1030,66 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let re_empty = self.hir.tcx().types.re_empty;\n         for binding in bindings {\n             let source_info = self.source_info(binding.span);\n-            let local_for_guard = self.storage_live_binding(\n-                block, binding.var_id, binding.span, WithinGuard);\n+\n+            // For each pattern ident P of type T, `ref_for_guard` is\n+            // a reference R: &T pointing to the location matched by\n+            // the pattern, and every occurrence of P within a guard\n+            // denotes *R.\n+            let ref_for_guard = self.storage_live_binding(\n+                block, binding.var_id, binding.span, RefWithinGuard);\n             // Question: Why schedule drops if bindings are all\n             // shared-&'s?  Answer: Because schedule_drop_for_binding\n             // also emits StorageDead's for those locals.\n-            self.schedule_drop_for_binding(binding.var_id, binding.span, WithinGuard);\n+            self.schedule_drop_for_binding(binding.var_id, binding.span, RefWithinGuard);\n             match binding.binding_mode {\n                 BindingMode::ByValue => {\n                     let rvalue = Rvalue::Ref(re_empty, BorrowKind::Shared, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n                 BindingMode::ByRef(region, borrow_kind) => {\n-                    // NOTE tricky business: For `ref id` and `ref mut\n-                    // id` patterns, we want `id` within the guard to\n+                    // Tricky business: For `ref id` and `ref mut id`\n+                    // patterns, we want `id` within the guard to\n                     // correspond to a temp of type `& &T` or `& &mut\n-                    // T`, while within the arm body it will\n-                    // correspond to a temp of type `&T` or `&mut T`,\n-                    // as usual.\n-                    //\n-                    // But to inject the level of indirection, we need\n-                    // something to point to.\n-                    //\n-                    // So:\n-                    //\n-                    // 1. First set up the local for the arm body\n-                    //   (even though we have not yet evaluated the\n-                    //   guard itself),\n+                    // T` (i.e. a \"borrow of a borrow\") that is\n+                    // implicitly dereferenced.\n                     //\n-                    // 2. Then setup the local for the guard, which is\n-                    //    just a reference to the local from step 1.\n+                    // To borrow a borrow, we need that inner borrow\n+                    // to point to. So, create a temp for the inner\n+                    // borrow, and then take a reference to it.\n                     //\n-                    // Note that since we are setting up the local for\n-                    // the arm body a bit eagerly here (and likewise\n-                    // scheduling its drop code), we should *not* do\n-                    // it redundantly later on.\n-                    //\n-                    // While we could have kept track of this with a\n-                    // flag or collection of such bindings, the\n-                    // treatment of all of these cases is uniform, so\n-                    // we should be safe just avoiding the code\n-                    // without maintaining such state.)\n-                    let local_for_arm_body = self.storage_live_binding(\n-                        block, binding.var_id, binding.span, OutsideGuard);\n-                    self.schedule_drop_for_binding(binding.var_id, binding.span, OutsideGuard);\n-\n-                    // rust-lang/rust#27282: this potentially mutable\n-                    // borrow may require a cast in the future to\n-                    // avoid conflicting with an implicit borrow of\n-                    // the whole match input; or maybe it just\n-                    // requires an extension of our two-phase borrows\n-                    // system. See discussion on rust-lang/rust#49870.\n+                    // Note: the temp created here is *not* the one\n+                    // used by the arm body itself. This eases\n+                    // observing two-phase borrow restrictions.\n+                    let val_for_guard = self.storage_live_binding(\n+                        block, binding.var_id, binding.span, ValWithinGuard);\n+                    self.schedule_drop_for_binding(binding.var_id, binding.span, ValWithinGuard);\n+\n+                    // rust-lang/rust#27282: We reuse the two-phase\n+                    // borrow infrastructure so that the mutable\n+                    // borrow (whose mutabilty is *unusable* within\n+                    // the guard) does not conflict with the implicit\n+                    // borrow of the whole match input. See additional\n+                    // discussion on rust-lang/rust#49870.\n+                    let borrow_kind = match borrow_kind {\n+                        BorrowKind::Shared | BorrowKind::Unique => borrow_kind,\n+                        BorrowKind::Mut { .. } => BorrowKind::Mut { allow_two_phase_borrow: true },\n+                    };\n                     let rvalue = Rvalue::Ref(region, borrow_kind, binding.source.clone());\n-                    self.cfg.push_assign(block, source_info, &local_for_arm_body, rvalue);\n-                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, local_for_arm_body);\n-                    self.cfg.push_assign(block, source_info, &local_for_guard, rvalue);\n+                    self.cfg.push_assign(block, source_info, &val_for_guard, rvalue);\n+                    let rvalue = Rvalue::Ref(region, BorrowKind::Shared, val_for_guard);\n+                    self.cfg.push_assign(block, source_info, &ref_for_guard, rvalue);\n                 }\n             }\n         }\n     }\n \n     fn bind_matched_candidate_for_arm_body(&mut self,\n                                            block: BasicBlock,\n-                                           bindings: &[Binding<'tcx>],\n-                                           already_initialized_state_for_refs: bool) {\n-        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}, \\\n-                already_initialized_state_for_refs={:?})\",\n-               block, bindings, already_initialized_state_for_refs);\n+                                           bindings: &[Binding<'tcx>]) {\n+        debug!(\"bind_matched_candidate_for_arm_body(block={:?}, bindings={:?}\", block, bindings);\n \n         // Assign each of the bindings. This may trigger moves out of the candidate.\n         for binding in bindings {\n-            if let BindingMode::ByRef(..) = binding.binding_mode {\n-                // See \"NOTE tricky business\" above\n-                if already_initialized_state_for_refs { continue; }\n-            }\n-\n             let source_info = self.source_info(binding.span);\n             let local = self.storage_live_binding(block, binding.var_id, binding.span,\n                                                   OutsideGuard);\n@@ -1059,17 +1126,19 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                var_id, name, var_ty, source_info, syntactic_scope);\n \n         let tcx = self.hir.tcx();\n-        let for_arm_body = self.local_decls.push(LocalDecl::<'tcx> {\n+        let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty.clone(),\n             name: Some(name),\n             source_info,\n             syntactic_scope,\n             internal: false,\n             is_user_variable: true,\n-        });\n+        };\n+        let for_arm_body = self.local_decls.push(local.clone());\n         let locals = if has_guard.0 && tcx.all_pat_vars_are_implicit_refs_within_guards() {\n-            let for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n+            let val_for_guard =  self.local_decls.push(local);\n+            let ref_for_guard = self.local_decls.push(LocalDecl::<'tcx> {\n                 mutability,\n                 ty: tcx.mk_imm_ref(tcx.types.re_empty, var_ty),\n                 name: Some(name),\n@@ -1078,7 +1147,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 internal: false,\n                 is_user_variable: true,\n             });\n-            LocalsForNode::Two { for_guard, for_arm_body }\n+            LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n         } else {\n             LocalsForNode::One(for_arm_body)\n         };"}, {"sha": "4822b9e4dfd81a6995dd728ef1ac31e1e2ab4778", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -293,7 +293,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n #[derive(Debug)]\n enum LocalsForNode {\n     One(Local),\n-    Two { for_guard: Local, for_arm_body: Local },\n+    Three { val_for_guard: Local, ref_for_guard: Local, for_arm_body: Local },\n }\n \n #[derive(Debug)]\n@@ -325,24 +325,29 @@ struct GuardFrame {\n     locals: Vec<GuardFrameLocal>,\n }\n \n-/// ForGuard is isomorphic to a boolean flag. It indicates whether we are\n-/// talking about the temp for a local binding for a use within a guard expression,\n-/// or a temp for use outside of a guard expressions.\n+/// ForGuard indicates whether we are talking about:\n+///   1. the temp for a local binding used solely within guard expressions,\n+///   2. the temp that holds reference to (1.), which is actually what the\n+///      guard expressions see, or\n+///   3. the temp for use outside of guard expressions.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum ForGuard {\n-    WithinGuard,\n+    ValWithinGuard,\n+    RefWithinGuard,\n     OutsideGuard,\n }\n \n impl LocalsForNode {\n     fn local_id(&self, for_guard: ForGuard) -> Local {\n         match (self, for_guard) {\n             (&LocalsForNode::One(local_id), ForGuard::OutsideGuard) |\n-            (&LocalsForNode::Two { for_guard: local_id, .. }, ForGuard::WithinGuard) |\n-            (&LocalsForNode::Two { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n+            (&LocalsForNode::Three { val_for_guard: local_id, .. }, ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::Three { ref_for_guard: local_id, .. }, ForGuard::RefWithinGuard) |\n+            (&LocalsForNode::Three { for_arm_body: local_id, .. }, ForGuard::OutsideGuard) =>\n                 local_id,\n \n-            (&LocalsForNode::One(_), ForGuard::WithinGuard) =>\n+            (&LocalsForNode::One(_), ForGuard::ValWithinGuard) |\n+            (&LocalsForNode::One(_), ForGuard::RefWithinGuard) =>\n                 bug!(\"anything with one local should never be within a guard.\"),\n         }\n     }"}, {"sha": "78886baf51476b1168727af735eab17af264265f", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -227,6 +227,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for Borrows<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n+            mir::StatementKind::ReadForMatch(..) |\n             mir::StatementKind::SetDiscriminant { .. } |\n             mir::StatementKind::StorageLive(..) |\n             mir::StatementKind::Validate(..) |"}, {"sha": "2ff22842141d9bfc806bff4ae7ca4b3f7f8b46c2", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -278,6 +278,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n                 }\n                 self.gather_rvalue(rval);\n             }\n+            StatementKind::ReadForMatch(ref place) => {\n+                self.create_move_path(place);\n+            }\n             StatementKind::InlineAsm { ref outputs, ref inputs, ref asm } => {\n                 for (output, kind) in outputs.iter().zip(&asm.outputs) {\n                     if !kind.is_indirect {"}, {"sha": "0a1139700984d13ca580404a6f37c43a7588305c", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -181,7 +181,9 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Second, if there is a guard on each arm, make sure it isn't\n             // assigning or borrowing anything mutably.\n             if let Some(ref guard) = arm.guard {\n-                check_for_mutation_in_guard(self, &guard);\n+                if self.tcx.check_for_mutation_in_guard_via_ast_walk() {\n+                    check_for_mutation_in_guard(self, &guard);\n+                }\n             }\n \n             // Third, perform some lints."}, {"sha": "ab15278219f40aa5fa5cdad605d7dcde6421f037", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -79,6 +79,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 self.deallocate_local(old_val)?;\n             }\n \n+            // No dynamic semantics attached to `ReadForMatch`; MIR\n+            // interpreter is solely intended for borrowck'ed code.\n+            ReadForMatch(..) => {}\n+\n             // Validity checks.\n             Validate(op, ref places) => {\n                 for operand in places {"}, {"sha": "4081f827d4b3da98ba8acad19f731cee89375d40", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -100,6 +100,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         self.source_info = statement.source_info;\n         match statement.kind {\n             StatementKind::Assign(..) |\n+            StatementKind::ReadForMatch(..) |\n             StatementKind::SetDiscriminant { .. } |\n             StatementKind::StorageLive(..) |\n             StatementKind::StorageDead(..) |"}, {"sha": "719630129440a6defacbbe1cc3928914cb937e92", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -1135,6 +1135,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                 StatementKind::Assign(ref place, ref rvalue) => {\n                     this.visit_assign(bb, place, rvalue, location);\n                 }\n+                StatementKind::ReadForMatch(..) |\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |"}, {"sha": "680b60b97284121f58be6726b6d42ad3b401fa2a", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -47,6 +47,7 @@ impl RemoveNoopLandingPads {\n     {\n         for stmt in &mir[bb].statements {\n             match stmt.kind {\n+                StatementKind::ReadForMatch(_) |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) |\n                 StatementKind::EndRegion(_) |"}, {"sha": "b23f05680121028dfd34f1f69dad8783215d9582", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -158,6 +158,7 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n                 (place, rvalue)\n             }\n+            mir::StatementKind::ReadForMatch(_) |\n             mir::StatementKind::StorageLive(_) |\n             mir::StatementKind::StorageDead(_) |\n             mir::StatementKind::InlineAsm { .. } |"}, {"sha": "f7c8f8f43f178a2c2f81005a14b89b0642bb4c31", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -85,6 +85,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(\"Statement\", statement);\n         self.record(match statement.kind {\n             StatementKind::Assign(..) => \"StatementKind::Assign\",\n+            StatementKind::ReadForMatch(..) => \"StatementKind::ReadForMatch\",\n             StatementKind::EndRegion(..) => \"StatementKind::EndRegion\",\n             StatementKind::Validate(..) => \"StatementKind::Validate\",\n             StatementKind::SetDiscriminant { .. } => \"StatementKind::SetDiscriminant\","}, {"sha": "739cbc0a99678fe9a375ce88e2d5026a909b62b1", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 125, "deletions": 112, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -54,60 +54,65 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      _3 = discriminant(_2);\n-//      _7 = discriminant(_2);\n-//      switchInt(move _7) -> [0isize: bb6, 1isize: bb4, otherwise: bb8];\n+//      _14 = promoted[1];\n+//      _4 = &(*_14);\n+//      _9 = discriminant(_2);\n+//      switchInt(move _9) -> [0isize: bb5, 1isize: bb3, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n //  bb2: {  // arm1\n-//      StorageLive(_9);\n-//      _9 = _4;\n-//      _1 = (const 1i32, move _9);\n-//      StorageDead(_9);\n+//      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n //  bb3: { // binding3(empty) and arm3\n-//      _1 = (const 3i32, const 3i32);\n-//      goto -> bb13;\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n //  }\n //  bb4: {\n-//      falseEdges -> [real: bb9, imaginary: bb5]; //pre_binding1\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding2\n //  }\n //  bb5: {\n-//      falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding2\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb2, imaginary: bb6]; //pre_binding3\n //  }\n //  bb6: {\n-//      falseEdges -> [real: bb3, imaginary: bb7]; //pre_binding3\n+//      unreachable;\n //  }\n //  bb7: {\n //      unreachable;\n //  }\n-//  bb8: {\n-//      unreachable;\n+//  bb8: { // binding1 and guard\n+//      StorageLive(_7);\n+//      _13 = promoted[0];\n+//      _7 = &(((*_13) as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n-//  bb9: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _11 = promoted[0];\n-//      _5 = &(((*_11) as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb10, unwind: bb1];\n+//  bb9: {\n+//      switchInt(move _10) -> [false: bb10, otherwise: bb11];\n //  }\n-//  bb10: { // end of guard\n-//      StorageLive(_4);\n-//      _4 = ((_2 as Some).0: i32);\n-//      switchInt(move _8) -> [false: bb11, otherwise: bb2];\n+//  bb10: { // to pre_binding2\n+//      falseEdges -> [real: bb4, imaginary: bb4];\n //  }\n-//  bb11: { // to pre_binding2\n-//      falseEdges -> [real: bb5, imaginary: bb5];\n+//  bb11: { // bindingNoLandingPads.before.mir2 and arm2\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_11);\n+//      _11 = _5;\n+//      _1 = (const 1i32, move _11);\n+//      StorageDead(_11);\n+//      goto -> bb13;\n //  }\n-//  bb12: { // bindingNoLandingPads.before.mir2 and arm2\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = _6;\n-//      _1 = (const 2i32, move _10);\n-//      StorageDead(_10);\n+//  bb12: {\n+//      StorageLive(_8);\n+//      _8 = ((_2 as Some).0: i32);\n+//      StorageLive(_12);\n+//      _12 = _8;\n+//      _1 = (const 2i32, move_12);\n+//      StorageDead(_12);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -121,59 +126,63 @@ fn main() {\n //      ...\n //      _2 = std::option::Option<i32>::Some(const 42i32,);\n //      _3 = discriminant(_2);\n-//      _7 = discriminant(_2);\n-//      switchInt(move _7) -> [0isize: bb5, 1isize: bb4, otherwise: bb8];\n+//      _4 = &_2;\n+//      _9 = discriminant(_2);\n+//      switchInt(move _9) -> [0isize: bb4, 1isize: bb3, otherwise: bb7];\n //  }\n //  bb1: {\n //      resume;\n //  }\n-//  bb2: { // arm1\n-//      StorageLive(_9);\n-//      _9 = _4;\n-//      _1 = (const 1i32, move _9);\n-//      StorageDead(_9);\n-//      goto -> bb13;\n-//  }\n-//  bb3: { // binding3(empty) and arm3\n+//  bb2: { // arm2\n //      _1 = (const 3i32, const 3i32);\n //      goto -> bb13;\n //  }\n+//  bb3: {\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb8, imaginary: bb4]; //pre_binding1\n+//  }\n //  bb4: {\n-//      falseEdges -> [real: bb9, imaginary: bb5]; //pre_binding1\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb2, imaginary: bb5]; //pre_binding2\n //  }\n //  bb5: {\n-//      falseEdges -> [real: bb3, imaginary: bb6]; //pre_binding2\n+//      ReadForMatch(_4);\n+//      falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding3\n //  }\n //  bb6: {\n-//      falseEdges -> [real: bb12, imaginary: bb7]; //pre_binding3\n+//      unreachable;\n //  }\n //  bb7: {\n //      unreachable;\n //  }\n-//  bb8: {\n-//      unreachable;\n+//  bb8: { // binding1 and guard\n+//      StorageLive(_7);\n+//      _7 = &((_2 as Some).0: i32);\n+//      StorageLive(_10);\n+//      _10 = const guard() -> [return: bb9, unwind: bb1];\n //  }\n-//  bb9: { // binding1 and guard\n-//      StorageLive(_5);\n-//      _5 = &((_2 as Some).0: i32);\n-//      StorageLive(_8);\n-//      _8 = const guard() -> [return: bb10, unwind: bb1];\n+//  bb9: { // end of guard\n+//      switchInt(move _10) -> [false: bb10, otherwise: bb11];\n //  }\n-//  bb10: { // end of guard\n-//      StorageLive(_4);\n-//      _4 = ((_2 as Some).0: i32);\n-//      switchInt(move _8) -> [false: bb11, otherwise: bb2];\n+//  bb10: { // to pre_binding3 (can skip 2 since this is `Some`)\n+//      falseEdges -> [real: bb5, imaginary: bb4];\n //  }\n-//  bb11: { // to pre_binding2\n-//      falseEdges -> [real: bb6, imaginary: bb5];\n+//  bb11: { // arm1\n+//      StorageLive(_5);\n+//      _5 = ((_2 as Some).0: i32);\n+//      StorageLive(_11);\n+//      _11 = _5;\n+//      _1 = (const 1i32, move _11);\n+//      StorageDead(_11);\n+//      goto -> bb13;\n //  }\n-//  bb12: { // binding2 and arm2\n-//      StorageLive(_6);\n-//      _6 = ((_2 as Some).0: i32);\n-//      StorageLive(_10);\n-//      _10 = _6;\n-//      _1 = (const 2i32, move _10);\n-//      StorageDead(_10);\n+//  bb12: { // binding3 and arm3\n+//      StorageLive(_8);\n+//      _8 = ((_2 as Some).0: i32);\n+//      StorageLive(_12);\n+//      _12 = _8;\n+//      _1 = (const 2i32, move _12);\n+//      StorageDead(_12);\n //      goto -> bb13;\n //  }\n //  bb13: {\n@@ -187,76 +196,80 @@ fn main() {\n //     ...\n //     _2 = std::option::Option<i32>::Some(const 1i32,);\n //     _3 = discriminant(_2);\n-//     _10 = discriminant(_2);\n-//     switchInt(move _10) -> [1isize: bb4, otherwise: bb5];\n+//     _4 = &_2;\n+//     _13 = discriminant(_2);\n+//     switchInt(move _13) -> [1isize: bb2, otherwise: bb3];\n // }\n // bb1: {\n //     resume;\n // }\n-// bb2: { // arm1\n-//     _1 = const 1i32;\n-//     goto -> bb17;\n+// bb2: {\n+//     ReadForMatch(_4);\n+//     falseEdges -> [real: bb7, imaginary: bb3]; //pre_binding1\n // }\n-// bb3: { // arm3\n-//     _1 = const 3i32;\n-//     goto -> bb17;\n+// bb3: {\n+//     ReadForMatch(_4);\n+//     falseEdges -> [real: bb11, imaginary: bb4]; //pre_binding2\n // }\n-//\n // bb4: {\n-//     falseEdges -> [real: bb9, imaginary: bb5]; //pre_binding1\n+//     ReadForMatch(_4);\n+//     falseEdges -> [real: bb12, imaginary: bb5]; //pre_binding3\n // }\n // bb5: {\n-//     falseEdges -> [real: bb12, imaginary: bb6]; //pre_binding2\n+//     ReadForMatch(_4);\n+//     falseEdges -> [real: bb16, imaginary: bb6]; //pre_binding4\n // }\n // bb6: {\n-//     falseEdges -> [real: bb13, imaginary: bb7]; //pre_binding3\n-// }\n-// bb7: {\n-//     falseEdges -> [real: bb16, imaginary: bb8]; //pre_binding4\n-// }\n-// bb8: {\n //     unreachable;\n // }\n-// bb9: { // binding1: Some(w) if guard()\n-//     StorageLive(_5);\n-//     _5 = &((_2 as Some).0: i32);\n-//     StorageLive(_11);\n-//     _11 = const guard() -> [return: bb10, unwind: bb1];\n+// bb7: { // binding1: Some(w) if guard()\n+//     StorageLive(_7);\n+//     _7 = &((_2 as Some).0: i32);\n+//     StorageLive(_14);\n+//     _14 = const guard() -> [return: bb8, unwind: bb1];\n // }\n-// bb10: { //end of guard\n-//    StorageLive(_4);\n-//    _4 = ((_2 as Some).0: i32);\n-//    switchInt(move _11) -> [false: bb11, otherwise: bb2];\n+// bb8: { //end of guard\n+//     switchInt(move _14) -> [false: bb9, otherwise: bb10];\n // }\n-// bb11: { // to pre_binding2\n-//     falseEdges -> [real: bb5, imaginary: bb5];\n+// bb9: { // to pre_binding2\n+//     falseEdges -> [real: bb3, imaginary: bb3];\n // }\n-// bb12: { // binding2 & arm2\n-//     StorageLive(_6);\n-//     _6 = _2;\n-//     _1 = const 2i32;\n+// bb10: { // set up bindings for arm1\n+//     StorageLive(_5);\n+//     _5 = ((_2 as Some).0: i32);\n+//     _1 = const 1i32;\n //     goto -> bb17;\n // }\n-// bb13: { // binding3: Some(y) if guard2(y)\n+// bb11: { // binding2 & arm2\n //     StorageLive(_8);\n-//     _8 = &((_2 as Some).0: i32);\n-//     StorageLive(_13);\n-//     StorageLive(_14);\n-//     _14 = (*_8);\n-//     _13 = const guard2(move _14) -> [return: bb14, unwind: bb1];\n+//     _8 = _2;\n+//     _1 = const 2i32;\n+//     goto -> bb17;\n // }\n-// bb14: { // end of guard2\n-//     StorageDead(_14);\n-//     StorageLive(_7);\n-//     _7 = ((_2 as Some).0: i32);\n-//     switchInt(move _13) -> [false: bb15, otherwise: bb3];\n+// bb12: { // binding3: Some(y) if guard2(y)\n+//     StorageLive(_11);\n+//     _11 = &((_2 as Some).0: i32);\n+//     StorageLive(_16);\n+//     StorageLive(_17);\n+//     _17 = (*_11);\n+//     _16 = const guard2(move _17) -> [return: bb13, unwind: bb1];\n // }\n-// bb15: { // to pre_binding4\n-//     falseEdges -> [real: bb7, imaginary: bb7];\n+// bb13: { // end of guard2\n+//     StorageDead(_17);\n+//     switchInt(move _16) -> [false: bb14, otherwise: bb15];\n // }\n-// bb16: { // binding4 & arm4\n+// bb14: { // to pre_binding4\n+//     falseEdges -> [real: bb5, imaginary: bb5];\n+// }\n+// bb15: { // set up bindings for arm3\n //     StorageLive(_9);\n-//     _9 = _2;\n+//     _9 = ((_2 as Some).0: i32);\n+//     _1 = const 3i32;\n+//     goto -> bb17;\n+// }\n+// bb16: { // binding4 & arm4\n+//     StorageLive(_12);\n+//     _12 = _2;\n //     _1 = const 4i32;\n //     goto -> bb17;\n // }"}, {"sha": "ac415e31f2b64e6d6877434bea1a66bc3650f498", "filename": "src/test/run-pass/issue-24535-allow-mutable-borrow-in-match-guard.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Frun-pass%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Frun-pass%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-24535-allow-mutable-borrow-in-match-guard.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This test illustrates that under NLL, we can remove our overly\n+// conservative approach for disallowing mutations of match inputs.\n+\n+// See further discussion on rust-lang/rust#24535 and\n+// rust-lang/rfcs#1006.\n+\n+// compile-flags: -Z disable-ast-check-for-mutation-in-guard\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    rust_issue_24535();\n+    rfcs_issue_1006_1();\n+    rfcs_issue_1006_2();\n+}\n+\n+fn rust_issue_24535() {\n+    fn compare(a: &u8, b: &mut u8) -> bool {\n+        a == b\n+    }\n+\n+    let a = 3u8;\n+\n+    match a {\n+        0 => panic!(\"nope\"),\n+        3 if compare(&a, &mut 3) => (),\n+        _ => panic!(\"nope\"),\n+    }\n+}\n+\n+fn rfcs_issue_1006_1() {\n+    let v = vec![\"1\".to_string(), \"2\".to_string(), \"3\".to_string()];\n+    match Some(&v) {\n+        Some(iv) if iv.iter().any(|x| &x[..]==\"2\") => true,\n+        _ => panic!(\"nope\"),\n+    };\n+}\n+\n+fn rfcs_issue_1006_2() {\n+    #[inline(always)]\n+    fn check<'a, I: Iterator<Item=&'a i32>>(mut i: I) -> bool {\n+        i.any(|&x| x == 2)\n+    }\n+\n+    let slice = [1, 2, 3];\n+\n+    match 42 {\n+        _ if slice.iter().any(|&x| x == 2) => { true },\n+        _ => { panic!(\"nope\"); }\n+    };\n+\n+    // (This match is just illustrating how easy it was to circumvent\n+    // the checking performed for the previous `match`.)\n+    match 42 {\n+        _ if check(slice.iter()) => { true },\n+        _ => { panic!(\"nope\"); }\n+    };\n+}"}, {"sha": "29481dbe522110c2b724e896cce35065673fed52", "filename": "src/test/ui/borrowck/issue-41962.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -15,11 +15,12 @@ pub fn main(){\n \n     loop {\n         if let Some(thing) = maybe {\n-        //~^ ERROR use of partially moved value: `maybe` (Ast) [E0382]\n+        }\n+        //~^^ ERROR use of partially moved value: `maybe` (Ast) [E0382]\n         //~| ERROR use of moved value: `(maybe as std::prelude::v1::Some).0` (Ast) [E0382]\n         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n         //~| ERROR use of moved value: `maybe.0` (Mir) [E0382]\n-        }\n+        //~| ERROR borrow of moved value: `maybe` (Mir) [E0382]\n     }\n }"}, {"sha": "e6eb3739d8c6fd3a624343944bbb24ea900b1a91", "filename": "src/test/ui/borrowck/issue-41962.stderr", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-41962.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -23,16 +23,23 @@ LL |           if let Some(thing) = maybe {\n    |           ^           ----- value moved here\n    |  _________|\n    | |\n-LL | |         //~^ ERROR use of partially moved value: `maybe` (Ast) [E0382]\n-LL | |         //~| ERROR use of moved value: `(maybe as std::prelude::v1::Some).0` (Ast) [E0382]\n-LL | |         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n-LL | |         //~| ERROR use of moved value: `maybe` (Mir) [E0382]\n-LL | |         //~| ERROR use of moved value: `maybe.0` (Mir) [E0382]\n LL | |         }\n    | |_________^ value used here after move\n    |\n    = note: move occurs because `maybe` has type `std::option::Option<std::vec::Vec<bool>>`, which does not implement the `Copy` trait\n \n+error[E0382]: borrow of moved value: `maybe` (Mir)\n+  --> $DIR/issue-41962.rs:17:9\n+   |\n+LL |           if let Some(thing) = maybe {\n+   |           ^           ----- value moved here\n+   |  _________|\n+   | |\n+LL | |         }\n+   | |_________^ value borrowed here after move\n+   |\n+   = note: move occurs because `maybe` has type `std::option::Option<std::vec::Vec<bool>>`, which does not implement the `Copy` trait\n+\n error[E0382]: use of moved value: `maybe` (Mir)\n   --> $DIR/issue-41962.rs:17:16\n    |\n@@ -52,6 +59,6 @@ LL |         if let Some(thing) = maybe {\n    |\n    = note: move occurs because `maybe.0` has type `std::vec::Vec<bool>`, which does not implement the `Copy` trait\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 6 previous errors\n \n For more information about this error, try `rustc --explain E0382`."}, {"sha": "b3be36e41e657408d9e02b083bb701a4d16b2960", "filename": "src/test/ui/issue-27282-move-match-input-into-guard.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 27282: Example 2: This sidesteps the AST checks disallowing\n+// mutable borrows in match guards by hiding the mutable borrow in a\n+// guard behind a move (of the mutably borrowed match input) within a\n+// closure.\n+//\n+// This example is not rejected by AST borrowck (and then reliably\n+// reaches the panic code when executed, despite the compiler warning\n+// about that match arm being unreachable.\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let b = &mut true;\n+    match b {\n+        &mut false => {},\n+        _ if { (|| { let bar = b; *bar = false; })();\n+                     //~^ ERROR cannot move out of `b` because it is borrowed [E0505]\n+                     false } => { },\n+        &mut true => { println!(\"You might think we should get here\"); },\n+        //~^ ERROR use of moved value: `*b` [E0382]\n+        _ => panic!(\"surely we could never get here, since rustc warns it is unreachable.\"),\n+    }\n+}"}, {"sha": "f89388f1738ead329beae9b062c429d1035c4fd0", "filename": "src/test/ui/issue-27282-move-match-input-into-guard.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-move-match-input-into-guard.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,32 @@\n+error[E0505]: cannot move out of `b` because it is borrowed\n+  --> $DIR/issue-27282-move-match-input-into-guard.rs:26:16\n+   |\n+LL |        match b {\n+   |   _____-\n+   |  |_____|\n+   | ||\n+LL | ||         &mut false => {},\n+LL | ||         _ if { (|| { let bar = b; *bar = false; })();\n+   | ||                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move out of `b` occurs here\n+LL | ||                      //~^ ERROR cannot move out of `b` because it is borrowed [E0505]\n+...  ||\n+LL | ||         _ => panic!(\"surely we could never get here, since rustc warns it is unreachable.\"),\n+LL | ||     }\n+   | ||     -\n+   | ||_____|\n+   | |______borrow of `b` occurs here\n+   |        borrow later used here\n+\n+error[E0382]: use of moved value: `*b`\n+  --> $DIR/issue-27282-move-match-input-into-guard.rs:29:14\n+   |\n+LL |         _ if { (|| { let bar = b; *bar = false; })();\n+   |                ----------------------------------- value moved here\n+...\n+LL |         &mut true => { println!(\"You might think we should get here\"); },\n+   |              ^^^^ value used here after move\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors occurred: E0382, E0505.\n+For more information about an error, try `rustc --explain E0382`."}, {"sha": "5b4c746a1b611e1725b5cf113d2a6031a20c328b", "filename": "src/test/ui/issue-27282-move-ref-mut-into-guard.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 27282: Example 1: This sidesteps the AST checks disallowing\n+// mutable borrows in match guards by hiding the mutable borrow in a\n+// guard behind a move (of the ref mut pattern id) within a closure.\n+//\n+// This example is not rejected by AST borrowck (and then reliably\n+// segfaults when executed).\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    match Some(&4) {\n+        None => {},\n+        ref mut foo\n+            if { (|| { let bar = foo; bar.take() })(); false } => {},\n+        //~^ ERROR cannot move out of borrowed content [E0507]\n+        Some(s) => std::process::exit(*s),\n+    }\n+}"}, {"sha": "f6ffa90069cc4c3519f7e078864d5a84b867dcad", "filename": "src/test/ui/issue-27282-move-ref-mut-into-guard.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-move-ref-mut-into-guard.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,9 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/issue-27282-move-ref-mut-into-guard.rs:24:18\n+   |\n+LL |             if { (|| { let bar = foo; bar.take() })(); false } => {},\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot move out of borrowed content\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0507`."}, {"sha": "b575f4ebce6c013c55338f924fba5e7ea41d6d02", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-1.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is testing an attempt to corrupt the discriminant of the match\n+// arm in a guard, followed by an attempt to continue matching on that\n+// corrupted discriminant in the remaining match arms.\n+//\n+// Basically this is testing that our new NLL feature of emitting a\n+// fake read on each match arm is catching cases like this.\n+//\n+// This case is interesting because it includes a guard that\n+// diverges, and therefore a single final fake-read at the very end\n+// after the final match arm would not suffice.\n+\n+#![feature(nll)]\n+\n+struct ForceFnOnce;\n+\n+fn main() {\n+    let mut x = &mut Some(&2);\n+    let force_fn_once = ForceFnOnce;\n+    match x {\n+        &mut None => panic!(\"unreachable\"),\n+        &mut Some(&_) if {\n+            // ForceFnOnce needed to exploit #27282\n+            (|| { *x = None; drop(force_fn_once); })();\n+            //~^ ERROR closure requires unique access to `x` but it is already borrowed [E0500]\n+            false\n+        } => {}\n+        &mut Some(&a) if { // this binds to garbage if we've corrupted discriminant\n+            println!(\"{}\", a);\n+            panic!()\n+        } => {}\n+        _ => panic!(\"unreachable\"),\n+    }\n+}"}, {"sha": "8f7fe9d33fe4128826edbcf27aa312b44b5a23ea", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-1.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-1.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,25 @@\n+error[E0500]: closure requires unique access to `x` but it is already borrowed\n+  --> $DIR/issue-27282-mutate-before-diverging-arm-1.rs:33:14\n+   |\n+LL |        match x {\n+   |   _____-\n+   |  |_____|\n+   | ||\n+LL | ||         &mut None => panic!(\"unreachable\"),\n+LL | ||         &mut Some(&_) if {\n+LL | ||             // ForceFnOnce needed to exploit #27282\n+LL | ||             (|| { *x = None; drop(force_fn_once); })();\n+   | ||              ^^    - borrow occurs due to use of `x` in closure\n+   | ||              |\n+   | ||              closure construction occurs here\n+...  ||\n+LL | ||         _ => panic!(\"unreachable\"),\n+LL | ||     }\n+   | ||     -\n+   | ||_____|\n+   | |______borrow occurs here\n+   |        borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0500`."}, {"sha": "866fed1368504d63857f465b3b62aae278d902ff", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-2.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is testing an attempt to corrupt the discriminant of the match\n+// arm in a guard, followed by an attempt to continue matching on that\n+// corrupted discriminant in the remaining match arms.\n+//\n+// Basically this is testing that our new NLL feature of emitting a\n+// fake read on each match arm is catching cases like this.\n+//\n+// This case is interesting because it includes a guard that\n+// diverges, and therefore a single final fake-read at the very end\n+// after the final match arm would not suffice.\n+//\n+// It is also interesting because the access to the corrupted data\n+// occurs in the pattern-match itself, and not in the guard\n+// expression.\n+\n+#![feature(nll)]\n+\n+struct ForceFnOnce;\n+\n+fn main() {\n+    let mut x = &mut Some(&2);\n+    let force_fn_once = ForceFnOnce;\n+    match x {\n+        &mut None => panic!(\"unreachable\"),\n+        &mut Some(&_)\n+            if {\n+                // ForceFnOnce needed to exploit #27282\n+                (|| { *x = None; drop(force_fn_once); })();\n+                //~^ ERROR closure requires unique access to `x` but it is already borrowed [E0500]\n+                false\n+            } => {}\n+\n+        // this segfaults if we corrupted the discriminant, because\n+        // the compiler gets to *assume* that it cannot be the `None`\n+        // case, even though that was the effect of the guard.\n+        &mut Some(&2)\n+            if {\n+                panic!()\n+            } => {}\n+        _ => panic!(\"unreachable\"),\n+    }\n+}"}, {"sha": "df5e4300ceca2904fb2c772be008a7f0f416b7ce", "filename": "src/test/ui/issue-27282-mutate-before-diverging-arm-2.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-mutate-before-diverging-arm-2.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,26 @@\n+error[E0500]: closure requires unique access to `x` but it is already borrowed\n+  --> $DIR/issue-27282-mutate-before-diverging-arm-2.rs:38:18\n+   |\n+LL |        match x {\n+   |   _____-\n+   |  |_____|\n+   | ||\n+LL | ||         &mut None => panic!(\"unreachable\"),\n+LL | ||         &mut Some(&_)\n+LL | ||             if {\n+LL | ||                 // ForceFnOnce needed to exploit #27282\n+LL | ||                 (|| { *x = None; drop(force_fn_once); })();\n+   | ||                  ^^    - borrow occurs due to use of `x` in closure\n+   | ||                  |\n+   | ||                  closure construction occurs here\n+...  ||\n+LL | ||         _ => panic!(\"unreachable\"),\n+LL | ||     }\n+   | ||     -\n+   | ||_____|\n+   | |______borrow occurs here\n+   |        borrow later used here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0500`."}, {"sha": "5d445c63ef49298c43cc5164bd163ee010d3660d", "filename": "src/test/ui/issue-27282-reborrow-ref-mut-in-guard.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 27282: This is a variation on issue-27282-move-ref-mut-into-guard.rs\n+//\n+// It reborrows instead of moving the `ref mut` pattern borrow. This\n+// means that our conservative check for mutation in guards will\n+// reject it. But I want to make sure that we continue to reject it\n+// (under NLL) even when that conservaive check goes away.\n+\n+// compile-flags: -Z disable-ast-check-for-mutation-in-guard\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let mut b = &mut true;\n+    match b {\n+        &mut false => {},\n+        ref mut r if { (|| { let bar = &mut *r; **bar = false; })();\n+                             //~^ ERROR cannot borrow immutable item `*r` as mutable\n+                             false } => { &mut *r; },\n+        &mut true => { println!(\"You might think we should get here\"); },\n+        _ => panic!(\"surely we could never get here, since rustc warns it is unreachable.\"),\n+    }\n+}"}, {"sha": "d767fdde9f217a52385cf3e84605483bca7057ec", "filename": "src/test/ui/issue-27282-reborrow-ref-mut-in-guard.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8372e7b37eb9777edc8f7179fc6cbc39456ce735/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr?ref=8372e7b37eb9777edc8f7179fc6cbc39456ce735", "patch": "@@ -0,0 +1,9 @@\n+error[E0596]: cannot borrow immutable item `*r` as mutable\n+  --> $DIR/issue-27282-reborrow-ref-mut-in-guard.rs:26:24\n+   |\n+LL |         ref mut r if { (|| { let bar = &mut *r; **bar = false; })();\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0596`."}]}