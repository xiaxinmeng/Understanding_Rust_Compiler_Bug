{"sha": "e590b849b83dd97fe98a39971cd91b692a0cf2a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OTBiODQ5YjgzZGQ5N2ZlOThhMzk5NzFjZDkxYjY5MmEwY2YyYTg=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-28T11:44:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T21:02:53Z"}, "message": "CTFE: simplify Value type by not checking for alignment", "tree": {"sha": "622391b54d6779c4065cbf9822956f0effd19ae4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/622391b54d6779c4065cbf9822956f0effd19ae4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e590b849b83dd97fe98a39971cd91b692a0cf2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e590b849b83dd97fe98a39971cd91b692a0cf2a8", "html_url": "https://github.com/rust-lang/rust/commit/e590b849b83dd97fe98a39971cd91b692a0cf2a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e590b849b83dd97fe98a39971cd91b692a0cf2a8/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf048cc115860cc110865f460f3f2b9b4308ad92", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf048cc115860cc110865f460f3f2b9b4308ad92", "html_url": "https://github.com/rust-lang/rust/commit/cf048cc115860cc110865f460f3f2b9b4308ad92"}], "stats": {"total": 109, "additions": 50, "deletions": 59}, "files": [{"sha": "5381d4697244093928b23f79c5eac80214a331d2", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -2,7 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n-use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n+use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n \n@@ -45,18 +45,11 @@ pub enum ConstValue<'tcx> {\n \n     /// A value not represented/representable by `Scalar` or `Slice`\n     ByRef {\n-        /// The alignment exists to allow `const_field` to have `ByRef` access to nonprimitive\n-        /// fields of `repr(packed)` structs. The alignment may be lower than the type of this\n-        /// constant. This permits reads with lower alignment than what the type would normally\n-        /// require.\n-        /// FIXME(RalfJ,oli-obk): The alignment checks are part of miri, but const eval doesn't\n-        /// really need them. Disabling them may be too hard though.\n-        align: Align,\n-        /// Offset into `alloc`\n-        offset: Size,\n         /// The backing memory of the value, may contain more memory than needed for just the value\n         /// in order to share `Allocation`s between values\n         alloc: &'tcx Allocation,\n+        /// Offset into `alloc`\n+        offset: Size,\n     },\n \n     /// Used in the HIR by using `Unevaluated` everywhere and later normalizing to one of the other"}, {"sha": "649a5244728baa2a4d7114aea0512ecc71622472", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -1367,8 +1367,8 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Const<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for ConstValue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {\n-            ConstValue::ByRef { offset, align, alloc } =>\n-                ConstValue::ByRef { offset, align, alloc },\n+            ConstValue::ByRef { alloc, offset } =>\n+                ConstValue::ByRef { alloc, offset },\n             ConstValue::Infer(ic) => ConstValue::Infer(ic.fold_with(folder)),\n             ConstValue::Param(p) => ConstValue::Param(p.fold_with(folder)),\n             ConstValue::Placeholder(p) => ConstValue::Placeholder(p),"}, {"sha": "19b051a4f38e0c4ba6829ab4c7b5ed9aa934a4e7", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -11,7 +11,7 @@ use crate::value::Value;\n use rustc_codegen_ssa::traits::*;\n \n use crate::consts::const_alloc_to_llvm;\n-use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size, Align};\n+use rustc::ty::layout::{HasDataLayout, LayoutOf, self, TyLayout, Size};\n use rustc::mir::interpret::{Scalar, GlobalAlloc, Allocation};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n \n@@ -329,10 +329,10 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn from_const_alloc(\n         &self,\n         layout: TyLayout<'tcx>,\n-        align: Align,\n         alloc: &Allocation,\n         offset: Size,\n     ) -> PlaceRef<'tcx, &'ll Value> {\n+        let align = alloc.align; // follow what CTFE did, not what the layout says\n         let init = const_alloc_to_llvm(self, alloc);\n         let base_addr = self.static_addr_of(init, align, None);\n "}, {"sha": "0077df3cf5eea191dcbc475038ab32a5055b62d7", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -72,8 +72,8 @@ pub fn codegen_static_initializer(\n \n     let alloc = match static_.val {\n         ConstValue::ByRef {\n-            offset, align, alloc,\n-        } if offset.bytes() == 0 && align == alloc.align => {\n+            alloc, offset,\n+        } if offset.bytes() == 0 => {\n             alloc\n         },\n         _ => bug!(\"static const eval returned {:#?}\", static_),"}, {"sha": "5e5804b72657b6009228fb19f447bc6f787f1bcc", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -109,8 +109,8 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n                 let b_llval = bx.const_usize((end - start) as u64);\n                 OperandValue::Pair(a_llval, b_llval)\n             },\n-            ConstValue::ByRef { offset, align, alloc } => {\n-                return bx.load_operand(bx.from_const_alloc(layout, align, alloc, offset));\n+            ConstValue::ByRef { alloc, offset } => {\n+                return bx.load_operand(bx.from_const_alloc(layout, alloc, offset));\n             },\n         };\n "}, {"sha": "a632838ba24424b5714d1cd77b47a89c95d4c1a0", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -466,8 +466,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n                 match bx.tcx().const_eval(param_env.and(cid)) {\n                     Ok(val) => match val.val {\n-                        mir::interpret::ConstValue::ByRef { offset, align, alloc } => {\n-                            bx.cx().from_const_alloc(layout, align, alloc, offset)\n+                        mir::interpret::ConstValue::ByRef { alloc, offset } => {\n+                            bx.cx().from_const_alloc(layout, alloc, offset)\n                         }\n                         _ => bug!(\"promoteds should have an allocation: {:?}\", val),\n                     },"}, {"sha": "e7ce03f1836198293376a553e1e5ee7027ae4f74", "filename": "src/librustc_codegen_ssa/traits/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fconsts.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -35,7 +35,6 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn from_const_alloc(\n         &self,\n         layout: layout::TyLayout<'tcx>,\n-        align: layout::Align,\n         alloc: &Allocation,\n         offset: layout::Size,\n     ) -> PlaceRef<'tcx, Self::Value>;"}, {"sha": "b94294578500f6e1c9d36e5840f1130b63fbfaa9", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -98,7 +98,7 @@ fn op_to_const<'tcx>(\n         Ok(mplace) => {\n             let ptr = mplace.ptr.to_ptr().unwrap();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-            ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }\n+            ConstValue::ByRef { alloc, offset: ptr.offset }\n         },\n         // see comment on `let try_as_immediate` above\n         Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n@@ -112,7 +112,7 @@ fn op_to_const<'tcx>(\n                 let mplace = op.assert_mem_place();\n                 let ptr = mplace.ptr.to_ptr().unwrap();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n-                ConstValue::ByRef { offset: ptr.offset, align: mplace.align, alloc }\n+                ConstValue::ByRef { alloc, offset: ptr.offset }\n             },\n         },\n         Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n@@ -326,6 +326,10 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n+    // We do not check for alignment to avoid having to carry an `Align`\n+    // in `ConstValue::ByRef`.\n+    const CHECK_ALIGN: bool = false;\n+\n     #[inline(always)]\n     fn enforce_validity(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n@@ -552,9 +556,8 @@ fn validate_and_turn_into_const<'tcx>(\n             let ptr = mplace.ptr.to_ptr()?;\n             Ok(tcx.mk_const(ty::Const {\n                 val: ConstValue::ByRef {\n-                    offset: ptr.offset,\n-                    align: mplace.align,\n                     alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),\n+                    offset: ptr.offset,\n                 },\n                 ty: mplace.layout.ty,\n             }))"}, {"sha": "b1a317ee65f6f70bbd623fb60958bbe79a65a4c7", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -218,10 +218,8 @@ impl LiteralExpander<'tcx> {\n             (ConstValue::Scalar(Scalar::Ptr(p)), x, y) if x == y => {\n                 let alloc = self.tcx.alloc_map.lock().unwrap_memory(p.alloc_id);\n                 ConstValue::ByRef {\n-                    offset: p.offset,\n-                    // FIXME(oli-obk): this should be the type's layout\n-                    align: alloc.align,\n                     alloc,\n+                    offset: p.offset,\n                 }\n             },\n             // unsize array to slice if pattern is array but match value or other patterns are slice"}, {"sha": "c6686fafd94ee858e81ea5dffa8cdf7b4694ae74", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -109,6 +109,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// that is added to the memory so that the work is not done twice.\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n+    /// Whether memory accesses should be alignment-checked.\n+    const CHECK_ALIGN: bool;\n+\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n "}, {"sha": "fcefe1abd7063103b4a69e45ed3c434c6a46db49", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -338,11 +338,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(bits) => {\n                 let bits = bits as u64; // it's ptr-sized\n                 assert!(size.bytes() == 0);\n-                // Must be non-NULL and aligned.\n+                // Must be non-NULL.\n                 if bits == 0 {\n                     throw_unsup!(InvalidNullPointerUsage)\n                 }\n-                check_offset_align(bits, align)?;\n+                // Must be aligned.\n+                if M::CHECK_ALIGN {\n+                    check_offset_align(bits, align)?;\n+                }\n                 None\n             }\n             Err(ptr) => {\n@@ -355,18 +358,20 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n-                if alloc_align.bytes() < align.bytes() {\n-                    // The allocation itself is not aligned enough.\n-                    // FIXME: Alignment check is too strict, depending on the base address that\n-                    // got picked we might be aligned even if this check fails.\n-                    // We instead have to fall back to converting to an integer and checking\n-                    // the \"real\" alignment.\n-                    throw_unsup!(AlignmentCheckFailed {\n-                        has: alloc_align,\n-                        required: align,\n-                    })\n+                if M::CHECK_ALIGN {\n+                    if alloc_align.bytes() < align.bytes() {\n+                        // The allocation itself is not aligned enough.\n+                        // FIXME: Alignment check is too strict, depending on the base address that\n+                        // got picked we might be aligned even if this check fails.\n+                        // We instead have to fall back to converting to an integer and checking\n+                        // the \"real\" alignment.\n+                        throw_unsup!(AlignmentCheckFailed {\n+                            has: alloc_align,\n+                            required: align,\n+                        });\n+                    }\n+                    check_offset_align(ptr.offset.bytes(), align)?;\n                 }\n-                check_offset_align(ptr.offset.bytes(), align)?;\n \n                 // We can still be zero-sized in this branch, in which case we have to\n                 // return `None`."}, {"sha": "18a70ae2607443e18f75b48728b9f0f55bc1fb07", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -548,12 +548,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.layout_of(self.monomorphize(val.ty)?)\n         })?;\n         let op = match val.val {\n-            ConstValue::ByRef { offset, align, alloc } => {\n+            ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.alloc_map.lock().create_memory_alloc(alloc);\n                 // We rely on mutability being set correctly in that allocation to prevent writes\n                 // where none should happen.\n                 let ptr = self.tag_static_base_pointer(Pointer::new(id, offset));\n-                Operand::Indirect(MemPlace::from_ptr(ptr, align))\n+                Operand::Indirect(MemPlace::from_ptr(ptr, layout.align.abi))\n             },\n             ConstValue::Scalar(x) =>\n                 Operand::Immediate(Immediate::Scalar(tag_scalar(x).into())),"}, {"sha": "accc520a64f0fc03dfd0b839bad021acdca23ac9", "filename": "src/test/ui/consts/const-eval/ub-ref.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.rs?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -4,9 +4,7 @@\n \n use std::mem;\n \n-const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-//~^ ERROR it is undefined behavior to use this value\n-//~^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n+const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) }; // Ok (CTFE does not check alignment)\n \n const NULL: &u16 = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value"}, {"sha": "e6d45ca8c9de4973aa044f49fe919d6bbe50736c", "filename": "src/test/ui/consts/const-eval/ub-ref.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e590b849b83dd97fe98a39971cd91b692a0cf2a8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-ref.stderr?ref=e590b849b83dd97fe98a39971cd91b692a0cf2a8", "patch": "@@ -1,43 +1,35 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:7:1\n-   |\n-LL | const UNALIGNED: &u16 = unsafe { mem::transmute(&[0u8; 4]) };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered unaligned reference (required 2 byte alignment but found 1)\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n-\n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:11:1\n+  --> $DIR/ub-ref.rs:9:1\n    |\n LL | const NULL: &u16 = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:14:1\n+  --> $DIR/ub-ref.rs:12:1\n    |\n LL | const REF_AS_USIZE: usize = unsafe { mem::transmute(&0) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected initialized plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:17:1\n+  --> $DIR/ub-ref.rs:15:1\n    |\n LL | const REF_AS_USIZE_SLICE: &[usize] = &[unsafe { mem::transmute(&0) }];\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer at .<deref>, but expected plain (non-pointer) bytes\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-ref.rs:20:1\n+  --> $DIR/ub-ref.rs:18:1\n    |\n LL | const USIZE_AS_REF: &'static u8 = unsafe { mem::transmute(1337usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered dangling reference (created from integer)\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}