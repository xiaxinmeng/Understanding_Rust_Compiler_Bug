{"sha": "dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOGIyM2JjMWZmYTIyN2JkYzdiOTUyMDZjN2IyZGFiZTMyODE4YWM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-07-15T03:03:17Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2014-08-13T18:31:47Z"}, "message": "std: Add sleep, oneshot and periodic timers, taking Duration", "tree": {"sha": "cb12edffac1611b4a7d56bc2411c43933703bff8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb12edffac1611b4a7d56bc2411c43933703bff8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "html_url": "https://github.com/rust-lang/rust/commit/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "657b679b158894556628f096a28aab364b605446", "url": "https://api.github.com/repos/rust-lang/rust/commits/657b679b158894556628f096a28aab364b605446", "html_url": "https://github.com/rust-lang/rust/commit/657b679b158894556628f096a28aab364b605446"}], "stats": {"total": 97, "additions": 97, "deletions": 0}, "files": [{"sha": "ff6ae05bb4951cf1046ddb16bd5412d1b8f0c2af", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=dc8b23bc1ffa227bdc7b95206c7b2dabe32818ac", "patch": "@@ -18,9 +18,11 @@ and create receivers which will receive notifications after a period of time.\n */\n \n use comm::{Receiver, Sender, channel};\n+use time::Duration;\n use io::{IoResult, IoError};\n use kinds::Send;\n use boxed::Box;\n+use num::{CheckedMul, CheckedAdd};\n use rt::rtio::{IoFactory, LocalIo, RtioTimer, Callback};\n \n /// A synchronous timer object\n@@ -69,6 +71,33 @@ pub struct Timer {\n \n struct TimerCallback { tx: Sender<()> }\n \n+#[allow(missing_doc)]\n+trait DurationExtension {\n+    fn in_ms(&self) -> u64;\n+}\n+\n+impl DurationExtension for Duration {\n+    fn in_ms(&self) -> u64 {\n+        if self.ndays() < 0 { fail!(\"negative duration\") }\n+        let nanos = self.nnanoseconds() as u64;\n+        let secs = self.nseconds() as u64;\n+        let days = self.ndays() as u64;\n+        let nanos_in_ms = nanos / 1000;\n+        let secs_in_ms = secs.checked_mul(&1000).expect(\"overflow\");\n+        let ms_per_day = 24 * 60 * 60 * 1000; // hours/day * min/hour * sec/min * ms/sec\n+        let days_in_ms = days.checked_mul(&ms_per_day).expect(\"overflow\");\n+        let result = nanos_in_ms;\n+        let result = result.checked_add(&secs_in_ms).expect(\"overflow\");\n+        let result = result.checked_add(&(days_in_ms as u64)).expect(\"overflow\");\n+        return result;\n+    }\n+}\n+\n+/// Sleep the current task for the specified duration.\n+pub fn sleep(duration: Duration) {\n+    sleep_ms(duration.in_ms())\n+}\n+\n /// Sleep the current task for `msecs` milliseconds.\n pub fn sleep_ms(msecs: u64) {\n     let timer = Timer::new();\n@@ -87,6 +116,14 @@ impl Timer {\n         }).map_err(IoError::from_rtio_error)\n     }\n \n+    /// Blocks the current task for the specified duration.\n+    ///\n+    /// Note that this function will cause any other receivers for this timer to\n+    /// be invalidated (the other end will be closed).\n+    pub fn sleep(&mut self, duration: Duration) {\n+        self.obj.sleep(duration.in_ms());\n+    }\n+\n     /// Blocks the current task for `msecs` milliseconds.\n     ///\n     /// Note that this function will cause any other receivers for this timer to\n@@ -95,6 +132,23 @@ impl Timer {\n         self.obj.sleep(msecs);\n     }\n \n+    /// Creates a oneshot receiver which will have a notification sent when\n+    /// the specified duration has elapsed.\n+    ///\n+    /// This does *not* block the current task, but instead returns immediately.\n+    ///\n+    /// Note that this invalidates any previous receiver which has been created\n+    /// by this timer, and that the returned receiver will be invalidated once\n+    /// the timer is destroyed (when it falls out of scope). In particular, if\n+    /// this is called in method-chaining style, the receiver will be\n+    /// invalidated at the end of that statement, and all `recv` calls will\n+    /// fail.\n+    pub fn oneshot(&mut self, duration: Duration) -> Receiver<()> {\n+        let (tx, rx) = channel();\n+        self.obj.oneshot(duration.in_ms(), box TimerCallback { tx: tx });\n+        return rx\n+    }\n+\n     /// Creates a oneshot receiver which will have a notification sent when\n     /// `msecs` milliseconds has elapsed.\n     ///\n@@ -135,6 +189,25 @@ impl Timer {\n         return rx\n     }\n \n+    /// Creates a receiver which will have a continuous stream of notifications\n+    /// being sent each time the specified duration has elapsed.\n+    ///\n+    /// This does *not* block the current task, but instead returns\n+    /// immediately. The first notification will not be received immediately,\n+    /// but rather after the first duration.\n+    ///\n+    /// Note that this invalidates any previous receiver which has been created\n+    /// by this timer, and that the returned receiver will be invalidated once\n+    /// the timer is destroyed (when it falls out of scope). In particular, if\n+    /// this is called in method-chaining style, the receiver will be\n+    /// invalidated at the end of that statement, and all `recv` calls will\n+    /// fail.\n+    pub fn periodic(&mut self, duration: Duration) -> Receiver<()> {\n+        let (tx, rx) = channel();\n+        self.obj.period(duration.in_ms(), box TimerCallback { tx: tx });\n+        return rx\n+    }\n+\n     /// Creates a receiver which will have a continuous stream of notifications\n     /// being sent every `msecs` milliseconds.\n     ///\n@@ -365,4 +438,28 @@ mod test {\n         // callback do something terrible.\n         timer2.sleep_ms(2);\n     })\n+\n+\n+    iotest!(fn test_io_timer_sleep_duration_simple() {\n+        use time::Duration;\n+        let mut timer = Timer::new().unwrap();\n+        timer.sleep(Duration::seconds(1));\n+    })\n+\n+    iotest!(fn test_io_timer_sleep_oneshot_duration() {\n+        use time::Duration;\n+        let mut timer = Timer::new().unwrap();\n+        timer.oneshot(Duration::seconds(1)).recv();\n+    })\n+\n+    iotest!(fn test_io_timer_sleep_periodic_duration() {\n+        use time::Duration;\n+        let mut timer = Timer::new().unwrap();\n+        let rx = timer.periodic(Duration::seconds(1));\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n+    })\n+\n+\n }"}]}