{"sha": "ea624699e3311985deec9b150ed02242b86aeb95", "node_id": "C_kwDOAAsO6NoAKGVhNjI0Njk5ZTMzMTE5ODVkZWVjOWIxNTBlZDAyMjQyYjg2YWViOTU", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-01-27T09:49:52Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-02-01T08:55:19Z"}, "message": "implement lint for suspicious auto trait impls", "tree": {"sha": "f4a56c675f094a521eb329a3bf68669bd1cb971b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4a56c675f094a521eb329a3bf68669bd1cb971b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea624699e3311985deec9b150ed02242b86aeb95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea624699e3311985deec9b150ed02242b86aeb95", "html_url": "https://github.com/rust-lang/rust/commit/ea624699e3311985deec9b150ed02242b86aeb95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea624699e3311985deec9b150ed02242b86aeb95/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fcf7745cc9845118a9ffeea066e7ee31236d15f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fcf7745cc9845118a9ffeea066e7ee31236d15f", "html_url": "https://github.com/rust-lang/rust/commit/7fcf7745cc9845118a9ffeea066e7ee31236d15f"}], "stats": {"total": 366, "additions": 359, "deletions": 7}, "files": [{"sha": "cf86c450a5bccff15950f986d196ee1e4f46b248", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -938,6 +938,12 @@ pub struct GrowableBitSet<T: Idx> {\n     bit_set: BitSet<T>,\n }\n \n+impl<T: Idx> Default for GrowableBitSet<T> {\n+    fn default() -> Self {\n+        GrowableBitSet::new_empty()\n+    }\n+}\n+\n impl<T: Idx> GrowableBitSet<T> {\n     /// Ensure that the set can hold at least `min_domain_size` elements.\n     pub fn ensure(&mut self, min_domain_size: usize) {"}, {"sha": "f4eba25475eee0b43bc4abb2632d51cefb479c27", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -3054,6 +3054,7 @@ declare_lint_pass! {\n         DEREF_INTO_DYN_SUPERTRAIT,\n         DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n         DUPLICATE_MACRO_ATTRIBUTES,\n+        SUSPICIOUS_AUTO_TRAIT_IMPLS,\n     ]\n }\n \n@@ -3630,3 +3631,37 @@ declare_lint! {\n     Warn,\n     \"duplicated attribute\"\n }\n+\n+declare_lint! {\n+    /// The `suspicious_auto_trait_impls` lint checks for potentially incorrect\n+    /// implementations of auto traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct Foo<T>(T);\n+    ///\n+    /// unsafe impl<T> Send for Foo<*const T> {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A type can implement auto traits, e.g. `Send`, `Sync` and `Unpin`,\n+    /// in two different ways: either by writing an explicit impl or if\n+    /// all fields of the type implement that auto trait.\n+    ///\n+    /// The compiler disables the automatic implementation if an explicit one\n+    /// exists for given type constructor. The exact rules governing this\n+    /// are currently unsound and quite subtle and and will be modified in the future.\n+    /// This change will cause the automatic implementation to be disabled in more\n+    /// cases, potentially breaking some code.\n+    pub SUSPICIOUS_AUTO_TRAIT_IMPLS,\n+    Warn,\n+    \"the rules governing auto traits will change in the future\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reason: FutureIncompatibilityReason::FutureReleaseSemanticsChange,\n+        reference: \"issue #93367 <https://github.com/rust-lang/rust/issues/93367>\",\n+    };\n+}"}, {"sha": "9e32c0162e6178e45a92ed6925585140916519f7", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -144,6 +144,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n     }\n \n+    pub fn non_blanket_impls_for_ty(\n+        self,\n+        def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+    ) -> impl Iterator<Item = DefId> + 'tcx {\n+        let impls = self.trait_impls_of(def_id);\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, SimplifyParams::No, StripReferences::No)\n+        {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                return impls.iter().copied();\n+            }\n+        }\n+\n+        [].iter().copied()\n+    }\n+\n     /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n     /// the first non-none value.\n     pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>("}, {"sha": "777bd640669ce8f1c33d8e192457a7925dd86847", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 210, "deletions": 3, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -1,24 +1,33 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n+use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::def_id::LocalDefId;\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n+use rustc_middle::ty::{self, ImplPolarity, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_session::lint;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n+use std::ops::ControlFlow;\n \n pub(super) fn orphan_check_crate(tcx: TyCtxt<'_>, (): ()) -> &[LocalDefId] {\n     let mut errors = Vec::new();\n-    for (_trait, impls_of_trait) in tcx.all_local_trait_impls(()) {\n+    for (&trait_def_id, impls_of_trait) in tcx.all_local_trait_impls(()) {\n         for &impl_of_trait in impls_of_trait {\n             match orphan_check_impl(tcx, impl_of_trait) {\n                 Ok(()) => {}\n                 Err(ErrorReported) => errors.push(impl_of_trait),\n             }\n         }\n+\n+        if tcx.trait_is_auto(trait_def_id) {\n+            lint_auto_trait_impls(tcx, trait_def_id, impls_of_trait);\n+        }\n     }\n     tcx.arena.alloc_slice(&errors)\n }\n@@ -265,3 +274,201 @@ fn emit_orphan_check_error<'tcx>(\n \n     Err(ErrorReported)\n }\n+\n+#[derive(Default)]\n+struct AreUniqueParamsVisitor {\n+    seen: GrowableBitSet<u32>,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum NotUniqueParam<'tcx> {\n+    DuplicateParam(GenericArg<'tcx>),\n+    NotParam(GenericArg<'tcx>),\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n+    type BreakTy = NotUniqueParam<'tcx>;\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match t.kind() {\n+            ty::Param(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(t.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(t.into())),\n+        }\n+    }\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReEarlyBound(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(r.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(r.into())),\n+        }\n+    }\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val {\n+            ty::ConstKind::Param(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(c.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(c.into())),\n+        }\n+    }\n+}\n+\n+/// Lint impls of auto traits if they are likely to have\n+/// unsound or surprising effects on auto impls.\n+fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDefId]) {\n+    let mut non_covering_impls = Vec::new();\n+    for &impl_def_id in impls {\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        if trait_ref.references_error() {\n+            return;\n+        }\n+\n+        if tcx.impl_polarity(impl_def_id) != ImplPolarity::Positive {\n+            return;\n+        }\n+\n+        assert_eq!(trait_ref.substs.len(), 1);\n+        let self_ty = trait_ref.self_ty();\n+        let (self_type_did, substs) = match self_ty.kind() {\n+            ty::Adt(def, substs) => (def.did, substs),\n+            _ => {\n+                // FIXME: should also lint for stuff like `&i32` but\n+                // considering that auto traits are unstable, that\n+                // isn't too important for now as this only affects\n+                // crates using `nightly`, and std.\n+                continue;\n+            }\n+        };\n+\n+        // Impls which completely cover a given root type are fine as they\n+        // disable auto impls entirely. So only lint if the substs\n+        // are not a permutation of the identity substs.\n+        match substs.visit_with(&mut AreUniqueParamsVisitor::default()) {\n+            ControlFlow::Continue(()) => {} // ok\n+            ControlFlow::Break(arg) => {\n+                // Ideally:\n+                //\n+                // - compute the requirements for the auto impl candidate\n+                // - check whether these are implied by the non covering impls\n+                // - if not, emit the lint\n+                //\n+                // What we do here is a bit simpler:\n+                //\n+                // - badly check if an auto impl candidate definitely does not apply\n+                //   for the given simplified type\n+                // - if so, do not lint\n+                if fast_reject_auto_impl(tcx, trait_def_id, self_ty) {\n+                    // ok\n+                } else {\n+                    non_covering_impls.push((impl_def_id, self_type_did, arg));\n+                }\n+            }\n+        }\n+    }\n+\n+    for &(impl_def_id, self_type_did, arg) in &non_covering_impls {\n+        tcx.struct_span_lint_hir(\n+            lint::builtin::SUSPICIOUS_AUTO_TRAIT_IMPLS,\n+            tcx.hir().local_def_id_to_hir_id(impl_def_id),\n+            tcx.def_span(impl_def_id),\n+            |err| {\n+                let mut err = err.build(&format!(\n+                    \"cross-crate traits with a default impl, like `{}`, \\\n+                         should not be specialized\",\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+                let item_span = tcx.def_span(self_type_did);\n+                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+                err.span_note(\n+                    item_span,\n+                    &format!(\n+                        \"try using the same sequence of generic parameters as the {} definition\",\n+                        self_descr,\n+                    ),\n+                );\n+                match arg {\n+                    NotUniqueParam::DuplicateParam(arg) => {\n+                        err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n+                    }\n+                    NotUniqueParam::NotParam(arg) => {\n+                        err.note(&format!(\"`{}` is not a generic parameter\", arg));\n+                    }\n+                }\n+                err.emit();\n+            },\n+        );\n+    }\n+}\n+\n+fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty: Ty<'tcx>) -> bool {\n+    struct DisableAutoTraitVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        trait_def_id: DefId,\n+        self_ty_root: Ty<'tcx>,\n+        seen: FxHashSet<DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for DisableAutoTraitVisitor<'tcx> {\n+        type BreakTy = ();\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            let tcx = self.tcx;\n+            if t != self.self_ty_root {\n+                for impl_def_id in tcx.non_blanket_impls_for_ty(self.trait_def_id, t) {\n+                    match tcx.impl_polarity(impl_def_id) {\n+                        ImplPolarity::Negative => return ControlFlow::BREAK,\n+                        ImplPolarity::Reservation => {}\n+                        // FIXME(@lcnr): That's probably not good enough, idk\n+                        //\n+                        // We might just want to take the rustdoc code and somehow avoid\n+                        // explicit impls for `Self`.\n+                        ImplPolarity::Positive => return ControlFlow::CONTINUE,\n+                    }\n+                }\n+            }\n+\n+            match t.kind() {\n+                ty::Adt(def, substs) => {\n+                    // @lcnr: This is the only place where cycles can happen. We avoid this\n+                    // by only visiting each `DefId` once.\n+                    //\n+                    // This will be is incorrect in subtle cases, but I don't care :)\n+                    if self.seen.insert(def.did) {\n+                        for ty in def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                            ty.visit_with(self)?;\n+                        }\n+                    }\n+\n+                    ControlFlow::CONTINUE\n+                }\n+                _ => t.super_visit_with(self),\n+            }\n+        }\n+    }\n+\n+    let self_ty_root = match self_ty.kind() {\n+        ty::Adt(def, _) => tcx.mk_adt(def, InternalSubsts::identity_for_item(tcx, def.did)),\n+        _ => unimplemented!(\"unexpected self ty {:?}\", self_ty),\n+    };\n+\n+    self_ty_root\n+        .visit_with(&mut DisableAutoTraitVisitor {\n+            tcx,\n+            self_ty_root,\n+            trait_def_id,\n+            seen: FxHashSet::default(),\n+        })\n+        .is_break()\n+}"}, {"sha": "1026a35a455acd0a2224208934145eed827cef39", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -0,0 +1,34 @@\n+#![deny(suspicious_auto_trait_impls)]\n+\n+struct MayImplementSendOk<T>(T);\n+unsafe impl<T: Send> Send for MayImplementSendOk<T> {} // ok\n+\n+struct MayImplementSendErr<T>(T);\n+unsafe impl<T: Send> Send for MayImplementSendErr<&T> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+struct ContainsNonSendDirect<T>(*const T);\n+unsafe impl<T: Send> Send for ContainsNonSendDirect<&T> {} // ok\n+\n+struct ContainsPtr<T>(*const T);\n+struct ContainsIndirectNonSend<T>(ContainsPtr<T>);\n+unsafe impl<T: Send> Send for ContainsIndirectNonSend<&T> {} // ok\n+\n+struct ContainsVec<T>(Vec<T>);\n+unsafe impl Send for ContainsVec<i32> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+struct TwoParams<T, U>(T, U);\n+unsafe impl<T: Send, U: Send> Send for TwoParams<T, U> {} // ok\n+\n+struct TwoParamsFlipped<T, U>(T, U);\n+unsafe impl<T: Send, U: Send> Send for TwoParamsFlipped<U, T> {} // ok\n+\n+struct TwoParamsSame<T, U>(T, U);\n+unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+fn main() {}"}, {"sha": "f91aa862271d365eee21687a7c43e5ddc0402015", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -0,0 +1,52 @@\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:7:1\n+   |\n+LL | unsafe impl<T: Send> Send for MayImplementSendErr<&T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/suspicious-impls-lint.rs:1:9\n+   |\n+LL | #![deny(suspicious_auto_trait_impls)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:6:1\n+   |\n+LL | struct MayImplementSendErr<T>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&T` is not a generic parameter\n+\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:19:1\n+   |\n+LL | unsafe impl Send for ContainsVec<i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:18:1\n+   |\n+LL | struct ContainsVec<T>(Vec<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `i32` is not a generic parameter\n+\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:30:1\n+   |\n+LL | unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:29:1\n+   |\n+LL | struct TwoParamsSame<T, U>(T, U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `T` is mentioned multiple times\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "cc75cd4909a234d734a36f7cbbeb0647228fdfc8", "filename": "src/test/ui/typeck/typeck-default-trait-impl-cross-crate-coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -1,4 +1,5 @@\n // aux-build:tdticc_coherence_lib.rs\n+#![allow(suspicious_auto_trait_impls)]\n \n // Test that we do not consider associated types to be sendable without\n // some applicable trait bound (and we don't ICE)."}, {"sha": "cf5c15df7051cee43b705213b501dd19fdea6d8d", "filename": "src/test/ui/typeck/typeck-default-trait-impl-cross-crate-coherence.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ea624699e3311985deec9b150ed02242b86aeb95/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr?ref=ea624699e3311985deec9b150ed02242b86aeb95", "patch": "@@ -1,5 +1,5 @@\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:13:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:14:1\n    |\n LL | impl DefaultedTrait for (A,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^----\n@@ -10,7 +10,7 @@ LL | impl DefaultedTrait for (A,) { }\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:16:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:17:1\n    |\n LL | impl !DefaultedTrait for (B,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n@@ -21,13 +21,13 @@ LL | impl !DefaultedTrait for (B,) { }\n    = note: define and implement a trait or new type instead\n \n error[E0321]: cross-crate traits with a default impl, like `DefaultedTrait`, can only be implemented for a struct/enum type defined in the current crate\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:20:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:21:1\n    |\n LL | impl DefaultedTrait for Box<C> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait for type in another crate\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:21:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:22:1\n    |\n LL | impl DefaultedTrait for lib::Something<C> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^-----------------"}]}