{"sha": "2e185485b34b5ab783d9faa3f17ead6059b6341b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMTg1NDg1YjM0YjVhYjc4M2Q5ZmFhM2YxN2VhZDYwNTliNjM0MWI=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T13:32:58Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-10T13:34:10Z"}, "message": "use the `lvalue_field` function more often to save needless `force_allocation`s", "tree": {"sha": "e28b63bd1977e470f88120c799ad120af98dc5d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e28b63bd1977e470f88120c799ad120af98dc5d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e185485b34b5ab783d9faa3f17ead6059b6341b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlidwVIACgkQpp+NIls6\n19nv8xAApZAbDwOwZ0Xy2OChBxhaAoeN0FMaucomJ+4STaKOcr0iALcOXeCF3fG7\nt4dd0DlZjPCZd8L26l5kV3kIGf5Mh+wFDd1AvThBdggP24/jFLXUd8Iuf0T1Njvh\n53xxWLlm2SjEPtDOk3awqqg1ev07VEaTvGpCOoAHALXHY0rsO7tpguLVjgbK/q6J\nATDFYRhmdy2ebiVjurTIEEsH8bPDDFh+2nJ2vuiPtMRjoQZQJrDEyRhOsXckhZSN\nThhejBmDhP0OLrQD2h9bQKnipiVIR/KBtTpJ4dczbMjGUdi3pBm9TbdlYNQ1b08j\nQcG7hRrCsHcRVsJmH5S6T3cWaEx8gZwLSGoEQEIQuymmHfKT+n5fo2BJSq4qXKet\n7zFepbQFIx8hpsJUFTtIyco8ay07prJRTjZ33C9hlHC65JmS9LktXPAiZi0JJcUA\n9j/ZliMfMWxYM1cnZoXzL5Uv1HA3wI7dOLyBxeVWKZpxZF1Ow8W2Gv51HH1sjj6D\n6vNGk1+h4hy+R+l06R3TWAPk6inhUPu8KekzohXLDrf8vdLHV1g5i6LldXc6Esqd\n4x22k6i6KiSoB/H95loGuvEtwaIpyQUhEosx94K3/Nsvm78DUnqvMWLRcDdPS5RS\nHCKxZEWgzNW+LF5b+fijrAh8giuDpNJCCva6MuN6auiUvDzeyd4=\n=gysl\n-----END PGP SIGNATURE-----", "payload": "tree e28b63bd1977e470f88120c799ad120af98dc5d9\nparent 12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486733578 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1486733650 +0100\n\nuse the `lvalue_field` function more often to save needless `force_allocation`s"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e185485b34b5ab783d9faa3f17ead6059b6341b", "html_url": "https://github.com/rust-lang/rust/commit/2e185485b34b5ab783d9faa3f17ead6059b6341b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e185485b34b5ab783d9faa3f17ead6059b6341b/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "url": "https://api.github.com/repos/rust-lang/rust/commits/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9", "html_url": "https://github.com/rust-lang/rust/commit/12826fb8a3b9f5b296a7cc9a8a30eff781e4f6e9"}], "stats": {"total": 73, "additions": 33, "deletions": 40}, "files": [{"sha": "5ac5ad78b8aaf19087b025741503b27bcecb9e51", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=2e185485b34b5ab783d9faa3f17ead6059b6341b", "patch": "@@ -160,7 +160,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(lvalue)\n     }\n \n-    fn lvalue_field(\n+    pub fn lvalue_field(\n         &mut self,\n         base: Lvalue<'tcx>,\n         field: usize,"}, {"sha": "5c957f0cdc08b7e69b5c7a627ed2844824eeca29", "filename": "src/step.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=2e185485b34b5ab783d9faa3f17ead6059b6341b", "patch": "@@ -14,6 +14,7 @@ use rustc::ty::{subst, self};\n use error::{EvalResult, EvalError};\n use eval_context::{EvalContext, StackPopCleanup, MirRef};\n use lvalue::{Global, GlobalId, Lvalue};\n+use value::{Value, PrimVal};\n use syntax::codemap::Span;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n@@ -89,15 +90,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let dest_layout = self.type_layout(dest_ty)?;\n \n                 match *dest_layout {\n-                    Layout::General { discr, ref variants, .. } => {\n-                        let discr_size = discr.size().bytes();\n-                        let discr_offset = variants[variant_index].offsets[0].bytes();\n+                    Layout::General { discr, .. } => {\n+                        // FIXME: I (oli-obk) think we need to check the\n+                        // `dest_ty` for the variant's discriminant and write\n+                        // instead of the variant index\n+                        // We don't have any tests actually going through these lines\n+                        let discr_ty = discr.to_ty(&self.tcx, false);\n+                        let discr_lval = self.lvalue_field(dest, 0, dest_ty, discr_ty)?;\n \n-                        // FIXME(solson)\n-                        let dest = self.force_allocation(dest)?;\n-                        let discr_dest = (dest.to_ptr()).offset(discr_offset);\n-\n-                        self.memory.write_uint(discr_dest, variant_index as u128, discr_size)?;\n+                        self.write_value(Value::ByVal(PrimVal::Bytes(variant_index as u128)), discr_lval, discr_ty)?;\n                     }\n \n                     Layout::RawNullablePointer { nndiscr, .. } => {"}, {"sha": "13c851244bfadcf37e58c1156c130d2661e9862b", "filename": "src/terminator/drop.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e185485b34b5ab783d9faa3f17ead6059b6341b/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=2e185485b34b5ab783d9faa3f17ead6059b6341b", "patch": "@@ -93,7 +93,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             ty::TyAdt(adt_def, substs) => {\n                 // FIXME: some structs are represented as ByValPair\n-                let lval = self.force_allocation(lval)?;\n+                let mut lval = self.force_allocation(lval)?;\n                 let adt_ptr = match lval {\n                     Lvalue::Ptr { ptr, .. } => ptr,\n                     _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n@@ -104,22 +104,26 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 }\n                 let layout = self.type_layout(ty)?;\n                 let fields = match *layout {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n-                    },\n-                    Layout::General { ref variants, .. } => {\n+                    Layout::Univariant { .. } => &adt_def.struct_variant().fields,\n+                    Layout::General { .. } => {\n                         let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n+                        let ptr = self.force_allocation(lval)?.to_ptr();\n                         match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n-                            // start at offset 1, to skip over the discriminant\n-                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n+                            Some(i) => {\n+                                lval = Lvalue::Ptr {\n+                                    ptr,\n+                                    extra: LvalueExtra::DowncastVariant(i),\n+                                };\n+                                &adt_def.variants[i].fields\n+                            },\n                             None => return Err(EvalError::InvalidDiscriminant),\n                         }\n                     },\n-                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                    Layout::StructWrappedNullablePointer { nndiscr, .. } => {\n                         let discr = self.read_discriminant_value(adt_ptr, ty)?;\n                         if discr == nndiscr as u128 {\n                             assert_eq!(discr as usize as u128, discr);\n-                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n+                            &adt_def.variants[discr as usize].fields\n                         } else {\n                             // FIXME: the zst variant might contain zst types that impl Drop\n                             return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n@@ -146,18 +150,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 let tcx = self.tcx;\n                 self.drop_fields(\n-                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    fields.iter().map(|field| monomorphize_field_ty(tcx, field, substs)),\n                     lval,\n+                    ty,\n                     drop,\n                 )?;\n             },\n-            ty::TyTuple(fields, _) => {\n-                let offsets = match *self.type_layout(ty)? {\n-                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n-                    _ => bug!(\"tuples must be univariant\"),\n-                };\n-                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n-            },\n+            ty::TyTuple(fields, _) => self.drop_fields(fields.into_iter().cloned(), lval, ty, drop)?,\n             ty::TyDynamic(..) => {\n                 let (ptr, vtable) = match lval {\n                     Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n@@ -208,25 +207,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     fn drop_fields<I>(\n         &mut self,\n-        mut fields: I,\n+        fields: I,\n         lval: Lvalue<'tcx>,\n+        ty: Ty<'tcx>,\n         drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n     ) -> EvalResult<'tcx>\n-        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n+        where I: Iterator<Item=Ty<'tcx>>,\n     {\n-        // FIXME: some aggregates may be represented by Value::ByValPair\n-        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n-        // manual iteration, because we need to be careful about the last field if it is unsized\n-        while let Some((field_ty, offset)) = fields.next() {\n-            let ptr = adt_ptr.offset(offset.bytes());\n-            if self.type_is_sized(field_ty) {\n-                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n-            } else {\n-                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n-                break; // if it is not sized, then this is the last field anyway\n-            }\n+        trace!(\"drop_fields: {:?} of type {}\", lval, ty);\n+        for (i, field_ty) in fields.enumerate() {\n+            let field_lval = self.lvalue_field(lval, i, ty, field_ty)?;\n+            self.drop(field_lval, field_ty, drop)?;\n         }\n-        assert!(fields.next().is_none());\n         Ok(())\n     }\n "}]}