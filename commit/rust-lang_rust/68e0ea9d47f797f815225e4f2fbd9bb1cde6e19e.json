{"sha": "68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4ZTBlYTlkNDdmNzk3ZjgxNTIyNWU0ZjJmYmQ5YmIxY2RlNmUxOWU=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2018-03-23T08:30:23Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2018-03-23T08:30:23Z"}, "message": "Introduce unsafe offset_from on pointers\n\nAdds intrinsics::exact_div to take advantage of the unsafe, which reduces the implementation from\n```asm\n    sub rcx, rdx\n    mov rax, rcx\n    sar rax, 63\n    shr rax, 62\n    lea rax, [rax + rcx]\n    sar rax, 2\n    ret\n```\ndown to\n```asm\n    sub rcx, rdx\n    sar rcx, 2\n    mov rax, rcx\n    ret\n```\n(for `*const i32`)", "tree": {"sha": "31e5c47c48d12df28fa1efc437457d71549ea3a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31e5c47c48d12df28fa1efc437457d71549ea3a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "html_url": "https://github.com/rust-lang/rust/commit/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52f7e8836cc2e6c0edfaf402ee40ca724a8c0989", "url": "https://api.github.com/repos/rust-lang/rust/commits/52f7e8836cc2e6c0edfaf402ee40ca724a8c0989", "html_url": "https://github.com/rust-lang/rust/commit/52f7e8836cc2e6c0edfaf402ee40ca724a8c0989"}], "stats": {"total": 239, "additions": 237, "deletions": 2}, "files": [{"sha": "3b740adc46832d06e0c21c5429d5527542c62a04", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -1314,6 +1314,11 @@ extern \"rust-intrinsic\" {\n     /// [`std::u32::overflowing_mul`](../../std/primitive.u32.html#method.overflowing_mul)\n     pub fn mul_with_overflow<T>(x: T, y: T) -> (T, bool);\n \n+    /// Performs an exact division, resulting in undefined behavior where\n+    /// `x % y != 0` or `y == 0` or `x == T::min_value() && y == -1`\n+    #[cfg(not(stage0))]\n+    pub fn exact_div<T>(x: T, y: T) -> T;\n+\n     /// Performs an unchecked division, resulting in undefined behavior\n     /// where y = 0 or x = `T::min_value()` and y = -1\n     pub fn unchecked_div<T>(x: T, y: T) -> T;\n@@ -1396,3 +1401,8 @@ extern \"rust-intrinsic\" {\n     /// Probably will never become stable.\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n }\n+\n+#[cfg(stage0)]\n+pub unsafe fn exact_div<T>(a: T, b: T) -> T {\n+    unchecked_div(a, b)\n+}"}, {"sha": "cbd45bb6a39e191d2a5f91177057a7837b4175c1", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -700,6 +700,114 @@ impl<T: ?Sized> *const T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T` and `T` must not be a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, other: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        // FIXME: can this be nuw/nsw?\n+        let d = isize::wrapping_sub(self as _, other as _);\n+        intrinsics::exact_div(d, pointee_size as _)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *const i32 = &a[1];\n+    /// let ptr2: *const i32 = &a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *const i32 = 3 as _;\n+    /// let ptr2: *const i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, other: *const T) -> isize where T: Sized {\n+        let pointee_size = mem::size_of::<T>();\n+        assert!(0 < pointee_size && pointee_size <= isize::max_value() as usize);\n+\n+        let d = isize::wrapping_sub(self as _, other as _);\n+        d.wrapping_div(pointee_size as _)\n+    }\n+\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g. a `count` of 3 represents a pointer\n@@ -1347,6 +1455,105 @@ impl<T: ?Sized> *mut T {\n         }\n     }\n \n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// This function is the inverse of [`offset`].\n+    ///\n+    /// [`offset`]: #method.offset-1\n+    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n+    ///\n+    /// # Safety\n+    ///\n+    /// If any of the following conditions are violated, the result is Undefined\n+    /// Behavior:\n+    ///\n+    /// * Both the starting and other pointer must be either in bounds or one\n+    ///   byte past the end of the same allocated object.\n+    ///\n+    /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n+    ///\n+    /// * The distance between the pointers, in bytes, must be an exact multiple\n+    ///   of the size of `T` and `T` must not be a Zero-Sized Type (\"ZST\").\n+    ///\n+    /// * The distance being in bounds cannot rely on \"wrapping around\" the address space.\n+    ///\n+    /// The compiler and standard library generally try to ensure allocations\n+    /// never reach a size where an offset is a concern. For instance, `Vec`\n+    /// and `Box` ensure they never allocate more than `isize::MAX` bytes, so\n+    /// `ptr_into_vec.offset_from(vec.as_ptr())` is always safe.\n+    ///\n+    /// Most platforms fundamentally can't even construct such an allocation.\n+    /// For instance, no known 64-bit platform can ever serve a request\n+    /// for 2<sup>63</sup> bytes due to page-table limitations or splitting the address space.\n+    /// However, some 32-bit and 16-bit platforms may successfully serve a request for\n+    /// more than `isize::MAX` bytes with things like Physical Address\n+    /// Extension. As such, memory acquired directly from allocators or memory\n+    /// mapped files *may* be too large to handle with this function.\n+    ///\n+    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n+    /// difficult to satisfy. The only advantage of this method is that it\n+    /// enables more aggressive compiler optimizations.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// unsafe {\n+    ///     assert_eq!(ptr2.offset_from(ptr1), 2);\n+    ///     assert_eq!(ptr1.offset_from(ptr2), -2);\n+    ///     assert_eq!(ptr1.offset(2), ptr2);\n+    ///     assert_eq!(ptr2.offset(-2), ptr1);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub unsafe fn offset_from(self, other: *const T) -> isize where T: Sized {\n+        (self as *const T).offset_from(other)\n+    }\n+\n+    /// Calculates the distance between two pointers. The returned value is in\n+    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n+    ///\n+    /// If the address different between the two pointers is not a multiple of\n+    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n+    /// zero.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function panics if `T` is a zero-sized typed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(ptr_wrapping_offset_from)]\n+    ///\n+    /// let a = [0; 5];\n+    /// let ptr1: *mut i32 = &mut a[1];\n+    /// let ptr2: *mut i32 = &mut a[3];\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n+    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n+    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n+    ///\n+    /// let ptr1: *mut i32 = 3 as _;\n+    /// let ptr2: *mut i32 = 13 as _;\n+    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n+    /// ```\n+    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n+    #[inline]\n+    pub fn wrapping_offset_from(self, other: *const T) -> isize where T: Sized {\n+        (self as *const T).wrapping_offset_from(other)\n+    }\n+\n     /// Computes the byte offset that needs to be applied in order to\n     /// make the pointer aligned to `align`.\n     /// If it is not possible to align the pointer, the implementation returns"}, {"sha": "403fe4731f118877156e7167d7dea727f913f7ea", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -935,6 +935,11 @@ extern \"C\" {\n                          RHS: ValueRef,\n                          Name: *const c_char)\n                          -> ValueRef;\n+    pub fn LLVMBuildExactUDiv(B: BuilderRef,\n+                              LHS: ValueRef,\n+                              RHS: ValueRef,\n+                              Name: *const c_char)\n+                              -> ValueRef;\n     pub fn LLVMBuildSDiv(B: BuilderRef,\n                          LHS: ValueRef,\n                          RHS: ValueRef,"}, {"sha": "5e2d32b359698a171c5f33fa82e37f741bab9227", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -344,6 +344,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n+    pub fn exactudiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n+        self.count_insn(\"exactudiv\");\n+        unsafe {\n+            llvm::LLVMBuildExactUDiv(self.llbuilder, lhs, rhs, noname())\n+        }\n+    }\n+\n     pub fn sdiv(&self, lhs: ValueRef, rhs: ValueRef) -> ValueRef {\n         self.count_insn(\"sdiv\");\n         unsafe {"}, {"sha": "ca5b48be4d5466822bdce3b3c65444a3cb215a77", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -289,7 +289,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n         \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"ctpop\" | \"bswap\" |\n         \"bitreverse\" | \"add_with_overflow\" | \"sub_with_overflow\" |\n         \"mul_with_overflow\" | \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n-        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" => {\n+        \"unchecked_div\" | \"unchecked_rem\" | \"unchecked_shl\" | \"unchecked_shr\" | \"exact_div\" => {\n             let ty = arg_tys[0];\n             match int_type_width_signed(ty, cx) {\n                 Some((width, signed)) =>\n@@ -343,6 +343,12 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bx: &Builder<'a, 'tcx>,\n                         \"overflowing_add\" => bx.add(args[0].immediate(), args[1].immediate()),\n                         \"overflowing_sub\" => bx.sub(args[0].immediate(), args[1].immediate()),\n                         \"overflowing_mul\" => bx.mul(args[0].immediate(), args[1].immediate()),\n+                        \"exact_div\" =>\n+                            if signed {\n+                                bx.exactsdiv(args[0].immediate(), args[1].immediate())\n+                            } else {\n+                                bx.exactudiv(args[0].immediate(), args[1].immediate())\n+                            },\n                         \"unchecked_div\" =>\n                             if signed {\n                                 bx.sdiv(args[0].immediate(), args[1].immediate())"}, {"sha": "a4e9967daa6e15d4a50f2a87590b85f5bc0924ec", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=68e0ea9d47f797f815225e4f2fbd9bb1cde6e19e", "patch": "@@ -283,7 +283,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 (1, vec![param(0), param(0)],\n                 tcx.intern_tup(&[param(0), tcx.types.bool])),\n \n-            \"unchecked_div\" | \"unchecked_rem\" =>\n+            \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" =>\n                 (1, vec![param(0), param(0)], param(0)),\n             \"unchecked_shl\" | \"unchecked_shr\" =>\n                 (1, vec![param(0), param(0)], param(0)),"}]}