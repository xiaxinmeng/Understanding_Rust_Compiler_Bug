{"sha": "128a1fa4e1f85e04f522653bb9bee83ed6523440", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGExZmE0ZTFmODVlMDRmNTIyNjUzYmI5YmVlODNlZDY1MjM0NDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T10:18:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-12-06T10:18:17Z"}, "message": "Auto merge of #55635 - oli-obk:min_const_unsafe_fn, r=nikomatsakis\n\nAllow calling `const unsafe fn` in `const fn` behind a feature gate\n\ncc #55607\n\nr? @Centril", "tree": {"sha": "cf1bb66e041bed563653ac45ea58bfa863d7518a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf1bb66e041bed563653ac45ea58bfa863d7518a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128a1fa4e1f85e04f522653bb9bee83ed6523440", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128a1fa4e1f85e04f522653bb9bee83ed6523440", "html_url": "https://github.com/rust-lang/rust/commit/128a1fa4e1f85e04f522653bb9bee83ed6523440", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128a1fa4e1f85e04f522653bb9bee83ed6523440/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77a6a61f066af3dd693d8527a8a1bf5a446d295c", "url": "https://api.github.com/repos/rust-lang/rust/commits/77a6a61f066af3dd693d8527a8a1bf5a446d295c", "html_url": "https://github.com/rust-lang/rust/commit/77a6a61f066af3dd693d8527a8a1bf5a446d295c"}, {"sha": "cb71752f911c47426e208a9f5f1862d4c0e56aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb71752f911c47426e208a9f5f1862d4c0e56aa4", "html_url": "https://github.com/rust-lang/rust/commit/cb71752f911c47426e208a9f5f1862d4c0e56aa4"}], "stats": {"total": 1005, "additions": 868, "deletions": 137}, "files": [{"sha": "23f07773f3f3431186d62c1d5a1eac4c04c77624", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -596,7 +596,7 @@ mod impls {\n /// This affects, for example, whether a `static` of that type is\n /// placed in read-only static memory or writable static memory.\n #[lang = \"freeze\"]\n-unsafe auto trait Freeze {}\n+pub(crate) unsafe auto trait Freeze {}\n \n impl<T: ?Sized> !Freeze for UnsafeCell<T> {}\n unsafe impl<T: ?Sized> Freeze for PhantomData<T> {}"}, {"sha": "a89c6ca60cbea434f1eb023d4b525db292f215dc", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -11,14 +11,23 @@\n //! Exposes the NonZero lang item which provides optimization hints.\n \n use ops::{CoerceUnsized, DispatchFromDyn};\n+use marker::Freeze;\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n #[rustc_layout_scalar_valid_range_start(1)]\n-#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+#[derive(Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n-pub(crate) struct NonZero<T>(pub(crate) T);\n+pub(crate) struct NonZero<T: Freeze>(pub(crate) T);\n \n-impl<T: CoerceUnsized<U>, U> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+// Do not call `T::clone` as theoretically it could turn the field into `0`\n+// invalidating `NonZero`'s invariant.\n+impl<T: Copy + Freeze> Clone for NonZero<T> {\n+    fn clone(&self) -> Self {\n+        unsafe { NonZero(self.0) }\n+    }\n+}\n \n-impl<T: DispatchFromDyn<U>, U> DispatchFromDyn<NonZero<U>> for NonZero<T> {}\n+impl<T: CoerceUnsized<U> + Freeze, U: Freeze> CoerceUnsized<NonZero<U>> for NonZero<T> {}\n+\n+impl<T: DispatchFromDyn<U> + Freeze, U: Freeze> DispatchFromDyn<NonZero<U>> for NonZero<T> {}"}, {"sha": "7f5d596b220b9e99fdf604d86467a7d28c51f351", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -70,15 +70,15 @@ assert_eq!(size_of::<Option<std::num::\", stringify!($Ty), \">>(), size_of::<\", st\n                 #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n                 #[inline]\n                 pub const unsafe fn new_unchecked(n: $Int) -> Self {\n-                    $Ty(NonZero(n))\n+                    $Ty(unsafe { NonZero(n) })\n                 }\n \n                 /// Create a non-zero if the given value is not zero.\n                 #[stable(feature = \"nonzero\", since = \"1.28.0\")]\n                 #[inline]\n                 pub fn new(n: $Int) -> Option<Self> {\n                     if n != 0 {\n-                        Some($Ty(NonZero(n)))\n+                        Some($Ty(unsafe { NonZero(n) }))\n                     } else {\n                         None\n                     }"}, {"sha": "0387708033b535ca1251395d97d69a578fc9f2ee", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -2759,7 +2759,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Creates a new `Unique` if `ptr` is non-null.\n     pub fn new(ptr: *mut T) -> Option<Self> {\n         if !ptr.is_null() {\n-            Some(Unique { pointer: NonZero(ptr as _), _marker: PhantomData })\n+            Some(Unique { pointer: unsafe { NonZero(ptr as _) }, _marker: PhantomData })\n         } else {\n             None\n         }\n@@ -2815,14 +2815,14 @@ impl<T: ?Sized> fmt::Pointer for Unique<T> {\n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a mut T> for Unique<T> {\n     fn from(reference: &'a mut T) -> Self {\n-        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n+        Unique { pointer: unsafe { NonZero(reference as _) }, _marker: PhantomData }\n     }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]\n impl<'a, T: ?Sized> From<&'a T> for Unique<T> {\n     fn from(reference: &'a T) -> Self {\n-        Unique { pointer: NonZero(reference as _), _marker: PhantomData }\n+        Unique { pointer: unsafe { NonZero(reference as _) }, _marker: PhantomData }\n     }\n }\n \n@@ -2895,15 +2895,15 @@ impl<T: ?Sized> NonNull<T> {\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n-        NonNull { pointer: NonZero(ptr as _) }\n+        NonNull { pointer: unsafe { NonZero(ptr as _) } }\n     }\n \n     /// Creates a new `NonNull` if `ptr` is non-null.\n     #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n     #[inline]\n     pub fn new(ptr: *mut T) -> Option<Self> {\n         if !ptr.is_null() {\n-            Some(NonNull { pointer: NonZero(ptr as _) })\n+            Some(unsafe { Self::new_unchecked(ptr) })\n         } else {\n             None\n         }\n@@ -3025,14 +3025,14 @@ impl<T: ?Sized> From<Unique<T>> for NonNull<T> {\n impl<'a, T: ?Sized> From<&'a mut T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &'a mut T) -> Self {\n-        NonNull { pointer: NonZero(reference as _) }\n+        NonNull { pointer: unsafe { NonZero(reference as _) } }\n     }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n impl<'a, T: ?Sized> From<&'a T> for NonNull<T> {\n     #[inline]\n     fn from(reference: &'a T) -> Self {\n-        NonNull { pointer: NonZero(reference as _) }\n+        NonNull { pointer: unsafe { NonZero(reference as _) } }\n     }\n }"}, {"sha": "c72887124aa0b4ab7b11619d032fa9b5507841a9", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -46,7 +46,8 @@ impl_stable_hash_for!(enum mir::BorrowKind {\n \n impl_stable_hash_for!(enum mir::UnsafetyViolationKind {\n     General,\n-    MinConstFn,\n+    GeneralAndConstFn,\n+    GatedConstFnCall,\n     ExternStatic(lint_node_id),\n     BorrowPacked(lint_node_id),\n });"}, {"sha": "91663557409f238dbaec035a2fe26590a3d58231", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -25,7 +25,7 @@ use rustc_data_structures::graph::{self, GraphPredecessors, GraphSuccessors};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::Lrc;\n use rustc_data_structures::sync::MappedReadGuard;\n-use rustc_serialize as serialize;\n+use rustc_serialize::{self as serialize};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Formatter, Write};\n@@ -2778,8 +2778,11 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// unsafety is not allowed at all in min const fn\n-    MinConstFn,\n+    /// Right now function calls to `const unsafe fn` are only permitted behind a feature gate\n+    /// Also, even `const unsafe fn` need an `unsafe` block to do the allowed operations.\n+    GatedConstFnCall,\n+    /// Permitted in const fn and regular fns\n+    GeneralAndConstFn,\n     ExternStatic(ast::NodeId),\n     BorrowPacked(ast::NodeId),\n }"}, {"sha": "bc06167399533cb2055ba69de2e51ebb05b13d3a", "filename": "src/librustc/ty/constness.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -5,7 +5,6 @@ use ty::TyCtxt;\n use syntax_pos::symbol::Symbol;\n use hir::map::blocks::FnLikeNode;\n use syntax::attr;\n-use rustc_target::spec::abi;\n \n impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n     /// Whether the `def_id` counts as const fn in your current crate, considering all active\n@@ -40,19 +39,12 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n     /// Returns true if this function must conform to `min_const_fn`\n     pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n+        // Bail out if the signature doesn't contain `const`\n+        if !self.is_const_fn_raw(def_id) {\n+            return false;\n+        }\n+\n         if self.features().staged_api {\n-            // some intrinsics are waved through if called inside the\n-            // standard library. Users never need to call them directly\n-            if let abi::Abi::RustIntrinsic = self.fn_sig(def_id).abi() {\n-                assert!(!self.is_const_fn(def_id));\n-                match &self.item_name(def_id).as_str()[..] {\n-                    | \"size_of\"\n-                    | \"min_align_of\"\n-                    | \"needs_drop\"\n-                    => return true,\n-                    _ => {},\n-                }\n-            }\n             // in order for a libstd function to be considered min_const_fn\n             // it needs to be stable and have no `rustc_const_unstable` attribute\n             match self.lookup_stability(def_id) {"}, {"sha": "6522dbe117994d75ead05ff1a07a25e6c683672c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -98,12 +98,18 @@ macro_rules! newtype_index {\n      @max          [$max:expr]\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]) => (\n-        #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, $($derives),*)]\n+        #[derive(Copy, PartialEq, Eq, Hash, PartialOrd, Ord, $($derives),*)]\n         #[rustc_layout_scalar_valid_range_end($max)]\n         $v struct $type {\n             private: u32\n         }\n \n+        impl Clone for $type {\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n+\n         impl $type {\n             $v const MAX_AS_U32: u32 = $max;\n \n@@ -145,7 +151,7 @@ macro_rules! newtype_index {\n \n             #[inline]\n             $v const unsafe fn from_u32_unchecked(value: u32) -> Self {\n-                $type { private: value }\n+                unsafe { $type { private: value } }\n             }\n \n             /// Extract value of this index as an integer.\n@@ -328,12 +334,13 @@ macro_rules! newtype_index {\n                    derive [$($derives:ident,)+]\n                    $($tokens:tt)*) => (\n         newtype_index!(\n-            @derives      [$($derives,)+ RustcDecodable, RustcEncodable,]\n+            @derives      [$($derives,)+ RustcEncodable,]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n+        newtype_index!(@decodable $type);\n     );\n \n     // The case where no derives are added, but encodable is overridden. Don't\n@@ -360,12 +367,29 @@ macro_rules! newtype_index {\n      @debug_format [$debug_format:tt]\n                    $($tokens:tt)*) => (\n         newtype_index!(\n-            @derives      [RustcDecodable, RustcEncodable,]\n+            @derives      [RustcEncodable,]\n             @type         [$type]\n             @max          [$max]\n             @vis          [$v]\n             @debug_format [$debug_format]\n                           $($tokens)*);\n+        newtype_index!(@decodable $type);\n+    );\n+\n+    (@decodable $type:ident) => (\n+        impl $type {\n+            fn __decodable__impl__hack() {\n+                mod __more_hacks_because__self_doesnt_work_in_functions {\n+                    extern crate serialize;\n+                    use self::serialize::{Decodable, Decoder};\n+                    impl Decodable for super::$type {\n+                        fn decode<D: Decoder>(d: &mut D) -> Result<Self, D::Error> {\n+                            d.read_u32().map(Self::from)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     );\n \n     // Rewrite final without comma to one that includes comma"}, {"sha": "90a204ce00d5384394c4fd668a81c3a4a871a3bb", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -91,8 +91,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n             // types/lifetimes replaced)\n             let fn_hir_id = tcx.hir.node_to_hir_id(id);\n             let fn_sig = cx.tables().liberated_fn_sigs()[fn_hir_id].clone();\n+            let fn_def_id = tcx.hir.local_def_id(id);\n \n-            let ty = tcx.type_of(tcx.hir.local_def_id(id));\n+            let ty = tcx.type_of(fn_def_id);\n             let mut abi = fn_sig.abi;\n             let implicit_argument = match ty.sty {\n                 ty::Closure(..) => {\n@@ -108,9 +109,15 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                 _ => None,\n             };\n \n-            // FIXME: safety in closures\n             let safety = match fn_sig.unsafety {\n                 hir::Unsafety::Normal => Safety::Safe,\n+                hir::Unsafety::Unsafe if tcx.is_min_const_fn(fn_def_id) => {\n+                    // As specified in #55607, a `const unsafe fn` differs\n+                    // from an `unsafe fn` in that its body is still considered\n+                    // safe code by default.\n+                    assert!(implicit_argument.is_none());\n+                    Safety::Safe\n+                },\n                 hir::Unsafety::Unsafe => Safety::FnUnsafe,\n             };\n "}, {"sha": "75f8045cfae99cad514b4b294527ce4dbcd136fc", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 201, "deletions": 54, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -23,6 +23,9 @@ use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext};\n \n use syntax::ast;\n use syntax::symbol::Symbol;\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n+\n+use std::ops::Bound;\n \n use util;\n \n@@ -34,6 +37,7 @@ pub struct UnsafetyChecker<'a, 'tcx: 'a> {\n     source_info: SourceInfo,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n+    /// mark an `unsafe` block as used, so we don't lint it\n     used_unsafe: FxHashSet<ast::NodeId>,\n     inherited_blocks: Vec<(ast::NodeId, bool)>,\n }\n@@ -93,7 +97,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if let hir::Unsafety::Unsafe = sig.unsafety() {\n                     self.require_unsafe(\"call to unsafe function\",\n                         \"consult the function's documentation for information on how to avoid \\\n-                         undefined behavior\")\n+                         undefined behavior\", UnsafetyViolationKind::GatedConstFnCall)\n                 }\n             }\n         }\n@@ -121,7 +125,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n \n             StatementKind::InlineAsm { .. } => {\n                 self.require_unsafe(\"use of inline assembly\",\n-                    \"inline assembly is entirely unchecked and can cause undefined behavior\")\n+                    \"inline assembly is entirely unchecked and can cause undefined behavior\",\n+                    UnsafetyViolationKind::General)\n             },\n         }\n         self.super_statement(block, statement, location);\n@@ -134,8 +139,18 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n         if let &Rvalue::Aggregate(box ref aggregate, _) = rvalue {\n             match aggregate {\n                 &AggregateKind::Array(..) |\n-                &AggregateKind::Tuple |\n-                &AggregateKind::Adt(..) => {}\n+                &AggregateKind::Tuple => {}\n+                &AggregateKind::Adt(ref def, ..) => {\n+                    match self.tcx.layout_scalar_valid_range(def.did) {\n+                        (Bound::Unbounded, Bound::Unbounded) => {},\n+                        _ => self.require_unsafe(\n+                            \"initializing type with `rustc_layout_scalar_valid_range` attr\",\n+                            \"initializing a layout restricted type's field with a value outside \\\n+                            the valid range is undefined behavior\",\n+                            UnsafetyViolationKind::GeneralAndConstFn,\n+                        ),\n+                    }\n+                }\n                 &AggregateKind::Closure(def_id, _) |\n                 &AggregateKind::Generator(def_id, _, _) => {\n                     let UnsafetyCheckResult {\n@@ -152,28 +167,43 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     place: &Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if context.is_borrow() {\n-            if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n-                let source_info = self.source_info;\n-                let lint_root =\n-                    self.source_scope_local_data[source_info.scope].lint_root;\n-                self.register_violations(&[UnsafetyViolation {\n-                    source_info,\n-                    description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n-                    details:\n-                        Symbol::intern(\"fields of packed structs might be misaligned: \\\n-                                        dereferencing a misaligned pointer or even just creating a \\\n-                                        misaligned reference is undefined behavior\")\n-                            .as_interned_str(),\n-                    kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n-                }], &[]);\n-            }\n-        }\n-\n         match place {\n             &Place::Projection(box Projection {\n                 ref base, ref elem\n             }) => {\n+                if context.is_borrow() {\n+                    if util::is_disaligned(self.tcx, self.mir, self.param_env, place) {\n+                        let source_info = self.source_info;\n+                        let lint_root =\n+                            self.source_scope_local_data[source_info.scope].lint_root;\n+                        self.register_violations(&[UnsafetyViolation {\n+                            source_info,\n+                            description: Symbol::intern(\"borrow of packed field\").as_interned_str(),\n+                            details:\n+                                Symbol::intern(\"fields of packed structs might be misaligned: \\\n+                                                dereferencing a misaligned pointer or even just \\\n+                                                creating a misaligned reference is undefined \\\n+                                                behavior\")\n+                                    .as_interned_str(),\n+                            kind: UnsafetyViolationKind::BorrowPacked(lint_root)\n+                        }], &[]);\n+                    }\n+                }\n+                let is_borrow_of_interior_mut = context.is_borrow() && !base\n+                    .ty(self.mir, self.tcx)\n+                    .to_ty(self.tcx)\n+                    .is_freeze(self.tcx, self.param_env, self.source_info.span);\n+                // prevent\n+                // * `&mut x.field`\n+                // * `x.field = y;`\n+                // * `&x.field` if `field`'s type has interior mutability\n+                // because either of these would allow modifying the layout constrained field and\n+                // insert values that violate the layout constraints.\n+                if context.is_mutating_use() || is_borrow_of_interior_mut {\n+                    self.check_mut_borrowing_layout_constrained_field(\n+                        place, context.is_mutating_use(),\n+                    );\n+                }\n                 let old_source_info = self.source_info;\n                 if let &Place::Local(local) = base {\n                     if self.mir.local_decls[local].internal {\n@@ -189,7 +219,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         self.require_unsafe(\"dereference of raw pointer\",\n                             \"raw pointers may be NULL, dangling or unaligned; they can violate \\\n                              aliasing rules and cause data races: all of these are undefined \\\n-                             behavior\")\n+                             behavior\", UnsafetyViolationKind::General)\n                     }\n                     ty::Adt(adt, _) => {\n                         if adt.is_union() {\n@@ -212,14 +242,15 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                                         \"assignment to non-`Copy` union field\",\n                                         \"the previous content of the field will be dropped, which \\\n                                          causes undefined behavior if the field was not properly \\\n-                                         initialized\")\n+                                         initialized\", UnsafetyViolationKind::General)\n                                 } else {\n                                     // write to non-move union, safe\n                                 }\n                             } else {\n                                 self.require_unsafe(\"access to union field\",\n                                     \"the field may not be properly initialized: using \\\n-                                     uninitialized data will cause undefined behavior\")\n+                                     uninitialized data will cause undefined behavior\",\n+                                     UnsafetyViolationKind::General)\n                             }\n                         }\n                     }\n@@ -237,7 +268,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing violations \\\n-                         or data races will cause undefined behavior\");\n+                         or data races will cause undefined behavior\",\n+                         UnsafetyViolationKind::General);\n                 } else if self.tcx.is_foreign_item(def_id) {\n                     let source_info = self.source_info;\n                     let lint_root =\n@@ -260,52 +292,150 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n-    fn require_unsafe(&mut self,\n-                      description: &'static str,\n-                      details: &'static str)\n-    {\n+    fn require_unsafe(\n+        &mut self,\n+        description: &'static str,\n+        details: &'static str,\n+        kind: UnsafetyViolationKind,\n+    ) {\n         let source_info = self.source_info;\n         self.register_violations(&[UnsafetyViolation {\n             source_info,\n             description: Symbol::intern(description).as_interned_str(),\n             details: Symbol::intern(details).as_interned_str(),\n-            kind: UnsafetyViolationKind::General,\n+            kind,\n         }], &[]);\n     }\n \n     fn register_violations(&mut self,\n                            violations: &[UnsafetyViolation],\n                            unsafe_blocks: &[(ast::NodeId, bool)]) {\n-        if self.min_const_fn {\n-            for violation in violations {\n-                let mut violation = violation.clone();\n-                violation.kind = UnsafetyViolationKind::MinConstFn;\n-                if !self.violations.contains(&violation) {\n-                    self.violations.push(violation)\n-                }\n-            }\n-        }\n-        let within_unsafe = match self.source_scope_local_data[self.source_info.scope].safety {\n-            Safety::Safe => {\n+        let safety = self.source_scope_local_data[self.source_info.scope].safety;\n+        let within_unsafe = match (safety, self.min_const_fn) {\n+            // Erring on the safe side, pun intended\n+            (Safety::BuiltinUnsafe, true) |\n+            // mir building encodes const fn bodies as safe, even for `const unsafe fn`\n+            (Safety::FnUnsafe, true) => bug!(\"const unsafe fn body treated as inherently unsafe\"),\n+            // `unsafe` blocks are required in safe code\n+            (Safety::Safe, _) => {\n                 for violation in violations {\n-                    if !self.violations.contains(violation) {\n-                        self.violations.push(violation.clone())\n+                    let mut violation = violation.clone();\n+                    match violation.kind {\n+                        UnsafetyViolationKind::GeneralAndConstFn |\n+                        UnsafetyViolationKind::General => {},\n+                        UnsafetyViolationKind::BorrowPacked(_) |\n+                        UnsafetyViolationKind::ExternStatic(_) => if self.min_const_fn {\n+                            // const fns don't need to be backwards compatible and can\n+                            // emit these violations as a hard error instead of a backwards\n+                            // compat lint\n+                            violation.kind = UnsafetyViolationKind::General;\n+                        },\n+                        UnsafetyViolationKind::GatedConstFnCall => {\n+                            // safe code can't call unsafe const fns, this `UnsafetyViolationKind`\n+                            // is only relevant for `Safety::ExplicitUnsafe` in `unsafe const fn`s\n+                            violation.kind = UnsafetyViolationKind::General;\n+                        }\n+                    }\n+                    if !self.violations.contains(&violation) {\n+                        self.violations.push(violation)\n                     }\n                 }\n                 false\n             }\n-            Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n-            Safety::ExplicitUnsafe(node_id) => {\n+            // regular `unsafe` function bodies allow unsafe without additional unsafe blocks\n+            (Safety::BuiltinUnsafe, false) | (Safety::FnUnsafe, false) => true,\n+            (Safety::ExplicitUnsafe(node_id), _) => {\n+                // mark unsafe block as used if there are any unsafe operations inside\n                 if !violations.is_empty() {\n                     self.used_unsafe.insert(node_id);\n                 }\n+                // only some unsafety is allowed in const fn\n+                if self.min_const_fn {\n+                    let min_const_unsafe_fn = self.tcx.features().min_const_unsafe_fn;\n+                    for violation in violations {\n+                        match violation.kind {\n+                            UnsafetyViolationKind::GatedConstFnCall if min_const_unsafe_fn => {\n+                                // these function calls to unsafe functions are allowed\n+                                // if `#![feature(min_const_unsafe_fn)]` is active\n+                            },\n+                            UnsafetyViolationKind::GatedConstFnCall => {\n+                                // without the feature gate, we report errors\n+                                if !self.violations.contains(&violation) {\n+                                    self.violations.push(violation.clone())\n+                                }\n+                            }\n+                            // these unsafe things are stable in const fn\n+                            UnsafetyViolationKind::GeneralAndConstFn => {},\n+                            // these things are forbidden in const fns\n+                            UnsafetyViolationKind::General |\n+                            UnsafetyViolationKind::BorrowPacked(_) |\n+                            UnsafetyViolationKind::ExternStatic(_) => {\n+                                let mut violation = violation.clone();\n+                                // const fns don't need to be backwards compatible and can\n+                                // emit these violations as a hard error instead of a backwards\n+                                // compat lint\n+                                violation.kind = UnsafetyViolationKind::General;\n+                                if !self.violations.contains(&violation) {\n+                                    self.violations.push(violation)\n+                                }\n+                            },\n+                        }\n+                    }\n+                }\n                 true\n             }\n         };\n         self.inherited_blocks.extend(unsafe_blocks.iter().map(|&(node_id, is_used)| {\n             (node_id, is_used && !within_unsafe)\n         }));\n     }\n+    fn check_mut_borrowing_layout_constrained_field(\n+        &mut self,\n+        mut place: &Place<'tcx>,\n+        is_mut_use: bool,\n+    ) {\n+        while let &Place::Projection(box Projection {\n+            ref base, ref elem\n+        }) = place {\n+            match *elem {\n+                ProjectionElem::Field(..) => {\n+                    let ty = base.ty(&self.mir.local_decls, self.tcx).to_ty(self.tcx);\n+                    match ty.sty {\n+                        ty::Adt(def, _) => match self.tcx.layout_scalar_valid_range(def.did) {\n+                            (Bound::Unbounded, Bound::Unbounded) => {},\n+                            _ => {\n+                                let (description, details) = if is_mut_use {\n+                                    (\n+                                        \"mutation of layout constrained field\",\n+                                        \"mutating layout constrained fields cannot statically be \\\n+                                        checked for valid values\",\n+                                    )\n+                                } else {\n+                                    (\n+                                        \"borrow of layout constrained field with interior \\\n+                                        mutability\",\n+                                        \"references to fields of layout constrained fields \\\n+                                        lose the constraints. Coupled with interior mutability, \\\n+                                        the field can be changed to invalid values\",\n+                                    )\n+                                };\n+                                let source_info = self.source_info;\n+                                self.register_violations(&[UnsafetyViolation {\n+                                    source_info,\n+                                    description: Symbol::intern(description).as_interned_str(),\n+                                    details: Symbol::intern(details).as_interned_str(),\n+                                    kind: UnsafetyViolationKind::GeneralAndConstFn,\n+                                }], &[]);\n+                            }\n+                        },\n+                        _ => {}\n+                    }\n+                }\n+                _ => {}\n+            }\n+            place = base;\n+        }\n+    }\n }\n \n pub(crate) fn provide(providers: &mut Providers) {\n@@ -384,7 +514,7 @@ fn unsafety_check_result<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n \n     let param_env = tcx.param_env(def_id);\n     let mut checker = UnsafetyChecker::new(\n-        tcx.is_const_fn(def_id) && tcx.is_min_const_fn(def_id),\n+        tcx.is_min_const_fn(def_id),\n         mir, source_scope_local_data, tcx, param_env);\n     checker.visit_mir(mir);\n \n@@ -486,6 +616,22 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     } in violations.iter() {\n         // Report an error.\n         match kind {\n+            UnsafetyViolationKind::General if tcx.is_min_const_fn(def_id) => {\n+                let mut err = tcx.sess.struct_span_err(\n+                    source_info.span,\n+                    &format!(\"{} is unsafe and unsafe operations \\\n+                            are not allowed in const fn\", description));\n+                err.span_label(source_info.span, &description.as_str()[..])\n+                    .note(&details.as_str()[..]);\n+                if tcx.fn_sig(def_id).unsafety() == hir::Unsafety::Unsafe {\n+                    err.note(\n+                        \"unsafe action within a `const unsafe fn` still require an `unsafe` \\\n+                        block in contrast to regular `unsafe fn`.\"\n+                    );\n+                }\n+                err.emit();\n+            }\n+            UnsafetyViolationKind::GeneralAndConstFn |\n             UnsafetyViolationKind::General => {\n                 struct_span_err!(\n                     tcx.sess, source_info.span, E0133,\n@@ -494,14 +640,15 @@ pub fn check_unsafety<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n                     .note(&details.as_str()[..])\n                     .emit();\n             }\n-            UnsafetyViolationKind::MinConstFn => {\n-                tcx.sess.struct_span_err(\n+            UnsafetyViolationKind::GatedConstFnCall => {\n+                emit_feature_err(\n+                    &tcx.sess.parse_sess,\n+                    \"min_const_unsafe_fn\",\n                     source_info.span,\n-                    &format!(\"{} is unsafe and unsafe operations \\\n-                            are not allowed in const fn\", description))\n-                    .span_label(source_info.span, &description.as_str()[..])\n-                    .note(&details.as_str()[..])\n-                    .emit();\n+                    GateIssue::Language,\n+                    \"calls to `const unsafe fn` in const fns are unstable\",\n+                );\n+\n             }\n             UnsafetyViolationKind::ExternStatic(lint_node_id) => {\n                 tcx.lint_node_note(SAFE_EXTERN_STATICS,"}, {"sha": "3c1b9dbd91fa80e60548fbe54ab1ddc9012659a5", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -2,6 +2,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::mir::*;\n use rustc::ty::{self, Predicate, TyCtxt};\n+use rustc_target::spec::abi;\n use std::borrow::Cow;\n use syntax_pos::Span;\n \n@@ -338,19 +339,40 @@ fn check_terminator(\n         } => {\n             let fn_ty = func.ty(mir, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.sty {\n-                if tcx.is_min_const_fn(def_id) {\n-                    check_operand(tcx, mir, func, span)?;\n \n-                    for arg in args {\n-                        check_operand(tcx, mir, arg, span)?;\n-                    }\n-                    Ok(())\n-                } else {\n-                    Err((\n+                // some intrinsics are waved through if called inside the\n+                // standard library. Users never need to call them directly\n+                match tcx.fn_sig(def_id).abi() {\n+                    abi::Abi::RustIntrinsic => match &tcx.item_name(def_id).as_str()[..] {\n+                        | \"size_of\"\n+                        | \"min_align_of\"\n+                        | \"needs_drop\"\n+                        => {},\n+                        _ => return Err((\n+                            span,\n+                            \"can only call a curated list of intrinsics in `min_const_fn`\".into(),\n+                        )),\n+                    },\n+                    abi::Abi::Rust if tcx.is_min_const_fn(def_id) => {},\n+                    abi::Abi::Rust => return Err((\n                         span,\n                         \"can only call other `min_const_fn` within a `min_const_fn`\".into(),\n-                    ))\n+                    )),\n+                    abi => return Err((\n+                        span,\n+                        format!(\n+                            \"cannot call functions with `{}` abi in `min_const_fn`\",\n+                            abi,\n+                        ).into(),\n+                    )),\n+                }\n+\n+                check_operand(tcx, mir, func, span)?;\n+\n+                for arg in args {\n+                    check_operand(tcx, mir, arg, span)?;\n                 }\n+                Ok(())\n             } else {\n                 Err((span, \"can only call other const fns within const fn\".into()))\n             }"}, {"sha": "bfdc75378d5e1dfeb57381801b671af7930f22d8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -492,6 +492,9 @@ declare_features! (\n \n     // `extern crate self as foo;` puts local crate root into extern prelude under name `foo`.\n     (active, extern_crate_self, \"1.31.0\", Some(56409), None),\n+\n+    // Allows calling `const unsafe fn` inside `unsafe` blocks in `const fn` functions.\n+    (active, min_const_unsafe_fn, \"1.31.0\", Some(55607), None),\n );\n \n declare_features! ("}, {"sha": "0fd7ccd55fb2dd76a765e7953519050178ad708e", "filename": "src/test/run-pass-fulldeps/newtype_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -1,4 +1,4 @@\n-#![feature(rustc_attrs, rustc_private, step_trait)]\n+#![feature(rustc_attrs, rustc_private, step_trait, min_const_unsafe_fn)]\n \n #[macro_use] extern crate rustc_data_structures;\n extern crate rustc_serialize;"}, {"sha": "43ca9e75393095255de640fd75327cae146ab6c1", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -78,9 +78,9 @@ const fn i32_ops2(c: i32, d: i32) -> bool { c < d }\n const fn i32_ops3(c: i32, d: i32) -> bool { c != d }\n const fn i32_ops4(c: i32, d: i32) -> i32 { c + d }\n const fn char_cast(u: u8) -> char { u as char }\n-const unsafe fn foo4() -> i32 { 42 }\n-const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n-const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n+const unsafe fn ret_i32_no_unsafe() -> i32 { 42 }\n+const unsafe fn ret_null_ptr_no_unsafe<T>() -> *const T { 0 as *const T }\n+const unsafe fn ret_null_mut_ptr_no_unsafe<T>() -> *mut T { 0 as *mut T }\n \n // not ok\n const fn foo11<T: std::fmt::Display>(t: T) -> T { t }"}, {"sha": "f11b43dcd865ce54e407a2c7a5f537acebcdc818", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -8,23 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// gate-test-min_const_unsafe_fn\n+\n // ok\n-const unsafe fn foo4() -> i32 { 42 }\n-const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n-const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n+const unsafe fn ret_i32_no_unsafe() -> i32 { 42 }\n+const unsafe fn ret_null_ptr_no_unsafe<T>() -> *const T { 0 as *const T }\n+const unsafe fn ret_null_mut_ptr_no_unsafe<T>() -> *mut T { 0 as *mut T }\n const fn no_unsafe() { unsafe {} }\n \n // not ok\n-const fn foo8() -> i32 {\n-    unsafe { foo4() } //~ ERROR unsafe operations are not allowed in const fn\n+const fn call_unsafe_const_fn() -> i32 {\n+    unsafe { ret_i32_no_unsafe() } //~ ERROR calls to `const unsafe fn` in const fns are unstable\n }\n-const fn foo9() -> *const String {\n-    unsafe { foo5::<String>() } //~ ERROR unsafe operations are not allowed in const fn\n+const fn call_unsafe_generic_const_fn() -> *const String {\n+    unsafe { ret_null_ptr_no_unsafe::<String>() }\n+    //~^ ERROR calls to `const unsafe fn` in const fns are unstable\n }\n-const fn foo10() -> *const Vec<std::cell::Cell<u32>> {\n-    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() } //~ ERROR not allowed in const fn\n+const fn call_unsafe_generic_cell_const_fn() -> *const Vec<std::cell::Cell<u32>> {\n+    unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n+    //~^ ERROR calls to `const unsafe fn` in const fns\n }\n-const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n //~^ dereferencing raw pointers in constant functions\n \n fn main() {}"}, {"sha": "922a7883b9f2d3b4e933c2a8ae9efdedbd910d7b", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe.stderr", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -1,58 +1,60 @@\n error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n-  --> $DIR/min_const_fn_unsafe.rs:27:51\n+  --> $DIR/min_const_fn_unsafe.rs:31:59\n    |\n-LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n-   |                                                   ^^\n+LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                           ^^\n    |\n    = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n \n error[E0658]: unions in const fn are unstable (see issue #51909)\n-  --> $DIR/min_const_fn_unsafe.rs:34:5\n+  --> $DIR/min_const_fn_unsafe.rs:38:5\n    |\n LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n    |     ^^^^^^^^^^^^^^^\n    |\n    = help: add #![feature(const_fn_union)] to the crate attributes to enable\n \n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:19:14\n+error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n+  --> $DIR/min_const_fn_unsafe.rs:21:14\n    |\n-LL |     unsafe { foo4() } //~ ERROR unsafe operations are not allowed in const fn\n-   |              ^^^^^^ call to unsafe function\n+LL |     unsafe { ret_i32_no_unsafe() } //~ ERROR calls to `const unsafe fn` in const fns are unstable\n+   |              ^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n \n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:22:14\n+error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n+  --> $DIR/min_const_fn_unsafe.rs:24:14\n    |\n-LL |     unsafe { foo5::<String>() } //~ ERROR unsafe operations are not allowed in const fn\n-   |              ^^^^^^^^^^^^^^^^ call to unsafe function\n+LL |     unsafe { ret_null_ptr_no_unsafe::<String>() }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n \n-error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:25:14\n+error[E0658]: calls to `const unsafe fn` in const fns are unstable (see issue #55607)\n+  --> $DIR/min_const_fn_unsafe.rs:28:14\n    |\n-LL |     unsafe { foo6::<Vec<std::cell::Cell<u32>>>() } //~ ERROR not allowed in const fn\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+LL |     unsafe { ret_null_mut_ptr_no_unsafe::<Vec<std::cell::Cell<u32>>>() }\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = help: add #![feature(min_const_unsafe_fn)] to the crate attributes to enable\n \n error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:27:51\n+  --> $DIR/min_const_fn_unsafe.rs:31:59\n    |\n-LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n-   |                                                   ^^ dereference of raw pointer\n+LL | const unsafe fn deref_forbidden(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                           ^^ dereference of raw pointer\n    |\n    = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n \n error: access to union field is unsafe and unsafe operations are not allowed in const fn\n-  --> $DIR/min_const_fn_unsafe.rs:34:5\n+  --> $DIR/min_const_fn_unsafe.rs:38:5\n    |\n LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n    |     ^^^^^^^^^^^^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n \n error: aborting due to 7 previous errors\n "}, {"sha": "8a6884bc6b93c3207e5c09b4ff2cc942834c5cdb", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(min_const_unsafe_fn)]\n+\n+// ok\n+const unsafe fn foo4() -> i32 { 42 }\n+const unsafe fn foo5<T>() -> *const T { 0 as *const T }\n+const unsafe fn foo6<T>() -> *mut T { 0 as *mut T }\n+const fn no_unsafe() { unsafe {} }\n+\n+const fn foo8() -> i32 {\n+    unsafe { foo4() }\n+}\n+const fn foo9() -> *const String {\n+    unsafe { foo5::<String>() }\n+}\n+const fn foo10() -> *const Vec<std::cell::Cell<u32>> {\n+    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() }\n+}\n+const unsafe fn foo8_3() -> i32 {\n+    unsafe { foo4() }\n+}\n+const unsafe fn foo9_3() -> *const String {\n+    unsafe { foo5::<String>() }\n+}\n+const unsafe fn foo10_3() -> *const Vec<std::cell::Cell<u32>> {\n+    unsafe { foo6::<Vec<std::cell::Cell<u32>>>() }\n+}\n+// not ok\n+const unsafe fn foo8_2() -> i32 {\n+    foo4() //~ ERROR not allowed in const fn\n+}\n+const unsafe fn foo9_2() -> *const String {\n+    foo5::<String>() //~ ERROR not allowed in const fn\n+}\n+const unsafe fn foo10_2() -> *const Vec<std::cell::Cell<u32>> {\n+    foo6::<Vec<std::cell::Cell<u32>>>() //~ ERROR not allowed in const fn\n+}\n+const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+//~^ dereferencing raw pointers in constant functions\n+\n+const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n+//~^ dereferencing raw pointers in constant functions\n+\n+const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+//~^ dereferencing raw pointers in constant functions\n+\n+fn main() {}\n+\n+const unsafe fn no_union() {\n+    union Foo { x: (), y: () }\n+    Foo { x: () }.y //~ ERROR not allowed in const fn\n+    //~^ unions in const fn\n+}"}, {"sha": "20c75afbe638b81478c0cb9dfb3ab6b00e9fd363", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_unsafe_feature_gate.stderr", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_unsafe_feature_gate.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,97 @@\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:47:51\n+   |\n+LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                   ^^\n+   |\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n+\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:50:60\n+   |\n+LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n+   |                                                            ^^^\n+   |\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n+\n+error[E0658]: dereferencing raw pointers in constant functions is unstable (see issue #51911)\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:53:62\n+   |\n+LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+   |                                                              ^^^\n+   |\n+   = help: add #![feature(const_raw_ptr_deref)] to the crate attributes to enable\n+\n+error[E0658]: unions in const fn are unstable (see issue #51909)\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:60:5\n+   |\n+LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(const_fn_union)] to the crate attributes to enable\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:39:5\n+   |\n+LL |     foo4() //~ ERROR not allowed in const fn\n+   |     ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:42:5\n+   |\n+LL |     foo5::<String>() //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: call to unsafe function is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:45:5\n+   |\n+LL |     foo6::<Vec<std::cell::Cell<u32>>>() //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:47:51\n+   |\n+LL | const unsafe fn foo30_3(x: *mut usize) -> usize { *x } //~ ERROR not allowed in const fn\n+   |                                                   ^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:50:60\n+   |\n+LL | const unsafe fn foo30_4(x: *mut usize) -> &'static usize { &*x } //~ ERROR not allowed in const fn\n+   |                                                            ^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: dereference of raw pointer is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:53:62\n+   |\n+LL | const fn foo30_5(x: *mut usize) -> &'static usize { unsafe { &*x } } //~ ERROR not allowed\n+   |                                                              ^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: access to union field is unsafe and unsafe operations are not allowed in const fn\n+  --> $DIR/min_const_fn_unsafe_feature_gate.rs:60:5\n+   |\n+LL |     Foo { x: () }.y //~ ERROR not allowed in const fn\n+   |     ^^^^^^^^^^^^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+   = note: unsafe action within a `const unsafe fn` still require an `unsafe` block in contrast to regular `unsafe fn`.\n+\n+error: aborting due to 11 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "f559c23ff0f541c10479b6fc0cd4b943c1dff94f", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"humans\",\n+            reason = \"who ever let humans program computers,\n+            we're apparently really bad at it\",\n+            issue = \"0\")]\n+\n+#![feature(rustc_const_unstable, const_fn, foo, foo2)]\n+#![feature(min_const_unsafe_fn)]\n+#![feature(staged_api)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature=\"foo\")]\n+const unsafe fn foo() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `min_const_fn`\n+\n+#[unstable(feature = \"rust1\", issue=\"0\")]\n+const unsafe fn foo2() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `min_const_fn`\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// conformity is required, even with `const_fn` feature gate\n+const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` op\n+\n+// check whether this function cannot be called even with the feature gate active\n+#[unstable(feature = \"foo2\", issue=\"0\")]\n+const unsafe fn foo2_gated() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } } //~ ERROR can only call other\n+\n+fn main() {}"}, {"sha": "37be2889173f851d620821a50d86b1c18e919327", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,26 @@\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:26:41\n+   |\n+LL | const unsafe fn bar() -> u32 { unsafe { foo() } } //~ ERROR can only call other `min_const_fn`\n+   |                                         ^^^^^\n+\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:33:42\n+   |\n+LL | const unsafe fn bar2() -> u32 { unsafe { foo2() } } //~ ERROR can only call other `min_const_fn`\n+   |                                          ^^^^^^\n+\n+error: only int, `bool` and `char` operations are stable in const fn\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:37:33\n+   |\n+LL | const unsafe fn bar3() -> u32 { (5f32 + 6f32) as u32 } //~ ERROR only int, `bool` and `char` op\n+   |                                 ^^^^^^^^^^^^^\n+\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability.rs:45:48\n+   |\n+LL | const unsafe fn bar2_gated() -> u32 { unsafe { foo2_gated() } } //~ ERROR can only call other\n+   |                                                ^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "131bc97c85a2a23bc34aa1ef5acb769653b1a28e", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"humans\",\n+            reason = \"who ever let humans program computers,\n+            we're apparently really bad at it\",\n+            issue = \"0\")]\n+\n+#![feature(rustc_const_unstable, const_fn, foo, foo2)]\n+#![feature(min_const_unsafe_fn)]\n+#![feature(staged_api)]\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_const_unstable(feature=\"foo\")]\n+const fn foo() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+\n+#[unstable(feature = \"rust1\", issue=\"0\")]\n+const fn foo2() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+\n+// check whether this function cannot be called even with the feature gate active\n+#[unstable(feature = \"foo2\", issue=\"0\")]\n+const fn foo2_gated() -> u32 { 42 }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+// can't call non-min_const_fn\n+const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n+\n+fn main() {}"}, {"sha": "0b58dc1294be0f7aa4b07a5c95ad8b648eaa0b52", "filename": "src/test/ui/consts/min_const_fn/min_const_unsafe_fn_libstd_stability2.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_unsafe_fn_libstd_stability2.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,20 @@\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:26:32\n+   |\n+LL | const unsafe fn bar() -> u32 { foo() } //~ ERROR can only call other `min_const_fn`\n+   |                                ^^^^^\n+\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:33:33\n+   |\n+LL | const unsafe fn bar2() -> u32 { foo2() } //~ ERROR can only call other `min_const_fn`\n+   |                                 ^^^^^^\n+\n+error: can only call other `min_const_fn` within a `min_const_fn`\n+  --> $DIR/min_const_unsafe_fn_libstd_stability2.rs:41:39\n+   |\n+LL | const unsafe fn bar2_gated() -> u32 { foo2_gated() } //~ ERROR can only call other `min_const_fn`\n+   |                                       ^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "0fa2da917e9f8e0c2a02a3f4caa140b46b4b1533", "filename": "src/test/ui/unsafe/ranged_ints.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,8 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {\n+    let _x = NonZero(0); //~ ERROR initializing type with `rustc_layout_scalar_valid_range` attr\n+}"}, {"sha": "f59a930b5a901682a08adcda20e43a7bf3ea094d", "filename": "src/test/ui/unsafe/ranged_ints.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints.rs:7:14\n+   |\n+LL |     let _x = NonZero(0); //~ ERROR initializing type with `rustc_layout_scalar_valid_range` attr\n+   |              ^^^^^^^^^^ initializing type with `rustc_layout_scalar_valid_range` attr\n+   |\n+   = note: initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "68ba120b279c02a80bdde064cea4bd3fe7f581ba", "filename": "src/test/ui/unsafe/ranged_ints2.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,9 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {\n+    let mut x = unsafe { NonZero(1) };\n+    let y = &mut x.0; //~ ERROR mutation of layout constrained field is unsafe\n+}"}, {"sha": "ae63f47ed74a7b6bb2f2d0922eb43636bd5f23ae", "filename": "src/test/ui/unsafe/ranged_ints2.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints2.rs:8:13\n+   |\n+LL |     let y = &mut x.0; //~ ERROR mutation of layout constrained field is unsafe\n+   |             ^^^^^^^^ mutation of layout constrained field\n+   |\n+   = note: mutating layout constrained fields cannot statically be checked for valid values\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "a61e3329bdce8b9dd899aedca44e80e914c63959", "filename": "src/test/ui/unsafe/ranged_ints2_const.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,20 @@\n+#![feature(rustc_attrs, const_let, const_fn)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {\n+}\n+\n+const fn foo() -> NonZero<u32> {\n+    let mut x = unsafe { NonZero(1) };\n+    let y = &mut x.0; //~ ERROR references in constant functions may only refer to immutable\n+    //~^ ERROR mutation of layout constrained field is unsafe\n+    unsafe { NonZero(1) }\n+}\n+\n+const fn bar() -> NonZero<u32> {\n+    let mut x = unsafe { NonZero(1) };\n+    let y = unsafe { &mut x.0 }; //~ ERROR references in constant functions may only refer to immut\n+    unsafe { NonZero(1) }\n+}"}, {"sha": "f79792ffba9bec63c9a2e1960920a6ef8aa16da6", "filename": "src/test/ui/unsafe/ranged_ints2_const.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,24 @@\n+error[E0017]: references in constant functions may only refer to immutable values\n+  --> $DIR/ranged_ints2_const.rs:11:13\n+   |\n+LL |     let y = &mut x.0; //~ ERROR references in constant functions may only refer to immutable\n+   |             ^^^^^^^^ constant functions require immutable values\n+\n+error[E0017]: references in constant functions may only refer to immutable values\n+  --> $DIR/ranged_ints2_const.rs:18:22\n+   |\n+LL |     let y = unsafe { &mut x.0 }; //~ ERROR references in constant functions may only refer to immut\n+   |                      ^^^^^^^^ constant functions require immutable values\n+\n+error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints2_const.rs:11:13\n+   |\n+LL |     let y = &mut x.0; //~ ERROR references in constant functions may only refer to immutable\n+   |             ^^^^^^^^ mutation of layout constrained field\n+   |\n+   = note: mutating layout constrained fields cannot statically be checked for valid values\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0017, E0133.\n+For more information about an error, try `rustc --explain E0017`."}, {"sha": "47d67fac6785c651f030b15970cc7d16caea7dd4", "filename": "src/test/ui/unsafe/ranged_ints3.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+#![feature(rustc_attrs)]\n+\n+use std::cell::Cell;\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {\n+    let mut x = unsafe { NonZero(Cell::new(1)) };\n+    let y = &x.0; //~ ERROR borrow of layout constrained field with interior mutability\n+}"}, {"sha": "311a058fdb07f81e8f7e8447fd705428b7d1bdf4", "filename": "src/test/ui/unsafe/ranged_ints3.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints3.rs:10:13\n+   |\n+LL |     let y = &x.0; //~ ERROR borrow of layout constrained field with interior mutability\n+   |             ^^^^ borrow of layout constrained field with interior mutability\n+   |\n+   = note: references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "6497b611224b6a77b3d17cd7acf41427f68dce90", "filename": "src/test/ui/unsafe/ranged_ints3_const.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,21 @@\n+#![feature(rustc_attrs, const_let, const_fn)]\n+\n+use std::cell::Cell;\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {}\n+\n+const fn foo() -> NonZero<Cell<u32>> {\n+    let mut x = unsafe { NonZero(Cell::new(1)) };\n+    let y = &x.0; //~ ERROR cannot borrow a constant which may contain interior mutability\n+    //~^ ERROR borrow of layout constrained field with interior mutability\n+    unsafe { NonZero(Cell::new(1)) }\n+}\n+\n+const fn bar() -> NonZero<Cell<u32>> {\n+    let mut x = unsafe { NonZero(Cell::new(1)) };\n+    let y = unsafe { &x.0 }; //~ ERROR cannot borrow a constant which may contain interior mut\n+    unsafe { NonZero(Cell::new(1)) }\n+}"}, {"sha": "d83d75787d948f34ad669173b81da1a9b5fb1c0d", "filename": "src/test/ui/unsafe/ranged_ints3_const.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints3_const.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,24 @@\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/ranged_ints3_const.rs:12:13\n+   |\n+LL |     let y = &x.0; //~ ERROR cannot borrow a constant which may contain interior mutability\n+   |             ^^^^\n+\n+error[E0492]: cannot borrow a constant which may contain interior mutability, create a static instead\n+  --> $DIR/ranged_ints3_const.rs:19:22\n+   |\n+LL |     let y = unsafe { &x.0 }; //~ ERROR cannot borrow a constant which may contain interior mut\n+   |                      ^^^^\n+\n+error[E0133]: borrow of layout constrained field with interior mutability is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints3_const.rs:12:13\n+   |\n+LL |     let y = &x.0; //~ ERROR cannot borrow a constant which may contain interior mutability\n+   |             ^^^^ borrow of layout constrained field with interior mutability\n+   |\n+   = note: references to fields of layout constrained fields lose the constraints. Coupled with interior mutability, the field can be changed to invalid values\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors occurred: E0133, E0492.\n+For more information about an error, try `rustc --explain E0133`."}, {"sha": "d8632c48434f25f1653ea41aeec4c889b2739e65", "filename": "src/test/ui/unsafe/ranged_ints4.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,9 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {\n+    let mut x = unsafe { NonZero(1) };\n+    x.0 = 0; //~ ERROR mutation of layout constrained field is unsafe\n+}"}, {"sha": "c6468b643b41a8473270353fd29b2c9bb6f0a582", "filename": "src/test/ui/unsafe/ranged_ints4.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints4.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints4.rs:8:5\n+   |\n+LL |     x.0 = 0; //~ ERROR mutation of layout constrained field is unsafe\n+   |     ^^^^^^^ mutation of layout constrained field\n+   |\n+   = note: mutating layout constrained fields cannot statically be checked for valid values\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "f589e4739baf17145f7d3e09d0e1e68e086a95fb", "filename": "src/test/ui/unsafe/ranged_ints4_const.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,19 @@\n+#![feature(rustc_attrs, const_let, const_fn)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {}\n+\n+const fn foo() -> NonZero<u32> {\n+    let mut x = unsafe { NonZero(1) };\n+    x.0 = 0;\n+    //~^ ERROR mutation of layout constrained field is unsafe\n+    x\n+}\n+\n+const fn bar() -> NonZero<u32> {\n+    let mut x = unsafe { NonZero(1) };\n+    unsafe { x.0 = 0 }; // this is UB\n+    x\n+}"}, {"sha": "fe83b15ce5cec456b434aee6cf703a5c4ae52eeb", "filename": "src/test/ui/unsafe/ranged_ints4_const.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints4_const.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints4_const.rs:10:5\n+   |\n+LL |     x.0 = 0;\n+   |     ^^^^^^^ mutation of layout constrained field\n+   |\n+   = note: mutating layout constrained fields cannot statically be checked for valid values\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}, {"sha": "8477772867e91d503a48750632775cf82310f78e", "filename": "src/test/ui/unsafe/ranged_ints_const.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.rs?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+#![feature(rustc_attrs)]\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+#[repr(transparent)]\n+pub(crate) struct NonZero<T>(pub(crate) T);\n+fn main() {}\n+\n+const fn foo() -> NonZero<u32> { NonZero(0) }\n+//~^ ERROR initializing type with `rustc_layout_scalar_valid_range` attr is unsafe\n+\n+const fn bar() -> NonZero<u32> { unsafe { NonZero(0) } }"}, {"sha": "584ad40a92bb08b6064540b6e7734ce9ca81f874", "filename": "src/test/ui/unsafe/ranged_ints_const.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/128a1fa4e1f85e04f522653bb9bee83ed6523440/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints_const.stderr?ref=128a1fa4e1f85e04f522653bb9bee83ed6523440", "patch": "@@ -0,0 +1,11 @@\n+error[E0133]: initializing type with `rustc_layout_scalar_valid_range` attr is unsafe and requires unsafe function or block\n+  --> $DIR/ranged_ints_const.rs:8:34\n+   |\n+LL | const fn foo() -> NonZero<u32> { NonZero(0) }\n+   |                                  ^^^^^^^^^^ initializing type with `rustc_layout_scalar_valid_range` attr\n+   |\n+   = note: initializing a layout restricted type's field with a value outside the valid range is undefined behavior\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0133`."}]}