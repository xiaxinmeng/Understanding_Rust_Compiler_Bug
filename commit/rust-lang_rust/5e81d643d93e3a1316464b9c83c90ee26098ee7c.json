{"sha": "5e81d643d93e3a1316464b9c83c90ee26098ee7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlODFkNjQzZDkzZTNhMTMxNjQ2NGI5YzgzYzkwZWUyNjA5OGVlN2M=", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-04-27T04:15:41Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-25T21:49:28Z"}, "message": "don't generate partially-undef consts", "tree": {"sha": "24ed175dcaed6dc61516f5101def21a3ade9ecd0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ed175dcaed6dc61516f5101def21a3ade9ecd0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e81d643d93e3a1316464b9c83c90ee26098ee7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e81d643d93e3a1316464b9c83c90ee26098ee7c", "html_url": "https://github.com/rust-lang/rust/commit/5e81d643d93e3a1316464b9c83c90ee26098ee7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e81d643d93e3a1316464b9c83c90ee26098ee7c/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738", "html_url": "https://github.com/rust-lang/rust/commit/4d635fdf63f1ba3480c30a6ea1e6f3e49a39b738"}], "stats": {"total": 80, "additions": 56, "deletions": 24}, "files": [{"sha": "3ece1659b9e07733c437e4729b957ade3c96bf03", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -36,11 +36,6 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n         alloc: &'a Allocation,\n         range: Range<usize>,\n     ) {\n-        /// Allocations larger than this will only be codegen'd as entirely initialized or entirely undef.\n-        /// This avoids compile time regressions when an alloc would have many chunks,\n-        /// e.g. for `[(u64, u8); N]`, which has undef padding in each element.\n-        const MAX_PARTIALLY_UNDEF_SIZE: usize = 1024;\n-\n         let mut chunks = alloc\n             .init_mask()\n             .range_as_init_chunks(Size::from_bytes(range.start), Size::from_bytes(range.end));\n@@ -57,21 +52,30 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx<'ll, '_>, alloc: &Allocation) -> &'ll\n             }\n         };\n \n-        if range.len() > MAX_PARTIALLY_UNDEF_SIZE {\n+        // Generating partially-uninit consts inhibits optimizations, so it is disabled by default.\n+        // See https://github.com/rust-lang/rust/issues/84565.\n+        let allow_partially_uninit =\n+            match cx.sess().opts.debugging_opts.partially_uninit_const_threshold {\n+                Some(max) => range.len() <= max,\n+                None => false,\n+            };\n+\n+        if allow_partially_uninit {\n+            llvals.extend(chunks.map(chunk_to_llval));\n+        } else {\n             let llval = match (chunks.next(), chunks.next()) {\n                 (Some(chunk), None) => {\n                     // exactly one chunk, either fully init or fully uninit\n                     chunk_to_llval(chunk)\n                 }\n                 _ => {\n-                    // partially uninit\n+                    // partially uninit, codegen as if it was initialized\n+                    // (using some arbitrary value for uninit bytes)\n                     let bytes = alloc.inspect_with_uninit_and_ptr_outside_interpreter(range);\n                     cx.const_bytes(bytes)\n                 }\n             };\n             llvals.push(llval);\n-        } else {\n-            llvals.extend(chunks.map(chunk_to_llval));\n         }\n     }\n "}, {"sha": "afab919bc3c2cff582ac90614c5f6d3a7bc9fc51", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -743,6 +743,7 @@ fn test_debugging_options_tracking_hash() {\n     tracked!(no_profiler_runtime, true);\n     tracked!(osx_rpath_install_name, true);\n     tracked!(panic_abort_tests, true);\n+    tracked!(partially_uninit_const_threshold, Some(123));\n     tracked!(plt, Some(true));\n     tracked!(polonius, true);\n     tracked!(precise_enum_drop_elaboration, false);"}, {"sha": "9a1be40558ccb3ca03796f97f6381065301b455e", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -1186,6 +1186,9 @@ options! {\n         \"support compiling tests with panic=abort (default: no)\"),\n     parse_only: bool = (false, parse_bool, [UNTRACKED],\n         \"parse only; do not compile, assemble, or link (default: no)\"),\n+    partially_uninit_const_threshold: Option<usize> = (None, parse_opt_number, [TRACKED],\n+        \"allow generating const initializers with mixed init/uninit bytes, \\\n+        and set the maximum total size of a const allocation for which this is allowed (default: never)\"),\n     perf_stats: bool = (false, parse_bool, [UNTRACKED],\n         \"print some performance-related statistics (default: no)\"),\n     plt: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "7f945299c22a6c9bb77fb8b39f9c797071da59d4", "filename": "src/test/codegen/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fconsts.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -43,14 +43,14 @@ pub fn inline_enum_const() -> E<i8, i16> {\n #[no_mangle]\n pub fn low_align_const() -> E<i16, [i16; 3]> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 2 %1, i8* align 2 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 2 %1, i8* align 2 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }\n \n // CHECK-LABEL: @high_align_const\n #[no_mangle]\n pub fn high_align_const() -> E<i16, i32> {\n     // Check that low_align_const and high_align_const use the same constant\n-    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [4 x i8] }>, <{ [4 x i8], [4 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n+    // CHECK: memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [8 x i8] }>, <{ [8 x i8] }>* [[LOW_HIGH]], i32 0, i32 0, i32 0), i{{(32|64)}} 8, i1 false)\n     *&E::A(0)\n }"}, {"sha": "f7420e4126ed0999d40a263f300bdb93e0d940cb", "filename": "src/test/codegen/uninit-consts-allow-partially-uninit.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Funinit-consts-allow-partially-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Funinit-consts-allow-partially-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funinit-consts-allow-partially-uninit.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -C no-prepopulate-passes -Z partially_uninit_const_threshold=1024\n+\n+// Like uninit-consts.rs, but tests that we correctly generate partially-uninit consts\n+// when the (disabled by default) partially_uninit_const_threshold flag is used.\n+\n+#![crate_type = \"lib\"]\n+\n+use std::mem::MaybeUninit;\n+\n+pub struct PartiallyUninit {\n+    x: u32,\n+    y: MaybeUninit<[u8; 10]>\n+}\n+\n+// This should be partially undef.\n+// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [4 x i8], [12 x i8] }> <{ [4 x i8] c\"\\EF\\BE\\AD\\DE\", [12 x i8] undef }>, align 4\n+\n+// This shouldn't contain undef, since it's larger than the 1024 byte limit.\n+// CHECK: [[UNINIT_PADDING_HUGE:@[0-9]+]] = private unnamed_addr constant <{ [32768 x i8] }> <{ [32768 x i8] c\"{{.+}}\" }>, align 4\n+\n+// CHECK-LABEL: @partially_uninit\n+#[no_mangle]\n+pub const fn partially_uninit() -> PartiallyUninit {\n+    const X: PartiallyUninit = PartiallyUninit { x: 0xdeadbeef, y: MaybeUninit::uninit() };\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [12 x i8] }>, <{ [4 x i8], [12 x i8] }>* [[PARTIALLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 16, i1 false)\n+    X\n+}\n+\n+// CHECK-LABEL: @uninit_padding_huge\n+#[no_mangle]\n+pub const fn uninit_padding_huge() -> [(u32, u8); 4096] {\n+    const X: [(u32, u8); 4096] = [(123, 45); 4096];\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [32768 x i8] }>, <{ [32768 x i8] }>* [[UNINIT_PADDING_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 32768, i1 false)\n+    X\n+}"}, {"sha": "c4c21e03f16767e2aa93538cbb70a4f161f958b9", "filename": "src/test/codegen/uninit-consts.rs", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e81d643d93e3a1316464b9c83c90ee26098ee7c/src%2Ftest%2Fcodegen%2Funinit-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funinit-consts.rs?ref=5e81d643d93e3a1316464b9c83c90ee26098ee7c", "patch": "@@ -12,12 +12,9 @@ pub struct PartiallyUninit {\n }\n \n // CHECK: [[FULLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [10 x i8] }> undef\n-// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [4 x i8], [12 x i8] }> <{ [4 x i8] c\"\\EF\\BE\\AD\\DE\", [12 x i8] undef }>, align 4\n+// CHECK: [[PARTIALLY_UNINIT:@[0-9]+]] = private unnamed_addr constant <{ [16 x i8] }> <{ [16 x i8] c\"\\EF\\BE\\AD\\DE\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\\00\" }>, align 4\n // CHECK: [[FULLY_UNINIT_HUGE:@[0-9]+]] = private unnamed_addr constant <{ [16384 x i8] }> undef\n \n-// This shouldn't contain undef, since generating huge partially undef constants is expensive.\n-// CHECK: [[UNINIT_PADDING_HUGE:@[0-9]+]] = private unnamed_addr constant <{ [32768 x i8] }> <{ [32768 x i8] c\"{{.+}}\" }>, align 4\n-\n // CHECK-LABEL: @fully_uninit\n #[no_mangle]\n pub const fn fully_uninit() -> MaybeUninit<[u8; 10]> {\n@@ -30,7 +27,7 @@ pub const fn fully_uninit() -> MaybeUninit<[u8; 10]> {\n #[no_mangle]\n pub const fn partially_uninit() -> PartiallyUninit {\n     const X: PartiallyUninit = PartiallyUninit { x: 0xdeadbeef, y: MaybeUninit::uninit() };\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [4 x i8], [12 x i8] }>, <{ [4 x i8], [12 x i8] }>* [[PARTIALLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 16, i1 false)\n+    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [16 x i8] }>, <{ [16 x i8] }>* [[PARTIALLY_UNINIT]], i32 0, i32 0, i32 0), i{{(32|64)}} 16, i1 false)\n     X\n }\n \n@@ -41,11 +38,3 @@ pub const fn fully_uninit_huge() -> MaybeUninit<[u32; 4096]> {\n     // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [16384 x i8] }>, <{ [16384 x i8] }>* [[FULLY_UNINIT_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 16384, i1 false)\n     F\n }\n-\n-// CHECK-LABEL: @uninit_padding_huge\n-#[no_mangle]\n-pub const fn uninit_padding_huge() -> [(u32, u8); 4096] {\n-    const X: [(u32, u8); 4096] = [(123, 45); 4096];\n-    // CHECK: call void @llvm.memcpy.p0i8.p0i8.i{{(32|64)}}(i8* align 4 %1, i8* align 4 getelementptr inbounds (<{ [32768 x i8] }>, <{ [32768 x i8] }>* [[UNINIT_PADDING_HUGE]], i32 0, i32 0, i32 0), i{{(32|64)}} 32768, i1 false)\n-    X\n-}"}]}