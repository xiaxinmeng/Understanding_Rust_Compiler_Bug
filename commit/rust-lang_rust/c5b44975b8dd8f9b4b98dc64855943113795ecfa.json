{"sha": "c5b44975b8dd8f9b4b98dc64855943113795ecfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YjQ0OTc1YjhkZDhmOWI0Yjk4ZGM2NDg1NTk0MzExMzc5NWVjZmE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-07T13:16:06Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-07T13:16:06Z"}, "message": "Merge #1660\n\n1660: implement while let desugaring r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c7209226fc680c545a02b0deb6da25c61a64500f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7209226fc680c545a02b0deb6da25c61a64500f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5b44975b8dd8f9b4b98dc64855943113795ecfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5b44975b8dd8f9b4b98dc64855943113795ecfa", "html_url": "https://github.com/rust-lang/rust/commit/c5b44975b8dd8f9b4b98dc64855943113795ecfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5b44975b8dd8f9b4b98dc64855943113795ecfa/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9ea4ae680a2d3ce2da38cd7fc6c039e5d7d03171", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea4ae680a2d3ce2da38cd7fc6c039e5d7d03171", "html_url": "https://github.com/rust-lang/rust/commit/9ea4ae680a2d3ce2da38cd7fc6c039e5d7d03171"}, {"sha": "6efc79b89d50b1b2ad9127afb2073bebe4b35290", "url": "https://api.github.com/repos/rust-lang/rust/commits/6efc79b89d50b1b2ad9127afb2073bebe4b35290", "html_url": "https://github.com/rust-lang/rust/commit/6efc79b89d50b1b2ad9127afb2073bebe4b35290"}], "stats": {"total": 160, "additions": 109, "deletions": 51}, "files": [{"sha": "f33676655b2359da89d4d635b6f1a21b12f80e42", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c5b44975b8dd8f9b4b98dc64855943113795ecfa", "patch": "@@ -11,17 +11,16 @@ use ra_syntax::{\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n };\n+use test_utils::tested_by;\n \n use crate::{\n     name::{AsName, SELF_PARAM},\n+    path::GenericArgs,\n+    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n     type_ref::{Mutability, TypeRef},\n     DefWithBody, Either, HasSource, HirDatabase, HirFileId, MacroCallLoc, MacroFileKind, Name,\n     Path, Resolver,\n };\n-use crate::{\n-    path::GenericArgs,\n-    ty::primitive::{FloatTy, IntTy, UncertainFloatTy, UncertainIntTy},\n-};\n \n pub use self::scope::ExprScopes;\n \n@@ -558,37 +557,40 @@ where\n         let syntax_ptr = SyntaxNodePtr::new(expr.syntax());\n         match expr.kind() {\n             ast::ExprKind::IfExpr(e) => {\n-                if let Some(pat) = e.condition().and_then(|c| c.pat()) {\n-                    // if let -- desugar to match\n-                    let pat = self.collect_pat(pat);\n-                    let match_expr =\n-                        self.collect_expr_opt(e.condition().expect(\"checked above\").expr());\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n-                    let else_branch = e\n-                        .else_branch()\n-                        .map(|b| match b {\n-                            ast::ElseBranch::Block(it) => self.collect_block(it),\n-                            ast::ElseBranch::IfExpr(elif) => self.collect_expr(elif.into()),\n-                        })\n-                        .unwrap_or_else(|| self.empty_block());\n-                    let placeholder_pat = self.pats.alloc(Pat::Missing);\n-                    let arms = vec![\n-                        MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n-                        MatchArm { pats: vec![placeholder_pat], expr: else_branch, guard: None },\n-                    ];\n-                    self.alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr)\n-                } else {\n-                    let condition = self.collect_expr_opt(e.condition().and_then(|c| c.expr()));\n-                    let then_branch = self.collect_block_opt(e.then_branch());\n-                    let else_branch = e.else_branch().map(|b| match b {\n-                        ast::ElseBranch::Block(it) => self.collect_block(it),\n-                        ast::ElseBranch::IfExpr(elif) => {\n-                            let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n-                            self.collect_expr(expr)\n+                let then_branch = self.collect_block_opt(e.then_branch());\n+\n+                let else_branch = e.else_branch().map(|b| match b {\n+                    ast::ElseBranch::Block(it) => self.collect_block(it),\n+                    ast::ElseBranch::IfExpr(elif) => {\n+                        let expr: ast::Expr = ast::Expr::cast(elif.syntax().clone()).unwrap();\n+                        self.collect_expr(expr)\n+                    }\n+                });\n+\n+                let condition = match e.condition() {\n+                    None => self.exprs.alloc(Expr::Missing),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: then_branch, guard: None },\n+                                MatchArm {\n+                                    pats: vec![placeholder_pat],\n+                                    expr: else_branch.unwrap_or_else(|| self.empty_block()),\n+                                    guard: None,\n+                                },\n+                            ];\n+                            return self\n+                                .alloc_expr(Expr::Match { expr: match_expr, arms }, syntax_ptr);\n                         }\n-                    });\n-                    self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n-                }\n+                    },\n+                };\n+\n+                self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::ExprKind::TryBlockExpr(e) => {\n                 let body = self.collect_block_opt(e.try_body());\n@@ -600,17 +602,30 @@ where\n                 self.alloc_expr(Expr::Loop { body }, syntax_ptr)\n             }\n             ast::ExprKind::WhileExpr(e) => {\n-                let condition = if let Some(condition) = e.condition() {\n-                    if condition.pat().is_none() {\n-                        self.collect_expr_opt(condition.expr())\n-                    } else {\n-                        // FIXME handle while let\n-                        return self.alloc_expr(Expr::Missing, syntax_ptr);\n-                    }\n-                } else {\n-                    self.exprs.alloc(Expr::Missing)\n-                };\n                 let body = self.collect_block_opt(e.loop_body());\n+\n+                let condition = match e.condition() {\n+                    None => self.exprs.alloc(Expr::Missing),\n+                    Some(condition) => match condition.pat() {\n+                        None => self.collect_expr_opt(condition.expr()),\n+                        // if let -- desugar to match\n+                        Some(pat) => {\n+                            tested_by!(infer_while_let);\n+                            let pat = self.collect_pat(pat);\n+                            let match_expr = self.collect_expr_opt(condition.expr());\n+                            let placeholder_pat = self.pats.alloc(Pat::Missing);\n+                            let break_ = self.exprs.alloc(Expr::Break { expr: None });\n+                            let arms = vec![\n+                                MatchArm { pats: vec![pat], expr: body, guard: None },\n+                                MatchArm { pats: vec![placeholder_pat], expr: break_, guard: None },\n+                            ];\n+                            let match_expr =\n+                                self.exprs.alloc(Expr::Match { expr: match_expr, arms });\n+                            return self.alloc_expr(Expr::Loop { body: match_expr }, syntax_ptr);\n+                        }\n+                    },\n+                };\n+\n                 self.alloc_expr(Expr::While { condition, body }, syntax_ptr)\n             }\n             ast::ExprKind::ForExpr(e) => {"}, {"sha": "5b15eee901a9bde788ff3be6c76b9e800fde1a2a", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=c5b44975b8dd8f9b4b98dc64855943113795ecfa", "patch": "@@ -10,4 +10,5 @@ test_utils::marks!(\n     std_prelude\n     match_ergonomics_ref\n     trait_resolution_on_fn_type\n+    infer_while_let\n );"}, {"sha": "d5f7a4d2503b71fdc68905a786b3213a2e9ef907", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c5b44975b8dd8f9b4b98dc64855943113795ecfa", "patch": "@@ -144,6 +144,26 @@ mod collections {\n     assert_eq!(\"&str\", type_at_pos(&db, pos));\n }\n \n+#[test]\n+fn infer_while_let() {\n+    covers!(infer_while_let);\n+    let (db, pos) = MockDatabase::with_position(\n+        r#\"\n+//- /main.rs\n+enum Option<T> { Some(T), None }\n+\n+fn test() {\n+    let foo: Option<f32> = None;\n+    while let Option::Some(x) = foo {\n+        <|>x\n+    }\n+}\n+\n+\"#,\n+    );\n+    assert_eq!(\"f32\", type_at_pos(&db, pos));\n+}\n+\n #[test]\n fn infer_basics() {\n     assert_snapshot_matches!("}, {"sha": "0b3c96d26aa63a179040d72d19975b149b6721b4", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5b44975b8dd8f9b4b98dc64855943113795ecfa/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=c5b44975b8dd8f9b4b98dc64855943113795ecfa", "patch": "@@ -414,13 +414,35 @@ fn main() {\n }\"#,\n         );\n \n-        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r#\"[\n-    InlayHint {\n-        range: [166; 170),\n-        kind: TypeHint,\n-        label: \"CustomOption<Test>\",\n-    },\n-]\"#\n+        assert_debug_snapshot_matches!(analysis.inlay_hints(file_id).unwrap(), @r###\"\n+       \u22ee[\n+       \u22ee    InlayHint {\n+       \u22ee        range: [166; 170),\n+       \u22ee        kind: TypeHint,\n+       \u22ee        label: \"CustomOption<Test>\",\n+       \u22ee    },\n+       \u22ee    InlayHint {\n+       \u22ee        range: [343; 347),\n+       \u22ee        kind: TypeHint,\n+       \u22ee        label: \"&Test\",\n+       \u22ee    },\n+       \u22ee    InlayHint {\n+       \u22ee        range: [401; 402),\n+       \u22ee        kind: TypeHint,\n+       \u22ee        label: \"&CustomOption<u32>\",\n+       \u22ee    },\n+       \u22ee    InlayHint {\n+       \u22ee        range: [404; 405),\n+       \u22ee        kind: TypeHint,\n+       \u22ee        label: \"&u8\",\n+       \u22ee    },\n+       \u22ee    InlayHint {\n+       \u22ee        range: [549; 550),\n+       \u22ee        kind: TypeHint,\n+       \u22ee        label: \"&u32\",\n+       \u22ee    },\n+       \u22ee]\n+        \"###\n         );\n     }\n "}]}