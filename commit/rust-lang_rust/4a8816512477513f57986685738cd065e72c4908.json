{"sha": "4a8816512477513f57986685738cd065e72c4908", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODgxNjUxMjQ3NzUxM2Y1Nzk4NjY4NTczOGNkMDY1ZTcyYzQ5MDg=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-16T21:56:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-02-18T10:07:49Z"}, "message": "ast: Keep expansion status for out-of-line module items\n\nAlso remove `ast::Mod` which is mostly redundant now", "tree": {"sha": "264d04ccc27f50e8b7f3e91402ba228e97af43c6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264d04ccc27f50e8b7f3e91402ba228e97af43c6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a8816512477513f57986685738cd065e72c4908", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a8816512477513f57986685738cd065e72c4908", "html_url": "https://github.com/rust-lang/rust/commit/4a8816512477513f57986685738cd065e72c4908", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a8816512477513f57986685738cd065e72c4908/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb65f15c7800930c3f74288974689d9884e51ba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb65f15c7800930c3f74288974689d9884e51ba0", "html_url": "https://github.com/rust-lang/rust/commit/eb65f15c7800930c3f74288974689d9884e51ba0"}], "stats": {"total": 272, "additions": 147, "deletions": 125}, "files": [{"sha": "3550055ac10d3ce384cdc312df57e50a8394e231", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -2299,21 +2299,22 @@ impl FnRetTy {\n     }\n }\n \n-/// Module declaration.\n-///\n-/// E.g., `mod foo;` or `mod foo { .. }`.\n+#[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n+pub enum Inline {\n+    Yes,\n+    No,\n+}\n+\n+/// Module item kind.\n #[derive(Clone, Encodable, Decodable, Debug)]\n-pub struct Mod {\n-    /// A span from the first token past `{` to the last token until `}`.\n-    /// For `mod foo;`, the inner span ranges from the first token\n-    /// to the last token in the external file.\n-    pub inner: Span,\n-    /// `unsafe` keyword accepted syntactically for macro DSLs, but not\n-    /// semantically by Rust.\n-    pub unsafety: Unsafe,\n-    pub items: Vec<P<Item>>,\n-    /// `true` for `mod foo { .. }`; `false` for `mod foo;`.\n-    pub inline: bool,\n+pub enum ModKind {\n+    /// Module with inlined definition `mod foo { ... }`,\n+    /// or with definition outlined to a separate file `mod foo;` and already loaded from it.\n+    /// The inner span is from the first token past `{` to the last token until `}`,\n+    /// or from the first to the last token in the loaded file.\n+    Loaded(Vec<P<Item>>, Inline, Span),\n+    /// Module with definition outlined to a separate file `mod foo;` but not yet loaded from it.\n+    Unloaded,\n }\n \n /// Foreign module declaration.\n@@ -2710,7 +2711,9 @@ pub enum ItemKind {\n     /// A module declaration (`mod`).\n     ///\n     /// E.g., `mod foo;` or `mod foo { .. }`.\n-    Mod(Mod),\n+    /// `unsafe` keyword on modules is accepted syntactically for macro DSLs, but not\n+    /// semantically by Rust.\n+    Mod(Unsafe, ModKind),\n     /// An external module (`extern`).\n     ///\n     /// E.g., `extern {}` or `extern \"C\" {}`."}, {"sha": "c286738811ca13c27648c1da000c6ed5f72bb64b", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -913,11 +913,13 @@ pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n             vis.visit_generics(generics);\n             visit_opt(body, |body| vis.visit_block(body));\n         }\n-        ItemKind::Mod(m) => {\n-            let Mod { inner, unsafety: _, items, inline: _ } = m;\n-            vis.visit_span(inner);\n-            items.flat_map_in_place(|item| vis.flat_map_item(item));\n-        }\n+        ItemKind::Mod(_unsafety, mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, inner_span) => {\n+                vis.visit_span(inner_span);\n+                items.flat_map_in_place(|item| vis.flat_map_item(item));\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(nm) => vis.visit_foreign_mod(nm),\n         ItemKind::GlobalAsm(_ga) => {}\n         ItemKind::TyAlias(box TyAliasKind(_, generics, bounds, ty)) => {\n@@ -1010,7 +1012,7 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n             id: DUMMY_NODE_ID,\n             vis: item_vis,\n             span,\n-            kind: ItemKind::Mod(Mod { inner: span, unsafety: Unsafe::No, items, inline: true }),\n+            kind: ItemKind::Mod(Unsafe::No, ModKind::Loaded(items, Inline::Yes, span)),\n             tokens: None,\n         });\n         let items = vis.flat_map_item(item);\n@@ -1021,7 +1023,9 @@ pub fn noop_visit_crate<T: MutVisitor>(krate: &mut Crate, vis: &mut T) {\n         } else if len == 1 {\n             let Item { attrs, span, kind, .. } = items.into_iter().next().unwrap().into_inner();\n             match kind {\n-                ItemKind::Mod(module) => Crate { attrs, items: module.items, span, proc_macros },\n+                ItemKind::Mod(_, ModKind::Loaded(items, ..)) => {\n+                    Crate { attrs, items, span, proc_macros }\n+                }\n                 _ => panic!(\"visitor converted a module to not a module\"),\n             }\n         } else {"}, {"sha": "32b9dd46baef446dc6b2f78d88e6393de49f4133", "filename": "compiler/rustc_ast/src/visit.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fvisit.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -290,7 +290,12 @@ pub fn walk_item<'a, V: Visitor<'a>>(visitor: &mut V, item: &'a Item) {\n             let kind = FnKind::Fn(FnCtxt::Free, item.ident, sig, &item.vis, body.as_deref());\n             visitor.visit_fn(kind, item.span, item.id)\n         }\n-        ItemKind::Mod(ref module) => walk_list!(visitor, visit_item, &module.items),\n+        ItemKind::Mod(_unsafety, ref mod_kind) => match mod_kind {\n+            ModKind::Loaded(items, _inline, _inner_span) => {\n+                walk_list!(visitor, visit_item, items)\n+            }\n+            ModKind::Unloaded => {}\n+        },\n         ItemKind::ForeignMod(ref foreign_module) => {\n             walk_list!(visitor, visit_foreign_item, &foreign_module.items);\n         }"}, {"sha": "8b740b77740892d875b3df8d64640a07f25578e3", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -314,7 +314,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::ItemKind::Fn(sig, generics, body_id)\n                 })\n             }\n-            ItemKind::Mod(ref m) => hir::ItemKind::Mod(self.lower_mod(&m.items, m.inner)),\n+            ItemKind::Mod(_, ref mod_kind) => match mod_kind {\n+                ModKind::Loaded(items, _, inner_span) => {\n+                    hir::ItemKind::Mod(self.lower_mod(items, *inner_span))\n+                }\n+                ModKind::Unloaded => panic!(\"`mod` items should have been loaded by now\"),\n+            },\n             ItemKind::ForeignMod(ref fm) => {\n                 if fm.abi.is_none() {\n                     self.maybe_lint_missing_abi(span, id, abi::Abi::C);"}, {"sha": "563bcda51906575cefaf6602b1553caa42bba11e", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -1054,12 +1054,14 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 walk_list!(self, visit_attribute, &item.attrs);\n                 return;\n             }\n-            ItemKind::Mod(Mod { inline, unsafety, .. }) => {\n+            ItemKind::Mod(unsafety, ref mod_kind) => {\n                 if let Unsafe::Yes(span) = unsafety {\n                     self.err_handler().span_err(span, \"module cannot be declared unsafe\");\n                 }\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n-                if !inline && !self.session.contains_name(&item.attrs, sym::path) {\n+                if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _))\n+                    && !self.session.contains_name(&item.attrs, sym::path)\n+                {\n                     self.check_mod_file_item_asciionly(item.ident);\n                 }\n             }"}, {"sha": "2189e6eaa0297344770eea82a4efe580465af21a", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 20, "deletions": 22, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -9,7 +9,7 @@ use rustc_ast::util::classify;\n use rustc_ast::util::comments::{gather_comments, Comment, CommentStyle};\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast::{self as ast, BlockCheckMode, PatKind, RangeEnd, RangeSyntax};\n-use rustc_ast::{GenericArg, MacArgs};\n+use rustc_ast::{GenericArg, MacArgs, ModKind};\n use rustc_ast::{GenericBound, SelfKind, TraitBoundModifier};\n use rustc_ast::{InlineAsmOperand, InlineAsmRegOrRegClass};\n use rustc_ast::{InlineAsmOptions, InlineAsmTemplatePiece};\n@@ -87,7 +87,6 @@ pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n     ann: &'a (dyn PpAnn + 'a),\n-    is_expanded: bool,\n }\n \n crate const INDENT_UNIT: usize = 4;\n@@ -103,12 +102,8 @@ pub fn print_crate<'a>(\n     is_expanded: bool,\n     edition: Edition,\n ) -> String {\n-    let mut s = State {\n-        s: pp::mk_printer(),\n-        comments: Some(Comments::new(sm, filename, input)),\n-        ann,\n-        is_expanded,\n-    };\n+    let mut s =\n+        State { s: pp::mk_printer(), comments: Some(Comments::new(sm, filename, input)), ann };\n \n     if is_expanded && !krate.attrs.iter().any(|attr| attr.has_name(sym::no_core)) {\n         // We need to print `#![no_std]` (and its feature gate) so that\n@@ -856,7 +851,7 @@ impl<'a> PrintState<'a> for State<'a> {\n \n impl<'a> State<'a> {\n     pub fn new() -> State<'a> {\n-        State { s: pp::mk_printer(), comments: None, ann: &NoAnn, is_expanded: false }\n+        State { s: pp::mk_printer(), comments: None, ann: &NoAnn }\n     }\n \n     // Synthesizes a comment that was not textually present in the original source\n@@ -1134,26 +1129,29 @@ impl<'a> State<'a> {\n                 let body = body.as_deref();\n                 self.print_fn_full(sig, item.ident, gen, &item.vis, def, body, &item.attrs);\n             }\n-            ast::ItemKind::Mod(ref _mod) => {\n+            ast::ItemKind::Mod(unsafety, ref mod_kind) => {\n                 self.head(self.to_string(|s| {\n                     s.print_visibility(&item.vis);\n-                    s.print_unsafety(_mod.unsafety);\n+                    s.print_unsafety(unsafety);\n                     s.word(\"mod\");\n                 }));\n                 self.print_ident(item.ident);\n \n-                if _mod.inline || self.is_expanded {\n-                    self.nbsp();\n-                    self.bopen();\n-                    self.print_inner_attributes(&item.attrs);\n-                    for item in &_mod.items {\n-                        self.print_item(item);\n+                match mod_kind {\n+                    ModKind::Loaded(items, ..) => {\n+                        self.nbsp();\n+                        self.bopen();\n+                        self.print_inner_attributes(&item.attrs);\n+                        for item in items {\n+                            self.print_item(item);\n+                        }\n+                        self.bclose(item.span);\n+                    }\n+                    ModKind::Unloaded => {\n+                        self.s.word(\";\");\n+                        self.end(); // end inner head-block\n+                        self.end(); // end outer head-block\n                     }\n-                    self.bclose(item.span);\n-                } else {\n-                    self.s.word(\";\");\n-                    self.end(); // end inner head-block\n-                    self.end(); // end outer head-block\n                 }\n             }\n             ast::ItemKind::ForeignMod(ref nmod) => {"}, {"sha": "28e8259784387078e064de865d09c7c62e8cb286", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -1,10 +1,10 @@\n // Code that generates a test runner to run all the tests in a crate\n \n use rustc_ast as ast;\n-use rustc_ast::attr;\n use rustc_ast::entry::EntryPointType;\n use rustc_ast::mut_visit::{ExpectOne, *};\n use rustc_ast::ptr::P;\n+use rustc_ast::{attr, ModKind};\n use rustc_expand::base::{ExtCtxt, ResolverExpand};\n use rustc_expand::expand::{AstFragment, ExpansionConfig};\n use rustc_feature::Features;\n@@ -106,19 +106,19 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         if let ast::ItemKind::Mod(..) = item.kind {\n             let tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n-            let module = match item.kind {\n-                ast::ItemKind::Mod(module) => module,\n-                _ => unreachable!(),\n-            };\n             let mut tests = mem::replace(&mut self.tests, tests);\n \n             if !tests.is_empty() {\n                 let parent =\n                     if item.id == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { item.id };\n                 // Create an identifier that will hygienically resolve the test\n                 // case name, even in another module.\n+                let inner_span = match item.kind {\n+                    ast::ItemKind::Mod(_, ModKind::Loaded(.., span)) => span,\n+                    _ => unreachable!(),\n+                };\n                 let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n-                    module.inner,\n+                    inner_span,\n                     AstPass::TestHarness,\n                     &[],\n                     Some(parent),\n@@ -130,7 +130,6 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n                 }\n                 self.cx.test_cases.extend(tests);\n             }\n-            item.kind = ast::ItemKind::Mod(module);\n         }\n         smallvec![P(item)]\n     }"}, {"sha": "5a4737842f0af0e4e0a26fee4c01a5f03853a69b", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 47, "deletions": 43, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -12,8 +12,8 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AttrItem, AttrStyle, Block, ItemKind, LitKind, MacArgs};\n-use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n@@ -367,12 +367,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let krate_item = AstFragment::Items(smallvec![P(ast::Item {\n             attrs: krate.attrs,\n             span: krate.span,\n-            kind: ast::ItemKind::Mod(ast::Mod {\n-                inner: krate.span,\n-                unsafety: Unsafe::No,\n-                items: krate.items,\n-                inline: true\n-            }),\n+            kind: ast::ItemKind::Mod(\n+                Unsafe::No,\n+                ModKind::Loaded(krate.items, Inline::Yes, krate.span)\n+            ),\n             ident: Ident::invalid(),\n             id: ast::DUMMY_NODE_ID,\n             vis: ast::Visibility {\n@@ -384,9 +382,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         })]);\n \n         match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n-            Some(ast::Item { attrs, kind: ast::ItemKind::Mod(module), .. }) => {\n+            Some(ast::Item {\n+                attrs,\n+                kind: ast::ItemKind::Mod(_, ModKind::Loaded(items, ..)),\n+                ..\n+            }) => {\n                 krate.attrs = attrs;\n-                krate.items = module.items;\n+                krate.items = items;\n             }\n             None => {\n                 // Resolution failed so we return an empty expansion\n@@ -809,7 +811,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         impl<'ast, 'a> Visitor<'ast> for GateProcMacroInput<'a> {\n             fn visit_item(&mut self, item: &'ast ast::Item) {\n                 match &item.kind {\n-                    ast::ItemKind::Mod(module) if !module.inline => {\n+                    ast::ItemKind::Mod(_, mod_kind)\n+                        if !matches!(mod_kind, ModKind::Loaded(_, Inline::Yes, _)) =>\n+                    {\n                         feature_err(\n                             self.parse_sess,\n                             sym::proc_macro_hygiene,\n@@ -1266,47 +1270,47 @@ impl<'a, 'b> MutVisitor for InvocationCollector<'a, 'b> {\n                     _ => unreachable!(),\n                 })\n             }\n-            ast::ItemKind::Mod(ref mut old_mod @ ast::Mod { .. }) if ident != Ident::invalid() => {\n+            ast::ItemKind::Mod(_, ref mut mod_kind) if ident != Ident::invalid() => {\n                 let sess = &self.cx.sess.parse_sess;\n                 let orig_ownership = self.cx.current_expansion.directory_ownership;\n                 let mut module = (*self.cx.current_expansion.module).clone();\n \n                 let pushed = &mut false; // Record `parse_external_mod` pushing so we can pop.\n                 let dir = Directory { ownership: orig_ownership, path: module.directory };\n-                let Directory { ownership, path } = if old_mod.inline {\n-                    // Inline `mod foo { ... }`, but we still need to push directories.\n-                    item.attrs = attrs;\n-                    push_directory(&self.cx.sess, ident, &item.attrs, dir)\n-                } else {\n-                    // We have an outline `mod foo;` so we need to parse the file.\n-                    let (ast::Mod { unsafety, inline, items, inner }, dir) = parse_external_mod(\n-                        &self.cx.sess,\n-                        ident,\n-                        span,\n-                        old_mod.unsafety,\n-                        dir,\n-                        &mut attrs,\n-                        pushed,\n-                    );\n-\n-                    let krate = ast::Crate { attrs, items, span: inner, proc_macros: vec![] };\n-                    if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n-                        extern_mod_loaded(&krate, ident);\n+                let Directory { ownership, path } = match mod_kind {\n+                    ModKind::Loaded(_, Inline::Yes, _) => {\n+                        // Inline `mod foo { ... }`, but we still need to push directories.\n+                        item.attrs = attrs;\n+                        push_directory(&self.cx.sess, ident, &item.attrs, dir)\n+                    }\n+                    ModKind::Loaded(_, Inline::No, _) => {\n+                        panic!(\"`mod` item is loaded from a file for the second time\")\n                     }\n+                    ModKind::Unloaded => {\n+                        // We have an outline `mod foo;` so we need to parse the file.\n+                        let (items, inner_span, dir) =\n+                            parse_external_mod(&self.cx.sess, ident, span, dir, &mut attrs, pushed);\n+\n+                        let krate =\n+                            ast::Crate { attrs, items, span: inner_span, proc_macros: vec![] };\n+                        if let Some(extern_mod_loaded) = self.cx.extern_mod_loaded {\n+                            extern_mod_loaded(&krate, ident);\n+                        }\n \n-                    *old_mod = ast::Mod { unsafety, inline, items: krate.items, inner };\n-                    item.attrs = krate.attrs;\n-                    // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n-                    item = match self.configure(item) {\n-                        Some(node) => node,\n-                        None => {\n-                            if *pushed {\n-                                sess.included_mod_stack.borrow_mut().pop();\n+                        *mod_kind = ModKind::Loaded(krate.items, Inline::No, inner_span);\n+                        item.attrs = krate.attrs;\n+                        // File can have inline attributes, e.g., `#![cfg(...)]` & co. => Reconfigure.\n+                        item = match self.configure(item) {\n+                            Some(node) => node,\n+                            None => {\n+                                if *pushed {\n+                                    sess.included_mod_stack.borrow_mut().pop();\n+                                }\n+                                return Default::default();\n                             }\n-                            return Default::default();\n-                        }\n-                    };\n-                    dir\n+                        };\n+                        dir\n+                    }\n                 };\n \n                 // Set the module info before we flat map."}, {"sha": "076d3b02be93fb45b565a17e4ac8cd6dec12074e", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -1,4 +1,5 @@\n-use rustc_ast::{token, Attribute, Mod, Unsafe};\n+use rustc_ast::ptr::P;\n+use rustc_ast::{token, Attribute, Item};\n use rustc_errors::{struct_span_err, PResult};\n use rustc_parse::new_parser_from_file;\n use rustc_session::parse::ParseSess;\n@@ -42,11 +43,10 @@ crate fn parse_external_mod(\n     sess: &Session,\n     id: Ident,\n     span: Span, // The span to blame on errors.\n-    unsafety: Unsafe,\n     Directory { mut ownership, path }: Directory,\n     attrs: &mut Vec<Attribute>,\n     pop_mod_stack: &mut bool,\n-) -> (Mod, Directory) {\n+) -> (Vec<P<Item>>, Span, Directory) {\n     // We bail on the first error, but that error does not cause a fatal error... (1)\n     let result: PResult<'_, _> = try {\n         // Extract the file path and the new ownership.\n@@ -62,25 +62,22 @@ crate fn parse_external_mod(\n \n         // Actually parse the external file as a module.\n         let mut parser = new_parser_from_file(&sess.parse_sess, &mp.path, Some(span));\n-        let (inner_attrs, items, inner) = parser.parse_mod(&token::Eof)?;\n-        (Mod { unsafety, inline: false, items, inner }, inner_attrs)\n+        let (mut inner_attrs, items, inner_span) = parser.parse_mod(&token::Eof)?;\n+        attrs.append(&mut inner_attrs);\n+        (items, inner_span)\n     };\n     // (1) ...instead, we return a dummy module.\n-    let (module, mut new_attrs) = result.map_err(|mut err| err.emit()).unwrap_or_else(|_| {\n-        let module = Mod { inner: Span::default(), unsafety, items: Vec::new(), inline: false };\n-        (module, Vec::new())\n-    });\n-    attrs.append(&mut new_attrs);\n+    let (items, inner_span) = result.map_err(|mut err| err.emit()).unwrap_or_default();\n \n-    // Extract the directory path for submodules of `module`.\n-    let path = sess.source_map().span_to_unmapped_path(module.inner);\n+    // Extract the directory path for submodules of  the module.\n+    let path = sess.source_map().span_to_unmapped_path(inner_span);\n     let mut path = match path {\n         FileName::Real(name) => name.into_local_path(),\n         other => PathBuf::from(other.to_string()),\n     };\n     path.pop();\n \n-    (module, Directory { ownership, path })\n+    (items, inner_span, Directory { ownership, path })\n }\n \n fn error_on_circular_module<'a>("}, {"sha": "56f25ffdb0187cf7bc4ea2a8f8c3ea7c17d25898", "filename": "compiler/rustc_expand/src/parse/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fparse%2Ftests.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -309,8 +309,8 @@ fn out_of_line_mod() {\n         .unwrap()\n         .unwrap();\n \n-        if let ast::ItemKind::Mod(ref m) = item.kind {\n-            assert!(m.items.len() == 2);\n+        if let ast::ItemKind::Mod(_, ref mod_kind) = item.kind {\n+            assert!(matches!(mod_kind, ast::ModKind::Loaded(items, ..) if items.len() == 2));\n         } else {\n             panic!();\n         }"}, {"sha": "0f907859a19a681d90ff554360a7cad0efc1e622", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -35,14 +35,16 @@ impl<'a> Parser<'a> {\n         let unsafety = self.parse_unsafety();\n         self.expect_keyword(kw::Mod)?;\n         let id = self.parse_ident()?;\n-        let ((mut inner_attrs, items, inner), inline) = if self.eat(&token::Semi) {\n-            ((Vec::new(), Vec::new(), Span::default()), false)\n+        let mod_kind = if self.eat(&token::Semi) {\n+            ModKind::Unloaded\n         } else {\n             self.expect(&token::OpenDelim(token::Brace))?;\n-            (self.parse_mod(&token::CloseDelim(token::Brace))?, true)\n+            let (mut inner_attrs, items, inner_span) =\n+                self.parse_mod(&token::CloseDelim(token::Brace))?;\n+            attrs.append(&mut inner_attrs);\n+            ModKind::Loaded(items, Inline::Yes, inner_span)\n         };\n-        attrs.append(&mut inner_attrs);\n-        Ok((id, ItemKind::Mod(Mod { unsafety, inline, items, inner })))\n+        Ok((id, ItemKind::Mod(unsafety, mod_kind)))\n     }\n \n     /// Parses the contents of a module (inner attributes followed by module items)."}, {"sha": "09ab84eaeb613d4111d99c9464092c3506da5ae4", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -1023,7 +1023,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 });\n             }\n \n-            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n+            ItemKind::Mod(..) | ItemKind::ForeignMod(_) => {\n                 self.with_scope(item.id, |this| {\n                     visit::walk_item(this, item);\n                 });"}, {"sha": "77fbbaa1532af38a15fa6b4967ff79688fa34ab6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -29,7 +29,7 @@ use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast::{Crate, CRATE_NODE_ID};\n-use rustc_ast::{ItemKind, Path};\n+use rustc_ast::{ItemKind, ModKind, Path};\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n@@ -339,8 +339,8 @@ impl UsePlacementFinder {\n \n impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     fn visit_item(&mut self, item: &'tcx ast::Item) {\n-        if let ItemKind::Mod(module) = &item.kind {\n-            if let ControlFlow::Break(..) = self.check_mod(&module.items, item.id) {\n+        if let ItemKind::Mod(_, ModKind::Loaded(items, ..)) = &item.kind {\n+            if let ControlFlow::Break(..) = self.check_mod(items, item.id) {\n                 return;\n             }\n         }"}, {"sha": "9ff7ef7cc3b55e17cb9acf107a732c5fb11e8ce5", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4a8816512477513f57986685738cd065e72c4908/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a8816512477513f57986685738cd065e72c4908/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=4a8816512477513f57986685738cd065e72c4908", "patch": "@@ -241,9 +241,12 @@ pub fn eq_item_kind(l: &ItemKind, r: &ItemKind) -> bool {\n                 && eq_generics(lg, rg)\n                 && both(lb, rb, |l, r| eq_block(l, r))\n         }\n-        (Mod(l), Mod(r)) => {\n-            l.inline == r.inline && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_item_kind))\n-        }\n+        (Mod(lu, lmk), Mod(ru, rmk)) => lu == ru && match (lmk, rmk) {\n+            (ModKind::Loaded(litems, linline, _), ModKind::Loaded(ritems, rinline, _)) =>\n+                linline == rinline && over(litems, ritems, |l, r| eq_item(l, r, eq_item_kind)),\n+            (ModKind::Unloaded, ModKind::Unloaded) => true,\n+            _ => false,\n+        },\n         (ForeignMod(l), ForeignMod(r)) => {\n             both(&l.abi, &r.abi, |l, r| eq_str_lit(l, r))\n                 && over(&l.items, &r.items, |l, r| eq_item(l, r, eq_foreign_item_kind))"}]}