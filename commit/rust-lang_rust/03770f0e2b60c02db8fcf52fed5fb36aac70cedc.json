{"sha": "03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "node_id": "C_kwDOAAsO6NoAKDAzNzcwZjBlMmI2MGMwMmRiOGZjZjUyZmVkNWZiMzZhYWM3MGNlZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-16T12:47:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-16T12:47:49Z"}, "message": "Auto merge of #103880 - b-naber:field-ty-mir, r=lcnr\n\nUse non-ascribed type as field's type in mir\n\nFixes https://github.com/rust-lang/rust/issues/96514\n\nr? `@lcnr`", "tree": {"sha": "fa8e7aea22d80f0b44cd5d982b6d3418a2ccb787", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa8e7aea22d80f0b44cd5d982b6d3418a2ccb787"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "html_url": "https://github.com/rust-lang/rust/commit/03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01ef4b21dc5251b58bd9c6fd6face2ae95d56da1", "url": "https://api.github.com/repos/rust-lang/rust/commits/01ef4b21dc5251b58bd9c6fd6face2ae95d56da1", "html_url": "https://github.com/rust-lang/rust/commit/01ef4b21dc5251b58bd9c6fd6face2ae95d56da1"}, {"sha": "ff41359e6535ca7dc1261f282b1601136fedee21", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff41359e6535ca7dc1261f282b1601136fedee21", "html_url": "https://github.com/rust-lang/rust/commit/ff41359e6535ca7dc1261f282b1601136fedee21"}], "stats": {"total": 532, "additions": 433, "deletions": 99}, "files": [{"sha": "e909b2f74aa16878bd4298bda6a7614c96fdb996", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -1488,7 +1488,7 @@ impl<'tcx> StatementKind<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Places\n \n-impl<V, T> ProjectionElem<V, T> {\n+impl<V, T, U> ProjectionElem<V, T, U> {\n     /// Returns `true` if the target of this projection may refer to a different region of memory\n     /// than the base.\n     fn is_indirect(&self) -> bool {\n@@ -1517,7 +1517,7 @@ impl<V, T> ProjectionElem<V, T> {\n \n /// Alias for projections as they appear in `UserTypeProjection`, where we\n /// need neither the `V` parameter for `Index` nor the `T` for `Field`.\n-pub type ProjectionKind = ProjectionElem<(), ()>;\n+pub type ProjectionKind = ProjectionElem<(), (), ()>;\n \n rustc_index::newtype_index! {\n     /// A [newtype'd][wrapper] index type in the MIR [control-flow graph][CFG]"}, {"sha": "a6ca04f5e627ade49119c343de8f3fd405470dc6", "filename": "compiler/rustc_middle/src/mir/syntax.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fsyntax.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -890,11 +890,18 @@ pub struct Place<'tcx> {\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n }\n \n+/// The different kinds of projections that can be used in the projection of a `Place`.\n+///\n+/// `T1` is the generic type for a field projection. For an actual projection on a `Place`\n+/// this parameter will always be `Ty`, but the field type can be unavailable when\n+/// building (by using `PlaceBuilder`) places that correspond to upvars.\n+/// `T2` is the generic type for an `OpaqueCast` (is generic since it's abstracted over\n+/// in dataflow analysis, see `AbstractElem`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[derive(TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]\n-pub enum ProjectionElem<V, T> {\n+pub enum ProjectionElem<V, T1, T2> {\n     Deref,\n-    Field(Field, T),\n+    Field(Field, T1),\n     /// Index into a slice/array.\n     ///\n     /// Note that this does not also dereference, and so it does not exactly correspond to slice\n@@ -950,12 +957,36 @@ pub enum ProjectionElem<V, T> {\n \n     /// Like an explicit cast from an opaque type to a concrete type, but without\n     /// requiring an intermediate variable.\n-    OpaqueCast(T),\n+    OpaqueCast(T2),\n }\n \n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n-pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n+pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>, Ty<'tcx>>;\n+\n+/// Alias for projections that appear in `PlaceBuilder::Upvar`, for which\n+/// we cannot provide any field types.\n+pub type UpvarProjectionElem<'tcx> = ProjectionElem<Local, (), Ty<'tcx>>;\n+\n+impl<'tcx> From<PlaceElem<'tcx>> for UpvarProjectionElem<'tcx> {\n+    fn from(elem: PlaceElem<'tcx>) -> Self {\n+        match elem {\n+            ProjectionElem::Deref => ProjectionElem::Deref,\n+            ProjectionElem::Field(field, _) => ProjectionElem::Field(field, ()),\n+            ProjectionElem::Index(v) => ProjectionElem::Index(v),\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+            }\n+            ProjectionElem::Subslice { from, to, from_end } => {\n+                ProjectionElem::Subslice { from, to, from_end }\n+            }\n+            ProjectionElem::Downcast(opt_sym, variant_idx) => {\n+                ProjectionElem::Downcast(opt_sym, variant_idx)\n+            }\n+            ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty),\n+        }\n+    }\n+}\n \n ///////////////////////////////////////////////////////////////////////////\n // Operands"}, {"sha": "e3ca1f41d7ea1b0b05e833217183dc4ff7c562c6", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -28,8 +28,8 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `place_ty.field_ty(tcx, f)` computes the type at a given field\n     /// of a record or enum-variant. (Most clients of `PlaceTy` can\n     /// instead just extract the relevant type directly from their\n-    /// `PlaceElem`, but some instances of `ProjectionElem<V, T>` do\n-    /// not carry a `Ty` for `T`.)\n+    /// `PlaceElem`, but some instances of `ProjectionElem<V, T1, T2>` do\n+    /// not carry a `Ty` for `T1` or `T2`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n     pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n@@ -64,17 +64,18 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `Ty` or downcast variant corresponding to that projection.\n     /// The `handle_field` callback must map a `Field` to its `Ty`,\n     /// (which should be trivial when `T` = `Ty`).\n-    pub fn projection_ty_core<V, T>(\n+    pub fn projection_ty_core<V, T1, T2>(\n         self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n-        mut handle_opaque_cast: impl FnMut(&Self, T) -> Ty<'tcx>,\n+        elem: &ProjectionElem<V, T1, T2>,\n+        mut handle_field: impl FnMut(&Self, Field, T1) -> Ty<'tcx>,\n+        mut handle_opaque_cast: impl FnMut(&Self, T2) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n-        T: ::std::fmt::Debug + Copy,\n+        T1: ::std::fmt::Debug + Copy,\n+        T2: ::std::fmt::Debug + Copy,\n     {\n         if self.variant_index.is_some() && !matches!(elem, ProjectionElem::Field(..)) {\n             bug!(\"cannot use non field projection on downcasted place\")"}, {"sha": "8a35478dd8b3412c648cc7ba8eceebab25cb8eaf", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 291, "deletions": 64, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::hir::place::Projection as HirProjection;\n use rustc_middle::hir::place::ProjectionKind as HirProjectionKind;\n use rustc_middle::middle::region;\n+use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::AssertKind::BoundsCheck;\n use rustc_middle::mir::*;\n use rustc_middle::thir::*;\n@@ -18,23 +19,31 @@ use rustc_target::abi::VariantIdx;\n use rustc_index::vec::Idx;\n \n use std::assert_matches::assert_matches;\n+use std::convert::From;\n use std::iter;\n \n-/// The \"outermost\" place that holds this value.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub(crate) enum PlaceBase {\n+/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n+/// place by pushing more and more projections onto the end, and then convert the final set into a\n+/// place using the `into_place` method.\n+///\n+/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n+/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n+#[derive(Clone, Debug, PartialEq)]\n+pub(in crate::build) enum PlaceBuilder<'tcx> {\n     /// Denotes the start of a `Place`.\n-    Local(Local),\n+    ///\n+    /// We use `PlaceElem` since this has all `Field` types available.\n+    Local { local: Local, projection: Vec<PlaceElem<'tcx>> },\n \n     /// When building place for an expression within a closure, the place might start off a\n     /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n     /// index (within the desugared closure) of the captured path until most of the projections\n-    /// are applied. We use `PlaceBase::Upvar` to keep track of the root variable off of which the\n+    /// are applied. We use `PlaceBuilder::Upvar` to keep track of the root variable off of which the\n     /// captured path starts, the closure the capture belongs to and the trait the closure\n     /// implements.\n     ///\n-    /// Once we have figured out the capture index, we can convert the place builder to start from\n-    /// `PlaceBase::Local`.\n+    /// Once we have figured out the capture index, we can convert the place builder to\n+    /// `PlaceBuilder::Local`.\n     ///\n     /// Consider the following example\n     /// ```rust\n@@ -55,24 +64,16 @@ pub(crate) enum PlaceBase {\n     ///\n     /// When `capture_disjoint_fields` is enabled, `t.0.0.0` is captured and we won't be able to\n     /// figure out that it is captured until all the `Field` projections are applied.\n-    Upvar {\n-        /// HirId of the upvar\n-        var_hir_id: LocalVarId,\n-        /// DefId of the closure\n-        closure_def_id: LocalDefId,\n-    },\n+    ///\n+    /// Note: in contrast to `PlaceBuilder::Local` we have not yet determined all `Field` types\n+    /// and will only do so once converting to `PlaceBuilder::Local`.\n+    Upvar { upvar: Upvar, projection: Vec<UpvarProjectionElem<'tcx>> },\n }\n \n-/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n-/// place by pushing more and more projections onto the end, and then convert the final set into a\n-/// place using the `to_place` method.\n-///\n-/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n-/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n-#[derive(Clone, Debug, PartialEq)]\n-pub(in crate::build) struct PlaceBuilder<'tcx> {\n-    base: PlaceBase,\n-    projection: Vec<PlaceElem<'tcx>>,\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub(crate) struct Upvar {\n+    var_hir_id: LocalVarId,\n+    closure_def_id: LocalDefId,\n }\n \n /// Given a list of MIR projections, convert them to list of HIR ProjectionKind.\n@@ -82,7 +83,7 @@ pub(in crate::build) struct PlaceBuilder<'tcx> {\n /// part of a path that is captured by a closure. We stop applying projections once we see the first\n /// projection that isn't captured by a closure.\n fn convert_to_hir_projections_and_truncate_for_capture<'tcx>(\n-    mir_projections: &[PlaceElem<'tcx>],\n+    mir_projections: &[UpvarProjectionElem<'tcx>],\n ) -> Vec<HirProjectionKind> {\n     let mut hir_projections = Vec::new();\n     let mut variant = None;\n@@ -156,7 +157,7 @@ fn is_ancestor_or_same_capture(\n fn find_capture_matching_projections<'a, 'tcx>(\n     upvars: &'a CaptureMap<'tcx>,\n     var_hir_id: LocalVarId,\n-    projections: &[PlaceElem<'tcx>],\n+    projections: &[UpvarProjectionElem<'tcx>],\n ) -> Option<(usize, &'a Capture<'tcx>)> {\n     let hir_projections = convert_to_hir_projections_and_truncate_for_capture(projections);\n \n@@ -174,7 +175,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n     cx: &Builder<'_, 'tcx>,\n     var_hir_id: LocalVarId,\n     closure_def_id: LocalDefId,\n-    projection: &[PlaceElem<'tcx>],\n+    projection: &[UpvarProjectionElem<'tcx>],\n ) -> Option<PlaceBuilder<'tcx>> {\n     let Some((capture_index, capture)) =\n         find_capture_matching_projections(\n@@ -196,23 +197,32 @@ fn to_upvars_resolved_place_builder<'tcx>(\n                 var_hir_id, projection,\n             );\n         }\n+\n         return None;\n     };\n \n     // Access the capture by accessing the field within the Closure struct.\n     let capture_info = &cx.upvars[capture_index];\n \n-    let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n+    let Place { local: upvar_resolved_local, projection: local_projection } =\n+        capture_info.use_place;\n \n     // We used some of the projections to build the capture itself,\n     // now we apply the remaining to the upvar resolved place.\n-    trace!(?capture.captured_place, ?projection);\n-    let remaining_projections = strip_prefix(\n+    let upvar_projection = strip_prefix(\n         capture.captured_place.place.base_ty,\n         projection,\n         &capture.captured_place.place.projections,\n     );\n-    upvar_resolved_place_builder.projection.extend(remaining_projections);\n+\n+    let upvar_resolved_place_builder = PlaceBuilder::construct_local_place_builder(\n+        cx,\n+        upvar_resolved_local,\n+        local_projection.as_slice(),\n+        upvar_projection,\n+    );\n+\n+    assert!(matches!(upvar_resolved_place_builder, PlaceBuilder::Local { .. }));\n \n     Some(upvar_resolved_place_builder)\n }\n@@ -225,15 +235,17 @@ fn to_upvars_resolved_place_builder<'tcx>(\n /// projection kinds are unsupported.\n fn strip_prefix<'a, 'tcx>(\n     mut base_ty: Ty<'tcx>,\n-    projections: &'a [PlaceElem<'tcx>],\n+    projections: &'a [UpvarProjectionElem<'tcx>],\n     prefix_projections: &[HirProjection<'tcx>],\n-) -> impl Iterator<Item = PlaceElem<'tcx>> + 'a {\n+) -> impl Iterator<Item = UpvarProjectionElem<'tcx>> + 'a {\n     let mut iter = projections\n         .iter()\n         .copied()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n         .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n     for projection in prefix_projections {\n+        debug!(?projection, ?projection.ty);\n+\n         match projection.kind {\n             HirProjectionKind::Deref => {\n                 assert_matches!(iter.next(), Some(ProjectionElem::Deref));\n@@ -248,8 +260,10 @@ fn strip_prefix<'a, 'tcx>(\n                 bug!(\"unexpected projection kind: {:?}\", projection);\n             }\n         }\n+\n         base_ty = projection.ty;\n     }\n+\n     iter\n }\n \n@@ -262,9 +276,9 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     pub(in crate::build) fn try_to_place(&self, cx: &Builder<'_, 'tcx>) -> Option<Place<'tcx>> {\n         let resolved = self.resolve_upvar(cx);\n         let builder = resolved.as_ref().unwrap_or(self);\n-        let PlaceBase::Local(local) = builder.base else { return None };\n-        let projection = cx.tcx.intern_place_elems(&builder.projection);\n-        Some(Place { local, projection })\n+        let PlaceBuilder::Local{local, ref projection} = builder else { return None };\n+        let projection = cx.tcx.intern_place_elems(projection);\n+        Some(Place { local: *local, projection })\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -281,22 +295,31 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         &self,\n         cx: &Builder<'_, 'tcx>,\n     ) -> Option<PlaceBuilder<'tcx>> {\n-        let PlaceBase::Upvar { var_hir_id, closure_def_id } = self.base else {\n+        let PlaceBuilder::Upvar{ upvar: Upvar {var_hir_id, closure_def_id }, projection} = self else {\n             return None;\n         };\n-        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &self.projection)\n-    }\n \n-    pub(crate) fn base(&self) -> PlaceBase {\n-        self.base\n+        to_upvars_resolved_place_builder(cx, *var_hir_id, *closure_def_id, &projection)\n     }\n \n-    pub(crate) fn projection(&self) -> &[PlaceElem<'tcx>] {\n-        &self.projection\n-    }\n+    #[instrument(skip(cx), level = \"debug\")]\n+    pub(crate) fn field(self, cx: &Builder<'_, 'tcx>, f: Field) -> Self {\n+        match self.clone() {\n+            PlaceBuilder::Local { local, projection } => {\n+                let base_place = PlaceBuilder::Local { local, projection };\n+                let PlaceTy { ty, variant_index } =\n+                    base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n+                let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+\n+                let field_ty = PlaceBuilder::compute_field_ty(cx, f, base_ty, variant_index);\n \n-    pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n-        self.project(PlaceElem::Field(f, ty))\n+                self.project(ProjectionElem::Field(f, field_ty))\n+            }\n+            PlaceBuilder::Upvar { upvar, mut projection } => {\n+                projection.push(ProjectionElem::Field(f, ()));\n+                PlaceBuilder::Upvar { upvar, projection }\n+            }\n+        }\n     }\n \n     pub(crate) fn deref(self) -> Self {\n@@ -311,35 +334,236 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    pub(crate) fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n-        self.projection.push(elem);\n-        self\n+    #[instrument(level = \"debug\")]\n+    pub(crate) fn project(self, elem: PlaceElem<'tcx>) -> Self {\n+        let result = match self {\n+            PlaceBuilder::Local { local, mut projection } => {\n+                projection.push(elem);\n+                PlaceBuilder::Local { local, projection }\n+            }\n+            PlaceBuilder::Upvar { upvar, mut projection } => {\n+                projection.push(elem.into());\n+                PlaceBuilder::Upvar { upvar, projection }\n+            }\n+        };\n+\n+        debug!(?result);\n+        result\n     }\n \n     /// Same as `.clone().project(..)` but more efficient\n     pub(crate) fn clone_project(&self, elem: PlaceElem<'tcx>) -> Self {\n-        Self {\n-            base: self.base,\n-            projection: Vec::from_iter(self.projection.iter().copied().chain([elem])),\n+        match self {\n+            PlaceBuilder::Local { local, projection } => PlaceBuilder::Local {\n+                local: *local,\n+                projection: Vec::from_iter(projection.iter().copied().chain([elem.into()])),\n+            },\n+            PlaceBuilder::Upvar { upvar, projection } => PlaceBuilder::Upvar {\n+                upvar: *upvar,\n+                projection: Vec::from_iter(projection.iter().copied().chain([elem.into()])),\n+            },\n         }\n     }\n+\n+    /// Similar to `Place::ty` but needed during mir building.\n+    ///\n+    /// Applies the projections in the `PlaceBuilder` to the base\n+    /// type.\n+    ///\n+    /// Fallible as the root of this place may be an upvar for\n+    /// which no base type can be determined.\n+    #[instrument(skip(cx), level = \"debug\")]\n+    fn compute_field_ty(\n+        cx: &Builder<'_, 'tcx>,\n+        field: Field,\n+        base_ty: Ty<'tcx>,\n+        variant_index: Option<VariantIdx>,\n+    ) -> Ty<'tcx> {\n+        let field_idx = field.as_usize();\n+        let field_ty = match base_ty.kind() {\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                let variant_idx = variant_index.unwrap();\n+                adt_def.variant(variant_idx).fields[field_idx].ty(cx.tcx, substs)\n+            }\n+            ty::Adt(adt_def, substs) => adt_def\n+                .all_fields()\n+                .nth(field_idx)\n+                .unwrap_or_else(|| {\n+                    bug!(\n+                        \"expected to take field with idx {:?} of fields of {:?}\",\n+                        field_idx,\n+                        adt_def\n+                    )\n+                })\n+                .ty(cx.tcx, substs),\n+            ty::Tuple(elems) => elems.iter().nth(field_idx).unwrap_or_else(|| {\n+                bug!(\"expected to take field with idx {:?} of {:?}\", field_idx, elems)\n+            }),\n+            ty::Closure(_, substs) => {\n+                let substs = substs.as_closure();\n+                let Some(f_ty) = substs.upvar_tys().nth(field_idx) else {\n+                    bug!(\"expected to take field with idx {:?} of {:?}\", field_idx, substs.upvar_tys().collect::<Vec<_>>());\n+                };\n+\n+                f_ty\n+            }\n+            &ty::Generator(def_id, substs, _) => {\n+                if let Some(var) = variant_index {\n+                    let gen_body = cx.tcx.optimized_mir(def_id);\n+                    let Some(layout) = gen_body.generator_layout() else {\n+                        bug!(\"No generator layout for {:?}\", base_ty);\n+                    };\n+\n+                    let Some(&local) = layout.variant_fields[var].get(field) else {\n+                        bug!(\"expected to take field {:?} of {:?}\", field, layout.variant_fields[var]);\n+                    };\n+\n+                    let Some(&f_ty) = layout.field_tys.get(local) else {\n+                        bug!(\"expected to get element for {:?} in {:?}\", local, layout.field_tys);\n+                    };\n+\n+                    f_ty\n+                } else {\n+                    let Some(f_ty) = substs.as_generator().prefix_tys().nth(field.index()) else {\n+                        bug!(\n+                            \"expected to take index {:?} in {:?}\",\n+                            field.index(),\n+                            substs.as_generator().prefix_tys().collect::<Vec<_>>()\n+                        );\n+                    };\n+\n+                    f_ty\n+                }\n+            }\n+            _ => bug!(\"couldn't create field type, unexpected base type: {:?}\", base_ty),\n+        };\n+\n+        cx.tcx.normalize_erasing_regions(cx.param_env, field_ty)\n+    }\n+\n+    /// Creates a `PlaceBuilder::Local` from a `PlaceBuilder::Upvar` whose upvars\n+    /// are resolved. This function takes two kinds of projections: `local_projection`\n+    /// contains the projections of the captured upvar and `upvar_projection` the\n+    /// projections that are applied to the captured upvar. The main purpose of this\n+    /// function is to figure out the `Ty`s of the field projections in `upvar_projection`.\n+    #[instrument(skip(cx, local, upvar_projection))]\n+    fn construct_local_place_builder(\n+        cx: &Builder<'_, 'tcx>,\n+        local: Local,\n+        local_projection: &[PlaceElem<'tcx>],\n+        upvar_projection: impl Iterator<Item = UpvarProjectionElem<'tcx>>,\n+    ) -> Self {\n+        // We maintain a `Ty` to which we apply a projection in each iteration over `upvar_projection`.\n+        // This `ancestor_ty` let's us infer the field type whenever we encounter a\n+        // `ProjectionElem::Field`.\n+        let (mut ancestor_ty, mut opt_variant_idx) =\n+            local_projections_to_ty(cx, local, local_projection);\n+\n+        // We add all projection elements we encounter to this `Vec`.\n+        let mut local_projection = local_projection.to_vec();\n+\n+        for (i, proj) in upvar_projection.enumerate() {\n+            debug!(\"i: {:?}, proj: {:?}, local_projection: {:?}\", i, proj, local_projection);\n+            match proj {\n+                ProjectionElem::Field(field, _) => {\n+                    let field_ty =\n+                        PlaceBuilder::compute_field_ty(cx, field, ancestor_ty, opt_variant_idx);\n+                    debug!(?field_ty);\n+\n+                    local_projection.push(ProjectionElem::Field(field, field_ty));\n+                    ancestor_ty = field_ty;\n+                    opt_variant_idx = None;\n+                }\n+                _ => {\n+                    let proj = upvar_proj_to_place_elem_no_field_proj(proj);\n+                    (ancestor_ty, opt_variant_idx) = project_ty(cx.tcx, ancestor_ty, proj);\n+                    local_projection.push(proj);\n+                }\n+            }\n+        }\n+\n+        PlaceBuilder::Local { local, projection: local_projection }\n+    }\n }\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { base: PlaceBase::Local(local), projection: Vec::new() }\n+        Self::Local { local, projection: Vec::new() }\n     }\n }\n \n-impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n-    fn from(base: PlaceBase) -> Self {\n-        Self { base, projection: Vec::new() }\n+impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n+    fn from(p: Place<'tcx>) -> Self {\n+        Self::Local { local: p.local, projection: p.projection.to_vec() }\n     }\n }\n \n-impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n-    fn from(p: Place<'tcx>) -> Self {\n-        Self { base: PlaceBase::Local(p.local), projection: p.projection.to_vec() }\n+fn project_ty<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    ty: Ty<'tcx>,\n+    elem: PlaceElem<'tcx>,\n+) -> (Ty<'tcx>, Option<VariantIdx>) {\n+    match elem {\n+        ProjectionElem::Deref => {\n+            let updated_ty = ty\n+                .builtin_deref(true)\n+                .unwrap_or_else(|| bug!(\"deref projection of non-dereferenceable ty {:?}\", ty))\n+                .ty;\n+\n+            (updated_ty, None)\n+        }\n+        ProjectionElem::Index(_) | ProjectionElem::ConstantIndex { .. } => {\n+            (ty.builtin_index().unwrap(), None)\n+        }\n+        ProjectionElem::Subslice { from, to, from_end } => {\n+            let ty = match ty.kind() {\n+                ty::Slice(..) => ty,\n+                ty::Array(inner, _) if !from_end => tcx.mk_array(*inner, (to - from) as u64),\n+                ty::Array(inner, size) if from_end => {\n+                    let size = size.eval_usize(tcx, ty::ParamEnv::empty());\n+                    let len = size - (from as u64) - (to as u64);\n+                    tcx.mk_array(*inner, len)\n+                }\n+                _ => bug!(\"cannot subslice non-array type: `{:?}`\", ty),\n+            };\n+\n+            (ty, None)\n+        }\n+        ProjectionElem::Downcast(_, variant_idx) => (ty, Some(variant_idx)),\n+        ProjectionElem::Field(_, ty) => (ty, None),\n+        ProjectionElem::OpaqueCast(..) => bug!(\"didn't expect OpaqueCast\"),\n+    }\n+}\n+\n+fn local_projections_to_ty<'a, 'tcx>(\n+    cx: &'a Builder<'a, 'tcx>,\n+    local: Local,\n+    projection: &'a [PlaceElem<'tcx>],\n+) -> (Ty<'tcx>, Option<VariantIdx>) {\n+    let local_ty = cx.local_decls.local_decls()[local].ty;\n+    projection.iter().fold((local_ty, None), |ty_variant_idx, elem| {\n+        let ty = ty_variant_idx.0;\n+        project_ty(cx.tcx, ty, *elem)\n+    })\n+}\n+\n+// Converts an `UpvarProjectionElem` to `PlaceElem`, ICE'ing when being passed a\n+// field projection.\n+fn upvar_proj_to_place_elem_no_field_proj<'tcx>(\n+    upvar_proj: UpvarProjectionElem<'tcx>,\n+) -> PlaceElem<'tcx> {\n+    match upvar_proj {\n+        ProjectionElem::Deref => ProjectionElem::Deref,\n+        ProjectionElem::Index(i) => ProjectionElem::Index(i),\n+        ProjectionElem::ConstantIndex { offset, min_length, from_end } => {\n+            ProjectionElem::ConstantIndex { offset, min_length, from_end }\n+        }\n+        ProjectionElem::Subslice { from, to, from_end } => {\n+            ProjectionElem::Subslice { from, to, from_end }\n+        }\n+        ProjectionElem::Downcast(ty, variant_idx) => ProjectionElem::Downcast(ty, variant_idx),\n+        ProjectionElem::OpaqueCast(ty) => ProjectionElem::OpaqueCast(ty),\n+        ProjectionElem::Field(..) => bug!(\"should not be called with `ProjectionElem::Field`\"),\n     }\n }\n \n@@ -403,15 +627,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n+    #[instrument(skip(self, fake_borrow_temps), level = \"debug\")]\n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        debug!(\"expr_as_place(block={:?}, expr={:?}, mutability={:?})\", block, expr, mutability);\n-\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n@@ -425,12 +648,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let lhs = &this.thir[lhs];\n                 let mut place_builder =\n                     unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n+                debug!(?place_builder);\n                 if let ty::Adt(adt_def, _) = lhs.ty.kind() {\n                     if adt_def.is_enum() {\n                         place_builder = place_builder.downcast(*adt_def, variant_index);\n                     }\n                 }\n-                block.and(place_builder.field(name, expr.ty))\n+                block.and(place_builder.field(this, name))\n             }\n             ExprKind::Deref { arg } => {\n                 let place_builder = unpack!(\n@@ -572,15 +796,18 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Lower a captured upvar. Note we might not know the actual capture index,\n-    /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n+    /// so we create a place starting from `Upvar`, which will be resolved\n     /// once all projections that allow us to identify a capture have been applied.\n     fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n         closure_def_id: LocalDefId,\n         var_hir_id: LocalVarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        block.and(PlaceBuilder::from(PlaceBase::Upvar { var_hir_id, closure_def_id }))\n+        block.and(PlaceBuilder::Upvar {\n+            upvar: Upvar { var_hir_id, closure_def_id },\n+            projection: vec![],\n+        })\n     }\n \n     /// Lower an index expression\n@@ -671,8 +898,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.tcx;\n-\n         let place_ty = base_place.ty(&self.local_decls, tcx);\n+\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to"}, {"sha": "b420e820171482c8813dbf3b6defaeb4ca7079d1", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -4,9 +4,8 @@ use rustc_index::vec::Idx;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_target::abi::{Abi, Primitive};\n \n-use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n-use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary};\n+use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary, PlaceBuilder};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n@@ -651,15 +650,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let arg_place_builder = unpack!(block = this.as_place_builder(block, arg));\n \n-        let mutability = match arg_place_builder.base() {\n+        let mutability = match arg_place_builder {\n             // We are capturing a path that starts off a local variable in the parent.\n             // The mutability of the current capture is same as the mutability\n             // of the local declaration in the parent.\n-            PlaceBase::Local(local) => this.local_decls[local].mutability,\n+            PlaceBuilder::Local { local, .. } => this.local_decls[local].mutability,\n             // Parent is a closure and we are capturing a path that is captured\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n-            PlaceBase::Upvar { .. } => {\n+            PlaceBuilder::Upvar { .. } => {\n                 let enclosing_upvars_resolved = arg_place_builder.to_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {"}, {"sha": "895051d7590b58a2c1da71d3807ddb091e522b40", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -355,11 +355,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     // base-supplied field, generate an operand that\n                     // reads it from the base.\n                     iter::zip(field_names, &**field_types)\n-                        .map(|(n, ty)| match fields_map.get(&n) {\n+                        .map(|(n, _ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {\n-                                let place = place_builder.clone_project(PlaceElem::Field(n, *ty));\n-                                this.consume_by_copy_or_move(place.to_place(this))\n+                                let place_builder = place_builder.clone();\n+                                this.consume_by_copy_or_move(\n+                                    place_builder.field(this, n).to_place(this),\n+                                )\n                             }\n                         })\n                         .collect()"}, {"sha": "36aa7693e827ff3009026c32fd2b88c3a8c7b2af", "filename": "compiler/rustc_mir_build/src/build/matches/simplify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fsimplify.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -272,9 +272,9 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     || !adt_def.is_variant_list_non_exhaustive());\n                 if irrefutable {\n                     let place_builder = match_pair.place.downcast(adt_def, variant_index);\n-                    candidate\n-                        .match_pairs\n-                        .extend(self.field_match_pairs(place_builder, subpatterns));\n+                    let field_match_pairs =\n+                        self.field_match_pairs(place_builder.clone(), subpatterns);\n+                    candidate.match_pairs.extend(field_match_pairs);\n                     Ok(())\n                 } else {\n                     Err(match_pair)"}, {"sha": "65a027111d78910867ebbef8a125bb579c7b3eb2", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -758,8 +758,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = downcast_place\n-                .clone_project(PlaceElem::Field(subpattern.field, subpattern.pattern.ty));\n+            let place = downcast_place.clone().field(self, subpattern.field);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern, self)\n         });"}, {"sha": "d95dbfca78e847573464af63833f1deb680bce0e", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -1,4 +1,3 @@\n-use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n@@ -17,8 +16,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place =\n-                    place.clone_project(PlaceElem::Field(fieldpat.field, fieldpat.pattern.ty));\n+                let place = place.clone().field(self, fieldpat.field);\n+\n                 MatchPair::new(place, &fieldpat.pattern, self)\n             })\n             .collect()\n@@ -107,9 +106,9 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n \n         // Only add the OpaqueCast projection if the given place is an opaque type and the\n         // expected type from the pattern is not.\n-        let may_need_cast = match place.base() {\n-            PlaceBase::Local(local) => {\n-                let ty = Place::ty_from(local, place.projection(), &cx.local_decls, cx.tcx).ty;\n+        let may_need_cast = match place {\n+            PlaceBuilder::Local { local, ref projection } => {\n+                let ty = Place::ty_from(local, projection, &cx.local_decls, cx.tcx).ty;\n                 ty != pattern.ty && ty.has_opaque_types()\n             }\n             _ => true,"}, {"sha": "5cfbbb1ac01e773980cb20b726038875af7252cf", "filename": "compiler/rustc_mir_dataflow/src/move_paths/abs_domain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fabs_domain.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::Ty;\n pub struct AbstractOperand;\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub struct AbstractType;\n-pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType>;\n+pub type AbstractElem = ProjectionElem<AbstractOperand, AbstractType, AbstractType>;\n \n pub trait Lift {\n     type Abstract;"}, {"sha": "ab16b60f82df94df027c9b1d36e97f53c4492e1a", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -777,10 +777,10 @@ pub enum TrackElem {\n     Field(Field),\n }\n \n-impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n+impl<V, T1, T2> TryFrom<ProjectionElem<V, T1, T2>> for TrackElem {\n     type Error = ();\n \n-    fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n+    fn try_from(value: ProjectionElem<V, T1, T2>) -> Result<Self, Self::Error> {\n         match value {\n             ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n             _ => Err(()),"}, {"sha": "b5d6add043cb93520dbbe0887266cfa76735a693", "filename": "src/test/ui/mir/field-projection-invariant.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-projection-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-projection-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Ffield-projection-invariant.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -0,0 +1,24 @@\n+// build-pass\n+struct Inv<'a>(&'a mut &'a ());\n+enum Foo<T> {\n+    Bar,\n+    Var(T),\n+}\n+type Supertype = Foo<for<'a> fn(Inv<'a>, Inv<'a>)>;\n+\n+fn foo(x: Foo<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>) {\n+    match x {\n+        Supertype::Bar => {}\n+        Supertype::Var(x) => {}\n+    }\n+}\n+\n+fn foo_nested(x: Foo<Foo<for<'a, 'b> fn(Inv<'a>, Inv<'b>)>>) {\n+    match x {\n+        Foo::Bar => {}\n+        Foo::Var(Supertype::Bar) => {}\n+        Foo::Var(Supertype::Var(x)) => {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "179af617090635ade42d828a10a9082d732ee1e3", "filename": "src/test/ui/mir/field-ty-ascription-enums.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription-enums.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -0,0 +1,15 @@\n+// build-pass\n+\n+enum Foo<T> {\n+    Var(T),\n+} // `T` is covariant.\n+\n+fn foo<'b>(x: Foo<for<'a> fn(&'a ())>) {\n+    let Foo::Var(x): Foo<fn(&'b ())> = x;\n+}\n+\n+fn foo_nested<'b>(x: Foo<Foo<for<'a> fn(&'a ())>>) {\n+    let Foo::Var(Foo::Var(x)): Foo<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn main() {}"}, {"sha": "178c7916bc59fe9215672c29fa266918d40ff940", "filename": "src/test/ui/mir/field-ty-ascription.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03770f0e2b60c02db8fcf52fed5fb36aac70cedc/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmir%2Ffield-ty-ascription.rs?ref=03770f0e2b60c02db8fcf52fed5fb36aac70cedc", "patch": "@@ -0,0 +1,37 @@\n+// build-pass\n+\n+struct Foo<T>(T); // `T` is covariant.\n+\n+struct Bar<T> {\n+    x: T,\n+} // `T` is covariant.\n+\n+fn bar<'b>(x: Bar<for<'a> fn(&'a ())>) {\n+    let Bar { x }: Bar<fn(&'b ())> = x;\n+}\n+\n+fn bar_nested<'b>(x: Bar<Bar<for<'a> fn(&'a ())>>) {\n+    let Bar { x: Bar { x } }: Bar<Bar<fn(&'b ())>> = x;\n+}\n+\n+fn bar_foo_nested<'b>(x: Bar<Foo<for<'a> fn(&'a ())>>) {\n+    let Bar { x: Foo ( x ) }: Bar<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn foo<'b>(x: Foo<for<'a> fn(&'a ())>) {\n+    let Foo(y): Foo<fn(&'b ())> = x;\n+}\n+\n+fn foo_nested<'b>(x: Foo<Foo<for<'a> fn(&'a ())>>) {\n+    let Foo(Foo(y)): Foo<Foo<fn(&'b ())>> = x;\n+}\n+\n+fn tuple<'b>(x: (u32, for<'a> fn(&'a ()))) {\n+    let (_, y): (u32, fn(&'b ())) = x;\n+}\n+\n+fn tuple_nested<'b>(x: (u32, (u32, for<'a> fn(&'a ())))) {\n+    let (_, (_, y)): (u32, (u32, fn(&'b ()))) = x;\n+}\n+\n+fn main() {}"}]}