{"sha": "44675ac6aff91889f960655b0034964740415e8c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0Njc1YWM2YWZmOTE4ODlmOTYwNjU1YjAwMzQ5NjQ3NDA0MTVlOGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T03:29:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-13T03:29:22Z"}, "message": "auto merge of #8476 : thestinger/rust/snapshot, r=brson", "tree": {"sha": "ae4e089fc4b43d6cfb8e497a707e9a0f5118baae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae4e089fc4b43d6cfb8e497a707e9a0f5118baae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44675ac6aff91889f960655b0034964740415e8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44675ac6aff91889f960655b0034964740415e8c", "html_url": "https://github.com/rust-lang/rust/commit/44675ac6aff91889f960655b0034964740415e8c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44675ac6aff91889f960655b0034964740415e8c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9492d72baa73082be91edf8acd6bb97747db3c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9492d72baa73082be91edf8acd6bb97747db3c9", "html_url": "https://github.com/rust-lang/rust/commit/d9492d72baa73082be91edf8acd6bb97747db3c9"}, {"sha": "0cb0ef2ca5e4c0694f12ff1ca7d0a59d789b795b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cb0ef2ca5e4c0694f12ff1ca7d0a59d789b795b", "html_url": "https://github.com/rust-lang/rust/commit/0cb0ef2ca5e4c0694f12ff1ca7d0a59d789b795b"}], "stats": {"total": 772, "additions": 24, "deletions": 748}, "files": [{"sha": "10f1b330c5b55b7cd0032d840bb2d872abb04ca1", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -475,103 +475,6 @@ impl FormatOp {\n     }\n }\n \n-#[cfg(stage0)]\n-fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n-    let mut s = match val {\n-        Number(d) => {\n-            match op {\n-                FormatString => {\n-                    return Err(~\"non-number on stack with %s\")\n-                }\n-                _ => {\n-                    let radix = match op {\n-                        FormatDigit => 10,\n-                        FormatOctal => 8,\n-                        FormatHex|FormatHEX => 16,\n-                        FormatString => util::unreachable()\n-                    };\n-                    let mut s = ~[];\n-                    match op {\n-                        FormatDigit => {\n-                            let sign = if flags.sign { SignAll } else { SignNeg };\n-                            do int_to_str_bytes_common(d, radix, sign) |c| {\n-                                s.push(c);\n-                            }\n-                        }\n-                        _ => {\n-                            do int_to_str_bytes_common(d as uint, radix, SignNone) |c| {\n-                                s.push(c);\n-                            }\n-                        }\n-                    };\n-                    if flags.precision > s.len() {\n-                        let mut s_ = vec::with_capacity(flags.precision);\n-                        let n = flags.precision - s.len();\n-                        s_.grow(n, &('0' as u8));\n-                        s_.push_all_move(s);\n-                        s = s_;\n-                    }\n-                    assert!(!s.is_empty(), \"string conversion produced empty result\");\n-                    match op {\n-                        FormatDigit => {\n-                            if flags.space && !(s[0] == '-' as u8 || s[0] == '+' as u8) {\n-                                s.unshift(' ' as u8);\n-                            }\n-                        }\n-                        FormatOctal => {\n-                            if flags.alternate && s[0] != '0' as u8 {\n-                                s.unshift('0' as u8);\n-                            }\n-                        }\n-                        FormatHex => {\n-                            if flags.alternate {\n-                                let s_ = util::replace(&mut s, ~['0' as u8, 'x' as u8]);\n-                                s.push_all_move(s_);\n-                            }\n-                        }\n-                        FormatHEX => {\n-                            s = s.into_ascii().to_upper().into_bytes();\n-                            if flags.alternate {\n-                                let s_ = util::replace(&mut s, ~['0' as u8, 'X' as u8]);\n-                                s.push_all_move(s_);\n-                            }\n-                        }\n-                        FormatString => util::unreachable()\n-                    }\n-                    s\n-                }\n-            }\n-        }\n-        String(s) => {\n-            match op {\n-                FormatString => {\n-                    let mut s = s.as_bytes().to_owned();\n-                    if flags.precision > 0 && flags.precision < s.len() {\n-                        s.truncate(flags.precision);\n-                    }\n-                    s\n-                }\n-                _ => {\n-                    return Err(fmt!(\"non-string on stack with %%%c\", op.to_char()))\n-                }\n-            }\n-        }\n-    };\n-    if flags.width > s.len() {\n-        let n = flags.width - s.len();\n-        if flags.left {\n-            s.grow(n, &(' ' as u8));\n-        } else {\n-            let mut s_ = vec::with_capacity(flags.width);\n-            s_.grow(n, &(' ' as u8));\n-            s_.push_all_move(s);\n-            s = s_;\n-        }\n-    }\n-    Ok(s)\n-}\n-\n-#[cfg(not(stage0))]\n fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n     let mut s = match val {\n         Number(d) => {"}, {"sha": "22ed0b3cf3c8bfd354dd094a67791e1f860c8363", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -130,19 +130,6 @@ pub fn get_absolute_rpath(lib: &Path) -> Path {\n     os::make_absolute(lib).dir_path()\n }\n \n-#[cfg(stage0)]\n-pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n-    let install_prefix = env!(\"CFG_PREFIX\");\n-\n-    if install_prefix == \"\" {\n-        fail!(\"rustc compiled without CFG_PREFIX environment variable\");\n-    }\n-\n-    let tlib = filesearch::relative_target_lib_path(target_triple);\n-    os::make_absolute(&Path(install_prefix).push_rel(&tlib))\n-}\n-\n-#[cfg(not(stage0))]\n pub fn get_install_prefix_rpath(target_triple: &str) -> Path {\n     let install_prefix = env!(\"CFG_PREFIX\");\n "}, {"sha": "ca2e33b6a6dd5a9729a63fecfea75fa7d06edfff", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -578,25 +578,6 @@ pub fn build_target_config(sopts: @session::options,\n     return target_cfg;\n }\n \n-#[cfg(stage0)]\n-pub fn host_triple() -> ~str {\n-    // Get the host triple out of the build environment. This ensures that our\n-    // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n-    // normalize all ix86 architectures to i386.\n-    //\n-    // Instead of grabbing the host triple (for the current host), we grab (at\n-    // compile time) the target triple that this rustc is built with and\n-    // calling that (at runtime) the host triple.\n-    let ht = env!(\"CFG_COMPILER_TRIPLE\");\n-    return if ht != \"\" {\n-            ht.to_owned()\n-        } else {\n-            fail!(\"rustc built without CFG_COMPILER_TRIPLE\")\n-        };\n-}\n-\n-#[cfg(not(stage0))]\n pub fn host_triple() -> ~str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've"}, {"sha": "33d517f3981bb4f2f03d67b8a3ca7238311a83af", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -200,16 +200,6 @@ fn push_if_exists(vec: &mut ~[Path], p: &Path) {\n \n // The name of the directory rustc expects libraries to be located.\n // On Unix should be \"lib\", on windows \"bin\"\n-#[cfg(stage0)]\n-pub fn libdir() -> ~str {\n-   let libdir = env!(\"CFG_LIBDIR\");\n-   if libdir.is_empty() {\n-      fail!(\"rustc compiled without CFG_LIBDIR environment variable\");\n-   }\n-   libdir.to_owned()\n-}\n-\n-#[cfg(not(stage0))]\n pub fn libdir() -> ~str {\n     (env!(\"CFG_LIBDIR\")).to_owned()\n }"}, {"sha": "195ff0dc6b695ed4e5ef5f20c5ced41bf7465bc7", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -117,16 +117,6 @@ mod std {\n }\n */\n \n-#[cfg(stage0)]\n-pub fn version(argv0: &str) {\n-    let mut vers = ~\"unknown version\";\n-    let env_vers = env!(\"CFG_VERSION\");\n-    if env_vers.len() != 0 { vers = env_vers.to_owned(); }\n-    printfln!(\"%s %s\", argv0, vers);\n-    printfln!(\"host: %s\", host_triple());\n-}\n-\n-#[cfg(not(stage0))]\n pub fn version(argv0: &str) {\n     let vers = match option_env!(\"CFG_VERSION\") {\n         Some(vers) => vers,"}, {"sha": "9d1d6e65901ae267af396cc8d27cb4f0270f3fd6", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -165,20 +165,10 @@ mod tests {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[test]\n-    fn test_transmute2() {\n-        unsafe {\n-            assert_eq!(~[76u8, 0u8], transmute(~\"L\"));\n-        }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n             assert_eq!(~[76u8], transmute(~\"L\"));\n         }\n     }\n-\n }"}, {"sha": "2c18bd272e81785cdc1379d708322cb0f0786918", "filename": "src/libstd/io.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -1707,20 +1707,6 @@ pub fn with_bytes_writer(f: &fn(@Writer)) -> ~[u8] {\n     (*bytes).clone()\n }\n \n-#[cfg(stage0)]\n-pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n-    let mut v = with_bytes_writer(f);\n-\n-    // Make sure the vector has a trailing null and is proper utf8.\n-    v.push(0);\n-    assert!(str::is_utf8(v));\n-\n-    unsafe {\n-        ::cast::transmute(v)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn with_str_writer(f: &fn(@Writer)) -> ~str {\n     str::from_bytes(with_bytes_writer(f))\n }"}, {"sha": "3af1666b4dad3b4fbdaf13f5fd5741f600168a66", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 14, "deletions": 37, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -19,7 +19,6 @@ use cmp::{Eq, ApproxEq, Ord};\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::{Option, Some, None};\n-#[cfg(not(stage0))]\n use unstable::intrinsics;\n \n pub mod strconv;\n@@ -522,7 +521,6 @@ pub trait CheckedAdd: Add<Self, Self> {\n     fn checked_add(&self, v: &Self) -> Option<Self>;\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for i8 {\n     #[inline]\n     fn checked_add(&self, v: &i8) -> Option<i8> {\n@@ -533,7 +531,6 @@ impl CheckedAdd for i8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for i16 {\n     #[inline]\n     fn checked_add(&self, v: &i16) -> Option<i16> {\n@@ -544,7 +541,6 @@ impl CheckedAdd for i16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for i32 {\n     #[inline]\n     fn checked_add(&self, v: &i32) -> Option<i32> {\n@@ -555,7 +551,6 @@ impl CheckedAdd for i32 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for i64 {\n     #[inline]\n     fn checked_add(&self, v: &i64) -> Option<i64> {\n@@ -566,7 +561,7 @@ impl CheckedAdd for i64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedAdd for int {\n     #[inline]\n     fn checked_add(&self, v: &int) -> Option<int> {\n@@ -577,7 +572,7 @@ impl CheckedAdd for int {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedAdd for int {\n     #[inline]\n     fn checked_add(&self, v: &int) -> Option<int> {\n@@ -588,7 +583,6 @@ impl CheckedAdd for int {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for u8 {\n     #[inline]\n     fn checked_add(&self, v: &u8) -> Option<u8> {\n@@ -599,7 +593,6 @@ impl CheckedAdd for u8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for u16 {\n     #[inline]\n     fn checked_add(&self, v: &u16) -> Option<u16> {\n@@ -610,7 +603,6 @@ impl CheckedAdd for u16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for u32 {\n     #[inline]\n     fn checked_add(&self, v: &u32) -> Option<u32> {\n@@ -621,7 +613,6 @@ impl CheckedAdd for u32 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedAdd for u64 {\n     #[inline]\n     fn checked_add(&self, v: &u64) -> Option<u64> {\n@@ -632,7 +623,7 @@ impl CheckedAdd for u64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedAdd for uint {\n     #[inline]\n     fn checked_add(&self, v: &uint) -> Option<uint> {\n@@ -643,7 +634,7 @@ impl CheckedAdd for uint {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedAdd for uint {\n     #[inline]\n     fn checked_add(&self, v: &uint) -> Option<uint> {\n@@ -658,7 +649,6 @@ pub trait CheckedSub: Sub<Self, Self> {\n     fn checked_sub(&self, v: &Self) -> Option<Self>;\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for i8 {\n     #[inline]\n     fn checked_sub(&self, v: &i8) -> Option<i8> {\n@@ -669,7 +659,6 @@ impl CheckedSub for i8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for i16 {\n     #[inline]\n     fn checked_sub(&self, v: &i16) -> Option<i16> {\n@@ -680,7 +669,6 @@ impl CheckedSub for i16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for i32 {\n     #[inline]\n     fn checked_sub(&self, v: &i32) -> Option<i32> {\n@@ -691,7 +679,6 @@ impl CheckedSub for i32 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for i64 {\n     #[inline]\n     fn checked_sub(&self, v: &i64) -> Option<i64> {\n@@ -702,7 +689,7 @@ impl CheckedSub for i64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedSub for int {\n     #[inline]\n     fn checked_sub(&self, v: &int) -> Option<int> {\n@@ -713,7 +700,7 @@ impl CheckedSub for int {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedSub for int {\n     #[inline]\n     fn checked_sub(&self, v: &int) -> Option<int> {\n@@ -724,7 +711,6 @@ impl CheckedSub for int {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for u8 {\n     #[inline]\n     fn checked_sub(&self, v: &u8) -> Option<u8> {\n@@ -735,7 +721,6 @@ impl CheckedSub for u8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for u16 {\n     #[inline]\n     fn checked_sub(&self, v: &u16) -> Option<u16> {\n@@ -746,7 +731,6 @@ impl CheckedSub for u16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for u32 {\n     #[inline]\n     fn checked_sub(&self, v: &u32) -> Option<u32> {\n@@ -757,7 +741,6 @@ impl CheckedSub for u32 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedSub for u64 {\n     #[inline]\n     fn checked_sub(&self, v: &u64) -> Option<u64> {\n@@ -768,7 +751,7 @@ impl CheckedSub for u64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedSub for uint {\n     #[inline]\n     fn checked_sub(&self, v: &uint) -> Option<uint> {\n@@ -779,7 +762,7 @@ impl CheckedSub for uint {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedSub for uint {\n     #[inline]\n     fn checked_sub(&self, v: &uint) -> Option<uint> {\n@@ -794,7 +777,6 @@ pub trait CheckedMul: Mul<Self, Self> {\n     fn checked_mul(&self, v: &Self) -> Option<Self>;\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for i8 {\n     #[inline]\n     fn checked_mul(&self, v: &i8) -> Option<i8> {\n@@ -805,7 +787,6 @@ impl CheckedMul for i8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for i16 {\n     #[inline]\n     fn checked_mul(&self, v: &i16) -> Option<i16> {\n@@ -816,7 +797,6 @@ impl CheckedMul for i16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for i32 {\n     #[inline]\n     fn checked_mul(&self, v: &i32) -> Option<i32> {\n@@ -828,7 +808,7 @@ impl CheckedMul for i32 {\n }\n \n // FIXME: #8449: should not be disabled on 32-bit\n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedMul for i64 {\n     #[inline]\n     fn checked_mul(&self, v: &i64) -> Option<i64> {\n@@ -839,7 +819,7 @@ impl CheckedMul for i64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedMul for int {\n     #[inline]\n     fn checked_mul(&self, v: &int) -> Option<int> {\n@@ -850,7 +830,7 @@ impl CheckedMul for int {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedMul for int {\n     #[inline]\n     fn checked_mul(&self, v: &int) -> Option<int> {\n@@ -861,7 +841,6 @@ impl CheckedMul for int {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for u8 {\n     #[inline]\n     fn checked_mul(&self, v: &u8) -> Option<u8> {\n@@ -872,7 +851,6 @@ impl CheckedMul for u8 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for u16 {\n     #[inline]\n     fn checked_mul(&self, v: &u16) -> Option<u16> {\n@@ -883,7 +861,6 @@ impl CheckedMul for u16 {\n     }\n }\n \n-#[cfg(not(stage0))]\n impl CheckedMul for u32 {\n     #[inline]\n     fn checked_mul(&self, v: &u32) -> Option<u32> {\n@@ -895,7 +872,7 @@ impl CheckedMul for u32 {\n }\n \n // FIXME: #8449: should not be disabled on 32-bit\n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedMul for u64 {\n     #[inline]\n     fn checked_mul(&self, v: &u64) -> Option<u64> {\n@@ -906,7 +883,7 @@ impl CheckedMul for u64 {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"32\")]\n+#[cfg(target_word_size = \"32\")]\n impl CheckedMul for uint {\n     #[inline]\n     fn checked_mul(&self, v: &uint) -> Option<uint> {\n@@ -917,7 +894,7 @@ impl CheckedMul for uint {\n     }\n }\n \n-#[cfg(not(stage0), target_word_size = \"64\")]\n+#[cfg(target_word_size = \"64\")]\n impl CheckedMul for uint {\n     #[inline]\n     fn checked_mul(&self, v: &uint) -> Option<uint> {"}, {"sha": "96f3e480617ad8f0f56b8da4e8f5e9dfb6b8d19c", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -309,15 +309,6 @@ impl<T> RawPtr<T> for *T {\n     /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n     /// the object, or one-byte-past-the-end.\n     #[inline]\n-    #[cfg(stage0)]\n-    unsafe fn offset_inbounds(self, count: int) -> *T {\n-        intrinsics::offset(self, count)\n-    }\n-\n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end.\n-    #[inline]\n-    #[cfg(not(stage0))]\n     unsafe fn offset_inbounds(self, count: int) -> *T {\n         intrinsics::offset_inbounds(self, count)\n     }\n@@ -361,19 +352,6 @@ impl<T> RawPtr<T> for *mut T {\n     /// This method should be preferred over `offset` when the guarantee can be\n     /// satisfied, to enable better optimization.\n     #[inline]\n-    #[cfg(stage0)]\n-    unsafe fn offset_inbounds(self, count: int) -> *mut T {\n-        intrinsics::offset(self as *T, count) as *mut T\n-    }\n-\n-    /// Calculates the offset from a pointer. The offset *must* be in-bounds of\n-    /// the object, or one-byte-past-the-end. An arithmetic overflow is also\n-    /// undefined behaviour.\n-    ///\n-    /// This method should be preferred over `offset` when the guarantee can be\n-    /// satisfied, to enable better optimization.\n-    #[inline]\n-    #[cfg(not(stage0))]\n     unsafe fn offset_inbounds(self, count: int) -> *mut T {\n         intrinsics::offset_inbounds(self as *T, count) as *mut T\n     }"}, {"sha": "743a47a812aed10b2b78c30be715654809aa791d", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -158,18 +158,6 @@ impl ReprVisitor {\n     }\n \n     #[inline]\n-    #[cfg(stage0)]\n-    pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let u = ReprVisitor(ptr, self.writer);\n-            let v = reflect::MovePtrAdaptor(u);\n-            visit_tydesc(inner, @v as @TyVisitor);\n-            true\n-        }\n-    }\n-\n-    #[inline]\n-    #[cfg(not(stage0))]\n     pub fn visit_ptr_inner(&self, ptr: *c_void, inner: *TyDesc) -> bool {\n         unsafe {\n             let u = ReprVisitor(ptr, self.writer);\n@@ -568,18 +556,6 @@ impl TyVisitor for ReprVisitor {\n     fn visit_closure_ptr(&self, _ck: uint) -> bool { true }\n }\n \n-#[cfg(stage0)]\n-pub fn write_repr<T>(writer: @Writer, object: &T) {\n-    unsafe {\n-        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n-        let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor(ptr, writer);\n-        let v = reflect::MovePtrAdaptor(u);\n-        visit_tydesc(tydesc, @v as @TyVisitor)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n pub fn write_repr<T>(writer: @Writer, object: &T) {\n     unsafe {\n         let ptr = ptr::to_unsafe_ptr(object) as *c_void;"}, {"sha": "9e5f2db4092e8eea935bf43985358692730ccc7f", "filename": "src/libstd/str.rs", "status": "modified", "additions": 2, "deletions": 426, "changes": 428, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -33,8 +33,6 @@ use ptr;\n use ptr::RawPtr;\n use to_str::ToStr;\n use uint;\n-#[cfg(stage0)]\n-use unstable::raw::Repr;\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n \n@@ -92,25 +90,6 @@ pub fn from_bytes_owned(vv: ~[u8]) -> ~str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n-#[cfg(stage0)]\n-pub fn from_bytes_slice<'a>(vector: &'a [u8]) -> &'a str {\n-    unsafe {\n-        assert!(is_utf8(vector));\n-        let mut s = vector.repr();\n-        s.len += 1;\n-        cast::transmute(s)\n-    }\n-}\n-\n-/// Converts a vector to a string slice without performing any allocations.\n-///\n-/// Once the slice has been validated as utf-8, it is transmuted in-place and\n-/// returned as a '&str' instead of a '&[u8]'\n-///\n-/// # Failure\n-///\n-/// Fails if invalid UTF-8\n-#[cfg(not(stage0))]\n pub fn from_bytes_slice<'a>(v: &'a [u8]) -> &'a str {\n     assert!(is_utf8(v));\n     unsafe { cast::transmute(v) }\n@@ -134,18 +113,6 @@ impl ToStr for @str {\n /// # Failure\n ///\n /// Fails if invalid UTF-8\n-#[cfg(stage0)]\n-pub fn from_byte(b: u8) -> ~str {\n-    assert!(b < 128u8);\n-    unsafe { cast::transmute(~[b, 0u8]) }\n-}\n-\n-/// Convert a byte to a UTF-8 string\n-///\n-/// # Failure\n-///\n-/// Fails if invalid UTF-8\n-#[cfg(not(stage0))]\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n     unsafe { ::cast::transmute(~[b]) }\n@@ -181,32 +148,6 @@ pub trait StrVector {\n \n impl<'self, S: Str> StrVector for &'self [S] {\n     /// Concatenate a vector of strings.\n-    #[cfg(stage0)]\n-    pub fn concat(&self) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n-\n-        let len = self.iter().map(|s| s.as_slice().len()).sum();\n-\n-        let mut s = with_capacity(len);\n-\n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                let mut buf = buf;\n-                for ss in self.iter() {\n-                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                        let sslen = sslen - 1;\n-                        ptr::copy_memory(buf, ssbuf, sslen);\n-                        buf = buf.offset(sslen as int);\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-\n-    /// Concatenate a vector of strings.\n-    #[cfg(not(stage0))]\n     pub fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -230,48 +171,6 @@ impl<'self, S: Str> StrVector for &'self [S] {\n     }\n \n     /// Concatenate a vector of strings, placing a given separator between each.\n-    #[cfg(stage0)]\n-    pub fn connect(&self, sep: &str) -> ~str {\n-        if self.is_empty() { return ~\"\"; }\n-\n-        // concat is faster\n-        if sep.is_empty() { return self.concat(); }\n-\n-        // this is wrong without the guarantee that `self` is non-empty\n-        let len = sep.len() * (self.len() - 1)\n-            + self.iter().map(|s| s.as_slice().len()).sum();\n-        let mut s = ~\"\";\n-        let mut first = true;\n-\n-        s.reserve(len);\n-\n-        unsafe {\n-            do s.as_mut_buf |buf, _| {\n-                do sep.as_imm_buf |sepbuf, seplen| {\n-                    let seplen = seplen - 1;\n-                    let mut buf = cast::transmute_mut_unsafe(buf);\n-                    for ss in self.iter() {\n-                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n-                            let sslen = sslen - 1;\n-                            if first {\n-                                first = false;\n-                            } else {\n-                                ptr::copy_memory(buf, sepbuf, seplen);\n-                                buf = buf.offset(seplen as int);\n-                            }\n-                            ptr::copy_memory(buf, ssbuf, sslen);\n-                            buf = buf.offset(sslen as int);\n-                        }\n-                    }\n-                }\n-            }\n-            raw::set_len(&mut s, len);\n-        }\n-        s\n-    }\n-\n-    /// Concatenate a vector of strings, placing a given separator between each.\n-    #[cfg(not(stage0))]\n     pub fn connect(&self, sep: &str) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -578,26 +477,7 @@ Section: Comparing strings\n */\n \n /// Bytewise slice equality\n-#[cfg(not(test), stage0)]\n-#[lang=\"str_eq\"]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 (alen - 1) as libc::size_t) == 0\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n@@ -616,26 +496,7 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n }\n \n /// Bytewise slice equality\n-#[cfg(test, stage0)]\n-#[lang=\"str_eq\"]\n-#[inline]\n-pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_imm_buf |ap, alen| {\n-        do b.as_imm_buf |bp, blen| {\n-            if (alen != blen) { false }\n-            else {\n-                unsafe {\n-                    libc::memcmp(ap as *libc::c_void,\n-                                 bp as *libc::c_void,\n-                                 (alen - 1) as libc::size_t) == 0\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Bytewise slice equality\n-#[cfg(test, not(stage0))]\n+#[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n     do a.as_imm_buf |ap, alen| {\n@@ -807,17 +668,6 @@ pub fn from_utf16(v: &[u16]) -> ~str {\n \n /// Allocates a new string with the specified capacity. The string returned is\n /// the empty string, but has capacity for much more.\n-#[cfg(stage0)]\n-#[inline]\n-pub fn with_capacity(capacity: uint) -> ~str {\n-    let mut buf = ~\"\";\n-    buf.reserve(capacity);\n-    buf\n-}\n-\n-/// Allocates a new string with the specified capacity. The string returned is\n-/// the empty string, but has capacity for much more.\n-#[cfg(not(stage0))]\n #[inline]\n pub fn with_capacity(capacity: uint) -> ~str {\n     unsafe {\n@@ -929,25 +779,8 @@ pub mod raw {\n     use vec;\n     use vec::MutableVector;\n     use unstable::raw::Slice;\n-    #[cfg(stage0)]\n-    use unstable::raw::String;\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    #[cfg(stage0)]\n-    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n-        let mut v: ~[u8] = vec::with_capacity(len + 1);\n-        v.as_mut_buf(|vbuf, _len| {\n-            ptr::copy_memory(vbuf, buf as *u8, len)\n-        });\n-        vec::raw::set_len(&mut v, len);\n-        v.push(0u8);\n-\n-        assert!(is_utf8(v));\n-        cast::transmute(v)\n-    }\n-\n-    /// Create a Rust string from a *u8 buffer of the given length\n-    #[cfg(not(stage0))]\n     pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len);\n         do v.as_mut_buf |vbuf, _len| {\n@@ -987,15 +820,6 @@ pub mod raw {\n \n     /// Converts an owned vector of bytes to a new owned string. This assumes\n     /// that the utf-8-ness of the vector has already been validated\n-    #[cfg(stage0)]\n-    pub unsafe fn from_bytes_owned(mut v: ~[u8]) -> ~str {\n-        v.push(0u8);\n-        cast::transmute(v)\n-    }\n-\n-    /// Converts an owned vector of bytes to a new owned string. This assumes\n-    /// that the utf-8-ness of the vector has already been validated\n-    #[cfg(not(stage0))]\n     #[inline]\n     pub unsafe fn from_bytes_owned(v: ~[u8]) -> ~str {\n         cast::transmute(v)\n@@ -1007,24 +831,6 @@ pub mod raw {\n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n     /// invalidated later.\n-    #[cfg(stage0)]\n-    pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n-        let s = s as *u8;\n-        let mut curr = s;\n-        let mut len = 0u;\n-        while *curr != 0u8 {\n-            len += 1u;\n-            curr = ptr::offset(s, len as int);\n-        }\n-        let v = Slice { data: s, len: len + 1 };\n-        assert!(is_utf8(cast::transmute(v)));\n-        cast::transmute(v)\n-    }\n-\n-    /// Form a slice from a C string. Unsafe because the caller must ensure the\n-    /// C string has the static lifetime, or else the return value may be\n-    /// invalidated later.\n-    #[cfg(not(stage0))]\n     pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n         let mut curr = s;\n@@ -1046,29 +852,6 @@ pub mod raw {\n     ///\n     /// If begin is greater than end.\n     /// If end is greater than the length of the string.\n-    #[cfg(stage0)]\n-    #[inline]\n-    pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n-        do s.as_imm_buf |sbuf, n| {\n-             assert!((begin <= end));\n-             assert!((end <= n));\n-\n-             cast::transmute(Slice {\n-                 data: ptr::offset(sbuf, begin as int),\n-                 len: end - begin + 1,\n-             })\n-        }\n-    }\n-\n-    /// Takes a bytewise (not UTF-8) slice from a string.\n-    ///\n-    /// Returns the substring from [`begin`..`end`).\n-    ///\n-    /// # Failure\n-    ///\n-    /// If begin is greater than end.\n-    /// If end is greater than the length of the string.\n-    #[cfg(not(stage0))]\n     #[inline]\n     pub unsafe fn slice_bytes<'a>(s: &'a str, begin: uint, end: uint) -> &'a str {\n         do s.as_imm_buf |sbuf, n| {\n@@ -1083,18 +866,6 @@ pub mod raw {\n     }\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n-    #[cfg(stage0)]\n-    pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        let new_len = s.len() + 1;\n-        s.reserve_at_least(new_len);\n-        do s.as_mut_buf |buf, len| {\n-            *ptr::mut_offset(buf, len as int) = b;\n-        }\n-        set_len(&mut *s, new_len);\n-    }\n-\n-    /// Appends a byte to a string. (Not UTF-8 safe).\n-    #[cfg(not(stage0))]\n     #[inline]\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let v: &mut ~[u8] = cast::transmute(s);\n@@ -1126,23 +897,11 @@ pub mod raw {\n         return b;\n     }\n \n-    /// Sets the length of the string and adds the null terminator\n-    #[cfg(stage0)]\n-    #[inline]\n-    pub unsafe fn set_len(v: &mut ~str, new_len: uint) {\n-        let v: **mut String = cast::transmute(v);\n-        let repr = *v;\n-        (*repr).fill = new_len + 1u;\n-        let null = ptr::mut_offset(&mut ((*repr).data), new_len as int);\n-        *null = 0u8;\n-    }\n-\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n     /// modifing its buffers, so it is up to the caller to ensure that\n     /// the string is actually the specified size.\n-    #[cfg(not(stage0))]\n     #[inline]\n     pub unsafe fn set_len(s: &mut ~str, new_len: uint) {\n         let v: &mut ~[u8] = cast::transmute(s);\n@@ -1331,13 +1090,6 @@ impl<'self> Str for @str {\n }\n \n impl<'self> Container for &'self str {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn len(&self) -> uint {\n-        do self.as_imm_buf |_p, n| { n - 1u }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn len(&self) -> uint {\n         do self.as_imm_buf |_p, n| { n }\n@@ -1815,26 +1567,6 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Copy a slice into a new unique str\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn to_owned(&self) -> ~str {\n-        do self.as_imm_buf |src, len| {\n-            assert!(len > 0);\n-            unsafe {\n-                let mut v = vec::with_capacity(len);\n-\n-                do v.as_mut_buf |dst, _| {\n-                    ptr::copy_memory(dst, src, len - 1);\n-                }\n-                vec::raw::set_len(&mut v, len - 1);\n-                v.push(0u8);\n-                ::cast::transmute(v)\n-            }\n-        }\n-    }\n-\n-    /// Copy a slice into a new unique str\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn to_owned(&self) -> ~str {\n         do self.as_imm_buf |src, len| {\n@@ -1850,16 +1582,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    fn to_managed(&self) -> @str {\n-        let v = at_vec::from_fn(self.len() + 1, |i| {\n-            if i == self.len() { 0 } else { self[i] }\n-        });\n-        unsafe { cast::transmute(v) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn to_managed(&self) -> @str {\n         unsafe {\n@@ -2008,19 +1730,6 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// Work with the byte buffer of a string as a byte slice.\n     ///\n     /// The byte slice does not include the null terminator.\n-    #[cfg(stage0)]\n-    fn as_bytes(&self) -> &'self [u8] {\n-        unsafe {\n-            let mut slice = self.repr();\n-            slice.len -= 1;\n-            cast::transmute(slice)\n-        }\n-    }\n-\n-    /// Work with the byte buffer of a string as a byte slice.\n-    ///\n-    /// The byte slice does not include the null terminator.\n-    #[cfg(not(stage0))]\n     fn as_bytes(&self) -> &'self [u8] {\n         unsafe { cast::transmute(*self) }\n     }\n@@ -2091,30 +1800,6 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     /// Given a string, make a new string with repeated copies of it.\n-    #[cfg(stage0)]\n-    fn repeat(&self, nn: uint) -> ~str {\n-        do self.as_imm_buf |buf, len| {\n-            // ignore the NULL terminator\n-            let len = len - 1;\n-            let mut ret = with_capacity(nn * len);\n-\n-            unsafe {\n-                do ret.as_mut_buf |rbuf, _len| {\n-                    let mut rbuf = rbuf;\n-\n-                    do nn.times {\n-                        ptr::copy_memory(rbuf, buf, len);\n-                        rbuf = rbuf.offset(len as int);\n-                    }\n-                }\n-                raw::set_len(&mut ret, nn * len);\n-            }\n-            ret\n-        }\n-    }\n-\n-    /// Given a string, make a new string with repeated copies of it.\n-    #[cfg(not(stage0))]\n     fn repeat(&self, nn: uint) -> ~str {\n         do self.as_imm_buf |buf, len| {\n             let mut ret = with_capacity(nn * len);\n@@ -2250,8 +1935,6 @@ pub trait OwnedStr {\n     fn reserve(&mut self, n: uint);\n     fn reserve_at_least(&mut self, n: uint);\n     fn capacity(&self) -> uint;\n-    #[cfg(stage0)]\n-    fn to_bytes_with_null(self) -> ~[u8];\n \n     /// Work with the mutable byte buffer and length of a slice.\n     ///\n@@ -2397,30 +2080,6 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    #[cfg(stage0)]\n-    #[inline]\n-    pub fn reserve(&mut self, n: uint) {\n-        unsafe {\n-            let v: *mut ~[u8] = cast::transmute(self);\n-            (*v).reserve(n + 1);\n-        }\n-    }\n-\n-    /// Reserves capacity for exactly `n` bytes in the given string, not including\n-    /// the null terminator.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`. To account for the null terminator,\n-    /// the underlying buffer will have the size `n` + 1.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n-    #[cfg(not(stage0))]\n     #[inline]\n     pub fn reserve(&mut self, n: uint) {\n         unsafe {\n@@ -2429,30 +2088,6 @@ impl OwnedStr for ~str {\n         }\n     }\n \n-    /// Reserves capacity for at least `n` bytes in the given string, not including\n-    /// the null terminator.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`. To account for the null terminator,\n-    /// the underlying buffer will have the size `n` + 1.\n-    ///\n-    /// This function will over-allocate in order to amortize the allocation costs\n-    /// in scenarios where the caller may need to repeatedly reserve additional\n-    /// space.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn reserve_at_least(&mut self, n: uint) {\n-        self.reserve(uint::next_power_of_two(n + 1u) - 1u)\n-    }\n-\n     /// Reserves capacity for at least `n` bytes in the given string.\n     ///\n     /// Assuming single-byte characters, the resulting string will be large\n@@ -2470,40 +2105,20 @@ impl OwnedStr for ~str {\n     ///\n     /// * s - A string\n     /// * n - The number of bytes to reserve space for\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn reserve_at_least(&mut self, n: uint) {\n         self.reserve(uint::next_power_of_two(n))\n     }\n \n     /// Returns the number of single-byte characters the string can hold without\n     /// reallocating\n-    #[cfg(stage0)]\n-    fn capacity(&self) -> uint {\n-        let buf: &~[u8] = unsafe { cast::transmute(self) };\n-        let vcap = buf.capacity();\n-        assert!(vcap > 0u);\n-        vcap - 1u\n-    }\n-\n-    /// Returns the number of single-byte characters the string can hold without\n-    /// reallocating\n-    #[cfg(not(stage0))]\n     fn capacity(&self) -> uint {\n         unsafe {\n             let buf: &~[u8] = cast::transmute(self);\n             buf.capacity()\n         }\n     }\n \n-    /// Convert to a vector of bytes. This does not allocate a new\n-    /// string, and includes the null terminator.\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn to_bytes_with_null(self) -> ~[u8] {\n-        unsafe { cast::transmute(self) }\n-    }\n-\n     #[inline]\n     fn as_mut_buf<T>(&mut self, f: &fn(*mut u8, uint) -> T) -> T {\n         let v: &mut ~[u8] = unsafe { cast::transmute(self) };\n@@ -3208,45 +2823,6 @@ mod tests {\n         assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n     }\n \n-    #[cfg(stage0)]\n-    #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_as_bytes_fail() {\n-        // Don't double free. (I'm not sure if this exercises the\n-        // original problem code path anymore.)\n-        let s = ~\"\";\n-        let _bytes = s.as_bytes();\n-        fail!();\n-    }\n-\n-    #[cfg(stage0)]\n-    #[test]\n-    #[ignore(cfg(windows))]\n-    #[should_fail]\n-    fn test_as_bytes_fail() {\n-        // Don't double free. (I'm not sure if this exercises the\n-        // original problem code path anymore.)\n-        let s = ~\"\";\n-        let _bytes = s.as_bytes_with_null();\n-        fail!();\n-    }\n-\n-    #[cfg(stage0)]\n-    #[test]\n-    fn test_to_bytes_with_null() {\n-        let s = ~\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        let v = ~[\n-            224, 184, 168, 224, 185, 132, 224, 184, 151, 224, 184, 162, 228,\n-            184, 173, 229, 141, 142, 86, 105, 225, 187, 135, 116, 32, 78, 97,\n-            109, 0\n-        ];\n-        assert_eq!((~\"\").to_bytes_with_null(), ~[0]);\n-        assert_eq!((~\"abc\").to_bytes_with_null(),\n-                   ~['a' as u8, 'b' as u8, 'c' as u8, 0]);\n-        assert_eq!(s.to_bytes_with_null(), v);\n-    }\n-\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]"}, {"sha": "701d57388158bd0697ebf030911c86ef95b39630", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -19,8 +19,6 @@ use cast;\n use ptr;\n use iterator::Iterator;\n use vec::{CopyableVector, ImmutableVector};\n-#[cfg(stage0)]\n-use vec::OwnedVector;\n use to_bytes::IterBytes;\n use option::{Some, None};\n \n@@ -105,14 +103,6 @@ impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n         unsafe { self.to_ascii_nocheck() }\n     }\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n-        let (p,len): (*u8, uint) = cast::transmute(*self);\n-        cast::transmute((p, len - 1))\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n         cast::transmute(*self)\n@@ -190,15 +180,6 @@ impl OwnedAsciiCast for ~str {\n         unsafe {self.into_ascii_nocheck()}\n     }\n \n-    #[cfg(stage0)]\n-    #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n-        let mut r: ~[Ascii] = cast::transmute(self);\n-        r.pop();\n-        r\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     unsafe fn into_ascii_nocheck(self) -> ~[Ascii] {\n         cast::transmute(self)\n@@ -221,15 +202,6 @@ pub trait AsciiStr {\n }\n \n impl<'self> AsciiStr for &'self [Ascii] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn to_str_ascii(&self) -> ~str {\n-        let mut cpy = self.to_owned();\n-        cpy.push(0u8.to_ascii());\n-        unsafe { cast::transmute(cpy) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn to_str_ascii(&self) -> ~str {\n         let cpy = self.to_owned();\n@@ -253,15 +225,6 @@ impl<'self> AsciiStr for &'self [Ascii] {\n }\n \n impl ToStrConsume for ~[Ascii] {\n-    #[cfg(stage0)]\n-    #[inline]\n-    fn into_str(self) -> ~str {\n-        let mut cpy = self;\n-        cpy.push(0u8.to_ascii());\n-        unsafe { cast::transmute(cpy) }\n-    }\n-\n-    #[cfg(not(stage0))]\n     #[inline]\n     fn into_str(self) -> ~str {\n         unsafe { cast::transmute(self) }"}, {"sha": "861b4f9a350dcb7c8c0c7c63a3360b44a55c24dc", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -328,10 +328,6 @@ extern \"rust-intrinsic\" {\n     /// Returns `true` if a type is managed (will be allocated on the local heap)\n     pub fn contains_managed<T>() -> bool;\n \n-    #[cfg(stage0)]\n-    pub fn visit_tydesc(td: *TyDesc, tv: @TyVisitor);\n-\n-    #[cfg(not(stage0))]\n     pub fn visit_tydesc(td: *TyDesc, tv: &TyVisitor);\n \n     pub fn frame_address(f: &once fn(*u8));\n@@ -351,7 +347,6 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic should be preferred over `offset` when the guarantee can\n     /// be satisfied, to enable better optimization.\n-    #[cfg(not(stage0))]\n     pub fn offset_inbounds<T>(dst: *T, offset: int) -> *T;\n \n     /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic, with a size of\n@@ -451,58 +446,34 @@ extern \"rust-intrinsic\" {\n     pub fn bswap32(x: i32) -> i32;\n     pub fn bswap64(x: i64) -> i64;\n \n-    #[cfg(not(stage0))]\n     pub fn i8_add_with_overflow(x: i8, y: i8) -> (i8, bool);\n-    #[cfg(not(stage0))]\n     pub fn i16_add_with_overflow(x: i16, y: i16) -> (i16, bool);\n-    #[cfg(not(stage0))]\n     pub fn i32_add_with_overflow(x: i32, y: i32) -> (i32, bool);\n-    #[cfg(not(stage0))]\n     pub fn i64_add_with_overflow(x: i64, y: i64) -> (i64, bool);\n \n-    #[cfg(not(stage0))]\n     pub fn u8_add_with_overflow(x: u8, y: u8) -> (u8, bool);\n-    #[cfg(not(stage0))]\n     pub fn u16_add_with_overflow(x: u16, y: u16) -> (u16, bool);\n-    #[cfg(not(stage0))]\n     pub fn u32_add_with_overflow(x: u32, y: u32) -> (u32, bool);\n-    #[cfg(not(stage0))]\n     pub fn u64_add_with_overflow(x: u64, y: u64) -> (u64, bool);\n \n-    #[cfg(not(stage0))]\n     pub fn i8_sub_with_overflow(x: i8, y: i8) -> (i8, bool);\n-    #[cfg(not(stage0))]\n     pub fn i16_sub_with_overflow(x: i16, y: i16) -> (i16, bool);\n-    #[cfg(not(stage0))]\n     pub fn i32_sub_with_overflow(x: i32, y: i32) -> (i32, bool);\n-    #[cfg(not(stage0))]\n     pub fn i64_sub_with_overflow(x: i64, y: i64) -> (i64, bool);\n \n-    #[cfg(not(stage0))]\n     pub fn u8_sub_with_overflow(x: u8, y: u8) -> (u8, bool);\n-    #[cfg(not(stage0))]\n     pub fn u16_sub_with_overflow(x: u16, y: u16) -> (u16, bool);\n-    #[cfg(not(stage0))]\n     pub fn u32_sub_with_overflow(x: u32, y: u32) -> (u32, bool);\n-    #[cfg(not(stage0))]\n     pub fn u64_sub_with_overflow(x: u64, y: u64) -> (u64, bool);\n \n-    #[cfg(not(stage0))]\n     pub fn i8_mul_with_overflow(x: i8, y: i8) -> (i8, bool);\n-    #[cfg(not(stage0))]\n     pub fn i16_mul_with_overflow(x: i16, y: i16) -> (i16, bool);\n-    #[cfg(not(stage0))]\n     pub fn i32_mul_with_overflow(x: i32, y: i32) -> (i32, bool);\n-    #[cfg(not(stage0))]\n     pub fn i64_mul_with_overflow(x: i64, y: i64) -> (i64, bool);\n \n-    #[cfg(not(stage0))]\n     pub fn u8_mul_with_overflow(x: u8, y: u8) -> (u8, bool);\n-    #[cfg(not(stage0))]\n     pub fn u16_mul_with_overflow(x: u16, y: u16) -> (u16, bool);\n-    #[cfg(not(stage0))]\n     pub fn u32_mul_with_overflow(x: u32, y: u32) -> (u32, bool);\n-    #[cfg(not(stage0))]\n     pub fn u64_mul_with_overflow(x: u64, y: u64) -> (u64, bool);\n }\n "}, {"sha": "987434b424e9cea4a4bfa2b1e552d88114f06c6a", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44675ac6aff91889f960655b0034964740415e8c/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/44675ac6aff91889f960655b0034964740415e8c/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=44675ac6aff91889f960655b0034964740415e8c", "patch": "@@ -1,3 +1,11 @@\n+S 2013-08-12 ecfc9a8\n+  freebsd-x86_64 ae903580d6328b8517dc64b013c1b0740bfa4e83\n+  linux-i386 3076bf032ce980157a894a0a4446902ba8b1783d\n+  linux-x86_64 241090d135e1ce95f0b17a198c194d29cd917bb1\n+  macos-i386 15a749ed891bfaad9515d01391fbcd1788d9adc6\n+  macos-x86_64 037e007d82dffdf3c8dfddaa6837ace821a1d3d5\n+  winnt-i386 d1272610ac2b7b938a5d992b61947aed7e4ebc3d\n+\n S 2013-08-03 18e3db7\n   freebsd-x86_64 addf91b20416bf21a7c53ea9508bc302ec957ce9\n   linux-i386 ce103c323c0a0b75d1307014f1d6f8ff4d03c873"}]}