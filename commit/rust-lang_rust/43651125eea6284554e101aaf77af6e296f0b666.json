{"sha": "43651125eea6284554e101aaf77af6e296f0b666", "node_id": "C_kwDOAAsO6NoAKDQzNjUxMTI1ZWVhNjI4NDU1NGUxMDFhYWY3N2FmNmUyOTZmMGI2NjY", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-11T23:45:45Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2021-11-24T20:06:47Z"}, "message": "Remove `ResolvedPath.did`", "tree": {"sha": "1d4aed9fb0becef639c9686b3984c84abb8d4b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d4aed9fb0becef639c9686b3984c84abb8d4b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43651125eea6284554e101aaf77af6e296f0b666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43651125eea6284554e101aaf77af6e296f0b666", "html_url": "https://github.com/rust-lang/rust/commit/43651125eea6284554e101aaf77af6e296f0b666", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43651125eea6284554e101aaf77af6e296f0b666/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db4a06e9bdbfc808e60b06b357c35481a91fc8e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4a06e9bdbfc808e60b06b357c35481a91fc8e6", "html_url": "https://github.com/rust-lang/rust/commit/db4a06e9bdbfc808e60b06b357c35481a91fc8e6"}], "stats": {"total": 59, "additions": 29, "deletions": 30}, "files": [{"sha": "5c893e44a9fc3bc28ab040ba62309a40843e1ede", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -1411,12 +1411,12 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, did, false, vec![], substs);\n-                ResolvedPath { path, did }\n+                ResolvedPath { path }\n             }\n             ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n                 let path = external_path(cx, did, false, vec![], InternalSubsts::empty());\n-                ResolvedPath { path, did }\n+                ResolvedPath { path }\n             }\n             ty::Dynamic(obj, ref reg) => {\n                 // HACK: pick the first `did` as the `did` of the trait object. Someone"}, {"sha": "9e088ac72ad2fbf13731e5b17fb78ddac5dbbe05", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -1419,7 +1419,7 @@ crate enum Type {\n     /// A named type, which could be a trait.\n     ///\n     /// This is mostly Rustdoc's version of [`hir::Path`]. It has to be different because Rustdoc's [`PathSegment`] can contain cleaned generics.\n-    ResolvedPath { path: Path, did: DefId },\n+    ResolvedPath { path: Path },\n     /// A `dyn Trait` object: `dyn for<'a> Trait<'a> + Send + 'static`\n     DynTrait(Vec<PolyTrait>, Option<Lifetime>),\n     /// A type parameter.\n@@ -1522,7 +1522,7 @@ impl Type {\n \n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n-            ResolvedPath { ref path, did: _ } => return Some(path.def_id()),\n+            ResolvedPath { ref path } => return Some(path.def_id()),\n             DynTrait(ref bounds, _) => return Some(bounds[0].trait_.def_id()),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,"}, {"sha": "2976dd8f65aef044f38022c58aae99ac08917496", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -187,7 +187,8 @@ crate fn build_deref_target_impls(cx: &mut DocContext<'_>, items: &[Item], ret:\n             for &did in prim.impls(tcx).iter().filter(|did| !did.is_local()) {\n                 inline::build_impl(cx, None, did, None, ret);\n             }\n-        } else if let ResolvedPath { did, .. } = *target {\n+        } else if let ResolvedPath { path } = target {\n+            let did = path.def_id();\n             if !did.is_local() {\n                 inline::build_impls(cx, None, did, None, ret);\n             }\n@@ -360,8 +361,8 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path) -> Type {\n         Res::SelfTy(..) if path.segments.len() == 1 => Generic(kw::SelfUpper),\n         Res::Def(DefKind::TyParam, _) if path.segments.len() == 1 => Generic(path.segments[0].name),\n         _ => {\n-            let did = register_res(cx, path.res);\n-            ResolvedPath { path, did }\n+            let _ = register_res(cx, path.res);\n+            ResolvedPath { path }\n         }\n     }\n }"}, {"sha": "dd13c4809bbce94bc511c4af9144f01f71f25b01", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -401,8 +401,8 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             clean::ImplItem(ref i) => {\n                 self.cache.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n-                    clean::ResolvedPath { did, .. } => {\n-                        self.cache.parent_stack.push(did);\n+                    clean::ResolvedPath { ref path } => {\n+                        self.cache.parent_stack.push(path.def_id());\n                         true\n                     }\n                     clean::DynTrait(ref bounds, _)\n@@ -436,9 +436,9 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n             // Note: matching twice to restrict the lifetime of the `i` borrow.\n             let mut dids = FxHashSet::default();\n             match i.for_ {\n-                clean::ResolvedPath { did, .. }\n-                | clean::BorrowedRef { type_: box clean::ResolvedPath { did, .. }, .. } => {\n-                    dids.insert(did);\n+                clean::ResolvedPath { ref path }\n+                | clean::BorrowedRef { type_: box clean::ResolvedPath { ref path }, .. } => {\n+                    dids.insert(path.def_id());\n                 }\n                 clean::DynTrait(ref bounds, _)\n                 | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {"}, {"sha": "1ed3ba7ece05638b5fb26f972843df3f5f08fdc3", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -762,8 +762,9 @@ fn fmt_type<'cx>(\n \n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),\n-        clean::ResolvedPath { did, ref path } => {\n+        clean::ResolvedPath { ref path } => {\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n+            let did = path.def_id();\n             resolved_path(f, did, path, path.is_assoc_ty(), use_absolute, cx)\n         }\n         clean::DynTrait(ref bounds, ref lt) => {"}, {"sha": "c114edf1e704c17564127dcb0f9d9a697a606d79", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -371,7 +371,7 @@ crate fn get_real_types<'tcx>(\n             let mut ty_generics = Vec::new();\n             for bound in bound.get_bounds().unwrap_or(&[]) {\n                 if let Some(path) = bound.get_trait_path() {\n-                    let ty = Type::ResolvedPath { did: path.def_id(), path };\n+                    let ty = Type::ResolvedPath { path };\n                     get_real_types(generics, &ty, tcx, recurse + 1, &mut ty_generics, cache);\n                 }\n             }"}, {"sha": "690c8f59fce88e562f06d8433e9cf4dff6faa161", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -1243,8 +1243,8 @@ fn should_render_item(item: &clean::Item, deref_mut_: bool, tcx: TyCtxt<'_>) ->\n             | SelfTy::SelfExplicit(clean::BorrowedRef { mutability, .. }) => {\n                 (mutability == Mutability::Mut, false, false)\n             }\n-            SelfTy::SelfExplicit(clean::ResolvedPath { did, .. }) => {\n-                (false, Some(did) == tcx.lang_items().owned_box(), false)\n+            SelfTy::SelfExplicit(clean::ResolvedPath { path }) => {\n+                (false, Some(path.def_id()) == tcx.lang_items().owned_box(), false)\n             }\n             SelfTy::SelfValue => (false, false, true),\n             _ => (false, false, false),\n@@ -2536,7 +2536,7 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n         }\n \n         match ty {\n-            clean::Type::ResolvedPath { did, .. } => process_path(did),\n+            clean::Type::ResolvedPath { path } => process_path(path.def_id()),\n             clean::Type::Tuple(tys) => {\n                 work.extend(tys.into_iter());\n             }"}, {"sha": "e59b94f6b7d3d09bcf351a92b2253a342e226573", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -727,10 +727,11 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         let mut implementor_dups: FxHashMap<Symbol, (DefId, bool)> = FxHashMap::default();\n         for implementor in implementors {\n             match implementor.inner_impl().for_ {\n-                clean::ResolvedPath { ref path, did, .. }\n-                | clean::BorrowedRef {\n-                    type_: box clean::ResolvedPath { ref path, did, .. }, ..\n-                } if !path.is_assoc_ty() => {\n+                clean::ResolvedPath { ref path }\n+                | clean::BorrowedRef { type_: box clean::ResolvedPath { ref path }, .. }\n+                    if !path.is_assoc_ty() =>\n+                {\n+                    let did = path.def_id();\n                     let &mut (prev_did, ref mut has_duplicates) =\n                         implementor_dups.entry(path.last()).or_insert((did, false));\n                     if prev_did != did {"}, {"sha": "a5c1eb1241096212722d02ca7fcdc8d591039366", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43651125eea6284554e101aaf77af6e296f0b666/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=43651125eea6284554e101aaf77af6e296f0b666", "patch": "@@ -365,8 +365,7 @@ impl FromWithTcx<clean::GenericBound> for GenericBound {\n         match bound {\n             TraitBound(clean::PolyTrait { trait_, generic_params }, modifier) => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-                let trait_ =\n-                    clean::ResolvedPath { did: trait_.def_id(), path: trait_ }.into_tcx(tcx);\n+                let trait_ = clean::ResolvedPath { path: trait_ }.into_tcx(tcx);\n                 GenericBound::TraitBound {\n                     trait_,\n                     generic_params: generic_params.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n@@ -391,9 +390,9 @@ impl FromWithTcx<clean::Type> for Type {\n     fn from_tcx(ty: clean::Type, tcx: TyCtxt<'_>) -> Self {\n         use clean::Type::*;\n         match ty {\n-            ResolvedPath { path, did } => Type::ResolvedPath {\n+            ResolvedPath { path } => Type::ResolvedPath {\n                 name: path.whole_name(),\n-                id: from_item_id(did.into()),\n+                id: from_item_id(path.def_id().into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n                 param_names: Vec::new(),\n             },\n@@ -436,7 +435,7 @@ impl FromWithTcx<clean::Type> for Type {\n             },\n             QPath { name, self_type, trait_, .. } => {\n                 // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-                let trait_ = ResolvedPath { did: trait_.def_id(), path: trait_ }.into_tcx(tcx);\n+                let trait_ = ResolvedPath { path: trait_ }.into_tcx(tcx);\n                 Type::QualifiedPath {\n                     name: name.to_string(),\n                     self_type: Box::new((*self_type).into_tcx(tcx)),\n@@ -502,10 +501,7 @@ impl FromWithTcx<clean::Impl> for Impl {\n         let provided_trait_methods = impl_.provided_trait_methods(tcx);\n         let clean::Impl { unsafety, generics, trait_, for_, items, polarity, kind } = impl_;\n         // FIXME: should `trait_` be a clean::Path equivalent in JSON?\n-        let trait_ = trait_.map(|path| {\n-            let did = path.def_id();\n-            clean::ResolvedPath { path, did }.into_tcx(tcx)\n-        });\n+        let trait_ = trait_.map(|path| clean::ResolvedPath { path }.into_tcx(tcx));\n         // FIXME: use something like ImplKind in JSON?\n         let (synthetic, blanket_impl) = match kind {\n             clean::ImplKind::Normal => (false, None),"}]}