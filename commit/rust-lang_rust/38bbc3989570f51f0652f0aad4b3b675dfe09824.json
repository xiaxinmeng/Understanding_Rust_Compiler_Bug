{"sha": "38bbc3989570f51f0652f0aad4b3b675dfe09824", "node_id": "C_kwDOAAsO6NoAKDM4YmJjMzk4OTU3MGY1MWYwNjUyZjBhYWQ0YjNiNjc1ZGZlMDk4MjQ", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2023-05-03T23:42:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-03T23:42:48Z"}, "message": "Rollup merge of #105452 - rcvalle:rust-cfi-3, r=bjorn3\n\nAdd cross-language LLVM CFI support to the Rust compiler\n\nThis PR adds cross-language LLVM Control Flow Integrity (CFI) support to the Rust compiler by adding the `-Zsanitizer-cfi-normalize-integers` option to be used with Clang `-fsanitize-cfi-icall-normalize-integers` for normalizing integer types (see https://reviews.llvm.org/D139395).\n\nIt provides forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed binaries\" (i.e., for when C or C++ and Rust -compiled code share the same virtual address space). For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler, see design document in the tracking issue #89653.\n\nCross-language LLVM CFI can be enabled with -Zsanitizer=cfi and -Zsanitizer-cfi-normalize-integers, and requires proper (i.e., non-rustc) LTO (i.e., -Clinker-plugin-lto).\n\nThank you again, ``@bjorn3,`` ``@nikic,`` ``@samitolvanen,`` and the Rust community for all the help!", "tree": {"sha": "59aab3a1e3f9b82f1acbb6c4f3b4b43aeb04d9ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59aab3a1e3f9b82f1acbb6c4f3b4b43aeb04d9ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38bbc3989570f51f0652f0aad4b3b675dfe09824", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkUvF4CRBK7hj4Ov3rIwAAaiAIAJp5P+IU+2GJ6nIrZQdgGfGE\nVWnWibp7Ge0t0FWMkNWgDF9toxftC/Sv065ndhsmnUX0xcT+O8TE4mmWunxW6N65\n8x84fQOzCJqJKAM8WaWP3QeFr5U6qKgyyrk6G/6hXFxCwjMiLijMdRACj+K+034j\nqYsjEJle3Q8l4U89FF0mCf4amqhQLWGcsAXbQbPskdznL68dV8n6jl0QuLfFpeMt\nYBYpnAa3j5Lg1CfqKV4ZyqoDYObGxB3PIfSlhpZRtSzZJ7kTYFzl0wDtqdxG9UpI\nLje4Bh2YPr7p8ruflm1GO6F9SEXmRtwFtbbw/WZLrMo62x82wcs5+l80A1q569A=\n=p1l0\n-----END PGP SIGNATURE-----\n", "payload": "tree 59aab3a1e3f9b82f1acbb6c4f3b4b43aeb04d9ec\nparent 84d8159ebff3ba1d21da0affb53ed1d4b582ec12\nparent 9a02f65a226349affec0c8e1480b3b6468572e70\nauthor Manish Goregaokar <manishsmail@gmail.com> 1683157368 -0700\ncommitter GitHub <noreply@github.com> 1683157368 -0700\n\nRollup merge of #105452 - rcvalle:rust-cfi-3, r=bjorn3\n\nAdd cross-language LLVM CFI support to the Rust compiler\n\nThis PR adds cross-language LLVM Control Flow Integrity (CFI) support to the Rust compiler by adding the `-Zsanitizer-cfi-normalize-integers` option to be used with Clang `-fsanitize-cfi-icall-normalize-integers` for normalizing integer types (see https://reviews.llvm.org/D139395).\n\nIt provides forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed binaries\" (i.e., for when C or C++ and Rust -compiled code share the same virtual address space). For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler, see design document in the tracking issue #89653.\n\nCross-language LLVM CFI can be enabled with -Zsanitizer=cfi and -Zsanitizer-cfi-normalize-integers, and requires proper (i.e., non-rustc) LTO (i.e., -Clinker-plugin-lto).\n\nThank you again, ``@bjorn3,`` ``@nikic,`` ``@samitolvanen,`` and the Rust community for all the help!\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38bbc3989570f51f0652f0aad4b3b675dfe09824", "html_url": "https://github.com/rust-lang/rust/commit/38bbc3989570f51f0652f0aad4b3b675dfe09824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38bbc3989570f51f0652f0aad4b3b675dfe09824/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84d8159ebff3ba1d21da0affb53ed1d4b582ec12", "url": "https://api.github.com/repos/rust-lang/rust/commits/84d8159ebff3ba1d21da0affb53ed1d4b582ec12", "html_url": "https://github.com/rust-lang/rust/commit/84d8159ebff3ba1d21da0affb53ed1d4b582ec12"}, {"sha": "9a02f65a226349affec0c8e1480b3b6468572e70", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a02f65a226349affec0c8e1480b3b6468572e70", "html_url": "https://github.com/rust-lang/rust/commit/9a02f65a226349affec0c8e1480b3b6468572e70"}], "stats": {"total": 1914, "additions": 1510, "deletions": 404}, "files": [{"sha": "250aa79f8d6098895e0d8d3db6c5a786f7990174", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -501,7 +501,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n         if options.contains(InlineAsmOptions::NORETURN) {\n             let builtin_unreachable = self.context.get_builtin_function(\"__builtin_unreachable\");\n             let builtin_unreachable: RValue<'gcc> = unsafe { std::mem::transmute(builtin_unreachable) };\n-            self.call(self.type_void(), None, builtin_unreachable, &[], None);\n+            self.call(self.type_void(), None, None, builtin_unreachable, &[], None);\n         }\n \n         // Write results to outputs."}, {"sha": "a66ddb6a09f2b8a4d76264d2d1d55fb5c1eb56e3", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -35,6 +35,7 @@ use rustc_codegen_ssa::traits::{\n };\n use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::bug;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n@@ -455,12 +456,12 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(feature=\"master\")]\n-    fn invoke(&mut self, typ: Type<'gcc>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_attrs: Option<&CodegenFnAttrs>, _fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n         let try_block = self.current_func().new_block(\"try\");\n \n         let current_block = self.block.clone();\n         self.block = try_block;\n-        let call = self.call(typ, None, func, args, None); // TODO(antoyo): use funclet here?\n+        let call = self.call(typ, fn_attrs, None, func, args, None); // TODO(antoyo): use funclet here?\n         self.block = current_block;\n \n         let return_value = self.current_func()\n@@ -483,8 +484,8 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     #[cfg(not(feature=\"master\"))]\n-    fn invoke(&mut self, typ: Type<'gcc>, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n-        let call_site = self.call(typ, None, func, args, None);\n+    fn invoke(&mut self, typ: Type<'gcc>, fn_attrs: &CodegenFnAttrs, fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>, func: RValue<'gcc>, args: &[RValue<'gcc>], then: Block<'gcc>, catch: Block<'gcc>, _funclet: Option<&Funclet>) -> RValue<'gcc> {\n+        let call_site = self.call(typ, fn_attrs, None, func, args, None);\n         let condition = self.context.new_rvalue_from_int(self.bool_type, 1);\n         self.llbb().end_with_conditional(None, condition, then, catch);\n         if let Some(_fn_abi) = fn_abi {\n@@ -1351,6 +1352,7 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn call(\n         &mut self,\n         _typ: Type<'gcc>,\n+        _fn_attrs: Option<&CodegenFnAttrs>,\n         fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         func: RValue<'gcc>,\n         args: &[RValue<'gcc>],"}, {"sha": "60176874747263d06c0d7e3582811eec751ca72c", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -113,7 +113,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                 _ if simple.is_some() => {\n                     // FIXME(antoyo): remove this cast when the API supports function.\n                     let func = unsafe { std::mem::transmute(simple.expect(\"simple\")) };\n-                    self.call(self.type_void(), None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n+                    self.call(self.type_void(), None, None, func, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None)\n                 },\n                 sym::likely => {\n                     self.expect(args[0].immediate(), true)\n@@ -326,7 +326,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                     let masked = self.and(addr, mask);\n                     self.bitcast(masked, void_ptr_type)\n                 },\n-                \n+\n                 _ if name_str.starts_with(\"simd_\") => {\n                     match generic_simd_intrinsic(self, name, callee_ty, args, ret_ty, llret_ty, span) {\n                         Ok(llval) => llval,\n@@ -354,7 +354,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn abort(&mut self) {\n         let func = self.context.get_builtin_function(\"abort\");\n         let func: RValue<'gcc> = unsafe { std::mem::transmute(func) };\n-        self.call(self.type_void(), None, func, &[], None);\n+        self.call(self.type_void(), None, None, func, &[], None);\n     }\n \n     fn assume(&mut self, value: Self::Value) {\n@@ -1135,7 +1135,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n fn try_intrinsic<'a, 'b, 'gcc, 'tcx>(bx: &'b mut Builder<'a, 'gcc, 'tcx>, try_func: RValue<'gcc>, data: RValue<'gcc>, _catch_func: RValue<'gcc>, dest: RValue<'gcc>) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n-        bx.call(bx.type_void(), None, try_func, &[data], None);\n+        bx.call(bx.type_void(), None, None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx.data_layout.i32_align.abi;\n@@ -1204,21 +1204,21 @@ fn codegen_gnu_try<'gcc>(bx: &mut Builder<'_, 'gcc, '_>, try_func: RValue<'gcc>,\n         let zero = bx.cx.context.new_rvalue_zero(bx.int_type);\n         let ptr = bx.cx.context.new_call(None, eh_pointer_builtin, &[zero]);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n \n         // NOTE: the blocks must be filled before adding the try/catch, otherwise gcc will not\n         // generate a try/catch.\n         // FIXME(antoyo): add a check in the libgccjit API to prevent this.\n         bx.switch_to_block(current_block);\n-        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, None, try_func, &[data], then, catch, None);\n     });\n \n     let func = unsafe { std::mem::transmute(func) };\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, None, func, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, None, func, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }"}, {"sha": "521b64ad34d15845a49aba5a167f9eb1330e8767", "filename": "compiler/rustc_codegen_gcc/src/type_.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -280,16 +280,4 @@ pub fn struct_fields<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, layout: TyAndLayout\n }\n \n impl<'gcc, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n-    fn set_type_metadata(&self, _function: RValue<'gcc>, _typeid: String) {\n-        // Unsupported.\n-    }\n-\n-    fn typeid_metadata(&self, _typeid: String) -> RValue<'gcc> {\n-        // Unsupported.\n-        self.context.new_rvalue_from_int(self.int_type, 0)\n-    }\n-\n-    fn set_kcfi_type_metadata(&self, _function: RValue<'gcc>, _kcfi_typeid: u32) {\n-        // Unsupported.\n-    }\n }"}, {"sha": "f9af103c9ad834ef07f495a878be27cd6949cf81", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -443,9 +443,9 @@ pub(crate) fn inline_asm_call<'ll>(\n             );\n \n             let call = if let Some((dest, catch, funclet)) = dest_catch_funclet {\n-                bx.invoke(fty, None, v, inputs, dest, catch, funclet)\n+                bx.invoke(fty, None, None, v, inputs, dest, catch, funclet)\n             } else {\n-                bx.call(fty, None, v, inputs, None)\n+                bx.call(fty, None, None, v, inputs, None)\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors"}, {"sha": "2fd6db8cbfeab7fc24ce00379c76fc786ac16194", "filename": "compiler/rustc_codegen_llvm/src/builder.rs", "status": "modified", "additions": 88, "deletions": 30, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fbuilder.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -15,14 +15,15 @@ use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_data_structures::small_c_str::SmallCStr;\n use rustc_hir::def_id::DefId;\n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::ty::layout::{\n     FnAbiError, FnAbiOfHelpers, FnAbiRequest, LayoutError, LayoutOfHelpers, TyAndLayout,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_span::Span;\n-use rustc_symbol_mangling::typeid::kcfi_typeid_for_fnabi;\n+use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi, TypeIdOptions};\n use rustc_target::abi::{self, call::FnAbi, Align, Size, WrappingRange};\n-use rustc_target::spec::{HasTargetSpec, Target};\n+use rustc_target::spec::{HasTargetSpec, SanitizerSet, Target};\n use std::borrow::Cow;\n use std::ffi::CStr;\n use std::iter;\n@@ -216,6 +217,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn invoke(\n         &mut self,\n         llty: &'ll Type,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n         fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n@@ -230,19 +232,13 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n         let mut bundles = vec![funclet_bundle];\n \n-        // Set KCFI operand bundle\n-        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n-        let kcfi_bundle =\n-            if self.tcx.sess.is_sanitizer_kcfi_enabled() && let Some(fn_abi) = fn_abi && is_indirect_call {\n-                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n-                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n-            } else {\n-                None\n-            };\n-        if kcfi_bundle.is_some() {\n-            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n-            bundles.push(kcfi_bundle);\n-        }\n+        // Emit CFI pointer type membership test\n+        self.cfi_type_test(fn_attrs, fn_abi, llfn);\n+\n+        // Emit KCFI operand bundle\n+        let kcfi_bundle = self.kcfi_operand_bundle(fn_attrs, fn_abi, llfn);\n+        let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+        bundles.push(kcfi_bundle);\n \n         bundles.retain(|bundle| bundle.is_some());\n         let invoke = unsafe {\n@@ -1183,6 +1179,7 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     fn call(\n         &mut self,\n         llty: &'ll Type,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n         fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: &'ll Value,\n         args: &[&'ll Value],\n@@ -1195,19 +1192,13 @@ impl<'a, 'll, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         let funclet_bundle = funclet_bundle.as_ref().map(|b| &*b.raw);\n         let mut bundles = vec![funclet_bundle];\n \n-        // Set KCFI operand bundle\n-        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n-        let kcfi_bundle =\n-            if let Some(fn_abi) = fn_abi && self.tcx.sess.is_sanitizer_kcfi_enabled() && is_indirect_call {\n-                let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n-                Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n-            } else {\n-                None\n-            };\n-        if kcfi_bundle.is_some() {\n-            let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n-            bundles.push(kcfi_bundle);\n-        }\n+        // Emit CFI pointer type membership test\n+        self.cfi_type_test(fn_attrs, fn_abi, llfn);\n+\n+        // Emit KCFI operand bundle\n+        let kcfi_bundle = self.kcfi_operand_bundle(fn_attrs, fn_abi, llfn);\n+        let kcfi_bundle = kcfi_bundle.as_ref().map(|b| &*b.raw);\n+        bundles.push(kcfi_bundle);\n \n         bundles.retain(|bundle| bundle.is_some());\n         let call = unsafe {\n@@ -1456,7 +1447,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n \n     pub(crate) fn call_intrinsic(&mut self, intrinsic: &str, args: &[&'ll Value]) -> &'ll Value {\n         let (ty, f) = self.cx.get_intrinsic(intrinsic);\n-        self.call(ty, None, f, args, None)\n+        self.call(ty, None, None, f, args, None)\n     }\n \n     fn call_lifetime_intrinsic(&mut self, intrinsic: &str, ptr: &'ll Value, size: Size) {\n@@ -1518,7 +1509,7 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             format!(\"llvm.{}.sat.i{}.f{}\", instr, int_width, float_width)\n         };\n         let f = self.declare_cfn(&name, llvm::UnnamedAddr::No, self.type_func(&[src_ty], dest_ty));\n-        self.call(self.type_func(&[src_ty], dest_ty), None, f, &[val], None)\n+        self.call(self.type_func(&[src_ty], dest_ty), None, None, f, &[val], None)\n     }\n \n     pub(crate) fn landing_pad(\n@@ -1535,4 +1526,71 @@ impl<'a, 'll, 'tcx> Builder<'a, 'll, 'tcx> {\n             llvm::LLVMBuildLandingPad(self.llbuilder, ty, None, num_clauses as c_uint, UNNAMED)\n         }\n     }\n+\n+    // Emits CFI pointer type membership tests.\n+    fn cfi_type_test(\n+        &mut self,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        llfn: &'ll Value,\n+    ) {\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        if is_indirect_call && fn_abi.is_some() && self.tcx.sess.is_sanitizer_cfi_enabled() {\n+            if fn_attrs.is_some() && fn_attrs.unwrap().no_sanitize.contains(SanitizerSet::CFI) {\n+                return;\n+            }\n+\n+            let mut options = TypeIdOptions::empty();\n+            if self.tcx.sess.is_sanitizer_cfi_generalize_pointers_enabled() {\n+                options.insert(TypeIdOptions::GENERALIZE_POINTERS);\n+            }\n+            if self.tcx.sess.is_sanitizer_cfi_normalize_integers_enabled() {\n+                options.insert(TypeIdOptions::NORMALIZE_INTEGERS);\n+            }\n+\n+            let typeid = typeid_for_fnabi(self.tcx, fn_abi.unwrap(), options);\n+            let typeid_metadata = self.cx.typeid_metadata(typeid).unwrap();\n+\n+            // Test whether the function pointer is associated with the type identifier.\n+            let cond = self.type_test(llfn, typeid_metadata);\n+            let bb_pass = self.append_sibling_block(\"type_test.pass\");\n+            let bb_fail = self.append_sibling_block(\"type_test.fail\");\n+            self.cond_br(cond, bb_pass, bb_fail);\n+\n+            self.switch_to_block(bb_fail);\n+            self.abort();\n+            self.unreachable();\n+\n+            self.switch_to_block(bb_pass);\n+        }\n+    }\n+\n+    // Emits KCFI operand bundles.\n+    fn kcfi_operand_bundle(\n+        &mut self,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n+        fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n+        llfn: &'ll Value,\n+    ) -> Option<llvm::OperandBundleDef<'ll>> {\n+        let is_indirect_call = unsafe { llvm::LLVMIsAFunction(llfn).is_none() };\n+        let kcfi_bundle = if is_indirect_call && self.tcx.sess.is_sanitizer_kcfi_enabled() {\n+            if fn_attrs.is_some() && fn_attrs.unwrap().no_sanitize.contains(SanitizerSet::KCFI) {\n+                return None;\n+            }\n+\n+            let mut options = TypeIdOptions::empty();\n+            if self.tcx.sess.is_sanitizer_cfi_generalize_pointers_enabled() {\n+                options.insert(TypeIdOptions::GENERALIZE_POINTERS);\n+            }\n+            if self.tcx.sess.is_sanitizer_cfi_normalize_integers_enabled() {\n+                options.insert(TypeIdOptions::NORMALIZE_INTEGERS);\n+            }\n+\n+            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi.unwrap(), options);\n+            Some(llvm::OperandBundleDef::new(\"kcfi\", &[self.const_u32(kcfi_typeid)]))\n+        } else {\n+            None\n+        };\n+        kcfi_bundle\n+    }\n }"}, {"sha": "83101a85435a018609580559bedeaf768356dab7", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -228,18 +228,29 @@ pub unsafe fn create_module<'ll>(\n         llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Warning, avoid_plt, 1);\n     }\n \n-    if sess.is_sanitizer_cfi_enabled() {\n-        // FIXME(rcvalle): Add support for non canonical jump tables.\n+    // Enable canonical jump tables if CFI is enabled. (See https://reviews.llvm.org/D65629.)\n+    if sess.is_sanitizer_cfi_canonical_jump_tables_enabled() && sess.is_sanitizer_cfi_enabled() {\n         let canonical_jump_tables = \"CFI Canonical Jump Tables\\0\".as_ptr().cast();\n-        // FIXME(rcvalle): Add it with Override behavior flag.\n         llvm::LLVMRustAddModuleFlag(\n             llmod,\n-            llvm::LLVMModFlagBehavior::Warning,\n+            llvm::LLVMModFlagBehavior::Override,\n             canonical_jump_tables,\n             1,\n         );\n     }\n \n+    // Enable LTO unit splitting if specified or if CFI is enabled. (See https://reviews.llvm.org/D53891.)\n+    if sess.is_split_lto_unit_enabled() || sess.is_sanitizer_cfi_enabled() {\n+        let enable_split_lto_unit = \"EnableSplitLTOUnit\\0\".as_ptr().cast();\n+        llvm::LLVMRustAddModuleFlag(\n+            llmod,\n+            llvm::LLVMModFlagBehavior::Override,\n+            enable_split_lto_unit,\n+            1,\n+        );\n+    }\n+\n+    // Add \"kcfi\" module flag if KCFI is enabled. (See https://reviews.llvm.org/D119296.)\n     if sess.is_sanitizer_kcfi_enabled() {\n         let kcfi = \"kcfi\\0\".as_ptr().cast();\n         llvm::LLVMRustAddModuleFlag(llmod, llvm::LLVMModFlagBehavior::Override, kcfi, 1);"}, {"sha": "cc2a5d158be824f2cb33e4df48b66a8572d34a2b", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -20,7 +20,7 @@ use crate::type_::Type;\n use crate::value::Value;\n use rustc_codegen_ssa::traits::TypeMembershipMethods;\n use rustc_middle::ty::Ty;\n-use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi};\n+use rustc_symbol_mangling::typeid::{kcfi_typeid_for_fnabi, typeid_for_fnabi, TypeIdOptions};\n use smallvec::SmallVec;\n \n /// Declare a function.\n@@ -132,12 +132,31 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n         fn_abi.apply_attrs_llfn(self, llfn);\n \n         if self.tcx.sess.is_sanitizer_cfi_enabled() {\n-            let typeid = typeid_for_fnabi(self.tcx, fn_abi);\n+            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::empty());\n             self.set_type_metadata(llfn, typeid);\n+            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::GENERALIZE_POINTERS);\n+            self.add_type_metadata(llfn, typeid);\n+            let typeid = typeid_for_fnabi(self.tcx, fn_abi, TypeIdOptions::NORMALIZE_INTEGERS);\n+            self.add_type_metadata(llfn, typeid);\n+            let typeid = typeid_for_fnabi(\n+                self.tcx,\n+                fn_abi,\n+                TypeIdOptions::GENERALIZE_POINTERS | TypeIdOptions::NORMALIZE_INTEGERS,\n+            );\n+            self.add_type_metadata(llfn, typeid);\n         }\n \n         if self.tcx.sess.is_sanitizer_kcfi_enabled() {\n-            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi);\n+            // LLVM KCFI does not support multiple !kcfi_type attachments\n+            let mut options = TypeIdOptions::empty();\n+            if self.tcx.sess.is_sanitizer_cfi_generalize_pointers_enabled() {\n+                options.insert(TypeIdOptions::GENERALIZE_POINTERS);\n+            }\n+            if self.tcx.sess.is_sanitizer_cfi_normalize_integers_enabled() {\n+                options.insert(TypeIdOptions::NORMALIZE_INTEGERS);\n+            }\n+\n+            let kcfi_typeid = kcfi_typeid_for_fnabi(self.tcx, fn_abi, options);\n             self.set_kcfi_type_metadata(llfn, kcfi_typeid);\n         }\n "}, {"sha": "00d1796f210bb4d2ddbda845bf65962e89d95de8", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -110,6 +110,7 @@ impl<'ll, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'_, 'll, 'tcx> {\n                 self.call(\n                     simple_ty,\n                     None,\n+                    None,\n                     simple_fn,\n                     &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n                     None,\n@@ -444,7 +445,7 @@ fn try_intrinsic<'ll>(\n ) {\n     if bx.sess().panic_strategy() == PanicStrategy::Abort {\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.call(try_func_ty, None, try_func, &[data], None);\n+        bx.call(try_func_ty, None, None, try_func, &[data], None);\n         // Return 0 unconditionally from the intrinsic call;\n         // we can never unwind.\n         let ret_align = bx.tcx().data_layout.i32_align.abi;\n@@ -543,7 +544,7 @@ fn codegen_msvc_try<'ll>(\n         let ptr_align = bx.tcx().data_layout.pointer_align.abi;\n         let slot = bx.alloca(bx.type_i8p(), ptr_align);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, None, try_func, &[data], normal, catchswitch, None);\n+        bx.invoke(try_func_ty, None, None, try_func, &[data], normal, catchswitch, None);\n \n         bx.switch_to_block(normal);\n         bx.ret(bx.const_i32(0));\n@@ -587,15 +588,15 @@ fn codegen_msvc_try<'ll>(\n         let funclet = bx.catch_pad(cs, &[tydesc, flags, slot]);\n         let ptr = bx.load(bx.type_i8p(), slot, ptr_align);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, None, catch_func, &[data, ptr], Some(&funclet));\n+        bx.call(catch_ty, None, None, catch_func, &[data, ptr], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         // The flag value of 64 indicates a \"catch-all\".\n         bx.switch_to_block(catchpad_foreign);\n         let flags = bx.const_i32(64);\n         let null = bx.const_null(bx.type_i8p());\n         let funclet = bx.catch_pad(cs, &[null, flags, null]);\n-        bx.call(catch_ty, None, catch_func, &[data, null], Some(&funclet));\n+        bx.call(catch_ty, None, None, catch_func, &[data, null], Some(&funclet));\n         bx.catch_ret(&funclet, caught);\n \n         bx.switch_to_block(caught);\n@@ -604,7 +605,7 @@ fn codegen_msvc_try<'ll>(\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -647,7 +648,7 @@ fn codegen_gnu_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -665,13 +666,13 @@ fn codegen_gnu_try<'ll>(\n         bx.add_clause(vals, tydesc);\n         let ptr = bx.extract_value(vals, 0);\n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, None, catch_func, &[data, ptr], None);\n+        bx.call(catch_ty, None, None, catch_func, &[data, ptr], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -711,7 +712,7 @@ fn codegen_emcc_try<'ll>(\n         let data = llvm::get_param(bx.llfn(), 1);\n         let catch_func = llvm::get_param(bx.llfn(), 2);\n         let try_func_ty = bx.type_func(&[bx.type_i8p()], bx.type_void());\n-        bx.invoke(try_func_ty, None, try_func, &[data], then, catch, None);\n+        bx.invoke(try_func_ty, None, None, try_func, &[data], then, catch, None);\n \n         bx.switch_to_block(then);\n         bx.ret(bx.const_i32(0));\n@@ -750,13 +751,13 @@ fn codegen_emcc_try<'ll>(\n         let catch_data = bx.bitcast(catch_data, bx.type_i8p());\n \n         let catch_ty = bx.type_func(&[bx.type_i8p(), bx.type_i8p()], bx.type_void());\n-        bx.call(catch_ty, None, catch_func, &[data, catch_data], None);\n+        bx.call(catch_ty, None, None, catch_func, &[data, catch_data], None);\n         bx.ret(bx.const_i32(1));\n     });\n \n     // Note that no invoke is used here because by definition this function\n     // can't panic (that's what it's catching).\n-    let ret = bx.call(llty, None, llfn, &[try_func, data, catch_func], None);\n+    let ret = bx.call(llty, None, None, llfn, &[try_func, data, catch_func], None);\n     let i32_align = bx.tcx().data_layout.i32_align.abi;\n     bx.store(ret, dest, i32_align);\n }\n@@ -1205,6 +1206,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let c = bx.call(\n             fn_ty,\n             None,\n+            None,\n             f,\n             &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(),\n             None,\n@@ -1423,6 +1425,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let v = bx.call(\n             fn_ty,\n             None,\n+            None,\n             f,\n             &[args[1].immediate(), alignment, mask, args[0].immediate()],\n             None,\n@@ -1564,6 +1567,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n         let v = bx.call(\n             fn_ty,\n             None,\n+            None,\n             f,\n             &[args[0].immediate(), args[1].immediate(), alignment, mask],\n             None,\n@@ -2037,7 +2041,7 @@ fn generic_simd_intrinsic<'ll, 'tcx>(\n \n         let fn_ty = bx.type_func(&[vec_ty, vec_ty], vec_ty);\n         let f = bx.declare_cfn(llvm_intrinsic, llvm::UnnamedAddr::No, fn_ty);\n-        let v = bx.call(fn_ty, None, f, &[lhs, rhs], None);\n+        let v = bx.call(fn_ty, None, None, f, &[lhs, rhs], None);\n         return Ok(v);\n     }\n "}, {"sha": "d3fad5699c800a58bed2eedc06d169b699a245f6", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 34, "deletions": 3, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -291,8 +291,24 @@ impl<'ll, 'tcx> LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n }\n \n impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n+    fn add_type_metadata(&self, function: &'ll Value, typeid: String) {\n+        let typeid_metadata = self.typeid_metadata(typeid).unwrap();\n+        let v = [self.const_usize(0), typeid_metadata];\n+        unsafe {\n+            llvm::LLVMRustGlobalAddMetadata(\n+                function,\n+                llvm::MD_type as c_uint,\n+                llvm::LLVMValueAsMetadata(llvm::LLVMMDNodeInContext(\n+                    self.llcx,\n+                    v.as_ptr(),\n+                    v.len() as c_uint,\n+                )),\n+            )\n+        }\n+    }\n+\n     fn set_type_metadata(&self, function: &'ll Value, typeid: String) {\n-        let typeid_metadata = self.typeid_metadata(typeid);\n+        let typeid_metadata = self.typeid_metadata(typeid).unwrap();\n         let v = [self.const_usize(0), typeid_metadata];\n         unsafe {\n             llvm::LLVMGlobalSetMetadata(\n@@ -307,13 +323,28 @@ impl<'ll, 'tcx> TypeMembershipMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n-    fn typeid_metadata(&self, typeid: String) -> &'ll Value {\n-        unsafe {\n+    fn typeid_metadata(&self, typeid: String) -> Option<&'ll Value> {\n+        Some(unsafe {\n             llvm::LLVMMDStringInContext(\n                 self.llcx,\n                 typeid.as_ptr() as *const c_char,\n                 typeid.len() as c_uint,\n             )\n+        })\n+    }\n+\n+    fn add_kcfi_type_metadata(&self, function: &'ll Value, kcfi_typeid: u32) {\n+        let kcfi_type_metadata = self.const_u32(kcfi_typeid);\n+        unsafe {\n+            llvm::LLVMRustGlobalAddMetadata(\n+                function,\n+                llvm::MD_kcfi_type as c_uint,\n+                llvm::LLVMMDNodeInContext2(\n+                    self.llcx,\n+                    &llvm::LLVMValueAsMetadata(kcfi_type_metadata),\n+                    1,\n+                ),\n+            )\n         }\n     }\n "}, {"sha": "ae45ae9d802c851ebe5253bda3e862ae71cb21f1", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -494,7 +494,7 @@ pub fn maybe_create_entry_wrapper<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n             (rust_main, start_ty, vec![arg_argc, arg_argv])\n         };\n \n-        let result = bx.call(start_ty, None, start_fn, &args, None);\n+        let result = bx.call(start_ty, None, None, start_fn, &args, None);\n         let cast = bx.intcast(result, cx.type_int(), true);\n         bx.ret(cast);\n "}, {"sha": "a8b935bd65ce175d283f15bbc182fd65a743f7dc", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -28,8 +28,9 @@ impl<'a, 'tcx> VirtualIndex {\n         if bx.cx().sess().opts.unstable_opts.virtual_function_elimination\n             && bx.cx().sess().lto() == Lto::Fat\n         {\n-            let typeid =\n-                bx.typeid_metadata(typeid_for_trait_ref(bx.tcx(), expect_dyn_trait_in_self(ty)));\n+            let typeid = bx\n+                .typeid_metadata(typeid_for_trait_ref(bx.tcx(), expect_dyn_trait_in_self(ty)))\n+                .unwrap();\n             let vtable_byte_offset = self.0 * bx.data_layout().pointer_size.bytes();\n             let func = bx.type_checked_load(llvtable, vtable_byte_offset, typeid);\n             bx.pointercast(func, llty)"}, {"sha": "c1613a9640a8bdb93004125b536e321dc9a579b2", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 13, "deletions": 43, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -19,7 +19,6 @@ use rustc_middle::ty::{self, Instance, Ty};\n use rustc_session::config::OptLevel;\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n-use rustc_symbol_mangling::typeid::typeid_for_fnabi;\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode, Reg};\n use rustc_target::abi::{self, HasDataLayout, WrappingRange};\n use rustc_target::spec::abi::Abi;\n@@ -163,6 +162,12 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n         // do an invoke, otherwise do a call.\n         let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n+        let fn_attrs = if bx.tcx().def_kind(fx.instance.def_id()).has_codegen_attrs() {\n+            Some(bx.tcx().codegen_fn_attrs(fx.instance.def_id()))\n+        } else {\n+            None\n+        };\n+\n         if !fn_abi.can_unwind {\n             unwind = mir::UnwindAction::Unreachable;\n         }\n@@ -190,6 +195,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             };\n             let invokeret = bx.invoke(\n                 fn_ty,\n+                fn_attrs,\n                 Some(&fn_abi),\n                 fn_ptr,\n                 &llargs,\n@@ -211,7 +217,7 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             }\n             MergingSucc::False\n         } else {\n-            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n+            let llret = bx.call(fn_ty, fn_attrs, Some(&fn_abi), fn_ptr, &llargs, self.funclet(fx));\n             if fx.mir[self.bb].is_cleanup {\n                 // Cleanup is always the cold path. Don't inline\n                 // drop glue. Also, when there is a deeply-nested\n@@ -1051,48 +1057,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             self.codegen_argument(bx, location, &mut llargs, last_arg);\n         }\n \n-        let (is_indirect_call, fn_ptr) = match (llfn, instance) {\n-            (Some(llfn), _) => (true, llfn),\n-            (None, Some(instance)) => (false, bx.get_fn_addr(instance)),\n-            _ => span_bug!(span, \"no llfn for call\"),\n+        let fn_ptr = match (instance, llfn) {\n+            (Some(instance), None) => bx.get_fn_addr(instance),\n+            (_, Some(llfn)) => llfn,\n+            _ => span_bug!(span, \"no instance or llfn for call\"),\n         };\n \n-        // For backends that support CFI using type membership (i.e., testing whether a given\n-        // pointer is associated with a type identifier).\n-        if bx.tcx().sess.is_sanitizer_cfi_enabled() && is_indirect_call {\n-            // Emit type metadata and checks.\n-            // FIXME(rcvalle): Add support for generalized identifiers.\n-            // FIXME(rcvalle): Create distinct unnamed MDNodes for internal identifiers.\n-            let typeid = typeid_for_fnabi(bx.tcx(), fn_abi);\n-            let typeid_metadata = self.cx.typeid_metadata(typeid);\n-\n-            // Test whether the function pointer is associated with the type identifier.\n-            let cond = bx.type_test(fn_ptr, typeid_metadata);\n-            let bb_pass = bx.append_sibling_block(\"type_test.pass\");\n-            let bb_fail = bx.append_sibling_block(\"type_test.fail\");\n-            bx.cond_br(cond, bb_pass, bb_fail);\n-\n-            bx.switch_to_block(bb_pass);\n-            let merging_succ = helper.do_call(\n-                self,\n-                bx,\n-                fn_abi,\n-                fn_ptr,\n-                &llargs,\n-                target.as_ref().map(|&target| (ret_dest, target)),\n-                unwind,\n-                &copied_constant_arguments,\n-                false,\n-            );\n-            assert_eq!(merging_succ, MergingSucc::False);\n-\n-            bx.switch_to_block(bb_fail);\n-            bx.abort();\n-            bx.unreachable();\n-\n-            return MergingSucc::False;\n-        }\n-\n         helper.do_call(\n             self,\n             bx,\n@@ -1640,7 +1610,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             let (fn_abi, fn_ptr) = common::build_langcall(&bx, None, LangItem::PanicCannotUnwind);\n             let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n \n-            let llret = bx.call(fn_ty, Some(&fn_abi), fn_ptr, &[], funclet.as_ref());\n+            let llret = bx.call(fn_ty, None, Some(&fn_abi), fn_ptr, &[], funclet.as_ref());\n             bx.do_not_inline(llret);\n \n             bx.unreachable();"}, {"sha": "6e7065713b8175c850e2879e8b3dd6a98b91b167", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -697,7 +697,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     let fn_ptr = bx.get_fn_addr(instance);\n                     let fn_abi = bx.fn_abi_of_instance(instance, ty::List::empty());\n                     let fn_ty = bx.fn_decl_backend_type(&fn_abi);\n-                    bx.call(fn_ty, Some(fn_abi), fn_ptr, &[], None)\n+                    let fn_attrs = if bx.tcx().def_kind(instance.def_id()).has_codegen_attrs() {\n+                        Some(bx.tcx().codegen_fn_attrs(instance.def_id()))\n+                    } else {\n+                        None\n+                    };\n+                    bx.call(fn_ty, fn_attrs, Some(fn_abi), fn_ptr, &[], None)\n                 } else {\n                     bx.get_static(def_id)\n                 };"}, {"sha": "57de7e9620e8764d165a15fd707a7d65a29cfbd2", "filename": "compiler/rustc_codegen_ssa/src/traits/builder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fbuilder.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -14,6 +14,7 @@ use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n use crate::MemFlags;\n \n+use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrs;\n use rustc_middle::ty::layout::{HasParamEnv, TyAndLayout};\n use rustc_middle::ty::Ty;\n use rustc_span::Span;\n@@ -72,6 +73,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn invoke(\n         &mut self,\n         llty: Self::Type,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n         fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],\n@@ -321,6 +323,7 @@ pub trait BuilderMethods<'a, 'tcx>:\n     fn call(\n         &mut self,\n         llty: Self::Type,\n+        fn_attrs: Option<&CodegenFnAttrs>,\n         fn_abi: Option<&FnAbi<'tcx, Ty<'tcx>>>,\n         llfn: Self::Value,\n         args: &[Self::Value],"}, {"sha": "36d9864221bcbac34933b57dc3896c9d2bdd8d13", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -128,12 +128,16 @@ pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     ) -> Self::Type;\n }\n \n-// For backends that support CFI using type membership (i.e., testing whether a given  pointer is\n+// For backends that support CFI using type membership (i.e., testing whether a given pointer is\n // associated with a type identifier).\n pub trait TypeMembershipMethods<'tcx>: Backend<'tcx> {\n-    fn set_type_metadata(&self, function: Self::Function, typeid: String);\n-    fn typeid_metadata(&self, typeid: String) -> Self::Value;\n-    fn set_kcfi_type_metadata(&self, function: Self::Function, typeid: u32);\n+    fn add_type_metadata(&self, _function: Self::Function, _typeid: String) {}\n+    fn set_type_metadata(&self, _function: Self::Function, _typeid: String) {}\n+    fn typeid_metadata(&self, _typeid: String) -> Option<Self::Value> {\n+        None\n+    }\n+    fn add_kcfi_type_metadata(&self, _function: Self::Function, _typeid: u32) {}\n+    fn set_kcfi_type_metadata(&self, _function: Self::Function, _typeid: u32) {}\n }\n \n pub trait ArgAbiMethods<'tcx>: HasCodegen<'tcx> {"}, {"sha": "dc5dc4608a07ff141142f92c785544fe7f6fd3ea", "filename": "compiler/rustc_feature/src/active.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_feature%2Fsrc%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Factive.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -331,6 +331,8 @@ declare_features! (\n     (active, cfg_target_thread_local, \"1.7.0\", Some(29594), None),\n     /// Allow conditional compilation depending on rust version\n     (active, cfg_version, \"1.45.0\", Some(64796), None),\n+    /// Allows to use the `#[cfi_encoding = \"\"]` attribute.\n+    (active, cfi_encoding, \"1.69.0\", Some(89653), None),\n     /// Allows `for<...>` on closures and generators.\n     (active, closure_lifetime_binder, \"1.64.0\", Some(97362), None),\n     /// Allows `#[track_caller]` on closures and generators."}, {"sha": "fe05d4590e7a677f5c120f553b183b42a706da93", "filename": "compiler/rustc_feature/src/builtin_attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Fbuiltin_attrs.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -494,6 +494,12 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // RFC 2397\n     gated!(do_not_recommend, Normal, template!(Word), WarnFollowing, experimental!(do_not_recommend)),\n \n+    // `#[cfi_encoding = \"\"]`\n+    gated!(\n+        cfi_encoding, Normal, template!(NameValueStr: \"encoding\"), ErrorPreceding,\n+        experimental!(cfi_encoding)\n+    ),\n+\n     // ==========================================================================\n     // Internal attributes: Stability, deprecation, and unsafe:\n     // =========================================================================="}, {"sha": "0a8bd1d612389d388b6f760c51f1bce50e2c1eae", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -226,6 +226,7 @@ language_item_table! {\n \n     PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n     PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    CVoid,                   sym::c_void,              c_void,                     Target::Enum,           GenericRequirement::None;\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays."}, {"sha": "a0c576234f96b512f2fb00140236588188bc7b9c", "filename": "compiler/rustc_interface/src/tests.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_interface%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Ftests.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -795,12 +795,16 @@ fn test_unstable_options_tracking_hash() {\n     tracked!(remap_cwd_prefix, Some(PathBuf::from(\"abc\")));\n     tracked!(report_delayed_bugs, true);\n     tracked!(sanitizer, SanitizerSet::ADDRESS);\n+    tracked!(sanitizer_cfi_canonical_jump_tables, None);\n+    tracked!(sanitizer_cfi_generalize_pointers, Some(true));\n+    tracked!(sanitizer_cfi_normalize_integers, Some(true));\n     tracked!(sanitizer_memory_track_origins, 2);\n     tracked!(sanitizer_recover, SanitizerSet::ADDRESS);\n     tracked!(saturating_float_casts, Some(true));\n     tracked!(share_generics, Some(true));\n     tracked!(show_span, Some(String::from(\"abc\")));\n     tracked!(simulate_remapped_rust_src_base, Some(PathBuf::from(\"/rustc/abc\")));\n+    tracked!(split_lto_unit, Some(true));\n     tracked!(src_hash_algorithm, Some(SourceFileHashAlgorithm::Sha1));\n     tracked!(stack_protector, StackProtector::All);\n     tracked!(symbol_mangling_version, Some(SymbolManglingVersion::V0));"}, {"sha": "f0d5f789e82834eab6fca50f572f56e5e11e55b2", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -2400,6 +2400,13 @@ impl<'tcx> Ty<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    pub fn is_c_void(self, tcx: TyCtxt<'_>) -> bool {\n+        match self.kind() {\n+            ty::Adt(adt, _) => tcx.lang_items().get(LangItem::CVoid) == Some(adt.did()),\n+            _ => false,\n+        }\n+    }\n }\n \n /// Extra information about why we ended up with a particular variance."}, {"sha": "c897275bee2b7c8285017fb7e7f872a0034852d0", "filename": "compiler/rustc_session/messages.ftl", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fmessages.ftl?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -35,7 +35,15 @@ session_cannot_mix_and_match_sanitizers = `-Zsanitizer={$first}` is incompatible\n \n session_cannot_enable_crt_static_linux = sanitizer is incompatible with statically linked libc, disable it using `-C target-feature=-crt-static`\n \n-session_sanitizer_cfi_enabled = `-Zsanitizer=cfi` requires `-Clto`\n+session_sanitizer_cfi_requires_lto = `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+\n+session_sanitizer_cfi_canonical_jump_tables_requires_cfi = `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n+\n+session_sanitizer_cfi_generalize_pointers_requires_cfi = `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+\n+session_sanitizer_cfi_normalize_integers_requires_cfi = `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+\n+session_split_lto_unit_requires_lto = `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n \n session_unstable_virtual_function_elimination = `-Zvirtual-function-elimination` requires `-Clto`\n "}, {"sha": "cfdba1120ec3831a77efae1a66f034adb00799d3", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -1036,6 +1036,14 @@ fn default_configuration(sess: &Session) -> CrateConfig {\n         ret.insert((sym::sanitize, Some(symbol)));\n     }\n \n+    if sess.is_sanitizer_cfi_generalize_pointers_enabled() {\n+        ret.insert((sym::sanitizer_cfi_generalize_pointers, None));\n+    }\n+\n+    if sess.is_sanitizer_cfi_normalize_integers_enabled() {\n+        ret.insert((sym::sanitizer_cfi_normalize_integers, None));\n+    }\n+\n     if sess.opts.debug_assertions {\n         ret.insert((sym::debug_assertions, None));\n     }"}, {"sha": "0df62c2064ee889d566fe874a7176a557e34b4a6", "filename": "compiler/rustc_session/src/errors.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ferrors.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -111,8 +111,24 @@ pub struct CannotMixAndMatchSanitizers {\n pub struct CannotEnableCrtStaticLinux;\n \n #[derive(Diagnostic)]\n-#[diag(session_sanitizer_cfi_enabled)]\n-pub struct SanitizerCfiEnabled;\n+#[diag(session_sanitizer_cfi_requires_lto)]\n+pub struct SanitizerCfiRequiresLto;\n+\n+#[derive(Diagnostic)]\n+#[diag(session_sanitizer_cfi_canonical_jump_tables_requires_cfi)]\n+pub struct SanitizerCfiCanonicalJumpTablesRequiresCfi;\n+\n+#[derive(Diagnostic)]\n+#[diag(session_sanitizer_cfi_generalize_pointers_requires_cfi)]\n+pub struct SanitizerCfiGeneralizePointersRequiresCfi;\n+\n+#[derive(Diagnostic)]\n+#[diag(session_sanitizer_cfi_normalize_integers_requires_cfi)]\n+pub struct SanitizerCfiNormalizeIntegersRequiresCfi;\n+\n+#[derive(Diagnostic)]\n+#[diag(session_split_lto_unit_requires_lto)]\n+pub struct SplitLtoUnitRequiresLto;\n \n #[derive(Diagnostic)]\n #[diag(session_unstable_virtual_function_elimination)]"}, {"sha": "d9e191c00c9506c5494e65b340b7872e2ee5c6ab", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -1662,6 +1662,12 @@ options! {\n         \"immediately print bugs registered with `delay_span_bug` (default: no)\"),\n     sanitizer: SanitizerSet = (SanitizerSet::empty(), parse_sanitizers, [TRACKED],\n         \"use a sanitizer\"),\n+    sanitizer_cfi_canonical_jump_tables: Option<bool> = (Some(true), parse_opt_bool, [TRACKED],\n+        \"enable canonical jump tables (default: yes)\"),\n+    sanitizer_cfi_generalize_pointers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"enable generalizing pointer types (default: no)\"),\n+    sanitizer_cfi_normalize_integers: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"enable normalizing integer types (default: no)\"),\n     sanitizer_memory_track_origins: usize = (0, parse_sanitizer_memory_track_origins, [TRACKED],\n         \"enable origins tracking in MemorySanitizer\"),\n     sanitizer_recover: SanitizerSet = (SanitizerSet::empty(), parse_sanitizers, [TRACKED],\n@@ -1707,6 +1713,8 @@ options! {\n                  file which is ignored by the linker\n         `single`: sections which do not require relocation are written into object file but ignored\n                   by the linker\"),\n+    split_lto_unit: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"enable LTO unit splitting (default: no)\"),\n     src_hash_algorithm: Option<SourceFileHashAlgorithm> = (None, parse_src_file_hash, [TRACKED],\n         \"hash algorithm of source files in debug info (`md5`, `sha1`, or `sha256`)\"),\n     #[rustc_lint_opt_deny_field_access(\"use `Session::stack_protector` instead of this field\")]"}, {"sha": "a988d7f28e6cbf315d0de41bbccee888dc7f3af7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 65, "deletions": 9, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -766,10 +766,30 @@ impl Session {\n         self.opts.unstable_opts.sanitizer.contains(SanitizerSet::CFI)\n     }\n \n+    pub fn is_sanitizer_cfi_canonical_jump_tables_disabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer_cfi_canonical_jump_tables == Some(false)\n+    }\n+\n+    pub fn is_sanitizer_cfi_canonical_jump_tables_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer_cfi_canonical_jump_tables == Some(true)\n+    }\n+\n+    pub fn is_sanitizer_cfi_generalize_pointers_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer_cfi_generalize_pointers == Some(true)\n+    }\n+\n+    pub fn is_sanitizer_cfi_normalize_integers_enabled(&self) -> bool {\n+        self.opts.unstable_opts.sanitizer_cfi_normalize_integers == Some(true)\n+    }\n+\n     pub fn is_sanitizer_kcfi_enabled(&self) -> bool {\n         self.opts.unstable_opts.sanitizer.contains(SanitizerSet::KCFI)\n     }\n \n+    pub fn is_split_lto_unit_enabled(&self) -> bool {\n+        self.opts.unstable_opts.split_lto_unit == Some(true)\n+    }\n+\n     /// Check whether this compile session and crate type use static crt.\n     pub fn crt_static(&self, crate_type: Option<CrateType>) -> bool {\n         if !self.target.crt_static_respected {\n@@ -1582,24 +1602,60 @@ fn validate_commandline_args_with_session_available(sess: &Session) {\n         sess.emit_err(errors::CannotEnableCrtStaticLinux);\n     }\n \n-    // LLVM CFI and VFE both require LTO.\n-    if sess.lto() != config::Lto::Fat {\n-        if sess.is_sanitizer_cfi_enabled() {\n-            sess.emit_err(errors::SanitizerCfiEnabled);\n-        }\n-        if sess.opts.unstable_opts.virtual_function_elimination {\n-            sess.emit_err(errors::UnstableVirtualFunctionElimination);\n-        }\n+    // LLVM CFI requires LTO.\n+    if sess.is_sanitizer_cfi_enabled()\n+        && !(sess.lto() == config::Lto::Fat\n+            || sess.lto() == config::Lto::Thin\n+            || sess.opts.cg.linker_plugin_lto.enabled())\n+    {\n+        sess.emit_err(errors::SanitizerCfiRequiresLto);\n     }\n \n-    // LLVM CFI and KCFI are mutually exclusive\n+    // LLVM CFI is incompatible with LLVM KCFI.\n     if sess.is_sanitizer_cfi_enabled() && sess.is_sanitizer_kcfi_enabled() {\n         sess.emit_err(errors::CannotMixAndMatchSanitizers {\n             first: \"cfi\".to_string(),\n             second: \"kcfi\".to_string(),\n         });\n     }\n \n+    // Canonical jump tables requires CFI.\n+    if sess.is_sanitizer_cfi_canonical_jump_tables_disabled() {\n+        if !sess.is_sanitizer_cfi_enabled() {\n+            sess.emit_err(errors::SanitizerCfiCanonicalJumpTablesRequiresCfi);\n+        }\n+    }\n+\n+    // LLVM CFI pointer generalization requires CFI or KCFI.\n+    if sess.is_sanitizer_cfi_generalize_pointers_enabled() {\n+        if !(sess.is_sanitizer_cfi_enabled() || sess.is_sanitizer_kcfi_enabled()) {\n+            sess.emit_err(errors::SanitizerCfiGeneralizePointersRequiresCfi);\n+        }\n+    }\n+\n+    // LLVM CFI integer normalization requires CFI or KCFI.\n+    if sess.is_sanitizer_cfi_normalize_integers_enabled() {\n+        if !(sess.is_sanitizer_cfi_enabled() || sess.is_sanitizer_kcfi_enabled()) {\n+            sess.emit_err(errors::SanitizerCfiNormalizeIntegersRequiresCfi);\n+        }\n+    }\n+\n+    // LTO unit splitting requires LTO.\n+    if sess.is_split_lto_unit_enabled()\n+        && !(sess.lto() == config::Lto::Fat\n+            || sess.lto() == config::Lto::Thin\n+            || sess.opts.cg.linker_plugin_lto.enabled())\n+    {\n+        sess.emit_err(errors::SplitLtoUnitRequiresLto);\n+    }\n+\n+    // VFE requires LTO.\n+    if sess.lto() != config::Lto::Fat {\n+        if sess.opts.unstable_opts.virtual_function_elimination {\n+            sess.emit_err(errors::UnstableVirtualFunctionElimination);\n+        }\n+    }\n+\n     if sess.opts.unstable_opts.stack_protector != StackProtector::None {\n         if !sess.target.options.supports_stack_protector {\n             sess.emit_warning(errors::StackProtectorNotSupportedForTarget {"}, {"sha": "1140a922f9fd14edf1668559ed21d065aa1feafe", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -443,6 +443,7 @@ symbols! {\n         c_str,\n         c_unwind,\n         c_variadic,\n+        c_void,\n         call,\n         call_mut,\n         call_once,\n@@ -470,6 +471,7 @@ symbols! {\n         cfg_target_vendor,\n         cfg_version,\n         cfi,\n+        cfi_encoding,\n         char,\n         client,\n         clippy,\n@@ -1323,6 +1325,8 @@ symbols! {\n         s,\n         safety,\n         sanitize,\n+        sanitizer_cfi_generalize_pointers,\n+        sanitizer_cfi_normalize_integers,\n         sanitizer_runtime,\n         saturating_add,\n         saturating_sub,"}, {"sha": "81dbff9ea4e40183f23a3cf1805d4df3232ad04a", "filename": "compiler/rustc_symbol_mangling/src/typeid.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -1,42 +1,65 @@\n-// For more information about type metadata and type metadata identifiers for cross-language LLVM\n-// CFI support, see Type metadata in the design document in the tracking issue #89653.\n-\n+/// Type metadata identifiers for LLVM Control Flow Integrity (CFI) and cross-language LLVM CFI\n+/// support.\n+///\n+/// For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler,\n+/// see design document in the tracking issue #89653.\n+use bitflags::bitflags;\n use rustc_middle::ty::{FnSig, Ty, TyCtxt};\n use rustc_target::abi::call::FnAbi;\n use std::hash::Hasher;\n use twox_hash::XxHash64;\n \n+bitflags! {\n+    /// Options for typeid_for_fnabi and typeid_for_fnsig.\n+    pub struct TypeIdOptions: u32 {\n+        const GENERALIZE_POINTERS = 1;\n+        const GENERALIZE_REPR_C = 2;\n+        const NORMALIZE_INTEGERS = 4;\n+    }\n+}\n+\n mod typeid_itanium_cxx_abi;\n-use typeid_itanium_cxx_abi::TypeIdOptions;\n \n /// Returns a type metadata identifier for the specified FnAbi.\n-pub fn typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> String {\n-    typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, TypeIdOptions::NO_OPTIONS)\n+pub fn typeid_for_fnabi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+    options: TypeIdOptions,\n+) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, options)\n }\n \n /// Returns a type metadata identifier for the specified FnSig.\n-pub fn typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> String {\n-    typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS)\n+pub fn typeid_for_fnsig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_sig: &FnSig<'tcx>,\n+    options: TypeIdOptions,\n+) -> String {\n+    typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options)\n }\n \n-/// Returns an LLVM KCFI type metadata identifier for the specified FnAbi.\n-pub fn kcfi_typeid_for_fnabi<'tcx>(tcx: TyCtxt<'tcx>, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> u32 {\n-    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n-    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+/// Returns a KCFI type metadata identifier for the specified FnAbi.\n+pub fn kcfi_typeid_for_fnabi<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_abi: &FnAbi<'tcx, Ty<'tcx>>,\n+    options: TypeIdOptions,\n+) -> u32 {\n+    // A KCFI type metadata identifier is a 32-bit constant produced by taking the lower half of the\n+    // xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n     let mut hash: XxHash64 = Default::default();\n-    hash.write(\n-        typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, TypeIdOptions::NO_OPTIONS).as_bytes(),\n-    );\n+    hash.write(typeid_itanium_cxx_abi::typeid_for_fnabi(tcx, fn_abi, options).as_bytes());\n     hash.finish() as u32\n }\n \n-/// Returns an LLVM KCFI type metadata identifier for the specified FnSig.\n-pub fn kcfi_typeid_for_fnsig<'tcx>(tcx: TyCtxt<'tcx>, fn_sig: &FnSig<'tcx>) -> u32 {\n-    // An LLVM KCFI type metadata identifier is a 32-bit constant produced by taking the lower half\n-    // of the xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n+/// Returns a KCFI type metadata identifier for the specified FnSig.\n+pub fn kcfi_typeid_for_fnsig<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    fn_sig: &FnSig<'tcx>,\n+    options: TypeIdOptions,\n+) -> u32 {\n+    // A KCFI type metadata identifier is a 32-bit constant produced by taking the lower half of the\n+    // xxHash64 of the type metadata identifier. (See llvm/llvm-project@cff5bef.)\n     let mut hash: XxHash64 = Default::default();\n-    hash.write(\n-        typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, TypeIdOptions::NO_OPTIONS).as_bytes(),\n-    );\n+    hash.write(typeid_itanium_cxx_abi::typeid_for_fnsig(tcx, fn_sig, options).as_bytes());\n     hash.finish() as u32\n }"}, {"sha": "5310ef26da768d890ac570e0172d4e693ebcccb2", "filename": "compiler/rustc_symbol_mangling/src/typeid/typeid_itanium_cxx_abi.rs", "status": "modified", "additions": 148, "deletions": 53, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftypeid%2Ftypeid_itanium_cxx_abi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -1,26 +1,30 @@\n-// For more information about type metadata and type metadata identifiers for cross-language LLVM\n-// CFI support, see Type metadata in the design document in the tracking issue #89653.\n-\n-// FIXME(rcvalle): Identify C char and integer type uses and encode them with their respective\n-// builtin type encodings as specified by the Itanium C++ ABI for extern function types with the \"C\"\n-// calling convention to use this encoding for cross-language LLVM CFI.\n-\n-use bitflags::bitflags;\n+/// Type metadata identifiers (using Itanium C++ ABI mangling for encoding) for LLVM Control Flow\n+/// Integrity (CFI) and cross-language LLVM CFI support.\n+///\n+/// Encodes type metadata identifiers for LLVM CFI and cross-language LLVM CFI support using Itanium\n+/// C++ ABI mangling for encoding with vendor extended type qualifiers and types for Rust types that\n+/// are not used across the FFI boundary.\n+///\n+/// For more information about LLVM CFI and cross-language LLVM CFI support for the Rust compiler,\n+/// see design document in the tracking issue #89653.\n use core::fmt::Display;\n use rustc_data_structures::base_n;\n use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::DiagnosticMessage;\n use rustc_hir as hir;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n     self, Const, ExistentialPredicate, FloatTy, FnSig, IntTy, List, Region, RegionKind, TermKind,\n     Ty, TyCtxt, UintTy,\n };\n use rustc_span::def_id::DefId;\n-use rustc_span::symbol::sym;\n+use rustc_span::sym;\n use rustc_target::abi::call::{Conv, FnAbi};\n use rustc_target::spec::abi::Abi;\n use std::fmt::Write as _;\n \n+use crate::typeid::TypeIdOptions;\n+\n /// Type and extended type qualifiers.\n #[derive(Eq, Hash, PartialEq)]\n enum TyQ {\n@@ -38,15 +42,6 @@ enum DictKey<'tcx> {\n     Predicate(ExistentialPredicate<'tcx>),\n }\n \n-bitflags! {\n-    /// Options for typeid_for_fnabi and typeid_for_fnsig.\n-    pub struct TypeIdOptions: u32 {\n-        const NO_OPTIONS = 0;\n-        const GENERALIZE_POINTERS = 1;\n-        const GENERALIZE_REPR_C = 2;\n-    }\n-}\n-\n /// Options for encode_ty.\n type EncodeTyOptions = TypeIdOptions;\n \n@@ -91,21 +86,6 @@ fn compress<'tcx>(\n     }\n }\n \n-// FIXME(rcvalle): Move to compiler/rustc_middle/src/ty/sty.rs after C types work is done, possibly\n-// along with other is_c_type methods.\n-/// Returns whether a `ty::Ty` is `c_void`.\n-fn is_c_void_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-    match ty.kind() {\n-        ty::Adt(adt_def, ..) => {\n-            let def_id = adt_def.0.did;\n-            let crate_name = tcx.crate_name(def_id.krate);\n-            tcx.item_name(def_id).as_str() == \"c_void\"\n-                && (crate_name == sym::core || crate_name == sym::std || crate_name == sym::libc)\n-        }\n-        _ => false,\n-    }\n-}\n-\n /// Encodes a const using the Itanium C++ ABI as a literal argument (see\n /// <https://itanium-cxx-abi.github.io/cxx-abi/abi.html#mangling.literal>).\n fn encode_const<'tcx>(\n@@ -448,6 +428,12 @@ fn encode_ty<'tcx>(\n \n     match ty.kind() {\n         // Primitive types\n+\n+        // Rust's bool has the same layout as C17's _Bool, that is, its size and alignment are\n+        // implementation-defined. Any bool can be cast into an integer, taking on the values 1\n+        // (true) or 0 (false).\n+        //\n+        // (See https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html#bool.)\n         ty::Bool => {\n             typeid.push('b');\n         }\n@@ -535,9 +521,33 @@ fn encode_ty<'tcx>(\n         // User-defined types\n         ty::Adt(adt_def, substs) => {\n             let mut s = String::new();\n-            let def_id = adt_def.0.did;\n-            if options.contains(EncodeTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c() {\n-                // For cross-language CFI support, the encoding must be compatible at the FFI\n+            let def_id = adt_def.did();\n+            if let Some(cfi_encoding) = tcx.get_attr(def_id, sym::cfi_encoding) {\n+                // Use user-defined CFI encoding for type\n+                if let Some(value_str) = cfi_encoding.value_str() {\n+                    if !value_str.to_string().trim().is_empty() {\n+                        s.push_str(&value_str.to_string().trim());\n+                    } else {\n+                        #[allow(\n+                            rustc::diagnostic_outside_of_impl,\n+                            rustc::untranslatable_diagnostic\n+                        )]\n+                        tcx.sess\n+                            .struct_span_err(\n+                                cfi_encoding.span,\n+                                DiagnosticMessage::Str(format!(\n+                                    \"invalid `cfi_encoding` for `{:?}`\",\n+                                    ty.kind()\n+                                )),\n+                            )\n+                            .emit();\n+                    }\n+                } else {\n+                    bug!(\"encode_ty: invalid `cfi_encoding` for `{:?}`\", ty.kind());\n+                }\n+                compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n+            } else if options.contains(EncodeTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c() {\n+                // For cross-language LLVM CFI support, the encoding must be compatible at the FFI\n                 // boundary. For instance:\n                 //\n                 //     struct type1 {};\n@@ -567,8 +577,33 @@ fn encode_ty<'tcx>(\n         ty::Foreign(def_id) => {\n             // <length><name>, where <name> is <unscoped-name>\n             let mut s = String::new();\n-            let name = tcx.item_name(*def_id).to_string();\n-            let _ = write!(s, \"{}{}\", name.len(), &name);\n+            if let Some(cfi_encoding) = tcx.get_attr(*def_id, sym::cfi_encoding) {\n+                // Use user-defined CFI encoding for type\n+                if let Some(value_str) = cfi_encoding.value_str() {\n+                    if !value_str.to_string().trim().is_empty() {\n+                        s.push_str(&value_str.to_string().trim());\n+                    } else {\n+                        #[allow(\n+                            rustc::diagnostic_outside_of_impl,\n+                            rustc::untranslatable_diagnostic\n+                        )]\n+                        tcx.sess\n+                            .struct_span_err(\n+                                cfi_encoding.span,\n+                                DiagnosticMessage::Str(format!(\n+                                    \"invalid `cfi_encoding` for `{:?}`\",\n+                                    ty.kind()\n+                                )),\n+                            )\n+                            .emit();\n+                    }\n+                } else {\n+                    bug!(\"encode_ty: invalid `cfi_encoding` for `{:?}`\", ty.kind());\n+                }\n+            } else {\n+                let name = tcx.item_name(*def_id).to_string();\n+                let _ = write!(s, \"{}{}\", name.len(), &name);\n+            }\n             compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n             typeid.push_str(&s);\n         }\n@@ -618,7 +653,7 @@ fn encode_ty<'tcx>(\n         ty::FnPtr(fn_sig) => {\n             // PF<return-type><parameter-type1..parameter-typeN>E\n             let mut s = String::from(\"P\");\n-            s.push_str(&encode_fnsig(tcx, &fn_sig.skip_binder(), dict, TypeIdOptions::NO_OPTIONS));\n+            s.push_str(&encode_fnsig(tcx, &fn_sig.skip_binder(), dict, TypeIdOptions::empty()));\n             compress(dict, DictKey::Ty(ty, TyQ::None), &mut s);\n             typeid.push_str(&s);\n         }\n@@ -655,22 +690,59 @@ fn encode_ty<'tcx>(\n }\n \n // Transforms a ty:Ty for being encoded and used in the substitution dictionary. It transforms all\n-// c_void types into unit types unconditionally, and generalizes all pointers if\n-// TransformTyOptions::GENERALIZE_POINTERS option is set.\n-#[instrument(level = \"trace\", skip(tcx))]\n+// c_void types into unit types unconditionally, generalizes pointers if\n+// TransformTyOptions::GENERALIZE_POINTERS option is set, and normalizes integers if\n+// TransformTyOptions::NORMALIZE_INTEGERS option is set.\n fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptions) -> Ty<'tcx> {\n     let mut ty = ty;\n \n     match ty.kind() {\n-        ty::Bool\n-        | ty::Int(..)\n-        | ty::Uint(..)\n-        | ty::Float(..)\n-        | ty::Char\n-        | ty::Str\n-        | ty::Never\n-        | ty::Foreign(..)\n-        | ty::Dynamic(..) => {}\n+        ty::Float(..) | ty::Char | ty::Str | ty::Never | ty::Foreign(..) | ty::Dynamic(..) => {}\n+\n+        ty::Bool => {\n+            if options.contains(EncodeTyOptions::NORMALIZE_INTEGERS) {\n+                // Note: on all platforms that Rust's currently supports, its size and alignment are\n+                // 1, and its ABI class is INTEGER - see Rust Layout and ABIs.\n+                //\n+                // (See https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html#bool.)\n+                //\n+                // Clang represents bool as an 8-bit unsigned integer.\n+                ty = tcx.types.u8;\n+            }\n+        }\n+\n+        ty::Int(..) | ty::Uint(..) => {\n+            if options.contains(EncodeTyOptions::NORMALIZE_INTEGERS) {\n+                // Note: C99 7.18.2.4 requires uintptr_t and intptr_t to be at least 16-bit wide.\n+                // All platforms we currently support have a C platform, and as a consequence,\n+                // isize/usize are at least 16-bit wide for all of them.\n+                //\n+                // (See https://rust-lang.github.io/unsafe-code-guidelines/layout/scalars.html#isize-and-usize.)\n+                match ty.kind() {\n+                    ty::Int(IntTy::Isize) => match tcx.sess.target.pointer_width {\n+                        16 => ty = tcx.types.i16,\n+                        32 => ty = tcx.types.i32,\n+                        64 => ty = tcx.types.i64,\n+                        128 => ty = tcx.types.i128,\n+                        _ => bug!(\n+                            \"transform_ty: unexpected pointer width `{}`\",\n+                            tcx.sess.target.pointer_width\n+                        ),\n+                    },\n+                    ty::Uint(UintTy::Usize) => match tcx.sess.target.pointer_width {\n+                        16 => ty = tcx.types.u16,\n+                        32 => ty = tcx.types.u32,\n+                        64 => ty = tcx.types.u64,\n+                        128 => ty = tcx.types.u128,\n+                        _ => bug!(\n+                            \"transform_ty: unexpected pointer width `{}`\",\n+                            tcx.sess.target.pointer_width\n+                        ),\n+                    },\n+                    _ => (),\n+                }\n+            }\n+        }\n \n         _ if ty.is_unit() => {}\n \n@@ -688,12 +760,17 @@ fn transform_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, options: TransformTyOptio\n         }\n \n         ty::Adt(adt_def, substs) => {\n-            if is_c_void_ty(tcx, ty) {\n+            if ty.is_c_void(tcx) {\n                 ty = tcx.mk_unit();\n             } else if options.contains(TransformTyOptions::GENERALIZE_REPR_C) && adt_def.repr().c()\n             {\n                 ty = tcx.mk_adt(*adt_def, ty::List::empty());\n             } else if adt_def.repr().transparent() && adt_def.is_struct() {\n+                // Don't transform repr(transparent) types with an user-defined CFI encoding to\n+                // preserve the user-defined CFI encoding.\n+                if let Some(_) = tcx.get_attr(adt_def.did(), sym::cfi_encoding) {\n+                    return ty;\n+                }\n                 let variant = adt_def.non_enum_variant();\n                 let param_env = tcx.param_env(variant.def_id);\n                 let field = variant.fields.iter().find(|field| {\n@@ -815,7 +892,7 @@ fn transform_substs<'tcx>(\n     options: TransformTyOptions,\n ) -> SubstsRef<'tcx> {\n     let substs = substs.iter().map(|subst| match subst.unpack() {\n-        GenericArgKind::Type(ty) if is_c_void_ty(tcx, ty) => tcx.mk_unit().into(),\n+        GenericArgKind::Type(ty) if ty.is_c_void(tcx) => tcx.mk_unit().into(),\n         GenericArgKind::Type(ty) => transform_ty(tcx, ty, options).into(),\n         _ => subst,\n     });\n@@ -887,6 +964,15 @@ pub fn typeid_for_fnabi<'tcx>(\n     // Close the \"F..E\" pair\n     typeid.push('E');\n \n+    // Add encoding suffixes\n+    if options.contains(EncodeTyOptions::NORMALIZE_INTEGERS) {\n+        typeid.push_str(\".normalized\");\n+    }\n+\n+    if options.contains(EncodeTyOptions::GENERALIZE_POINTERS) {\n+        typeid.push_str(\".generalized\");\n+    }\n+\n     typeid\n }\n \n@@ -913,5 +999,14 @@ pub fn typeid_for_fnsig<'tcx>(\n     // Encode the function signature\n     typeid.push_str(&encode_fnsig(tcx, fn_sig, &mut dict, options));\n \n+    // Add encoding suffixes\n+    if options.contains(EncodeTyOptions::NORMALIZE_INTEGERS) {\n+        typeid.push_str(\".normalized\");\n+    }\n+\n+    if options.contains(EncodeTyOptions::GENERALIZE_POINTERS) {\n+        typeid.push_str(\".generalized\");\n+    }\n+\n     typeid\n }"}, {"sha": "b85894259f1f34e7654f8e1d4a28848269851356", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -202,6 +202,7 @@ mod c_long_definition {\n //     would be uninhabited and at least dereferencing such pointers would\n //     be UB.\n #[doc = include_str!(\"c_void.md\")]\n+#[cfg_attr(not(bootstrap), lang = \"c_void\")]\n #[repr(u8)]\n #[stable(feature = \"core_c_void\", since = \"1.30.0\")]\n pub enum c_void {"}, {"sha": "aa776daf09db63251e86d09647aff20544a1f7b1", "filename": "src/doc/unstable-book/src/compiler-flags/sanitizer.md", "status": "modified", "additions": 101, "deletions": 17, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fsanitizer.md?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -196,18 +196,18 @@ Shadow byte legend (one shadow byte represents 8 application bytes):\n \n # ControlFlowIntegrity\n \n-The LLVM Control Flow Integrity (CFI) support in the Rust compiler initially\n-provides forward-edge control flow protection for Rust-compiled code only by\n-aggregating function pointers in groups identified by their return and parameter\n-types.\n-\n-Forward-edge control flow protection for C or C++ and Rust -compiled code \"mixed\n-binaries\" (i.e., for when C or C++ and Rust -compiled code share the same\n-virtual address space) will be provided in later work by defining and using\n-compatible type identifiers (see Type metadata in the design document in the\n-tracking issue [#89653](https://github.com/rust-lang/rust/issues/89653)).\n-\n-LLVM CFI can be enabled with -Zsanitizer=cfi and requires LTO (i.e., -Clto).\n+The LLVM Control Flow Integrity (CFI) support in the Rust compiler provides\n+forward-edge control flow protection for both Rust-compiled code only and for C\n+or C++ and Rust -compiled code mixed-language binaries, also known as \u201cmixed\n+binaries\u201d (i.e., for when C or C++ and Rust -compiled code share the same\n+virtual address space), by aggregating function pointers in groups identified by\n+their return and parameter types.\n+\n+LLVM CFI can be enabled with `-Zsanitizer=cfi` and requires LTO (i.e., `-Clto`).\n+Cross-language LLVM CFI can be enabled with `-Zsanitizer=cfi`, and requires the\n+`-Zsanitizer-cfi-normalize-integers` option to be used with Clang\n+`-fsanitize-cfi-icall-normalize-integers` for normalizing integer types, and\n+proper (i.e., non-rustc) LTO (i.e., `-Clinker-plugin-lto`).\n \n See the [Clang ControlFlowIntegrity documentation][clang-cfi] for more details.\n \n@@ -343,7 +343,7 @@ $\n Fig. 5.\u2003Build and execution of the modified example with LLVM CFI disabled.\n \n ```shell\n-$ RUSTFLAGS=\"-Zsanitizer=cfi -Cembed-bitcode=yes -Clto\" cargo run --release\n+$ RUSTFLAGS=\"-Cembed-bitcode=yes -Clto -Zsanitizer=cfi\" cargo run --release\n    Compiling rust-cfi-2 v0.1.0 (/home/rcvalle/rust-cfi-2)\n     Finished release [optimized] target(s) in 3.38s\n      Running `target/release/rust-cfi-2`\n@@ -392,7 +392,7 @@ Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n Language][rust-book] book.\n \n ```shell\n- cargo run --release\n+$ cargo run --release\n    Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)\n     Finished release [optimized] target(s) in 0.74s\n      Running `target/release/rust-cfi-3`\n@@ -404,7 +404,7 @@ $\n Fig. 8.\u2003Build and execution of the modified example with LLVM CFI disabled.\n \n ```shell\n-$ RUSTFLAGS=\"-Zsanitizer=cfi -Cembed-bitcode=yes -Clto\" cargo run --release\n+$ RUSTFLAGS=\"-Cembed-bitcode=yes -Clto -Zsanitizer=cfi\" cargo run --release\n    Compiling rust-cfi-3 v0.1.0 (/home/rcvalle/rust-cfi-3)\n     Finished release [optimized] target(s) in 3.40s\n      Running `target/release/rust-cfi-3`\n@@ -420,8 +420,92 @@ flow using an indirect branch/call to a function with different return and\n parameter types than the return type expected and arguments intended/passed in\n the call/branch site, the execution is also terminated (see Fig. 9).\n \n-[rust-book-ch19-05]: ../../book/ch19-05-advanced-functions-and-closures.html\n-[rust-book]: ../../book/title-page.html\n+```ignore (cannot-test-this-because-uses-custom-build)\n+int\n+do_twice(int (*fn)(int), int arg) {\n+    return fn(arg) + fn(arg);\n+}\n+```\n+Fig. 10.\u2003Example C library.\n+\n+```ignore (cannot-test-this-because-uses-custom-build)\n+use std::mem;\n+\n+#[link(name = \"foo\")]\n+extern \"C\" {\n+    fn do_twice(f: unsafe extern \"C\" fn(i32) -> i32, arg: i32) -> i32;\n+}\n+\n+unsafe extern \"C\" fn add_one(x: i32) -> i32 {\n+    x + 1\n+}\n+\n+unsafe extern \"C\" fn add_two(x: i64) -> i64 {\n+    x + 2\n+}\n+\n+fn main() {\n+    let answer = unsafe { do_twice(add_one, 5) };\n+\n+    println!(\"The answer is: {}\", answer);\n+\n+    println!(\"With CFI enabled, you should not see the next answer\");\n+    let f: unsafe extern \"C\" fn(i32) -> i32 = unsafe {\n+        mem::transmute::<*const u8, unsafe extern \"C\" fn(i32) -> i32>(add_two as *const u8)\n+    };\n+    let next_answer = unsafe { do_twice(f, 5) };\n+\n+    println!(\"The next answer is: {}\", next_answer);\n+}\n+```\n+Fig. 11.\u2003Another modified example from the [Advanced Functions and\n+Closures][rust-book-ch19-05] chapter of the [The Rust Programming\n+Language][rust-book] book.\n+\n+```shell\n+$ make\n+mkdir -p target/debug\n+clang -I. -Isrc -Wall -flto -fvisibility=hidden -c -emit-llvm src/foo.c -o target/debug/libfoo.bc\n+llvm-ar rcs target/debug/libfoo.a target/debug/libfoo.bc\n+RUSTFLAGS=\"-L./target/debug -Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld\" cargo build\n+   Compiling main v0.1.0 (/home/rcvalle/rust-cross-cfi-1)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n+$ ./target/debug/main\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+The next answer is: 14\n+$\n+```\n+Fig. 12.\u2003Build and execution of the modified example with LLVM CFI disabled.\n+\n+```shell\n+$ make\n+mkdir -p target/debug\n+clang -I. -Isrc -Wall -flto -fvisibility=hidden -fsanitize=cfi -fsanitize-cfi-icall-normalize-integers -c -emit-llvm src/foo.c -o target/debug/libfoo.bc\n+llvm-ar rcs target/debug/libfoo.a target/debug/libfoo.bc\n+RUSTFLAGS=\"-L./target/debug -Clinker-plugin-lto -Clinker=clang -Clink-arg=-fuse-ld=lld -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers\" cargo build\n+   Compiling main v0.1.0 (/home/rcvalle/rust-cross-cfi-1)\n+    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n+$ ./target/debug/main\n+The answer is: 12\n+With CFI enabled, you should not see the next answer\n+Illegal instruction\n+$\n+```\n+Fig. 13.\u2003Build and execution of the modified example with LLVM CFI enabled.\n+\n+When LLVM CFI is enabled, if there are any attempts to change/hijack control\n+flow using an indirect branch/call to a function with different return and\n+parameter types than the return type expected and arguments intended/passed in\n+the call/branch site, even across the FFI boundary and for extern \"C\" function\n+types indirectly called (i.e., callbacks/function pointers) across the FFI\n+boundary, in C or C++ and Rust -compiled code mixed-language binaries, also\n+known as \u201cmixed binaries\u201d (i.e., for when C or C++ and Rust -compiled code share\n+the same virtual address space), the execution is also terminated (see Fig. 13).\n+\n+\n+[rust-book-ch19-05]: https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html\n+[rust-book]: https://doc.rust-lang.org/book/title-page.html\n \n # HWAddressSanitizer\n "}, {"sha": "f2f74cc17b3de1b680287ad85f20f8f501967f62", "filename": "src/doc/unstable-book/src/language-features/cfi-encoding.md", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfi-encoding.md", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfi-encoding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fcfi-encoding.md?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,25 @@\n+# `cfi_encoding`\n+\n+The tracking issue for this feature is: [#89653]\n+\n+[#89653]: https://github.com/rust-lang/rust/issues/89653\n+\n+------------------------\n+\n+The `cfi_encoding` feature allows the user to define a CFI encoding for a type.\n+It allows the user to use a different names for types that otherwise would be\n+required to have the same name as used in externally defined C functions.\n+\n+## Examples\n+\n+```rust\n+#![feature(cfi_encoding, extern_types)]\n+\n+#[cfi_encoding = \"3Foo\"]\n+pub struct Type1(i32);\n+\n+extern {\n+    #[cfi_encoding = \"3Bar\"]\n+    type Type2;\n+}\n+```"}, {"sha": "7daa05f69d19fab02a236183b76687ca88830498", "filename": "tests/codegen/enable-lto-unit-splitting.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fenable-lto-unit-splitting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fenable-lto-unit-splitting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fenable-lto-unit-splitting.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,10 @@\n+// Verifies that \"EnableSplitLTOUnit\" module flag is added.\n+//\n+// compile-flags: -Clto -Ctarget-feature=-crt-static -Zsplit-lto-unit\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"EnableSplitLTOUnit\", i32 1}"}, {"sha": "1ee8bdfc3ab287a75505ac5372863ccb42a6ae12", "filename": "tests/codegen/sanitizer-cfi-add-canonical-jump-tables-flag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-add-canonical-jump-tables-flag.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -8,4 +8,4 @@\n pub fn foo() {\n }\n \n-// CHECK: !{{[0-9]+}} = !{i32 2, !\"CFI Canonical Jump Tables\", i32 1}\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"CFI Canonical Jump Tables\", i32 1}"}, {"sha": "68c91384b826b4d1771b1992cd6467e3e85ebc7d", "filename": "tests/codegen/sanitizer-cfi-add-enable-split-lto-unit-flag.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-add-enable-split-lto-unit-flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-add-enable-split-lto-unit-flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-add-enable-split-lto-unit-flag.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,11 @@\n+// Verifies that \"EnableSplitLTOUnit\" module flag is added.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"EnableSplitLTOUnit\", i32 1}"}, {"sha": "2b61c9078fd9cb379cfba31184c9570bc332f01a", "filename": "tests/codegen/sanitizer-cfi-emit-type-checks-attr-no-sanitize.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks-attr-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks-attr-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks-attr-no-sanitize.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,18 @@\n+// Verifies that pointer type membership tests for indirect calls are omitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Copt-level=0\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_sanitize)]\n+\n+#[no_sanitize(cfi)]\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: sanitizer_cfi_emit_type_checks_attr_no_sanitize::foo\n+    // CHECK:       Function Attrs: {{.*}}\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+    // CHECK:       start:\n+    // CHECK-NEXT:  {{%.+}} = call i32 %f(i32 %arg)\n+    // CHECK-NEXT:  ret i32 {{%.+}}\n+    f(arg)\n+}"}, {"sha": "cea6aac8b8ba4ca36e45200f00ea436e34b55bf5", "filename": "tests/codegen/sanitizer-cfi-emit-type-checks.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-checks.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -6,13 +6,12 @@\n #![crate_type=\"lib\"]\n \n pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n-    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}}\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n     // CHECK:       start:\n     // CHECK:       [[TT:%.+]] = call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"{{[[:print:]]+}}\")\n     // CHECK-NEXT:  br i1 [[TT]], label %type_test.pass, label %type_test.fail\n     // CHECK:       type_test.pass:\n     // CHECK-NEXT:  {{%.+}} = call i32 %f(i32 %arg)\n-    // CHECK-NEXT:  br label %bb1\n     // CHECK:       type_test.fail:\n     // CHECK-NEXT:  call void @llvm.trap()\n     // CHECK-NEXT:  unreachable"}, {"sha": "084d8bf803c8987a5aec5dee43366586d6930ac6", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-attr-cfi-encoding.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-attr-cfi-encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-attr-cfi-encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-attr-cfi-encoding.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,48 @@\n+// Verifies that user-defined CFI encoding for types are emitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![crate_type=\"lib\"]\n+#![feature(cfi_encoding, extern_types)]\n+\n+#[cfi_encoding = \"3Foo\"]\n+pub struct Type1(i32);\n+\n+extern {\n+    #[cfi_encoding = \"3Bar\"]\n+    type Type2;\n+}\n+\n+#[cfi_encoding = \"3Baz\"]\n+#[repr(transparent)]\n+pub struct Type3(i32);\n+\n+pub fn foo0(_: Type1) { }\n+// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo1(_: Type1, _: Type1) { }\n+// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo2(_: Type1, _: Type1, _: Type1) { }\n+// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo3(_: *mut Type2) { }\n+// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo4(_: *mut Type2, _: *mut Type2) { }\n+// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo5(_: *mut Type2, _: *mut Type2, _: *mut Type2) { }\n+// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo6(_: *mut Type3) { }\n+// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo7(_: *mut Type3, _: *mut Type3) { }\n+// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo8(_: *mut Type3, _: *mut Type3, _: *mut Type3) { }\n+// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+\n+// CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFv3FooE\"}\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFv3FooS_E\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFv3FooS_S_E\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFvP3BarE\"}\n+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFvP3BarS0_E\"}\n+// CHECK: ![[TYPE5]] = !{i64 0, !\"_ZTSFvP3BarS0_S0_E\"}\n+// CHECK: ![[TYPE6]] = !{i64 0, !\"_ZTSFvP3BazE\"}\n+// CHECK: ![[TYPE7]] = !{i64 0, !\"_ZTSFvP3BazS0_E\"}\n+// CHECK: ![[TYPE8]] = !{i64 0, !\"_ZTSFvP3BazS0_S0_E\"}"}, {"sha": "71e26e3fe8a65b5a4602a66ea86f2c4250f93cd9", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "status": "modified", "additions": 160, "deletions": 159, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-id-itanium-cxx-abi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -10,7 +10,7 @@\n #![feature(adt_const_params, extern_types, inline_const, type_alias_impl_trait)]\n \n extern crate core;\n-use core::ffi::c_void;\n+use core::ffi::*;\n use std::marker::PhantomData;\n \n // User-defined type (structure)\n@@ -113,9 +113,10 @@ pub fn fn1<'a>() {\n     let _: Type11 = Quuux;\n }\n \n-// repr(transparent) user-defined type\n+// Helper type to make Type12 have an unique id\n struct Foo(i32);\n \n+// repr(transparent) user-defined type\n #[repr(transparent)]\n pub struct Type12 {\n     member1: (),\n@@ -131,313 +132,313 @@ pub struct Type13<'a> {\n     member3: &'a Type13<'a>,\n }\n \n-// Helper type to allow `Type14<Bar>` to be a unique ID\n+// Helper type to make Type14 have an unique id\n pub struct Bar;\n \n-// repr(transparent) parameterized type\n+// repr(transparent) user-defined generic type\n #[repr(transparent)]\n pub struct Type14<T>(T);\n \n pub fn foo0(_: ()) { }\n-// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]]\n-pub fn foo1(_: c_void, _: ()) { }\n-// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]]\n+// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo1(_: (), _: c_void) { }\n+// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo2(_: (), _: c_void, _: c_void) { }\n-// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]]\n-pub fn foo3(_: *mut c_void) { }\n-// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]]\n-pub fn foo4(_: *mut c_void, _: *mut ()) { }\n-// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]]\n+// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo3(_: *mut ()) { }\n+// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo4(_: *mut (), _: *mut c_void) { }\n+// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo5(_: *mut (), _: *mut c_void, _: *mut c_void) { }\n-// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]]\n-pub fn foo6(_: *const c_void) { }\n-// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]]\n-pub fn foo7(_: *const c_void, _: *const ()) { }\n-// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]]\n+// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo6(_: *const ()) { }\n+// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo7(_: *const (), _: *const c_void) { }\n+// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo8(_: *const (), _: *const c_void, _: *const c_void) { }\n-// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]]\n+// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo9(_: bool) { }\n-// CHECK: define{{.*}}foo9{{.*}}!type ![[TYPE9:[0-9]+]]\n+// CHECK: define{{.*}}foo9{{.*}}!type ![[TYPE9:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo10(_: bool, _: bool) { }\n-// CHECK: define{{.*}}foo10{{.*}}!type ![[TYPE10:[0-9]+]]\n+// CHECK: define{{.*}}foo10{{.*}}!type ![[TYPE10:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo11(_: bool, _: bool, _: bool) { }\n-// CHECK: define{{.*}}foo11{{.*}}!type ![[TYPE11:[0-9]+]]\n+// CHECK: define{{.*}}foo11{{.*}}!type ![[TYPE11:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo12(_: i8) { }\n-// CHECK: define{{.*}}foo12{{.*}}!type ![[TYPE12:[0-9]+]]\n+// CHECK: define{{.*}}foo12{{.*}}!type ![[TYPE12:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo13(_: i8, _: i8) { }\n-// CHECK: define{{.*}}foo13{{.*}}!type ![[TYPE13:[0-9]+]]\n+// CHECK: define{{.*}}foo13{{.*}}!type ![[TYPE13:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo14(_: i8, _: i8, _: i8) { }\n-// CHECK: define{{.*}}foo14{{.*}}!type ![[TYPE14:[0-9]+]]\n+// CHECK: define{{.*}}foo14{{.*}}!type ![[TYPE14:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo15(_: i16) { }\n-// CHECK: define{{.*}}foo15{{.*}}!type ![[TYPE15:[0-9]+]]\n+// CHECK: define{{.*}}foo15{{.*}}!type ![[TYPE15:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo16(_: i16, _: i16) { }\n-// CHECK: define{{.*}}foo16{{.*}}!type ![[TYPE16:[0-9]+]]\n+// CHECK: define{{.*}}foo16{{.*}}!type ![[TYPE16:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo17(_: i16, _: i16, _: i16) { }\n-// CHECK: define{{.*}}foo17{{.*}}!type ![[TYPE17:[0-9]+]]\n+// CHECK: define{{.*}}foo17{{.*}}!type ![[TYPE17:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo18(_: i32) { }\n-// CHECK: define{{.*}}foo18{{.*}}!type ![[TYPE18:[0-9]+]]\n+// CHECK: define{{.*}}foo18{{.*}}!type ![[TYPE18:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo19(_: i32, _: i32) { }\n-// CHECK: define{{.*}}foo19{{.*}}!type ![[TYPE19:[0-9]+]]\n+// CHECK: define{{.*}}foo19{{.*}}!type ![[TYPE19:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo20(_: i32, _: i32, _: i32) { }\n-// CHECK: define{{.*}}foo20{{.*}}!type ![[TYPE20:[0-9]+]]\n+// CHECK: define{{.*}}foo20{{.*}}!type ![[TYPE20:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo21(_: i64) { }\n-// CHECK: define{{.*}}foo21{{.*}}!type ![[TYPE21:[0-9]+]]\n+// CHECK: define{{.*}}foo21{{.*}}!type ![[TYPE21:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo22(_: i64, _: i64) { }\n-// CHECK: define{{.*}}foo22{{.*}}!type ![[TYPE22:[0-9]+]]\n+// CHECK: define{{.*}}foo22{{.*}}!type ![[TYPE22:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo23(_: i64, _: i64, _: i64) { }\n-// CHECK: define{{.*}}foo23{{.*}}!type ![[TYPE23:[0-9]+]]\n+// CHECK: define{{.*}}foo23{{.*}}!type ![[TYPE23:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo24(_: i128) { }\n-// CHECK: define{{.*}}foo24{{.*}}!type ![[TYPE24:[0-9]+]]\n+// CHECK: define{{.*}}foo24{{.*}}!type ![[TYPE24:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo25(_: i128, _: i128) { }\n-// CHECK: define{{.*}}foo25{{.*}}!type ![[TYPE25:[0-9]+]]\n+// CHECK: define{{.*}}foo25{{.*}}!type ![[TYPE25:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo26(_: i128, _: i128, _: i128) { }\n-// CHECK: define{{.*}}foo26{{.*}}!type ![[TYPE26:[0-9]+]]\n+// CHECK: define{{.*}}foo26{{.*}}!type ![[TYPE26:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo27(_: isize) { }\n-// CHECK: define{{.*}}foo27{{.*}}!type ![[TYPE27:[0-9]+]]\n+// CHECK: define{{.*}}foo27{{.*}}!type ![[TYPE27:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo28(_: isize, _: isize) { }\n-// CHECK: define{{.*}}foo28{{.*}}!type ![[TYPE28:[0-9]+]]\n+// CHECK: define{{.*}}foo28{{.*}}!type ![[TYPE28:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo29(_: isize, _: isize, _: isize) { }\n-// CHECK: define{{.*}}foo29{{.*}}!type ![[TYPE29:[0-9]+]]\n+// CHECK: define{{.*}}foo29{{.*}}!type ![[TYPE29:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo30(_: u8) { }\n-// CHECK: define{{.*}}foo30{{.*}}!type ![[TYPE30:[0-9]+]]\n+// CHECK: define{{.*}}foo30{{.*}}!type ![[TYPE30:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo31(_: u8, _: u8) { }\n-// CHECK: define{{.*}}foo31{{.*}}!type ![[TYPE31:[0-9]+]]\n+// CHECK: define{{.*}}foo31{{.*}}!type ![[TYPE31:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo32(_: u8, _: u8, _: u8) { }\n-// CHECK: define{{.*}}foo32{{.*}}!type ![[TYPE32:[0-9]+]]\n+// CHECK: define{{.*}}foo32{{.*}}!type ![[TYPE32:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo33(_: u16) { }\n-// CHECK: define{{.*}}foo33{{.*}}!type ![[TYPE33:[0-9]+]]\n+// CHECK: define{{.*}}foo33{{.*}}!type ![[TYPE33:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo34(_: u16, _: u16) { }\n-// CHECK: define{{.*}}foo34{{.*}}!type ![[TYPE34:[0-9]+]]\n+// CHECK: define{{.*}}foo34{{.*}}!type ![[TYPE34:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo35(_: u16, _: u16, _: u16) { }\n-// CHECK: define{{.*}}foo35{{.*}}!type ![[TYPE35:[0-9]+]]\n+// CHECK: define{{.*}}foo35{{.*}}!type ![[TYPE35:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo36(_: u32) { }\n-// CHECK: define{{.*}}foo36{{.*}}!type ![[TYPE36:[0-9]+]]\n+// CHECK: define{{.*}}foo36{{.*}}!type ![[TYPE36:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo37(_: u32, _: u32) { }\n-// CHECK: define{{.*}}foo37{{.*}}!type ![[TYPE37:[0-9]+]]\n+// CHECK: define{{.*}}foo37{{.*}}!type ![[TYPE37:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo38(_: u32, _: u32, _: u32) { }\n-// CHECK: define{{.*}}foo38{{.*}}!type ![[TYPE38:[0-9]+]]\n+// CHECK: define{{.*}}foo38{{.*}}!type ![[TYPE38:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo39(_: u64) { }\n-// CHECK: define{{.*}}foo39{{.*}}!type ![[TYPE39:[0-9]+]]\n+// CHECK: define{{.*}}foo39{{.*}}!type ![[TYPE39:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo40(_: u64, _: u64) { }\n-// CHECK: define{{.*}}foo40{{.*}}!type ![[TYPE40:[0-9]+]]\n+// CHECK: define{{.*}}foo40{{.*}}!type ![[TYPE40:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo41(_: u64, _: u64, _: u64) { }\n-// CHECK: define{{.*}}foo41{{.*}}!type ![[TYPE41:[0-9]+]]\n+// CHECK: define{{.*}}foo41{{.*}}!type ![[TYPE41:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo42(_: u128) { }\n-// CHECK: define{{.*}}foo42{{.*}}!type ![[TYPE42:[0-9]+]]\n+// CHECK: define{{.*}}foo42{{.*}}!type ![[TYPE42:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo43(_: u128, _: u128) { }\n-// CHECK: define{{.*}}foo43{{.*}}!type ![[TYPE43:[0-9]+]]\n+// CHECK: define{{.*}}foo43{{.*}}!type ![[TYPE43:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo44(_: u128, _: u128, _: u128) { }\n-// CHECK: define{{.*}}foo44{{.*}}!type ![[TYPE44:[0-9]+]]\n+// CHECK: define{{.*}}foo44{{.*}}!type ![[TYPE44:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo45(_: usize) { }\n-// CHECK: define{{.*}}foo45{{.*}}!type ![[TYPE45:[0-9]+]]\n+// CHECK: define{{.*}}foo45{{.*}}!type ![[TYPE45:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo46(_: usize, _: usize) { }\n-// CHECK: define{{.*}}foo46{{.*}}!type ![[TYPE46:[0-9]+]]\n+// CHECK: define{{.*}}foo46{{.*}}!type ![[TYPE46:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo47(_: usize, _: usize, _: usize) { }\n-// CHECK: define{{.*}}foo47{{.*}}!type ![[TYPE47:[0-9]+]]\n+// CHECK: define{{.*}}foo47{{.*}}!type ![[TYPE47:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo48(_: f32) { }\n-// CHECK: define{{.*}}foo48{{.*}}!type ![[TYPE48:[0-9]+]]\n+// CHECK: define{{.*}}foo48{{.*}}!type ![[TYPE48:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo49(_: f32, _: f32) { }\n-// CHECK: define{{.*}}foo49{{.*}}!type ![[TYPE49:[0-9]+]]\n+// CHECK: define{{.*}}foo49{{.*}}!type ![[TYPE49:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo50(_: f32, _: f32, _: f32) { }\n-// CHECK: define{{.*}}foo50{{.*}}!type ![[TYPE50:[0-9]+]]\n+// CHECK: define{{.*}}foo50{{.*}}!type ![[TYPE50:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo51(_: f64) { }\n-// CHECK: define{{.*}}foo51{{.*}}!type ![[TYPE51:[0-9]+]]\n+// CHECK: define{{.*}}foo51{{.*}}!type ![[TYPE51:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo52(_: f64, _: f64) { }\n-// CHECK: define{{.*}}foo52{{.*}}!type ![[TYPE52:[0-9]+]]\n+// CHECK: define{{.*}}foo52{{.*}}!type ![[TYPE52:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo53(_: f64, _: f64, _: f64) { }\n-// CHECK: define{{.*}}foo53{{.*}}!type ![[TYPE53:[0-9]+]]\n+// CHECK: define{{.*}}foo53{{.*}}!type ![[TYPE53:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo54(_: char) { }\n-// CHECK: define{{.*}}foo54{{.*}}!type ![[TYPE54:[0-9]+]]\n+// CHECK: define{{.*}}foo54{{.*}}!type ![[TYPE54:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo55(_: char, _: char) { }\n-// CHECK: define{{.*}}foo55{{.*}}!type ![[TYPE55:[0-9]+]]\n+// CHECK: define{{.*}}foo55{{.*}}!type ![[TYPE55:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo56(_: char, _: char, _: char) { }\n-// CHECK: define{{.*}}foo56{{.*}}!type ![[TYPE56:[0-9]+]]\n+// CHECK: define{{.*}}foo56{{.*}}!type ![[TYPE56:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo57(_: &str) { }\n-// CHECK: define{{.*}}foo57{{.*}}!type ![[TYPE57:[0-9]+]]\n+// CHECK: define{{.*}}foo57{{.*}}!type ![[TYPE57:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo58(_: &str, _: &str) { }\n-// CHECK: define{{.*}}foo58{{.*}}!type ![[TYPE58:[0-9]+]]\n+// CHECK: define{{.*}}foo58{{.*}}!type ![[TYPE58:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo59(_: &str, _: &str, _: &str) { }\n-// CHECK: define{{.*}}foo59{{.*}}!type ![[TYPE59:[0-9]+]]\n+// CHECK: define{{.*}}foo59{{.*}}!type ![[TYPE59:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo60(_: (i32, i32)) { }\n-// CHECK: define{{.*}}foo60{{.*}}!type ![[TYPE60:[0-9]+]]\n+// CHECK: define{{.*}}foo60{{.*}}!type ![[TYPE60:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo61(_: (i32, i32), _: (i32, i32)) { }\n-// CHECK: define{{.*}}foo61{{.*}}!type ![[TYPE61:[0-9]+]]\n+// CHECK: define{{.*}}foo61{{.*}}!type ![[TYPE61:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo62(_: (i32, i32), _: (i32, i32), _: (i32, i32)) { }\n-// CHECK: define{{.*}}foo62{{.*}}!type ![[TYPE62:[0-9]+]]\n+// CHECK: define{{.*}}foo62{{.*}}!type ![[TYPE62:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo63(_: [i32; 32]) { }\n-// CHECK: define{{.*}}foo63{{.*}}!type ![[TYPE63:[0-9]+]]\n+// CHECK: define{{.*}}foo63{{.*}}!type ![[TYPE63:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo64(_: [i32; 32], _: [i32; 32]) { }\n-// CHECK: define{{.*}}foo64{{.*}}!type ![[TYPE64:[0-9]+]]\n+// CHECK: define{{.*}}foo64{{.*}}!type ![[TYPE64:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo65(_: [i32; 32], _: [i32; 32], _: [i32; 32]) { }\n-// CHECK: define{{.*}}foo65{{.*}}!type ![[TYPE65:[0-9]+]]\n+// CHECK: define{{.*}}foo65{{.*}}!type ![[TYPE65:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo66(_: &[i32]) { }\n-// CHECK: define{{.*}}foo66{{.*}}!type ![[TYPE66:[0-9]+]]\n+// CHECK: define{{.*}}foo66{{.*}}!type ![[TYPE66:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo67(_: &[i32], _: &[i32]) { }\n-// CHECK: define{{.*}}foo67{{.*}}!type ![[TYPE67:[0-9]+]]\n+// CHECK: define{{.*}}foo67{{.*}}!type ![[TYPE67:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo68(_: &[i32], _: &[i32], _: &[i32]) { }\n-// CHECK: define{{.*}}foo68{{.*}}!type ![[TYPE68:[0-9]+]]\n+// CHECK: define{{.*}}foo68{{.*}}!type ![[TYPE68:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo69(_: &Struct1::<i32>) { }\n-// CHECK: define{{.*}}foo69{{.*}}!type ![[TYPE69:[0-9]+]]\n+// CHECK: define{{.*}}foo69{{.*}}!type ![[TYPE69:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo70(_: &Struct1::<i32>, _: &Struct1::<i32>) { }\n-// CHECK: define{{.*}}foo70{{.*}}!type ![[TYPE70:[0-9]+]]\n+// CHECK: define{{.*}}foo70{{.*}}!type ![[TYPE70:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo71(_: &Struct1::<i32>, _: &Struct1::<i32>, _: &Struct1::<i32>) { }\n-// CHECK: define{{.*}}foo71{{.*}}!type ![[TYPE71:[0-9]+]]\n+// CHECK: define{{.*}}foo71{{.*}}!type ![[TYPE71:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo72(_: &Enum1::<i32>) { }\n-// CHECK: define{{.*}}foo72{{.*}}!type ![[TYPE72:[0-9]+]]\n+// CHECK: define{{.*}}foo72{{.*}}!type ![[TYPE72:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo73(_: &Enum1::<i32>, _: &Enum1::<i32>) { }\n-// CHECK: define{{.*}}foo73{{.*}}!type ![[TYPE73:[0-9]+]]\n+// CHECK: define{{.*}}foo73{{.*}}!type ![[TYPE73:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo74(_: &Enum1::<i32>, _: &Enum1::<i32>, _: &Enum1::<i32>) { }\n-// CHECK: define{{.*}}foo74{{.*}}!type ![[TYPE74:[0-9]+]]\n+// CHECK: define{{.*}}foo74{{.*}}!type ![[TYPE74:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo75(_: &Union1::<i32>) { }\n-// CHECK: define{{.*}}foo75{{.*}}!type ![[TYPE75:[0-9]+]]\n+// CHECK: define{{.*}}foo75{{.*}}!type ![[TYPE75:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo76(_: &Union1::<i32>, _: &Union1::<i32>) { }\n-// CHECK: define{{.*}}foo76{{.*}}!type ![[TYPE76:[0-9]+]]\n+// CHECK: define{{.*}}foo76{{.*}}!type ![[TYPE76:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo77(_: &Union1::<i32>, _: &Union1::<i32>, _: &Union1::<i32>) { }\n-// CHECK: define{{.*}}foo77{{.*}}!type ![[TYPE77:[0-9]+]]\n+// CHECK: define{{.*}}foo77{{.*}}!type ![[TYPE77:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo78(_: *mut type1) { }\n-// CHECK: define{{.*}}foo78{{.*}}!type ![[TYPE78:[0-9]+]]\n+// CHECK: define{{.*}}foo78{{.*}}!type ![[TYPE78:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo79(_: *mut type1, _: *mut type1) { }\n-// CHECK: define{{.*}}foo79{{.*}}!type ![[TYPE79:[0-9]+]]\n+// CHECK: define{{.*}}foo79{{.*}}!type ![[TYPE79:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo80(_: *mut type1, _: *mut type1, _: *mut type1) { }\n-// CHECK: define{{.*}}foo80{{.*}}!type ![[TYPE80:[0-9]+]]\n+// CHECK: define{{.*}}foo80{{.*}}!type ![[TYPE80:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo81(_: &mut i32) { }\n-// CHECK: define{{.*}}foo81{{.*}}!type ![[TYPE81:[0-9]+]]\n+// CHECK: define{{.*}}foo81{{.*}}!type ![[TYPE81:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo82(_: &mut i32, _: &i32) { }\n-// CHECK: define{{.*}}foo82{{.*}}!type ![[TYPE82:[0-9]+]]\n+// CHECK: define{{.*}}foo82{{.*}}!type ![[TYPE82:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo83(_: &mut i32, _: &i32, _: &i32) { }\n-// CHECK: define{{.*}}foo83{{.*}}!type ![[TYPE83:[0-9]+]]\n+// CHECK: define{{.*}}foo83{{.*}}!type ![[TYPE83:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo84(_: &i32) { }\n-// CHECK: define{{.*}}foo84{{.*}}!type ![[TYPE84:[0-9]+]]\n+// CHECK: define{{.*}}foo84{{.*}}!type ![[TYPE84:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo85(_: &i32, _: &mut i32) { }\n-// CHECK: define{{.*}}foo85{{.*}}!type ![[TYPE85:[0-9]+]]\n+// CHECK: define{{.*}}foo85{{.*}}!type ![[TYPE85:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo86(_: &i32, _: &mut i32, _: &mut i32) { }\n-// CHECK: define{{.*}}foo86{{.*}}!type ![[TYPE86:[0-9]+]]\n+// CHECK: define{{.*}}foo86{{.*}}!type ![[TYPE86:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo87(_: *mut i32) { }\n-// CHECK: define{{.*}}foo87{{.*}}!type ![[TYPE87:[0-9]+]]\n+// CHECK: define{{.*}}foo87{{.*}}!type ![[TYPE87:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo88(_: *mut i32, _: *const i32) { }\n-// CHECK: define{{.*}}foo88{{.*}}!type ![[TYPE88:[0-9]+]]\n+// CHECK: define{{.*}}foo88{{.*}}!type ![[TYPE88:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo89(_: *mut i32, _: *const i32, _: *const i32) { }\n-// CHECK: define{{.*}}foo89{{.*}}!type ![[TYPE89:[0-9]+]]\n+// CHECK: define{{.*}}foo89{{.*}}!type ![[TYPE89:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo90(_: *const i32) { }\n-// CHECK: define{{.*}}foo90{{.*}}!type ![[TYPE90:[0-9]+]]\n+// CHECK: define{{.*}}foo90{{.*}}!type ![[TYPE90:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo91(_: *const i32, _: *mut i32) { }\n-// CHECK: define{{.*}}foo91{{.*}}!type ![[TYPE91:[0-9]+]]\n+// CHECK: define{{.*}}foo91{{.*}}!type ![[TYPE91:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo92(_: *const i32, _: *mut i32, _: *mut i32) { }\n-// CHECK: define{{.*}}foo92{{.*}}!type ![[TYPE92:[0-9]+]]\n+// CHECK: define{{.*}}foo92{{.*}}!type ![[TYPE92:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo93(_: fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo93{{.*}}!type ![[TYPE93:[0-9]+]]\n+// CHECK: define{{.*}}foo93{{.*}}!type ![[TYPE93:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo94(_: fn(i32) -> i32, _: fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo94{{.*}}!type ![[TYPE94:[0-9]+]]\n+// CHECK: define{{.*}}foo94{{.*}}!type ![[TYPE94:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo95(_: fn(i32) -> i32, _: fn(i32) -> i32, _: fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo95{{.*}}!type ![[TYPE95:[0-9]+]]\n+// CHECK: define{{.*}}foo95{{.*}}!type ![[TYPE95:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo96(_: &dyn Fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo96{{.*}}!type ![[TYPE96:[0-9]+]]\n+// CHECK: define{{.*}}foo96{{.*}}!type ![[TYPE96:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo97(_: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo97{{.*}}!type ![[TYPE97:[0-9]+]]\n+// CHECK: define{{.*}}foo97{{.*}}!type ![[TYPE97:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo98(_: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32, _: &dyn Fn(i32) -> i32) { }\n-// CHECK: define{{.*}}foo98{{.*}}!type ![[TYPE98:[0-9]+]]\n+// CHECK: define{{.*}}foo98{{.*}}!type ![[TYPE98:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo99(_: &dyn FnMut(i32) -> i32) { }\n-// CHECK: define{{.*}}foo99{{.*}}!type ![[TYPE99:[0-9]+]]\n+// CHECK: define{{.*}}foo99{{.*}}!type ![[TYPE99:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo100(_: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32) { }\n-// CHECK: define{{.*}}foo100{{.*}}!type ![[TYPE100:[0-9]+]]\n+// CHECK: define{{.*}}foo100{{.*}}!type ![[TYPE100:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo101(_: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32, _: &dyn FnMut(i32) -> i32) { }\n-// CHECK: define{{.*}}foo101{{.*}}!type ![[TYPE101:[0-9]+]]\n+// CHECK: define{{.*}}foo101{{.*}}!type ![[TYPE101:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo102(_: &dyn FnOnce(i32) -> i32) { }\n-// CHECK: define{{.*}}foo102{{.*}}!type ![[TYPE102:[0-9]+]]\n+// CHECK: define{{.*}}foo102{{.*}}!type ![[TYPE102:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo103(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) { }\n-// CHECK: define{{.*}}foo103{{.*}}!type ![[TYPE103:[0-9]+]]\n+// CHECK: define{{.*}}foo103{{.*}}!type ![[TYPE103:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo104(_: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32, _: &dyn FnOnce(i32) -> i32) {}\n-// CHECK: define{{.*}}foo104{{.*}}!type ![[TYPE104:[0-9]+]]\n+// CHECK: define{{.*}}foo104{{.*}}!type ![[TYPE104:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo105(_: &dyn Send) { }\n-// CHECK: define{{.*}}foo105{{.*}}!type ![[TYPE105:[0-9]+]]\n+// CHECK: define{{.*}}foo105{{.*}}!type ![[TYPE105:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo106(_: &dyn Send, _: &dyn Send) { }\n-// CHECK: define{{.*}}foo106{{.*}}!type ![[TYPE106:[0-9]+]]\n+// CHECK: define{{.*}}foo106{{.*}}!type ![[TYPE106:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo107(_: &dyn Send, _: &dyn Send, _: &dyn Send) { }\n-// CHECK: define{{.*}}foo107{{.*}}!type ![[TYPE107:[0-9]+]]\n+// CHECK: define{{.*}}foo107{{.*}}!type ![[TYPE107:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo108(_: Type1) { }\n-// CHECK: define{{.*}}foo108{{.*}}!type ![[TYPE108:[0-9]+]]\n+// CHECK: define{{.*}}foo108{{.*}}!type ![[TYPE108:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo109(_: Type1, _: Type1) { }\n-// CHECK: define{{.*}}foo109{{.*}}!type ![[TYPE109:[0-9]+]]\n+// CHECK: define{{.*}}foo109{{.*}}!type ![[TYPE109:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo110(_: Type1, _: Type1, _: Type1) { }\n-// CHECK: define{{.*}}foo110{{.*}}!type ![[TYPE110:[0-9]+]]\n+// CHECK: define{{.*}}foo110{{.*}}!type ![[TYPE110:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo111(_: Type2) { }\n-// CHECK: define{{.*}}foo111{{.*}}!type ![[TYPE111:[0-9]+]]\n+// CHECK: define{{.*}}foo111{{.*}}!type ![[TYPE111:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo112(_: Type2, _: Type2) { }\n-// CHECK: define{{.*}}foo112{{.*}}!type ![[TYPE112:[0-9]+]]\n+// CHECK: define{{.*}}foo112{{.*}}!type ![[TYPE112:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo113(_: Type2, _: Type2, _: Type2) { }\n-// CHECK: define{{.*}}foo113{{.*}}!type ![[TYPE113:[0-9]+]]\n+// CHECK: define{{.*}}foo113{{.*}}!type ![[TYPE113:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo114(_: Type3) { }\n-// CHECK: define{{.*}}foo114{{.*}}!type ![[TYPE114:[0-9]+]]\n+// CHECK: define{{.*}}foo114{{.*}}!type ![[TYPE114:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo115(_: Type3, _: Type3) { }\n-// CHECK: define{{.*}}foo115{{.*}}!type ![[TYPE115:[0-9]+]]\n+// CHECK: define{{.*}}foo115{{.*}}!type ![[TYPE115:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo116(_: Type3, _: Type3, _: Type3) { }\n-// CHECK: define{{.*}}foo116{{.*}}!type ![[TYPE116:[0-9]+]]\n+// CHECK: define{{.*}}foo116{{.*}}!type ![[TYPE116:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo117(_: Type4) { }\n-// CHECK: define{{.*}}foo117{{.*}}!type ![[TYPE117:[0-9]+]]\n+// CHECK: define{{.*}}foo117{{.*}}!type ![[TYPE117:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo118(_: Type4, _: Type4) { }\n-// CHECK: define{{.*}}foo118{{.*}}!type ![[TYPE118:[0-9]+]]\n+// CHECK: define{{.*}}foo118{{.*}}!type ![[TYPE118:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo119(_: Type4, _: Type4, _: Type4) { }\n-// CHECK: define{{.*}}foo119{{.*}}!type ![[TYPE119:[0-9]+]]\n+// CHECK: define{{.*}}foo119{{.*}}!type ![[TYPE119:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo120(_: Type5) { }\n-// CHECK: define{{.*}}foo120{{.*}}!type ![[TYPE120:[0-9]+]]\n+// CHECK: define{{.*}}foo120{{.*}}!type ![[TYPE120:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo121(_: Type5, _: Type5) { }\n-// CHECK: define{{.*}}foo121{{.*}}!type ![[TYPE121:[0-9]+]]\n+// CHECK: define{{.*}}foo121{{.*}}!type ![[TYPE121:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo122(_: Type5, _: Type5, _: Type5) { }\n-// CHECK: define{{.*}}foo122{{.*}}!type ![[TYPE122:[0-9]+]]\n+// CHECK: define{{.*}}foo122{{.*}}!type ![[TYPE122:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo123(_: Type6) { }\n-// CHECK: define{{.*}}foo123{{.*}}!type ![[TYPE123:[0-9]+]]\n+// CHECK: define{{.*}}foo123{{.*}}!type ![[TYPE123:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo124(_: Type6, _: Type6) { }\n-// CHECK: define{{.*}}foo124{{.*}}!type ![[TYPE124:[0-9]+]]\n+// CHECK: define{{.*}}foo124{{.*}}!type ![[TYPE124:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo125(_: Type6, _: Type6, _: Type6) { }\n-// CHECK: define{{.*}}foo125{{.*}}!type ![[TYPE125:[0-9]+]]\n+// CHECK: define{{.*}}foo125{{.*}}!type ![[TYPE125:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo126(_: Type7) { }\n-// CHECK: define{{.*}}foo126{{.*}}!type ![[TYPE126:[0-9]+]]\n+// CHECK: define{{.*}}foo126{{.*}}!type ![[TYPE126:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo127(_: Type7, _: Type7) { }\n-// CHECK: define{{.*}}foo127{{.*}}!type ![[TYPE127:[0-9]+]]\n+// CHECK: define{{.*}}foo127{{.*}}!type ![[TYPE127:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo128(_: Type7, _: Type7, _: Type7) { }\n-// CHECK: define{{.*}}foo128{{.*}}!type ![[TYPE128:[0-9]+]]\n+// CHECK: define{{.*}}foo128{{.*}}!type ![[TYPE128:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo129(_: Type8) { }\n-// CHECK: define{{.*}}foo129{{.*}}!type ![[TYPE129:[0-9]+]]\n+// CHECK: define{{.*}}foo129{{.*}}!type ![[TYPE129:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo130(_: Type8, _: Type8) { }\n-// CHECK: define{{.*}}foo130{{.*}}!type ![[TYPE130:[0-9]+]]\n+// CHECK: define{{.*}}foo130{{.*}}!type ![[TYPE130:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo131(_: Type8, _: Type8, _: Type8) { }\n-// CHECK: define{{.*}}foo131{{.*}}!type ![[TYPE131:[0-9]+]]\n+// CHECK: define{{.*}}foo131{{.*}}!type ![[TYPE131:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo132(_: Type9) { }\n-// CHECK: define{{.*}}foo132{{.*}}!type ![[TYPE132:[0-9]+]]\n+// CHECK: define{{.*}}foo132{{.*}}!type ![[TYPE132:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo133(_: Type9, _: Type9) { }\n-// CHECK: define{{.*}}foo133{{.*}}!type ![[TYPE133:[0-9]+]]\n+// CHECK: define{{.*}}foo133{{.*}}!type ![[TYPE133:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo134(_: Type9, _: Type9, _: Type9) { }\n-// CHECK: define{{.*}}foo134{{.*}}!type ![[TYPE134:[0-9]+]]\n+// CHECK: define{{.*}}foo134{{.*}}!type ![[TYPE134:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo135(_: Type10) { }\n-// CHECK: define{{.*}}foo135{{.*}}!type ![[TYPE135:[0-9]+]]\n+// CHECK: define{{.*}}foo135{{.*}}!type ![[TYPE135:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo136(_: Type10, _: Type10) { }\n-// CHECK: define{{.*}}foo136{{.*}}!type ![[TYPE136:[0-9]+]]\n+// CHECK: define{{.*}}foo136{{.*}}!type ![[TYPE136:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo137(_: Type10, _: Type10, _: Type10) { }\n-// CHECK: define{{.*}}foo137{{.*}}!type ![[TYPE137:[0-9]+]]\n+// CHECK: define{{.*}}foo137{{.*}}!type ![[TYPE137:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo138(_: Type11) { }\n-// CHECK: define{{.*}}foo138{{.*}}!type ![[TYPE138:[0-9]+]]\n+// CHECK: define{{.*}}foo138{{.*}}!type ![[TYPE138:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo139(_: Type11, _: Type11) { }\n-// CHECK: define{{.*}}foo139{{.*}}!type ![[TYPE139:[0-9]+]]\n+// CHECK: define{{.*}}foo139{{.*}}!type ![[TYPE139:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo140(_: Type11, _: Type11, _: Type11) { }\n-// CHECK: define{{.*}}foo140{{.*}}!type ![[TYPE140:[0-9]+]]\n+// CHECK: define{{.*}}foo140{{.*}}!type ![[TYPE140:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo141(_: Type12) { }\n-// CHECK: define{{.*}}foo141{{.*}}!type ![[TYPE141:[0-9]+]]\n+// CHECK: define{{.*}}foo141{{.*}}!type ![[TYPE141:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo142(_: Type12, _: Type12) { }\n-// CHECK: define{{.*}}foo142{{.*}}!type ![[TYPE142:[0-9]+]]\n+// CHECK: define{{.*}}foo142{{.*}}!type ![[TYPE142:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo143(_: Type12, _: Type12, _: Type12) { }\n-// CHECK: define{{.*}}foo143{{.*}}!type ![[TYPE143:[0-9]+]]\n+// CHECK: define{{.*}}foo143{{.*}}!type ![[TYPE143:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo144(_: Type13) { }\n-// CHECK: define{{.*}}foo144{{.*}}!type ![[TYPE144:[0-9]+]]\n+// CHECK: define{{.*}}foo144{{.*}}!type ![[TYPE144:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo145(_: Type13, _: Type13) { }\n-// CHECK: define{{.*}}foo145{{.*}}!type ![[TYPE145:[0-9]+]]\n+// CHECK: define{{.*}}foo145{{.*}}!type ![[TYPE145:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo146(_: Type13, _: Type13, _: Type13) { }\n-// CHECK: define{{.*}}foo146{{.*}}!type ![[TYPE146:[0-9]+]]\n+// CHECK: define{{.*}}foo146{{.*}}!type ![[TYPE146:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo147(_: Type14<Bar>) { }\n-// CHECK: define{{.*}}foo147{{.*}}!type ![[TYPE147:[0-9]+]]\n+// CHECK: define{{.*}}foo147{{.*}}!type ![[TYPE147:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo148(_: Type14<Bar>, _: Type14<Bar>) { }\n-// CHECK: define{{.*}}foo148{{.*}}!type ![[TYPE148:[0-9]+]]\n+// CHECK: define{{.*}}foo148{{.*}}!type ![[TYPE148:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n pub fn foo149(_: Type14<Bar>, _: Type14<Bar>, _: Type14<Bar>) { }\n-// CHECK: define{{.*}}foo149{{.*}}!type ![[TYPE149:[0-9]+]]\n+// CHECK: define{{.*}}foo149{{.*}}!type ![[TYPE149:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n \n // CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFvvE\"}\n // CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvvvE\"}"}, {"sha": "78ef0c2c7d6bacf1d1337e2a61e1c7e8190a2f93", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi-generalized.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-generalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-generalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-generalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,31 @@\n+// Verifies that generalized type metadata for functions are emitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-generalize-pointers\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_E.generalized\")\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_E.generalized\")\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_S_E.generalized\")\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFu3i32PKvS_E.generalized\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFu3i32PKvS_S_E.generalized\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFu3i32PKvS_S_S_E.generalized\"}"}, {"sha": "3b72459c4b097684aa5410fd441c2d9776e690cd", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized-generalized.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized-generalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized-generalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized-generalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,31 @@\n+// Verifies that normalized and generalized type metadata for functions are emitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers -Zsanitizer-cfi-generalize-pointers\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}![[TYPE1:[0-9]+]]\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_E.normalized.generalized\")\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}![[TYPE2:[0-9]+]]\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_E.normalized.generalized\")\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}![[TYPE3:[0-9]+]]\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_S_E.normalized.generalized\")\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFu3i32PKvS_E.normalized.generalized\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFu3i32PKvS_S_E.normalized.generalized\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFu3i32PKvS_S_S_E.normalized.generalized\"}"}, {"sha": "9218e9947bfe3cae1a9faac4ac721d3a1759ac22", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi-normalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,31 @@\n+// Verifies that normalized type metadata for functions are emitted.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_E.normalized\")\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_E.normalized\")\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}}\n+    // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_S_E.normalized\")\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFu3i32PFS_S_ES_E.normalized\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFu3i32PFS_S_S_ES_S_E.normalized\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFu3i32PFS_S_S_S_ES_S_S_E.normalized\"}"}, {"sha": "f9fd816dedb9d35ea09ddc6885bb8c516ba9c9d4", "filename": "tests/codegen/sanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-emit-type-metadata-itanium-cxx-abi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -7,21 +7,21 @@\n \n pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}foo\n-    // CHECK-SAME: {{.*}}!type ![[TYPE1:[0-9]+]]\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n     // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_E\")\n     f(arg)\n }\n \n pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}bar\n-    // CHECK-SAME: {{.*}}!type ![[TYPE2:[0-9]+]]\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n     // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_E\")\n     f(arg1, arg2)\n }\n \n pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}baz\n-    // CHECK-SAME: {{.*}}!type ![[TYPE3:[0-9]+]]\n+    // CHECK-SAME:  {{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}} !type !{{[0-9]+}}\n     // CHECK:       call i1 @llvm.type.test({{i8\\*|ptr}} {{%f|%0}}, metadata !\"_ZTSFu3i32S_S_S_E\")\n     f(arg1, arg2, arg3)\n }"}, {"sha": "677ebdb27ec5e7505530bc453c6a1edac2fde917", "filename": "tests/codegen/sanitizer-cfi-generalize-pointers.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-generalize-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-generalize-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-generalize-pointers.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,46 @@\n+// Verifies that pointer types are generalized.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-generalize-pointers\n+\n+#![crate_type=\"lib\"]\n+\n+extern crate core;\n+\n+pub fn foo0(_: &mut i32) { }\n+// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo1(_: &mut i32, _: &mut i32) { }\n+// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo2(_: &mut i32, _: &mut i32, _: &mut i32) { }\n+// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo3(_: &i32) { }\n+// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo4(_: &i32, _: &i32) { }\n+// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo5(_: &i32, _: &i32, _: &i32) { }\n+// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo6(_: *mut i32) { }\n+// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo7(_: *mut i32, _: *mut i32) { }\n+// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo8(_: *mut i32, _: *mut i32, _: *mut i32) { }\n+// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo9(_: *const i32) { }\n+// CHECK: define{{.*}}foo9{{.*}}!type ![[TYPE9:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo10(_: *const i32, _: *const i32) { }\n+// CHECK: define{{.*}}foo10{{.*}}!type ![[TYPE10:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+pub fn foo11(_: *const i32, _: *const i32, _: *const i32) { }\n+// CHECK: define{{.*}}foo11{{.*}}!type ![[TYPE11:[0-9]+]] !type !{{[0-9]+}} !type !{{[0-9]+}}\n+\n+// CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFvU3mutu3refIvEE.generalized\"}\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvU3mutu3refIvES0_E.generalized\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFvU3mutu3refIvES0_S0_E.generalized\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFvu3refIvEE.generalized\"}\n+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFvu3refIvES_E.generalized\"}\n+// CHECK: ![[TYPE5]] = !{i64 0, !\"_ZTSFvu3refIvES_S_E.generalized\"}\n+// CHECK: ![[TYPE6]] = !{i64 0, !\"_ZTSFvPvE.generalized\"}\n+// CHECK: ![[TYPE7]] = !{i64 0, !\"_ZTSFvPvS_E.generalized\"}\n+// CHECK: ![[TYPE8]] = !{i64 0, !\"_ZTSFvPvS_S_E.generalized\"}\n+// CHECK: ![[TYPE9]] = !{i64 0, !\"_ZTSFvPKvE.generalized\"}\n+// CHECK: ![[TYPE10]] = !{i64 0, !\"_ZTSFvPKvS0_E.generalized\"}\n+// CHECK: ![[TYPE11]] = !{i64 0, !\"_ZTSFvPKvS0_S0_E.generalized\"}"}, {"sha": "aa3913cb8e7d27e551bc8a93c6a2deac151d8f35", "filename": "tests/codegen/sanitizer-cfi-normalize-integers.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-normalize-integers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-cfi-normalize-integers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-cfi-normalize-integers.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,83 @@\n+// Verifies that integer types are normalized.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers\n+\n+#![crate_type=\"lib\"]\n+\n+extern crate core;\n+use core::ffi::*;\n+\n+pub fn foo0(_: bool) { }\n+// CHECK: define{{.*}}foo0{{.*}}!type ![[TYPE0:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo1(_: bool, _: c_uchar) { }\n+// CHECK: define{{.*}}foo1{{.*}}!type ![[TYPE1:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo2(_: bool, _: c_uchar, _: c_uchar) { }\n+// CHECK: define{{.*}}foo2{{.*}}!type ![[TYPE2:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo3(_: isize) { }\n+// CHECK: define{{.*}}foo3{{.*}}!type ![[TYPE3:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo4(_: isize, _: c_long) { }\n+// CHECK: define{{.*}}foo4{{.*}}!type ![[TYPE4:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo5(_: isize, _: c_long, _: c_longlong) { }\n+// CHECK: define{{.*}}foo5{{.*}}!type ![[TYPE5:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo6(_: usize) { }\n+// CHECK: define{{.*}}foo6{{.*}}!type ![[TYPE6:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo7(_: usize, _: c_ulong) { }\n+// CHECK: define{{.*}}foo7{{.*}}!type ![[TYPE7:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo8(_: usize, _: c_ulong, _: c_ulonglong) { }\n+// CHECK: define{{.*}}foo8{{.*}}!type ![[TYPE8:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo9(_: c_schar) { }\n+// CHECK: define{{.*}}foo9{{.*}}!type ![[TYPE9:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo10(_: c_char, _: c_schar) { }\n+// CHECK: define{{.*}}foo10{{.*}}!type ![[TYPE10:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo11(_: c_char, _: c_schar, _: c_schar) { }\n+// CHECK: define{{.*}}foo11{{.*}}!type ![[TYPE11:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo12(_: c_int) { }\n+// CHECK: define{{.*}}foo12{{.*}}!type ![[TYPE12:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo13(_: c_int, _: c_int) { }\n+// CHECK: define{{.*}}foo13{{.*}}!type ![[TYPE13:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo14(_: c_int, _: c_int, _: c_int) { }\n+// CHECK: define{{.*}}foo14{{.*}}!type ![[TYPE14:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo15(_: c_short) { }\n+// CHECK: define{{.*}}foo15{{.*}}!type ![[TYPE15:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo16(_: c_short, _: c_short) { }\n+// CHECK: define{{.*}}foo16{{.*}}!type ![[TYPE16:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo17(_: c_short, _: c_short, _: c_short) { }\n+// CHECK: define{{.*}}foo17{{.*}}!type ![[TYPE17:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo18(_: c_uint) { }\n+// CHECK: define{{.*}}foo18{{.*}}!type ![[TYPE18:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo19(_: c_uint, _: c_uint) { }\n+// CHECK: define{{.*}}foo19{{.*}}!type ![[TYPE19:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo20(_: c_uint, _: c_uint, _: c_uint) { }\n+// CHECK: define{{.*}}foo20{{.*}}!type ![[TYPE20:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo21(_: c_ushort) { }\n+// CHECK: define{{.*}}foo21{{.*}}!type ![[TYPE21:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo22(_: c_ushort, _: c_ushort) { }\n+// CHECK: define{{.*}}foo22{{.*}}!type ![[TYPE22:[0-9]+]] !type !{{[0-9]+}}\n+pub fn foo23(_: c_ushort, _: c_ushort, _: c_ushort) { }\n+// CHECK: define{{.*}}foo23{{.*}}!type ![[TYPE23:[0-9]+]] !type !{{[0-9]+}}\n+\n+// CHECK: ![[TYPE0]] = !{i64 0, !\"_ZTSFvu2u8E.normalized\"}\n+// CHECK: ![[TYPE1]] = !{i64 0, !\"_ZTSFvu2u8S_E.normalized\"}\n+// CHECK: ![[TYPE2]] = !{i64 0, !\"_ZTSFvu2u8S_S_E.normalized\"}\n+// CHECK: ![[TYPE3]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}E.normalized\"}\n+// CHECK: ![[TYPE4]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}{{u3i32|u3i64|S_}}E.normalized\"}\n+// CHECK: ![[TYPE5]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}{{u3i32|u3i64|S_}}{{u3i64|S_|S0_}}E.normalized\"}\n+// CHECK: ![[TYPE6]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}E.normalized\"}\n+// CHECK: ![[TYPE7]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}{{u3u32|u3u64|S_}}E.normalized\"}\n+// CHECK: ![[TYPE8]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}{{u3u32|u3u64|S_}}{{u3u64|S_|S0_}}E.normalized\"}\n+// CHECK: ![[TYPE9]] = !{i64 0, !\"_ZTSFvu2i8E.normalized\"}\n+// CHECK: ![[TYPE10]] = !{i64 0, !\"_ZTSFv{{u2i8S_|u2u8u2i8}}E.normalized\"}\n+// CHECK: ![[TYPE11]] = !{i64 0, !\"_ZTSFv{{u2i8S_S_|u2u8u2i8S0_}}E.normalized\"}\n+// CHECK: ![[TYPE12]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}E.normalized\"}\n+// CHECK: ![[TYPE13]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}S_E.normalized\"}\n+// CHECK: ![[TYPE14]] = !{i64 0, !\"_ZTSFv{{u3i16|u3i32|u3i64}}S_S_E.normalized\"}\n+// CHECK: ![[TYPE15]] = !{i64 0, !\"_ZTSFvu3i16E.normalized\"}\n+// CHECK: ![[TYPE16]] = !{i64 0, !\"_ZTSFvu3i16S_E.normalized\"}\n+// CHECK: ![[TYPE17]] = !{i64 0, !\"_ZTSFvu3i16S_S_E.normalized\"}\n+// CHECK: ![[TYPE18]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}E.normalized\"}\n+// CHECK: ![[TYPE19]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}S_E.normalized\"}\n+// CHECK: ![[TYPE20]] = !{i64 0, !\"_ZTSFv{{u3u16|u3u32|u3u64}}S_S_E.normalized\"}\n+// CHECK: ![[TYPE21]] = !{i64 0, !\"_ZTSFvu3u16E.normalized\"}\n+// CHECK: ![[TYPE22]] = !{i64 0, !\"_ZTSFvu3u16S_E.normalized\"}\n+// CHECK: ![[TYPE23]] = !{i64 0, !\"_ZTSFvu3u16S_S_E.normalized\"}"}, {"sha": "bb317e4a2fad384970de14762c0c7f2dcb79b5ad", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-attr-no-sanitize.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-attr-no-sanitize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-attr-no-sanitize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-attr-no-sanitize.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,30 @@\n+// Verifies that KCFI operand bundles are omitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Copt-level=0\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, no_sanitize, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+#[no_sanitize(kcfi)]\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: sanitizer_kcfi_emit_kcfi_operand_bundle_attr_no_sanitize::foo\n+    // CHECK:       Function Attrs: {{.*}}\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       start:\n+    // CHECK-NOT:   {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 {{[-0-9]+}}) ]\n+    // CHECK:       ret i32 {{%.+}}\n+    f(arg)\n+}"}, {"sha": "29e4df3511fbbc9178a9d5b1ffac737e26d97345", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-generalized.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-generalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-generalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-generalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,44 @@\n+// Verifies that generalized KCFI type metadata for functions are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Zsanitizer-cfi-generalize-pointers\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE1:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 233085384) ]\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE2:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2){{.*}}[ \"kcfi\"(i32 435418021) ]\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE3:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2, i32 {{(noundef )*}}%arg3){{.*}}[ \"kcfi\"(i32 -1003721339) ]\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i32 -1741689296}\n+// CHECK: ![[TYPE2]] = !{i32 489439372}\n+// CHECK: ![[TYPE3]] = !{i32 2026563871}"}, {"sha": "84d678a33ba906dc26d4444a53be32dc2c44c069", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized-generalized.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized-generalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized-generalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized-generalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,44 @@\n+// Verifies that normalized and generalized KCFI type metadata for functions are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Zsanitizer-cfi-normalize-integers -Zsanitizer-cfi-generalize-pointers\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE1:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 -686570305) ]\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE2:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2){{.*}}[ \"kcfi\"(i32 1281038450) ]\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE3:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2, i32 {{(noundef )*}}%arg3){{.*}}[ \"kcfi\"(i32 -1751512973) ]\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i32 975484707}\n+// CHECK: ![[TYPE2]] = !{i32 1658833102}\n+// CHECK: ![[TYPE3]] = !{i32 230429758}"}, {"sha": "761c37a9e06a07c443f209c627083e1971f6ae7c", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi-normalized.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,44 @@\n+// Verifies that normalized KCFI type metadata for functions are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Zsanitizer-cfi-normalize-integers\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE1:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 -841055669) ]\n+    f(arg)\n+}\n+\n+pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}bar\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE2:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2){{.*}}[ \"kcfi\"(i32 1390819368) ]\n+    f(arg1, arg2)\n+}\n+\n+pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}baz\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE3:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2, i32 {{(noundef )*}}%arg3){{.*}}[ \"kcfi\"(i32 586925835) ]\n+    f(arg1, arg2, arg3)\n+}\n+\n+// CHECK: ![[TYPE1]] = !{i32 -458317079}\n+// CHECK: ![[TYPE2]] = !{i32 1737138182}\n+// CHECK: ![[TYPE3]] = !{i32 197182412}"}, {"sha": "83cda0ef136f88510202d705205e1949305595d8", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle-itanium-cxx-abi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -20,22 +20,22 @@ impl Copy for i32 {}\n \n pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}foo\n-    // CHECK-SAME: {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE1:[0-9]+]]\n-    // CHECK: call i32 %f(i32 %arg){{.*}}[ \"kcfi\"(i32 -1666898348) ]\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE1:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 -1666898348) ]\n     f(arg)\n }\n \n pub fn bar(f: fn(i32, i32) -> i32, arg1: i32, arg2: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}bar\n-    // CHECK-SAME: {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE2:[0-9]+]]\n-    // CHECK: call i32 %f(i32 %arg1, i32 %arg2){{.*}}[ \"kcfi\"(i32 -1789026986) ]\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE2:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2){{.*}}[ \"kcfi\"(i32 -1789026986) ]\n     f(arg1, arg2)\n }\n \n pub fn baz(f: fn(i32, i32, i32) -> i32, arg1: i32, arg2: i32, arg3: i32) -> i32 {\n     // CHECK-LABEL: define{{.*}}baz\n-    // CHECK-SAME: {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE3:[0-9]+]]\n-    // CHECK: call i32 %f(i32 %arg1, i32 %arg2, i32 %arg3){{.*}}[ \"kcfi\"(i32 1248878270) ]\n+    // CHECK-SAME:  {{.*}}!{{<unknown kind #36>|kcfi_type}} ![[TYPE3:[0-9]+]]\n+    // CHECK:       {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg1, i32 {{(noundef )*}}%arg2, i32 {{(noundef )*}}%arg3){{.*}}[ \"kcfi\"(i32 1248878270) ]\n     f(arg1, arg2, arg3)\n }\n "}, {"sha": "e1d617b5ee18ec5dd7f5145b27008611d97d7d0b", "filename": "tests/codegen/sanitizer-kcfi-emit-kcfi-operand-bundle.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsanitizer-kcfi-emit-kcfi-operand-bundle.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,27 @@\n+// Verifies that KCFI operand bundles are emitted.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components:\n+// compile-flags: -Cno-prepopulate-passes -Zsanitizer=kcfi -Copt-level=0\n+\n+#![crate_type=\"lib\"]\n+#![feature(no_core, lang_items)]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized { }\n+#[lang=\"copy\"]\n+trait Copy { }\n+\n+impl Copy for i32 {}\n+\n+pub fn foo(f: fn(i32) -> i32, arg: i32) -> i32 {\n+    // CHECK-LABEL: define{{.*}}foo{{.*}}!{{<unknown kind #36>|kcfi_type}} !{{[0-9]+}}\n+    // CHECK:       start:\n+    // CHECK-NEXT:  {{%.+}} = call {{(noundef )*}}i32 %f(i32 {{(noundef )*}}%arg){{.*}}[ \"kcfi\"(i32 {{[-0-9]+}}) ]\n+    // CHECK-NEXT:  ret i32 {{%.+}}\n+    f(arg)\n+}"}, {"sha": "dc6570be32b4873116be0500c03c0ba42b75a568", "filename": "tests/codegen/split-lto-unit.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsplit-lto-unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fcodegen%2Fsplit-lto-unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fsplit-lto-unit.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,11 @@\n+// Verifies that \"EnableSplitLTOUnit\" module flag is added.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Ctarget-feature=-crt-static -Zsplit-lto-unit\n+\n+#![crate_type=\"lib\"]\n+\n+pub fn foo() {\n+}\n+\n+// CHECK: !{{[0-9]+}} = !{i32 4, !\"EnableSplitLTOUnit\", i32 1}"}, {"sha": "3cef8156014bfbde5018301417a44830758aff0e", "filename": "tests/ui/feature-gates/feature-gate-cfi_encoding.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+#![crate_type = \"lib\"]\n+\n+#[cfi_encoding = \"3Bar\"] //~ERROR 3:1: 3:25: the `#[cfi_encoding]` attribute is an experimental feature [E0658]\n+pub struct Foo(i32);"}, {"sha": "b10a15088818f285586e147bb430e3c3905a3b71", "filename": "tests/ui/feature-gates/feature-gate-cfi_encoding.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffeature-gates%2Ffeature-gate-cfi_encoding.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: the `#[cfi_encoding]` attribute is an experimental feature\n+  --> $DIR/feature-gate-cfi_encoding.rs:3:1\n+   |\n+LL | #[cfi_encoding = \"3Bar\"]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #89653 <https://github.com/rust-lang/rust/issues/89653> for more information\n+   = help: add `#![feature(cfi_encoding)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "c0f08a6d1e5475cc0cef6c159200f3cd635a814e", "filename": "tests/ui/sanitize/cfg.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fcfg.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -3,12 +3,16 @@\n \n // needs-sanitizer-support\n // needs-sanitizer-address\n+// needs-sanitizer-cfi\n+// needs-sanitizer-kcfi\n // needs-sanitizer-leak\n // needs-sanitizer-memory\n // needs-sanitizer-thread\n // check-pass\n // revisions: address leak memory thread\n //[address]compile-flags: -Zsanitizer=address --cfg address\n+//[cfi]compile-flags:     -Zsanitizer=cfi     --cfg cfi\n+//[kcfi]compile-flags:    -Zsanitizer=kcfi    --cfg kcfi\n //[leak]compile-flags:    -Zsanitizer=leak    --cfg leak\n //[memory]compile-flags:  -Zsanitizer=memory  --cfg memory\n //[thread]compile-flags:  -Zsanitizer=thread  --cfg thread\n@@ -18,6 +22,12 @@\n #[cfg(all(sanitize = \"address\", address))]\n fn main() {}\n \n+#[cfg(all(sanitize = \"cfi\", cfi))]\n+fn main() {}\n+\n+#[cfg(all(sanitize = \"kcfi\", kcfi))]\n+fn main() {}\n+\n #[cfg(all(sanitize = \"leak\", leak))]\n fn main() {}\n "}, {"sha": "462a3f661efb5f36a2fb2f2c78f99d53e641e373", "filename": "tests/ui/sanitize/sanitizer-cfi-canonical-jump-tables-require-cfi.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+// Verifies that `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer-cfi-canonical-jump-tables=false\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "3ee95634b16a171e0b611d82e9bf53baf4805de3", "filename": "tests/ui/sanitize/sanitizer-cfi-canonical-jump-tables-require-cfi.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-canonical-jump-tables-require-cfi.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+error: `-Zsanitizer-cfi-canonical-jump-tables` requires `-Zsanitizer=cfi`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a0fc143da6fb33690a5b84b67b0c3eb336f0465", "filename": "tests/ui/sanitize/sanitizer-cfi-generalize-pointers-attr-cfg.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-attr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-attr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-attr-cfg.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,9 @@\n+// Verifies that when compiling with `-Zsanitizer-cfi-generalize-pointers` the\n+// `#[cfg(sanitizer_cfi_generalize_pointers)]` attribute is configured.\n+//\n+// needs-sanitizer-cfi\n+// check-pass\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-generalize-pointers\n+\n+#[cfg(sanitizer_cfi_generalize_pointers)]\n+fn main() {}"}, {"sha": "f31b8bde7aebf3377902df8db55cbc3ffa08c41f", "filename": "tests/ui/sanitize/sanitizer-cfi-generalize-pointers-require-cfi.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,9 @@\n+// Verifies that `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or\n+// `-Zsanitizer=kcfi`.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer-cfi-generalize-pointers\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "6eb09a53b48629e71241e3c4b3e29094fe8731fc", "filename": "tests/ui/sanitize/sanitizer-cfi-generalize-pointers-require-cfi.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-generalize-pointers-require-cfi.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+error: `-Zsanitizer-cfi-generalize-pointers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe044f50a2162d6048c004ecf34ee5d7e1840994", "filename": "tests/ui/sanitize/sanitizer-cfi-invalid-attr-cfi-encoding.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,11 @@\n+// Verifies that invalid user-defined CFI encodings can't be used.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![feature(cfi_encoding, no_core)]\n+#![no_core]\n+#![no_main]\n+\n+#[cfi_encoding] //~ERROR 10:1: 10:16: malformed `cfi_encoding` attribute input\n+pub struct Type1(i32);"}, {"sha": "e23bafb18146850054fd30001cb7392fde257253", "filename": "tests/ui/sanitize/sanitizer-cfi-invalid-attr-cfi-encoding.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-invalid-attr-cfi-encoding.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `cfi_encoding` attribute input\n+  --> $DIR/sanitizer-cfi-invalid-attr-cfi-encoding.rs:10:1\n+   |\n+LL | #[cfi_encoding]\n+   | ^^^^^^^^^^^^^^^ help: must be of the form: `#[cfi_encoding = \"encoding\"]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "8328178e8d0ae68961ac87b0fd8fa749a1c764b0", "filename": "tests/ui/sanitize/sanitizer-cfi-is-incompatible-with-saniziter-kcfi.aarch64.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.aarch64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.aarch64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.aarch64.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+error: cfi sanitizer is not supported for this target\n+\n+error: `-Zsanitizer=cfi` is incompatible with `-Zsanitizer=kcfi`\n+\n+error: `-Zsanitizer=cfi` is incompatible with `-Zsanitizer=kcfi`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "9a5b0f3899041c425fe688aee12925b6059a8df0", "filename": "tests/ui/sanitize/sanitizer-cfi-is-incompatible-with-saniziter-kcfi.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,12 @@\n+// Verifies that `-Zsanitizer=cfi` is incompatible with `-Zsanitizer=kcfi`.\n+//\n+// revisions: aarch64 x86_64\n+// [aarch64] compile-flags: --target aarch64-unknown-none\n+// [aarch64] needs-llvm-components: aarch64\n+// [x86_64] compile-flags: --target x86_64-unknown-none\n+// [x86_64] needs-llvm-components: x86\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer=kcfi\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "8328178e8d0ae68961ac87b0fd8fa749a1c764b0", "filename": "tests/ui/sanitize/sanitizer-cfi-is-incompatible-with-saniziter-kcfi.x86_64.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.x86_64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.x86_64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-is-incompatible-with-saniziter-kcfi.x86_64.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+error: cfi sanitizer is not supported for this target\n+\n+error: `-Zsanitizer=cfi` is incompatible with `-Zsanitizer=kcfi`\n+\n+error: `-Zsanitizer=cfi` is incompatible with `-Zsanitizer=kcfi`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "dafc20162abc12970a907c11809424b658a765f3", "filename": "tests/ui/sanitize/sanitizer-cfi-normalize-integers-attr-cfg.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-attr-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-attr-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-attr-cfg.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,9 @@\n+// Verifies that when compiling with `-Zsanitizer-cfi-normalize-integers` the\n+// `#[cfg(sanitizer_cfi_normalize_integers)]` attribute is configured.\n+//\n+// needs-sanitizer-cfi\n+// check-pass\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi -Zsanitizer-cfi-normalize-integers\n+\n+#[cfg(sanitizer_cfi_normalize_integers)]\n+fn main() {}"}, {"sha": "b25a60d3494b84c99f671be9e51fcd4a6e7c8dd6", "filename": "tests/ui/sanitize/sanitizer-cfi-normalize-integers-require-cfi.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,9 @@\n+// Verifies that `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or\n+// `-Zsanitizer=kcfi`\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Clto -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer-cfi-normalize-integers\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "e31642054343cef23657827d7ce920337739fdab", "filename": "tests/ui/sanitize/sanitizer-cfi-normalize-integers-require-cfi.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-normalize-integers-require-cfi.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+error: `-Zsanitizer-cfi-normalize-integers` requires `-Zsanitizer=cfi` or `-Zsanitizer=kcfi`\n+\n+error: aborting due to previous error\n+"}, {"sha": "29e32889fcc77d098a9d3eaf3354b7c2d6c36cfe", "filename": "tests/ui/sanitize/sanitizer-cfi-requires-lto.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+// Verifies that `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsanitizer=cfi\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "5e706b513b91422d6c6412fe1ba9735d9f0d2f32", "filename": "tests/ui/sanitize/sanitizer-cfi-requires-lto.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsanitizer-cfi-requires-lto.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+error: `-Zsanitizer=cfi` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+\n+error: aborting due to previous error\n+"}, {"sha": "3c497260e85c685f0317b07ff421282bf05dfc8a", "filename": "tests/ui/sanitize/split-lto-unit-requires-lto.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.rs?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,8 @@\n+// Verifies that `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`.\n+//\n+// needs-sanitizer-cfi\n+// compile-flags: -Cno-prepopulate-passes -Ctarget-feature=-crt-static -Zsplit-lto-unit\n+\n+#![feature(no_core)]\n+#![no_core]\n+#![no_main]"}, {"sha": "ab8f4f4f351531e95332fc70a0b66d1370cbc521", "filename": "tests/ui/sanitize/split-lto-unit-requires-lto.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/38bbc3989570f51f0652f0aad4b3b675dfe09824/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsanitize%2Fsplit-lto-unit-requires-lto.stderr?ref=38bbc3989570f51f0652f0aad4b3b675dfe09824", "patch": "@@ -0,0 +1,4 @@\n+error: `-Zsplit-lto-unit` requires `-Clto`, `-Clto=thin`, or `-Clinker-plugin-lto`\n+\n+error: aborting due to previous error\n+"}]}