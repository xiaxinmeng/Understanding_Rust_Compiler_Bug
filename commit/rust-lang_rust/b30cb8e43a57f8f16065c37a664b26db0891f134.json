{"sha": "b30cb8e43a57f8f16065c37a664b26db0891f134", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMGNiOGU0M2E1N2Y4ZjE2MDY1YzM3YTY2NGIyNmRiMDg5MWYxMzQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-13T14:55:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-03-14T01:30:07Z"}, "message": "implement deserialization, rename mk_mem_buffer() to mem_buffer()", "tree": {"sha": "3af051107ff1f2c8b5ee5d823fc5c44e2d106807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3af051107ff1f2c8b5ee5d823fc5c44e2d106807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b30cb8e43a57f8f16065c37a664b26db0891f134", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b30cb8e43a57f8f16065c37a664b26db0891f134", "html_url": "https://github.com/rust-lang/rust/commit/b30cb8e43a57f8f16065c37a664b26db0891f134", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b30cb8e43a57f8f16065c37a664b26db0891f134/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d91742294f282a07b1e26d8da02f7ecec4e0b952", "url": "https://api.github.com/repos/rust-lang/rust/commits/d91742294f282a07b1e26d8da02f7ecec4e0b952", "html_url": "https://github.com/rust-lang/rust/commit/d91742294f282a07b1e26d8da02f7ecec4e0b952"}], "stats": {"total": 689, "additions": 502, "deletions": 187}, "files": [{"sha": "49aa10998db06e62b4e4eda9eea56799246289ba", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -221,10 +221,10 @@ fn under(n: uint, it: fn(uint)) {\n     while i < n { it(i); i += 1u; }\n }\n \n-fn devnull() -> io::writer { io::mem_buffer_writer(io::mk_mem_buffer()) }\n+fn devnull() -> io::writer { io::mem_buffer_writer(io::mem_buffer()) }\n \n fn as_str(f: fn@(io::writer)) -> str {\n-    let buf = io::mk_mem_buffer();\n+    let buf = io::mem_buffer();\n     f(io::mem_buffer_writer(buf));\n     io::mem_buffer_str(buf)\n }"}, {"sha": "72f5b528c9af81084d6a491ed82bb51deae92914", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -31,7 +31,7 @@ export uint, u8, u16, u32, u64;\n export float, f32, f64;\n export box, char, str, ptr, vec, bool;\n export either, option, result, iter;\n-export libc, os, ctypes, io, run, rand, sys, unsafe, logging, serialization;\n+export libc, os, io, run, rand, sys, unsafe, logging, serialization;\n export comm, task, future;\n export extfmt;\n export tuple;"}, {"sha": "6c344ed73f6f23921597abe99783a5091e157c9d", "filename": "src/libcore/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -543,7 +543,7 @@ impl of writer for mem_buffer {\n     fn flush() -> int { 0 }\n }\n \n-fn mk_mem_buffer() -> mem_buffer {\n+fn mem_buffer() -> mem_buffer {\n     @{mutable buf: [mutable], mutable pos: 0u}\n }\n fn mem_buffer_writer(b: mem_buffer) -> writer { b as writer }\n@@ -554,14 +554,14 @@ fn mem_buffer_str(b: mem_buffer) -> str {\n }\n \n fn with_str_writer(f: fn(writer)) -> str {\n-    let buf = mk_mem_buffer();\n+    let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n     io::mem_buffer_str(buf)\n }\n \n fn with_buf_writer(f: fn(writer)) -> [u8] {\n-    let buf = mk_mem_buffer();\n+    let buf = mem_buffer();\n     let wr = mem_buffer_writer(buf);\n     f(wr);\n     io::mem_buffer_buf(buf)"}, {"sha": "187be90c4f55518ee75f20c910953540d6989622", "filename": "src/libcore/serialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fserialization.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -96,7 +96,7 @@ fn emit_from_vec<S: serializer, T>(s: S, v: [T], f: fn(T)) {\n \n fn read_to_vec<D: deserializer, T>(d: D, f: fn() -> T) -> [T] {\n     d.read_vec {|len|\n-        vec::init_fn(len) {|i|\n+        vec::from_fn(len) {|i|\n             d.read_vec_elt(i) {|| f() }\n         }\n     }"}, {"sha": "795da4d70260a45970adf290d934ac1f75b19218", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -31,6 +31,7 @@ export grow_fn;\n export grow_set;\n export map;\n export map2;\n+export flat_map;\n export filter_map;\n export filter;\n export concat;"}, {"sha": "c0f71d067c4da525c7c48f421966b614e81acefe", "filename": "src/libstd/serialization.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibstd%2Fserialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibstd%2Fserialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fserialization.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -5,3 +5,8 @@ Deprecated in favor of core::serialization.\"];\n use core;\n import list::list;\n import ebml::writer;\n+\n+import core::serialization::{serializer,deserializer};\n+\n+export serializer;\n+export deserializer;"}, {"sha": "828f0ca85d42b582cce40019fde365fb281cee7d", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -189,7 +189,7 @@ fn print_failures(st: console_test_state) {\n \n #[test]\n fn should_sort_failures_before_printing_them() {\n-    let buffer = io::mk_mem_buffer();\n+    let buffer = io::mem_buffer();\n     let writer = io::mem_buffer_writer(buffer);\n \n     let test_a = {"}, {"sha": "4aea919c40f5ce7f315131476952751876d7fd84", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -948,7 +948,7 @@ fn mk_ctxt() -> fake_ext_ctxt {\n #[cfg(test)]\n fn roundtrip(in_item: @ast::item) {\n     #debug[\"in_item = %s\", pprust::item_to_str(in_item)];\n-    let mbuf = io::mk_mem_buffer();\n+    let mbuf = io::mem_buffer();\n     let ebml_w = ebml::writer(io::mem_buffer_writer(mbuf));\n     encode_item_ast(ebml_w, in_item);\n     let ebml_doc = ebml::new_doc(@io::mem_buffer_buf(mbuf));"}, {"sha": "7f1359aeadcaa421bbfde5c04cc43e2414d56738", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -745,7 +745,7 @@ fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n                 type_abbrevs: abbrevs,\n                 reachable: reachable};\n \n-    let buf = io::mk_mem_buffer();\n+    let buf = io::mem_buffer();\n     let buf_w = io::mem_buffer_writer(buf);\n     let ebml_w = ebml::writer(buf_w);\n \n@@ -779,7 +779,7 @@ fn encode_metadata(cx: crate_ctxt, crate: @crate) -> [u8] {\n // Get the encoded string for a type\n fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> str {\n     let cx = @{ds: def_to_str, tcx: tcx, abbrevs: tyencode::ac_no_abbrevs};\n-    let buf = io::mk_mem_buffer();\n+    let buf = io::mem_buffer();\n     tyencode::enc_ty(io::mem_buffer_writer(buf), cx, t);\n     ret io::mem_buffer_str(buf);\n }"}, {"sha": "4dd229c7dd2f3957905fde7bb570af6d755bde1b", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -40,7 +40,7 @@ fn enc_ty(w: io::writer, cx: @ctxt, t: ty::t) {\n         let result_str = alt cx.tcx.short_names_cache.find(t) {\n           some(s) { *s }\n           none {\n-            let buf = io::mk_mem_buffer();\n+            let buf = io::mem_buffer();\n             enc_sty(io::mem_buffer_writer(buf), cx, ty::get(t).struct);\n             cx.tcx.short_names_cache.insert(t, @io::mem_buffer_str(buf));\n             io::mem_buffer_str(buf)"}, {"sha": "1b048c26240198743af1426621e17339c0d66fc0", "filename": "src/rustc/syntax/ext/auto_serialize.rs", "status": "modified", "additions": 377, "deletions": 142, "changes": 519, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fext%2Fauto_serialize.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -87,10 +87,8 @@ import front::attr;\n \n export expand;\n \n-enum ser_cx = @{\n-    ext_cx: ext_ctxt,\n-    tps: map::hashmap<str, fn@(@ast::expr) -> [@ast::stmt]>\n-};\n+type ser_tps_map = map::hashmap<str, fn@(@ast::expr) -> [@ast::stmt]>;\n+type deser_tps_map = map::hashmap<str, fn@() -> @ast::expr>;\n \n fn expand(cx: ext_ctxt,\n           span: span,\n@@ -136,20 +134,10 @@ impl helpers for ext_ctxt {\n     }\n \n     fn ty_path(span: span, strs: [str]) -> @ast::ty {\n-        @{node: ast::ty_path(self.path(span, strs), self.next_id()),\n+        @{id: self.next_id(),\n+          node: ast::ty_path(self.path(span, strs), self.next_id()),\n           span: span}\n     }\n-}\n-\n-impl helpers for ser_cx {\n-    fn session() -> session { self.ext_cx.session() }\n-    fn next_id() -> ast::node_id { self.ext_cx.next_id() }\n-    fn path(span: span, strs: [str]) -> @ast::path {\n-        self.ext_cx.path(span, strs)\n-    }\n-    fn ty_path(span: span, strs: [str]) -> @ast::ty {\n-        self.ext_cx.ty_path(span, strs)\n-    }\n \n     fn ty_fn(span: span,\n              -input_tys: [@ast::ty],\n@@ -161,7 +149,8 @@ impl helpers for ser_cx {\n              id: self.next_id()}\n         };\n \n-        @{node: ast::ty_fn(ast::proto_any, {inputs: args,\n+        @{id: self.next_id(),\n+          node: ast::ty_fn(ast::proto_any, {inputs: args,\n                                             output: output,\n                                             purity: ast::impure_fn,\n                                             cf: ast::return_val,\n@@ -170,7 +159,7 @@ impl helpers for ser_cx {\n     }\n \n     fn ty_nil(span: span) -> @ast::ty {\n-        @{node: ast::ty_nil, span: span}\n+        @{id: self.next_id(), node: ast::ty_nil, span: span}\n     }\n \n     fn expr(span: span, node: ast::expr_) -> @ast::expr {\n@@ -190,6 +179,15 @@ impl helpers for ser_cx {\n          span: span}\n     }\n \n+    fn expr_blk(expr: @ast::expr) -> ast::blk {\n+        {node: {view_items: [],\n+                stmts: [],\n+                expr: some(expr),\n+                id: self.next_id(),\n+                rules: ast::default_blk},\n+         span: expr.span}\n+    }\n+\n     fn binder_pat(span: span, nm: str) -> @ast::pat {\n         let path = @{node: {global: false,\n                             idents: [nm],\n@@ -231,30 +229,28 @@ impl helpers for ser_cx {\n     fn lambda(blk: ast::blk) -> @ast::expr {\n         let ext_cx = self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk));\n-        #ast(expr){{|| $(blk_e) }}\n+        #ast{ {|| $(blk_e) } }\n     }\n \n-    fn clone(v: @ast::expr) -> @ast::expr {\n-        let fld = fold::make_fold({\n+    fn clone_folder() -> fold::ast_fold {\n+        fold::make_fold({\n             new_id: {|_id| self.next_id()}\n             with *fold::default_ast_fold()\n-        });\n+        })\n+    }\n+\n+    fn clone(v: @ast::expr) -> @ast::expr {\n+        let fld = self.clone_folder();\n         fld.fold_expr(v)\n     }\n \n     fn clone_ty(v: @ast::ty) -> @ast::ty {\n-        let fld = fold::make_fold({\n-            new_id: {|_id| self.next_id()}\n-            with *fold::default_ast_fold()\n-        });\n+        let fld = self.clone_folder();\n         fld.fold_ty(v)\n     }\n \n     fn clone_ty_param(v: ast::ty_param) -> ast::ty_param {\n-        let fld = fold::make_fold({\n-            new_id: {|_id| self.next_id()}\n-            with *fold::default_ast_fold()\n-        });\n+        let fld = self.clone_folder();\n         fold::fold_ty_param(v, fld)\n     }\n \n@@ -276,10 +272,10 @@ impl helpers for ser_cx {\n     }\n }\n \n-fn serialize_path(cx: ser_cx, path: @ast::path,\n+fn ser_path(cx: ext_ctxt, tps: ser_tps_map, path: @ast::path,\n                   -s: @ast::expr, -v: @ast::expr)\n     -> [@ast::stmt] {\n-    let ext_cx = cx.ext_cx;\n+    let ext_cx = cx; // required for #ast{}\n \n     // We want to take a path like a::b::c<...> and generate a call\n     // like a::b::c::serialize(s, ...), as described above.\n@@ -291,11 +287,10 @@ fn serialize_path(cx: ser_cx, path: @ast::path,\n                 cx.path(path.span, path.node.idents + [\"serialize\"])));\n \n     let ty_args = vec::map(path.node.types) {|ty|\n-        let sv_stmts = serialize_ty(cx, ty, cx.clone(s), #ast(expr){__v});\n+        let sv_stmts = ser_ty(cx, tps, ty, cx.clone(s), #ast{ __v });\n         let sv = cx.expr(path.span,\n-                         ast::expr_block(cx.blk(path.span,\n-                                                sv_stmts)));\n-        cx.at(ty.span, #ast(expr){{|__v| $(sv)}})\n+                         ast::expr_block(cx.blk(path.span, sv_stmts)));\n+        cx.at(ty.span, #ast{ {|__v| $(sv)} })\n     };\n \n     [cx.stmt(\n@@ -304,25 +299,26 @@ fn serialize_path(cx: ser_cx, path: @ast::path,\n             ast::expr_call(callee, [s, v] + ty_args, false)))]\n }\n \n-fn serialize_variant(cx: ser_cx,\n-                     tys: [@ast::ty],\n-                     span: span,\n-                     -s: @ast::expr,\n-                     pfn: fn([@ast::pat]) -> ast::pat_,\n-                     bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n-                     argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n+fn ser_variant(cx: ext_ctxt,\n+               tps: ser_tps_map,\n+               tys: [@ast::ty],\n+               span: span,\n+               -s: @ast::expr,\n+               pfn: fn([@ast::pat]) -> ast::pat_,\n+               bodyfn: fn(-@ast::expr, ast::blk) -> @ast::expr,\n+               argfn: fn(-@ast::expr, uint, ast::blk) -> @ast::expr)\n     -> ast::arm {\n-    let vnames = vec::init_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n-    let pats = vec::init_fn(vec::len(tys)) {|i|\n+    let vnames = vec::from_fn(vec::len(tys)) {|i| #fmt[\"__v%u\", i]};\n+    let pats = vec::from_fn(vec::len(tys)) {|i|\n         cx.binder_pat(tys[i].span, vnames[i])\n     };\n     let pat: @ast::pat = @{id: cx.next_id(), node: pfn(pats), span: span};\n-    let stmts = vec::init_fn(vec::len(tys)) {|i|\n+    let stmts = vec::from_fn(vec::len(tys)) {|i|\n         let v = cx.var_ref(span, vnames[i]);\n         let arg_blk =\n             cx.blk(\n                 span,\n-                serialize_ty(cx, tys[i], cx.clone(s), v));\n+                ser_ty(cx, tps, tys[i], cx.clone(s), v));\n         cx.stmt(argfn(cx.clone(s), i, arg_blk))\n     };\n \n@@ -332,29 +328,35 @@ fn serialize_variant(cx: ser_cx,\n     {pats: [pat], guard: none, body: body}\n }\n \n-fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n-    -> [@ast::stmt] {\n-\n-    fn ty_lambda(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n-        -> @ast::expr {\n-        cx.lambda(cx.blk(ty.span, serialize_ty(cx, ty, s, v)))\n-    }\n+fn ser_lambda(cx: ext_ctxt, tps: ser_tps_map, ty: @ast::ty,\n+              -s: @ast::expr, -v: @ast::expr) -> @ast::expr {\n+    cx.lambda(cx.blk(ty.span, ser_ty(cx, tps, ty, s, v)))\n+}\n \n+fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n+                ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n+    -> [@ast::stmt] {\n \n-    let ext_cx = cx.ext_cx;\n+    let ext_cx = cx; // required for #ast{}\n \n     alt ty.node {\n-      ast::ty_nil | ast::ty_bot {\n+      ast::ty_nil {\n+        [#ast[stmt]{$(s).emit_nil()}]\n+      }\n+\n+      ast::ty_bot {\n+        cx.session().span_err(\n+            ty.span, #fmt[\"Cannot serialize bottom type\"]);\n         []\n       }\n \n       ast::ty_box(mt) {\n-        let l = ty_lambda(cx, mt.ty, cx.clone(s), #ast(expr){*$(v)});\n+        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n         [#ast(stmt){$(s).emit_box($(l));}]\n       }\n \n       ast::ty_uniq(mt) {\n-        let l = ty_lambda(cx, mt.ty, cx.clone(s), #ast(expr){*$(v)});\n+        let l = ser_lambda(cx, tps, mt.ty, cx.clone(s), #ast{ *$(v) });\n         [#ast(stmt){$(s).emit_uniq($(l));}]\n       }\n \n@@ -365,7 +367,7 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n       }\n \n       ast::ty_rec(flds) {\n-        let fld_stmts = vec::init_fn(vec::len(flds)) {|fidx|\n+        let fld_stmts = vec::from_fn(vec::len(flds)) {|fidx|\n             let fld = flds[fidx];\n             let vf = cx.expr(fld.span,\n                              ast::expr_field(cx.clone(v),\n@@ -374,7 +376,7 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n             let s = cx.clone(s);\n             let f = cx.lit_str(fld.span, fld.node.ident);\n             let i = cx.lit_uint(fld.span, fidx);\n-            let l = ty_lambda(cx, fld.node.mt.ty, cx.clone(s), vf);\n+            let l = ser_lambda(cx, tps, fld.node.mt.ty, cx.clone(s), vf);\n             #ast(stmt){$(s).emit_rec_field($(f), $(i), $(l));}\n         };\n         let fld_lambda = cx.lambda(cx.blk(ty.span, fld_stmts));\n@@ -397,9 +399,9 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n         // };\n \n         let arms = [\n-            serialize_variant(\n+            ser_variant(\n \n-                cx, tys, ty.span, s,\n+                cx, tps, tys, ty.span, s,\n \n                 // Generate pattern (v1, v2, v3)\n                 {|pats| ast::pat_tup(pats)},\n@@ -408,18 +410,14 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                 {|-s, blk|\n                     let sz = cx.lit_uint(ty.span, vec::len(tys));\n                     let body = cx.lambda(blk);\n-                    #ast[expr]{\n-                        $(s).emit_tup($(sz), $(body))\n-                    }\n+                    #ast{ $(s).emit_tup($(sz), $(body)) }\n                 },\n \n                 // Generate s.emit_tup_elt(i, {|| blk })\n                 {|-s, i, blk|\n                     let idx = cx.lit_uint(ty.span, i);\n                     let body = cx.lambda(blk);\n-                    #ast[expr]{\n-                        $(s).emit_tup_elt($(idx), $(body))\n-                    }\n+                    #ast{ $(s).emit_tup_elt($(idx), $(body)) }\n                 })\n         ];\n         [cx.alt_stmt(arms, ty.span, v)]\n@@ -430,17 +428,17 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n             vec::is_empty(path.node.types) {\n             let ident = path.node.idents[0];\n \n-            alt cx.tps.find(ident) {\n+            alt tps.find(ident) {\n               some(f) { f(v) }\n-              none { serialize_path(cx, path, s, v) }\n+              none { ser_path(cx, tps, path, s, v) }\n             }\n         } else {\n-            serialize_path(cx, path, s, v)\n+            ser_path(cx, tps, path, s, v)\n         }\n       }\n \n       ast::ty_constr(ty, _) {\n-        serialize_ty(cx, ty, s, v)\n+        ser_ty(cx, tps, ty, s, v)\n       }\n \n       ast::ty_mac(_) {\n@@ -462,12 +460,10 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n                 ast::expr_block(\n                     cx.blk(\n                         ty.span,\n-                        serialize_ty(\n-                            cx, mt.ty,\n+                        ser_ty(\n+                            cx, tps, mt.ty,\n                             cx.clone(s),\n-                            cx.at(\n-                                ty.span,\n-                                #ast(expr){__e})))));\n+                            cx.at(ty.span, #ast{ __e })))));\n \n         [#ast(stmt){\n             core::serialization::emit_from_vec($(s), $(v), {|__e| $(ser_e) })\n@@ -476,12 +472,12 @@ fn serialize_ty(cx: ser_cx, ty: @ast::ty, -s: @ast::expr, -v: @ast::expr)\n     }\n }\n \n-fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n-             v_ty: @ast::ty, tps: [ast::ty_param],\n-             f: fn(ser_cx, @ast::ty, -@ast::expr, -@ast::expr) -> [@ast::stmt])\n+fn mk_ser_fn(cx: ext_ctxt, span: span,\n+             -v_ty: @ast::ty, tps: [ast::ty_param],\n+             f: fn(ext_ctxt, ser_tps_map, @ast::ty,\n+                   -@ast::expr, -@ast::expr) -> [@ast::stmt])\n     -> @ast::item {\n-\n-    let cx = ser_cx(@{ext_cx: ext_cx, tps: map::new_str_hash()});\n+    let ext_cx = cx; // required for #ast\n \n     let tp_inputs =\n         vec::map(tps, {|tp|\n@@ -500,14 +496,15 @@ fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n           ident: \"__s\",\n           id: cx.next_id()},\n          {mode: ast::expl(ast::by_ref),\n-          ty: cx.clone_ty(v_ty),\n+          ty: v_ty,\n           ident: \"__v\",\n           id: cx.next_id()}]\n         + tp_inputs;\n \n+    let tps_map = map::new_str_hash();\n     vec::iter2(tps, tp_inputs) {|tp, arg|\n         let arg_ident = arg.ident;\n-        cx.tps.insert(\n+        tps_map.insert(\n             tp.ident,\n             fn@(v: @ast::expr) -> [@ast::stmt] {\n                 let f = cx.var_ref(span, arg_ident);\n@@ -526,11 +523,12 @@ fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n           bounds: ser_bnds}] +\n         vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n \n-    let ser_output: @ast::ty = @{node: ast::ty_nil,\n+    let ser_output: @ast::ty = @{id: cx.next_id(),\n+                                 node: ast::ty_nil,\n                                  span: span};\n \n     let ser_blk = cx.blk(span,\n-                         f(cx, v_ty, #ast(expr){__s}, #ast(expr){__v}));\n+                         f(cx, tps_map, v_ty, #ast{ __s }, #ast{ __v }));\n \n     @{ident: \"serialize\",\n       attrs: [],\n@@ -545,77 +543,314 @@ fn mk_ser_fn(ext_cx: ext_ctxt, span: span,\n       span: span}\n }\n \n-fn ty_module(ext_cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n+// ______________________________________________________________________\n+\n+fn deser_path(cx: ext_ctxt, tps: deser_tps_map, path: @ast::path,\n+                    -d: @ast::expr) -> @ast::expr {\n+    // We want to take a path like a::b::c<...> and generate a call\n+    // like a::b::c::deserialize(d, ...), as described above.\n+\n+    let callee =\n+        cx.expr(\n+            path.span,\n+            ast::expr_path(\n+                cx.path(path.span, path.node.idents + [\"deserialize\"])));\n+\n+    let ty_args = vec::map(path.node.types) {|ty|\n+        let dv_expr = deser_ty(cx, tps, ty, cx.clone(d));\n+        cx.lambda(cx.expr_blk(dv_expr))\n+    };\n+\n+    cx.expr(path.span, ast::expr_call(callee, [d] + ty_args, false))\n+}\n+\n+fn deser_lambda(cx: ext_ctxt, tps: deser_tps_map, ty: @ast::ty,\n+                -d: @ast::expr) -> @ast::expr {\n+    cx.lambda(cx.expr_blk(deser_ty(cx, tps, ty, d)))\n+}\n+\n+fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n+                  ty: @ast::ty, -d: @ast::expr) -> @ast::expr {\n+\n+    let ext_cx = cx; // required for #ast{}\n+\n+    alt ty.node {\n+      ast::ty_nil {\n+        #ast{ $(d).read_nil() }\n+      }\n+\n+      ast::ty_bot {\n+        #ast{ fail }\n+      }\n+\n+      ast::ty_box(mt) {\n+        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n+        #ast{ @$(d).read_box($(l)) }\n+      }\n+\n+      ast::ty_uniq(mt) {\n+        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n+        #ast{ ~$(d).read_uniq($(l)) }\n+      }\n+\n+      ast::ty_ptr(_) | ast::ty_rptr(_, _) {\n+        #ast{ fail }\n+      }\n+\n+      ast::ty_rec(flds) {\n+        let fields = vec::from_fn(vec::len(flds)) {|fidx|\n+            let fld = flds[fidx];\n+            let d = cx.clone(d);\n+            let f = cx.lit_str(fld.span, fld.node.ident);\n+            let i = cx.lit_uint(fld.span, fidx);\n+            let l = deser_lambda(cx, tps, fld.node.mt.ty, cx.clone(d));\n+            {node: {mutbl: fld.node.mt.mutbl,\n+                    ident: fld.node.ident,\n+                    expr: #ast{ $(d).read_rec_field($(f), $(i), $(l))} },\n+             span: fld.span}\n+        };\n+        let fld_expr = cx.expr(ty.span, ast::expr_rec(fields, none));\n+        let fld_lambda = cx.lambda(cx.expr_blk(fld_expr));\n+        #ast{ $(d).read_rec($(fld_lambda)) }\n+      }\n+\n+      ast::ty_fn(_, _) {\n+        #ast{ fail }\n+      }\n+\n+      ast::ty_tup(tys) {\n+        // Generate code like\n+        //\n+        // d.read_tup(3u) {||\n+        //   (d.read_tup_elt(0u, {||...}),\n+        //    d.read_tup_elt(1u, {||...}),\n+        //    d.read_tup_elt(2u, {||...}))\n+        // }\n+\n+        let arg_exprs = vec::from_fn(vec::len(tys)) {|i|\n+            let idx = cx.lit_uint(ty.span, i);\n+            let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n+            #ast{ $(d).read_tup_elt($(idx), $(body)) }\n+        };\n+        let body =\n+            cx.lambda(cx.expr_blk(\n+                cx.expr(ty.span, ast::expr_tup(arg_exprs))));\n+        let sz = cx.lit_uint(ty.span, vec::len(tys));\n+        #ast{ $(d).read_tup($(sz), $(body)) }\n+      }\n+\n+      ast::ty_path(path, _) {\n+        if vec::len(path.node.idents) == 1u &&\n+            vec::is_empty(path.node.types) {\n+            let ident = path.node.idents[0];\n+\n+            alt tps.find(ident) {\n+              some(f) { f() }\n+              none { deser_path(cx, tps, path, d) }\n+            }\n+        } else {\n+            deser_path(cx, tps, path, d)\n+        }\n+      }\n+\n+      ast::ty_constr(ty, constrs) {\n+        deser_ty(cx, tps, ty, d)\n+      }\n+\n+      ast::ty_mac(_) {\n+        #ast{ fail }\n+      }\n+\n+      ast::ty_infer {\n+        #ast{ fail }\n+      }\n+\n+      ast::ty_vec(mt) {\n+        let l = deser_lambda(cx, tps, mt.ty, cx.clone(d));\n+        #ast{ core::serialization::read_to_vec($(d), $(l)) }\n+      }\n+    }\n+}\n+\n+fn mk_deser_fn(cx: ext_ctxt, span: span,\n+               -v_ty: @ast::ty, tps: [ast::ty_param],\n+               f: fn(ext_ctxt, deser_tps_map,\n+                     @ast::ty, -@ast::expr) -> @ast::expr)\n+    -> @ast::item {\n+    let ext_cx = cx; // required for #ast\n+\n+    let tp_inputs =\n+        vec::map(tps, {|tp|\n+            {mode: ast::expl(ast::by_ref),\n+             ty: cx.ty_fn(span,\n+                          [],\n+                          cx.ty_path(span, [tp.ident])),\n+             ident: \"__d\" + tp.ident,\n+             id: cx.next_id()}});\n+\n+    #debug[\"tp_inputs = %?\", tp_inputs];\n+\n+    let deser_inputs: [ast::arg] =\n+        [{mode: ast::expl(ast::by_ref),\n+          ty: cx.ty_path(span, [\"__D\"]),\n+          ident: \"__d\",\n+          id: cx.next_id()}]\n+        + tp_inputs;\n+\n+    let tps_map = map::new_str_hash();\n+    vec::iter2(tps, tp_inputs) {|tp, arg|\n+        let arg_ident = arg.ident;\n+        tps_map.insert(\n+            tp.ident,\n+            fn@() -> @ast::expr {\n+                let f = cx.var_ref(span, arg_ident);\n+                #ast{ $(f)() }\n+            });\n+    }\n+\n+    let deser_bnds = @[ast::bound_iface(cx.ty_path(span,\n+                                                   [\"serialization\",\n+                                                    \"deserializer\"]))];\n+\n+    let deser_tps: [ast::ty_param] =\n+        [{ident: \"__D\",\n+          id: cx.next_id(),\n+          bounds: deser_bnds}] +\n+        vec::map(tps) {|tp| cx.clone_ty_param(tp) };\n+\n+    let deser_blk = cx.expr_blk(f(cx, tps_map, v_ty, #ast(expr){__d}));\n+\n+    @{ident: \"deserialize\",\n+      attrs: [],\n+      id: cx.next_id(),\n+      node: ast::item_fn({inputs: deser_inputs,\n+                          output: v_ty,\n+                          purity: ast::impure_fn,\n+                          cf: ast::return_val,\n+                          constraints: []},\n+                         deser_tps,\n+                         deser_blk),\n+      span: span}\n+}\n+\n+fn ty_module(cx: ext_ctxt, name: str, ty: @ast::ty, tps: [ast::ty_param])\n     -> @ast::item {\n \n     let span = ty.span;\n-    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps, serialize_ty);\n+    let ser_fn = mk_ser_fn(cx, span, cx.clone_ty(ty), tps, ser_ty);\n+    let deser_fn = mk_deser_fn(cx, span, cx.clone_ty(ty), tps, deser_ty);\n \n     // Return a module containing the serialization and deserialization\n     // functions:\n     @{ident: name,\n       attrs: [],\n-      id: ext_cx.session().next_node_id(),\n+      id: cx.next_id(),\n       node: ast::item_mod({view_items: [],\n-                           items: [ser_fn]}),\n+                           items: [ser_fn, deser_fn]}),\n       span: span}\n }\n \n-fn enum_module(ext_cx: ext_ctxt, name: str, span: span,\n-               variants: [ast::variant], tps: [ast::ty_param])\n-    -> @ast::item {\n+fn ser_enum(cx: ext_ctxt, tps: ser_tps_map, e_name: str,\n+            e_span: span, variants: [ast::variant],\n+            _ty: @ast::ty, -s: @ast::expr, -v: @ast::expr) -> [@ast::stmt] {\n+    let ext_cx = cx;\n+    let arms = vec::from_fn(vec::len(variants)) {|vidx|\n+        let variant = variants[vidx];\n+        let v_span = variant.span;\n+        let v_name = variant.node.name;\n+        let variant_tys = vec::map(variant.node.args) {|a| a.ty };\n+\n+        ser_variant(\n+            cx, tps, variant_tys, v_span, cx.clone(s),\n+\n+            // Generate pattern var(v1, v2, v3)\n+            {|pats|\n+                if vec::is_empty(pats) {\n+                    ast::pat_ident(cx.path(v_span, [v_name]), none)\n+                } else {\n+                    ast::pat_enum(cx.path(v_span, [v_name]), pats)\n+                }\n+            },\n+\n+            // Generate body s.emit_enum_variant(\"foo\", 0u,\n+            //                                   3u, {|| blk })\n+            {|-s, blk|\n+                let v_name = cx.lit_str(v_span, v_name);\n+                let v_id = cx.lit_uint(v_span, vidx);\n+                let sz = cx.lit_uint(v_span, vec::len(variant_tys));\n+                let body = cx.lambda(blk);\n+                #ast[expr]{\n+                    $(s).emit_enum_variant($(v_name), $(v_id),\n+                                           $(sz), $(body))\n+                }\n+            },\n+\n+            // Generate s.emit_enum_variant_arg(i, {|| blk })\n+            {|-s, i, blk|\n+                let idx = cx.lit_uint(v_span, i);\n+                let body = cx.lambda(blk);\n+                #ast[expr]{\n+                    $(s).emit_enum_variant_arg($(idx), $(body))\n+                }\n+            })\n+    };\n+    let lam = cx.lambda(cx.blk(e_span, [cx.alt_stmt(arms, e_span, v)]));\n+    let e_name = cx.lit_str(e_span, e_name);\n+    [#ast(stmt){ $(s).emit_enum($(e_name), $(lam)) }]\n+}\n \n-    let ty = ext_cx.ty_path(span, [name]);\n-    let ser_fn = mk_ser_fn(ext_cx, span, ty, tps) {|cx, _ty, s, v|\n-        let arms = vec::init_fn(\n-            vec::len(variants),\n-            fn&(vidx: uint) -> ast::arm {\n-                let variant = variants[vidx];\n-                let span = variant.span;\n-                let name = variant.node.name;\n-                let variant_tys = vec::map(variant.node.args) {|a| a.ty };\n-\n-                serialize_variant(\n-                    cx, variant_tys, span, cx.clone(s),\n-\n-                    // Generate pattern var(v1, v2, v3)\n-                    {|pats|\n-                        if vec::is_empty(pats) {\n-                            ast::pat_ident(cx.path(span, [name]), none)\n-                        } else {\n-                            ast::pat_enum(cx.path(span, [name]), pats)\n-                        }\n-                    },\n-\n-                    // Generate body s.emit_enum_variant(\"foo\", 0u,\n-                    //                                   3u, {|| blk })\n-                    {|-s, blk|\n-                        let v_name = cx.lit_str(span, name);\n-                        let v_id = cx.lit_uint(span, vidx);\n-                        let sz = cx.lit_uint(span, vec::len(variant_tys));\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant($(v_name), $(v_id),\n-                                                   $(sz), $(body))\n-                        }\n-                    },\n-\n-                    // Generate s.emit_enum_variant_arg(i, {|| blk })\n-                    {|-s, i, blk|\n-                        let idx = cx.lit_uint(span, i);\n-                        let body = cx.lambda(blk);\n-                        #ast[expr]{\n-                            $(s).emit_enum_variant_arg($(idx), $(body))\n-                        }\n-                    })\n-            });\n-        [cx.alt_stmt(arms, span, v)]\n+fn deser_enum(cx: ext_ctxt, tps: deser_tps_map, e_name: str,\n+              e_span: span, variants: [ast::variant],\n+              _ty: @ast::ty, -d: @ast::expr) -> @ast::expr {\n+    let ext_cx = cx;\n+    let arms: [ast::arm] = vec::from_fn(vec::len(variants)) {|vidx|\n+        let variant = variants[vidx];\n+        let v_span = variant.span;\n+        let v_name = variant.node.name;\n+        let tys = vec::map(variant.node.args) {|a| a.ty };\n+\n+        let arg_exprs = vec::from_fn(vec::len(tys)) {|i|\n+            let idx = cx.lit_uint(v_span, i);\n+            let body = deser_lambda(cx, tps, tys[i], cx.clone(d));\n+            #ast{ $(d).read_enum_variant_arg($(idx), $(body)) }\n+        };\n+\n+        let body =\n+            cx.expr(v_span, ast::expr_call(\n+                cx.var_ref(v_span, v_name), arg_exprs, false));\n+\n+        {pats: [@{id: cx.next_id(),\n+                  node: ast::pat_lit(cx.lit_uint(v_span, vidx)),\n+                  span: v_span}],\n+         guard: none,\n+         body: cx.expr_blk(body)}\n     };\n \n-    @{ident: name,\n+    // Generate code like:\n+    let e_name = cx.lit_str(e_span, e_name);\n+    let alt_expr = cx.expr(e_span,\n+                           ast::expr_alt(#ast{__i}, arms, ast::alt_check));\n+    let var_lambda = #ast{ {|__i| $(alt_expr)} };\n+    let read_var = #ast{ $(cx.clone(d)).read_enum_variant($(var_lambda)) };\n+    let read_lambda = cx.lambda(cx.expr_blk(read_var));\n+    #ast{ $(d).read_enum($(e_name), $(read_lambda)) }\n+}\n+\n+fn enum_module(cx: ext_ctxt, e_name: str, e_span: span,\n+               variants: [ast::variant], tps: [ast::ty_param])\n+    -> @ast::item {\n+    let ty = cx.ty_path(e_span, [e_name]);\n+    let ser_fn =\n+        mk_ser_fn(cx, e_span, cx.clone_ty(ty), tps,\n+                  ser_enum(_, _, e_name, e_span, variants, _, _, _));\n+    let deser_fn =\n+        mk_deser_fn(cx, e_span, ty, tps,\n+                    deser_enum(_, _, e_name, e_span, variants, _, _));\n+\n+    @{ident: e_name,\n       attrs: [],\n-      id: ext_cx.session().next_node_id(),\n+      id: cx.next_id(),\n       node: ast::item_mod({view_items: [],\n-                           items: [ser_fn]}),\n-      span: span}\n+                           items: [ser_fn, deser_fn]}),\n+      span: e_span}\n }"}, {"sha": "34d6d09b5ad147cb8ac374a0f605bf92f7cdb602", "filename": "src/rustc/syntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fprint%2Fpprust.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -99,7 +99,7 @@ fn path_to_str(&&p: @ast::path) -> str {\n \n fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: [ast::ty_param]) -> str {\n-    let buffer = io::mk_mem_buffer();\n+    let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n     print_fn(s, decl, name, params);\n     end(s); // Close the head box\n@@ -124,7 +124,7 @@ fn test_fun_to_str() {\n \n fn res_to_str(decl: ast::fn_decl, name: ast::ident,\n               params: [ast::ty_param]) -> str {\n-    let buffer = io::mk_mem_buffer();\n+    let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n     print_res(s, decl, name, params);\n     end(s); // Close the head box\n@@ -155,7 +155,7 @@ fn test_res_to_str() {\n }\n \n fn block_to_str(blk: ast::blk) -> str {\n-    let buffer = io::mk_mem_buffer();\n+    let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n     // containing cbox, will be closed by print-block at }\n     cbox(s, indent_unit);\n@@ -1700,7 +1700,7 @@ fn escape_str(st: str, to_escape: char) -> str {\n }\n \n fn to_str<T>(t: T, f: fn@(ps, T)) -> str {\n-    let buffer = io::mk_mem_buffer();\n+    let buffer = io::mem_buffer();\n     let s = rust_printer(io::mem_buffer_writer(buffer));\n     f(s, t);\n     eof(s.s);"}, {"sha": "419985ef731c70574986b5a410981e2e2ced8700", "filename": "src/test/auxiliary/auto_serialize_lib.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fauto_serialize_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fauto_serialize_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fauto_serialize_lib.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -0,0 +1,32 @@\n+#[link(name=\"auto_serialize_lib\", vers=\"0.0\")];\n+\n+use std;\n+import std::ebml;\n+import io::writer;\n+\n+fn test_ser_and_deser<A>(a1: A,\n+                         expected: str,\n+                         ebml_ser_fn: fn(ebml::writer, A),\n+                         ebml_deser_fn: fn(ebml::ebml_deserializer) -> A,\n+                         io_ser_fn: fn(io::writer, A)) {\n+\n+    // check the pretty printer:\n+    io_ser_fn(io::stdout(), a1);\n+    let s = io::with_str_writer {|w| io_ser_fn(w, a1) };\n+    #debug[\"s == %?\", s];\n+    assert s == expected;\n+\n+    // check the EBML serializer:\n+    let buf = io::mem_buffer();\n+    let w = ebml::writer(buf as io::writer);\n+    ebml_ser_fn(w, a1);\n+    let d = ebml::new_doc(@io::mem_buffer_buf(buf));\n+    let a2 = ebml_deser_fn(ebml::ebml_deserializer(d));\n+    io::print(\"\\na1 = \");\n+    io_ser_fn(io::stdout(), a1);\n+    io::print(\"\\na2 = \");\n+    io_ser_fn(io::stdout(), a2);\n+    io::print(\"\\n\");\n+    assert a1 == a2;\n+\n+}"}, {"sha": "6e58c4cecee84c950067dc0c98529dba7a8fd995", "filename": "src/test/auxiliary/cci_impl_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_impl_lib.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,3 +1,5 @@\n+#[link(name=\"cci_impl_lib\", vers=\"0.0\")];\n+\n impl helpers for uint {\n     #[inline]\n     fn to(v: uint, f: fn(uint)) {"}, {"sha": "668030087bd512cbc23cc705413d48eec219dba5", "filename": "src/test/auxiliary/cci_iter_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_iter_lib.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,3 +1,5 @@\n+#[link(name=\"cci_iter_lib\", vers=\"0.0\")];\n+\n #[inline]\n fn iter<T>(v: [T], f: fn(T)) {\n     let i = 0u;"}, {"sha": "2755fdfa6cf523ef2313aa5e07b4df0161a10476", "filename": "src/test/auxiliary/cci_no_inline_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_no_inline_lib.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,3 +1,5 @@\n+#[link(name=\"cci_no_inline_lib\", vers=\"0.0\")];\n+\n // same as cci_iter_lib, more-or-less, but not marked inline\n fn iter(v: [uint], f: fn(uint)) {\n     let i = 0u;"}, {"sha": "35a1f613058981fd849b51bcb4deeb918c618dc7", "filename": "src/test/auxiliary/native_lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fnative_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Fauxiliary%2Fnative_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fnative_lib.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,3 +1,5 @@\n+#[link(name=\"native_lib\", vers=\"0.0\")];\n+\n native mod rustrt {\n     fn last_os_error() -> str;\n }\n\\ No newline at end of file"}, {"sha": "8bb9e02e0f2ab432d1e13a7e6aab4a64fd69d0fc", "filename": "src/test/run-pass/auto_serialize_enum.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_enum.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,6 +1,12 @@\n+// aux-build:auto_serialize_lib.rs\n+// xfail-fast:aux-build currently incompatible\n+\n use std;\n+use auto_serialize_lib;\n import std::prettyprint::serializer;\n-import std::io;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n+import auto_serialize_lib::*;\n \n #[auto_serialize]\n enum expr {\n@@ -10,10 +16,11 @@ enum expr {\n }\n \n fn main() {\n-    let ex = @plus(@minus(@val(3u), @val(10u)),\n-                   @plus(@val(22u), @val(5u)));\n-    let s = io::with_str_writer {|w| expr::serialize(w, *ex)};\n-    #debug[\"s == %?\", s];\n-    assert s == \"plus(@minus(@val(3u), @val(10u)), \\\n-                 @plus(@val(22u), @val(5u)))\";\n+    test_ser_and_deser(plus(@minus(@val(3u), @val(10u)),\n+                            @plus(@val(22u), @val(5u))),\n+                       \"plus(@minus(@val(3u), @val(10u)), \\\n+                        @plus(@val(22u), @val(5u)))\",\n+                       expr::serialize(_, _),\n+                       expr::deserialize(_),\n+                       expr::serialize(_, _));\n }\n\\ No newline at end of file"}, {"sha": "b4cf5417b3b062300a16d1ec0406ed8dd34b4b01", "filename": "src/test/run-pass/auto_serialize_gen.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_gen.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,6 +1,12 @@\n+// aux-build:auto_serialize_lib.rs\n+// xfail-fast:aux-build currently incompatible\n+\n use std;\n+use auto_serialize_lib;\n import std::prettyprint::serializer;\n-import std::io;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n+import auto_serialize_lib::*;\n \n // Test where we link various types used by name.\n \n@@ -11,9 +17,9 @@ type spanned<T> = {lo: uint, hi: uint, node: T};\n type spanned_uint = spanned<uint>;\n \n fn main() {\n-    let x: spanned_uint = {lo: 0u, hi: 5u, node: 22u};\n-    spanned_uint::serialize(io::stdout(), x);\n-    let s = io::with_str_writer {|w| spanned_uint::serialize(w, x)};\n-    #debug[\"s == %?\", s];\n-    assert s == \"{lo: 0u, hi: 5u, node: 22u}\";\n+    test_ser_and_deser({lo: 0u, hi: 5u, node: 22u},\n+                       \"{lo: 0u, hi: 5u, node: 22u}\",\n+                       spanned_uint::serialize(_, _),\n+                       spanned_uint::deserialize(_),\n+                       spanned_uint::serialize(_, _));\n }\n\\ No newline at end of file"}, {"sha": "5f3cd8f7aa62ab26be25506c4b141af8226150ec", "filename": "src/test/run-pass/auto_serialize_link.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_link.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,6 +1,12 @@\n+// aux-build:auto_serialize_lib.rs\n+// xfail-fast:aux-build currently incompatible\n+\n use std;\n+use auto_serialize_lib;\n import std::prettyprint::serializer;\n-import std::io;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n+import auto_serialize_lib::*;\n \n // Test where we link various types used by name.\n \n@@ -14,9 +20,9 @@ type some_rec = {v: uint_vec};\n enum an_enum = some_rec;\n \n fn main() {\n-    let x = an_enum({v: [1u, 2u, 3u]});\n-    an_enum::serialize(io::stdout(), x);\n-    let s = io::with_str_writer {|w| an_enum::serialize(w, x)};\n-    #debug[\"s == %?\", s];\n-    assert s == \"an_enum({v: [1u, 2u, 3u]})\";\n+    test_ser_and_deser(an_enum({v: [1u, 2u, 3u]}),\n+                       \"an_enum({v: [1u, 2u, 3u]})\",\n+                       an_enum::serialize(_, _),\n+                       an_enum::deserialize(_),\n+                       an_enum::serialize(_, _));\n }\n\\ No newline at end of file"}, {"sha": "a16396ce3d0e615d5bdaf3070fa005f3aa5f7998", "filename": "src/test/run-pass/auto_serialize_rec.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_rec.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,12 +1,20 @@\n+// aux-build:auto_serialize_lib.rs\n+// xfail-fast:aux-build currently incompatible\n+\n use std;\n+use auto_serialize_lib;\n import std::prettyprint::serializer;\n-import std::io;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n+import auto_serialize_lib::*;\n \n #[auto_serialize]\n type point = {x: uint, y: uint};\n \n fn main() {\n-    let s = io::with_str_writer {|w| point::serialize(w, {x: 3u, y: 5u}) };\n-    #debug[\"s == %?\", s];\n-    assert s == \"{x: 3u, y: 5u}\";\n+    test_ser_and_deser({x: 3u, y: 5u},\n+                       \"{x: 3u, y: 5u}\",\n+                       point::serialize(_, _),\n+                       point::deserialize(_),\n+                       point::serialize(_, _));\n }\n\\ No newline at end of file"}, {"sha": "24fa76d5316eb67e96f217c6f6dcaa4bc75910e7", "filename": "src/test/run-pass/auto_serialize_vec.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto_serialize_vec.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -1,13 +1,20 @@\n+// aux-build:auto_serialize_lib.rs\n+// xfail-fast:aux-build currently incompatible\n+\n use std;\n+use auto_serialize_lib;\n import std::prettyprint::serializer;\n-import std::io;\n+import std::ebml::serializer;\n+import std::ebml::deserializer;\n+import auto_serialize_lib::*;\n \n #[auto_serialize]\n type uint_vec = [uint];\n \n fn main() {\n-    let ex = [1u, 2u, 3u];\n-    let s = io::with_str_writer {|w| uint_vec::serialize(w, ex)};\n-    #debug[\"s == %?\", s];\n-    assert s == \"[1u, 2u, 3u]\";\n+    test_ser_and_deser([1u, 2u, 3u],\n+                       \"[1u, 2u, 3u]\",\n+                       uint_vec::serialize(_, _),\n+                       uint_vec::deserialize(_),\n+                       uint_vec::serialize(_, _));\n }\n\\ No newline at end of file"}, {"sha": "74624781a306e2c72dfc535906d9a0b1acd47ff0", "filename": "src/test/run-pass/qquote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b30cb8e43a57f8f16065c37a664b26db0891f134/src%2Ftest%2Frun-pass%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fqquote.rs?ref=b30cb8e43a57f8f16065c37a664b26db0891f134", "patch": "@@ -100,7 +100,7 @@ fn main() {\n }\n \n fn check_pp<T>(expr: T, f: fn(pprust::ps, T), expect: str) {\n-    let buf = mk_mem_buffer();\n+    let buf = mem_buffer();\n     let pp = pprust::rust_printer(buf as io::writer);\n     f(pp, expr);\n     pp::eof(pp.s);"}]}