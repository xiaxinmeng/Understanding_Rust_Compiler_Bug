{"sha": "021d5821befc2e0a0d7d164b345f93d8dfaac52a", "node_id": "C_kwDOAAsO6NoAKDAyMWQ1ODIxYmVmYzJlMGEwZDdkMTY0YjM0NWY5M2Q4ZGZhYWM1MmE", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-10T19:02:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-10T19:02:51Z"}, "message": "Merge #10981\n\n10981: internal: Remove some allocations r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "9363db584b6448e81ca4e137c61f0547ae95f30d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9363db584b6448e81ca4e137c61f0547ae95f30d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/021d5821befc2e0a0d7d164b345f93d8dfaac52a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhs6RbCRBK7hj4Ov3rIwAA3CEIAHg6fn/Y1Qzj05XK8/KZ4qy0\nHgLOKISrkBppr4IuxeOkFd5XxuYVlr+sORQevkIfcjmLt4XlV3q0AOfWvMiZstjK\nrHVaLM3whz7YDb9t4SYR61azIiLjUaZH6sik+CXQ7rLXpImAVSWkY0jy/EQyLTGa\nEVlUic0zRqIjbU4TbsCj/iQaigoRNxkzWhj4chJZ8yn89a4NCh964GFM1P1Uhg7F\nNpKLRCOhoLHfYsN3aGHxU8jkSi4tqSp6dakqbXfwWlJTFi5DZgsr9Cj54x56uh3n\nrbdFx/lznrAdP/5mi7PAvtyP8Icdfk4vYE239GoLo+yvRD6Kkt51dNkjKNJugdY=\n=woq4\n-----END PGP SIGNATURE-----\n", "payload": "tree 9363db584b6448e81ca4e137c61f0547ae95f30d\nparent bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9\nparent 1bbc255ec59118e4e971dc65468b5a0c9955f9b4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639162971 +0000\ncommitter GitHub <noreply@github.com> 1639162971 +0000\n\nMerge #10981\n\n10981: internal: Remove some allocations r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/021d5821befc2e0a0d7d164b345f93d8dfaac52a", "html_url": "https://github.com/rust-lang/rust/commit/021d5821befc2e0a0d7d164b345f93d8dfaac52a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/021d5821befc2e0a0d7d164b345f93d8dfaac52a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9", "html_url": "https://github.com/rust-lang/rust/commit/bcc720f22ffeab3d5d7f0ecf5f6f441f83ff10f9"}, {"sha": "1bbc255ec59118e4e971dc65468b5a0c9955f9b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1bbc255ec59118e4e971dc65468b5a0c9955f9b4", "html_url": "https://github.com/rust-lang/rust/commit/1bbc255ec59118e4e971dc65468b5a0c9955f9b4"}], "stats": {"total": 136, "additions": 78, "deletions": 58}, "files": [{"sha": "17465dc2b04281a2423160dbad388aa1f48e9d6c", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -12,7 +12,10 @@ use hir_ty::{\n     },\n     Interner, TraitRefExt, WhereClause,\n };\n-use syntax::ast::{self, HasName};\n+use syntax::{\n+    ast::{self, HasName},\n+    SmolStr,\n+};\n \n use crate::{\n     Adt, Const, ConstParam, Enum, Field, Function, GenericParam, HasCrate, HasVisibility,\n@@ -247,7 +250,8 @@ impl HirDisplay for TypeParam {\n             bounds.iter().cloned().map(|b| b.substitute(&Interner, &substs)).collect();\n         let krate = self.id.parent.krate(f.db).id;\n         let sized_trait =\n-            f.db.lang_item(krate, \"sized\".into()).and_then(|lang_item| lang_item.as_trait());\n+            f.db.lang_item(krate, SmolStr::new_inline(\"sized\"))\n+                .and_then(|lang_item| lang_item.as_trait());\n         let has_only_sized_bound = predicates.iter().all(move |pred| match pred.skip_binders() {\n             WhereClause::Implemented(it) => Some(it.hir_trait_id()) == sized_trait,\n             _ => false,"}, {"sha": "7add0f4a4362eb6d27c08f0cf8a796173f0a6935", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -2427,7 +2427,7 @@ impl Type {\n         let krate = self.krate;\n \n         let std_future_trait =\n-            db.lang_item(krate, \"future_trait\".into()).and_then(|it| it.as_trait());\n+            db.lang_item(krate, SmolStr::new_inline(\"future_trait\")).and_then(|it| it.as_trait());\n         let std_future_trait = match std_future_trait {\n             Some(it) => it,\n             None => return false,\n@@ -2516,7 +2516,7 @@ impl Type {\n     }\n \n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n-        let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n+        let lang_item = db.lang_item(self.krate, SmolStr::new_inline(\"copy\"));\n         let copy_trait = match lang_item {\n             Some(LangItemTarget::TraitId(it)) => it,\n             _ => return false,"}, {"sha": "2d3d16cda0ecdc00c76037a3f07266f125ef9b4a", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -10,6 +10,7 @@ use chalk_ir::{cast::Cast, fold::Fold, interner::HasInterner, VariableKind};\n use hir_def::lang_item::LangItemTarget;\n use hir_expand::name::name;\n use limit::Limit;\n+use syntax::SmolStr;\n use tracing::{info, warn};\n \n use crate::{\n@@ -71,7 +72,10 @@ impl Iterator for Autoderef<'_> {\n         }\n \n         let (kind, new_ty) = if let Some(derefed) = builtin_deref(&self.ty.value) {\n-            (AutoderefKind::Builtin, Canonical { value: derefed, binders: self.ty.binders.clone() })\n+            (\n+                AutoderefKind::Builtin,\n+                Canonical { value: derefed.clone(), binders: self.ty.binders.clone() },\n+            )\n         } else {\n             (\n                 AutoderefKind::Overloaded,\n@@ -110,15 +114,17 @@ pub(crate) fn deref(\n ) -> Option<Canonical<Ty>> {\n     let _p = profile::span(\"deref\");\n     match builtin_deref(&ty.goal.value) {\n-        Some(derefed) => Some(Canonical { value: derefed, binders: ty.goal.binders.clone() }),\n+        Some(derefed) => {\n+            Some(Canonical { value: derefed.clone(), binders: ty.goal.binders.clone() })\n+        }\n         None => deref_by_trait(db, krate, ty),\n     }\n }\n \n-fn builtin_deref(ty: &Ty) -> Option<Ty> {\n+fn builtin_deref(ty: &Ty) -> Option<&Ty> {\n     match ty.kind(&Interner) {\n-        TyKind::Ref(.., ty) => Some(ty.clone()),\n-        TyKind::Raw(.., ty) => Some(ty.clone()),\n+        TyKind::Ref(.., ty) => Some(ty),\n+        TyKind::Raw(.., ty) => Some(ty),\n         _ => None,\n     }\n }\n@@ -129,7 +135,7 @@ fn deref_by_trait(\n     ty: InEnvironment<&Canonical<Ty>>,\n ) -> Option<Canonical<Ty>> {\n     let _p = profile::span(\"deref_by_trait\");\n-    let deref_trait = match db.lang_item(krate, \"deref\".into())? {\n+    let deref_trait = match db.lang_item(krate, SmolStr::new_inline(\"deref\"))? {\n         LangItemTarget::TraitId(it) => it,\n         _ => return None,\n     };"}, {"sha": "4a7b2d7363736b514132a51575d2a754f5efaad7", "filename": "crates/hir_ty/src/chalk_db.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_db.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -3,6 +3,7 @@\n use std::sync::Arc;\n \n use cov_mark::hit;\n+use syntax::SmolStr;\n use tracing::debug;\n \n use chalk_ir::{cast::Cast, fold::shift::Shift, CanonicalVarKinds};\n@@ -213,7 +214,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             crate::ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n                 if let Some((future_trait, future_output)) = self\n                     .db\n-                    .lang_item(self.krate, \"future_trait\".into())\n+                    .lang_item(self.krate, SmolStr::new_inline(\"future_trait\"))\n                     .and_then(|item| item.as_trait())\n                     .and_then(|trait_| {\n                         let alias =\n@@ -419,7 +420,7 @@ pub(crate) fn associated_ty_data_query(\n     if !ctx.unsized_types.borrow().contains(&self_ty) {\n         let sized_trait = resolver\n             .krate()\n-            .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n+            .and_then(|krate| db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n             .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n         let sized_bound = sized_trait.into_iter().map(|sized_trait| {\n             let trait_bound ="}, {"sha": "97d1ad0f9cd44a3d2767fda25da73112c96ea2de", "filename": "crates/hir_ty/src/chalk_ext.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fchalk_ext.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -6,6 +6,7 @@ use hir_def::{\n     type_ref::Rawness,\n     FunctionId, GenericDefId, HasModule, ItemContainerId, Lookup, TraitId,\n };\n+use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n@@ -187,7 +188,7 @@ impl TyExt for Ty {\n                     ImplTraitId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n                         if let Some(future_trait) = db\n-                            .lang_item(krate, \"future_trait\".into())\n+                            .lang_item(krate, SmolStr::new_inline(\"future_trait\"))\n                             .and_then(|item| item.as_trait())\n                         {\n                             // This is only used by type walking."}, {"sha": "f268746809e490e8c25644d2df81177c1cee0a73", "filename": "crates/hir_ty/src/diagnostics/match_check/deconstruct_pat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check%2Fdeconstruct_pat.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -50,6 +50,7 @@ use std::{\n use hir_def::{EnumVariantId, HasModule, LocalFieldId, VariantId};\n use smallvec::{smallvec, SmallVec};\n use stdx::never;\n+use syntax::SmolStr;\n \n use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n@@ -905,7 +906,7 @@ fn is_field_list_non_exhaustive(variant_id: VariantId, cx: &MatchCheckCtx<'_>) -\n \n fn adt_is_box(adt: hir_def::AdtId, cx: &MatchCheckCtx<'_>) -> bool {\n     use hir_def::lang_item::LangItemTarget;\n-    match cx.db.lang_item(cx.module.krate(), \"owned_box\".into()) {\n+    match cx.db.lang_item(cx.module.krate(), SmolStr::new_inline(\"owned_box\")) {\n         Some(LangItemTarget::StructId(box_id)) => adt == box_id.into(),\n         _ => false,\n     }"}, {"sha": "c09f8db86e3f68018625546a153557aed577d85e", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -20,6 +20,7 @@ use hir_def::{\n };\n use hir_expand::{hygiene::Hygiene, name::Name};\n use itertools::Itertools;\n+use syntax::SmolStr;\n \n use crate::{\n     const_from_placeholder_idx,\n@@ -774,8 +775,9 @@ impl SizedByDefault {\n         match self {\n             Self::NotSized => false,\n             Self::Sized { anchor } => {\n-                let sized_trait =\n-                    db.lang_item(anchor, \"sized\".into()).and_then(|lang_item| lang_item.as_trait());\n+                let sized_trait = db\n+                    .lang_item(anchor, SmolStr::new_inline(\"sized\"))\n+                    .and_then(|lang_item| lang_item.as_trait());\n                 Some(trait_) == sized_trait\n             }\n         }"}, {"sha": "aebff59113ecfe4bc9acbeef23766bbdeb93e477", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -10,6 +10,7 @@ use std::iter;\n use chalk_ir::{cast::Cast, Goal, Mutability, TyVariableKind};\n use hir_def::{expr::ExprId, lang_item::LangItemTarget};\n use stdx::always;\n+use syntax::SmolStr;\n \n use crate::{\n     autoderef::{Autoderef, AutoderefKind},\n@@ -536,10 +537,11 @@ impl<'a> InferenceContext<'a> {\n             reborrow.as_ref().map_or_else(|| from_ty.clone(), |(_, adj)| adj.target.clone());\n \n         let krate = self.resolver.krate().unwrap();\n-        let coerce_unsized_trait = match self.db.lang_item(krate, \"coerce_unsized\".into()) {\n-            Some(LangItemTarget::TraitId(trait_)) => trait_,\n-            _ => return Err(TypeError),\n-        };\n+        let coerce_unsized_trait =\n+            match self.db.lang_item(krate, SmolStr::new_inline(\"coerce_unsized\")) {\n+                Some(LangItemTarget::TraitId(trait_)) => trait_,\n+                _ => return Err(TypeError),\n+            };\n \n         let coerce_unsized_tref = {\n             let b = TyBuilder::trait_ref(self.db, coerce_unsized_trait);"}, {"sha": "7373c9eb8b4b84c143f25cabd295c0abe91b9137", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -28,7 +28,7 @@ use la_arena::ArenaMap;\n use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::impl_from;\n-use syntax::ast;\n+use syntax::{ast, SmolStr};\n \n use crate::all_super_traits;\n use crate::{\n@@ -797,7 +797,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let sized_trait = self\n                     .resolver\n                     .krate()\n-                    .and_then(|krate| self.db.lang_item(krate, \"sized\".into()))\n+                    .and_then(|krate| self.db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n                     .and_then(|lang_item| lang_item.as_trait());\n                 // Don't lower associated type bindings as the only possible relaxed trait bound\n                 // `?Sized` has no of them.\n@@ -895,7 +895,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let krate = func.lookup(ctx.db.upcast()).module(ctx.db.upcast()).krate();\n                 let sized_trait = ctx\n                     .db\n-                    .lang_item(krate, \"sized\".into())\n+                    .lang_item(krate, SmolStr::new_inline(\"sized\"))\n                     .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n                 let sized_clause = sized_trait.map(|trait_id| {\n                     let clause = WhereClause::Implemented(TraitRef {\n@@ -1200,7 +1200,7 @@ fn implicitly_sized_clauses<'a>(\n     let generic_args = &substitution.as_slice(&Interner)[is_trait_def as usize..];\n     let sized_trait = resolver\n         .krate()\n-        .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n+        .and_then(|krate| db.lang_item(krate, SmolStr::new_inline(\"sized\")))\n         .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n \n     sized_trait.into_iter().flat_map(move |sized_trait| {"}, {"sha": "1549a40c91dc208f70f6a49669ed374b16c6e723", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -541,19 +541,19 @@ pub fn iterate_method_candidates_dyn(\n             // types*.\n \n             let deref_chain = autoderef_method_receiver(db, krate, ty);\n-            for i in 0..deref_chain.len() {\n+            let mut deref_chains = stdx::slice_tails(&deref_chain);\n+            deref_chains.try_for_each(|deref_chain| {\n                 iterate_method_candidates_with_autoref(\n-                    &deref_chain[i..],\n+                    deref_chain,\n                     db,\n                     env.clone(),\n                     krate,\n                     traits_in_scope,\n                     visible_from_module,\n                     name,\n                     callback,\n-                )?;\n-            }\n-            ControlFlow::Continue(())\n+                )\n+            })\n         }\n         LookupMode::Path => {\n             // No autoderef for path lookups\n@@ -716,15 +716,14 @@ fn iterate_trait_method_candidates(\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = match self_ty.value.kind(&Interner) {\n-        TyKind::Placeholder(_) => {\n-            // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n+    let env_traits = matches!(self_ty.value.kind(&Interner), TyKind::Placeholder(_))\n+        // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n+        .then(|| {\n             env.traits_in_scope_from_clauses(self_ty.value.clone())\n                 .flat_map(|t| all_super_traits(db.upcast(), t))\n-                .collect()\n-        }\n-        _ => Vec::new(),\n-    };\n+        })\n+        .into_iter()\n+        .flatten();\n     let traits = inherent_trait.chain(env_traits).chain(traits_in_scope.iter().copied());\n \n     'traits: for t in traits {\n@@ -747,10 +746,10 @@ fn iterate_trait_method_candidates(\n         // trait, but if we find out it doesn't, we'll skip the rest of the\n         // iteration\n         let mut known_implemented = false;\n-        for (_name, item) in data.items.iter() {\n+        for &(_, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(db, env.clone(), name, receiver_ty, *item, self_ty, None) {\n+            if !is_valid_candidate(db, env.clone(), name, receiver_ty, item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n@@ -761,7 +760,7 @@ fn iterate_trait_method_candidates(\n             }\n             known_implemented = true;\n             // FIXME: we shouldn't be ignoring the binders here\n-            callback(self_ty, *item)?\n+            callback(self_ty, item)?\n         }\n     }\n     ControlFlow::Continue(())\n@@ -774,18 +773,14 @@ fn filter_inherent_impls_for_self_ty<'i>(\n     // inherent methods on arrays are fingerprinted as [T; {unknown}], so we must also consider them when\n     // resolving a method call on an array with a known len\n     let array_impls = {\n-        if let TyKind::Array(parameters, array_len) = self_ty.kind(&Interner) {\n-            if !array_len.is_unknown() {\n+        match self_ty.kind(&Interner) {\n+            TyKind::Array(parameters, array_len) if !array_len.is_unknown() => {\n                 let unknown_array_len_ty =\n-                    TyKind::Array(parameters.clone(), consteval::usize_const(None))\n-                        .intern(&Interner);\n+                    TyKind::Array(parameters.clone(), consteval::usize_const(None));\n \n-                Some(impls.for_self_ty(&unknown_array_len_ty))\n-            } else {\n-                None\n+                Some(impls.for_self_ty(&unknown_array_len_ty.intern(&Interner)))\n             }\n-        } else {\n-            None\n+            _ => None,\n         }\n     }\n     .into_iter()"}, {"sha": "0d135651c78ee615e03611b899b85f1039fe22f6", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -9,6 +9,7 @@ use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n use base_db::CrateId;\n use hir_def::{lang_item::LangItemTarget, TraitId};\n use stdx::panic_context;\n+use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Goal, Guidance, InEnvironment,\n@@ -169,7 +170,7 @@ pub enum FnTrait {\n }\n \n impl FnTrait {\n-    fn lang_item_name(self) -> &'static str {\n+    const fn lang_item_name(self) -> &'static str {\n         match self {\n             FnTrait::FnOnce => \"fn_once\",\n             FnTrait::FnMut => \"fn_mut\",\n@@ -178,7 +179,7 @@ impl FnTrait {\n     }\n \n     pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-        let target = db.lang_item(krate, self.lang_item_name().into())?;\n+        let target = db.lang_item(krate, SmolStr::new_inline(self.lang_item_name()))?;\n         match target {\n             LangItemTarget::TraitId(t) => Some(t),\n             _ => None,"}, {"sha": "f36a5f898719d33fba723c3acb3d4833b840ed17", "filename": "crates/hir_ty/src/utils.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fhir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Futils.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -18,6 +18,8 @@ use hir_def::{\n };\n use hir_expand::name::{name, Name};\n use rustc_hash::FxHashSet;\n+use smallvec::{smallvec, SmallVec};\n+use syntax::SmolStr;\n \n use crate::{\n     db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, TyKind,\n@@ -26,16 +28,16 @@ use crate::{\n \n pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n     [\n-        db.lang_item(krate, \"fn\".into()),\n-        db.lang_item(krate, \"fn_mut\".into()),\n-        db.lang_item(krate, \"fn_once\".into()),\n+        db.lang_item(krate, SmolStr::new_inline(\"fn\")),\n+        db.lang_item(krate, SmolStr::new_inline(\"fn_mut\")),\n+        db.lang_item(krate, SmolStr::new_inline(\"fn_once\")),\n     ]\n     .into_iter()\n     .flatten()\n     .flat_map(|it| it.as_trait())\n }\n \n-fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n     let resolver = trait_.resolver(db);\n     // returning the iterator directly doesn't easily work because of\n     // lifetime problems, but since there usually shouldn't be more than a\n@@ -100,13 +102,13 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n \n /// Returns an iterator over the whole super trait hierarchy (including the\n /// trait itself).\n-pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n     // we need to take care a bit here to avoid infinite loops in case of cycles\n     // (i.e. if we have `trait A: B; trait B: A;`)\n-    let mut result = vec![trait_];\n+\n+    let mut result = smallvec![trait_];\n     let mut i = 0;\n-    while i < result.len() {\n-        let t = result[i];\n+    while let Some(&t) = result.get(i) {\n         // yeah this is quadratic, but trait hierarchies should be flat\n         // enough that this doesn't matter\n         for tt in direct_super_traits(db, t) {"}, {"sha": "e33b45cc8efc40b605e98c923a8b363a7286e60a", "filename": "crates/stdx/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fstdx%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/021d5821befc2e0a0d7d164b345f93d8dfaac52a/crates%2Fstdx%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fstdx%2Fsrc%2Flib.rs?ref=021d5821befc2e0a0d7d164b345f93d8dfaac52a", "patch": "@@ -193,6 +193,11 @@ where\n     }\n }\n \n+/// Returns all final segments of the argument, longest first.\n+pub fn slice_tails<T>(this: &[T]) -> impl Iterator<Item = &[T]> {\n+    (0..this.len()).map(|i| &this[i..])\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}