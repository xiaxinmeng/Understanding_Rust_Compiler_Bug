{"sha": "dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiYzAyODU0ZmNlMWY3ODM1OTllM2Y5OGI2ZWU2YjlhMTM2ZDllOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T06:32:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-10T06:32:32Z"}, "message": "Auto merge of #5727 - rail-rain:manual_memcpy_with_counter, r=flip1995\n\nExpands `manual_memcpy` to lint ones with loop counters\n\nCloses #1670\n\nThis PR expands `manual_memcpy` to lint ones with loop counters as described in https://github.com/rust-lang/rust-clippy/issues/1670#issuecomment-293280204\n\nAlthough the current code is working, I have a couple of questions and concerns.\n\n~~Firstly, I manually implemented `Clone` for `Sugg` because `AssocOp` lacks `Clone`. As `AssocOp` only holds an enum, which is `Copy`, as a value, it seems `AssocOp` can be `Clone`; but, I was not sure where to ask it. Should I make a PR to `rustc`?~~ The [PR]( https://github.com/rust-lang/rust/pull/73629) was made.\n\nSecondly, manual copying with loop counters are likely to trigger `needless_range_loop` and `explicit_counter_loop` along with `manual_memcpy`; in fact, I explicitly allowed them in the tests. Is there any way to disable these two lints when a code triggers `manual_memcpy`?\n\nAnd, another thing I'd like to note is that `Sugg` adds unnecessary parentheses when expressions with parentheses passed to its `hir` function, as seen here:\n\n```\nerror: it looks like you're manually copying between slices\n  --> $DIR/manual_memcpy.rs:145:14\n   |\nLL |     for i in 3..(3 + src.len()) {\n   |              ^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[3..((3 + src.len()))].clone_from_slice(&src[..((3 + src.len()) - 3)])\n```\n\nHowever, using the `hir` function is needed to prevent the suggestion causing  errors when users use bitwise operations; and also this have already existed, for example: `verbose_bit_mask`. Thus, I think this is fine.\n\nchangelog: Expands `manual_memcpy` to lint ones with loop counters", "tree": {"sha": "79cea5dd04adaef96de5fdba80c4c4f0b93850a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79cea5dd04adaef96de5fdba80c4c4f0b93850a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "html_url": "https://github.com/rust-lang/rust/commit/dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480", "html_url": "https://github.com/rust-lang/rust/commit/2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480"}, {"sha": "b54188429409a6da5f931fa4be5df1f40b377015", "url": "https://api.github.com/repos/rust-lang/rust/commits/b54188429409a6da5f931fa4be5df1f40b377015", "html_url": "https://github.com/rust-lang/rust/commit/b54188429409a6da5f931fa4be5df1f40b377015"}], "stats": {"total": 1101, "additions": 804, "deletions": 297}, "files": [{"sha": "b606db179efdbda604c3549c6df52f77b7f68820", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 437, "deletions": 201, "changes": 638, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -5,9 +5,8 @@ use crate::utils::usage::{is_unused, mutated_variables};\n use crate::utils::{\n     contains_name, get_enclosing_block, get_parent_expr, get_trait_def_id, has_iter_method, higher, implements_trait,\n     is_integer_const, is_no_std_crate, is_refutable, is_type_diagnostic_item, last_path_segment, match_trait_method,\n-    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_opt, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg,\n-    SpanlessEq,\n+    match_type, match_var, multispan_sugg, qpath_res, snippet, snippet_with_applicability, snippet_with_macro_callsite,\n+    span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, sugg, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -769,15 +768,28 @@ fn check_for_loop<'tcx>(\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n ) {\n-    check_for_loop_range(cx, pat, arg, body, expr);\n+    let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n+    if !is_manual_memcpy_triggered {\n+        check_for_loop_range(cx, pat, arg, body, expr);\n+        check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n+    }\n     check_for_loop_arg(cx, pat, arg, expr);\n-    check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n     check_for_mut_range_bound(cx, arg, body);\n-    detect_manual_memcpy(cx, pat, arg, body, expr);\n     detect_same_item_push(cx, pat, arg, body, expr);\n }\n \n+// this function assumes the given expression is a `for` loop.\n+fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n+    // for some reason this is the only way to get the `Span`\n+    // of the entire `for` loop\n+    if let ExprKind::Match(_, arms, _) = &expr.kind {\n+        arms[0].body.span\n+    } else {\n+        unreachable!()\n+    }\n+}\n+\n fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     if_chain! {\n         if let ExprKind::Path(qpath) = &expr.kind;\n@@ -793,36 +805,131 @@ fn same_var<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, var: HirId) -> bool {\n     }\n }\n \n-#[derive(Clone, Copy)]\n-enum OffsetSign {\n-    Positive,\n-    Negative,\n+/// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n+/// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n+/// it exists for the convenience of the overloaded operators while normal functions can do the\n+/// same.\n+#[derive(Clone)]\n+struct MinifyingSugg<'a>(Sugg<'a>);\n+\n+impl<'a> MinifyingSugg<'a> {\n+    fn as_str(&self) -> &str {\n+        let Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) = &self.0;\n+        s.as_ref()\n+    }\n+\n+    fn into_sugg(self) -> Sugg<'a> {\n+        self.0\n+    }\n+}\n+\n+impl<'a> From<Sugg<'a>> for MinifyingSugg<'a> {\n+    fn from(sugg: Sugg<'a>) -> Self {\n+        Self(sugg)\n+    }\n+}\n+\n+impl std::ops::Add for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self.clone(),\n+            (_, _) => (&self.0 + &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Sub for &MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self.clone(),\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (&self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+impl std::ops::Add<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn add(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (\"0\", _) => rhs.clone(),\n+            (_, \"0\") => self,\n+            (_, _) => (self.0 + &rhs.0).into(),\n+        }\n+    }\n }\n \n+impl std::ops::Sub<&MinifyingSugg<'static>> for MinifyingSugg<'static> {\n+    type Output = MinifyingSugg<'static>;\n+    fn sub(self, rhs: &MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n+        match (self.as_str(), rhs.as_str()) {\n+            (_, \"0\") => self,\n+            (\"0\", _) => (-rhs.0.clone()).into(),\n+            (x, y) if x == y => sugg::ZERO.into(),\n+            (_, _) => (self.0 - &rhs.0).into(),\n+        }\n+    }\n+}\n+\n+/// a wrapper around `MinifyingSugg`, which carries a operator like currying\n+/// so that the suggested code become more efficient (e.g. `foo + -bar` `foo - bar`).\n struct Offset {\n-    value: String,\n+    value: MinifyingSugg<'static>,\n     sign: OffsetSign,\n }\n \n+#[derive(Clone, Copy)]\n+enum OffsetSign {\n+    Positive,\n+    Negative,\n+}\n+\n impl Offset {\n-    fn negative(value: String) -> Self {\n+    fn negative(value: Sugg<'static>) -> Self {\n         Self {\n-            value,\n+            value: value.into(),\n             sign: OffsetSign::Negative,\n         }\n     }\n \n-    fn positive(value: String) -> Self {\n+    fn positive(value: Sugg<'static>) -> Self {\n         Self {\n-            value,\n+            value: value.into(),\n             sign: OffsetSign::Positive,\n         }\n     }\n+\n+    fn empty() -> Self {\n+        Self::positive(sugg::ZERO)\n+    }\n }\n \n-struct FixedOffsetVar<'hir> {\n-    var: &'hir Expr<'hir>,\n-    offset: Offset,\n+fn apply_offset(lhs: &MinifyingSugg<'static>, rhs: &Offset) -> MinifyingSugg<'static> {\n+    match rhs.sign {\n+        OffsetSign::Positive => lhs + &rhs.value,\n+        OffsetSign::Negative => lhs - &rhs.value,\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum StartKind<'hir> {\n+    Range,\n+    Counter { initializer: &'hir Expr<'hir> },\n+}\n+\n+struct IndexExpr<'hir> {\n+    base: &'hir Expr<'hir>,\n+    idx: StartKind<'hir>,\n+    idx_offset: Offset,\n+}\n+\n+struct Start<'hir> {\n+    id: HirId,\n+    kind: StartKind<'hir>,\n }\n \n fn is_slice_like<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'_>) -> bool {\n@@ -845,151 +952,216 @@ fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     }\n }\n \n-fn get_offset<'tcx>(cx: &LateContext<'tcx>, idx: &Expr<'_>, var: HirId) -> Option<Offset> {\n-    fn extract_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, var: HirId) -> Option<String> {\n+fn get_details_from_idx<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    idx: &Expr<'_>,\n+    starts: &[Start<'tcx>],\n+) -> Option<(StartKind<'tcx>, Offset)> {\n+    fn get_start<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<StartKind<'tcx>> {\n+        starts.iter().find_map(|start| {\n+            if same_var(cx, e, start.id) {\n+                Some(start.kind)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+\n+    fn get_offset<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>, starts: &[Start<'tcx>]) -> Option<Sugg<'static>> {\n         match &e.kind {\n             ExprKind::Lit(l) => match l.node {\n-                ast::LitKind::Int(x, _ty) => Some(x.to_string()),\n+                ast::LitKind::Int(x, _ty) => Some(Sugg::NonParen(x.to_string().into())),\n                 _ => None,\n             },\n-            ExprKind::Path(..) if !same_var(cx, e, var) => Some(snippet_opt(cx, e.span).unwrap_or_else(|| \"??\".into())),\n+            ExprKind::Path(..) if get_start(cx, e, starts).is_none() => Some(Sugg::hir(cx, e, \"???\")),\n             _ => None,\n         }\n     }\n \n     match idx.kind {\n         ExprKind::Binary(op, lhs, rhs) => match op.node {\n             BinOpKind::Add => {\n-                let offset_opt = if same_var(cx, lhs, var) {\n-                    extract_offset(cx, rhs, var)\n-                } else if same_var(cx, rhs, var) {\n-                    extract_offset(cx, lhs, var)\n-                } else {\n-                    None\n-                };\n+                let offset_opt = get_start(cx, lhs, starts)\n+                    .and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, o)))\n+                    .or_else(|| get_start(cx, rhs, starts).and_then(|s| get_offset(cx, lhs, starts).map(|o| (s, o))));\n \n-                offset_opt.map(Offset::positive)\n+                offset_opt.map(|(s, o)| (s, Offset::positive(o)))\n+            },\n+            BinOpKind::Sub => {\n+                get_start(cx, lhs, starts).and_then(|s| get_offset(cx, rhs, starts).map(|o| (s, Offset::negative(o))))\n             },\n-            BinOpKind::Sub if same_var(cx, lhs, var) => extract_offset(cx, rhs, var).map(Offset::negative),\n             _ => None,\n         },\n-        ExprKind::Path(..) if same_var(cx, idx, var) => Some(Offset::positive(\"0\".into())),\n+        ExprKind::Path(..) => get_start(cx, idx, starts).map(|s| (s, Offset::empty())),\n         _ => None,\n     }\n }\n \n-fn get_assignments<'tcx>(body: &'tcx Expr<'tcx>) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> {\n-    fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n-        if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n-            Some((lhs, rhs))\n-        } else {\n-            None\n-        }\n+fn get_assignment<'tcx>(e: &'tcx Expr<'tcx>) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)> {\n+    if let ExprKind::Assign(lhs, rhs, _) = e.kind {\n+        Some((lhs, rhs))\n+    } else {\n+        None\n     }\n+}\n \n-    // This is one of few ways to return different iterators\n-    // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n-    let mut iter_a = None;\n-    let mut iter_b = None;\n+/// Get assignments from the given block.\n+/// The returned iterator yields `None` if no assignment expressions are there,\n+/// filtering out the increments of the given whitelisted loop counters;\n+/// because its job is to make sure there's nothing other than assignments and the increments.\n+fn get_assignments<'a: 'c, 'tcx: 'c, 'c>(\n+    cx: &'a LateContext<'tcx>,\n+    Block { stmts, expr, .. }: &'tcx Block<'tcx>,\n+    loop_counters: &'c [Start<'tcx>],\n+) -> impl Iterator<Item = Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>)>> + 'c {\n+    // As the `filter` and `map` below do different things, I think putting together\n+    // just increases complexity. (cc #3188 and #4193)\n+    #[allow(clippy::filter_map)]\n+    stmts\n+        .iter()\n+        .filter_map(move |stmt| match stmt.kind {\n+            StmtKind::Local(..) | StmtKind::Item(..) => None,\n+            StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+        })\n+        .chain((*expr).into_iter())\n+        .filter(move |e| {\n+            if let ExprKind::AssignOp(_, place, _) = e.kind {\n+                !loop_counters\n+                    .iter()\n+                    // skip the first item which should be `StartKind::Range`\n+                    // this makes it possible to use the slice with `StartKind::Range` in the same iterator loop.\n+                    .skip(1)\n+                    .any(|counter| same_var(cx, place, counter.id))\n+            } else {\n+                true\n+            }\n+        })\n+        .map(get_assignment)\n+}\n \n-    if let ExprKind::Block(b, _) = body.kind {\n-        let Block { stmts, expr, .. } = *b;\n+fn get_loop_counters<'a, 'tcx>(\n+    cx: &'a LateContext<'tcx>,\n+    body: &'tcx Block<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<impl Iterator<Item = Start<'tcx>> + 'a> {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_block(&mut increment_visitor, body);\n \n-        iter_a = stmts\n-            .iter()\n-            .filter_map(|stmt| match stmt.kind {\n-                StmtKind::Local(..) | StmtKind::Item(..) => None,\n-                StmtKind::Expr(e) | StmtKind::Semi(e) => Some(e),\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    get_enclosing_block(&cx, expr.hir_id).and_then(|block| {\n+        increment_visitor\n+            .into_results()\n+            .filter_map(move |var_id| {\n+                let mut initialize_visitor = InitializeVisitor::new(cx, expr, var_id);\n+                walk_block(&mut initialize_visitor, block);\n+\n+                initialize_visitor.get_result().map(|(_, initializer)| Start {\n+                    id: var_id,\n+                    kind: StartKind::Counter { initializer },\n+                })\n             })\n-            .chain(expr.into_iter())\n-            .map(get_assignment)\n             .into()\n-    } else {\n-        iter_b = Some(get_assignment(body))\n-    }\n-\n-    iter_a.into_iter().flatten().chain(iter_b.into_iter())\n+    })\n }\n \n fn build_manual_memcpy_suggestion<'tcx>(\n     cx: &LateContext<'tcx>,\n     start: &Expr<'_>,\n     end: &Expr<'_>,\n     limits: ast::RangeLimits,\n-    dst_var: FixedOffsetVar<'_>,\n-    src_var: FixedOffsetVar<'_>,\n+    dst: &IndexExpr<'_>,\n+    src: &IndexExpr<'_>,\n ) -> String {\n-    fn print_sum(arg1: &str, arg2: &Offset) -> String {\n-        match (arg1, &arg2.value[..], arg2.sign) {\n-            (\"0\", \"0\", _) => \"0\".into(),\n-            (\"0\", x, OffsetSign::Positive) | (x, \"0\", _) => x.into(),\n-            (\"0\", x, OffsetSign::Negative) => format!(\"-{}\", x),\n-            (x, y, OffsetSign::Positive) => format!(\"({} + {})\", x, y),\n-            (x, y, OffsetSign::Negative) => {\n-                if x == y {\n-                    \"0\".into()\n-                } else {\n-                    format!(\"({} - {})\", x, y)\n-                }\n-            },\n-        }\n-    }\n-\n-    fn print_offset(start_str: &str, inline_offset: &Offset) -> String {\n-        let offset = print_sum(start_str, inline_offset);\n+    fn print_offset(offset: MinifyingSugg<'static>) -> MinifyingSugg<'static> {\n         if offset.as_str() == \"0\" {\n-            \"\".into()\n+            sugg::EMPTY.into()\n         } else {\n             offset\n         }\n     }\n \n-    let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n+    let print_limit = |end: &Expr<'_>, end_str: &str, base: &Expr<'_>, sugg: MinifyingSugg<'static>| {\n         if_chain! {\n             if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n-            if var_def_id(cx, arg) == var_def_id(cx, var);\n+            if var_def_id(cx, arg) == var_def_id(cx, base);\n             then {\n-                match offset.sign {\n-                    OffsetSign::Negative => format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value),\n-                    OffsetSign::Positive => \"\".into(),\n+                if sugg.as_str() == end_str {\n+                    sugg::EMPTY.into()\n+                } else {\n+                    sugg\n                 }\n             } else {\n-                let end_str = match limits {\n+                match limits {\n                     ast::RangeLimits::Closed => {\n-                        let end = sugg::Sugg::hir(cx, end, \"<count>\");\n-                        format!(\"{}\", end + sugg::ONE)\n+                        sugg + &sugg::ONE.into()\n                     },\n-                    ast::RangeLimits::HalfOpen => format!(\"{}\", snippet(cx, end.span, \"..\")),\n-                };\n-\n-                print_sum(&end_str, &offset)\n+                    ast::RangeLimits::HalfOpen => sugg,\n+                }\n             }\n         }\n     };\n \n-    let start_str = snippet(cx, start.span, \"\").to_string();\n-    let dst_offset = print_offset(&start_str, &dst_var.offset);\n-    let dst_limit = print_limit(end, dst_var.offset, dst_var.var);\n-    let src_offset = print_offset(&start_str, &src_var.offset);\n-    let src_limit = print_limit(end, src_var.offset, src_var.var);\n+    let start_str = Sugg::hir(cx, start, \"\").into();\n+    let end_str: MinifyingSugg<'_> = Sugg::hir(cx, end, \"\").into();\n+\n+    let print_offset_and_limit = |idx_expr: &IndexExpr<'_>| match idx_expr.idx {\n+        StartKind::Range => (\n+            print_offset(apply_offset(&start_str, &idx_expr.idx_offset)).into_sugg(),\n+            print_limit(\n+                end,\n+                end_str.as_str(),\n+                idx_expr.base,\n+                apply_offset(&end_str, &idx_expr.idx_offset),\n+            )\n+            .into_sugg(),\n+        ),\n+        StartKind::Counter { initializer } => {\n+            let counter_start = Sugg::hir(cx, initializer, \"\").into();\n+            (\n+                print_offset(apply_offset(&counter_start, &idx_expr.idx_offset)).into_sugg(),\n+                print_limit(\n+                    end,\n+                    end_str.as_str(),\n+                    idx_expr.base,\n+                    apply_offset(&end_str, &idx_expr.idx_offset) + &counter_start - &start_str,\n+                )\n+                .into_sugg(),\n+            )\n+        },\n+    };\n+\n+    let (dst_offset, dst_limit) = print_offset_and_limit(&dst);\n+    let (src_offset, src_limit) = print_offset_and_limit(&src);\n \n-    let dst_var_name = snippet_opt(cx, dst_var.var.span).unwrap_or_else(|| \"???\".into());\n-    let src_var_name = snippet_opt(cx, src_var.var.span).unwrap_or_else(|| \"???\".into());\n+    let dst_base_str = snippet(cx, dst.base.span, \"???\");\n+    let src_base_str = snippet(cx, src.base.span, \"???\");\n \n-    let dst = if dst_offset == \"\" && dst_limit == \"\" {\n-        dst_var_name\n+    let dst = if dst_offset == sugg::EMPTY && dst_limit == sugg::EMPTY {\n+        dst_base_str\n     } else {\n-        format!(\"{}[{}..{}]\", dst_var_name, dst_offset, dst_limit)\n+        format!(\n+            \"{}[{}..{}]\",\n+            dst_base_str,\n+            dst_offset.maybe_par(),\n+            dst_limit.maybe_par()\n+        )\n+        .into()\n     };\n \n     format!(\n-        \"{}.clone_from_slice(&{}[{}..{}])\",\n-        dst, src_var_name, src_offset, src_limit\n+        \"{}.clone_from_slice(&{}[{}..{}]);\",\n+        dst,\n+        src_base_str,\n+        src_offset.maybe_par(),\n+        src_limit.maybe_par()\n     )\n }\n+\n /// Checks for for loops that sequentially copy items from one slice-like\n /// object to another.\n fn detect_manual_memcpy<'tcx>(\n@@ -998,7 +1170,7 @@ fn detect_manual_memcpy<'tcx>(\n     arg: &'tcx Expr<'_>,\n     body: &'tcx Expr<'_>,\n     expr: &'tcx Expr<'_>,\n-) {\n+) -> bool {\n     if let Some(higher::Range {\n         start: Some(start),\n         end: Some(end),\n@@ -1007,32 +1179,53 @@ fn detect_manual_memcpy<'tcx>(\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {\n-            // The only statements in the for loops can be indexed assignments from\n-            // indexed retrievals.\n-            let big_sugg = get_assignments(body)\n+            let mut starts = vec![Start {\n+                id: canonical_id,\n+                kind: StartKind::Range,\n+            }];\n+\n+            // This is one of few ways to return different iterators\n+            // derived from: https://stackoverflow.com/questions/29760668/conditionally-iterate-over-one-of-several-possible-iterators/52064434#52064434\n+            let mut iter_a = None;\n+            let mut iter_b = None;\n+\n+            if let ExprKind::Block(block, _) = body.kind {\n+                if let Some(loop_counters) = get_loop_counters(cx, block, expr) {\n+                    starts.extend(loop_counters);\n+                }\n+                iter_a = Some(get_assignments(cx, block, &starts));\n+            } else {\n+                iter_b = Some(get_assignment(body));\n+            }\n+\n+            let assignments = iter_a.into_iter().flatten().chain(iter_b.into_iter());\n+\n+            let big_sugg = assignments\n+                // The only statements in the for loops can be indexed assignments from\n+                // indexed retrievals (except increments of loop counters).\n                 .map(|o| {\n                     o.and_then(|(lhs, rhs)| {\n                         let rhs = fetch_cloned_expr(rhs);\n                         if_chain! {\n-                            if let ExprKind::Index(seqexpr_left, idx_left) = lhs.kind;\n-                            if let ExprKind::Index(seqexpr_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(seqexpr_right));\n-                            if let Some(offset_left) = get_offset(cx, &idx_left, canonical_id);\n-                            if let Some(offset_right) = get_offset(cx, &idx_right, canonical_id);\n+                            if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n+                            if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n+                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n+                            if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n \n                             // Source and destination must be different\n-                            if var_def_id(cx, seqexpr_left) != var_def_id(cx, seqexpr_right);\n+                            if var_def_id(cx, base_left) != var_def_id(cx, base_right);\n                             then {\n-                                Some((FixedOffsetVar { var: seqexpr_left, offset: offset_left },\n-                                    FixedOffsetVar { var: seqexpr_right, offset: offset_right }))\n+                                Some((IndexExpr { base: base_left, idx: start_left, idx_offset: offset_left },\n+                                    IndexExpr { base: base_right, idx: start_right, idx_offset: offset_right }))\n                             } else {\n                                 None\n                             }\n                         }\n                     })\n                 })\n-                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, dst, src)))\n+                .map(|o| o.map(|(dst, src)| build_manual_memcpy_suggestion(cx, start, end, limits, &dst, &src)))\n                 .collect::<Option<Vec<_>>>()\n                 .filter(|v| !v.is_empty())\n                 .map(|v| v.join(\"\\n    \"));\n@@ -1041,15 +1234,17 @@ fn detect_manual_memcpy<'tcx>(\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_MEMCPY,\n-                    expr.span,\n+                    get_span_of_entire_for_loop(expr),\n                     \"it looks like you're manually copying between slices\",\n                     \"try replacing the loop by\",\n                     big_sugg,\n                     Applicability::Unspecified,\n                 );\n+                return true;\n             }\n         }\n     }\n+    false\n }\n \n // Scans the body of the for loop and determines whether lint should be given\n@@ -1532,6 +1727,9 @@ fn check_arg_type(cx: &LateContext<'_>, pat: &Pat<'_>, arg: &Expr<'_>) {\n     }\n }\n \n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n fn check_for_loop_explicit_counter<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,\n@@ -1540,40 +1738,23 @@ fn check_for_loop_explicit_counter<'tcx>(\n     expr: &'tcx Expr<'_>,\n ) {\n     // Look for variables that are incremented once per loop iteration.\n-    let mut visitor = IncrementVisitor {\n-        cx,\n-        states: FxHashMap::default(),\n-        depth: 0,\n-        done: false,\n-    };\n-    walk_expr(&mut visitor, body);\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_expr(&mut increment_visitor, body);\n \n     // For each candidate, check the parent block to see if\n     // it's initialized to zero at the start of the loop.\n     if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n-        for (id, _) in visitor.states.iter().filter(|&(_, v)| *v == VarState::IncrOnce) {\n-            let mut visitor2 = InitializeVisitor {\n-                cx,\n-                end_expr: expr,\n-                var_id: *id,\n-                state: VarState::IncrOnce,\n-                name: None,\n-                depth: 0,\n-                past_loop: false,\n-            };\n-            walk_block(&mut visitor2, block);\n+        for id in increment_visitor.into_results() {\n+            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n+            walk_block(&mut initialize_visitor, block);\n \n-            if visitor2.state == VarState::Warn {\n-                if let Some(name) = visitor2.name {\n+            if_chain! {\n+                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if is_integer_const(cx, initializer, 0);\n+                then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    // for some reason this is the only way to get the `Span`\n-                    // of the entire `for` loop\n-                    let for_span = if let ExprKind::Match(_, arms, _) = &expr.kind {\n-                        arms[0].body.span\n-                    } else {\n-                        unreachable!()\n-                    };\n+                    let for_span = get_span_of_entire_for_loop(expr);\n \n                     span_lint_and_sugg(\n                         cx,\n@@ -2126,26 +2307,42 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n     }\n }\n \n-// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n-// incremented exactly once in the loop body, and initialized to zero\n-// at the start of the loop.\n #[derive(Debug, PartialEq)]\n-enum VarState {\n+enum IncrementVisitorVarState {\n     Initial,  // Not examined yet\n     IncrOnce, // Incremented exactly once, may be a loop counter\n-    Declared, // Declared but not (yet) initialized to zero\n-    Warn,\n     DontWarn,\n }\n \n /// Scan a for loop for variables that are incremented exactly once and not used after that.\n struct IncrementVisitor<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,          // context reference\n-    states: FxHashMap<HirId, VarState>, // incremented variables\n-    depth: u32,                         // depth of conditional expressions\n+    cx: &'a LateContext<'tcx>,                          // context reference\n+    states: FxHashMap<HirId, IncrementVisitorVarState>, // incremented variables\n+    depth: u32,                                         // depth of conditional expressions\n     done: bool,\n }\n \n+impl<'a, 'tcx> IncrementVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>) -> Self {\n+        Self {\n+            cx,\n+            states: FxHashMap::default(),\n+            depth: 0,\n+            done: false,\n+        }\n+    }\n+\n+    fn into_results(self) -> impl Iterator<Item = HirId> {\n+        self.states.into_iter().filter_map(|(id, state)| {\n+            if state == IncrementVisitorVarState::IncrOnce {\n+                Some(id)\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -2157,85 +2354,118 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n         // If node is a variable\n         if let Some(def_id) = var_def_id(self.cx, expr) {\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n-                let state = self.states.entry(def_id).or_insert(VarState::Initial);\n-                if *state == VarState::IncrOnce {\n-                    *state = VarState::DontWarn;\n+                let state = self.states.entry(def_id).or_insert(IncrementVisitorVarState::Initial);\n+                if *state == IncrementVisitorVarState::IncrOnce {\n+                    *state = IncrementVisitorVarState::DontWarn;\n                     return;\n                 }\n \n                 match parent.kind {\n                     ExprKind::AssignOp(op, ref lhs, ref rhs) => {\n                         if lhs.hir_id == expr.hir_id {\n-                            if op.node == BinOpKind::Add && is_integer_const(self.cx, rhs, 1) {\n-                                *state = match *state {\n-                                    VarState::Initial if self.depth == 0 => VarState::IncrOnce,\n-                                    _ => VarState::DontWarn,\n-                                };\n+                            *state = if op.node == BinOpKind::Add\n+                                && is_integer_const(self.cx, rhs, 1)\n+                                && *state == IncrementVisitorVarState::Initial\n+                                && self.depth == 0\n+                            {\n+                                IncrementVisitorVarState::IncrOnce\n                             } else {\n-                                // Assigned some other value\n-                                *state = VarState::DontWarn;\n-                            }\n+                                // Assigned some other value or assigned multiple times\n+                                IncrementVisitorVarState::DontWarn\n+                            };\n                         }\n                     },\n-                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => *state = VarState::DontWarn,\n+                    ExprKind::Assign(ref lhs, _, _) if lhs.hir_id == expr.hir_id => {\n+                        *state = IncrementVisitorVarState::DontWarn\n+                    },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        *state = VarState::DontWarn\n+                        *state = IncrementVisitorVarState::DontWarn\n                     },\n                     _ => (),\n                 }\n             }\n+\n+            walk_expr(self, expr);\n         } else if is_loop(expr) || is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n-            return;\n         } else if let ExprKind::Continue(_) = expr.kind {\n             self.done = true;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n     }\n }\n \n-/// Checks whether a variable is initialized to zero at the start of a loop.\n+enum InitializeVisitorState<'hir> {\n+    Initial,          // Not examined yet\n+    Declared(Symbol), // Declared but not (yet) initialized\n+    Initialized {\n+        name: Symbol,\n+        initializer: &'hir Expr<'hir>,\n+    },\n+    DontWarn,\n+}\n+\n+/// Checks whether a variable is initialized at the start of a loop and not modified\n+/// and used after the loop.\n struct InitializeVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,  // context reference\n     end_expr: &'tcx Expr<'tcx>, // the for loop. Stop scanning here.\n     var_id: HirId,\n-    state: VarState,\n-    name: Option<Symbol>,\n+    state: InitializeVisitorState<'tcx>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n \n+impl<'a, 'tcx> InitializeVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'tcx>, end_expr: &'tcx Expr<'tcx>, var_id: HirId) -> Self {\n+        Self {\n+            cx,\n+            end_expr,\n+            var_id,\n+            state: InitializeVisitorState::Initial,\n+            depth: 0,\n+            past_loop: false,\n+        }\n+    }\n+\n+    fn get_result(&self) -> Option<(Symbol, &'tcx Expr<'tcx>)> {\n+        if let InitializeVisitorState::Initialized { name, initializer } = self.state {\n+            Some((name, initializer))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_stmt(&mut self, stmt: &'tcx Stmt<'_>) {\n         // Look for declarations of the variable\n-        if let StmtKind::Local(ref local) = stmt.kind {\n-            if local.pat.hir_id == self.var_id {\n-                if let PatKind::Binding(.., ident, _) = local.pat.kind {\n-                    self.name = Some(ident.name);\n-\n-                    self.state = local.init.as_ref().map_or(VarState::Declared, |init| {\n-                        if is_integer_const(&self.cx, init, 0) {\n-                            VarState::Warn\n-                        } else {\n-                            VarState::Declared\n-                        }\n-                    })\n-                }\n+        if_chain! {\n+            if let StmtKind::Local(ref local) = stmt.kind;\n+            if local.pat.hir_id == self.var_id;\n+            if let PatKind::Binding(.., ident, _) = local.pat.kind;\n+            then {\n+                self.state = local.init.map_or(InitializeVisitorState::Declared(ident.name), |init| {\n+                    InitializeVisitorState::Initialized {\n+                        initializer: init,\n+                        name: ident.name,\n+                    }\n+                })\n             }\n         }\n         walk_stmt(self, stmt);\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if self.state == VarState::DontWarn {\n+        if matches!(self.state, InitializeVisitorState::DontWarn) {\n             return;\n         }\n         if expr.hir_id == self.end_expr.hir_id {\n@@ -2244,45 +2474,51 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n         }\n         // No need to visit expressions before the variable is\n         // declared\n-        if self.state == VarState::IncrOnce {\n+        if matches!(self.state, InitializeVisitorState::Initial) {\n             return;\n         }\n \n         // If node is the desired variable, see how it's used\n         if var_def_id(self.cx, expr) == Some(self.var_id) {\n+            if self.past_loop {\n+                self.state = InitializeVisitorState::DontWarn;\n+                return;\n+            }\n+\n             if let Some(parent) = get_parent_expr(self.cx, expr) {\n                 match parent.kind {\n                     ExprKind::AssignOp(_, ref lhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = VarState::DontWarn;\n+                        self.state = InitializeVisitorState::DontWarn;\n                     },\n                     ExprKind::Assign(ref lhs, ref rhs, _) if lhs.hir_id == expr.hir_id => {\n-                        self.state = if is_integer_const(&self.cx, rhs, 0) && self.depth == 0 {\n-                            VarState::Warn\n-                        } else {\n-                            VarState::DontWarn\n+                        self.state = if_chain! {\n+                            if self.depth == 0;\n+                            if let InitializeVisitorState::Declared(name)\n+                                | InitializeVisitorState::Initialized { name, ..} = self.state;\n+                            then {\n+                                InitializeVisitorState::Initialized { initializer: rhs, name }\n+                            } else {\n+                                InitializeVisitorState::DontWarn\n+                            }\n                         }\n                     },\n                     ExprKind::AddrOf(BorrowKind::Ref, mutability, _) if mutability == Mutability::Mut => {\n-                        self.state = VarState::DontWarn\n+                        self.state = InitializeVisitorState::DontWarn\n                     },\n                     _ => (),\n                 }\n             }\n \n-            if self.past_loop {\n-                self.state = VarState::DontWarn;\n-                return;\n-            }\n+            walk_expr(self, expr);\n         } else if !self.past_loop && is_loop(expr) {\n-            self.state = VarState::DontWarn;\n-            return;\n+            self.state = InitializeVisitorState::DontWarn;\n         } else if is_conditional(expr) {\n             self.depth += 1;\n             walk_expr(self, expr);\n             self.depth -= 1;\n-            return;\n+        } else {\n+            walk_expr(self, expr);\n         }\n-        walk_expr(self, expr);\n     }\n \n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {"}, {"sha": "a9d26d48b1278db3861c164dcf581f32190bad4c", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -708,7 +708,7 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n }\n \n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n-pub fn get_parent_expr<'c>(cx: &'c LateContext<'_>, e: &Expr<'_>) -> Option<&'c Expr<'c>> {\n+pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     let map = &cx.tcx.hir();\n     let hir_id = e.hir_id;\n     let parent_id = map.get_parent_node(hir_id);"}, {"sha": "0b2cb667bf4130edeafc5c67cea36e96799091b5", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 52, "deletions": 7, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -13,8 +13,10 @@ use rustc_span::{BytePos, Pos};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n+use std::ops::{Add, Neg, Not, Sub};\n \n /// A helper type to build suggestion correctly handling parenthesis.\n+#[derive(Clone, PartialEq)]\n pub enum Sugg<'a> {\n     /// An expression that never needs parenthesis such as `1337` or `[0; 42]`.\n     NonParen(Cow<'a, str>),\n@@ -25,8 +27,12 @@ pub enum Sugg<'a> {\n     BinOp(AssocOp, Cow<'a, str>),\n }\n \n+/// Literal constant `0`, for convenience.\n+pub const ZERO: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"0\"));\n /// Literal constant `1`, for convenience.\n pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n+/// a constant represents an empty string, for convenience.\n+pub const EMPTY: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"\"));\n \n impl Display for Sugg<'_> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {\n@@ -267,21 +273,60 @@ impl<'a> Sugg<'a> {\n     }\n }\n \n-impl<'a, 'b> std::ops::Add<Sugg<'b>> for Sugg<'a> {\n+// Copied from the rust standart library, and then edited\n+macro_rules! forward_binop_impls_to_ref {\n+    (impl $imp:ident, $method:ident for $t:ty, type Output = $o:ty) => {\n+        impl $imp<$t> for &$t {\n+            type Output = $o;\n+\n+            fn $method(self, other: $t) -> $o {\n+                $imp::$method(self, &other)\n+            }\n+        }\n+\n+        impl $imp<&$t> for $t {\n+            type Output = $o;\n+\n+            fn $method(self, other: &$t) -> $o {\n+                $imp::$method(&self, other)\n+            }\n+        }\n+\n+        impl $imp for $t {\n+            type Output = $o;\n+\n+            fn $method(self, other: $t) -> $o {\n+                $imp::$method(&self, &other)\n+            }\n+        }\n+    };\n+}\n+\n+impl Add for &Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn add(self, rhs: Sugg<'b>) -> Sugg<'static> {\n-        make_binop(ast::BinOpKind::Add, &self, &rhs)\n+    fn add(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Add, self, rhs)\n     }\n }\n \n-impl<'a, 'b> std::ops::Sub<Sugg<'b>> for Sugg<'a> {\n+impl Sub for &Sugg<'_> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: &Sugg<'_>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, self, rhs)\n+    }\n+}\n+\n+forward_binop_impls_to_ref!(impl Add, add for Sugg<'_>, type Output = Sugg<'static>);\n+forward_binop_impls_to_ref!(impl Sub, sub for Sugg<'_>, type Output = Sugg<'static>);\n+\n+impl Neg for Sugg<'_> {\n     type Output = Sugg<'static>;\n-    fn sub(self, rhs: Sugg<'b>) -> Sugg<'static> {\n-        make_binop(ast::BinOpKind::Sub, &self, &rhs)\n+    fn neg(self) -> Sugg<'static> {\n+        make_unop(\"-\", self)\n     }\n }\n \n-impl<'a> std::ops::Not for Sugg<'a> {\n+impl Not for Sugg<'_> {\n     type Output = Sugg<'static>;\n     fn not(self) -> Sugg<'static> {\n         make_unop(\"!\", self)"}, {"sha": "bad84a589008180df702444d2e57b4a9042b9d82", "filename": "tests/ui/manual_memcpy.stderr", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480/tests%2Fui%2Fmanual_memcpy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480/tests%2Fui%2Fmanual_memcpy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy.stderr?ref=2bdadd8e7dc54651df06e0adff1c1b1e7dcf6480", "patch": "@@ -1,88 +0,0 @@\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:7:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n-   |\n-   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:12:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:17:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:22:14\n-   |\n-LL |     for i in 11..src.len() {\n-   |              ^^^^^^^^^^^^^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:27:14\n-   |\n-LL |     for i in 0..dst.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:40:14\n-   |\n-LL |     for i in 10..256 {\n-   |              ^^^^^^^\n-   |\n-help: try replacing the loop by\n-   |\n-LL |     for i in dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)])\n-LL |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256]) {\n-   |\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:52:14\n-   |\n-LL |     for i in 10..LOOP_OFFSET {\n-   |              ^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:65:14\n-   |\n-LL |     for i in 0..src_vec.len() {\n-   |              ^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:94:14\n-   |\n-LL |     for i in from..from + src.len() {\n-   |              ^^^^^^^^^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + src.len()].clone_from_slice(&src[..(from + src.len() - from)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:98:14\n-   |\n-LL |     for i in from..from + 3 {\n-   |              ^^^^^^^^^^^^^^ help: try replacing the loop by: `dst[from..from + 3].clone_from_slice(&src[..(from + 3 - from)])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:103:14\n-   |\n-LL |     for i in 0..5 {\n-   |              ^^^^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:108:14\n-   |\n-LL |     for i in 0..0 {\n-   |              ^^^^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0])`\n-\n-error: it looks like you're manually copying between slices\n-  --> $DIR/manual_memcpy.rs:120:14\n-   |\n-LL |     for i in 0..src.len() {\n-   |              ^^^^^^^^^^^^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..])`\n-\n-error: aborting due to 13 previous errors\n-"}, {"sha": "ba388a05a2859e7a05dab97158ce872be225266c", "filename": "tests/ui/manual_memcpy/with_loop_counters.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.rs?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -0,0 +1,88 @@\n+#![warn(clippy::needless_range_loop, clippy::manual_memcpy)]\n+\n+pub fn manual_copy_with_counters(src: &[i32], dst: &mut [i32], dst2: &mut [i32]) {\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[count] = src[i];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 0..src.len() {\n+        dst[count] = src[i];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 0..src.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 0;\n+    for i in 3..(3 + src.len()) {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    for i in 5..src.len() {\n+        dst[i] = src[count - 2];\n+        count += 1;\n+    }\n+\n+    let mut count = 2;\n+    for i in 0..dst.len() {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 5;\n+    for i in 3..10 {\n+        dst[i] = src[count];\n+        count += 1;\n+    }\n+\n+    let mut count = 3;\n+    let mut count2 = 30;\n+    for i in 0..src.len() {\n+        dst[count] = src[i];\n+        dst2[count2] = src[i];\n+        count += 1;\n+        count2 += 1;\n+    }\n+\n+    // make sure parentheses are added properly to bitwise operators, which have lower precedence than\n+    // arithmetric ones\n+    let mut count = 0 << 1;\n+    for i in 0..1 << 1 {\n+        dst[count] = src[i + 2];\n+        count += 1;\n+    }\n+\n+    // make sure incrementing expressions without semicolons at the end of loops are handled correctly.\n+    let mut count = 0;\n+    for i in 3..src.len() {\n+        dst[i] = src[count];\n+        count += 1\n+    }\n+\n+    // make sure ones where the increment is not at the end of the loop.\n+    // As a possible enhancement, one could adjust the offset in the suggestion according to\n+    // the position. For example, if the increment is at the top of the loop;\n+    // treating the loop counter as if it were initialized 1 greater than the original value.\n+    let mut count = 0;\n+    #[allow(clippy::needless_range_loop)]\n+    for i in 0..src.len() {\n+        count += 1;\n+        dst[i] = src[count];\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2547b19f5d1d43978225d22eb15b03b917776f78", "filename": "tests/ui/manual_memcpy/with_loop_counters.stderr", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwith_loop_counters.stderr?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -0,0 +1,111 @@\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:5:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+   |\n+   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:11:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..(src.len() - 3)].clone_from_slice(&src[3..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:17:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..(src.len() + 3)].clone_from_slice(&src[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:23:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[3..(src.len() + 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:29:5\n+   |\n+LL | /     for i in 3..(3 + src.len()) {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..((3 + src.len()))].clone_from_slice(&src[..((3 + src.len()) - 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:35:5\n+   |\n+LL | /     for i in 5..src.len() {\n+LL | |         dst[i] = src[count - 2];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[5..src.len()].clone_from_slice(&src[(3 - 2)..((src.len() - 2) + 3 - 5)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:41:5\n+   |\n+LL | /     for i in 0..dst.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[2..(dst.len() + 2)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:47:5\n+   |\n+LL | /     for i in 3..10 {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..10].clone_from_slice(&src[5..(10 + 5 - 3)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:54:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[count] = src[i];\n+LL | |         dst2[count2] = src[i];\n+LL | |         count += 1;\n+LL | |         count2 += 1;\n+LL | |     }\n+   | |_____^\n+   |\n+help: try replacing the loop by\n+   |\n+LL |     dst[3..(src.len() + 3)].clone_from_slice(&src[..]);\n+LL |     dst2[30..(src.len() + 30)].clone_from_slice(&src[..]);\n+   |\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:64:5\n+   |\n+LL | /     for i in 0..1 << 1 {\n+LL | |         dst[count] = src[i + 2];\n+LL | |         count += 1;\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[(0 << 1)..((1 << 1) + (0 << 1))].clone_from_slice(&src[2..((1 << 1) + 2)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/with_loop_counters.rs:71:5\n+   |\n+LL | /     for i in 3..src.len() {\n+LL | |         dst[i] = src[count];\n+LL | |         count += 1\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[3..src.len()].clone_from_slice(&src[..(src.len() - 3)]);`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "0083f94798fe4b2c650998d439f05cda4e7b0d0c", "filename": "tests/ui/manual_memcpy/without_loop_counters.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.rs?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "previous_filename": "tests/ui/manual_memcpy.rs"}, {"sha": "54b966f6e5419d375623fee09c6c58c66273ca7e", "filename": "tests/ui/manual_memcpy/without_loop_counters.stderr", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/dbc02854fce1f783599e3f98b6ee6b9a136d9e96/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_memcpy%2Fwithout_loop_counters.stderr?ref=dbc02854fce1f783599e3f98b6ee6b9a136d9e96", "patch": "@@ -0,0 +1,115 @@\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:7:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..]);`\n+   |\n+   = note: `-D clippy::manual-memcpy` implied by `-D warnings`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:12:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i + 10] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[10..(src.len() + 10)].clone_from_slice(&src[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:17:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i + 10];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[10..(src.len() + 10)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:22:5\n+   |\n+LL | /     for i in 11..src.len() {\n+LL | |         dst[i] = src[i - 10];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[11..src.len()].clone_from_slice(&src[(11 - 10)..(src.len() - 10)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:27:5\n+   |\n+LL | /     for i in 0..dst.len() {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst.clone_from_slice(&src[..dst.len()]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:40:5\n+   |\n+LL | /     for i in 10..256 {\n+LL | |         dst[i] = src[i - 5];\n+LL | |         dst2[i + 500] = src[i]\n+LL | |     }\n+   | |_____^\n+   |\n+help: try replacing the loop by\n+   |\n+LL |     dst[10..256].clone_from_slice(&src[(10 - 5)..(256 - 5)]);\n+LL |     dst2[(10 + 500)..(256 + 500)].clone_from_slice(&src[10..256]);\n+   |\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:52:5\n+   |\n+LL | /     for i in 10..LOOP_OFFSET {\n+LL | |         dst[i + LOOP_OFFSET] = src[i - some_var];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[(10 + LOOP_OFFSET)..(LOOP_OFFSET + LOOP_OFFSET)].clone_from_slice(&src[(10 - some_var)..(LOOP_OFFSET - some_var)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:65:5\n+   |\n+LL | /     for i in 0..src_vec.len() {\n+LL | |         dst_vec[i] = src_vec[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst_vec[..src_vec.len()].clone_from_slice(&src_vec[..]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:94:5\n+   |\n+LL | /     for i in from..from + src.len() {\n+LL | |         dst[i] = src[i - from];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + src.len())].clone_from_slice(&src[..(from + src.len() - from)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:98:5\n+   |\n+LL | /     for i in from..from + 3 {\n+LL | |         dst[i] = src[i - from];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[from..(from + 3)].clone_from_slice(&src[..(from + 3 - from)]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:103:5\n+   |\n+LL | /     for i in 0..5 {\n+LL | |         dst[i - 0] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..5].clone_from_slice(&src[..5]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:108:5\n+   |\n+LL | /     for i in 0..0 {\n+LL | |         dst[i] = src[i];\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..0].clone_from_slice(&src[..0]);`\n+\n+error: it looks like you're manually copying between slices\n+  --> $DIR/without_loop_counters.rs:120:5\n+   |\n+LL | /     for i in 0..src.len() {\n+LL | |         dst[i] = src[i].clone();\n+LL | |     }\n+   | |_____^ help: try replacing the loop by: `dst[..src.len()].clone_from_slice(&src[..]);`\n+\n+error: aborting due to 13 previous errors\n+"}]}