{"sha": "e1580f6d09f0cd990c3eed55b1d6181af3258791", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxNTgwZjZkMDlmMGNkOTkwYzNlZWQ1NWIxZDYxODFhZjMyNTg3OTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-29T16:21:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-29T16:21:38Z"}, "message": "auto merge of #11868 : bytbox/rust/remove-do, r=alexcrichton\n\nFixes #10815.", "tree": {"sha": "034b8287f1f017f7956d004be95184f53140bd5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/034b8287f1f017f7956d004be95184f53140bd5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1580f6d09f0cd990c3eed55b1d6181af3258791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1580f6d09f0cd990c3eed55b1d6181af3258791", "html_url": "https://github.com/rust-lang/rust/commit/e1580f6d09f0cd990c3eed55b1d6181af3258791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1580f6d09f0cd990c3eed55b1d6181af3258791/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87004db1137c9126ecc8834b1c881c2ef09ee8ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/87004db1137c9126ecc8834b1c881c2ef09ee8ef", "html_url": "https://github.com/rust-lang/rust/commit/87004db1137c9126ecc8834b1c881c2ef09ee8ef"}, {"sha": "a6867e259b98904d0144904b4ffbba61f7c8f6f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6867e259b98904d0144904b4ffbba61f7c8f6f9", "html_url": "https://github.com/rust-lang/rust/commit/a6867e259b98904d0144904b4ffbba61f7c8f6f9"}], "stats": {"total": 2241, "additions": 843, "deletions": 1398}, "files": [{"sha": "d97de7799024cbacb5e6ba8811e87bc9003f1349", "filename": "doc/guide-conditions.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-conditions.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-conditions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-conditions.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -261,15 +261,15 @@ use std::task;\n fn main() {\n \n     // Isolate failure within a subtask.\n-    let result = do task::try {\n+    let result = task::try(proc() {\n \n         // The protected logic.\n         let pairs = read_int_pairs();\n         for &(a,b) in pairs.iter() {\n             println!(\"{:4.4d}, {:4.4d}\", a, b);\n         }\n \n-    };\n+    });\n     if result.is_err() {\n             println!(\"parsing failed\");\n     }"}, {"sha": "19696b42a3747e7ff156c52611a355ae9263fe21", "filename": "doc/guide-pointers.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-pointers.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -221,9 +221,9 @@ struct Point {\n \n fn main() {\n     let a = Point { x: 10, y: 20 };\n-    do spawn {\n+    spawn(proc() {\n         println!(\"{}\", a.x);\n-    }\n+    });\n }\n ~~~\n \n@@ -238,9 +238,9 @@ struct Point {\n \n fn main() {\n     let a = ~Point { x: 10, y: 20 };\n-    do spawn {\n+    spawn(proc() {\n         println!(\"{}\", a.x);\n-    }\n+    });\n }\n ~~~\n "}, {"sha": "b6a54b042e96acf77887d2a8305ae22929730467", "filename": "doc/guide-runtime.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-runtime.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-runtime.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-runtime.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -236,9 +236,9 @@ extern mod green;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    do green::start(argc, argv) {\n+    green::start(argc, argv, proc() {\n         main();\n-    }\n+    })\n }\n \n fn main() {}"}, {"sha": "c3bdbe3a3ee8992126abee557864b10b84052caa", "filename": "doc/guide-tasks.md", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fguide-tasks.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -77,11 +77,6 @@ spawn(print_message);\n \n // Print something more profound in a different task using a lambda expression\n spawn(proc() println!(\"I am also running in a different task!\") );\n-\n-// The canonical way to spawn is using `do` notation\n-do spawn {\n-    println!(\"I too am running in a different task!\");\n-}\n ~~~~\n \n In Rust, there is nothing special about creating tasks: a task is not a\n@@ -103,10 +98,10 @@ an environment that it carries across tasks.\n // Generate some state locally\n let child_task_number = generate_task_number();\n \n-do spawn {\n+spawn(proc() {\n     // Capture it in the remote task\n     println!(\"I am child number {}\", child_task_number);\n-}\n+});\n ~~~\n \n ## Communication\n@@ -132,10 +127,10 @@ concurrently:\n \n let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n \n-do spawn || {\n+spawn(proc() {\n     let result = some_expensive_computation();\n     chan.send(result);\n-}\n+});\n \n some_other_expensive_computation();\n let result = port.recv();\n@@ -160,10 +155,10 @@ spawns the child task.\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n # let (port, chan) = Chan::new();\n-do spawn || {\n+spawn(proc() {\n     let result = some_expensive_computation();\n     chan.send(result);\n-}\n+});\n ~~~~\n \n Notice that the creation of the task closure transfers `chan` to the child\n@@ -195,15 +190,15 @@ of tasks? The following program is ill-typed:\n # fn some_expensive_computation() -> int { 42 }\n let (port, chan) = Chan::new();\n \n-do spawn {\n+spawn(proc() {\n     chan.send(some_expensive_computation());\n-}\n+});\n \n // ERROR! The previous spawn statement already owns the channel,\n // so the compiler will not allow it to be captured again\n-do spawn {\n+spawn(proc() {\n     chan.send(some_expensive_computation());\n-}\n+});\n ~~~\n \n Instead we can use a `SharedChan`, a type that allows a single\n@@ -217,9 +212,9 @@ let (port, chan) = SharedChan::new();\n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n     let child_chan = chan.clone();\n-    do spawn {\n+    spawn(proc() {\n         child_chan.send(some_expensive_computation(init_val));\n-    }\n+    });\n }\n \n let result = port.recv() + port.recv() + port.recv();\n@@ -247,9 +242,9 @@ might look like the example below.\n // Create a vector of ports, one for each child task\n let ports = vec::from_fn(3, |init_val| {\n     let (port, chan) = Chan::new();\n-    do spawn {\n+    spawn(proc() {\n         chan.send(some_expensive_computation(init_val));\n-    }\n+    });\n     port\n });\n \n@@ -296,7 +291,7 @@ fn partial_sum(start: uint) -> f64 {\n }\n \n fn main() {\n-    let mut futures = vec::from_fn(1000, |ind| do extra::future::Future::spawn { partial_sum(ind) });\n+    let mut futures = vec::from_fn(1000, |ind| extra::future::Future::spawn( proc() { partial_sum(ind) }));\n \n     let mut final_res = 0f64;\n     for ft in futures.mut_iter()  {\n@@ -339,11 +334,11 @@ fn main() {\n         let (port, chan)  = Chan::new();\n         chan.send(numbers_arc.clone());\n \n-        do spawn {\n+        spawn(proc() {\n             let local_arc : Arc<~[f64]> = port.recv();\n             let task_numbers = local_arc.get();\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n-        }\n+        });\n     }\n }\n ~~~\n@@ -417,13 +412,13 @@ termination with an error).\n # use std::task;\n # fn some_condition() -> bool { false }\n # fn calculate_result() -> int { 0 }\n-let result: Result<int, ()> = do task::try {\n+let result: Result<int, ()> = task::try(proc() {\n     if some_condition() {\n         calculate_result()\n     } else {\n         fail!(\"oops!\");\n     }\n-};\n+});\n assert!(result.is_err());\n ~~~\n \n@@ -502,9 +497,9 @@ Here is the code for the parent task:\n \n let (from_child, to_child) = DuplexStream::new();\n \n-do spawn {\n+spawn(proc() {\n     stringifier(&to_child);\n-};\n+});\n \n from_child.send(22);\n assert!(from_child.recv() == ~\"22\");"}, {"sha": "1dd312febb7188030e7437326b1e68334d4039ba", "filename": "doc/rust.md", "status": "modified", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -2751,52 +2751,6 @@ but must enclose it.\n \n A `loop` expression is only permitted in the body of a loop.\n \n-### Do expressions\n-\n-~~~~ {.ebnf .gram}\n-do_expr : \"do\" expr [ '|' ident_list '|' ] ? '{' block '}' ;\n-~~~~\n-\n-A _do expression_ provides a more-familiar block syntax\n-for invoking a function and passing it a newly-created a procedure.\n-\n-The optional `ident_list` and `block` provided in a `do` expression are parsed\n-as though they constitute a procedure expression;\n-if the `ident_list` is missing, an empty `ident_list` is implied.\n-\n-The procedure expression is then provided as a _trailing argument_\n-to the outermost [call](#call-expressions) or\n-[method call](#method-call-expressions) expression\n-in the `expr` following `do`.\n-If the `expr` is a [path expression](#path-expressions), it is parsed as though it is a call expression.\n-If the `expr` is a [field expression](#field-expressions), it is parsed as though it is a method call expression.\n-\n-In this example, both calls to `f` are equivalent:\n-\n-~~~~\n-# fn f(f: proc(int)) { }\n-# fn g(i: int) { }\n-\n-f(proc(j) { g(j) });\n-\n-do f |j| {\n-    g(j);\n-}\n-~~~~\n-\n-In this example, both calls to the (binary) function `k` are equivalent:\n-\n-~~~~\n-# fn k(x:int, f: proc(int)) { }\n-# fn l(i: int) { }\n-\n-k(3, proc(j) { l(j) });\n-\n-do k(3) |j| {\n-   l(j);\n-}\n-~~~~\n-\n ### For expressions\n \n ~~~~ {.ebnf .gram}"}, {"sha": "9304badb1c6e68402300d39657e04a0b59a5bded", "filename": "doc/tutorial.md", "status": "modified", "additions": 9, "deletions": 37, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -1796,48 +1796,20 @@ call_it(proc(n) {\n });\n ~~~~\n \n-This is such a useful pattern that Rust has a special form of function\n-call for these functions.\n-\n-~~~~\n-# fn call_it(op: proc(v: int)) { }\n-do call_it() |n| {\n-    println!(\"{}\", n);\n-}\n-~~~~\n-\n-The call is prefixed with the keyword `do` and, instead of writing the\n-final procedure inside the argument list, it appears outside of the\n-parentheses, where it looks more like a typical block of\n-code.\n-\n-`do` is a convenient way to create tasks with the `task::spawn`\n-function.  `spawn` has the signature `spawn(fn: proc())`. In other\n-words, it is a function that takes an owned closure that takes no\n-arguments.\n-\n-~~~~\n-use std::task::spawn;\n-\n-do spawn() || {\n-    debug!(\"I'm a task, whatever\");\n-}\n-~~~~\n-\n-Look at all those bars and parentheses -- that's two empty argument\n-lists back to back. Since that is so unsightly, empty argument lists\n-may be omitted from `do` expressions.\n+A practical example of this pattern is found when using the `spawn` function,\n+which starts a new task.\n \n ~~~~\n use std::task::spawn;\n-\n-do spawn {\n-   debug!(\"Kablam!\");\n-}\n+spawn(proc() {\n+    debug!(\"I'm a new task\")\n+});\n ~~~~\n \n-If you want to see the output of `debug!` statements, you will need to turn on `debug!` logging.\n-To enable `debug!` logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named `foo.rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`).\n+If you want to see the output of `debug!` statements, you will need to turn on\n+`debug!` logging.  To enable `debug!` logging, set the RUST_LOG environment\n+variable to the name of your crate, which, for a file named `foo.rs`, will be\n+`foo` (e.g., with bash, `export RUST_LOG=foo`).\n \n # Methods\n "}, {"sha": "c57d2492d459c9e8edaab12349e655818e0e8238", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -317,10 +317,10 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(1000);\n-                let result = do task::try {\n+                let result = task::try(proc() {\n                     tcp::TcpStream::connect(\n                         SocketAddr { ip: Ipv4Addr(127, 0, 0, 1), port: 5039 });\n-                };\n+                });\n                 if result.is_err() {\n                     continue;\n                 }"}, {"sha": "bf47e3bdf89ead32ff8547f7d549e3cac6576f13", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -28,12 +28,12 @@\n  *       let (port, chan) = Chan::new();\n  *       chan.send(shared_numbers.clone());\n  *\n- *       do spawn {\n+ *       spawn(proc() {\n  *           let shared_numbers = port.recv();\n  *           let local_numbers = shared_numbers.get();\n  *\n  *           // Work with the local numbers\n- *       }\n+ *       });\n  *   }\n  * ```\n  */\n@@ -567,12 +567,12 @@ mod tests {\n \n         let (p, c) = Chan::new();\n \n-        do task::spawn {\n+        task::spawn(proc() {\n             let arc_v: Arc<~[int]> = p.recv();\n \n             let v = arc_v.get().clone();\n             assert_eq!(v[3], 4);\n-        };\n+        });\n \n         c.send(arc_v.clone());\n \n@@ -587,14 +587,14 @@ mod tests {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n         let (p,c) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             // wait until parent gets in\n             p.recv();\n             arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n             })\n-        }\n+        });\n \n         arc.access_cond(|state, cond| {\n             c.send(());\n@@ -611,14 +611,14 @@ mod tests {\n         let arc2 = ~arc.clone();\n         let (p, c) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let _ = p.recv();\n             arc2.access_cond(|one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n                 assert_eq!(*one, 0);\n             })\n-        }\n+        });\n \n         arc.access_cond(|one, cond| {\n             c.send(());\n@@ -632,11 +632,11 @@ mod tests {\n     fn test_mutex_arc_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        do task::try || {\n+        task::try(proc() {\n             arc2.access(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.access(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -649,13 +649,13 @@ mod tests {\n             // to underlaying data.\n             let arc = ~MutexArc::new(1);\n             let arc2 = ~MutexArc::new(*arc);\n-            do task::spawn || {\n+            task::spawn(proc() {\n                 (*arc2).unsafe_access(|mutex| {\n                     (*mutex).access(|one| {\n                         assert!(*one == 1);\n                     })\n                 })\n-            };\n+            });\n         }\n     }\n \n@@ -682,11 +682,11 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.read(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -696,11 +696,11 @@ mod tests {\n     fn test_rw_arc_poison_ww() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -709,13 +709,13 @@ mod tests {\n     fn test_rw_arc_poison_dw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write_downgrade(|mut write_mode| {\n                 write_mode.write(|one| {\n                     assert_eq!(*one, 2);\n                 })\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -724,11 +724,11 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.read(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -737,11 +737,11 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.read(|one| {\n                 assert_eq!(*one, 2);\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -750,14 +750,14 @@ mod tests {\n     fn test_rw_arc_no_poison_dr() {\n         let arc = RWArc::new(1);\n         let arc2 = arc.clone();\n-        do task::try {\n+        task::try(proc() {\n             arc2.write_downgrade(|write_mode| {\n                 let read_mode = arc2.downgrade(write_mode);\n                 read_mode.read(|one| {\n                     assert_eq!(*one, 2);\n                 })\n             })\n-        };\n+        });\n         arc.write(|one| {\n             assert_eq!(*one, 1);\n         })\n@@ -768,7 +768,7 @@ mod tests {\n         let arc2 = arc.clone();\n         let (p, c) = Chan::new();\n \n-        do task::spawn {\n+        task::spawn(proc() {\n             arc2.write(|num| {\n                 10.times(|| {\n                     let tmp = *num;\n@@ -778,19 +778,19 @@ mod tests {\n                 });\n                 c.send(());\n             })\n-        }\n+        });\n \n         // Readers try to catch the writer in the act\n         let mut children = ~[];\n         5.times(|| {\n             let arc3 = arc.clone();\n             let mut builder = task::task();\n             children.push(builder.future_result());\n-            do builder.spawn {\n+            builder.spawn(proc() {\n                 arc3.read(|num| {\n                     assert!(*num >= 0);\n                 })\n-            }\n+            });\n         });\n \n         // Wait for children to pass their asserts\n@@ -840,19 +840,19 @@ mod tests {\n             let ((rp1, rc1), (rp2, rc2)) = (Chan::new(), Chan::new());\n             reader_convos.push((rc1, rp2));\n             let arcn = arc.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 rp1.recv(); // wait for downgrader to give go-ahead\n                 arcn.read(|state| {\n                     assert_eq!(*state, 31337);\n                     rc2.send(());\n                 })\n-            }\n+            });\n         });\n \n         // Writer task\n         let arc2 = arc.clone();\n         let ((wp1, wc1), (wp2, wc2)) = (Chan::new(), Chan::new());\n-        do task::spawn || {\n+        task::spawn(proc() {\n             wp1.recv();\n             arc2.write_cond(|state, cond| {\n                 assert_eq!(*state, 0);\n@@ -867,7 +867,7 @@ mod tests {\n                 *state = 42;\n             });\n             wc2.send(());\n-        }\n+        });\n \n         // Downgrader (us)\n         arc.write_downgrade(|mut write_mode| {\n@@ -912,7 +912,7 @@ mod tests {\n \n         // writer task\n         let xw = x.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             xw.write_cond(|state, c| {\n                 wc.send(()); // tell downgrader it's ok to go\n                 c.wait();\n@@ -921,7 +921,7 @@ mod tests {\n                 // trying to receive the \"reader cloud lock hand-off\".\n                 *state = false;\n             })\n-        }\n+        });\n \n         wp.recv(); // wait for writer to get in\n \n@@ -934,10 +934,10 @@ mod tests {\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n             let (rp, rc) = Chan::new();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 rc.send(());\n                 xr.read(|_state| { })\n-            }\n+            });\n             rp.recv(); // wait for reader task to exist\n \n             let read_mode = x.downgrade(write_mode);"}, {"sha": "69a1383e44da4b761e8fde107610d7efea2fa847", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -115,9 +115,9 @@ mod test {\n     pub fn basic_rendezvous_test() {\n         let (port, chan) = rendezvous();\n \n-        do spawn {\n+        spawn(proc() {\n             chan.send(\"abc\");\n-        }\n+        });\n \n         assert!(port.recv() == \"abc\");\n     }\n@@ -126,40 +126,40 @@ mod test {\n     fn recv_a_lot() {\n         // Rendezvous streams should be able to handle any number of messages being sent\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             10000.times(|| { chan.send(()) })\n-        }\n+        });\n         10000.times(|| { port.recv() })\n     }\n \n     #[test]\n     fn send_and_fail_and_try_recv() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             chan.duplex_stream.send(()); // Can't access this field outside this module\n             fail!()\n-        }\n+        });\n         port.recv()\n     }\n \n     #[test]\n     fn try_send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             port.duplex_stream.recv();\n             fail!()\n-        }\n+        });\n         chan.try_send(());\n     }\n \n     #[test]\n     #[should_fail]\n     fn send_and_recv_then_fail_before_ack() {\n         let (port, chan) = rendezvous();\n-        do spawn {\n+        spawn(proc() {\n             port.duplex_stream.recv();\n             fail!()\n-        }\n+        });\n         chan.send(());\n     }\n }"}, {"sha": "0706d4e5a687430c88190ab80155bb40e3e74763", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -971,10 +971,10 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from([1,2,3]);\n-        do spawn {\n+        spawn(proc() {\n             check_links(&n);\n             assert_eq!(~[&1,&2,&3], n.iter().collect::<~[&int]>());\n-        }\n+        });\n     }\n \n     #[test]"}, {"sha": "b9121290f33f4ba49abcf8d312192bf43d6a5e36", "filename": "src/libextra/future.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -18,7 +18,7 @@\n  * use extra::future::Future;\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n- * let mut delayed_fib = do Future::spawn { fib(5000) };\n+ * let mut delayed_fib = Future::spawn(proc() { fib(5000) });\n  * make_a_sandwich();\n  * println!(\"fib(5000) = {}\", delayed_fib.get())\n  * ```\n@@ -112,9 +112,9 @@ impl<A:Send> Future<A> {\n          * waiting for the result to be received on the port.\n          */\n \n-        do Future::from_fn {\n+        Future::from_fn(proc() {\n             port.recv()\n-        }\n+        })\n     }\n \n     pub fn spawn(blk: proc() -> A) -> Future<A> {\n@@ -127,9 +127,9 @@ impl<A:Send> Future<A> {\n \n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             chan.send(blk());\n-        }\n+        });\n \n         Future::from_port(port)\n     }\n@@ -195,11 +195,11 @@ mod test {\n     #[test]\n     fn test_sendable_future() {\n         let expected = \"schlorf\";\n-        let f = do Future::spawn { expected };\n-        do task::spawn {\n+        let f = Future::spawn(proc() { expected });\n+        task::spawn(proc() {\n             let mut f = f;\n             let actual = f.get();\n             assert_eq!(actual, expected);\n-        }\n+        });\n     }\n }"}, {"sha": "d8c1cb51a118190983ce562408541f8ac8429404", "filename": "src/libextra/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -2201,7 +2201,7 @@ mod tests {\n     }\n     fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n         use std::task;\n-        let res = do task::try {\n+        let res = task::try(proc() {\n             // either fails in `decode` (which is what we want), or\n             // returns Some(error_message)/None if the string was\n             // invalid or valid JSON.\n@@ -2212,7 +2212,7 @@ mod tests {\n                     None\n                 }\n             }\n-        };\n+        });\n         match res {\n             Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n                                            to_parse, parse_error),"}, {"sha": "3acaf8352564653a0e3481482c5afd471447a1fd", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 58, "deletions": 59, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -695,11 +695,11 @@ impl<'a> RWLockReadMode<'a> {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     do spawn {\n+///     spawn(proc() {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n-///     }\n+///     });\n /// });\n /// ```\n #[deriving(Clone)]\n@@ -778,11 +778,11 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Semaphore::new(1);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.access(|| {\n                 5.times(|| { task::deschedule(); })\n             })\n-        }\n+        });\n         s.access(|| {\n             5.times(|| { task::deschedule(); })\n         })\n@@ -793,10 +793,10 @@ mod tests {\n         let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.acquire();\n             c.send(());\n-        }\n+        });\n         5.times(|| { task::deschedule(); });\n         s.release();\n         let _ = p.recv();\n@@ -805,11 +805,11 @@ mod tests {\n         let (p, c) = Chan::new();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             5.times(|| { task::deschedule(); });\n             s2.release();\n             let _ = p.recv();\n-        }\n+        });\n         s.acquire();\n         c.send(());\n     }\n@@ -821,12 +821,12 @@ mod tests {\n         let s2 = s.clone();\n         let (p1,c1) = Chan::new();\n         let (p2,c2) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             s2.access(|| {\n                 let _ = p2.recv();\n                 c1.send(());\n             })\n-        }\n+        });\n         s.access(|| {\n             c2.send(());\n             let _ = p1.recv();\n@@ -842,11 +842,11 @@ mod tests {\n         let mut child_data = Some((s2, c));\n         s.access(|| {\n             let (s2, c) = child_data.take_unwrap();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 c.send(());\n                 s2.access(|| { });\n                 c.send(());\n-            }\n+            });\n             let _ = p.recv(); // wait for child to come alive\n             5.times(|| { task::deschedule(); }); // let the child contend\n         });\n@@ -865,13 +865,12 @@ mod tests {\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn {\n+            task::spawn(proc() {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &m2, 10);\n                 c.send(());\n-\n-            }\n+            });\n         }\n         {\n             access_shared(sharedstate, &m, 10);\n@@ -897,24 +896,24 @@ mod tests {\n         // Child wakes up parent\n         m.lock_cond(|cond| {\n             let m2 = m.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n                 })\n-            }\n+            });\n             cond.wait();\n         });\n         // Parent wakes up child\n         let (port,chan) = Chan::new();\n         let m3 = m.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             m3.lock_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n             })\n-        }\n+        });\n         let _ = port.recv(); // Wait until child gets in the mutex\n         m.lock_cond(|cond| {\n             let woken = cond.signal();\n@@ -931,13 +930,13 @@ mod tests {\n             let mi = m.clone();\n             let (port, chan) = Chan::new();\n             ports.push(port);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 mi.lock_cond(|cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n                 })\n-            }\n+            });\n         });\n \n         // wait until all children get in the mutex\n@@ -961,9 +960,9 @@ mod tests {\n     fn test_mutex_cond_no_waiter() {\n         let m = Mutex::new();\n         let m2 = m.clone();\n-        do task::try {\n+        task::try(proc() {\n             m.lock_cond(|_x| { })\n-        };\n+        });\n         m2.lock_cond(|cond| {\n             assert!(!cond.signal());\n         })\n@@ -974,11 +973,11 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             m2.lock(|| {\n                 fail!();\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         m.lock(|| { })\n@@ -991,18 +990,18 @@ mod tests {\n         let m = Mutex::new();\n         let m2 = m.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             let (p, c) = Chan::new();\n-            do task::spawn { // linked\n+            task::spawn(proc() { // linked\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n                 task::deschedule();\n                 fail!();\n-            }\n+            });\n             m2.lock_cond(|cond| {\n                 c.send(()); // tell sibling go ahead\n                 cond.wait(); // block forever\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         m.lock_cond(|cond| {\n@@ -1019,14 +1018,14 @@ mod tests {\n         let m2 = m.clone();\n         let (p, c) = Chan::new();\n \n-        let result: result::Result<(), ~Any> = do task::try {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             let mut sibling_convos = ~[];\n             2.times(|| {\n                 let (p, c) = Chan::new();\n                 sibling_convos.push(p);\n                 let mi = m2.clone();\n                 // spawn sibling task\n-                do task::spawn { // linked\n+                task::spawn(proc() { // linked\n                     mi.lock_cond(|cond| {\n                         c.send(()); // tell sibling to go ahead\n                         (|| {\n@@ -1037,15 +1036,15 @@ mod tests {\n                             error!(\"task unwinding and done sending\");\n                         })\n                     })\n-                }\n+                });\n             });\n             for p in sibling_convos.mut_iter() {\n                 let _ = p.recv(); // wait for sibling to get in the mutex\n             }\n             m2.lock(|| { });\n             c.send(sibling_convos); // let parent wait on all children\n             fail!();\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         let mut r = p.recv();\n@@ -1061,52 +1060,52 @@ mod tests {\n         let m = Mutex::new();\n         m.lock_cond(|cond| {\n             let m2 = m.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     cond.signal_on(0);\n                 })\n-            }\n+            });\n             cond.wait();\n         })\n     }\n     #[test]\n     #[ignore(reason = \"linked failure?\")]\n     fn test_mutex_different_conds() {\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(2);\n             let m2 = m.clone();\n             let (p, c) = Chan::new();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 m2.lock_cond(|cond| {\n                     c.send(());\n                     cond.wait_on(1);\n                 })\n-            }\n+            });\n             let _ = p.recv();\n             m.lock_cond(|cond| {\n                 if !cond.signal_on(0) {\n                     fail!(); // success; punt sibling awake.\n                 }\n             })\n-        };\n+        });\n         assert!(result.is_err());\n     }\n     #[test]\n     fn test_mutex_no_condvars() {\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.wait(); })\n-        };\n+        });\n         assert!(result.is_err());\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.signal(); })\n-        };\n+        });\n         assert!(result.is_err());\n-        let result = do task::try {\n+        let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n             m.lock_cond(|cond| { cond.broadcast(); })\n-        };\n+        });\n         assert!(result.is_err());\n     }\n     /************************************************************************\n@@ -1141,12 +1140,12 @@ mod tests {\n         let mut sharedstate = ~0;\n         {\n             let ptr: *int = &*sharedstate;\n-            do task::spawn {\n+            task::spawn(proc() {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &x2, mode1, 10);\n                 c.send(());\n-            }\n+            });\n         }\n         {\n             access_shared(sharedstate, x, mode2, 10);\n@@ -1189,7 +1188,7 @@ mod tests {\n         let x2 = x.clone();\n         let (p1, c1) = Chan::new();\n         let (p2, c2) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n             if !make_mode2_go_first {\n                 let _ = p2.recv(); // parent sends to us once it locks, or ...\n             }\n@@ -1200,7 +1199,7 @@ mod tests {\n                 let _ = p2.recv();\n                 c1.send(());\n             })\n-        }\n+        });\n         if make_mode2_go_first {\n             let _ = p1.recv(); // child sends to us once it locks, or ...\n         }\n@@ -1244,24 +1243,24 @@ mod tests {\n         // Child wakes up parent\n         x.write_cond(|cond| {\n             let x2 = x.clone();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 x2.write_cond(|cond| {\n                     let woken = cond.signal();\n                     assert!(woken);\n                 })\n-            }\n+            });\n             cond.wait();\n         });\n         // Parent wakes up child\n         let (port, chan) = Chan::new();\n         let x3 = x.clone();\n-        do task::spawn {\n+        task::spawn(proc() {\n             x3.write_cond(|cond| {\n                 chan.send(());\n                 cond.wait();\n                 chan.send(());\n             })\n-        }\n+        });\n         let _ = port.recv(); // Wait until child gets in the rwlock\n         x.read(|| { }); // Must be able to get in as a reader in the meantime\n         x.write_cond(|cond| { // Or as another writer\n@@ -1292,13 +1291,13 @@ mod tests {\n             let xi = x.clone();\n             let (port, chan) = Chan::new();\n             ports.push(port);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 lock_cond(&xi, dg1, |cond| {\n                     chan.send(());\n                     cond.wait();\n                     chan.send(());\n                 })\n-            }\n+            });\n         });\n \n         // wait until all children get in the mutex\n@@ -1327,11 +1326,11 @@ mod tests {\n         let x = RWLock::new();\n         let x2 = x.clone();\n \n-        let result: result::Result<(), ~Any> = do task::try || {\n+        let result: result::Result<(), ~Any> = task::try(proc() {\n             lock_rwlock_in_mode(&x2, mode1, || {\n                 fail!();\n             })\n-        };\n+        });\n         assert!(result.is_err());\n         // child task must have finished by the time try returns\n         lock_rwlock_in_mode(&x, mode2, || { })\n@@ -1392,10 +1391,10 @@ mod tests {\n         9.times(|| {\n             let c = barrier.clone();\n             let chan = chan.clone();\n-            do spawn {\n+            spawn(proc() {\n                 c.wait();\n                 chan.send(true);\n-            }\n+            });\n         });\n \n         // At this point, all spawned tasks should be blocked,"}, {"sha": "cd04cddba4a6937a864d7a0c4b64cdfe29e5be8d", "filename": "src/libextra/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -873,7 +873,7 @@ pub fn run_test(force_ignore: bool,\n     fn run_test_inner(desc: TestDesc,\n                       monitor_ch: SharedChan<MonitorMsg>,\n                       testfn: proc()) {\n-        do spawn {\n+        spawn(proc() {\n             let mut task = task::task();\n             task.name(match desc.name {\n                 DynTestName(ref name) => SendStrOwned(name.clone()),\n@@ -885,7 +885,7 @@ pub fn run_test(force_ignore: bool,\n             let task_result = result_future.recv();\n             let test_result = calc_result(&desc, task_result.is_ok());\n             monitor_ch.send((desc.clone(), test_result));\n-        }\n+        });\n     }\n \n     match testfn {"}, {"sha": "70bbe02d32f1769839b08021c8a3706d45d93033", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -414,14 +414,14 @@ impl<'a> Prep<'a> {\n                 let blk = bo.take_unwrap();\n \n                 // FIXME: What happens if the task fails?\n-                do spawn {\n+                spawn(proc() {\n                     let mut exe = Exec {\n                         discovered_inputs: WorkMap::new(),\n                         discovered_outputs: WorkMap::new(),\n                     };\n                     let v = blk(&mut exe);\n                     chan.send((exe, v));\n-                }\n+                });\n                 Work::from_task(self, port)\n             }\n         }\n@@ -495,7 +495,7 @@ fn test() {\n \n         // FIXME (#9639): This needs to handle non-utf8 paths\n         prep.declare_input(\"file\", pth.as_str().unwrap(), file_content);\n-        do prep.exec |_exe| {\n+        prep.exec(proc(_exe) {\n             let out = make_path(~\"foo.o\");\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             run::process_status(\"gcc\", [pth.as_str().unwrap().to_owned(),\n@@ -507,7 +507,7 @@ fn test() {\n \n             // FIXME (#9639): This needs to handle non-utf8 paths\n             out.as_str().unwrap().to_owned()\n-        }\n+        })\n     });\n \n     println!(\"{}\", s);"}, {"sha": "89c3398ab62d029795e5e658452cb076b12f6171", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -247,18 +247,18 @@ mod test {\n \n     #[test]\n     fn smoke() {\n-        do run {}\n+        run(proc() {});\n     }\n \n     #[test]\n     fn some_channels() {\n-        do run {\n+        run(proc() {\n             let (p, c) = Chan::new();\n-            do spawn {\n+            spawn(proc() {\n                 c.send(());\n-            }\n+            });\n             p.recv();\n-        }\n+        });\n     }\n \n     #[test]\n@@ -269,13 +269,13 @@ mod test {\n         });\n \n         for _ in range(0, 20) {\n-            do pool.spawn(TaskOpts::new()) {\n+            pool.spawn(TaskOpts::new(), proc() {\n                 let (p, c) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     c.send(());\n-                }\n+                });\n                 p.recv();\n-            }\n+            });\n         }\n \n         pool.shutdown();"}, {"sha": "f8d629589fc3c5f2a1d33b2cf062f57059ee455d", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -60,10 +60,10 @@ pub mod task;\n #[cfg(not(test))]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n-    do start(argc, argv) {\n+    start(argc, argv, proc() {\n         let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n         main();\n-    }\n+    })\n }\n \n /// Set up a default runtime configuration, given compiler-supplied arguments.\n@@ -222,7 +222,7 @@ impl SchedPool {\n                                             pool.task_state.clone());\n             pool.handles.push(sched.make_handle());\n             let sched = sched;\n-            pool.threads.push(do Thread::start { sched.bootstrap(); });\n+            pool.threads.push(Thread::start(proc() { sched.bootstrap(); }));\n         }\n \n         return pool;\n@@ -284,7 +284,7 @@ impl SchedPool {\n         let ret = sched.make_handle();\n         self.handles.push(sched.make_handle());\n         let sched = sched;\n-        self.threads.push(do Thread::start { sched.bootstrap() });\n+        self.threads.push(Thread::start(proc() { sched.bootstrap() }));\n \n         return ret;\n     }"}, {"sha": "7ac874ebd9542f7525a7408c64deb21f7bc60daf", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 70, "deletions": 72, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -998,10 +998,10 @@ mod test {\n     fn trivial_run_in_newsched_task_test() {\n         let mut task_ran = false;\n         let task_ran_ptr: *mut bool = &mut task_ran;\n-        do run {\n+        run(proc() {\n             unsafe { *task_ran_ptr = true };\n             rtdebug!(\"executed from the new scheduler\")\n-        }\n+        });\n         assert!(task_ran);\n     }\n \n@@ -1012,31 +1012,31 @@ mod test {\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n         // with only one thread this is safe to run in without worries of\n         // contention.\n-        do run {\n+        run(proc() {\n             for _ in range(0u, total) {\n-                do spawn || {\n+                spawn(proc() {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1};\n-                }\n+                });\n             }\n-        }\n+        });\n         assert!(task_run_count == total);\n     }\n \n     #[test]\n     fn multiple_task_nested_test() {\n         let mut task_run_count = 0;\n         let task_run_count_ptr: *mut uint = &mut task_run_count;\n-        do run {\n-            do spawn {\n+        run(proc() {\n+            spawn(proc() {\n                 unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                do spawn {\n+                spawn(proc() {\n                     unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    do spawn {\n+                    spawn(proc() {\n                         unsafe { *task_run_count_ptr = *task_run_count_ptr + 1 };\n-                    }\n-                }\n-            }\n-        }\n+                    })\n+                })\n+            })\n+        });\n         assert!(task_run_count == 3);\n     }\n \n@@ -1052,15 +1052,15 @@ mod test {\n             let mut handle1 = pool.spawn_sched();\n             let mut handle2 = pool.spawn_sched();\n \n-            handle1.send(TaskFromFriend(do pool.task(TaskOpts::new()) {\n+            handle1.send(TaskFromFriend(pool.task(TaskOpts::new(), proc() {\n                 chan.send(sched_id());\n-            }));\n+            })));\n             let sched1_id = port.recv();\n \n-            let mut task = do pool.task(TaskOpts::new()) {\n+            let mut task = pool.task(TaskOpts::new(), proc() {\n                 assert_eq!(sched_id(), sched1_id);\n                 dchan.send(());\n-            };\n+            });\n             task.give_home(HomeSched(handle1));\n             handle2.send(TaskFromFriend(task));\n         }\n@@ -1080,7 +1080,7 @@ mod test {\n         use std::rt::thread::Thread;\n         use std::sync::deque::BufferPool;\n \n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let sleepers = SleeperList::new();\n             let mut pool = BufferPool::new();\n             let (normal_worker, normal_stealer) = pool.deque();\n@@ -1146,23 +1146,23 @@ mod test {\n                 ret\n             }\n \n-            let task1 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n-                                                None, HomeSched(t1_handle)) {\n+            let task1 = GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                             None, HomeSched(t1_handle), proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task2 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+            let task2 = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task3 = do GreenTask::new(&mut normal_sched.stack_pool, None) {\n+            let task3 = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n-            let task4 = do GreenTask::new_homed(&mut special_sched.stack_pool,\n-                                                None, HomeSched(t4_handle)) {\n+            let task4 = GreenTask::new_homed(&mut special_sched.stack_pool,\n+                                             None, HomeSched(t4_handle), proc() {\n                 rtassert!(on_appropriate_sched());\n-            };\n+            });\n \n             // Signal from the special task that we are done.\n             let (port, chan) = Chan::<()>::new();\n@@ -1173,35 +1173,33 @@ mod test {\n                 sched.run_task(task, next)\n             }\n \n-            let normal_task = do GreenTask::new(&mut normal_sched.stack_pool,\n-                                                None) {\n+            let normal_task = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 run(task2);\n                 run(task4);\n                 port.recv();\n                 let mut nh = normal_handle;\n                 nh.send(Shutdown);\n                 let mut sh = special_handle;\n                 sh.send(Shutdown);\n-            };\n+            });\n             normal_sched.enqueue_task(normal_task);\n \n-            let special_task = do GreenTask::new(&mut special_sched.stack_pool,\n-                                                 None) {\n+            let special_task = GreenTask::new(&mut special_sched.stack_pool, None, proc() {\n                 run(task1);\n                 run(task3);\n                 chan.send(());\n-            };\n+            });\n             special_sched.enqueue_task(special_task);\n \n             let normal_sched = normal_sched;\n-            let normal_thread = do Thread::start { normal_sched.bootstrap() };\n+            let normal_thread = Thread::start(proc() { normal_sched.bootstrap() });\n \n             let special_sched = special_sched;\n-            let special_thread = do Thread::start { special_sched.bootstrap() };\n+            let special_thread = Thread::start(proc() { special_sched.bootstrap() });\n \n             normal_thread.join();\n             special_thread.join();\n-        }\n+        });\n     }\n \n     //#[test]\n@@ -1226,11 +1224,11 @@ mod test {\n         // the work queue, but we are performing I/O, that once we do put\n         // something in the work queue again the scheduler picks it up and\n         // doesn't exit before emptying the work queue\n-        do pool.spawn(TaskOpts::new()) {\n-            do spawn {\n+        pool.spawn(TaskOpts::new(), proc() {\n+            spawn(proc() {\n                 timer::sleep(10);\n-            }\n-        }\n+            });\n+        });\n \n         pool.shutdown();\n     }\n@@ -1243,19 +1241,19 @@ mod test {\n         let mut pool1 = pool();\n         let mut pool2 = pool();\n \n-        do pool1.spawn(TaskOpts::new()) {\n+        pool1.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n             chan1.send(());\n             port2.recv();\n             assert_eq!(id, sched_id());\n-        }\n+        });\n \n-        do pool2.spawn(TaskOpts::new()) {\n+        pool2.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n             port1.recv();\n             assert_eq!(id, sched_id());\n             chan2.send(());\n-        }\n+        });\n \n         pool1.shutdown();\n         pool2.shutdown();\n@@ -1275,13 +1273,13 @@ mod test {\n \n     #[test]\n     fn multithreading() {\n-        do run {\n+        run(proc() {\n             let mut ports = ~[];\n             10.times(|| {\n                 let (port, chan) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     chan.send(());\n-                }\n+                });\n                 ports.push(port);\n             });\n \n@@ -1291,12 +1289,12 @@ mod test {\n                     None => break,\n                 }\n             }\n-        }\n+        });\n     }\n \n      #[test]\n     fn thread_ring() {\n-        do run {\n+        run(proc() {\n             let (end_port, end_chan) = Chan::new();\n \n             let n_tasks = 10;\n@@ -1309,19 +1307,19 @@ mod test {\n                 let (next_p, ch) = Chan::new();\n                 let imm_i = i;\n                 let imm_p = p;\n-                do spawn {\n+                spawn(proc() {\n                     roundtrip(imm_i, n_tasks, &imm_p, &ch);\n-                };\n+                });\n                 p = next_p;\n                 i += 1;\n             }\n             let p = p;\n-            do spawn {\n+            spawn(proc() {\n                 roundtrip(1, n_tasks, &p, &ch1);\n-            }\n+            });\n \n             end_port.recv();\n-        }\n+        });\n \n         fn roundtrip(id: int, n_tasks: int,\n                      p: &Port<(int, Chan<()>)>,\n@@ -1349,7 +1347,7 @@ mod test {\n     fn start_closure_dtor() {\n         // Regression test that the `start` task entrypoint can\n         // contain dtors that use task resources\n-        do run {\n+        run(proc() {\n             struct S { field: () }\n \n             impl Drop for S {\n@@ -1360,10 +1358,10 @@ mod test {\n \n             let s = S { field: () };\n \n-            do spawn {\n+            spawn(proc() {\n                 let _ss = &s;\n-            }\n-        }\n+            });\n+        });\n     }\n \n     // FIXME: #9407: xfail-test\n@@ -1374,46 +1372,46 @@ mod test {\n             threads: 2, // this must be > 1\n             event_loop_factory: Some(basic::event_loop),\n         });\n-        do pool.spawn(TaskOpts::new()) {\n+        pool.spawn(TaskOpts::new(), proc() {\n             let (port, chan) = Chan::new();\n \n             // This task should not be able to starve the sender;\n             // The sender should get stolen to another thread.\n-            do spawn {\n+            spawn(proc() {\n                 while port.try_recv() != comm::Data(()) { }\n-            }\n+            });\n \n             chan.send(());\n-        }\n+        });\n         pool.shutdown();\n     }\n \n     #[test]\n     fn dont_starve_2() {\n-        do run {\n+        run(proc() {\n             let (port, chan) = Chan::new();\n             let (_port2, chan2) = Chan::new();\n \n             // This task should not be able to starve the other task.\n             // The sends should eventually yield.\n-            do spawn {\n+            spawn(proc() {\n                 while port.try_recv() != comm::Data(()) {\n                     chan2.send(());\n                 }\n-            }\n+            });\n \n             chan.send(());\n-        }\n+        });\n     }\n \n     // Regression test for a logic bug that would cause single-threaded\n     // schedulers to sleep forever after yielding and stealing another task.\n     #[test]\n     fn single_threaded_yield() {\n         use std::task::deschedule;\n-        do run {\n+        run(proc() {\n             5.times(deschedule);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -1461,11 +1459,11 @@ mod test {\n \n                 let (setup_po, setup_ch) = Chan::new();\n                 let (parent_po, parent_ch) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     let (child_po, child_ch) = Chan::new();\n                     setup_ch.send(child_ch);\n                     pingpong(&child_po, &parent_ch);\n-                };\n+                });\n \n                 let child_ch = setup_po.recv();\n                 child_ch.send(20);"}, {"sha": "f5dafe578cafdce06e149729fb0846867545b6c8", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -494,19 +494,19 @@ mod tests {\n     #[test]\n     fn smoke() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn smoke_fail() {\n         let (p, c) = Chan::<()>::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let _c = c;\n             fail!()\n-        }\n+        });\n         assert_eq!(p.recv_opt(), None);\n     }\n \n@@ -533,38 +533,38 @@ mod tests {\n     #[test]\n     fn yield_test() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             10.times(task::deschedule);\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_children() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let (p, c2) = Chan::new();\n-            do spawn {\n+            spawn(proc() {\n                 let (p, c3) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     c3.send(());\n-                }\n+                });\n                 p.recv();\n                 c2.send(());\n-            }\n+            });\n             p.recv();\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_inherits() {\n         let (p, c) = Chan::new();\n-        do spawn_opts(TaskOpts::new()) {\n+        spawn_opts(TaskOpts::new(), proc() {\n             let c = c;\n-            do spawn {\n+            spawn(proc() {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<GreenTask>() {\n                     Some(ops) => {\n@@ -574,8 +574,8 @@ mod tests {\n                 }\n                 Local::put(task);\n                 c.send(());\n-            }\n-        }\n+            });\n+        });\n         p.recv();\n     }\n }"}, {"sha": "9fc182203860b65e7d28d569d810db7b8d6db104", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -46,10 +46,10 @@ pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n             let (receive, send) = imp::new();\n             HELPER_SIGNAL = send;\n \n-            do task::spawn {\n+            task::spawn(proc() {\n                 bookkeeping::decrement();\n                 helper(receive, msgp);\n-            }\n+            });\n \n             rt::at_exit(proc() { shutdown() });\n         })"}, {"sha": "438ac4add39fcedfc84e830ab74d06773b7b6e6f", "filename": "src/libnative/task.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -272,19 +272,19 @@ mod tests {\n     #[test]\n     fn smoke() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn smoke_fail() {\n         let (p, c) = Chan::<()>::new();\n-        do spawn {\n+        spawn(proc() {\n             let _c = c;\n             fail!()\n-        }\n+        });\n         assert_eq!(p.recv_opt(), None);\n     }\n \n@@ -311,38 +311,38 @@ mod tests {\n     #[test]\n     fn yield_test() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             10.times(task::deschedule);\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_children() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let (p, c2) = Chan::new();\n-            do spawn {\n+            spawn(proc() {\n                 let (p, c3) = Chan::new();\n-                do spawn {\n+                spawn(proc() {\n                     c3.send(());\n-                }\n+                });\n                 p.recv();\n                 c2.send(());\n-            }\n+            });\n             p.recv();\n             c.send(());\n-        }\n+        });\n         p.recv();\n     }\n \n     #[test]\n     fn spawn_inherits() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let c = c;\n-            do spawn {\n+            spawn(proc() {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<Ops>() {\n                     Some(ops) => {\n@@ -352,8 +352,8 @@ mod tests {\n                 }\n                 Local::put(task);\n                 c.send(());\n-            }\n-        }\n+            });\n+        });\n         p.recv();\n     }\n }"}, {"sha": "eb9c434ca28497192744ba58383873e14fa39f2c", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -398,7 +398,6 @@ impl CFGBuilder {\n             }\n \n             ast::ExprAddrOf(_, e) |\n-            ast::ExprDoBody(e) |\n             ast::ExprCast(e, _) |\n             ast::ExprUnary(_, _, e) |\n             ast::ExprParen(e) |"}, {"sha": "164b231fedc7198f5fe833e98158ba6e5a828862", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -706,7 +706,6 @@ impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n             ast::ExprPath(..) => {}\n \n             ast::ExprAddrOf(_, e) |\n-            ast::ExprDoBody(e) |\n             ast::ExprCast(e, _) |\n             ast::ExprUnary(_, _, e) |\n             ast::ExprParen(e) |"}, {"sha": "6a1fa488121bb58ffff60a3ce3934f22de3c6b8c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -538,7 +538,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: &Expr, this: @IrMaps) {\n       ExprIndex(..) | ExprField(..) | ExprVstore(..) | ExprVec(..) |\n       ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprLogLevel |\n       ExprBinary(..) | ExprAddrOf(..) |\n-      ExprDoBody(..) | ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n+      ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n       ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n       ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n       ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n@@ -1245,7 +1245,6 @@ impl Liveness {\n           }\n \n           ExprAddrOf(_, e) |\n-          ExprDoBody(e) |\n           ExprCast(e, _) |\n           ExprUnary(_, _, e) |\n           ExprParen(e) => {\n@@ -1529,7 +1528,7 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n       ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n       ExprVstore(..) | ExprVec(..) | ExprTup(..) | ExprLogLevel |\n-      ExprBinary(..) | ExprDoBody(..) |\n+      ExprBinary(..) |\n       ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n       ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n       ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |"}, {"sha": "fadcd516e4ba8dff1ceaa76a8e856058f32979e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -436,7 +436,7 @@ impl mem_categorization_ctxt {\n           ast::ExprAddrOf(..) | ast::ExprCall(..) |\n           ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n           ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprRet(..) |\n-          ast::ExprDoBody(..) | ast::ExprUnary(..) |\n+          ast::ExprUnary(..) |\n           ast::ExprMethodCall(..) | ast::ExprCast(..) | ast::ExprVstore(..) |\n           ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n           ast::ExprLogLevel | ast::ExprBinary(..) | ast::ExprWhile(..) |"}, {"sha": "b0171eafeb3fa1c041c9a0ed0f41f9493d93e88a", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -570,10 +570,6 @@ impl VisitContext {\n                 self.consume_expr(count);\n             }\n \n-            ExprDoBody(base) => {\n-                self.use_expr(base, comp_mode);\n-            }\n-\n             ExprFnBlock(ref decl, body) |\n             ExprProc(ref decl, body) => {\n                 for a in decl.inputs.iter() {"}, {"sha": "b9877d327cb1a423bf7c1f565bfef6c2342ca219", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -2655,20 +2655,6 @@ fn populate_scope_map(cx: &CrateContext,\n                 })\n             }\n \n-            ast::ExprDoBody(inner_exp) => {\n-                let inner_expr_is_expr_fn_block = match *inner_exp {\n-                    ast::Expr { node: ast::ExprFnBlock(..), .. } => true,\n-                    _ => false\n-                };\n-\n-                if !inner_expr_is_expr_fn_block {\n-                    cx.sess.span_bug(inner_exp.span, \"debuginfo: Inner expression was expected \\\n-                                                      to be an ast::expr_fn_block.\");\n-                }\n-\n-                walk_expr(cx, inner_exp, scope_stack, scope_map);\n-            }\n-\n             ast::ExprCall(fn_exp, ref args, _) => {\n                 walk_expr(cx, fn_exp, scope_stack, scope_map);\n "}, {"sha": "d0a01f56b530c4ac084e726925fcd3accc42d019", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -867,9 +867,6 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             closure::trans_expr_fn(bcx, sigil, decl, body,\n                                    expr.id, expr.id, dest)\n         }\n-        ast::ExprDoBody(blk) => {\n-            trans_into(bcx, blk, dest)\n-        }\n         ast::ExprCall(f, ref args, _) => {\n             callee::trans_call(bcx, expr, f,\n                                callee::ArgExprs(*args), expr.id, dest)"}, {"sha": "469df730a1290ec66ef5fc7a986225ebe49618b5", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -3166,7 +3166,6 @@ pub fn expr_kind(tcx: ctxt,\n         ast::ExprMatch(..) |\n         ast::ExprFnBlock(..) |\n         ast::ExprProc(..) |\n-        ast::ExprDoBody(..) |\n         ast::ExprBlock(..) |\n         ast::ExprRepeat(..) |\n         ast::ExprVstore(_, ast::ExprVstoreSlice) |"}, {"sha": "fe9998786f35fd586d206f89191a4c6cebd8c152", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 43, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -146,7 +146,7 @@ pub mod method;\n /// closures defined within the function.  For example:\n ///\n ///     fn foo() {\n-///         do bar() { ... }\n+///         bar(proc() { ... })\n ///     }\n ///\n /// Here, the function `foo()` and the closure passed to\n@@ -1640,8 +1640,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n         } else {\n             let suffix = match sugar {\n                 ast::NoSugar => \"\",\n-                ast::DoSugar => \" (including the closure passed by \\\n-                                 the `do` keyword)\",\n                 ast::ForSugar => \" (including the closure passed by \\\n                                   the `for` keyword)\"\n             };\n@@ -1690,8 +1688,7 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n             for (i, arg) in args.iter().take(t).enumerate() {\n                 let is_block = match arg.node {\n                     ast::ExprFnBlock(..) |\n-                    ast::ExprProc(..) |\n-                    ast::ExprDoBody(..) => true,\n+                    ast::ExprProc(..) => true,\n                     _ => false\n                 };\n \n@@ -2928,44 +2925,6 @@ pub fn check_expr_with_unifier(fcx: @FnCtxt,\n                       Vanilla,\n                       expected);\n       }\n-      ast::ExprDoBody(b) => {\n-        let expected_sty = unpack_expected(fcx,\n-                                           expected,\n-                                           |x| Some((*x).clone()));\n-        let inner_ty = match expected_sty {\n-            Some(ty::ty_closure(ref closure_ty))\n-                    if closure_ty.sigil == ast::OwnedSigil => {\n-                expected.unwrap()\n-            }\n-            _ => match expected {\n-                Some(expected_t) => {\n-                    fcx.type_error_message(expr.span, |actual| {\n-                        format!(\"last argument in `do` call \\\n-                              has non-procedure type: {}\",\n-                             actual)\n-                    }, expected_t, None);\n-                    let err_ty = ty::mk_err();\n-                    fcx.write_ty(id, err_ty);\n-                    err_ty\n-                }\n-                None => {\n-                    fcx.tcx().sess.impossible_case(\n-                        expr.span,\n-                        \"do body must have expected type\")\n-                }\n-            }\n-        };\n-        match b.node {\n-          ast::ExprFnBlock(decl, body) => {\n-            check_expr_fn(fcx, b, None,\n-                          decl, body, DoBlock, Some(inner_ty));\n-            demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n-          }\n-          // argh\n-          _ => fail!(\"expected fn ty\")\n-        }\n-        fcx.write_ty(expr.id, fcx.node_ty(b.id));\n-      }\n       ast::ExprBlock(b) => {\n         check_block_with_expected(fcx, b, expected);\n         fcx.write_ty(id, fcx.node_ty(b.id));"}, {"sha": "f134fb3b6ae85d842d87d54ef10500a26aada8f2", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -1045,7 +1045,6 @@ pub mod guarantor {\n             ast::ExprMatch(..) |\n             ast::ExprFnBlock(..) |\n             ast::ExprProc(..) |\n-            ast::ExprDoBody(..) |\n             ast::ExprBlock(..) |\n             ast::ExprRepeat(..) |\n             ast::ExprVec(..) => {"}, {"sha": "f7a484e3d3e00262c6072a406250a679c3a2fde7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -211,10 +211,10 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     let cfgs = matches.opt_strs(\"cfg\");\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n-    let (crate, analysis) = do std::task::try {\n+    let (crate, analysis) = std::task::try(proc() {\n         let cr = cr;\n         core::run_core(libs.move_iter().collect(), cfgs, &cr)\n-    }.unwrap();\n+    }).unwrap();\n     info!(\"finished with rustc\");\n     local_data::set(analysiskey, analysis);\n "}, {"sha": "b43ffec2783cafb3d5e37613be81e0db69501fa4", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -799,14 +799,14 @@ pub fn main_args(args: &[~str]) -> int {\n     debug!(\"Will store workcache in {}\", ws.display());\n \n     // Wrap the rest in task::try in case of a condition failure in a task\n-    let result = do task::try {\n+    let result = task::try(proc() {\n         BuildContext {\n             context: context,\n             sysroot: sysroot.clone(), // Currently, only tests override this\n             workcache_context: api::default_context(sysroot.clone(),\n                                                     default_workspace()).workcache_context\n         }.run(command, args.clone())\n-    };\n+    });\n     // FIXME #9262: This is using the same error code for all errors,\n     // and at least one test case succeeds if rustpkg returns COPY_FAILED_CODE,\n     // when actually, it might set the exit code for that even if a different"}, {"sha": "091399c3fb7de274659d9b6e2b740cd35d7fde64", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -607,13 +607,13 @@ fn test_install_invalid() {\n     let ctxt = fake_ctxt(sysroot, &temp_workspace);\n \n     // Uses task::try because of #9001\n-    let result = do task::try {\n+    let result = task::try(proc() {\n         let pkg_src = PkgSrc::new(temp_workspace.clone(),\n                                   temp_workspace.clone(),\n                                   false,\n                                   crateid.clone());\n         ctxt.install(pkg_src, &WhatToBuild::new(MaybeCustom, Everything));\n-    };\n+    });\n     assert!(result.unwrap_err()\n             .to_str().contains(\"supplied path for package dir does not exist\"));\n }"}, {"sha": "dcc39ae0e92b43d9fe7ec20e138b05710f657969", "filename": "src/librustpkg/testsuite/pass/src/c-dependencies/pkg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fc-dependencies%2Fpkg.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -50,7 +50,7 @@ pub fn main() {\n         prep.declare_input(\"file\",\n                            foo_c_name.as_str().unwrap().to_owned(),\n                            digest_file_with_date(&foo_c_name));\n-        let out_path = do prep.exec |exec| {\n+        let out_path = prep.exec(|exec| {\n             let out_path = api::build_library_in_workspace(exec,\n                                                            &mut sub_cx.clone(),\n                                                            \"cdep\",\n@@ -60,22 +60,22 @@ pub fn main() {\n                                                            \"foo\");\n             let out_p = Path::new(out_path.unwrap());\n             out_p.as_str().unwrap().to_owned()\n-        };\n+        });\n         out_path\n     });\n     let out_lib_path = Path::new(out_lib_path);\n     debug!(\"out_lib_path = {}\", out_lib_path.display());\n     context.add_library_path(out_lib_path.dir_path());\n \n     let context_clone = context.clone();\n-    let task_res = do task::try {\n+    let task_res = task::try(proc() {\n         let mut cc = context_clone.clone();\n         api::install_pkg(&mut cc,\n                          os::getcwd(),\n                          ~\"cdep\",\n                          None,\n                          ~[(~\"binary\", out_lib_path.clone()), (~\"file\", foo_c_name.clone())]);\n-    };\n+    });\n \n     if task_res.is_err() {\n         os::set_exit_status(COPY_FAILED_CODE);"}, {"sha": "5dc50beb8506176648245916c9260aa21d63121c", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -152,10 +152,10 @@ mod test_remote {\n         let watcher = AsyncWatcher::new(&mut local_loop().loop_,\n                                         cb as ~Callback);\n \n-        let thread = do Thread::start {\n+        let thread = Thread::start(proc() {\n             let mut watcher = watcher;\n             watcher.fire();\n-        };\n+        });\n \n         assert_eq!(port.recv(), 1);\n         thread.join();"}, {"sha": "8d3e71312cd9510be048e73c654541fd65b0962a", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -170,14 +170,14 @@ mod test {\n             event_loop_factory: None,\n         });\n \n-        do pool.spawn(TaskOpts::new()) {\n+        pool.spawn(TaskOpts::new(), proc() {\n             let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n             chan.send(listener.unwrap());\n-        }\n+        });\n \n-        let task = do pool.task(TaskOpts::new()) {\n+        let task = pool.task(TaskOpts::new(), proc() {\n             port.recv();\n-        };\n+        });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n         pool.shutdown();\n@@ -191,20 +191,20 @@ mod test {\n             event_loop_factory: None,\n         });\n \n-        do pool.spawn(TaskOpts::new()) {\n+        pool.spawn(TaskOpts::new(), proc() {\n             let addr1 = next_test_ip4();\n             let addr2 = next_test_ip4();\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n             chan.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n             listener.sendto([1, 2, 3, 4], addr2);\n-        }\n+        });\n \n-        let task = do pool.task(TaskOpts::new()) {\n+        let task = pool.task(TaskOpts::new(), proc() {\n             let (mut watcher, addr) = port.recv();\n             let mut buf = [0, ..10];\n             assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n-        };\n+        });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n         pool.shutdown();"}, {"sha": "0b889e17a445ea2eb3f62a2c8195f111c6cb7cb1", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -433,10 +433,10 @@ mod test {\n \n     #[test]\n     fn loop_smoke_test() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let mut loop_ = Loop::new();\n             loop_.run();\n             loop_.close();\n-        }\n+        });\n     }\n }"}, {"sha": "8919ecfa97ef40308ee5928829f61c60920991ee", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -692,7 +692,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n-        do spawn {\n+        spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n@@ -712,7 +712,7 @@ mod test {\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n             }\n-        }\n+        });\n \n         port.recv();\n         let mut w = match TcpWatcher::connect(local_loop(), addr) {\n@@ -728,7 +728,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let addr = next_test_ip6();\n \n-        do spawn {\n+        spawn(proc() {\n             let w = match TcpListener::bind(local_loop(), addr) {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n             };\n@@ -748,7 +748,7 @@ mod test {\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n             }\n-        }\n+        });\n \n         port.recv();\n         let mut w = match TcpWatcher::connect(local_loop(), addr) {\n@@ -765,7 +765,7 @@ mod test {\n         let client = next_test_ip4();\n         let server = next_test_ip4();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     chan.send(());\n@@ -780,7 +780,7 @@ mod test {\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n             }\n-        }\n+        });\n \n         port.recv();\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n@@ -797,7 +797,7 @@ mod test {\n         let client = next_test_ip6();\n         let server = next_test_ip6();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n                     chan.send(());\n@@ -812,7 +812,7 @@ mod test {\n                 }\n                 Err(e) => fail!(\"{:?}\", e)\n             }\n-        }\n+        });\n \n         port.recv();\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n@@ -829,7 +829,7 @@ mod test {\n         static MAX: uint = 5000;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             chan.send(());\n@@ -841,7 +841,7 @@ mod test {\n                 uvdebug!(\"wrote bytes\");\n                 total_bytes_written += buf.len();\n             }\n-        }\n+        });\n \n         port.recv();\n         let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n@@ -864,12 +864,12 @@ mod test {\n         let client_addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n             port.recv();\n             assert!(client.sendto([1], server_addr).is_ok());\n             assert!(client.sendto([2], server_addr).is_ok());\n-        }\n+        });\n \n         let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n         chan.send(());\n@@ -896,7 +896,7 @@ mod test {\n         let (p1, c1) = Chan::new();\n         let (p2, c2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let l = local_loop();\n             let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n             let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n@@ -918,7 +918,7 @@ mod test {\n                 assert_eq!(src, client_out_addr);\n             }\n             assert!(total_bytes_sent >= MAX);\n-        }\n+        });\n \n         let l = local_loop();\n         let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n@@ -950,7 +950,7 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::<Port<()>>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let port2 = port.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n@@ -959,7 +959,7 @@ mod test {\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]);\n             port2.recv();\n-        }\n+        });\n \n         let listener = TcpListener::bind(local_loop(), addr).unwrap();\n         let mut acceptor = listener.listen().unwrap();\n@@ -992,7 +992,7 @@ mod test {\n     fn test_simple_tcp_server_and_client_on_diff_threads() {\n         let addr = next_test_ip4();\n \n-        do spawn {\n+        spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n             let mut stream = acceptor.accept().unwrap();\n@@ -1002,7 +1002,7 @@ mod test {\n             for i in range(0u, nread) {\n                 assert_eq!(buf[i], i as u8);\n             }\n-        }\n+        });\n \n         let mut stream = TcpWatcher::connect(local_loop(), addr);\n         while stream.is_err() {\n@@ -1024,12 +1024,12 @@ mod test {\n         let (port, chan) = Chan::new();\n         let addr = next_test_ip4();\n \n-        do spawn {\n+        spawn(proc() {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n             chan.send(());\n             w.accept();\n-        }\n+        });\n         port.recv();\n         let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n         fail!();\n@@ -1050,10 +1050,10 @@ mod test {\n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n-        do spawn {\n+        spawn(proc() {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n             chan.send(w);\n-        }\n+        });\n \n         let _w = port.recv();\n         fail!();"}, {"sha": "cfe86d739abcf935c95fec374b3994e9fadd3003", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -278,7 +278,7 @@ mod tests {\n         let path2 = path.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n             chan.send(());\n@@ -287,7 +287,7 @@ mod tests {\n             assert!(client.read(buf).unwrap() == 1);\n             assert_eq!(buf[0], 1);\n             assert!(client.write([2]).is_ok());\n-        }\n+        });\n         port.recv();\n         let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n         assert!(c.write([1]).is_ok());\n@@ -302,12 +302,12 @@ mod tests {\n         let path2 = path.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n             chan.send(());\n             p.accept();\n-        }\n+        });\n         port.recv();\n         let _c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n         fail!()"}, {"sha": "8cb0c1f0a52d70c8b7fe54f9908d3c32f7131420", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -85,9 +85,9 @@ mod test {\n         let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n                                          chan);\n \n-        do spawn {\n+        spawn(proc() {\n             port.try_recv();\n-        }\n+        });\n \n         // when we drop the SignalWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end"}, {"sha": "aeda1a45175eacdad0c943db86ebf3898f3ae12e", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -245,9 +245,9 @@ mod test {\n         let mut timer = TimerWatcher::new(local_loop());\n         let timer_port = timer.period(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end\n@@ -259,9 +259,9 @@ mod test {\n         let mut timer = TimerWatcher::new(local_loop());\n         let timer_port = timer.period(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.oneshot(1);\n     }\n@@ -271,9 +271,9 @@ mod test {\n         let mut timer = TimerWatcher::new(local_loop());\n         let timer_port = timer.period(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.sleep(1);\n     }"}, {"sha": "e0bff059b0c91344305c64535150427b2538cc07", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -111,16 +111,16 @@ pub fn new_loop() -> ~rtio::EventLoop {\n #[test]\n fn test_callback_run_once() {\n     use std::rt::rtio::EventLoop;\n-    do run_in_bare_thread {\n+    run_in_bare_thread(proc() {\n         let mut event_loop = UvEventLoop::new();\n         let mut count = 0;\n         let count_ptr: *mut int = &mut count;\n-        do event_loop.callback {\n+        event_loop.callback(proc() {\n             unsafe { *count_ptr += 1 }\n-        }\n+        });\n         event_loop.run();\n         assert_eq!(count, 1);\n-    }\n+    });\n }\n \n pub struct UvIoFactory {"}, {"sha": "8c56e65c22c667dbd19ebb4339015e320e25fe25", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 67, "deletions": 67, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -60,18 +60,18 @@\n //! ```rust,should_fail\n //! // Create a simple streaming channel\n //! let (port, chan) = Chan::new();\n-//! do spawn {\n+//! spawn(proc() {\n //!     chan.send(10);\n-//! }\n+//! })\n //! assert_eq!(port.recv(), 10);\n //!\n //! // Create a shared channel which can be sent along from many tasks\n //! let (port, chan) = SharedChan::new();\n //! for i in range(0, 10) {\n //!     let chan = chan.clone();\n-//!     do spawn {\n+//!     spawn(proc() {\n //!         chan.send(i);\n-//!     }\n+//!     })\n //! }\n //!\n //! for _ in range(0, 10) {\n@@ -264,7 +264,7 @@ macro_rules! test (\n             $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n-                do native::task::spawn { c.send(f()) }\n+                native::task::spawn(proc() { c.send(f()) });\n                 p.recv();\n             }\n         }\n@@ -962,9 +962,9 @@ mod test {\n \n     test!(fn smoke_threads() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             c.send(1);\n-        }\n+        });\n         assert_eq!(p.recv(), 1);\n     })\n \n@@ -990,18 +990,18 @@ mod test {\n \n     test!(fn port_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             p.recv();\n-        }\n+        });\n         loop { c.send(1) }\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent_shared() {\n         let (p, c) = SharedChan::new();\n         let c1 = c.clone();\n-        do spawn {\n+        spawn(proc() {\n             p.recv();\n-        }\n+        });\n         loop {\n             c.send(1);\n             c1.send(1);\n@@ -1024,18 +1024,18 @@ mod test {\n \n     test!(fn chan_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             c.send(1);\n             c.send(1);\n-        }\n+        });\n         loop { p.recv(); }\n     } #[should_fail])\n \n     test!(fn stress() {\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             for _ in range(0, 10000) { c.send(1); }\n-        }\n+        });\n         for _ in range(0, 10000) {\n             assert_eq!(p.recv(), 1);\n         }\n@@ -1047,7 +1047,7 @@ mod test {\n         let (p, c) = SharedChan::<int>::new();\n         let (p1, c1) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             for _ in range(0, AMT * NTHREADS) {\n                 assert_eq!(p.recv(), 1);\n             }\n@@ -1056,13 +1056,13 @@ mod test {\n                 _ => {}\n             }\n             c1.send(());\n-        }\n+        });\n \n         for _ in range(0, NTHREADS) {\n             let c = c.clone();\n-            do spawn {\n+            spawn(proc() {\n                 for _ in range(0, AMT) { c.send(1); }\n-            }\n+            });\n         }\n         p1.recv();\n     })\n@@ -1073,20 +1073,20 @@ mod test {\n         let (p1, c1) = Chan::new();\n         let (port, chan) = SharedChan::new();\n         let chan2 = chan.clone();\n-        do spawn {\n+        spawn(proc() {\n             c1.send(());\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n             chan2.send(());\n-        }\n+        });\n         p1.recv();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             for _ in range(0, 40) {\n                 c.send(1);\n             }\n             chan.send(());\n-        }\n+        });\n         port.recv();\n         port.recv();\n     }\n@@ -1095,12 +1095,12 @@ mod test {\n     fn recv_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n         let (dp, dc) = Chan::new();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n             dc.send(());\n-        };\n+        });\n         for _ in range(0, 40) {\n             c.send(1);\n         }\n@@ -1113,16 +1113,16 @@ mod test {\n         let (p2, c2) = Chan::<int>::new();\n         let (port, chan) = SharedChan::new();\n         let chan2 = chan.clone();\n-        do native::task::spawn {\n+        native::task::spawn(proc() {\n             assert_eq!(p1.recv(), 1);\n             c2.send(2);\n             chan2.send(());\n-        }\n-        do native::task::spawn {\n+        });\n+        native::task::spawn(proc() {\n             c1.send(1);\n             assert_eq!(p2.recv(), 2);\n             chan.send(());\n-        }\n+        });\n         port.recv();\n         port.recv();\n     }\n@@ -1148,11 +1148,11 @@ mod test {\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will fail\n-        let res = do task::try {\n+        let res = task::try(proc() {\n             let (port, chan) = Chan::<~int>::new();\n             { let _c = chan; }\n             port.recv();\n-        };\n+        });\n         // What is our res?\n         assert!(res.is_err());\n     })\n@@ -1208,74 +1208,74 @@ mod test {\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (port, chan) = Chan::<~int>::new();\n-        do spawn {\n+        spawn(proc() {\n             assert!(port.recv() == ~10);\n-        }\n+        });\n \n         chan.send(~10);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n         let (port, chan) = Chan::<~int>::new();\n-        do spawn {\n+        spawn(proc() {\n             let _chan = chan;\n-        }\n-        let res = do task::try {\n+        });\n+        let res = task::try(proc() {\n             assert!(port.recv() == ~10);\n-        };\n+        });\n         assert!(res.is_err());\n     })\n \n     test!(fn oneshot_multi_thread_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let _p = port;\n-            }\n+            });\n             let _chan = chan;\n         })\n     })\n \n     test!(fn oneshot_multi_thread_send_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let _p = port;\n-            }\n-            do task::try {\n+            });\n+            task::try(proc() {\n                 chan.send(1);\n-            };\n+            });\n         })\n     })\n \n     test!(fn oneshot_multi_thread_recv_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 let port = port;\n-                let res = do task::try {\n+                let res = task::try(proc() {\n                     port.recv();\n-                };\n+                });\n                 assert!(res.is_err());\n-            };\n-            do spawn {\n+            });\n+            spawn(proc() {\n                 let chan = chan;\n-                do spawn {\n+                spawn(proc() {\n                     let _chan = chan;\n-                }\n-            };\n+                });\n+            });\n         })\n     })\n \n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n-            do spawn {\n+            spawn(proc() {\n                 chan.send(~10);\n-            }\n-            do spawn {\n+            });\n+            spawn(proc() {\n                 assert!(port.recv() == ~10);\n-            }\n+            });\n         })\n     })\n \n@@ -1289,19 +1289,19 @@ mod test {\n             fn send(chan: Chan<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawn {\n+                spawn(proc() {\n                     chan.send(~i);\n                     send(chan, i + 1);\n-                }\n+                });\n             }\n \n             fn recv(port: Port<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawn {\n+                spawn(proc() {\n                     assert!(port.recv() == ~i);\n                     recv(port, i + 1);\n-                };\n+                });\n             }\n         })\n     })\n@@ -1318,9 +1318,9 @@ mod test {\n         let total = stress_factor() + 100;\n         total.times(|| {\n             let chan_clone = chan.clone();\n-            do spawn {\n+            spawn(proc() {\n                 chan_clone.send(());\n-            }\n+            });\n         });\n \n         total.times(|| {\n@@ -1332,13 +1332,13 @@ mod test {\n         let (port, chan) = Chan::<int>::new();\n         let (total_port, total_chan) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acc = 0;\n             for x in port.iter() {\n                 acc += x;\n             }\n             total_chan.send(acc);\n-        }\n+        });\n \n         chan.send(3);\n         chan.send(1);\n@@ -1351,7 +1351,7 @@ mod test {\n         let (port, chan) = Chan::<int>::new();\n         let (count_port, count_chan) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut count = 0;\n             for x in port.iter() {\n                 if count >= 3 {\n@@ -1361,7 +1361,7 @@ mod test {\n                 }\n             }\n             count_chan.send(count);\n-        }\n+        });\n \n         chan.send(2);\n         chan.send(2);\n@@ -1375,14 +1375,14 @@ mod test {\n         let (p, c) = Chan::<int>::new();\n         let (p1, c1) = Chan::<()>::new();\n         let (p2, c2) = Chan::<()>::new();\n-        do spawn {\n+        spawn(proc() {\n             p1.recv();\n             c.send(1);\n             c2.send(());\n             p1.recv();\n             drop(c);\n             c2.send(());\n-        }\n+        });\n \n         assert_eq!(p.try_recv(), Empty);\n         c1.send(());"}, {"sha": "af435c3fc5f311bb206b84a8dcf36c4849f4769f", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -378,12 +378,12 @@ mod test {\n         let (mut p2, _c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<int>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             20.times(task::deschedule);\n             c1.send(1);\n             p3.recv();\n             20.times(task::deschedule);\n-        }\n+        });\n \n         select! (\n             a = p1.recv() => { assert_eq!(a, 1); },\n@@ -401,12 +401,12 @@ mod test {\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             20.times(task::deschedule);\n             c1.send(1);\n             c2.send(2);\n             p3.recv();\n-        }\n+        });\n \n         select! (\n             a = p1.recv() => { assert_eq!(a, 1); },\n@@ -427,7 +427,7 @@ mod test {\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n                     c1.send(i);\n@@ -436,7 +436,7 @@ mod test {\n                 }\n                 p3.recv();\n             }\n-        }\n+        });\n \n         for i in range(0, AMT) {\n             select! ("}, {"sha": "0acfa71e3151c9a5484195cfafe7934fdabb48a7", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -120,13 +120,13 @@ mod test {\n     #[test]\n     fn test_port_reader() {\n         let (port, chan) = Chan::new();\n-        do task::spawn {\n+        task::spawn(proc() {\n           chan.send(~[1u8, 2u8]);\n           chan.send(~[]);\n           chan.send(~[3u8, 4u8]);\n           chan.send(~[5u8, 6u8]);\n           chan.send(~[7u8, 8u8]);\n-        }\n+        });\n \n         let mut reader = PortReader::new(port);\n         let mut buf = ~[0u8, ..3];\n@@ -172,7 +172,7 @@ mod test {\n         writer.write_be_u32(42);\n \n         let wanted = ~[0u8, 0u8, 0u8, 42u8];\n-        let got = do task::try { port.recv() }.unwrap();\n+        let got = task::try(proc() { port.recv() }).unwrap();\n         assert_eq!(wanted, got);\n \n         let mut err = None;"}, {"sha": "2d074df49199b1df8f3929b16fb855be4a72c7a4", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -167,11 +167,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -185,11 +185,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]);\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -203,11 +203,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -221,11 +221,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -239,11 +239,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -267,11 +267,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -295,11 +295,11 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -326,11 +326,11 @@ mod test {\n         let addr = next_test_ip6();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -358,13 +358,13 @@ mod test {\n         let max = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -380,13 +380,13 @@ mod test {\n         let max = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             max.times(|| {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]);\n             });\n-        }\n+        });\n \n         let mut acceptor = TcpListener::bind(addr).listen();\n         chan.send(());\n@@ -402,35 +402,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([i as u8]);\n-            }\n+            });\n         }\n     })\n \n@@ -439,35 +439,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([i as u8]);\n-            }\n+            });\n         }\n     })\n \n@@ -476,35 +476,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([99]);\n-            }\n+            });\n         }\n     })\n \n@@ -513,35 +513,35 @@ mod test {\n         static MAX: int = 10;\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                do spawn {\n+                spawn(proc() {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n                     debug!(\"read\");\n-                }\n+                });\n             }\n-        }\n+        });\n \n         port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            do spawn {\n+            spawn(proc() {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n                 connect(i + 1, addr);\n                 debug!(\"writing\");\n                 stream.write([99]);\n-            }\n+            });\n         }\n     })\n \n@@ -558,11 +558,11 @@ mod test {\n     pub fn peer_name(addr: SocketAddr) {\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             acceptor.accept();\n-        }\n+        });\n \n         port.recv();\n         let stream = TcpStream::connect(addr);\n@@ -592,15 +592,15 @@ mod test {\n     iotest!(fn partial_read() {\n         let addr = next_test_ip4();\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let mut srv = TcpListener::bind(addr).listen();\n             c.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]);\n             let mut b = [0];\n             cl.read(b);\n             c.send(());\n-        }\n+        });\n \n         p.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n@@ -630,12 +630,12 @@ mod test {\n         let addr = next_test_ip4();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             let stream = TcpStream::connect(addr);\n             // Close\n             port.recv();\n-        }\n+        });\n \n         {\n             let mut acceptor = TcpListener::bind(addr).listen();"}, {"sha": "1cf30d469f7aa81d76982ea75a3a34bca0f6f4d8", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -119,7 +119,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n@@ -128,7 +128,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(ref mut server) => {\n@@ -153,15 +153,15 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (port, chan) = Chan::<()>::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(ref mut client) => {\n                     port.recv();\n                     client.sendto([99], server_ip)\n                 }\n                 None => fail!()\n             }\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(ref mut server) => {\n@@ -186,7 +186,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -197,7 +197,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(server) => {\n@@ -224,7 +224,7 @@ mod test {\n         let (port, chan) = Chan::new();\n         let (port2, chan2) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Some(client) => {\n                     let client = ~client;\n@@ -235,7 +235,7 @@ mod test {\n                 None => fail!()\n             }\n             chan2.send(());\n-        }\n+        });\n \n         match UdpSocket::bind(server_ip) {\n             Some(server) => {"}, {"sha": "dcf6d2ad2035894f2859505be2d52bdcb3656d16", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -147,10 +147,10 @@ mod tests {\n         let path2 = path1.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             client(UnixStream::connect(&path2).unwrap());\n-        }\n+        });\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n         chan.send(());\n@@ -232,13 +232,13 @@ mod tests {\n         let path2 = path1.clone();\n         let (port, chan) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             port.recv();\n             times.times(|| {\n                 let mut stream = UnixStream::connect(&path2);\n                 stream.write([100]);\n             })\n-        }\n+        });\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n         chan.send(());"}, {"sha": "9919d333f41b4c80bda9726565c1d76ae53c7986", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -89,11 +89,11 @@ mod test {\n         let out = PipeStream::open(out);\n         let mut input = PipeStream::open(input);\n         let (p, c) = Chan::new();\n-        do spawn {\n+        spawn(proc() {\n             let mut out = out;\n             out.write([10]);\n             p.recv(); // don't close the pipe until the other read has finished\n-        }\n+        });\n \n         let mut buf = [0, ..10];\n         input.read(buf);"}, {"sha": "5575e289b59a7a096a4acfc66ca1aece6cb66cdc", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -65,14 +65,14 @@ pub enum Signum {\n /// let mut listener = Listener::new();\n /// listener.register(Interrupt);\n ///\n-/// do spawn {\n+/// spawn({\n ///     loop {\n ///         match listener.port.recv() {\n ///             Interrupt => println!(\"Got Interrupt'ed\"),\n ///             _ => (),\n ///         }\n ///     }\n-/// }\n+/// });\n ///\n /// ```\n pub struct Listener {"}, {"sha": "d9fa2a4fc336bc63b65d0e3cc55c19e68560e473", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -372,10 +372,10 @@ mod tests {\n \n         let (p, c) = Chan::new();\n         let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n-        do spawn {\n+        spawn(proc() {\n             set_stdout(~w as ~Writer);\n             println!(\"hello!\");\n-        }\n+        });\n         assert_eq!(r.read_to_str(), ~\"hello!\\n\");\n     })\n \n@@ -384,10 +384,10 @@ mod tests {\n \n         let (p, c) = Chan::new();\n         let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n-        do spawn {\n+        spawn(proc() {\n             set_stderr(~w as ~Writer);\n             fail!(\"my special message\");\n-        }\n+        });\n         let s = r.read_to_str();\n         assert!(s.contains(\"my special message\"));\n     })"}, {"sha": "6ac73e7f61e712c78a810bd16968562313786cd6", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -45,7 +45,7 @@ macro_rules! iotest (\n             $($a)* #[test] fn native() {\n                 use native;\n                 let (p, c) = Chan::new();\n-                do native::task::spawn { c.send(f()) }\n+                native::task::spawn(proc() { c.send(f()) });\n                 p.recv();\n             }\n         }"}, {"sha": "24eaf6adf3f3ead681439b736b3dbf66c4be7fa6", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -204,9 +204,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n         // which must wake up the task on the other end\n@@ -217,9 +217,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.oneshot(1);\n     })\n@@ -229,9 +229,9 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_port = timer.periodic(1000);\n \n-        do spawn {\n+        spawn(proc() {\n             timer_port.recv_opt();\n-        }\n+        });\n \n         timer.sleep(1);\n     })"}, {"sha": "719cf2450c5054c964ff8ac4f79c7931f978302e", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -355,14 +355,14 @@ mod tests {\n     fn test_tls_multitask() {\n         static my_key: Key<~str> = &Key;\n         set(my_key, ~\"parent data\");\n-        do task::spawn {\n+        task::spawn(proc() {\n             // TLS shouldn't carry over.\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).is_none());\n             set(my_key, ~\"child data\");\n             assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() ==\n                     ~\"child data\");\n             // should be cleaned up for us\n-        }\n+        });\n         // Must work multiple times\n         assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n         assert!(get(my_key, |k| k.map(|k| (*k).clone())).unwrap() == ~\"parent data\");\n@@ -414,21 +414,21 @@ mod tests {\n         // subsequent upcall (esp. for logging, think vsnprintf) would run on\n         // a stack smaller than 1 MB.\n         static my_key: Key<~str> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(my_key, ~\"hax\");\n-        }\n+        });\n     }\n \n     #[test]\n     fn test_tls_multiple_types() {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(str_key, ~\"string data\");\n             set(box_key, @());\n             set(int_key, 42);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -437,7 +437,7 @@ mod tests {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;\n         static int_key: Key<int> = &Key;\n-        do task::spawn {\n+        task::spawn(proc() {\n             set(str_key, ~\"string data\");\n             set(str_key, ~\"string data 2\");\n             set(box_key, @());\n@@ -447,7 +447,7 @@ mod tests {\n             // with the crazy polymorphic transmute rather than the provided\n             // finaliser.\n             set(int_key, 31337);\n-        }\n+        });\n     }\n \n     #[test]\n@@ -458,13 +458,13 @@ mod tests {\n         static int_key: Key<int> = &Key;\n         set(str_key, ~\"parent data\");\n         set(box_key, @());\n-        do task::spawn {\n+        task::spawn(proc() {\n             // spawn_linked\n             set(str_key, ~\"string data\");\n             set(box_key, @());\n             set(int_key, 42);\n             fail!();\n-        }\n+        });\n         // Not quite nondeterministic.\n         set(int_key, 31337);\n         fail!();"}, {"sha": "8029ec696f82a7282600ec6addd5c0442d792407", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -569,11 +569,11 @@ mod tests {\n         use task;\n \n         macro_rules! t(\n-            ($name:expr => $code:block) => (\n+            ($name:expr => $code:expr) => (\n                 {\n                     let mut t = task::task();\n                     t.name($name);\n-                    let res = do t.try $code;\n+                    let res = t.try(proc() $code);\n                     assert!(res.is_err());\n                 }\n             )"}, {"sha": "a07471afc1a67f940fbebdb3ff8e05606c63bd9d", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -1290,11 +1290,11 @@ mod tests {\n         use task;\n \n         macro_rules! t(\n-            ($name:expr => $code:block) => (\n+            ($name:expr => $code:expr) => (\n                 {\n                     let mut t = task::task();\n                     t.name($name);\n-                    let res = do t.try $code;\n+                    let res = t.try(proc() $code);\n                     assert!(res.is_err());\n                 }\n             )"}, {"sha": "c359d79d27509e8204d4ce089d94432fadcd172a", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -159,7 +159,7 @@ mod test {\n         for _ in range(0, 20) {\n             let (p, c) = Chan::new();\n             chans.push(c);\n-            do task::spawn {\n+            task::spawn(proc() {\n                 // wait until all the tasks are ready to go.\n                 p.recv();\n \n@@ -177,7 +177,7 @@ mod test {\n                     r.fill_bytes(v);\n                     task::deschedule();\n                 }\n-            }\n+            })\n         }\n \n         // start all the tasks"}, {"sha": "76a672b79cada5638095031819a2ab940f5151ab", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -57,17 +57,17 @@ mod test {\n \n     #[test]\n     fn thread_local_task_smoke_test() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn thread_local_task_two_instances() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n@@ -76,13 +76,12 @@ mod test {\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n-\n+        });\n     }\n \n     #[test]\n     fn borrow_smoke_test() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -91,12 +90,12 @@ mod test {\n             }\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn borrow_with_return() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -106,12 +105,12 @@ mod test {\n \n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-        }\n+        });\n     }\n \n     #[test]\n     fn try_take() {\n-        do run_in_bare_thread {\n+        run_in_bare_thread(proc() {\n             let task = ~Task::new();\n             Local::put(task);\n \n@@ -120,7 +119,7 @@ mod test {\n             assert!(u.is_none());\n \n             cleanup_task(t);\n-        }\n+        });\n     }\n \n     fn cleanup_task(mut t: ~Task) {"}, {"sha": "83f5ca346a9369104c4e7b4455adcf44a11b5f6a", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -255,11 +255,11 @@ mod tests {\n     use super::Thread;\n \n     #[test]\n-    fn smoke() { do Thread::start {}.join(); }\n+    fn smoke() { Thread::start(proc (){}).join(); }\n \n     #[test]\n-    fn data() { assert_eq!(do Thread::start { 1 }.join(), 1); }\n+    fn data() { assert_eq!(Thread::start(proc () { 1 }).join(), 1); }\n \n     #[test]\n-    fn detached() { do Thread::spawn {} }\n+    fn detached() { Thread::spawn(proc () {}) }\n }"}, {"sha": "482477b2f0eb9ec27d488c427477f89807d5c6eb", "filename": "src/libstd/run.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -223,22 +223,22 @@ impl Process {\n         let (p, ch) = SharedChan::new();\n         let ch_clone = ch.clone();\n \n-        do spawn {\n+        spawn(proc() {\n             let _guard = io::ignore_io_error();\n             let mut error = error;\n             match error {\n                 Some(ref mut e) => ch.send((2, e.read_to_end())),\n                 None => ch.send((2, ~[]))\n             }\n-        }\n-        do spawn {\n+        });\n+        spawn(proc() {\n             let _guard = io::ignore_io_error();\n             let mut output = output;\n             match output {\n                 Some(ref mut e) => ch_clone.send((1, e.read_to_end())),\n                 None => ch_clone.send((1, ~[]))\n             }\n-        }\n+        });\n \n         let status = self.finish();\n \n@@ -414,9 +414,9 @@ mod tests {\n         os::close(pipe_out.out as int);\n         os::close(pipe_err.out as int);\n \n-        do spawn {\n+        spawn(proc() {\n             writeclose(pipe_in.out, \"test\");\n-        }\n+        });\n         let actual = readclose(pipe_out.input);\n         readclose(pipe_err.input);\n         process.finish();"}, {"sha": "7feff127d691a029511e7af37995d1b7b6bfc761", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -425,7 +425,7 @@ mod tests {\n         static AMT: int = 100000;\n         let mut pool = BufferPool::<int>::new();\n         let (mut w, s) = pool.deque();\n-        let t = do Thread::start {\n+        let t = Thread::start(proc() {\n             let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n@@ -437,7 +437,7 @@ mod tests {\n                     Abort | Empty => {}\n                 }\n             }\n-        };\n+        });\n \n         for _ in range(0, AMT) {\n             w.push(1);\n@@ -451,7 +451,7 @@ mod tests {\n         static AMT: int = 100000;\n         let mut pool = BufferPool::<(int, int)>::new();\n         let (mut w, s) = pool.deque();\n-        let t = do Thread::start {\n+        let t = Thread::start(proc() {\n             let mut s = s;\n             let mut left = AMT;\n             while left > 0 {\n@@ -461,7 +461,7 @@ mod tests {\n                     Abort | Empty => {}\n                 }\n             }\n-        };\n+        });\n \n         for _ in range(0, AMT) {\n             w.push((1, 10));\n@@ -480,7 +480,7 @@ mod tests {\n \n         let threads = range(0, nthreads).map(|_| {\n             let s = s.clone();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     while (*unsafe_remaining).load(SeqCst) > 0 {\n@@ -493,7 +493,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }\n+            })\n         }).to_owned_vec();\n \n         while remaining.load(SeqCst) > 0 {\n@@ -522,9 +522,9 @@ mod tests {\n         let mut pool = BufferPool::<~int>::new();\n         let threads = range(0, AMT).map(|_| {\n             let (w, s) = pool.deque();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 stampede(w, s, 4, 10000);\n-            }\n+            })\n         }).to_owned_vec();\n \n         for thread in threads.move_iter() {\n@@ -543,7 +543,7 @@ mod tests {\n \n         let threads = range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n-            do Thread::start {\n+            Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     loop {\n@@ -555,7 +555,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }\n+            })\n         }).to_owned_vec();\n \n         let mut rng = rand::task_rng();\n@@ -606,7 +606,7 @@ mod tests {\n             let thread_box = unsafe {\n                 *cast::transmute::<&~AtomicUint,**mut AtomicUint>(&unique_box)\n             };\n-            (do Thread::start {\n+            (Thread::start(proc() {\n                 unsafe {\n                     let mut s = s;\n                     loop {\n@@ -620,7 +620,7 @@ mod tests {\n                         }\n                     }\n                 }\n-            }, unique_box)\n+            }), unique_box)\n         }));\n \n         let mut rng = rand::task_rng();"}, {"sha": "bb0e96f96de2b8417583d4f9e7119b3d2237a42b", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -177,21 +177,21 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = q.clone();\n             let chan = chan.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n                 chan.send(());\n-            }\n+            });\n         }\n \n         let mut completion_ports = ~[];\n         for _ in range(0, nthreads) {\n             let (completion_port, completion_chan) = Chan::new();\n             completion_ports.push(completion_port);\n             let q = q.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 let mut i = 0u;\n                 loop {\n@@ -204,7 +204,7 @@ mod tests {\n                     }\n                 }\n                 completion_chan.send(i);\n-            }\n+            });\n         }\n \n         for completion_port in completion_ports.mut_iter() {"}, {"sha": "1ec8ac5d83e055abe2ef14330c39585b5e8dd903", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -227,13 +227,13 @@ mod tests {\n         for _ in range(0, nthreads) {\n             let q = p.clone();\n             let chan = chan.clone();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n                 chan.send(());\n-            }\n+            });\n         }\n \n         let mut i = 0u;"}, {"sha": "35a5846f11aba287fc843ca4b16034d24b50dcbd", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -315,7 +315,7 @@ mod test {\n         fn stress_bound(bound: uint) {\n             let (c, mut p) = queue(bound, ());\n             let (port, chan) = Chan::new();\n-            do native::task::spawn {\n+            native::task::spawn(proc() {\n                 let mut c = c;\n                 for _ in range(0, 100000) {\n                     loop {\n@@ -327,7 +327,7 @@ mod test {\n                     }\n                 }\n                 chan.send(());\n-            }\n+            });\n             for _ in range(0, 100000) {\n                 p.push(1);\n             }"}, {"sha": "c8b690830866e9a763a9ce99bf53682298babc2a", "filename": "src/libstd/task.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -45,9 +45,9 @@\n  * # Example\n  *\n  * ```\n- * do spawn {\n+ * spawn(proc() {\n  *     log(error, \"Hello, World!\");\n- * }\n+ * })\n  * ```\n  */\n \n@@ -265,9 +265,9 @@ impl TaskBuilder {\n \n         let result = self.future_result();\n \n-        do self.spawn {\n+        self.spawn(proc() {\n             ch.send(f());\n-        }\n+        });\n \n         match result.recv() {\n             Ok(())     => Ok(po.recv()),\n@@ -365,83 +365,83 @@ pub fn failing() -> bool {\n \n #[test]\n fn test_unnamed_task() {\n-    do spawn {\n+    spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.is_none());\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_owned_named_task() {\n     let mut t = task();\n     t.name(~\"ada lovelace\");\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_static_named_task() {\n     let mut t = task();\n     t.name(\"ada lovelace\");\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_send_named_task() {\n     let mut t = task();\n     t.name(\"ada lovelace\".into_send_str());\n-    do t.spawn {\n+    t.spawn(proc() {\n         with_task_name(|name| {\n             assert!(name.unwrap() == \"ada lovelace\");\n         })\n-    }\n+    })\n }\n \n #[test]\n fn test_run_basic() {\n     let (po, ch) = Chan::new();\n-    do task().spawn {\n+    task().spawn(proc() {\n         ch.send(());\n-    }\n+    });\n     po.recv();\n }\n \n #[test]\n fn test_add_wrapper() {\n     let (po, ch) = Chan::new();\n     let mut b0 = task();\n-    do b0.add_wrapper |body| {\n+    b0.add_wrapper(proc(body) {\n         let ch = ch;\n         let result: proc() = proc() {\n             body();\n             ch.send(());\n         };\n         result\n-    };\n-    do b0.spawn { }\n+    });\n+    b0.spawn(proc() { });\n     po.recv();\n }\n \n #[test]\n fn test_future_result() {\n     let mut builder = task();\n     let result = builder.future_result();\n-    do builder.spawn {}\n+    builder.spawn(proc() {});\n     assert!(result.recv().is_ok());\n \n     let mut builder = task();\n     let result = builder.future_result();\n-    do builder.spawn {\n+    builder.spawn(proc() {\n         fail!();\n-    }\n+    });\n     assert!(result.recv().is_err());\n }\n \n@@ -454,19 +454,19 @@ fn test_back_to_the_future_result() {\n \n #[test]\n fn test_try_success() {\n-    match do try {\n+    match try(proc() {\n         ~\"Success!\"\n-    } {\n+    }) {\n         result::Ok(~\"Success!\") => (),\n         _ => fail!()\n     }\n }\n \n #[test]\n fn test_try_fail() {\n-    match do try {\n+    match try(proc() {\n         fail!()\n-    } {\n+    }) {\n         result::Err(_) => (),\n         result::Ok(()) => fail!()\n     }\n@@ -480,13 +480,13 @@ fn test_spawn_sched() {\n \n     fn f(i: int, ch: SharedChan<()>) {\n         let ch = ch.clone();\n-        do spawn {\n+        spawn(proc() {\n             if i == 0 {\n                 ch.send(());\n             } else {\n                 f(i - 1, ch);\n             }\n-        };\n+        });\n \n     }\n     f(10, ch);\n@@ -497,12 +497,12 @@ fn test_spawn_sched() {\n fn test_spawn_sched_childs_on_default_sched() {\n     let (po, ch) = Chan::new();\n \n-    do spawn {\n+    spawn(proc() {\n         let ch = ch;\n-        do spawn {\n+        spawn(proc() {\n             ch.send(());\n-        };\n-    };\n+        });\n+    });\n \n     po.recv();\n }\n@@ -514,10 +514,10 @@ fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n     let x = ~1;\n     let x_in_parent = ptr::to_unsafe_ptr(&*x) as uint;\n \n-    do spawnfn {\n+    spawnfn(proc() {\n         let x_in_child = ptr::to_unsafe_ptr(&*x) as uint;\n         ch.send(x_in_child);\n-    }\n+    });\n \n     let x_in_child = p.recv();\n     assert_eq!(x_in_parent, x_in_child);\n@@ -532,18 +532,18 @@ fn test_avoid_copying_the_body_spawn() {\n fn test_avoid_copying_the_body_task_spawn() {\n     avoid_copying_the_body(|f| {\n         let builder = task();\n-        do builder.spawn || {\n+        builder.spawn(proc() {\n             f();\n-        }\n+        });\n     })\n }\n \n #[test]\n fn test_avoid_copying_the_body_try() {\n     avoid_copying_the_body(|f| {\n-        do try || {\n+        try(proc() {\n             f()\n-        };\n+        });\n     })\n }\n \n@@ -575,9 +575,9 @@ fn test_simple_newsched_spawn() {\n \n #[test]\n fn test_try_fail_message_static_str() {\n-    match do try {\n+    match try(proc() {\n         fail!(\"static string\");\n-    } {\n+    }) {\n         Err(e) => {\n             type T = &'static str;\n             assert!(e.is::<T>());\n@@ -589,9 +589,9 @@ fn test_try_fail_message_static_str() {\n \n #[test]\n fn test_try_fail_message_owned_str() {\n-    match do try {\n+    match try(proc() {\n         fail!(~\"owned string\");\n-    } {\n+    }) {\n         Err(e) => {\n             type T = ~str;\n             assert!(e.is::<T>());\n@@ -603,9 +603,9 @@ fn test_try_fail_message_owned_str() {\n \n #[test]\n fn test_try_fail_message_any() {\n-    match do try {\n+    match try(proc() {\n         fail!(~413u16 as ~Any);\n-    } {\n+    }) {\n         Err(e) => {\n             type T = ~Any;\n             assert!(e.is::<T>());\n@@ -621,9 +621,9 @@ fn test_try_fail_message_any() {\n fn test_try_fail_message_unit_struct() {\n     struct Juju;\n \n-    match do try {\n+    match try(proc() {\n         fail!(Juju)\n-    } {\n+    }) {\n         Err(ref e) if e.is::<Juju>() => {}\n         Err(_) | Ok(()) => fail!()\n     }"}, {"sha": "87870ef033142c5b28998485babfaae2ab411907", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -41,18 +41,18 @@ pub fn run_in_bare_thread(f: proc()) {\n #[test]\n fn test_run_in_bare_thread() {\n     let i = 100;\n-    do run_in_bare_thread {\n+    run_in_bare_thread(proc() {\n         assert_eq!(i, 100);\n-    }\n+    });\n }\n \n #[test]\n fn test_run_in_bare_thread_exchange() {\n     // Does the exchange heap work without the runtime?\n     let i = ~100;\n-    do run_in_bare_thread {\n+    run_in_bare_thread(proc() {\n         assert!(i == ~100);\n-    }\n+    });\n }\n \n /// Dynamically inquire about whether we're running under V."}, {"sha": "39f0d7b5638bc366b5cef813ff2be6f8e9db9b6e", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -439,7 +439,7 @@ mod test {\n         let (p, c) = SharedChan::new();\n         for _ in range(0, 10) {\n             let c = c.clone();\n-            do spawn {\n+            spawn(proc() {\n                 for _ in range(0, 4) { task::deschedule() }\n                 unsafe {\n                     o.doit(|| {\n@@ -449,7 +449,7 @@ mod test {\n                     assert!(run);\n                 }\n                 c.send(());\n-            }\n+            });\n         }\n \n         unsafe {\n@@ -479,11 +479,11 @@ mod test {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n             lock.lock();\n-            let t = do Thread::start {\n+            let t = Thread::start(proc() {\n                 lock.lock();\n                 lock.signal();\n                 lock.unlock();\n-            };\n+            });\n             lock.wait();\n             lock.unlock();\n             t.join();"}, {"sha": "3b2c86c371217138a5cec130ebed2aeb007f8b28", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -179,12 +179,12 @@ mod tests {\n                 let (port, chan) = Chan::new();\n                 futures.push(port);\n \n-                do task::spawn {\n+                task::spawn(proc() {\n                     for _ in range(0u, count) {\n                         total.with(|count| **count += 1);\n                     }\n                     chan.send(());\n-                }\n+                });\n             };\n \n             for f in futures.mut_iter() { f.recv() }\n@@ -200,9 +200,9 @@ mod tests {\n             // accesses will also fail.\n             let x = Exclusive::new(1);\n             let x2 = x.clone();\n-            do task::try || {\n+            task::try(proc() {\n                 x2.with(|one| assert_eq!(*one, 2))\n-            };\n+            });\n             x.with(|one| assert_eq!(*one, 1));\n         }\n     }"}, {"sha": "3070ecde71e6be7e3f8591577faac41c0564306c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -539,7 +539,6 @@ impl Expr {\n #[deriving(Clone, Eq, Encodable, Decodable, IterBytes)]\n pub enum CallSugar {\n     NoSugar,\n-    DoSugar,\n     ForSugar\n }\n \n@@ -566,7 +565,6 @@ pub enum Expr_ {\n     ExprMatch(@Expr, ~[Arm]),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n     ExprProc(P<FnDecl>, P<Block>),\n-    ExprDoBody(@Expr),\n     ExprBlock(P<Block>),\n \n     ExprAssign(@Expr, @Expr),"}, {"sha": "d02f6384990a95e6d0334c398c2484c7573cbda4", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -752,7 +752,6 @@ pub fn noop_fold_expr<T: Folder>(e: @Expr, folder: &mut T) -> @Expr {\n         ExprUnary(callee_id, binop, ohs) => {\n             ExprUnary(folder.new_id(callee_id), binop, folder.fold_expr(ohs))\n         }\n-        ExprDoBody(f) => ExprDoBody(folder.fold_expr(f)),\n         ExprLit(_) => e.node.clone(),\n         ExprCast(expr, ty) => {\n             ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))"}, {"sha": "accf5e735404504f01ee4104e65e9e1fc4763dc0", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -29,9 +29,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n       | ast::ExprWhile(..)\n       | ast::ExprLoop(..)\n       | ast::ExprForLoop(..)\n-      | ast::ExprCall(_, _, ast::DoSugar)\n       | ast::ExprCall(_, _, ast::ForSugar)\n-      | ast::ExprMethodCall(_, _, _, _, ast::DoSugar)\n       | ast::ExprMethodCall(_, _, _, _, ast::ForSugar) => false,\n       _ => true\n     }"}, {"sha": "b4de4dabfc6d0495d19e1ab52e45c2f2f7a281a4", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 74, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,7 +13,7 @@\n use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n-use ast::{CallSugar, NoSugar, DoSugar};\n+use ast::{CallSugar, NoSugar};\n use ast::{BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{Provided, Public, Purity};\n@@ -24,7 +24,7 @@ use ast::{Crate, CrateConfig, Decl, DeclItem};\n use ast::{DeclLocal, DefaultBlock, UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n use ast::{ExprAssign, ExprAssignOp, ExprBinary, ExprBlock, ExprBox};\n-use ast::{ExprBreak, ExprCall, ExprCast, ExprDoBody};\n+use ast::{ExprBreak, ExprCall, ExprCast};\n use ast::{ExprField, ExprFnBlock, ExprIf, ExprIndex};\n use ast::{ExprLit, ExprLogLevel, ExprLoop, ExprMac};\n use ast::{ExprMethodCall, ExprParen, ExprPath, ExprProc};\n@@ -1796,9 +1796,6 @@ impl Parser {\n             return self.parse_if_expr();\n         } else if self.eat_keyword(keywords::For) {\n             return self.parse_for_expr(None);\n-        } else if self.eat_keyword(keywords::Do) {\n-            return self.parse_sugary_call_expr(lo, ~\"do\", DoSugar,\n-                                               ExprDoBody);\n         } else if self.eat_keyword(keywords::While) {\n             return self.parse_while_expr();\n         } else if Parser::token_is_lifetime(&self.token) {\n@@ -2541,75 +2538,6 @@ impl Parser {\n         self.mk_expr(lo, hi, ExprForLoop(pat, expr, loop_block, opt_ident))\n     }\n \n-\n-    // parse a 'do'.\n-    // the 'do' expression parses as a call, but looks like\n-    // a function call followed by a closure expression.\n-    pub fn parse_sugary_call_expr(&mut self,\n-                                  lo: BytePos,\n-                                  keyword: ~str,\n-                                  sugar: CallSugar,\n-                                  ctor: |v: @Expr| -> Expr_)\n-                                  -> @Expr {\n-        // Parse the callee `foo` in\n-        //    do foo || {\n-        //    do foo.bar || {\n-        // etc, or the portion of the call expression before the lambda in\n-        //    do foo() || {\n-        // or\n-        //    do foo.bar(a) || {\n-        // Turn on the restriction to stop at | or || so we can parse\n-        // them as the lambda arguments\n-        let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n-        match e.node {\n-            ExprCall(f, ref args, NoSugar) => {\n-                let block = self.parse_lambda_block_expr();\n-                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                            ctor(block));\n-                let args = vec::append_one((*args).clone(), last_arg);\n-                self.mk_expr(lo, block.span.hi, ExprCall(f, args, sugar))\n-            }\n-            ExprMethodCall(_, i, ref tps, ref args, NoSugar) => {\n-                let block = self.parse_lambda_block_expr();\n-                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                            ctor(block));\n-                let args = vec::append_one((*args).clone(), last_arg);\n-                let method_call = self.mk_method_call(i,\n-                                                      (*tps).clone(),\n-                                                      args,\n-                                                      sugar);\n-                self.mk_expr(lo, block.span.hi, method_call)\n-            }\n-            ExprField(f, i, ref tps) => {\n-                let block = self.parse_lambda_block_expr();\n-                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                            ctor(block));\n-                let method_call = self.mk_method_call(i,\n-                                                      (*tps).clone(),\n-                                                      ~[f, last_arg],\n-                                                      sugar);\n-                self.mk_expr(lo, block.span.hi, method_call)\n-            }\n-            ExprPath(..) | ExprCall(..) | ExprMethodCall(..) |\n-                ExprParen(..) => {\n-                let block = self.parse_lambda_block_expr();\n-                let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n-                                            ctor(block));\n-                let call = self.mk_call(e, ~[last_arg], sugar);\n-                self.mk_expr(lo, last_arg.span.hi, call)\n-            }\n-            _ => {\n-                // There may be other types of expressions that can\n-                // represent the callee in `do` expressions\n-                // but they aren't represented by tests\n-                debug!(\"sugary call on {:?}\", e.node);\n-                self.span_fatal(\n-                    e.span,\n-                    format!(\"`{}` must be followed by a block call\", keyword));\n-            }\n-        }\n-    }\n-\n     pub fn parse_while_expr(&mut self) -> @Expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();"}, {"sha": "68e2f44ebb18482a302609e6bd24e668604b75a4", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 39, "deletions": 40, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -433,51 +433,50 @@ declare_special_idents_and_keywords! {\n         (14,                         As,         \"as\");\n         (15,                         Break,      \"break\");\n         (16,                         Const,      \"const\");\n-        (17,                         Do,         \"do\");\n-        (18,                         Else,       \"else\");\n-        (19,                         Enum,       \"enum\");\n-        (20,                         Extern,     \"extern\");\n-        (21,                         False,      \"false\");\n-        (22,                         Fn,         \"fn\");\n-        (23,                         For,        \"for\");\n-        (24,                         If,         \"if\");\n-        (25,                         Impl,       \"impl\");\n-        (26,                         In,         \"in\");\n-        (27,                         Let,        \"let\");\n-        (28,                         __LogLevel, \"__log_level\");\n-        (29,                         Loop,       \"loop\");\n-        (30,                         Match,      \"match\");\n-        (31,                         Mod,        \"mod\");\n-        (32,                         Mut,        \"mut\");\n-        (33,                         Once,       \"once\");\n-        (34,                         Priv,       \"priv\");\n-        (35,                         Pub,        \"pub\");\n-        (36,                         Ref,        \"ref\");\n-        (37,                         Return,     \"return\");\n+        (17,                         Else,       \"else\");\n+        (18,                         Enum,       \"enum\");\n+        (19,                         Extern,     \"extern\");\n+        (20,                         False,      \"false\");\n+        (21,                         Fn,         \"fn\");\n+        (22,                         For,        \"for\");\n+        (23,                         If,         \"if\");\n+        (24,                         Impl,       \"impl\");\n+        (25,                         In,         \"in\");\n+        (26,                         Let,        \"let\");\n+        (27,                         __LogLevel, \"__log_level\");\n+        (28,                         Loop,       \"loop\");\n+        (29,                         Match,      \"match\");\n+        (30,                         Mod,        \"mod\");\n+        (31,                         Mut,        \"mut\");\n+        (32,                         Once,       \"once\");\n+        (33,                         Priv,       \"priv\");\n+        (34,                         Pub,        \"pub\");\n+        (35,                         Ref,        \"ref\");\n+        (36,                         Return,     \"return\");\n         // Static and Self are also special idents (prefill de-dupes)\n         (super::STATIC_KEYWORD_NAME, Static,     \"static\");\n         (super::SELF_KEYWORD_NAME,   Self,       \"self\");\n-        (38,                         Struct,     \"struct\");\n-        (39,                         Super,      \"super\");\n-        (40,                         True,       \"true\");\n-        (41,                         Trait,      \"trait\");\n-        (42,                         Type,       \"type\");\n-        (43,                         Unsafe,     \"unsafe\");\n-        (44,                         Use,        \"use\");\n-        (45,                         While,      \"while\");\n-        (46,                         Continue,   \"continue\");\n-        (47,                         Proc,       \"proc\");\n-        (48,                         Box,        \"box\");\n+        (37,                         Struct,     \"struct\");\n+        (38,                         Super,      \"super\");\n+        (39,                         True,       \"true\");\n+        (40,                         Trait,      \"trait\");\n+        (41,                         Type,       \"type\");\n+        (42,                         Unsafe,     \"unsafe\");\n+        (43,                         Use,        \"use\");\n+        (44,                         While,      \"while\");\n+        (45,                         Continue,   \"continue\");\n+        (46,                         Proc,       \"proc\");\n+        (47,                         Box,        \"box\");\n \n         'reserved:\n-        (49,                         Alignof,    \"alignof\");\n-        (50,                         Be,         \"be\");\n-        (51,                         Offsetof,   \"offsetof\");\n-        (52,                         Pure,       \"pure\");\n-        (53,                         Sizeof,     \"sizeof\");\n-        (54,                         Typeof,     \"typeof\");\n-        (55,                         Unsized,    \"unsized\");\n-        (56,                         Yield,      \"yield\");\n+        (48,                         Alignof,    \"alignof\");\n+        (49,                         Be,         \"be\");\n+        (50,                         Offsetof,   \"offsetof\");\n+        (51,                         Pure,       \"pure\");\n+        (52,                         Sizeof,     \"sizeof\");\n+        (53,                         Typeof,     \"typeof\");\n+        (54,                         Unsized,    \"unsized\");\n+        (55,                         Yield,      \"yield\");\n     }\n }\n "}, {"sha": "68efdf31e03147da6da6a229a5fa7873dca955f7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 20, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -1088,10 +1088,6 @@ pub fn print_call_pre(s: &mut State,\n                       base_args: &mut ~[@ast::Expr])\n                    -> Option<@ast::Expr> {\n     match sugar {\n-        ast::DoSugar => {\n-            head(s, \"do\");\n-            Some(base_args.pop().unwrap())\n-        }\n         ast::ForSugar => {\n             head(s, \"for\");\n             Some(base_args.pop().unwrap())\n@@ -1111,19 +1107,8 @@ pub fn print_call_post(s: &mut State,\n     }\n     if sugar != ast::NoSugar {\n         nbsp(s);\n-        match blk.unwrap().node {\n-          // need to handle closures specifically\n-          ast::ExprDoBody(e) => {\n-            end(s); // we close our head box; closure\n-                    // will create it's own.\n-            print_expr(s, e);\n-            end(s); // close outer box, as closures don't\n-          }\n-          _ => {\n-            // not sure if this can happen.\n-            print_expr(s, blk.unwrap());\n-          }\n-        }\n+        // not sure if this can happen\n+        print_expr(s, blk.unwrap());\n     }\n }\n \n@@ -1405,9 +1390,6 @@ pub fn print_expr(s: &mut State, expr: &ast::Expr) {\n         // empty box to satisfy the close.\n         ibox(s, 0);\n       }\n-      ast::ExprDoBody(body) => {\n-        print_expr(s, body);\n-      }\n       ast::ExprBlock(blk) => {\n         // containing cbox, will be closed by print-block at }\n         cbox(s, indent_unit);"}, {"sha": "7201fc3a380520f5f05731dad9b7586717bd631c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -665,8 +665,7 @@ pub fn walk_expr<E: Clone, V: Visitor<E>>(visitor: &mut V, expression: &Expr, en\n             visitor.visit_expr(right_expression, env.clone())\n         }\n         ExprAddrOf(_, subexpression) |\n-        ExprUnary(_, _, subexpression) |\n-        ExprDoBody(subexpression) => {\n+        ExprUnary(_, _, subexpression) => {\n             visitor.visit_expr(subexpression, env.clone())\n         }\n         ExprLit(_) => {}"}, {"sha": "3bf084b5fdae7abde835fc93f5ebd5bf767a6c03", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -12,8 +12,8 @@ use std::task;\n \n pub fn foo<T:Send + Clone>(x: T) -> Port<T> {\n     let (p, c) = Chan::new();\n-    do task::spawn() {\n+    task::spawn(proc() {\n         c.send(x.clone());\n-    }\n+    });\n     p\n }"}, {"sha": "aa4e0f1ae5809bf5ca10efd4b3293e50777cb2e9", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -64,17 +64,17 @@ fn run(args: &[~str]) {\n         let to_child = to_child.clone();\n         let mut builder = task::task();\n         worker_results.push(builder.future_result());\n-        do builder.spawn {\n+        builder.spawn(proc() {\n             for _ in range(0u, size / workers) {\n                 //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //error!(\"worker {:?} exiting\", i);\n-        }\n+        });\n     }\n-    do task::spawn || {\n+    task::spawn(proc() {\n         server(&from_parent, &to_parent);\n-    }\n+    });\n \n     for r in worker_results.iter() {\n         r.recv();"}, {"sha": "6ce0f9de8d0a237772cf5ddca820b794795198e0", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -58,33 +58,33 @@ fn run(args: &[~str]) {\n         let (from_parent, to_child) = Chan::new();\n         let mut builder = task::task();\n         worker_results.push(builder.future_result());\n-        do builder.spawn {\n+        builder.spawn(proc() {\n             for _ in range(0u, size / workers) {\n                 //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                 to_child.send(bytes(num_bytes));\n             }\n             //error!(\"worker {:?} exiting\", i);\n-        };\n+        });\n         from_parent\n     } else {\n         let (from_parent, to_child) = SharedChan::new();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n             let mut builder = task::task();\n             worker_results.push(builder.future_result());\n-            do builder.spawn {\n+            builder.spawn(proc() {\n                 for _ in range(0u, size / workers) {\n                     //error!(\"worker {:?}: sending {:?} bytes\", i, num_bytes);\n                     to_child.send(bytes(num_bytes));\n                 }\n                 //error!(\"worker {:?} exiting\", i);\n-            };\n+            });\n         }\n         from_parent\n     };\n-    do task::spawn || {\n+    task::spawn(proc() {\n         server(&from_parent, &to_parent);\n-    }\n+    });\n \n     for r in worker_results.iter() {\n         r.recv();"}, {"sha": "b1b2300466a5edb5fc56fee613b6dcd20a1dcc1e", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -91,9 +91,9 @@ fn main() {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan_2 = num_chan.clone();\n-        let new_future = do Future::spawn() {\n+        let new_future = Future::spawn(proc() {\n             thread_ring(i, msg_per_task, num_chan_2, num_port)\n-        };\n+        });\n         futures.push(new_future);\n         num_chan = new_chan;\n     };"}, {"sha": "d7bd0f2f6bd3da361f406fd23a18f98c47443513", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -87,9 +87,9 @@ fn main() {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n         let num_chan_2 = num_chan.clone();\n-        let new_future = do Future::spawn {\n+        let new_future = Future::spawn(proc() {\n             thread_ring(i, msg_per_task, num_chan_2, num_port)\n-        };\n+        });\n         futures.push(new_future);\n         num_chan = new_chan;\n     };"}, {"sha": "29904de897eba7782accc4b1299d90ba171e9b15", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -26,23 +26,23 @@ fn ping_pong_bench(n: uint, m: uint) {\n         // Create a stream B->A\n         let (pb,cb) = Chan::<()>::new();\n \n-        do spawn() || {\n+        spawn(proc() {\n             let chan = ca;\n             let port = pb;\n             n.times(|| {\n                 chan.send(());\n                 port.recv();\n             })\n-        }\n+        });\n \n-        do spawn() || {\n+        spawn(proc() {\n             let chan = cb;\n             let port = pa;\n             n.times(|| {\n                 port.recv();\n                 chan.send(());\n             })\n-        }\n+        });\n     }\n \n     m.times(|| {"}, {"sha": "59f5afa47dafd130151c709a82212d2065ffcb4a", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -23,9 +23,9 @@ fn parfib(n: uint) -> uint {\n     }\n \n     let (port,chan) = Chan::new();\n-    do spawn {\n+    spawn(proc() {\n         chan.send(parfib(n-1));\n-    };\n+    });\n     let m2 = parfib(n-2);\n     return (port.recv() + m2);\n }"}, {"sha": "f3bb168f65117febd5c48d0a1e1cddaa49658b4d", "filename": "src/test/bench/rt-spawn-rate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Frt-spawn-rate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-spawn-rate.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -27,7 +27,7 @@ fn main() {\n     };\n \n     n.times(|| {\n-        do spawn || {};\n+        spawn(proc() {});\n     })\n \n }"}, {"sha": "da658e6d041f734889810987f9973864b4443095", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -65,7 +65,7 @@ fn main() {\n     let mut messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n             use std::num::pow;\n             let iterations = pow(2, (max_depth - depth + min_depth) as uint);\n-            do Future::spawn {\n+            Future::spawn(proc() {\n                 let mut chk = 0;\n                 for i in range(1, iterations + 1) {\n                     let arena = TypedArena::new();\n@@ -75,7 +75,7 @@ fn main() {\n                 }\n                 format!(\"{}\\t trees of depth {}\\t check: {}\",\n                         iterations * 2, depth, chk)\n-            }\n+            })\n         }).to_owned_vec();\n \n     for message in messages.mut_iter() {"}, {"sha": "7281667e6769a62a4c4ffcd16415cca3e11d3cf4", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -152,13 +152,13 @@ fn rendezvous(nn: uint, set: ~[color]) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (from_rendezvous, to_creature) = Chan::new();\n-            do task::spawn {\n+            task::spawn(proc() {\n                 creature(ii,\n                          col,\n                          from_rendezvous,\n                          to_rendezvous.clone(),\n                          to_rendezvous_log.clone());\n-            }\n+            });\n             to_creature\n         }).collect();\n "}, {"sha": "375f9154841f4b73620c8bc27f718ebba4cb8472", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -168,9 +168,9 @@ fn main() {\n \n         let (from_parent, to_child) = Chan::new();\n \n-        do spawn {\n+        spawn(proc() {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n-        }\n+        });\n \n         to_child\n     }).collect::<~[Chan<~[u8]>]>();"}, {"sha": "040c8526ee04fdfedabfbe1b972c3638f86ca9df", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -79,9 +79,9 @@ fn stress(num_tasks: int) {\n     for i in range(0, num_tasks) {\n         let mut builder = task::task();\n         results.push(builder.future_result());\n-        do builder.spawn {\n+        builder.spawn(proc() {\n             stress_task(i);\n-        }\n+        });\n     }\n     for r in results.iter() {\n         r.recv();"}, {"sha": "d68ca4e0abbae800980bb452569c70bec031621c", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -41,13 +41,13 @@ fn mult(v: RWArc<~[f64]>, out: RWArc<~[f64]>, f: fn(&~[f64], uint) -> f64) {\n         let w = wait.clone();\n         let v = v.clone();\n         let out = out.clone();\n-        do spawn {\n+        spawn(proc() {\n             for i in range(chk, min(len, chk + chunk)) {\n                 let val = v.read(|v| f(v, i));\n                 out.write(|out| out[i] = val);\n             }\n             let _ = w;\n-        }\n+        });\n     }\n     let _ = wait.unwrap();\n }"}, {"sha": "7063194eab862d43fb794209c509ccf3ddcb45d0", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -23,17 +23,17 @@ fn start(n_tasks: int, token: int) {\n         let (next_p, ch) = Chan::new();\n         let imm_i = i;\n         let imm_p = p;\n-        do spawn {\n+        spawn(proc() {\n             roundtrip(imm_i, n_tasks, &imm_p, &ch);\n-        };\n+        });\n         p = next_p;\n         i += 1;\n     }\n     let imm_p = p;\n     let imm_ch = ch1;\n-    do spawn {\n+    spawn(proc() {\n         roundtrip(1, n_tasks, &imm_p, &imm_ch);\n-    }\n+    });\n }\n \n fn roundtrip(id: int, n_tasks: int, p: &Port<int>, ch: &Chan<int>) {"}, {"sha": "16a9c03225adb52656ea9703b7b9d7eca1a0a015", "filename": "src/test/bench/silly-test-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsilly-test-spawn.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -11,6 +11,6 @@\n // Useful smoketest for scheduler performance.\n fn main() {\n     for _ in range(1, 100_000) {\n-        do spawn { }\n+        spawn(proc() {})\n     }\n }"}, {"sha": "b55f471bdb24d40f6f7619b4b592c18dcd6eca8e", "filename": "src/test/bench/spawnone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fspawnone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Fspawnone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fspawnone.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -10,5 +10,5 @@\n \n // Useful for checking syscall usage of baseline scheduler usage\n fn main() {\n-    do spawn { }\n+    spawn(proc() {});\n }"}, {"sha": "58fdadc2064da35485a61f74fb7a312883b13ee5", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -34,9 +34,9 @@ fn main() {\n fn run(repeat: int, depth: int) {\n     for _ in range(0, repeat) {\n         info!(\"starting {:.4f}\", precise_time_s());\n-        do task::try {\n+        task::try(proc() {\n             recurse_or_fail(depth, None)\n-        };\n+        });\n         info!(\"stopping {:.4f}\", precise_time_s());\n     }\n }"}, {"sha": "b41f6bcc50ad85cb31d6a6f146e1c17a4760c8f3", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -26,7 +26,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    do spawn {\n+    spawn(proc() {\n         if gens_left & 1 == 1 {\n             task::deschedule(); // shake things up a bit\n         }\n@@ -35,7 +35,7 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n         } else {\n             c.send(())\n         }\n-    }\n+    });\n }\n \n fn main() {"}, {"sha": "052900102c9a27f8a06c6e600335580b995bca79", "filename": "src/test/bench/task-perf-linked-failure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-linked-failure.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -36,11 +36,11 @@ fn grandchild_group(num_tasks: uint) {\n     for _ in range(0, num_tasks) {\n         let ch = ch.clone();\n         let mut t = task::task();\n-        do t.spawn { // linked\n+        t.spawn(proc() { // linked\n             ch.send(());\n             let (p, _c) = stream::<()>();\n             p.recv(); // block forever\n-        }\n+        });\n     }\n     error!(\"Grandchild group getting started\");\n     for _ in range(0, num_tasks) {\n@@ -77,17 +77,17 @@ fn main() {\n     // Main group #0 waits for unsupervised group #1.\n     // Grandparent group #1 waits for middle group #2, then fails, killing #3.\n     // Middle group #2 creates grandchild_group #3, waits for it to be ready, exits.\n-    let x: result::Result<(), ~Any> = do task::try { // unlinked\n-        do spawn_supervised_blocking(\"grandparent\") {\n-            do spawn_supervised_blocking(\"middle\") {\n+    let x: result::Result<(), ~Any> = task::try(proc() { // unlinked\n+        spawn_supervised_blocking(\"grandparent\", proc() {\n+            spawn_supervised_blocking(\"middle\", proc() {\n                 grandchild_group(num_tasks);\n-            }\n+            });\n             // When grandchild group is ready to go, make the middle group exit.\n             error!(\"Middle group wakes up and exits\");\n-        }\n+        });\n         // Grandparent group waits for middle group to be gone, then fails\n         error!(\"Grandparent group wakes up and fails\");\n         fail!();\n-    };\n+    });\n     assert!(x.is_err());\n }"}, {"sha": "454c7e45cc163d9b0af20449579c408c623f76cc", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -21,9 +21,9 @@ fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n \n     let wait_ports: ~[Port<Chan<Chan<int>>>] = vec::from_fn(children, |_| {\n         let (wait_port, wait_chan) = stream::<Chan<Chan<int>>>();\n-        do task::spawn {\n+        task::spawn(proc() {\n             calc(children / 2, &wait_chan);\n-        }\n+        });\n         wait_port\n     });\n \n@@ -58,9 +58,9 @@ fn main() {\n \n     let children = from_str::<uint>(args[1]).unwrap();\n     let (wait_port, wait_chan) = stream();\n-    do task::spawn {\n+    task::spawn(proc() {\n         calc(children, &wait_chan);\n-    };\n+    });\n \n     let start_chan = wait_port.recv();\n     let (sum_port, sum_chan) = stream::<int>();"}, {"sha": "716dfe2c8b5c54e2b89af8f032d8615ac01fae77", "filename": "src/test/compile-fail/arc-rw-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-read-mode-shouldnt-escape.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     });\n     y.unwrap();\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).read |state| { assert!(*state == 1); }\n+    // (&option::unwrap(y)).read(|state| { assert!(*state == 1); })\n }"}, {"sha": "213bf48a08750446aa6220ce09e65a24f71cc739", "filename": "src/test/compile-fail/arc-rw-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farc-rw-write-mode-shouldnt-escape.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,5 +17,5 @@ fn main() {\n     x.write_downgrade(|write_mode| y = Some(write_mode));\n     y.unwrap();\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).write |state| { assert!(*state == 1); }\n+    // (&option::unwrap(y)).write(|state| { assert!(*state == 1); })\n }"}, {"sha": "c193288468a20ba3aa120c884469d332a2867b16", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,10 +17,10 @@ fn borrow(v: &int, f: |x: &int|) {\n fn box_imm() {\n     let v = ~3;\n     let _w = &v;\n-    do task::spawn {\n+    task::spawn(proc() {\n         info!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n-    }\n+    });\n \n     let v = ~3;\n     let _w = &v;"}, {"sha": "a836556dff88161fa89508cd998e9abcf8109eda", "filename": "src/test/compile-fail/do-lambda-requires-braces.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    do something\n-        |x| do somethingelse //~ ERROR: expected `{` but found `do`\n-        |y| say(x, y)\n-}"}, {"sha": "d16fa4eadd566b81a50f4f1407d16abd728d5e07", "filename": "src/test/compile-fail/do1.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo1.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,13 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let x = do y; //~ ERROR: expected `{` but found\n-}"}, {"sha": "309abe218f6f1bc55712130446824d7fcf6e7ef5", "filename": "src/test/compile-fail/do2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo2.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(f: proc(int) -> bool) -> bool { f(10i) }\n-\n-fn main() {\n-    assert!(do f() |i| { i == 10i } == 10i);\n-    //~^ ERROR: expected `bool` but found `int`\n-}"}, {"sha": "5fab2ed195cecdd0a1cd469effa23a82d48b2321", "filename": "src/test/compile-fail/issue-3044.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3044.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -10,9 +10,9 @@\n \n fn main() {\n     let needlesArr: ~[char] = ~['a', 'f'];\n-    do needlesArr.iter().fold() |x, y| {\n-    }\n-    //~^^ ERROR 1 parameter was supplied (including the closure passed by the `do` keyword)\n+    needlesArr.iter().fold(|x, y| {\n+    });\n+    //~^^ ERROR this function takes 2 parameters but 1 parameter was supplied\n     //\n     // the first error is, um, non-ideal.\n }"}, {"sha": "b2a0c8a02a90da117e82817dede7e08f6772fd85", "filename": "src/test/compile-fail/keyword-do-as-identifier.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fkeyword-do-as-identifier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Fcompile-fail%2Fkeyword-do-as-identifier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkeyword-do-as-identifier.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This file was auto-generated using 'src/etc/generate-keyword-tests.py do'\n-\n-fn main() {\n-    let do = \"foo\"; //~ error: ident\n-}"}, {"sha": "fe9c7ede83a0883e75c40fb38210e7ac907da88e", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -2,8 +2,8 @@ use std::task;\n \n fn main() {\n     let x = ~\"Hello world!\";\n-    do task::spawn {\n+    task::spawn(proc() {\n         println!(\"{}\", x);\n-    }\n+    });\n     println!(\"{}\", x); //~ ERROR use of moved value\n }"}, {"sha": "24a141c4799d520708ea88020c67da576935e005", "filename": "src/test/compile-fail/mutex-arc-nested.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fmutex-arc-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fmutex-arc-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutex-arc-nested.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,10 +17,10 @@ fn test_mutex_arc_nested() {\n     let arc = ~MutexArc::new(1);\n     let arc2 = ~MutexArc::new(*arc);\n \n-    do task::spawn || {\n+    task::spawn(proc() {\n         (*arc2).access(|mutex| { //~ ERROR instantiating a type parameter with an incompatible type\n         })\n-    };\n+    });\n }\n \n fn main() {}"}, {"sha": "5ae38e69ec0e30c52ba492dec58694705566a3c2", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -19,10 +19,10 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::Arc::new(v);\n \n-    do task::spawn() {\n+    task::spawn(proc() {\n         let v = arc_v.get();\n         assert_eq!(v[3], 4);\n-    };\n+    });\n \n     assert_eq!((arc_v.get())[2], 3);\n "}, {"sha": "c6c0ba41ab91a45ba21e0fb8af43b6566b61e662", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,10 +17,10 @@ fn main() {\n     let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     let arc_v = arc::Arc::new(v);\n \n-    do task::spawn() {\n+    task::spawn(proc() {\n         let v = arc_v.get();\n         assert_eq!(v[3], 4);\n-    };\n+    });\n \n     assert_eq!((arc_v.get())[2], 3); //~ ERROR use of moved value: `arc_v`\n "}, {"sha": "9e564e997e6739c91245e0f775d78f3f68be3788", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -32,8 +32,8 @@ fn main() {\n \n     let x = foo(Port(@()));\n \n-    do task::spawn {\n+    task::spawn(proc() {\n         let y = x;   //~ ERROR does not fulfill `Send`\n         error!(\"{:?}\", y);\n-    }\n+    });\n }"}, {"sha": "8d5e2229b2e5dc0a10d99eb772db3c6aba21af20", "filename": "src/test/compile-fail/once-cant-call-twice-on-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fonce-cant-call-twice-on-heap.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -22,8 +22,8 @@ fn foo(blk: proc()) {\n \n fn main() {\n     let x = arc::Arc::new(true);\n-    do foo {\n+    foo(proc() {\n         assert!(*x.get());\n         drop(x);\n-    }\n+    });\n }"}, {"sha": "0078841acb139b54a3a1c6c59c915ce4c20670be", "filename": "src/test/compile-fail/sync-rwlock-read-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-read-mode-shouldnt-escape.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         y = Some(x.downgrade(write_mode));\n     })\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).read { }\n+    // (&option::unwrap(y)).read(proc() { });\n }"}, {"sha": "6e9216830750b1d729d119a8ea32370860b14f6e", "filename": "src/test/compile-fail/sync-rwlock-write-mode-shouldnt-escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsync-rwlock-write-mode-shouldnt-escape.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -18,5 +18,5 @@ fn main() {\n         y = Some(write_mode);\n     });\n     // Adding this line causes a method unification failure instead\n-    // do (&option::unwrap(y)).write { }\n+    // (&option::unwrap(y)).write(proc() { })\n }"}, {"sha": "b998056176e39fd087b0cbca2d4462200d37b100", "filename": "src/test/run-fail/extern-fail.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fextern-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fextern-fail.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -41,11 +41,11 @@ fn count(n: uint) -> uint {\n }\n \n fn main() {\n-    do 10u.times {\n-        do task::spawn {\n+    10u.times(proc() {\n+        task::spawn(proc() {\n             let result = count(5u);\n             info!(\"result = %?\", result);\n             fail!();\n-        };\n-    }\n+        });\n+    });\n }"}, {"sha": "3f662e6d0e3e4ca673d4203253405ee42e9dc236", "filename": "src/test/run-fail/fail-task-name-none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-none.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,8 +13,8 @@\n use std::task;\n \n fn main() {\n-    do task::try {\n+    task::try(proc() {\n         fail!(\"test\");\n         1\n-    }.unwrap()\n+    }).unwrap()\n }"}, {"sha": "a1115a09fb1765d08fa2742a9c9dfe1acab04e15", "filename": "src/test/run-fail/fail-task-name-owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-owned.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -15,8 +15,8 @@ use std::task;\n fn main() {\n     let mut t = task::task();\n     t.name(~\"owned name\");\n-    do t.try {\n+    t.try(proc() {\n         fail!(\"test\");\n         1\n-    }.unwrap()\n+    }).unwrap()\n }"}, {"sha": "ca2472cfa55f159f2ac5b507f13befebbee3b92a", "filename": "src/test/run-fail/fail-task-name-send-str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-send-str.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,8 +13,8 @@\n fn main() {\n     let mut t = ::std::task::task();\n     t.name(\"send name\".to_send_str());\n-    do t.try {\n+    t.try(proc() {\n         fail!(\"test\");\n         3\n-    }.unwrap()\n+    }).unwrap()\n }"}, {"sha": "2303ab102d409bedc5d5cc50fe753d353d07772d", "filename": "src/test/run-fail/fail-task-name-static.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail-task-name-static.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     let mut t = ::std::task::task();\n     t.name(\"static name\");\n-    do t.try {\n+    t.try(proc() {\n         fail!(\"test\");\n-    }.unwrap()\n+    }).unwrap()\n }"}, {"sha": "1094227770efd9e6a63eee7dcd7fc9138bf585d8", "filename": "src/test/run-fail/morestack2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack2.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -62,8 +62,8 @@ fn and_then_get_big_again(x:int) -> and_then_get_big_again {\n }\n \n fn main() {\n-    do task::spawn {\n+    task::spawn(proc() {\n         let r = and_then_get_big_again(4);\n         getbig_call_c_and_fail(10000);\n-    };\n+    });\n }"}, {"sha": "6acfa0b79f4100a750b40a505ad437f679fa5ebf", "filename": "src/test/run-fail/morestack3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack3.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -48,7 +48,7 @@ fn and_then_get_big_again(x:int) -> and_then_get_big_again {\n }\n \n fn main() {\n-    do task::spawn {\n+    task::spawn(proc() {\n         getbig_and_fail(400);\n-    };\n+    });\n }"}, {"sha": "8be8e6b44f6afe9232bac06178105987058c4ef7", "filename": "src/test/run-fail/morestack4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fmorestack4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fmorestack4.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -41,7 +41,7 @@ fn and_then_get_big_again(x:int) -> and_then_get_big_again {\n }\n \n fn main() {\n-    do task::spawn {\n+    task::spawn(proc() {\n         getbig_and_fail(1);\n-    };\n+    });\n }"}, {"sha": "20d8a543ae1966483a0695311e50f2483efdda58", "filename": "src/test/run-fail/native-failure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnative-failure.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,7 +17,7 @@ extern mod native;\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    do native::start(argc, argv) {\n+    native::start(argc, argv, proc() {\n         fail!();\n-    }\n+    })\n }"}, {"sha": "d19788d8b5b84f72fa9faf00e7f2b5e2f7f3796b", "filename": "src/test/run-fail/rt-set-exit-status-fail2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-fail2.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -34,8 +34,8 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    do task::spawn {\n+    task::spawn(proc() {\n       let _i = r(5);\n-    };\n+    });\n     fail!();\n }"}, {"sha": "94119cc0278dab39aff0fb42326c403acaafe35e", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,9 +17,9 @@ extern mod green;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    do green::start(argc, argv) {\n-        do spawn {\n+    green::start(argc, argv, proc() {\n+        spawn(proc() {\n             println!(\"hello\");\n-        }\n-    }\n+        });\n+    })\n }"}, {"sha": "2a783606d944acd2ac5589e5776135b0a97c4655", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -16,9 +16,9 @@ extern mod native;\n \n #[no_mangle] // this needs to get called from C\n pub extern \"C\" fn foo(argc: int, argv: **u8) -> int {\n-    do native::start(argc, argv) {\n-        do spawn {\n+    native::start(argc, argv, proc() {\n+        spawn(proc() {\n             println!(\"hello\");\n-        }\n-    }\n+        });\n+    })\n }"}, {"sha": "96dabf8f07699c6fa01fc362b65dbea69f6f13ce", "filename": "src/test/run-make/static-unwinding/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fstatic-unwinding%2Fmain.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -12,11 +12,11 @@ impl Drop for A {\n }\n \n fn main() {\n-    do task::try {\n+    task::try(proc() {\n         let _a = A;\n         lib::callback(|| fail!());\n         1\n-    };\n+    });\n \n     unsafe {\n         assert!(lib::statik == 1);"}, {"sha": "05225eb0e7adabdadd77e2c22a0e9133929ac73a", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -75,11 +75,11 @@ fn main() {\n \n fn check_pp<T>(cx: fake_ext_ctxt,\n                expr: T, f: |pprust::ps, T|, expect: ~str) {\n-    let s = do io::with_str_writer |wr| {\n+    let s = io::with_str_writer(|wr| {\n         let pp = pprust::rust_printer(wr, cx.parse_sess().interner);\n         f(pp, expr);\n         pp::eof(pp.s);\n-    };\n+    });\n     stdout().write_line(s);\n     if expect != ~\"\" {\n         error!(\"expect: '%s', got: '%s'\", expect, s);"}, {"sha": "f2149e23210ccb256cbf5af0a46eddbbbf83ff1c", "filename": "src/test/run-pass/block-arg-can-be-followed-by-binop.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-binop.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn add(x: proc(f64) -> f64) -> f64 {\n-    x(10.0)\n-}\n-\n-pub fn main() {\n-    // Trailing expressions don't require parentheses:\n-    let y = do add |x| { x + 10.0 } + 10.0;\n-\n-    assert_eq!(y, 30.0);\n-}"}, {"sha": "2cdf0a1ffe1f1e0dcc05ff7861d8552d1a73af2f", "filename": "src/test/run-pass/block-arg-can-be-followed-by-block-arg.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-block-arg.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(_: proc()) -> proc(proc() -> uint) {\n-    proc(_: proc() -> uint) {}\n-}\n-\n-pub fn main() {\n-    do do f {} { 20 };\n-}"}, {"sha": "544367bdfa9d5c9b9333750f63fe10ea45c8709e", "filename": "src/test/run-pass/block-arg-can-be-followed-by-call.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-can-be-followed-by-call.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(_: proc()) -> proc(uint) -> uint {\n-    proc(x: uint) { x }\n-}\n-\n-pub fn main() {\n-    let z = do f {} (22u);\n-    assert_eq!(z, 22u);\n-}"}, {"sha": "083217132de1125e70b21a2d2ab2baeac2b6ecb5", "filename": "src/test/run-pass/block-arg-in-parentheses.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-in-parentheses.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,38 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(_: proc(int, int) -> int) -> int {\n-    10\n-}\n-\n-fn w_semi() {\n-    // the semicolon causes compiler not to\n-    // complain about the ignored return value:\n-    do f |x, y| { x+y };\n-}\n-\n-fn w_paren1() -> int {\n-    (do f |x, y| { x+y }) - 10\n-}\n-\n-fn w_paren2() -> int {\n-    (do f |x, y| { x+y } - 10)\n-}\n-\n-fn w_ret() -> int {\n-    return do f |x, y| { x+y } - 10;\n-}\n-\n-pub fn main() {\n-    w_semi();\n-    w_paren1();\n-    w_paren2();\n-    w_ret();\n-}"}, {"sha": "87a6cbd6fc2f33aa4de1b742b920e4ebf0e6e51d", "filename": "src/test/run-pass/block-arg-used-as-any.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-used-as-any.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,18 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn call_any(f: proc() -> uint) -> uint {\n-    return f();\n-}\n-\n-pub fn main() {\n-    let x_r = do call_any { 22u };\n-    assert_eq!(x_r, 22u);\n-}"}, {"sha": "d59804b23954e17fa380451779e55eef48c7cf51", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -25,49 +25,4 @@ pub fn main() {\n         info!(\"{:?}\", *i);\n     }\n \n-    // Usable at all:\n-    do inty |x| { x };\n-\n-    // Higher precedence than assignments:\n-    let result = do inty |e| { e };\n-    assert_eq!(result, 100);\n-\n-    // Higher precedence than unary operations:\n-    let stringy = do inty |e| { e }.to_str();\n-    assert!(do booly |_| { true });\n-    assert!(!do booly |_| { false });\n-\n-    // Usable in funny statement-like forms:\n-    if !do booly |_| { true } {\n-        assert!(false);\n-    }\n-    match do booly |_| { false } {\n-        true => { fail!(\"incorrect answer.\"); }\n-        false => { }\n-    }\n-    match 3 {\n-      _ if do booly |_| { true } => {\n-      }\n-      _ => {\n-        fail!(\"wrong answer.\");\n-      }\n-    }\n-\n-\n-    // Lower precedence than binary operations:\n-    let w = do inty |_| { 10 } + 10;\n-    let y = do inty |_| { 10 } + 10;\n-    let z = 10 + do inty |_| { 10 };\n-    assert_eq!(w, y);\n-    assert_eq!(y, z);\n-\n-    // In the tail of a block\n-    let w = if true {\n-        do booly |_| {\n-            true\n-        }\n-    } else {\n-        false\n-    };\n-    assert!(w);\n }"}, {"sha": "874075e8c1400bb1a71f4c45ffbecd06de298218", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -28,9 +28,9 @@ use std::task;\n \n fn foo(x: ()) -> Port<()> {\n     let (p, c) = Chan::<()>::new();\n-    do task::spawn() {\n+    task::spawn(proc() {\n         c.send(x);\n-    }\n+    });\n     p\n }\n "}, {"sha": "171424d8b3b6905ffb0bd4f14be850ac6f0c8c43", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -30,18 +30,18 @@ impl Logger for MyWriter {\n \n #[start]\n fn start(argc: int, argv: **u8) -> int {\n-    do native::start(argc, argv) {\n+    native::start(argc, argv, proc() {\n         main();\n-    }\n+    })\n }\n \n fn main() {\n     let (p, c) = Chan::new();\n     let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n-    do spawn {\n+    spawn(proc() {\n         set_logger(~MyWriter(w) as ~Logger);\n         debug!(\"debug\");\n         info!(\"info\");\n-    }\n+    });\n     assert_eq!(r.read_to_str(), ~\"info\\n\");\n }"}, {"sha": "66fac94ba51e1b41c61af71caeb5d4b0c8a03f09", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -16,8 +16,8 @@ fn foo(blk: proc()) {\n \n pub fn main() {\n     let (p,c) = Chan::new();\n-    do foo {\n+    foo(proc() {\n         c.send(());\n-    }\n+    });\n     p.recv();\n }"}, {"sha": "3ed77cd9fb767cdccfc621e0e8f966b108ebd339", "filename": "src/test/run-pass/closure-reform.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fclosure-reform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-reform.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -38,11 +38,6 @@ fn call_bare_again(f: extern \"Rust\" fn(&str)) {\n pub fn main() {\n     // Procs\n \n-    let greeting = ~\"Hi \";\n-    do call_it |s| {\n-        greeting + s\n-    }\n-\n     let greeting = ~\"Hello \";\n     call_it(proc(s) {\n         greeting + s"}, {"sha": "56ba2ffddbb4bd9959c53101b1a7bad2399bd0c4", "filename": "src/test/run-pass/do-empty-args.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-empty-args.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,23 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// no-reformat\n-// Testing various forms of `do` with empty arg lists\n-\n-fn f(_f: proc() -> bool) -> bool {\n-    true\n-}\n-\n-pub fn main() {\n-    do f() || { true };\n-    do f() { true };\n-    do f || { true };\n-    do f { true };\n-}"}, {"sha": "0df5c82ab077f33aa81f3bff4466cfdd6a7bde45", "filename": "src/test/run-pass/do-no-args.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo-no-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo-no-args.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Testing that we can drop the || in do exprs\n-\n-fn f(_f: proc() -> bool) -> bool { true }\n-\n-fn d(_f: proc()) { }\n-\n-pub fn main() {\n-    do d { }\n-}"}, {"sha": "bdbad74b32095ce721a3ecbb6b516a00c175b56d", "filename": "src/test/run-pass/do1.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo1.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(f: proc(int)) { f(10) }\n-\n-pub fn main() {\n-    do f() |i| { assert!(i == 10) }\n-}"}, {"sha": "f509f7b454d35afeba0d2bb30dd63fc808af84e3", "filename": "src/test/run-pass/do2.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo2.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(f: proc(int) -> int) -> int { f(10) }\n-\n-pub fn main() {\n-    assert_eq!(do f() |i| { i }, 10);\n-}"}, {"sha": "cdba14f1deda4a182c0d306a0826b60a10bfff99", "filename": "src/test/run-pass/do3.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87004db1137c9126ecc8834b1c881c2ef09ee8ef/src%2Ftest%2Frun-pass%2Fdo3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdo3.rs?ref=87004db1137c9126ecc8834b1c881c2ef09ee8ef", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn f(f: proc(int) -> int) -> int { f(10) }\n-\n-pub fn main() {\n-    assert_eq!(do f |i| { i }, 10);\n-}"}, {"sha": "500ae8951ec4aa72459d3f84f251f2e03808b92d", "filename": "src/test/run-pass/extern-call-deep2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-deep2.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -40,9 +40,9 @@ fn count(n: uint) -> uint {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    do task::spawn {\n+    task::spawn(proc() {\n         let result = count(1000u);\n         info!(\"result = {}\", result);\n         assert_eq!(result, 1000u);\n-    };\n+    });\n }"}, {"sha": "c35e84154d80ba48bc9eede4d36fab66ce068a64", "filename": "src/test/run-pass/extern-call-scrub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-call-scrub.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -44,9 +44,9 @@ fn count(n: uint) -> uint {\n pub fn main() {\n     // Make sure we're on a task with small Rust stacks (main currently\n     // has a large stack)\n-    do task::spawn {\n+    task::spawn(proc() {\n         let result = count(12u);\n         info!(\"result = {}\", result);\n         assert_eq!(result, 2048u);\n-    };\n+    });\n }"}, {"sha": "26c7e6881a6c42134b5117339f81e1248936117a", "filename": "src/test/run-pass/extern-stress.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-stress.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -42,8 +42,8 @@ fn count(n: uint) -> uint {\n \n pub fn main() {\n     100u.times(|| {\n-        do task::spawn {\n+        task::spawn(proc() {\n             assert_eq!(count(5u), 16u);\n-        };\n+        });\n     })\n }"}, {"sha": "da26f92ecdf3233048edf7d884da6f022718e8a1", "filename": "src/test/run-pass/extern-yield.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fextern-yield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fextern-yield.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -39,10 +39,10 @@ fn count(n: uint) -> uint {\n \n pub fn main() {\n     10u.times(|| {\n-        do task::spawn {\n+        task::spawn(proc() {\n             let result = count(5u);\n             info!(\"result = {}\", result);\n             assert_eq!(result, 16u);\n-        };\n+        });\n     })\n }"}, {"sha": "be4a497989ce8d239ed6f2d1a1e19c88ca65a4a9", "filename": "src/test/run-pass/fail-in-dtor-drops-fields.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffail-in-dtor-drops-fields.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -33,9 +33,9 @@ impl Drop for B {\n }\n \n pub fn main() {\n-    let ret = do task::try {\n+    let ret = task::try(proc() {\n         let _a = A { b: B { foo: 3 } };\n-    };\n+    });\n     assert!(ret.is_err());\n     unsafe { assert!(dropped); }\n }"}, {"sha": "daaaac93791bd38b8da3e0c7d21bf94c6f3f2d3b", "filename": "src/test/run-pass/foreign-call-no-runtime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeign-call-no-runtime.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -10,10 +10,10 @@ extern {\n \n pub fn main() {\n     unsafe {\n-        do run_in_bare_thread() {\n+        run_in_bare_thread(proc() {\n             let i = &100;\n             rust_dbg_call(callback, cast::transmute(i));\n-        }\n+        });\n     }\n }\n "}, {"sha": "633c096b689201fb491e2dd836bcfecd9a5f0e81", "filename": "src/test/run-pass/infinite-loops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Finfinite-loops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfinite-loops.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -17,13 +17,13 @@\n extern mod extra;\n \n fn loopy(n: int) {\n-    if n > 0 { do spawn { loopy(n - 1) }; do spawn { loopy(n - 1) }; }\n+    if n > 0 { spawn(proc() { loopy(n - 1) }); spawn(proc() { loopy(n - 1) }); }\n     loop { }\n }\n \n pub fn main() {\n     // Commenting this out, as this will hang forever otherwise.\n     // Even after seeing the comment above, I'm not sure what the\n     // intention of this test is.\n-    // do spawn { loopy(5) };\n+    // spawn(proc() { loopy(5) });\n }"}, {"sha": "cef183e5f33c772fc333b6df4dbd6a74c3f85270", "filename": "src/test/run-pass/issue-2185.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-2185.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2185.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -51,16 +51,16 @@ impl iterable<uint> for 'static ||uint|| {\n }\n \n fn filter<A,IA:iterable<A>>(self: IA, prd: 'static |A| -> bool, blk: |A|) {\n-    do self.iter |a| {\n+    self.iter(|a| {\n         if prd(a) { blk(a) }\n-    }\n+    });\n }\n \n fn foldl<A,B,IA:iterable<A>>(self: IA, b0: B, blk: |B, A| -> B) -> B {\n     let mut b = b0;\n-    do self.iter |a| {\n+    self.iter(|a| {\n         b = blk(b, a);\n-    }\n+    });\n     b\n }\n "}, {"sha": "49b7e50c01e61b942b1f1abb9ca1d654ef90c5e1", "filename": "src/test/run-pass/issue-3168.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-3168.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3168.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -16,19 +16,19 @@ use std::task;\n \n pub fn main() {\n     let (p,c) = comm::stream();\n-    do task::try || {\n+    task::try(|| {\n         let (p2,c2) = comm::stream();\n-        do task::spawn || {\n+        task::spawn(|| {\n             p2.recv();\n             error!(\"sibling fails\");\n             fail!();\n-        }\n+        });\n         let (p3,c3) = comm::stream();\n         c.send(c3);\n         c2.send(());\n         error!(\"child blocks\");\n         p3.recv();\n-    };\n+    });\n     error!(\"parent tries\");\n     assert!(!p.recv().try_send(()));\n     error!(\"all done!\");"}, {"sha": "bcda2e27614c687f1da1d8a2bebac62d311d7cea", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -12,16 +12,15 @@ enum Msg\n }\n \n fn foo(name: ~str, samples_chan: Chan<Msg>) {\n-    do task::spawn\n-    {\n+    task::spawn(proc() {\n         let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {\n             for i in range(0u, buffer.len()) {\n                 error!(\"{}: {}\", i, buffer[i])\n             }\n         };\n         samples_chan.send(GetSamples(name.clone(), callback));\n-    };\n+    });\n }\n \n pub fn main() {}"}, {"sha": "173f76434d303b0feb0f58296e48e48bad7f1379", "filename": "src/test/run-pass/issue-4241.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4241.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4241.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -45,13 +45,13 @@ priv fn parse_data(len: uint, io: @io::Reader) -> Result {\n \n priv fn parse_list(len: uint, io: @io::Reader) -> Result {\n   let mut list: ~[Result] = ~[];\n-    do len.times {\n+    len.times(proc() {\n     let v =\n         match io.read_char() {\n         '$' => parse_bulk(io),\n         ':' => parse_int(io),\n          _ => fail!()\n-    };\n+    });\n     list.push(v);\n     }\n   return List(list);\n@@ -119,11 +119,11 @@ fn query(cmd: ~[~str], sb: TcpSocketBuf) -> Result {\n \n fn query2(cmd: ~[~str]) -> Result {\n   let _cmd = cmd_to_str(cmd);\n-    do io::with_str_reader(~\"$3\\r\\nXXX\\r\\n\") |sb| {\n+    io::with_str_reader(~\"$3\\r\\nXXX\\r\\n\")(|sb| {\n     let res = parse_response(@sb as @io::Reader);\n     println!(\"{:?}\", res);\n     res\n-    }\n+    });\n }\n \n "}, {"sha": "8f2d9f32440bb186b18d0df39a20b4a309268b11", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,9 +13,9 @@ use std::io::println;\n pub fn main() {\n     let (port, chan) = Chan::new();\n \n-    do spawn {\n+    spawn(proc() {\n         println(port.recv());\n-    }\n+    });\n \n     chan.send(\"hello, world\");\n }"}, {"sha": "8fbc35c72005ac673c8c767e7fd6dde6d757a5d7", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -13,9 +13,9 @@ use std::task;\n pub fn main() {\n     let (port, chan) = Chan::<&'static str>::new();\n \n-    do task::spawn {\n+    task::spawn(proc() {\n         assert_eq!(port.recv(), \"hello, world\");\n-    }\n+    });\n \n     chan.send(\"hello, world\");\n }"}, {"sha": "3f45e864da35af1251bf0631f67a453714f49aa0", "filename": "src/test/run-pass/kindck-implicit-close-over-mut-var.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fkindck-implicit-close-over-mut-var.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -16,10 +16,10 @@ fn foo() {\n     // Here, i is *copied* into the proc (heap closure).\n     // Requires allocation.  The proc's copy is not mutable.\n     let mut i = 0;\n-    do task::spawn {\n+    task::spawn(proc() {\n         user(i);\n         println!(\"spawned {}\", i)\n-    }\n+    });\n     i += 1;\n     println!(\"original {}\", i)\n }\n@@ -29,9 +29,9 @@ fn bar() {\n     // mutable outside of the proc.\n     let mut i = 0;\n     while i < 10 {\n-        do task::spawn {\n+        task::spawn(proc() {\n             user(i);\n-        }\n+        });\n         i += 1;\n     }\n }\n@@ -40,11 +40,11 @@ fn car() {\n     // Here, i must be shadowed in the proc to be mutable.\n     let mut i = 0;\n     while i < 10 {\n-        do task::spawn {\n+        task::spawn(proc() {\n             let mut i = i;\n             i += 1;\n             user(i);\n-        }\n+        });\n         i += 1;\n     }\n }"}, {"sha": "d81b5818d6693a53ea00bd506cb72b5b09a2a5c5", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -26,12 +26,12 @@ impl fmt::Default for Foo {\n \n pub fn main() {\n     let (p,c) = Chan::new();\n-    do spawn {\n+    spawn(proc() {\n         let mut f = Foo(Cell::new(0));\n         debug!(\"{}\", f);\n         let Foo(ref mut f) = f;\n         assert!(f.get() == 1);\n         c.send(());\n-    }\n+    });\n     p.recv();\n }"}, {"sha": "eb347ab28ff97b1688bb5e4725f4dc9479b0dd21", "filename": "src/test/run-pass/moves-based-on-type-capture-clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmoves-based-on-type-capture-clause.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -2,7 +2,7 @@ use std::task;\n \n pub fn main() {\n     let x = ~\"Hello world!\";\n-    do task::spawn {\n+    task::spawn(proc() {\n         println!(\"{}\", x);\n-    }\n+    });\n }"}, {"sha": "8907db04dadc0b6230f41275c7d3a707dc7d5219", "filename": "src/test/run-pass/native-always-waits.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-always-waits.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -18,11 +18,11 @@ static mut set: bool = false;\n #[start]\n fn start(argc: int, argv: **u8) -> int {\n     // make sure that native::start always waits for all children to finish\n-    do native::start(argc, argv) {\n-        do spawn {\n+    native::start(argc, argv, proc() {\n+        spawn(proc() {\n             unsafe { set = true; }\n-        }\n-    };\n+        });\n+    });\n \n     // if we didn't set the global, then return a nonzero code\n     if unsafe {set} {0} else {1}"}, {"sha": "f9567858022b33d306027fe511cfabc25897a8bd", "filename": "src/test/run-pass/no-landing-pads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fno-landing-pads.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -24,9 +24,9 @@ impl Drop for A {\n }\n \n fn main() {\n-    do task::try::<()> {\n+    task::try::<()>(proc() {\n         let _a = A;\n         fail!();\n-    };\n+    });\n     assert!(unsafe { !HIT });\n }"}, {"sha": "bc56712ee3bc1b2b2947c6e8c564b60f13e6a728", "filename": "src/test/run-pass/once-move-out-on-heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fonce-move-out-on-heap.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -22,8 +22,8 @@ fn foo(blk: proc()) {\n \n pub fn main() {\n     let x = arc::Arc::new(true);\n-    do foo {\n+    foo(proc() {\n         assert!(*x.get());\n         drop(x);\n-    }\n+    });\n }"}, {"sha": "0527f47c112e012dbf1c9d50640440b269fed496", "filename": "src/test/run-pass/preempt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -29,9 +29,9 @@ pub fn main() {\n     let (port, chan) = stream();\n \n     info!(\"main started\");\n-    do spawn {\n+    spawn(proc() {\n         starve_main(port);\n-    };\n+    });\n     let mut i: int = 0;\n     info!(\"main waiting for alive signal\");\n     chan.send(i);"}, {"sha": "474606ad347bd6747933b7509b24f03959021eae", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -27,12 +27,12 @@ fn test(f: int) -> test {\n pub fn main() {\n     let (p, c) = Chan::new();\n \n-    do task::spawn() {\n+    task::spawn(proc() {\n         let (pp, cc) = Chan::new();\n         c.send(cc);\n \n         let _r = pp.recv();\n-    }\n+    });\n \n     p.recv().send(test(42));\n }"}, {"sha": "f6f6f3ba240cfd2dcaf1b3ef685442e5d35a1e9d", "filename": "src/test/run-pass/task-comm-12.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-12.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -20,9 +20,9 @@ fn test00() {\n     let i: int = 0;\n     let mut builder = task::task();\n     let mut result = builder.future_result();\n-    do builder.spawn {\n+    builder.spawn(proc() {\n         start(i)\n-    }\n+    });\n \n     // Sleep long enough for the task to finish.\n     let mut i = 0;"}, {"sha": "8622ff7608999ed45e77151e7d1e9ae4f1019140", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -31,21 +31,21 @@ fn test00() {\n     let number_of_messages: int = 10;\n \n     let c = ch.clone();\n-    do task::spawn || {\n+    task::spawn(proc() {\n         test00_start(&c, number_of_messages * 0, number_of_messages);\n-    }\n+    });\n     let c = ch.clone();\n-    do task::spawn || {\n+    task::spawn(proc() {\n         test00_start(&c, number_of_messages * 1, number_of_messages);\n-    }\n+    });\n     let c = ch.clone();\n-    do task::spawn || {\n+    task::spawn(proc() {\n         test00_start(&c, number_of_messages * 2, number_of_messages);\n-    }\n+    });\n     let c = ch.clone();\n-    do task::spawn || {\n+    task::spawn(proc() {\n         test00_start(&c, number_of_messages * 3, number_of_messages);\n-    }\n+    });\n \n     let mut i: int = 0;\n     while i < number_of_messages {"}, {"sha": "feae49ffeb83c31d23c317e1b04a0483db2e3ea3", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -29,10 +29,10 @@ fn test00() {\n \n     let mut builder = task::task();\n     let result = builder.future_result();\n-    do builder.spawn {\n+    builder.spawn(proc() {\n         let mut ch = ch;\n         test00_start(&mut ch, number_of_messages);\n-    }\n+    });\n \n     let mut i: int = 0;\n     while i < number_of_messages {"}, {"sha": "a4be47323e5b99e126d60551f16951a572113d39", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -56,10 +56,10 @@ fn joinable(f: proc()) -> Port<bool> {\n         *b = true;\n     }\n     let (p, c) = stream();\n-    do task::spawn_unlinked {\n+    task::spawn_unlinked(proc() {\n         let ccc = c;\n         wrapper(ccc, f)\n-    }\n+    });\n     p\n }\n "}, {"sha": "2bf18e1ae1d5f67635e4b29eb3c0f8293f8b997f", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -71,13 +71,13 @@ pub fn main() {\n                          ~dogge2 as ~Pet:Freeze+Send]);\n     let (p1,c1) = Chan::new();\n     let arc1 = arc.clone();\n-    do task::spawn { check_legs(arc1); c1.send(()); }\n+    task::spawn(proc() { check_legs(arc1); c1.send(()); });\n     let (p2,c2) = Chan::new();\n     let arc2 = arc.clone();\n-    do task::spawn { check_names(arc2); c2.send(()); }\n+    task::spawn(proc() { check_names(arc2); c2.send(()); });\n     let (p3,c3) = Chan::new();\n     let arc3 = arc.clone();\n-    do task::spawn { check_pedigree(arc3); c3.send(()); }\n+    task::spawn(proc() { check_pedigree(arc3); c3.send(()); });\n     p1.recv();\n     p2.recv();\n     p3.recv();"}, {"sha": "04507dd01ce5c0890de6c49014cd7475a584d1f6", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1580f6d09f0cd990c3eed55b1d6181af3258791/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=e1580f6d09f0cd990c3eed55b1d6181af3258791", "patch": "@@ -21,9 +21,9 @@ impl Drop for Foo {\n }\n \n pub fn main() {\n-    let x = do task::try {\n+    let x = task::try(proc() {\n         let _b = Foo;\n-    };\n+    });\n \n     let s = x.unwrap_err().move::<&'static str>().unwrap();\n     assert_eq!(s.as_slice(), \"This failure should happen.\");"}]}