{"sha": "09a760e52e20dcd79d902b05065934615cc4d56b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YTc2MGU1MmUyMGRjZDc5ZDkwMmIwNTA2NTkzNDYxNWNjNGQ1NmI=", "commit": {"author": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-03-31T13:05:42Z"}, "committer": {"name": "veetaha", "email": "veetaha2@gmail.com", "date": "2020-03-31T13:20:59Z"}, "message": "vscode: add syntax tree inspection hovers and highlights", "tree": {"sha": "dcc97feaab96dcd25fc7712d38d6fd1cd189b113", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcc97feaab96dcd25fc7712d38d6fd1cd189b113"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a760e52e20dcd79d902b05065934615cc4d56b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a760e52e20dcd79d902b05065934615cc4d56b", "html_url": "https://github.com/rust-lang/rust/commit/09a760e52e20dcd79d902b05065934615cc4d56b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a760e52e20dcd79d902b05065934615cc4d56b/comments", "author": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veetaha", "id": 36276403, "node_id": "MDQ6VXNlcjM2Mjc2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/36276403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veetaha", "html_url": "https://github.com/Veetaha", "followers_url": "https://api.github.com/users/Veetaha/followers", "following_url": "https://api.github.com/users/Veetaha/following{/other_user}", "gists_url": "https://api.github.com/users/Veetaha/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veetaha/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veetaha/subscriptions", "organizations_url": "https://api.github.com/users/Veetaha/orgs", "repos_url": "https://api.github.com/users/Veetaha/repos", "events_url": "https://api.github.com/users/Veetaha/events{/privacy}", "received_events_url": "https://api.github.com/users/Veetaha/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f0d8db529478ce41b429f06708fa600a97c2151", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f0d8db529478ce41b429f06708fa600a97c2151", "html_url": "https://github.com/rust-lang/rust/commit/6f0d8db529478ce41b429f06708fa600a97c2151"}], "stats": {"total": 173, "additions": 118, "deletions": 55}, "files": [{"sha": "21ecf2661e06a715172c0b3d465c1211edbfedc4", "filename": "editors/code/src/commands/syntax_tree.ts", "status": "modified", "additions": 116, "deletions": 53, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/09a760e52e20dcd79d902b05065934615cc4d56b/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "raw_url": "https://github.com/rust-lang/rust/raw/09a760e52e20dcd79d902b05065934615cc4d56b/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Fcommands%2Fsyntax_tree.ts?ref=09a760e52e20dcd79d902b05065934615cc4d56b", "patch": "@@ -1,44 +1,24 @@\n import * as vscode from 'vscode';\n import * as ra from '../rust-analyzer-api';\n \n-import { Ctx, Cmd } from '../ctx';\n-import { isRustDocument } from '../util';\n+import { Ctx, Cmd, Disposable } from '../ctx';\n+import { isRustDocument, RustEditor, isRustEditor, sleep } from '../util';\n+\n+const AST_FILE_SCHEME = \"rust-analyzer\";\n \n // Opens the virtual file that will show the syntax tree\n //\n // The contents of the file come from the `TextDocumentContentProvider`\n export function syntaxTree(ctx: Ctx): Cmd {\n     const tdcp = new TextDocumentContentProvider(ctx);\n \n-    ctx.pushCleanup(\n-        vscode.workspace.registerTextDocumentContentProvider(\n-            'rust-analyzer',\n-            tdcp,\n-        ),\n-    );\n-\n-    vscode.workspace.onDidChangeTextDocument(\n-        (event: vscode.TextDocumentChangeEvent) => {\n-            const doc = event.document;\n-            if (!isRustDocument(doc)) return;\n-            afterLs(() => tdcp.eventEmitter.fire(tdcp.uri));\n-        },\n-        null,\n-        ctx.subscriptions,\n-    );\n-\n-    vscode.window.onDidChangeActiveTextEditor(\n-        (editor: vscode.TextEditor | undefined) => {\n-            if (!editor || !isRustDocument(editor.document)) return;\n-            tdcp.eventEmitter.fire(tdcp.uri);\n-        },\n-        null,\n-        ctx.subscriptions,\n-    );\n+    ctx.pushCleanup(new AstInspector);\n+    ctx.pushCleanup(tdcp);\n+    ctx.pushCleanup(vscode.workspace.registerTextDocumentContentProvider(AST_FILE_SCHEME, tdcp));\n \n     return async () => {\n         const editor = vscode.window.activeTextEditor;\n-        const rangeEnabled = !!(editor && !editor.selection.isEmpty);\n+        const rangeEnabled = !!editor && !editor.selection.isEmpty;\n \n         const uri = rangeEnabled\n             ? vscode.Uri.parse(`${tdcp.uri.toString()}?range=true`)\n@@ -48,45 +28,128 @@ export function syntaxTree(ctx: Ctx): Cmd {\n \n         tdcp.eventEmitter.fire(uri);\n \n-        return vscode.window.showTextDocument(\n-            document,\n-            vscode.ViewColumn.Two,\n-            true,\n-        );\n+        void await vscode.window.showTextDocument(document, {\n+            viewColumn: vscode.ViewColumn.Two,\n+            preserveFocus: true\n+        });\n     };\n }\n \n-// We need to order this after LS updates, but there's no API for that.\n-// Hence, good old setTimeout.\n-function afterLs(f: () => void) {\n-    setTimeout(f, 10);\n-}\n-\n-\n-class TextDocumentContentProvider implements vscode.TextDocumentContentProvider {\n-    uri = vscode.Uri.parse('rust-analyzer://syntaxtree');\n-    eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+class TextDocumentContentProvider implements vscode.TextDocumentContentProvider, Disposable {\n+    readonly uri = vscode.Uri.parse('rust-analyzer://syntaxtree');\n+    readonly eventEmitter = new vscode.EventEmitter<vscode.Uri>();\n+    private readonly disposables: Disposable[] = [];\n \n     constructor(private readonly ctx: Ctx) {\n+        vscode.workspace.onDidChangeTextDocument(this.onDidChangeTextDocument, this, this.disposables);\n+        vscode.window.onDidChangeActiveTextEditor(this.onDidChangeActiveTextEditor, this, this.disposables);\n+    }\n+    dispose() {\n+        this.disposables.forEach(d => d.dispose());\n     }\n \n-    provideTextDocumentContent(uri: vscode.Uri): vscode.ProviderResult<string> {\n-        const editor = vscode.window.activeTextEditor;\n-        const client = this.ctx.client;\n-        if (!editor || !client) return '';\n+    private onDidChangeTextDocument(event: vscode.TextDocumentChangeEvent) {\n+        if (isRustDocument(event.document)) {\n+            // We need to order this after language server updates, but there's no API for that.\n+            // Hence, good old sleep().\n+            void sleep(10).then(() => this.eventEmitter.fire(this.uri));\n+        }\n+    }\n+    private onDidChangeActiveTextEditor(editor: vscode.TextEditor | undefined) {\n+        if (editor && isRustEditor(editor)) {\n+            this.eventEmitter.fire(this.uri);\n+        }\n+    }\n+\n+    provideTextDocumentContent(uri: vscode.Uri, ct: vscode.CancellationToken): vscode.ProviderResult<string> {\n+        const rustEditor = this.ctx.activeRustEditor;\n+        if (!rustEditor) return '';\n \n         // When the range based query is enabled we take the range of the selection\n-        const range = uri.query === 'range=true' && !editor.selection.isEmpty\n-            ? client.code2ProtocolConverter.asRange(editor.selection)\n+        const range = uri.query === 'range=true' && !rustEditor.selection.isEmpty\n+            ? this.ctx.client.code2ProtocolConverter.asRange(rustEditor.selection)\n             : null;\n \n-        return client.sendRequest(ra.syntaxTree, {\n-            textDocument: { uri: editor.document.uri.toString() },\n-            range,\n-        });\n+        const params = { textDocument: { uri: rustEditor.document.uri.toString() }, range, };\n+        return this.ctx.client.sendRequest(ra.syntaxTree, params, ct);\n     }\n \n     get onDidChange(): vscode.Event<vscode.Uri> {\n         return this.eventEmitter.event;\n     }\n }\n+\n+\n+// FIXME: consider implementing this via the Tree View API?\n+// https://code.visualstudio.com/api/extension-guides/tree-view\n+class AstInspector implements vscode.HoverProvider, Disposable {\n+    private static readonly astDecorationType = vscode.window.createTextEditorDecorationType({\n+        fontStyle: \"normal\",\n+        border: \"#ffffff 1px solid\",\n+    });\n+    private rustEditor: undefined | RustEditor;\n+    private readonly disposables: Disposable[] = [];\n+\n+    constructor() {\n+        this.disposables.push(vscode.languages.registerHoverProvider({ scheme: AST_FILE_SCHEME }, this));\n+        vscode.workspace.onDidCloseTextDocument(this.onDidCloseTextDocument, this, this.disposables);\n+        vscode.window.onDidChangeVisibleTextEditors(this.onDidChangeVisibleTextEditors, this, this.disposables);\n+    }\n+    dispose() {\n+        this.setRustEditor(undefined);\n+        this.disposables.forEach(d => d.dispose());\n+    }\n+\n+    private onDidCloseTextDocument(doc: vscode.TextDocument) {\n+        if (!!this.rustEditor && doc.uri.toString() === this.rustEditor.document.uri.toString()) {\n+            this.setRustEditor(undefined);\n+        }\n+    }\n+\n+    private onDidChangeVisibleTextEditors(editors: vscode.TextEditor[]) {\n+        if (editors.every(suspect => suspect.document.uri.scheme !== AST_FILE_SCHEME)) {\n+            this.setRustEditor(undefined);\n+            return;\n+        }\n+        this.setRustEditor(editors.find(isRustEditor));\n+    }\n+\n+    private setRustEditor(newRustEditor: undefined | RustEditor) {\n+        if (newRustEditor !== this.rustEditor) {\n+            this.rustEditor?.setDecorations(AstInspector.astDecorationType, []);\n+        }\n+        this.rustEditor = newRustEditor;\n+    }\n+\n+    provideHover(doc: vscode.TextDocument, hoverPosition: vscode.Position): vscode.ProviderResult<vscode.Hover> {\n+        if (!this.rustEditor) return;\n+\n+        const astTextLine = doc.lineAt(hoverPosition.line);\n+\n+        const rustTextRange = this.parseRustTextRange(this.rustEditor.document, astTextLine.text);\n+        if (!rustTextRange) return;\n+\n+        this.rustEditor.setDecorations(AstInspector.astDecorationType, [rustTextRange]);\n+\n+        const rustSourceCode = this.rustEditor.document.getText(rustTextRange);\n+        const astTextRange = this.findAstRange(astTextLine);\n+\n+        return new vscode.Hover([\"```rust\\n\" + rustSourceCode + \"\\n```\"], astTextRange);\n+    }\n+\n+    private findAstRange(astLine: vscode.TextLine) {\n+        const lineOffset = astLine.range.start;\n+        const begin = lineOffset.translate(undefined, astLine.firstNonWhitespaceCharacterIndex);\n+        const end = lineOffset.translate(undefined, astLine.text.trimEnd().length);\n+        return new vscode.Range(begin, end);\n+    }\n+\n+    private parseRustTextRange(doc: vscode.TextDocument, astLine: string): undefined | vscode.Range {\n+        const parsedRange = /\\[(\\d+); (\\d+)\\)/.exec(astLine);\n+        if (!parsedRange) return;\n+\n+        const [, begin, end] = parsedRange.map(off => doc.positionAt(+off));\n+\n+        return new vscode.Range(begin, end);\n+    }\n+}"}, {"sha": "6f91f81d63ed707aac1f0282cc9aad27b1dfb890", "filename": "editors/code/src/util.ts", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09a760e52e20dcd79d902b05065934615cc4d56b/editors%2Fcode%2Fsrc%2Futil.ts", "raw_url": "https://github.com/rust-lang/rust/raw/09a760e52e20dcd79d902b05065934615cc4d56b/editors%2Fcode%2Fsrc%2Futil.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/editors%2Fcode%2Fsrc%2Futil.ts?ref=09a760e52e20dcd79d902b05065934615cc4d56b", "patch": "@@ -65,12 +65,12 @@ export async function sendRequestWithRetry<TParam, TRet>(\n     throw 'unreachable';\n }\n \n-function sleep(ms: number) {\n+export function sleep(ms: number) {\n     return new Promise(resolve => setTimeout(resolve, ms));\n }\n \n export type RustDocument = vscode.TextDocument & { languageId: \"rust\" };\n-export type RustEditor = vscode.TextEditor & { document: RustDocument; id: string };\n+export type RustEditor = vscode.TextEditor & { document: RustDocument };\n \n export function isRustDocument(document: vscode.TextDocument): document is RustDocument {\n     return document.languageId === 'rust'"}]}