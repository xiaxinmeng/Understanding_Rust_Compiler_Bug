{"sha": "38ae18b7592f97a7058d97928307bccbd881a582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YWUxOGI3NTkyZjk3YTcwNThkOTc5MjgzMDdiY2NiZDg4MWE1ODI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-14T16:46:25Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-14T16:46:25Z"}, "message": "Merge #9272\n\n9272: internal: move diagnostics to a dedicated crate r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5f6f59f48f05999495654bf2e4250e029e6f010f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f6f59f48f05999495654bf2e4250e029e6f010f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38ae18b7592f97a7058d97928307bccbd881a582", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgx4fhCRBK7hj4Ov3rIwAARd4IAG/xlUBoCPkXUp4Fhbty8xBx\nBAOtS4qZTVWZNwfBww4nUBJb3TeyUGJhPMpZeyQCHb513wIZ2yw9DjUr2m7KphTx\nl4OJlxgKGU2ThMbF73ZtsGTbirpcyA0GRsm9GyIvN9fTP+aEFHTtko74N3YxTCDq\nBmMW61YZpdRJHOxu46c9NqBdFFOoAdyjJlppVZYr6W2Yo2awFAqRCMqb4gWF7pf2\nERNv/Mx538EgsnNd0Bnt8PdS8aXXw7RJ5RiXwbNFm+mXEhzFhTcuD+YZcK6AiXgK\nHpRrz/GwB35JxXeith+ws8KG468ptKCcjB8MiAN2RPYp3XMmIa17a4JroT8Gq/4=\n=YMwv\n-----END PGP SIGNATURE-----\n", "payload": "tree 5f6f59f48f05999495654bf2e4250e029e6f010f\nparent 401d79ac0674ec62689949c3a531836420cb9beb\nparent 4768e5fb23c058eba90f0a1dcd6e9d5c0ecdee1b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623689185 +0000\ncommitter GitHub <noreply@github.com> 1623689185 +0000\n\nMerge #9272\n\n9272: internal: move diagnostics to a dedicated crate r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38ae18b7592f97a7058d97928307bccbd881a582", "html_url": "https://github.com/rust-lang/rust/commit/38ae18b7592f97a7058d97928307bccbd881a582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38ae18b7592f97a7058d97928307bccbd881a582/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "401d79ac0674ec62689949c3a531836420cb9beb", "url": "https://api.github.com/repos/rust-lang/rust/commits/401d79ac0674ec62689949c3a531836420cb9beb", "html_url": "https://github.com/rust-lang/rust/commit/401d79ac0674ec62689949c3a531836420cb9beb"}, {"sha": "4768e5fb23c058eba90f0a1dcd6e9d5c0ecdee1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4768e5fb23c058eba90f0a1dcd6e9d5c0ecdee1b", "html_url": "https://github.com/rust-lang/rust/commit/4768e5fb23c058eba90f0a1dcd6e9d5c0ecdee1b"}], "stats": {"total": 1735, "additions": 937, "deletions": 798}, "files": [{"sha": "847277118387355de4f52cc016007a7de5722151", "filename": "Cargo.lock", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -591,6 +591,7 @@ dependencies = [\n  \"ide_assists\",\n  \"ide_completion\",\n  \"ide_db\",\n+ \"ide_diagnostics\",\n  \"ide_ssr\",\n  \"indexmap\",\n  \"itertools\",\n@@ -668,6 +669,25 @@ dependencies = [\n  \"text_edit\",\n ]\n \n+[[package]]\n+name = \"ide_diagnostics\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"cfg\",\n+ \"cov-mark\",\n+ \"either\",\n+ \"expect-test\",\n+ \"hir\",\n+ \"ide_db\",\n+ \"itertools\",\n+ \"profile\",\n+ \"rustc-hash\",\n+ \"stdx\",\n+ \"syntax\",\n+ \"test_utils\",\n+ \"text_edit\",\n+]\n+\n [[package]]\n name = \"ide_ssr\"\n version = \"0.0.0\""}, {"sha": "1b17db102c2fabca294f80f6d13a58c182d16162", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -24,6 +24,14 @@ pub trait WithFixture: Default + SourceDatabaseExt + 'static {\n         (db, fixture.files[0])\n     }\n \n+    fn with_many_files(ra_fixture: &str) -> (Self, Vec<FileId>) {\n+        let fixture = ChangeFixture::parse(ra_fixture);\n+        let mut db = Self::default();\n+        fixture.change.apply(&mut db);\n+        assert!(fixture.file_position.is_none());\n+        (db, fixture.files)\n+    }\n+\n     fn with_files(ra_fixture: &str) -> Self {\n         let fixture = ChangeFixture::parse(ra_fixture);\n         let mut db = Self::default();"}, {"sha": "0e84473940a7257c66477599282a8aad5d108f19", "filename": "crates/ide/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2FCargo.toml?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -29,6 +29,7 @@ ide_db = { path = \"../ide_db\", version = \"0.0.0\" }\n cfg = { path = \"../cfg\", version = \"0.0.0\" }\n profile = { path = \"../profile\", version = \"0.0.0\" }\n ide_assists = { path = \"../ide_assists\", version = \"0.0.0\" }\n+ide_diagnostics = { path = \"../ide_diagnostics\", version = \"0.0.0\" }\n ide_ssr = { path = \"../ide_ssr\", version = \"0.0.0\" }\n ide_completion = { path = \"../ide_completion\", version = \"0.0.0\" }\n "}, {"sha": "cf679edd3b3e03dd479fa8a87bac22975934fd0b", "filename": "crates/ide/src/fixture.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Ffixture.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -12,14 +12,6 @@ pub(crate) fn file(ra_fixture: &str) -> (Analysis, FileId) {\n     (host.analysis(), change_fixture.files[0])\n }\n \n-/// Creates analysis for many files.\n-pub(crate) fn files(ra_fixture: &str) -> (Analysis, Vec<FileId>) {\n-    let mut host = AnalysisHost::default();\n-    let change_fixture = ChangeFixture::parse(ra_fixture);\n-    host.db.apply_change(change_fixture.change);\n-    (host.analysis(), change_fixture.files)\n-}\n-\n /// Creates analysis from a multi-file fixture, returns positions marked with $0.\n pub(crate) fn position(ra_fixture: &str) -> (Analysis, FilePosition) {\n     let mut host = AnalysisHost::default();"}, {"sha": "9db387d26dea36c6b11d6726905b0291d33c6e0c", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -24,7 +24,6 @@ mod display;\n \n mod annotations;\n mod call_hierarchy;\n-mod diagnostics;\n mod expand_macro;\n mod extend_selection;\n mod file_structure;\n@@ -40,6 +39,7 @@ mod matching_brace;\n mod move_item;\n mod parent_module;\n mod references;\n+mod rename;\n mod fn_references;\n mod runnables;\n mod ssr;\n@@ -71,7 +71,6 @@ use crate::display::ToNav;\n pub use crate::{\n     annotations::{Annotation, AnnotationConfig, AnnotationKind},\n     call_hierarchy::CallItem,\n-    diagnostics::{Diagnostic, DiagnosticsConfig, Severity},\n     display::navigation_target::NavigationTarget,\n     expand_macro::ExpandedMacro,\n     file_structure::{StructureNode, StructureNodeKind},\n@@ -81,7 +80,8 @@ pub use crate::{\n     markup::Markup,\n     move_item::Direction,\n     prime_caches::PrimeCachesProgress,\n-    references::{rename::RenameError, ReferenceSearchResult},\n+    references::ReferenceSearchResult,\n+    rename::RenameError,\n     runnables::{Runnable, RunnableKind, TestId},\n     syntax_highlighting::{\n         tags::{Highlight, HlMod, HlMods, HlOperator, HlPunct, HlTag},\n@@ -109,6 +109,7 @@ pub use ide_db::{\n     symbol_index::Query,\n     RootDatabase, SymbolKind,\n };\n+pub use ide_diagnostics::{Diagnostic, DiagnosticsConfig, Severity};\n pub use ide_ssr::SsrError;\n pub use syntax::{TextRange, TextSize};\n pub use text_edit::{Indel, TextEdit};\n@@ -536,7 +537,7 @@ impl Analysis {\n     ) -> Cancellable<Vec<Assist>> {\n         self.with_db(|db| {\n             let ssr_assists = ssr::ssr_assists(db, &resolve, frange);\n-            let mut acc = Assist::get(db, config, resolve, frange);\n+            let mut acc = ide_assists::assists(db, config, resolve, frange);\n             acc.extend(ssr_assists.into_iter());\n             acc\n         })\n@@ -549,7 +550,7 @@ impl Analysis {\n         resolve: AssistResolveStrategy,\n         file_id: FileId,\n     ) -> Cancellable<Vec<Diagnostic>> {\n-        self.with_db(|db| diagnostics::diagnostics(db, config, &resolve, file_id))\n+        self.with_db(|db| ide_diagnostics::diagnostics(db, config, &resolve, file_id))\n     }\n \n     /// Convenience function to return assists + quick fixes for diagnostics\n@@ -568,7 +569,7 @@ impl Analysis {\n         self.with_db(|db| {\n             let ssr_assists = ssr::ssr_assists(db, &resolve, frange);\n             let diagnostic_assists = if include_fixes {\n-                diagnostics::diagnostics(db, diagnostics_config, &resolve, frange.file_id)\n+                ide_diagnostics::diagnostics(db, diagnostics_config, &resolve, frange.file_id)\n                     .into_iter()\n                     .flat_map(|it| it.fixes.unwrap_or_default())\n                     .filter(|it| it.target.intersect(frange.range).is_some())\n@@ -577,7 +578,7 @@ impl Analysis {\n                 Vec::new()\n             };\n \n-            let mut res = Assist::get(db, assist_config, resolve, frange);\n+            let mut res = ide_assists::assists(db, assist_config, resolve, frange);\n             res.extend(ssr_assists.into_iter());\n             res.extend(diagnostic_assists.into_iter());\n \n@@ -592,22 +593,22 @@ impl Analysis {\n         position: FilePosition,\n         new_name: &str,\n     ) -> Cancellable<Result<SourceChange, RenameError>> {\n-        self.with_db(|db| references::rename::rename(db, position, new_name))\n+        self.with_db(|db| rename::rename(db, position, new_name))\n     }\n \n     pub fn prepare_rename(\n         &self,\n         position: FilePosition,\n     ) -> Cancellable<Result<RangeInfo<()>, RenameError>> {\n-        self.with_db(|db| references::rename::prepare_rename(db, position))\n+        self.with_db(|db| rename::prepare_rename(db, position))\n     }\n \n     pub fn will_rename_file(\n         &self,\n         file_id: FileId,\n         new_name_stem: &str,\n     ) -> Cancellable<Option<SourceChange>> {\n-        self.with_db(|db| references::rename::will_rename_file(db, file_id, new_name_stem))\n+        self.with_db(|db| rename::will_rename_file(db, file_id, new_name_stem))\n     }\n \n     pub fn structural_search_replace("}, {"sha": "945c9b9e10ed402f3cae69ada76139deb6a4e183", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -9,8 +9,6 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n-pub(crate) mod rename;\n-\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,"}, {"sha": "8096dfa0ea785c4fe967ebbd6b42e643fd8440ca", "filename": "crates/ide/src/rename.rs", "status": "renamed", "additions": 34, "deletions": 425, "changes": 459, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frename.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,45 +1,25 @@\n-//! Renaming functionality\n+//! Renaming functionality.\n //!\n-//! All reference and file rename requests go through here where the corresponding [`SourceChange`]s\n-//! will be calculated.\n-use std::fmt::{self, Display};\n-\n-use either::Either;\n-use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n+//! This is mostly front-end for [`ide_db::rename`], but it also includes the\n+//! tests. This module also implements a couple of magic tricks, like renaming\n+//! `self` and to `self` (to switch between associated function and method).\n+use hir::{AsAssocItem, InFile, Semantics};\n use ide_db::{\n-    base_db::{AnchoredPathBuf, FileId, FileRange},\n+    base_db::FileId,\n     defs::{Definition, NameClass, NameRefClass},\n-    search::FileReference,\n+    rename::{bail, format_err, source_edit_from_references, IdentifierKind},\n     RootDatabase,\n };\n use stdx::never;\n-use syntax::{\n-    ast::{self, NameOwner},\n-    lex_single_syntax_kind, AstNode, SyntaxKind, SyntaxNode, T,\n-};\n+use syntax::{ast, AstNode, SyntaxNode};\n \n use text_edit::TextEdit;\n \n-use crate::{FilePosition, FileSystemEdit, RangeInfo, SourceChange, TextRange};\n-\n-type RenameResult<T> = Result<T, RenameError>;\n-#[derive(Debug)]\n-pub struct RenameError(String);\n-\n-impl fmt::Display for RenameError {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Display::fmt(&self.0, f)\n-    }\n-}\n+use crate::{FilePosition, RangeInfo, SourceChange};\n \n-macro_rules! format_err {\n-    ($fmt:expr) => {RenameError(format!($fmt))};\n-    ($fmt:expr, $($arg:tt)+) => {RenameError(format!($fmt, $($arg)+))}\n-}\n+pub use ide_db::rename::RenameError;\n \n-macro_rules! bail {\n-    ($($tokens:tt)*) => {return Err(format_err!($($tokens)*))}\n-}\n+type RenameResult<T> = Result<T, RenameError>;\n \n /// Prepares a rename. The sole job of this function is to return the TextRange of the thing that is\n /// being targeted for a rename.\n@@ -52,7 +32,8 @@ pub(crate) fn prepare_rename(\n     let syntax = source_file.syntax();\n \n     let def = find_definition(&sema, syntax, position)?;\n-    let frange = def_name_range(&&sema, def)\n+    let frange = def\n+        .range_for_rename(&sema)\n         .ok_or_else(|| format_err!(\"No references found at position\"))?;\n     Ok(RangeInfo::new(frange.range, ()))\n }\n@@ -98,14 +79,7 @@ pub(crate) fn rename_with_semantics(\n         }\n     }\n \n-    match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => rename_mod(sema, module, new_name),\n-        Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n-        Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n-            bail!(\"Cannot rename builtin type\")\n-        }\n-        def => rename_reference(sema, def, new_name),\n-    }\n+    def.rename(sema, new_name)\n }\n \n /// Called by the client when it is about to rename a file.\n@@ -116,38 +90,12 @@ pub(crate) fn will_rename_file(\n ) -> Option<SourceChange> {\n     let sema = Semantics::new(db);\n     let module = sema.to_module_def(file_id)?;\n-    let mut change = rename_mod(&sema, module, new_name_stem).ok()?;\n+    let def = Definition::ModuleDef(module.into());\n+    let mut change = def.rename(&sema, new_name_stem).ok()?;\n     change.file_system_edits.clear();\n     Some(change)\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq)]\n-enum IdentifierKind {\n-    Ident,\n-    Lifetime,\n-    Underscore,\n-}\n-\n-impl IdentifierKind {\n-    fn classify(new_name: &str) -> RenameResult<IdentifierKind> {\n-        match lex_single_syntax_kind(new_name) {\n-            Some(res) => match res {\n-                (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n-                (T![_], _) => Ok(IdentifierKind::Underscore),\n-                (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n-                    Ok(IdentifierKind::Lifetime)\n-                }\n-                (SyntaxKind::LIFETIME_IDENT, _) => {\n-                    bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n-                }\n-                (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n-                (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-            },\n-            None => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n-        }\n-    }\n-}\n-\n fn find_definition(\n     sema: &Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n@@ -189,126 +137,6 @@ fn find_definition(\n     .ok_or_else(|| format_err!(\"No references found at position\"))\n }\n \n-fn rename_mod(\n-    sema: &Semantics<RootDatabase>,\n-    module: hir::Module,\n-    new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    if IdentifierKind::classify(new_name)? != IdentifierKind::Ident {\n-        bail!(\"Invalid name `{0}`: cannot rename module to {0}\", new_name);\n-    }\n-\n-    let mut source_change = SourceChange::default();\n-\n-    let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n-    let file_id = file_id.original_file(sema.db);\n-    if let ModuleSource::SourceFile(..) = def_source {\n-        // mod is defined in path/to/dir/mod.rs\n-        let path = if module.is_mod_rs(sema.db) {\n-            format!(\"../{}/mod.rs\", new_name)\n-        } else {\n-            format!(\"{}.rs\", new_name)\n-        };\n-        let dst = AnchoredPathBuf { anchor: file_id, path };\n-        let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n-        source_change.push_file_system_edit(move_file);\n-    }\n-\n-    if let Some(InFile { file_id, value: decl_source }) = module.declaration_source(sema.db) {\n-        let file_id = file_id.original_file(sema.db);\n-        match decl_source.name() {\n-            Some(name) => source_change.insert_source_edit(\n-                file_id,\n-                TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n-            ),\n-            _ => never!(\"Module source node is missing a name\"),\n-        }\n-    }\n-    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n-    let usages = def.usages(sema).all();\n-    let ref_edits = usages.iter().map(|(&file_id, references)| {\n-        (file_id, source_edit_from_references(references, def, new_name))\n-    });\n-    source_change.extend(ref_edits);\n-\n-    Ok(source_change)\n-}\n-\n-fn rename_reference(\n-    sema: &Semantics<RootDatabase>,\n-    mut def: Definition,\n-    new_name: &str,\n-) -> RenameResult<SourceChange> {\n-    let ident_kind = IdentifierKind::classify(new_name)?;\n-\n-    if matches!(\n-        def, // is target a lifetime?\n-        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n-    ) {\n-        match ident_kind {\n-            IdentifierKind::Ident | IdentifierKind::Underscore => {\n-                cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n-                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name);\n-            }\n-            IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n-        }\n-    } else {\n-        match (ident_kind, def) {\n-            (IdentifierKind::Lifetime, _) => {\n-                cov_mark::hit!(rename_not_an_ident_ref);\n-                bail!(\"Invalid name `{}`: not an identifier\", new_name);\n-            }\n-            (IdentifierKind::Ident, _) => cov_mark::hit!(rename_non_local),\n-            (IdentifierKind::Underscore, _) => (),\n-        }\n-    }\n-\n-    def = match def {\n-        // HACK: resolve trait impl items to the item def of the trait definition\n-        // so that we properly resolve all trait item references\n-        Definition::ModuleDef(mod_def) => mod_def\n-            .as_assoc_item(sema.db)\n-            .and_then(|it| it.containing_trait_impl(sema.db))\n-            .and_then(|it| {\n-                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n-                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n-                        if trait_func.name(sema.db) == func.name(sema.db) =>\n-                    {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n-                    }\n-                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n-                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n-                    {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n-                    }\n-                    (\n-                        hir::AssocItem::TypeAlias(trait_type_alias),\n-                        hir::ModuleDef::TypeAlias(type_alias),\n-                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n-                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n-                    }\n-                    _ => None,\n-                })\n-            })\n-            .unwrap_or(def),\n-        _ => def,\n-    };\n-    let usages = def.usages(sema).all();\n-\n-    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n-        cov_mark::hit!(rename_underscore_multiple);\n-        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n-    }\n-    let mut source_change = SourceChange::default();\n-    source_change.extend(usages.iter().map(|(&file_id, references)| {\n-        (file_id, source_edit_from_references(references, def, new_name))\n-    }));\n-\n-    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n-    source_change.insert_source_edit(file_id, edit);\n-    Ok(source_change)\n-}\n-\n fn rename_to_self(sema: &Semantics<RootDatabase>, local: hir::Local) -> RenameResult<SourceChange> {\n     if never!(local.is_self(sema.db)) {\n         bail!(\"rename_to_self invoked on self\");\n@@ -426,243 +254,6 @@ fn text_edit_from_self_param(self_param: &ast::SelfParam, new_name: &str) -> Opt\n     Some(TextEdit::replace(self_param.syntax().text_range(), replacement_text))\n }\n \n-fn source_edit_from_references(\n-    references: &[FileReference],\n-    def: Definition,\n-    new_name: &str,\n-) -> TextEdit {\n-    let mut edit = TextEdit::builder();\n-    for reference in references {\n-        let (range, replacement) = match &reference.name {\n-            // if the ranges differ then the node is inside a macro call, we can't really attempt\n-            // to make special rewrites like shorthand syntax and such, so just rename the node in\n-            // the macro input\n-            ast::NameLike::NameRef(name_ref)\n-                if name_ref.syntax().text_range() == reference.range =>\n-            {\n-                source_edit_from_name_ref(name_ref, new_name, def)\n-            }\n-            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n-                source_edit_from_name(name, new_name)\n-            }\n-            _ => None,\n-        }\n-        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n-        edit.replace(range, replacement);\n-    }\n-    edit.finish()\n-}\n-\n-fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n-    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n-        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n-            return Some((\n-                TextRange::empty(ident_pat.syntax().text_range().start()),\n-                [new_name, \": \"].concat(),\n-            ));\n-        }\n-    }\n-    None\n-}\n-\n-fn source_edit_from_name_ref(\n-    name_ref: &ast::NameRef,\n-    new_name: &str,\n-    def: Definition,\n-) -> Option<(TextRange, String)> {\n-    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_expr = record_field.expr();\n-        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n-            // field: init-expr, check if we can use a field init shorthand\n-            (Some(field_name), Some(init)) => {\n-                if field_name == *name_ref {\n-                    if init.text() == new_name {\n-                        cov_mark::hit!(test_rename_field_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                } else if init == *name_ref {\n-                    if field_name.text() == new_name {\n-                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n-                        // same names, we can use a shorthand here instead.\n-                        // we do not want to erase attributes hence this range start\n-                        let s = field_name.syntax().text_range().start();\n-                        let e = record_field.syntax().text_range().end();\n-                        return Some((TextRange::new(s, e), new_name.to_owned()));\n-                    }\n-                }\n-                None\n-            }\n-            // init shorthand\n-            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n-            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n-            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n-                cov_mark::hit!(test_rename_field_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().start();\n-                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n-            }\n-            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n-                cov_mark::hit!(test_rename_local_in_field_shorthand);\n-                let s = name_ref.syntax().text_range().end();\n-                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n-            }\n-            _ => None,\n-        }\n-    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n-        let rcf_name_ref = record_field.name_ref();\n-        let rcf_pat = record_field.pat();\n-        match (rcf_name_ref, rcf_pat) {\n-            // field: rename\n-            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n-                // field name is being renamed\n-                if pat.name().map_or(false, |it| it.text() == new_name) {\n-                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n-                    // same names, we can use a shorthand here instead/\n-                    // we do not want to erase attributes hence this range start\n-                    let s = field_name.syntax().text_range().start();\n-                    let e = record_field.syntax().text_range().end();\n-                    Some((TextRange::new(s, e), pat.to_string()))\n-                } else {\n-                    None\n-                }\n-            }\n-            _ => None,\n-        }\n-    } else {\n-        None\n-    }\n-}\n-\n-fn source_edit_from_def(\n-    sema: &Semantics<RootDatabase>,\n-    def: Definition,\n-    new_name: &str,\n-) -> RenameResult<(FileId, TextEdit)> {\n-    let frange: FileRange = def_name_range(sema, def)\n-        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n-\n-    let mut replacement_text = String::new();\n-    let mut repl_range = frange.range;\n-    if let Definition::Local(local) = def {\n-        if let Either::Left(pat) = local.source(sema.db).value {\n-            if matches!(\n-                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n-                Some(pat_field) if pat_field.name_ref().is_none()\n-            ) {\n-                replacement_text.push_str(\": \");\n-                replacement_text.push_str(new_name);\n-                repl_range = TextRange::new(\n-                    pat.syntax().text_range().end(),\n-                    pat.syntax().text_range().end(),\n-                );\n-            }\n-        }\n-    }\n-    if replacement_text.is_empty() {\n-        replacement_text.push_str(new_name);\n-    }\n-    let edit = TextEdit::replace(repl_range, replacement_text);\n-    Ok((frange.file_id, edit))\n-}\n-\n-fn def_name_range(sema: &Semantics<RootDatabase>, def: Definition) -> Option<FileRange> {\n-    // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n-    // and _fall back_ to the entirety of the macro call. Such fall back is\n-    // incorrect for renames. The safe behavior would be to return an error for\n-    // such cases. The correct behavior would be to return an auxiliary list of\n-    // \"can't rename these occurrences in macros\" items, and then show some kind\n-    // of a dialog to the user.\n-\n-    let res = match def {\n-        Definition::Macro(mac) => {\n-            let src = mac.source(sema.db)?;\n-            let name = match &src.value {\n-                Either::Left(it) => it.name()?,\n-                Either::Right(it) => it.name()?,\n-            };\n-            src.with_value(name.syntax()).original_file_range(sema.db)\n-        }\n-        Definition::Field(field) => {\n-            let src = field.source(sema.db)?;\n-\n-            match &src.value {\n-                FieldSource::Named(record_field) => {\n-                    let name = record_field.name()?;\n-                    src.with_value(name.syntax()).original_file_range(sema.db)\n-                }\n-                FieldSource::Pos(_) => {\n-                    return None;\n-                }\n-            }\n-        }\n-        Definition::ModuleDef(module_def) => match module_def {\n-            hir::ModuleDef::Module(module) => {\n-                let src = module.declaration_source(sema.db)?;\n-                let name = src.value.name()?;\n-                src.with_value(name.syntax()).original_file_range(sema.db)\n-            }\n-            hir::ModuleDef::Function(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Adt(adt) => match adt {\n-                hir::Adt::Struct(it) => name_range(it, sema)?,\n-                hir::Adt::Union(it) => name_range(it, sema)?,\n-                hir::Adt::Enum(it) => name_range(it, sema)?,\n-            },\n-            hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Const(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Static(it) => name_range(it, sema)?,\n-            hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n-            hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n-            hir::ModuleDef::BuiltinType(_) => return None,\n-        },\n-        Definition::SelfType(_) => return None,\n-        Definition::Local(local) => {\n-            let src = local.source(sema.db);\n-            let name = match &src.value {\n-                Either::Left(bind_pat) => bind_pat.name()?,\n-                Either::Right(_) => return None,\n-            };\n-            src.with_value(name.syntax()).original_file_range(sema.db)\n-        }\n-        Definition::GenericParam(generic_param) => match generic_param {\n-            hir::GenericParam::TypeParam(type_param) => {\n-                let src = type_param.source(sema.db)?;\n-                let name = match &src.value {\n-                    Either::Left(_) => return None,\n-                    Either::Right(type_param) => type_param.name()?,\n-                };\n-                src.with_value(name.syntax()).original_file_range(sema.db)\n-            }\n-            hir::GenericParam::LifetimeParam(lifetime_param) => {\n-                let src = lifetime_param.source(sema.db)?;\n-                let lifetime = src.value.lifetime()?;\n-                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n-            }\n-            hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n-        },\n-        Definition::Label(label) => {\n-            let src = label.source(sema.db);\n-            let lifetime = src.value.lifetime()?;\n-            src.with_value(lifetime.syntax()).original_file_range(sema.db)\n-        }\n-    };\n-    return Some(res);\n-\n-    fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n-    where\n-        D: HasSource,\n-        D::Ast: ast::NameOwner,\n-    {\n-        let src = def.source(sema.db)?;\n-        let name = src.value.name()?;\n-        let res = src.with_value(name.syntax()).original_file_range(sema.db);\n-        Some(res)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n@@ -2178,4 +1769,22 @@ fn f() { <()>::BAR$0; }\"#,\n             res,\n         );\n     }\n+\n+    #[test]\n+    fn macros_are_broken_lol() {\n+        cov_mark::check!(macros_are_broken_lol);\n+        check(\n+            \"lol\",\n+            r#\"\n+macro_rules! m { () => { fn f() {} } }\n+m!();\n+fn main() { f$0()  }\n+\"#,\n+            r#\"\n+macro_rules! m { () => { fn f() {} } }\n+lol\n+fn main() { lol()  }\n+\"#,\n+        )\n+    }\n }", "previous_filename": "crates/ide/src/references/rename.rs"}, {"sha": "fa378a622dc2e6f5e9fab0fc0d58dcb9890bce66", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 19, "deletions": 144, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -17,156 +17,31 @@ mod tests;\n pub mod utils;\n pub mod path_transform;\n \n-use std::str::FromStr;\n-\n use hir::Semantics;\n-use ide_db::{base_db::FileRange, label::Label, source_change::SourceChange, RootDatabase};\n+use ide_db::{base_db::FileRange, RootDatabase};\n use syntax::TextRange;\n \n pub(crate) use crate::assist_context::{AssistContext, Assists};\n \n pub use assist_config::AssistConfig;\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub enum AssistKind {\n-    // FIXME: does the None variant make sense? Probably not.\n-    None,\n-\n-    QuickFix,\n-    Generate,\n-    Refactor,\n-    RefactorExtract,\n-    RefactorInline,\n-    RefactorRewrite,\n-}\n-\n-impl AssistKind {\n-    pub fn contains(self, other: AssistKind) -> bool {\n-        if self == other {\n-            return true;\n-        }\n-\n-        match self {\n-            AssistKind::None | AssistKind::Generate => true,\n-            AssistKind::Refactor => match other {\n-                AssistKind::RefactorExtract\n-                | AssistKind::RefactorInline\n-                | AssistKind::RefactorRewrite => true,\n-                _ => false,\n-            },\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn name(&self) -> &str {\n-        match self {\n-            AssistKind::None => \"None\",\n-            AssistKind::QuickFix => \"QuickFix\",\n-            AssistKind::Generate => \"Generate\",\n-            AssistKind::Refactor => \"Refactor\",\n-            AssistKind::RefactorExtract => \"RefactorExtract\",\n-            AssistKind::RefactorInline => \"RefactorInline\",\n-            AssistKind::RefactorRewrite => \"RefactorRewrite\",\n-        }\n-    }\n-}\n-\n-impl FromStr for AssistKind {\n-    type Err = String;\n-\n-    fn from_str(s: &str) -> Result<Self, Self::Err> {\n-        match s {\n-            \"None\" => Ok(AssistKind::None),\n-            \"QuickFix\" => Ok(AssistKind::QuickFix),\n-            \"Generate\" => Ok(AssistKind::Generate),\n-            \"Refactor\" => Ok(AssistKind::Refactor),\n-            \"RefactorExtract\" => Ok(AssistKind::RefactorExtract),\n-            \"RefactorInline\" => Ok(AssistKind::RefactorInline),\n-            \"RefactorRewrite\" => Ok(AssistKind::RefactorRewrite),\n-            unknown => Err(format!(\"Unknown AssistKind: '{}'\", unknown)),\n-        }\n-    }\n-}\n-\n-/// Unique identifier of the assist, should not be shown to the user\n-/// directly.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub struct AssistId(pub &'static str, pub AssistKind);\n-\n-/// A way to control how many asssist to resolve during the assist resolution.\n-/// When an assist is resolved, its edits are calculated that might be costly to always do by default.\n-#[derive(Debug)]\n-pub enum AssistResolveStrategy {\n-    /// No assists should be resolved.\n-    None,\n-    /// All assists should be resolved.\n-    All,\n-    /// Only a certain assist should be resolved.\n-    Single(SingleResolve),\n-}\n-\n-/// Hold the [`AssistId`] data of a certain assist to resolve.\n-/// The original id object cannot be used due to a `'static` lifetime\n-/// and the requirement to construct this struct dynamically during the resolve handling.\n-#[derive(Debug)]\n-pub struct SingleResolve {\n-    /// The id of the assist.\n-    pub assist_id: String,\n-    // The kind of the assist.\n-    pub assist_kind: AssistKind,\n-}\n-\n-impl AssistResolveStrategy {\n-    pub fn should_resolve(&self, id: &AssistId) -> bool {\n-        match self {\n-            AssistResolveStrategy::None => false,\n-            AssistResolveStrategy::All => true,\n-            AssistResolveStrategy::Single(single_resolve) => {\n-                single_resolve.assist_id == id.0 && single_resolve.assist_kind == id.1\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct GroupLabel(pub String);\n-\n-#[derive(Debug, Clone)]\n-pub struct Assist {\n-    pub id: AssistId,\n-    /// Short description of the assist, as shown in the UI.\n-    pub label: Label,\n-    pub group: Option<GroupLabel>,\n-    /// Target ranges are used to sort assists: the smaller the target range,\n-    /// the more specific assist is, and so it should be sorted first.\n-    pub target: TextRange,\n-    /// Computing source change sometimes is much more costly then computing the\n-    /// other fields. Additionally, the actual change is not required to show\n-    /// the lightbulb UI, it only is needed when the user tries to apply an\n-    /// assist. So, we compute it lazily: the API allow requesting assists with\n-    /// or without source change. We could (and in fact, used to) distinguish\n-    /// between resolved and unresolved assists at the type level, but this is\n-    /// cumbersome, especially if you want to embed an assist into another data\n-    /// structure, such as a diagnostic.\n-    pub source_change: Option<SourceChange>,\n-}\n-\n-impl Assist {\n-    /// Return all the assists applicable at the given position.\n-    pub fn get(\n-        db: &RootDatabase,\n-        config: &AssistConfig,\n-        resolve: AssistResolveStrategy,\n-        range: FileRange,\n-    ) -> Vec<Assist> {\n-        let sema = Semantics::new(db);\n-        let ctx = AssistContext::new(sema, config, range);\n-        let mut acc = Assists::new(&ctx, resolve);\n-        handlers::all().iter().for_each(|handler| {\n-            handler(&mut acc, &ctx);\n-        });\n-        acc.finish()\n-    }\n+pub use ide_db::assists::{\n+    Assist, AssistId, AssistKind, AssistResolveStrategy, GroupLabel, SingleResolve,\n+};\n+\n+/// Return all the assists applicable at the given position.\n+pub fn assists(\n+    db: &RootDatabase,\n+    config: &AssistConfig,\n+    resolve: AssistResolveStrategy,\n+    range: FileRange,\n+) -> Vec<Assist> {\n+    let sema = Semantics::new(db);\n+    let ctx = AssistContext::new(sema, config, range);\n+    let mut acc = Assists::new(&ctx, resolve);\n+    handlers::all().iter().for_each(|handler| {\n+        handler(&mut acc, &ctx);\n+    });\n+    acc.finish()\n }\n \n mod handlers {"}, {"sha": "60cecd94c8bafbeb4dfb6c0713d1ba1da4db44d9", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -16,8 +16,8 @@ use syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset};\n \n use crate::{\n-    handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, AssistResolveStrategy,\n-    Assists, SingleResolve,\n+    assists, handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind,\n+    AssistResolveStrategy, Assists, SingleResolve,\n };\n \n pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n@@ -78,14 +78,14 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let before = db.file_text(file_id).to_string();\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let assist = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::All, frange)\n+    let assist = assists(&db, &TEST_CONFIG, AssistResolveStrategy::All, frange)\n         .into_iter()\n         .find(|assist| assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange)\n+                assists(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange)\n                     .into_iter()\n                     .map(|assist| assist.id.0)\n                     .collect::<Vec<_>>()\n@@ -210,7 +210,7 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n+    let assists = assists(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Change visibility to pub(crate)\");\n@@ -235,7 +235,7 @@ pub fn test_some_range(a: int) -> bool {\n \"#,\n     );\n \n-    let assists = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n+    let assists = assists(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n     let expected = labels(&assists);\n \n     expect![[r#\"\n@@ -264,7 +264,7 @@ pub fn test_some_range(a: int) -> bool {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::Refactor]);\n \n-        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n+        let assists = assists(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\n@@ -279,7 +279,7 @@ pub fn test_some_range(a: int) -> bool {\n     {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n-        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n+        let assists = assists(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\n@@ -292,7 +292,7 @@ pub fn test_some_range(a: int) -> bool {\n     {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::QuickFix]);\n-        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n+        let assists = assists(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\"#]].assert_eq(&expected);\n@@ -317,7 +317,7 @@ pub fn test_some_range(a: int) -> bool {\n     cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n \n     {\n-        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n+        let assists = assists(&db, &cfg, AssistResolveStrategy::None, frange);\n         assert_eq!(2, assists.len());\n         let mut assists = assists.into_iter();\n \n@@ -353,7 +353,7 @@ pub fn test_some_range(a: int) -> bool {\n     }\n \n     {\n-        let assists = Assist::get(\n+        let assists = assists(\n             &db,\n             &cfg,\n             AssistResolveStrategy::Single(SingleResolve {\n@@ -397,7 +397,7 @@ pub fn test_some_range(a: int) -> bool {\n     }\n \n     {\n-        let assists = Assist::get(\n+        let assists = assists(\n             &db,\n             &cfg,\n             AssistResolveStrategy::Single(SingleResolve {\n@@ -462,7 +462,7 @@ pub fn test_some_range(a: int) -> bool {\n     }\n \n     {\n-        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::All, frange);\n+        let assists = assists(&db, &cfg, AssistResolveStrategy::All, frange);\n         assert_eq!(2, assists.len());\n         let mut assists = assists.into_iter();\n "}, {"sha": "7881d83691ba1ef494f893bd1897bbf670f99743", "filename": "crates/ide_db/src/assists.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Fassists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Fassists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fassists.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -0,0 +1,136 @@\n+//! This module defines the `Assist` data structure. The actual assist live in\n+//! the `ide_assists` downstream crate. We want to define the data structures in\n+//! this low-level crate though, because `ide_diagnostics` also need them\n+//! (fixits for diagnostics and assists are the same thing under the hood). We\n+//! want to compile `ide_assists` and `ide_diagnostics` in parallel though, so\n+//! we pull the common definitions upstream, to this crate.\n+\n+use std::str::FromStr;\n+\n+use syntax::TextRange;\n+\n+use crate::{label::Label, source_change::SourceChange};\n+\n+#[derive(Debug, Clone)]\n+pub struct Assist {\n+    pub id: AssistId,\n+    /// Short description of the assist, as shown in the UI.\n+    pub label: Label,\n+    pub group: Option<GroupLabel>,\n+    /// Target ranges are used to sort assists: the smaller the target range,\n+    /// the more specific assist is, and so it should be sorted first.\n+    pub target: TextRange,\n+    /// Computing source change sometimes is much more costly then computing the\n+    /// other fields. Additionally, the actual change is not required to show\n+    /// the lightbulb UI, it only is needed when the user tries to apply an\n+    /// assist. So, we compute it lazily: the API allow requesting assists with\n+    /// or without source change. We could (and in fact, used to) distinguish\n+    /// between resolved and unresolved assists at the type level, but this is\n+    /// cumbersome, especially if you want to embed an assist into another data\n+    /// structure, such as a diagnostic.\n+    pub source_change: Option<SourceChange>,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub enum AssistKind {\n+    // FIXME: does the None variant make sense? Probably not.\n+    None,\n+\n+    QuickFix,\n+    Generate,\n+    Refactor,\n+    RefactorExtract,\n+    RefactorInline,\n+    RefactorRewrite,\n+}\n+\n+impl AssistKind {\n+    pub fn contains(self, other: AssistKind) -> bool {\n+        if self == other {\n+            return true;\n+        }\n+\n+        match self {\n+            AssistKind::None | AssistKind::Generate => true,\n+            AssistKind::Refactor => match other {\n+                AssistKind::RefactorExtract\n+                | AssistKind::RefactorInline\n+                | AssistKind::RefactorRewrite => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn name(&self) -> &str {\n+        match self {\n+            AssistKind::None => \"None\",\n+            AssistKind::QuickFix => \"QuickFix\",\n+            AssistKind::Generate => \"Generate\",\n+            AssistKind::Refactor => \"Refactor\",\n+            AssistKind::RefactorExtract => \"RefactorExtract\",\n+            AssistKind::RefactorInline => \"RefactorInline\",\n+            AssistKind::RefactorRewrite => \"RefactorRewrite\",\n+        }\n+    }\n+}\n+\n+impl FromStr for AssistKind {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"None\" => Ok(AssistKind::None),\n+            \"QuickFix\" => Ok(AssistKind::QuickFix),\n+            \"Generate\" => Ok(AssistKind::Generate),\n+            \"Refactor\" => Ok(AssistKind::Refactor),\n+            \"RefactorExtract\" => Ok(AssistKind::RefactorExtract),\n+            \"RefactorInline\" => Ok(AssistKind::RefactorInline),\n+            \"RefactorRewrite\" => Ok(AssistKind::RefactorRewrite),\n+            unknown => Err(format!(\"Unknown AssistKind: '{}'\", unknown)),\n+        }\n+    }\n+}\n+\n+/// Unique identifier of the assist, should not be shown to the user\n+/// directly.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct AssistId(pub &'static str, pub AssistKind);\n+\n+/// A way to control how many asssist to resolve during the assist resolution.\n+/// When an assist is resolved, its edits are calculated that might be costly to always do by default.\n+#[derive(Debug)]\n+pub enum AssistResolveStrategy {\n+    /// No assists should be resolved.\n+    None,\n+    /// All assists should be resolved.\n+    All,\n+    /// Only a certain assist should be resolved.\n+    Single(SingleResolve),\n+}\n+\n+/// Hold the [`AssistId`] data of a certain assist to resolve.\n+/// The original id object cannot be used due to a `'static` lifetime\n+/// and the requirement to construct this struct dynamically during the resolve handling.\n+#[derive(Debug)]\n+pub struct SingleResolve {\n+    /// The id of the assist.\n+    pub assist_id: String,\n+    // The kind of the assist.\n+    pub assist_kind: AssistKind,\n+}\n+\n+impl AssistResolveStrategy {\n+    pub fn should_resolve(&self, id: &AssistId) -> bool {\n+        match self {\n+            AssistResolveStrategy::None => false,\n+            AssistResolveStrategy::All => true,\n+            AssistResolveStrategy::Single(single_resolve) => {\n+                single_resolve.assist_id == id.0 && single_resolve.assist_kind == id.1\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct GroupLabel(pub String);"}, {"sha": "7bbd08d6f1764300125fd722f02d080e4f983aff", "filename": "crates/ide_db/src/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Flib.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -3,18 +3,21 @@\n //! It is mainly a `HirDatabase` for semantic analysis, plus a `SymbolsDatabase`, for fuzzy search.\n \n mod apply_change;\n+pub mod assists;\n pub mod label;\n pub mod line_index;\n pub mod symbol_index;\n pub mod defs;\n-pub mod search;\n pub mod items_locator;\n pub mod source_change;\n pub mod ty_filter;\n pub mod traits;\n pub mod call_info;\n pub mod helpers;\n \n+pub mod search;\n+pub mod rename;\n+\n use std::{fmt, sync::Arc};\n \n use base_db::{"}, {"sha": "82855725fa179cbd7a6e95a8551398015b00aa55", "filename": "crates/ide_db/src/rename.rs", "status": "added", "additions": 468, "deletions": 0, "changes": 468, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Frename.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -0,0 +1,468 @@\n+//! Rename infrastructure for rust-analyzer. It is used primarily for the\n+//! literal \"rename\" in the ide (look for tests there), but it is also available\n+//! as a general-purpose service. For example, it is used by the fix for the\n+//! \"incorrect case\" diagnostic.\n+//!\n+//! It leverages the [`crate::search`] functionality to find what needs to be\n+//! renamed. The actual renames are tricky -- field shorthands need special\n+//! attention, and, when renaming modules, you also want to rename files on the\n+//! file system.\n+//!\n+//! Another can of worms are macros:\n+//!\n+//! ```\n+//! macro_rules! m { () => { fn f() {} } }\n+//! m!();\n+//! fn main() {\n+//!     f() // <- rename me\n+//! }\n+//! ```\n+//!\n+//! The correct behavior in such cases is probably to show a dialog to the user.\n+//! Our current behavior is \u00af\\_(\u30c4)_/\u00af.\n+use std::fmt;\n+\n+use base_db::{AnchoredPathBuf, FileId, FileRange};\n+use either::Either;\n+use hir::{AsAssocItem, FieldSource, HasSource, InFile, ModuleSource, Semantics};\n+use stdx::never;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    lex_single_syntax_kind, AstNode, SyntaxKind, TextRange, T,\n+};\n+use text_edit::TextEdit;\n+\n+use crate::{\n+    defs::Definition,\n+    search::FileReference,\n+    source_change::{FileSystemEdit, SourceChange},\n+    RootDatabase,\n+};\n+\n+pub type Result<T, E = RenameError> = std::result::Result<T, E>;\n+\n+#[derive(Debug)]\n+pub struct RenameError(pub String);\n+\n+impl fmt::Display for RenameError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! _format_err {\n+    ($fmt:expr) => { RenameError(format!($fmt)) };\n+    ($fmt:expr, $($arg:tt)+) => { RenameError(format!($fmt, $($arg)+)) }\n+}\n+pub use _format_err as format_err;\n+\n+#[macro_export]\n+macro_rules! _bail {\n+    ($($tokens:tt)*) => { return Err(format_err!($($tokens)*)) }\n+}\n+pub use _bail as bail;\n+\n+impl Definition {\n+    pub fn rename(&self, sema: &Semantics<RootDatabase>, new_name: &str) -> Result<SourceChange> {\n+        match *self {\n+            Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                rename_mod(sema, module, new_name)\n+            }\n+            Definition::ModuleDef(hir::ModuleDef::BuiltinType(_)) => {\n+                bail!(\"Cannot rename builtin type\")\n+            }\n+            Definition::SelfType(_) => bail!(\"Cannot rename `Self`\"),\n+            def => rename_reference(sema, def, new_name),\n+        }\n+    }\n+\n+    /// Textual range of the identifier which will change when renaming this\n+    /// `Definition`. Note that some definitions, like buitin types, can't be\n+    /// renamed.\n+    pub fn range_for_rename(self, sema: &Semantics<RootDatabase>) -> Option<FileRange> {\n+        // FIXME: the `original_file_range` calls here are wrong -- they never fail,\n+        // and _fall back_ to the entirety of the macro call. Such fall back is\n+        // incorrect for renames. The safe behavior would be to return an error for\n+        // such cases. The correct behavior would be to return an auxiliary list of\n+        // \"can't rename these occurrences in macros\" items, and then show some kind\n+        // of a dialog to the user. See:\n+        cov_mark::hit!(macros_are_broken_lol);\n+\n+        let res = match self {\n+            Definition::Macro(mac) => {\n+                let src = mac.source(sema.db)?;\n+                let name = match &src.value {\n+                    Either::Left(it) => it.name()?,\n+                    Either::Right(it) => it.name()?,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            Definition::Field(field) => {\n+                let src = field.source(sema.db)?;\n+\n+                match &src.value {\n+                    FieldSource::Named(record_field) => {\n+                        let name = record_field.name()?;\n+                        src.with_value(name.syntax()).original_file_range(sema.db)\n+                    }\n+                    FieldSource::Pos(_) => {\n+                        return None;\n+                    }\n+                }\n+            }\n+            Definition::ModuleDef(module_def) => match module_def {\n+                hir::ModuleDef::Module(module) => {\n+                    let src = module.declaration_source(sema.db)?;\n+                    let name = src.value.name()?;\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                hir::ModuleDef::Function(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Adt(adt) => match adt {\n+                    hir::Adt::Struct(it) => name_range(it, sema)?,\n+                    hir::Adt::Union(it) => name_range(it, sema)?,\n+                    hir::Adt::Enum(it) => name_range(it, sema)?,\n+                },\n+                hir::ModuleDef::Variant(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Const(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Static(it) => name_range(it, sema)?,\n+                hir::ModuleDef::Trait(it) => name_range(it, sema)?,\n+                hir::ModuleDef::TypeAlias(it) => name_range(it, sema)?,\n+                hir::ModuleDef::BuiltinType(_) => return None,\n+            },\n+            Definition::SelfType(_) => return None,\n+            Definition::Local(local) => {\n+                let src = local.source(sema.db);\n+                let name = match &src.value {\n+                    Either::Left(bind_pat) => bind_pat.name()?,\n+                    Either::Right(_) => return None,\n+                };\n+                src.with_value(name.syntax()).original_file_range(sema.db)\n+            }\n+            Definition::GenericParam(generic_param) => match generic_param {\n+                hir::GenericParam::TypeParam(type_param) => {\n+                    let src = type_param.source(sema.db)?;\n+                    let name = match &src.value {\n+                        Either::Left(_) => return None,\n+                        Either::Right(type_param) => type_param.name()?,\n+                    };\n+                    src.with_value(name.syntax()).original_file_range(sema.db)\n+                }\n+                hir::GenericParam::LifetimeParam(lifetime_param) => {\n+                    let src = lifetime_param.source(sema.db)?;\n+                    let lifetime = src.value.lifetime()?;\n+                    src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+                }\n+                hir::GenericParam::ConstParam(it) => name_range(it, sema)?,\n+            },\n+            Definition::Label(label) => {\n+                let src = label.source(sema.db);\n+                let lifetime = src.value.lifetime()?;\n+                src.with_value(lifetime.syntax()).original_file_range(sema.db)\n+            }\n+        };\n+        return Some(res);\n+\n+        fn name_range<D>(def: D, sema: &Semantics<RootDatabase>) -> Option<FileRange>\n+        where\n+            D: HasSource,\n+            D::Ast: ast::NameOwner,\n+        {\n+            let src = def.source(sema.db)?;\n+            let name = src.value.name()?;\n+            let res = src.with_value(name.syntax()).original_file_range(sema.db);\n+            Some(res)\n+        }\n+    }\n+}\n+\n+fn rename_mod(\n+    sema: &Semantics<RootDatabase>,\n+    module: hir::Module,\n+    new_name: &str,\n+) -> Result<SourceChange> {\n+    if IdentifierKind::classify(new_name)? != IdentifierKind::Ident {\n+        bail!(\"Invalid name `{0}`: cannot rename module to {0}\", new_name);\n+    }\n+\n+    let mut source_change = SourceChange::default();\n+\n+    let InFile { file_id, value: def_source } = module.definition_source(sema.db);\n+    let file_id = file_id.original_file(sema.db);\n+    if let ModuleSource::SourceFile(..) = def_source {\n+        // mod is defined in path/to/dir/mod.rs\n+        let path = if module.is_mod_rs(sema.db) {\n+            format!(\"../{}/mod.rs\", new_name)\n+        } else {\n+            format!(\"{}.rs\", new_name)\n+        };\n+        let dst = AnchoredPathBuf { anchor: file_id, path };\n+        let move_file = FileSystemEdit::MoveFile { src: file_id, dst };\n+        source_change.push_file_system_edit(move_file);\n+    }\n+\n+    if let Some(InFile { file_id, value: decl_source }) = module.declaration_source(sema.db) {\n+        let file_id = file_id.original_file(sema.db);\n+        match decl_source.name() {\n+            Some(name) => source_change.insert_source_edit(\n+                file_id,\n+                TextEdit::replace(name.syntax().text_range(), new_name.to_string()),\n+            ),\n+            _ => never!(\"Module source node is missing a name\"),\n+        }\n+    }\n+    let def = Definition::ModuleDef(hir::ModuleDef::Module(module));\n+    let usages = def.usages(sema).all();\n+    let ref_edits = usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(references, def, new_name))\n+    });\n+    source_change.extend(ref_edits);\n+\n+    Ok(source_change)\n+}\n+\n+fn rename_reference(\n+    sema: &Semantics<RootDatabase>,\n+    mut def: Definition,\n+    new_name: &str,\n+) -> Result<SourceChange> {\n+    let ident_kind = IdentifierKind::classify(new_name)?;\n+\n+    if matches!(\n+        def, // is target a lifetime?\n+        Definition::GenericParam(hir::GenericParam::LifetimeParam(_)) | Definition::Label(_)\n+    ) {\n+        match ident_kind {\n+            IdentifierKind::Ident | IdentifierKind::Underscore => {\n+                cov_mark::hit!(rename_not_a_lifetime_ident_ref);\n+                bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name);\n+            }\n+            IdentifierKind::Lifetime => cov_mark::hit!(rename_lifetime),\n+        }\n+    } else {\n+        match (ident_kind, def) {\n+            (IdentifierKind::Lifetime, _) => {\n+                cov_mark::hit!(rename_not_an_ident_ref);\n+                bail!(\"Invalid name `{}`: not an identifier\", new_name);\n+            }\n+            (IdentifierKind::Ident, _) => cov_mark::hit!(rename_non_local),\n+            (IdentifierKind::Underscore, _) => (),\n+        }\n+    }\n+\n+    def = match def {\n+        // HACK: resolve trait impl items to the item def of the trait definition\n+        // so that we properly resolve all trait item references\n+        Definition::ModuleDef(mod_def) => mod_def\n+            .as_assoc_item(sema.db)\n+            .and_then(|it| it.containing_trait_impl(sema.db))\n+            .and_then(|it| {\n+                it.items(sema.db).into_iter().find_map(|it| match (it, mod_def) {\n+                    (hir::AssocItem::Function(trait_func), hir::ModuleDef::Function(func))\n+                        if trait_func.name(sema.db) == func.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Function(trait_func)))\n+                    }\n+                    (hir::AssocItem::Const(trait_konst), hir::ModuleDef::Const(konst))\n+                        if trait_konst.name(sema.db) == konst.name(sema.db) =>\n+                    {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::Const(trait_konst)))\n+                    }\n+                    (\n+                        hir::AssocItem::TypeAlias(trait_type_alias),\n+                        hir::ModuleDef::TypeAlias(type_alias),\n+                    ) if trait_type_alias.name(sema.db) == type_alias.name(sema.db) => {\n+                        Some(Definition::ModuleDef(hir::ModuleDef::TypeAlias(trait_type_alias)))\n+                    }\n+                    _ => None,\n+                })\n+            })\n+            .unwrap_or(def),\n+        _ => def,\n+    };\n+    let usages = def.usages(sema).all();\n+\n+    if !usages.is_empty() && ident_kind == IdentifierKind::Underscore {\n+        cov_mark::hit!(rename_underscore_multiple);\n+        bail!(\"Cannot rename reference to `_` as it is being referenced multiple times\");\n+    }\n+    let mut source_change = SourceChange::default();\n+    source_change.extend(usages.iter().map(|(&file_id, references)| {\n+        (file_id, source_edit_from_references(references, def, new_name))\n+    }));\n+\n+    let (file_id, edit) = source_edit_from_def(sema, def, new_name)?;\n+    source_change.insert_source_edit(file_id, edit);\n+    Ok(source_change)\n+}\n+\n+pub fn source_edit_from_references(\n+    references: &[FileReference],\n+    def: Definition,\n+    new_name: &str,\n+) -> TextEdit {\n+    let mut edit = TextEdit::builder();\n+    for reference in references {\n+        let (range, replacement) = match &reference.name {\n+            // if the ranges differ then the node is inside a macro call, we can't really attempt\n+            // to make special rewrites like shorthand syntax and such, so just rename the node in\n+            // the macro input\n+            ast::NameLike::NameRef(name_ref)\n+                if name_ref.syntax().text_range() == reference.range =>\n+            {\n+                source_edit_from_name_ref(name_ref, new_name, def)\n+            }\n+            ast::NameLike::Name(name) if name.syntax().text_range() == reference.range => {\n+                source_edit_from_name(name, new_name)\n+            }\n+            _ => None,\n+        }\n+        .unwrap_or_else(|| (reference.range, new_name.to_string()));\n+        edit.replace(range, replacement);\n+    }\n+    edit.finish()\n+}\n+\n+fn source_edit_from_name(name: &ast::Name, new_name: &str) -> Option<(TextRange, String)> {\n+    if let Some(_) = ast::RecordPatField::for_field_name(name) {\n+        if let Some(ident_pat) = name.syntax().parent().and_then(ast::IdentPat::cast) {\n+            return Some((\n+                TextRange::empty(ident_pat.syntax().text_range().start()),\n+                [new_name, \": \"].concat(),\n+            ));\n+        }\n+    }\n+    None\n+}\n+\n+fn source_edit_from_name_ref(\n+    name_ref: &ast::NameRef,\n+    new_name: &str,\n+    def: Definition,\n+) -> Option<(TextRange, String)> {\n+    if let Some(record_field) = ast::RecordExprField::for_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_expr = record_field.expr();\n+        match (rcf_name_ref, rcf_expr.and_then(|it| it.name_ref())) {\n+            // field: init-expr, check if we can use a field init shorthand\n+            (Some(field_name), Some(init)) => {\n+                if field_name == *name_ref {\n+                    if init.text() == new_name {\n+                        cov_mark::hit!(test_rename_field_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                } else if init == *name_ref {\n+                    if field_name.text() == new_name {\n+                        cov_mark::hit!(test_rename_local_put_init_shorthand);\n+                        // same names, we can use a shorthand here instead.\n+                        // we do not want to erase attributes hence this range start\n+                        let s = field_name.syntax().text_range().start();\n+                        let e = record_field.syntax().text_range().end();\n+                        return Some((TextRange::new(s, e), new_name.to_owned()));\n+                    }\n+                }\n+                None\n+            }\n+            // init shorthand\n+            // FIXME: instead of splitting the shorthand, recursively trigger a rename of the\n+            // other name https://github.com/rust-analyzer/rust-analyzer/issues/6547\n+            (None, Some(_)) if matches!(def, Definition::Field(_)) => {\n+                cov_mark::hit!(test_rename_field_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().start();\n+                Some((TextRange::empty(s), format!(\"{}: \", new_name)))\n+            }\n+            (None, Some(_)) if matches!(def, Definition::Local(_)) => {\n+                cov_mark::hit!(test_rename_local_in_field_shorthand);\n+                let s = name_ref.syntax().text_range().end();\n+                Some((TextRange::empty(s), format!(\": {}\", new_name)))\n+            }\n+            _ => None,\n+        }\n+    } else if let Some(record_field) = ast::RecordPatField::for_field_name_ref(name_ref) {\n+        let rcf_name_ref = record_field.name_ref();\n+        let rcf_pat = record_field.pat();\n+        match (rcf_name_ref, rcf_pat) {\n+            // field: rename\n+            (Some(field_name), Some(ast::Pat::IdentPat(pat))) if field_name == *name_ref => {\n+                // field name is being renamed\n+                if pat.name().map_or(false, |it| it.text() == new_name) {\n+                    cov_mark::hit!(test_rename_field_put_init_shorthand_pat);\n+                    // same names, we can use a shorthand here instead/\n+                    // we do not want to erase attributes hence this range start\n+                    let s = field_name.syntax().text_range().start();\n+                    let e = record_field.syntax().text_range().end();\n+                    Some((TextRange::new(s, e), pat.to_string()))\n+                } else {\n+                    None\n+                }\n+            }\n+            _ => None,\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+fn source_edit_from_def(\n+    sema: &Semantics<RootDatabase>,\n+    def: Definition,\n+    new_name: &str,\n+) -> Result<(FileId, TextEdit)> {\n+    let frange = def\n+        .range_for_rename(sema)\n+        .ok_or_else(|| format_err!(\"No identifier available to rename\"))?;\n+\n+    let mut replacement_text = String::new();\n+    let mut repl_range = frange.range;\n+    if let Definition::Local(local) = def {\n+        if let Either::Left(pat) = local.source(sema.db).value {\n+            if matches!(\n+                pat.syntax().parent().and_then(ast::RecordPatField::cast),\n+                Some(pat_field) if pat_field.name_ref().is_none()\n+            ) {\n+                replacement_text.push_str(\": \");\n+                replacement_text.push_str(new_name);\n+                repl_range = TextRange::new(\n+                    pat.syntax().text_range().end(),\n+                    pat.syntax().text_range().end(),\n+                );\n+            }\n+        }\n+    }\n+    if replacement_text.is_empty() {\n+        replacement_text.push_str(new_name);\n+    }\n+    let edit = TextEdit::replace(repl_range, replacement_text);\n+    Ok((frange.file_id, edit))\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum IdentifierKind {\n+    Ident,\n+    Lifetime,\n+    Underscore,\n+}\n+\n+impl IdentifierKind {\n+    pub fn classify(new_name: &str) -> Result<IdentifierKind> {\n+        match lex_single_syntax_kind(new_name) {\n+            Some(res) => match res {\n+                (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n+                (T![_], _) => Ok(IdentifierKind::Underscore),\n+                (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n+                    Ok(IdentifierKind::Lifetime)\n+                }\n+                (SyntaxKind::LIFETIME_IDENT, _) => {\n+                    bail!(\"Invalid name `{}`: not a lifetime identifier\", new_name)\n+                }\n+                (_, Some(syntax_error)) => bail!(\"Invalid name `{}`: {}\", new_name, syntax_error),\n+                (_, None) => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+            },\n+            None => bail!(\"Invalid name `{}`: not an identifier\", new_name),\n+        }\n+    }\n+}"}, {"sha": "fa2adf212295c55334e4fb5f891d5b1a5ef35072", "filename": "crates/ide_diagnostics/Cargo.toml", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2FCargo.toml?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -0,0 +1,29 @@\n+[package]\n+name = \"ide_diagnostics\"\n+version = \"0.0.0\"\n+description = \"TBD\"\n+license = \"MIT OR Apache-2.0\"\n+authors = [\"rust-analyzer developers\"]\n+edition = \"2018\"\n+\n+[lib]\n+doctest = false\n+\n+[dependencies]\n+cov-mark = \"2.0.0-pre.1\"\n+itertools = \"0.10.0\"\n+rustc-hash = \"1.1.0\"\n+either = \"1.5.3\"\n+\n+profile = { path = \"../profile\", version = \"0.0.0\" }\n+stdx = { path = \"../stdx\", version = \"0.0.0\" }\n+syntax = { path = \"../syntax\", version = \"0.0.0\" }\n+text_edit = { path = \"../text_edit\", version = \"0.0.0\" }\n+cfg = { path = \"../cfg\", version = \"0.0.0\" }\n+hir = { path = \"../hir\", version = \"0.0.0\" }\n+ide_db = { path = \"../ide_db\", version = \"0.0.0\" }\n+\n+[dev-dependencies]\n+expect-test = \"1.1\"\n+\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "0b6af99654e7c51cb336f86246cb7aa853b2425c", "filename": "crates/ide_diagnostics/src/field_shorthand.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Ffield_shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Ffield_shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Ffield_shorthand.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -5,7 +5,7 @@ use ide_db::{base_db::FileId, source_change::SourceChange};\n use syntax::{ast, match_ast, AstNode, SyntaxNode};\n use text_edit::TextEdit;\n \n-use crate::{diagnostics::fix, Diagnostic, Severity};\n+use crate::{fix, Diagnostic, Severity};\n \n pub(super) fn check(acc: &mut Vec<Diagnostic>, file_id: FileId, node: &SyntaxNode) {\n     match_ast! {\n@@ -101,7 +101,7 @@ fn check_pat_field_shorthand(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn test_check_expr_field_shorthand() {", "previous_filename": "crates/ide/src/diagnostics/field_shorthand.rs"}, {"sha": "5ad0fbd1bb065a4ef8d1e882bfecfc31d402cb68", "filename": "crates/ide_diagnostics/src/handlers/break_outside_of_loop.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fbreak_outside_of_loop.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,9 +1,9 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: break-outside-of-loop\n //\n // This diagnostic is triggered if the `break` keyword is used outside of a loop.\n-pub(super) fn break_outside_of_loop(\n+pub(crate) fn break_outside_of_loop(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::BreakOutsideOfLoop,\n ) -> Diagnostic {\n@@ -16,7 +16,7 @@ pub(super) fn break_outside_of_loop(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn break_outside_of_loop() {", "previous_filename": "crates/ide/src/diagnostics/break_outside_of_loop.rs"}, {"sha": "4b722fd64b7933e1491e6318e6464f0eefa7ad23", "filename": "crates/ide_diagnostics/src/handlers/inactive_code.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Finactive_code.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,15 +1,12 @@\n use cfg::DnfExpr;\n use stdx::format_to;\n \n-use crate::{\n-    diagnostics::{Diagnostic, DiagnosticsContext},\n-    Severity,\n-};\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n \n // Diagnostic: inactive-code\n //\n // This diagnostic is shown for code with inactive `#[cfg]` attributes.\n-pub(super) fn inactive_code(\n+pub(crate) fn inactive_code(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::InactiveCode,\n ) -> Option<Diagnostic> {\n@@ -37,7 +34,7 @@ pub(super) fn inactive_code(\n \n #[cfg(test)]\n mod tests {\n-    use crate::{diagnostics::tests::check_diagnostics_with_config, DiagnosticsConfig};\n+    use crate::{tests::check_diagnostics_with_config, DiagnosticsConfig};\n \n     pub(crate) fn check(ra_fixture: &str) {\n         let config = DiagnosticsConfig::default();", "previous_filename": "crates/ide/src/diagnostics/inactive_code.rs"}, {"sha": "3a33029cf727bcaef757c22dbff8ea5507130e90", "filename": "crates/ide_diagnostics/src/handlers/incorrect_case.rs", "status": "renamed", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fincorrect_case.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,18 +1,19 @@\n use hir::{db::AstDatabase, InFile};\n-use ide_assists::Assist;\n-use ide_db::base_db::FilePosition;\n+use ide_db::{assists::Assist, defs::NameClass};\n use syntax::AstNode;\n \n use crate::{\n-    diagnostics::{unresolved_fix, Diagnostic, DiagnosticsContext},\n-    references::rename::rename_with_semantics,\n+    // references::rename::rename_with_semantics,\n+    unresolved_fix,\n+    Diagnostic,\n+    DiagnosticsContext,\n     Severity,\n };\n \n // Diagnostic: incorrect-ident-case\n //\n // This diagnostic is triggered if an item name doesn't follow https://doc.rust-lang.org/1.0.0/style/style/naming/README.html[Rust naming convention].\n-pub(super) fn incorrect_case(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Diagnostic {\n+pub(crate) fn incorrect_case(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Diagnostic {\n     Diagnostic::new(\n         \"incorrect-ident-case\",\n         format!(\n@@ -28,15 +29,15 @@ pub(super) fn incorrect_case(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCas\n fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Option<Vec<Assist>> {\n     let root = ctx.sema.db.parse_or_expand(d.file)?;\n     let name_node = d.ident.to_node(&root);\n+    let def = NameClass::classify(&ctx.sema, &name_node)?.defined(ctx.sema.db)?;\n \n     let name_node = InFile::new(d.file, name_node.syntax());\n     let frange = name_node.original_file_range(ctx.sema.db);\n-    let file_position = FilePosition { file_id: frange.file_id, offset: frange.range.start() };\n \n     let label = format!(\"Rename to {}\", d.suggested_text);\n     let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n     if ctx.resolve.should_resolve(&res.id) {\n-        let source_change = rename_with_semantics(&ctx.sema, file_position, &d.suggested_text);\n+        let source_change = def.rename(&ctx.sema, &d.suggested_text);\n         res.source_change = Some(source_change.ok().unwrap_or_default());\n     }\n \n@@ -45,10 +46,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::IncorrectCase) -> Option<Vec<Ass\n \n #[cfg(test)]\n mod change_case {\n-    use crate::{\n-        diagnostics::tests::{check_diagnostics, check_fix},\n-        fixture, AssistResolveStrategy, DiagnosticsConfig,\n-    };\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn test_rename_incorrect_case() {\n@@ -116,7 +114,7 @@ fn some_fn() {\n         check_diagnostics(\n             r#\"\n fn foo() {\n-    const ANOTHER_ITEM$0: &str = \"some_item\";\n+    const ANOTHER_ITEM: &str = \"some_item\";\n }\n \"#,\n         );\n@@ -148,20 +146,13 @@ impl TestStruct {\n \n     #[test]\n     fn test_single_incorrect_case_diagnostic_in_function_name_issue_6970() {\n-        let input = r#\"fn FOO$0() {}\"#;\n-        let expected = r#\"fn foo() {}\"#;\n-\n-        let (analysis, file_position) = fixture::position(input);\n-        let diagnostics = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap();\n-        assert_eq!(diagnostics.len(), 1);\n-\n-        check_fix(input, expected);\n+        check_diagnostics(\n+            r#\"\n+fn FOO() {}\n+// ^^^ Function `FOO` should have snake_case name, e.g. `foo`\n+\"#,\n+        );\n+        check_fix(r#\"fn FOO$0() {}\"#, r#\"fn foo() {}\"#);\n     }\n \n     #[test]", "previous_filename": "crates/ide/src/diagnostics/incorrect_case.rs"}, {"sha": "d4d928ad105c5c02aedad7be9fc5a336ac7f03b1", "filename": "crates/ide_diagnostics/src/handlers/macro_error.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmacro_error.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,9 +1,9 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: macro-error\n //\n // This diagnostic is shown for macro expansion errors.\n-pub(super) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) -> Diagnostic {\n+pub(crate) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) -> Diagnostic {\n     Diagnostic::new(\n         \"macro-error\",\n         d.message.clone(),\n@@ -15,7 +15,7 @@ pub(super) fn macro_error(ctx: &DiagnosticsContext<'_>, d: &hir::MacroError) ->\n #[cfg(test)]\n mod tests {\n     use crate::{\n-        diagnostics::tests::{check_diagnostics, check_diagnostics_with_config},\n+        tests::{check_diagnostics, check_diagnostics_with_config},\n         DiagnosticsConfig,\n     };\n ", "previous_filename": "crates/ide/src/diagnostics/macro_error.rs"}, {"sha": "ce313b2cce53d08e1cb271b23a546a9881f8df61", "filename": "crates/ide_diagnostics/src/handlers/mismatched_arg_count.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmismatched_arg_count.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,9 +1,9 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: mismatched-arg-count\n //\n // This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.\n-pub(super) fn mismatched_arg_count(\n+pub(crate) fn mismatched_arg_count(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::MismatchedArgCount,\n ) -> Diagnostic {\n@@ -18,7 +18,7 @@ pub(super) fn mismatched_arg_count(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn simple_free_fn_zero() {", "previous_filename": "crates/ide/src/diagnostics/mismatched_arg_count.rs"}, {"sha": "bc82c0e4a0d466b7f8a9d03b973733ad77f91bb1", "filename": "crates/ide_diagnostics/src/handlers/missing_fields.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,12 +1,11 @@\n use either::Either;\n use hir::{db::AstDatabase, InFile};\n-use ide_assists::Assist;\n-use ide_db::source_change::SourceChange;\n+use ide_db::{assists::Assist, source_change::SourceChange};\n use stdx::format_to;\n use syntax::{algo, ast::make, AstNode, SyntaxNodePtr};\n use text_edit::TextEdit;\n \n-use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-fields\n //\n@@ -19,7 +18,7 @@ use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n //\n // let a = A { a: 10 };\n // ```\n-pub(super) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {\n+pub(crate) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {\n     let mut message = String::from(\"Missing structure fields:\\n\");\n     for field in &d.missed_fields {\n         format_to!(message, \"- {}\\n\", field);\n@@ -77,7 +76,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn missing_record_pat_field_diagnostic() {", "previous_filename": "crates/ide/src/diagnostics/missing_fields.rs"}, {"sha": "9ea533d74fd5bcd1af5f0f1508c0d74448b29bc8", "filename": "crates/ide_diagnostics/src/handlers/missing_match_arms.rs", "status": "renamed", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_match_arms.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,11 +1,11 @@\n use hir::InFile;\n \n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-match-arm\n //\n // This diagnostic is triggered if `match` block is missing one or more match arms.\n-pub(super) fn missing_match_arms(\n+pub(crate) fn missing_match_arms(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::MissingMatchArms,\n ) -> Diagnostic {\n@@ -17,12 +17,12 @@ pub(super) fn missing_match_arms(\n }\n \n #[cfg(test)]\n-pub(super) mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+mod tests {\n+    use crate::tests::check_diagnostics;\n \n     fn check_diagnostics_no_bails(ra_fixture: &str) {\n         cov_mark::check_count!(validate_match_bailed_out, 0);\n-        crate::diagnostics::tests::check_diagnostics(ra_fixture)\n+        crate::tests::check_diagnostics(ra_fixture)\n     }\n \n     #[test]", "previous_filename": "crates/ide/src/diagnostics/missing_match_arms.rs"}, {"sha": "63de545707cb03bb5a344936ed65fac27e9e5587", "filename": "crates/ide_diagnostics/src/handlers/missing_ok_or_some_in_tail_expr.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_ok_or_some_in_tail_expr.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,10 +1,9 @@\n use hir::db::AstDatabase;\n-use ide_assists::Assist;\n-use ide_db::source_change::SourceChange;\n+use ide_db::{assists::Assist, source_change::SourceChange};\n use syntax::AstNode;\n use text_edit::TextEdit;\n \n-use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-ok-or-some-in-tail-expr\n //\n@@ -18,7 +17,7 @@ use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n //     10\n // }\n // ```\n-pub(super) fn missing_ok_or_some_in_tail_expr(\n+pub(crate) fn missing_ok_or_some_in_tail_expr(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::MissingOkOrSomeInTailExpr,\n ) -> Diagnostic {\n@@ -44,7 +43,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingOkOrSomeInTailExpr) -> Op\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn test_wrap_return_type_option() {", "previous_filename": "crates/ide/src/diagnostics/missing_ok_or_some_in_tail_expr.rs"}, {"sha": "62d8687ba75a57693ab8b68cd5f280f1fe24e488", "filename": "crates/ide_diagnostics/src/handlers/missing_unsafe.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fmissing_unsafe.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,9 +1,9 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: missing-unsafe\n //\n // This diagnostic is triggered if an operation marked as `unsafe` is used outside of an `unsafe` function or block.\n-pub(super) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Diagnostic {\n+pub(crate) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsafe) -> Diagnostic {\n     Diagnostic::new(\n         \"missing-unsafe\",\n         \"this operation is unsafe and requires an unsafe function or block\",\n@@ -13,7 +13,7 @@ pub(super) fn missing_unsafe(ctx: &DiagnosticsContext<'_>, d: &hir::MissingUnsaf\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn missing_unsafe_diagnostic_with_raw_ptr() {", "previous_filename": "crates/ide/src/diagnostics/missing_unsafe.rs"}, {"sha": "e4cc8a840d9271b578beac465083e76477f08b05", "filename": "crates/ide_diagnostics/src/handlers/no_such_field.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fno_such_field.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -6,15 +6,12 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n-    Assist,\n-};\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: no-such-field\n //\n // This diagnostic is triggered if created structure does not have field provided in record.\n-pub(super) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {\n+pub(crate) fn no_such_field(ctx: &DiagnosticsContext<'_>, d: &hir::NoSuchField) -> Diagnostic {\n     Diagnostic::new(\n         \"no-such-field\",\n         \"no such field\",\n@@ -112,7 +109,7 @@ fn missing_record_expr_field_fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn no_such_field_diagnostics() {", "previous_filename": "crates/ide/src/diagnostics/no_such_field.rs"}, {"sha": "b52e4dc84f33df28aed109c13b16348e354aa8f1", "filename": "crates/ide_diagnostics/src/handlers/remove_this_semicolon.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Fremove_this_semicolon.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -3,15 +3,12 @@ use ide_db::source_change::SourceChange;\n use syntax::{ast, AstNode};\n use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n-    Assist,\n-};\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: remove-this-semicolon\n //\n // This diagnostic is triggered when there's an erroneous `;` at the end of the block.\n-pub(super) fn remove_this_semicolon(\n+pub(crate) fn remove_this_semicolon(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::RemoveThisSemicolon,\n ) -> Diagnostic {\n@@ -45,7 +42,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::RemoveThisSemicolon) -> Option<V\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix};\n+    use crate::tests::{check_diagnostics, check_fix};\n \n     #[test]\n     fn missing_semicolon() {", "previous_filename": "crates/ide/src/diagnostics/remove_this_semicolon.rs"}, {"sha": "10d5da15dbf4b6337649a05efd65865640942162", "filename": "crates/ide_diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs", "status": "renamed", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Freplace_filter_map_next_with_find_map.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -6,15 +6,12 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, Diagnostic, DiagnosticsContext},\n-    Assist, Severity,\n-};\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext, Severity};\n \n // Diagnostic: replace-filter-map-next-with-find-map\n //\n // This diagnostic is triggered when `.filter_map(..).next()` is used, rather than the more concise `.find_map(..)`.\n-pub(super) fn replace_filter_map_next_with_find_map(\n+pub(crate) fn replace_filter_map_next_with_find_map(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::ReplaceFilterMapNextWithFindMap,\n ) -> Diagnostic {\n@@ -58,7 +55,7 @@ fn fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_fix;\n+    use crate::tests::check_fix;\n \n     // Register the required standard library types to make the tests work\n     #[track_caller]\n@@ -86,7 +83,7 @@ pub mod iter {\n     }\n }\n \"#;\n-        crate::diagnostics::tests::check_diagnostics(&format!(\"{}{}{}\", prefix, ra_fixture, suffix))\n+        crate::tests::check_diagnostics(&format!(\"{}{}{}\", prefix, ra_fixture, suffix))\n     }\n \n     #[test]", "previous_filename": "crates/ide/src/diagnostics/replace_filter_map_next_with_find_map.rs"}, {"sha": "e879de75cd8477f3d971cc244500b47074df22f3", "filename": "crates/ide_diagnostics/src/handlers/unimplemented_builtin_macro.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funimplemented_builtin_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funimplemented_builtin_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funimplemented_builtin_macro.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,12 +1,9 @@\n-use crate::{\n-    diagnostics::{Diagnostic, DiagnosticsContext},\n-    Severity,\n-};\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n \n // Diagnostic: unimplemented-builtin-macro\n //\n // This diagnostic is shown for builtin macros which are not yet implemented by rust-analyzer\n-pub(super) fn unimplemented_builtin_macro(\n+pub(crate) fn unimplemented_builtin_macro(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnimplementedBuiltinMacro,\n ) -> Diagnostic {", "previous_filename": "crates/ide/src/diagnostics/unimplemented_builtin_macro.rs"}, {"sha": "8921ddde257eae8d7c6c98ec0a0690f9f197559c", "filename": "crates/ide_diagnostics/src/handlers/unlinked_file.rs", "status": "renamed", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funlinked_file.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -12,10 +12,7 @@ use syntax::{\n };\n use text_edit::TextEdit;\n \n-use crate::{\n-    diagnostics::{fix, DiagnosticsContext},\n-    Assist, Diagnostic,\n-};\n+use crate::{fix, Assist, Diagnostic, DiagnosticsContext};\n \n #[derive(Debug)]\n pub(crate) struct UnlinkedFile {\n@@ -26,7 +23,7 @@ pub(crate) struct UnlinkedFile {\n //\n // This diagnostic is shown for files that are not included in any crate, or files that are part of\n // crates rust-analyzer failed to discover. The file will not have IDE features available.\n-pub(super) fn unlinked_file(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Diagnostic {\n+pub(crate) fn unlinked_file(ctx: &DiagnosticsContext, d: &UnlinkedFile) -> Diagnostic {\n     // Limit diagnostic to the first few characters in the file. This matches how VS Code\n     // renders it with the full span, but on other editors, and is less invasive.\n     let range = ctx.sema.db.parse(d.file).syntax_node().text_range();\n@@ -164,7 +161,7 @@ fn make_fixes(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n+    use crate::tests::{check_diagnostics, check_fix, check_fixes, check_no_fix};\n \n     #[test]\n     fn unlinked_file_prepend_first_item() {", "previous_filename": "crates/ide/src/diagnostics/unlinked_file.rs"}, {"sha": "f5313cc0c659f5cad20f39c1e5e0fc98f9404e91", "filename": "crates/ide_diagnostics/src/handlers/unresolved_extern_crate.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_extern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_extern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_extern_crate.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,9 +1,9 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: unresolved-extern-crate\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.\n-pub(super) fn unresolved_extern_crate(\n+pub(crate) fn unresolved_extern_crate(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedExternCrate,\n ) -> Diagnostic {\n@@ -16,7 +16,7 @@ pub(super) fn unresolved_extern_crate(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn unresolved_extern_crate() {", "previous_filename": "crates/ide/src/diagnostics/unresolved_extern_crate.rs"}, {"sha": "f30051c1266e859ff2cc2be35d75c83fd6ded98f", "filename": "crates/ide_diagnostics/src/handlers/unresolved_import.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_import.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,10 +1,10 @@\n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: unresolved-import\n //\n // This diagnostic is triggered if rust-analyzer is unable to resolve a path in\n // a `use` declaration.\n-pub(super) fn unresolved_import(\n+pub(crate) fn unresolved_import(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedImport,\n ) -> Diagnostic {\n@@ -22,7 +22,7 @@ pub(super) fn unresolved_import(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn unresolved_import() {", "previous_filename": "crates/ide/src/diagnostics/unresolved_import.rs"}, {"sha": "4c3c1c19afedb0c2e9ff8d39b2ecf357934e5fbd", "filename": "crates/ide_diagnostics/src/handlers/unresolved_macro_call.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,13 +1,13 @@\n use hir::{db::AstDatabase, InFile};\n use syntax::{AstNode, SyntaxNodePtr};\n \n-use crate::diagnostics::{Diagnostic, DiagnosticsContext};\n+use crate::{Diagnostic, DiagnosticsContext};\n \n // Diagnostic: unresolved-macro-call\n //\n // This diagnostic is triggered if rust-analyzer is unable to resolve the path\n // to a macro in a macro invocation.\n-pub(super) fn unresolved_macro_call(\n+pub(crate) fn unresolved_macro_call(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedMacroCall,\n ) -> Diagnostic {\n@@ -32,7 +32,7 @@ pub(super) fn unresolved_macro_call(\n \n #[cfg(test)]\n mod tests {\n-    use crate::diagnostics::tests::check_diagnostics;\n+    use crate::tests::check_diagnostics;\n \n     #[test]\n     fn unresolved_macro_diag() {", "previous_filename": "crates/ide/src/diagnostics/unresolved_macro_call.rs"}, {"sha": "17166a0c6c88e87ae4f6ba2b5a46b41e9ead73f2", "filename": "crates/ide_diagnostics/src/handlers/unresolved_module.rs", "status": "renamed", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_module.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,14 +1,13 @@\n use hir::db::AstDatabase;\n-use ide_assists::Assist;\n-use ide_db::{base_db::AnchoredPathBuf, source_change::FileSystemEdit};\n+use ide_db::{assists::Assist, base_db::AnchoredPathBuf, source_change::FileSystemEdit};\n use syntax::AstNode;\n \n-use crate::diagnostics::{fix, Diagnostic, DiagnosticsContext};\n+use crate::{fix, Diagnostic, DiagnosticsContext};\n \n // Diagnostic: unresolved-module\n //\n // This diagnostic is triggered if rust-analyzer is unable to discover referred module.\n-pub(super) fn unresolved_module(\n+pub(crate) fn unresolved_module(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedModule,\n ) -> Diagnostic {\n@@ -42,7 +41,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::UnresolvedModule) -> Option<Vec<\n mod tests {\n     use expect_test::expect;\n \n-    use crate::diagnostics::tests::{check_diagnostics, check_expect};\n+    use crate::tests::{check_diagnostics, check_expect};\n \n     #[test]\n     fn unresolved_module() {", "previous_filename": "crates/ide/src/diagnostics/unresolved_module.rs"}, {"sha": "fde1d1323f5bcdf142da117622283407c286c486", "filename": "crates/ide_diagnostics/src/handlers/unresolved_proc_macro.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Fhandlers%2Funresolved_proc_macro.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,7 +1,4 @@\n-use crate::{\n-    diagnostics::{Diagnostic, DiagnosticsContext},\n-    Severity,\n-};\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n \n // Diagnostic: unresolved-proc-macro\n //\n@@ -12,7 +9,7 @@ use crate::{\n // If you are seeing a lot of \"proc macro not expanded\" warnings, you can add this option to the\n // `rust-analyzer.diagnostics.disabled` list to prevent them from showing. Alternatively you can\n // enable support for procedural macros (see `rust-analyzer.procMacro.enable`).\n-pub(super) fn unresolved_proc_macro(\n+pub(crate) fn unresolved_proc_macro(\n     ctx: &DiagnosticsContext<'_>,\n     d: &hir::UnresolvedProcMacro,\n ) -> Diagnostic {", "previous_filename": "crates/ide/src/diagnostics/unresolved_proc_macro.rs"}, {"sha": "88037be5a92f79578ff5b7d384ffca44fe607fd9", "filename": "crates/ide_diagnostics/src/lib.rs", "status": "renamed", "additions": 117, "deletions": 85, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38ae18b7592f97a7058d97928307bccbd881a582/crates%2Fide_diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_diagnostics%2Fsrc%2Flib.rs?ref=38ae18b7592f97a7058d97928307bccbd881a582", "patch": "@@ -1,44 +1,69 @@\n-//! Collects diagnostics & fixits  for a single file.\n+//! Diagnostics rendering and fixits.\n //!\n-//! The tricky bit here is that diagnostics are produced by hir in terms of\n-//! macro-expanded files, but we need to present them to the users in terms of\n-//! original files. So we need to map the ranges.\n-\n-mod break_outside_of_loop;\n-mod inactive_code;\n-mod incorrect_case;\n-mod macro_error;\n-mod mismatched_arg_count;\n-mod missing_fields;\n-mod missing_match_arms;\n-mod missing_ok_or_some_in_tail_expr;\n-mod missing_unsafe;\n-mod no_such_field;\n-mod remove_this_semicolon;\n-mod replace_filter_map_next_with_find_map;\n-mod unimplemented_builtin_macro;\n-mod unlinked_file;\n-mod unresolved_extern_crate;\n-mod unresolved_import;\n-mod unresolved_macro_call;\n-mod unresolved_module;\n-mod unresolved_proc_macro;\n+//! Most of the diagnostics originate from the dark depth of the compiler, and\n+//! are originally expressed in term of IR. When we emit the diagnostic, we are\n+//! usually not in the position to decide how to best \"render\" it in terms of\n+//! user-authored source code. We are especially not in the position to offer\n+//! fixits, as the compiler completely lacks the infrastructure to edit the\n+//! source code.\n+//!\n+//! Instead, we \"bubble up\" raw, structured diagnostics until the `hir` crate,\n+//! where we \"cook\" them so that each diagnostic is formulated in terms of `hir`\n+//! types. Well, at least that's the aspiration, the \"cooking\" is somewhat\n+//! ad-hoc at the moment. Anyways, we get a bunch of ide-friendly diagnostic\n+//! structs from hir, and we want to render them to unified serializable\n+//! representation (span, level, message) here. If we can, we also provide\n+//! fixits. By the way, that's why we want to keep diagnostics structured\n+//! internally -- so that we have all the info to make fixes.\n+//!\n+//! We have one \"handler\" module per diagnostic code. Such a module contains\n+//! rendering, optional fixes and tests. It's OK if some low-level compiler\n+//! functionality ends up being tested via a diagnostic.\n+//!\n+//! There are also a couple of ad-hoc diagnostics implemented directly here, we\n+//! don't yet have a great pattern for how to do them properly.\n+\n+mod handlers {\n+    pub(crate) mod break_outside_of_loop;\n+    pub(crate) mod inactive_code;\n+    pub(crate) mod incorrect_case;\n+    pub(crate) mod macro_error;\n+    pub(crate) mod mismatched_arg_count;\n+    pub(crate) mod missing_fields;\n+    pub(crate) mod missing_match_arms;\n+    pub(crate) mod missing_ok_or_some_in_tail_expr;\n+    pub(crate) mod missing_unsafe;\n+    pub(crate) mod no_such_field;\n+    pub(crate) mod remove_this_semicolon;\n+    pub(crate) mod replace_filter_map_next_with_find_map;\n+    pub(crate) mod unimplemented_builtin_macro;\n+    pub(crate) mod unlinked_file;\n+    pub(crate) mod unresolved_extern_crate;\n+    pub(crate) mod unresolved_import;\n+    pub(crate) mod unresolved_macro_call;\n+    pub(crate) mod unresolved_module;\n+    pub(crate) mod unresolved_proc_macro;\n+}\n \n mod field_shorthand;\n \n use hir::{diagnostics::AnyDiagnostic, Semantics};\n-use ide_assists::AssistResolveStrategy;\n-use ide_db::{base_db::SourceDatabase, RootDatabase};\n+use ide_db::{\n+    assists::{Assist, AssistId, AssistKind, AssistResolveStrategy},\n+    base_db::{FileId, SourceDatabase},\n+    label::Label,\n+    source_change::SourceChange,\n+    RootDatabase,\n+};\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n     SyntaxNode, TextRange,\n };\n use text_edit::TextEdit;\n-use unlinked_file::UnlinkedFile;\n \n-use crate::{Assist, AssistId, AssistKind, FileId, Label, SourceChange};\n+use crate::handlers::unlinked_file::UnlinkedFile;\n \n #[derive(Copy, Clone, Debug, PartialEq)]\n pub struct DiagnosticCode(pub &'static str);\n@@ -113,7 +138,7 @@ struct DiagnosticsContext<'a> {\n     resolve: &'a AssistResolveStrategy,\n }\n \n-pub(crate) fn diagnostics(\n+pub fn diagnostics(\n     db: &RootDatabase,\n     config: &DiagnosticsConfig,\n     resolve: &AssistResolveStrategy,\n@@ -145,32 +170,32 @@ pub(crate) fn diagnostics(\n     let ctx = DiagnosticsContext { config, sema, resolve };\n     if module.is_none() {\n         let d = UnlinkedFile { file: file_id };\n-        let d = unlinked_file::unlinked_file(&ctx, &d);\n+        let d = handlers::unlinked_file::unlinked_file(&ctx, &d);\n         res.push(d)\n     }\n \n     for diag in diags {\n         #[rustfmt::skip]\n         let d = match diag {\n-            AnyDiagnostic::BreakOutsideOfLoop(d) => break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n-            AnyDiagnostic::IncorrectCase(d) => incorrect_case::incorrect_case(&ctx, &d),\n-            AnyDiagnostic::MacroError(d) => macro_error::macro_error(&ctx, &d),\n-            AnyDiagnostic::MismatchedArgCount(d) => mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n-            AnyDiagnostic::MissingFields(d) => missing_fields::missing_fields(&ctx, &d),\n-            AnyDiagnostic::MissingMatchArms(d) => missing_match_arms::missing_match_arms(&ctx, &d),\n-            AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n-            AnyDiagnostic::MissingUnsafe(d) => missing_unsafe::missing_unsafe(&ctx, &d),\n-            AnyDiagnostic::NoSuchField(d) => no_such_field::no_such_field(&ctx, &d),\n-            AnyDiagnostic::RemoveThisSemicolon(d) => remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n-            AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n-            AnyDiagnostic::UnimplementedBuiltinMacro(d) => unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n-            AnyDiagnostic::UnresolvedExternCrate(d) => unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n-            AnyDiagnostic::UnresolvedImport(d) => unresolved_import::unresolved_import(&ctx, &d),\n-            AnyDiagnostic::UnresolvedMacroCall(d) => unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n-            AnyDiagnostic::UnresolvedModule(d) => unresolved_module::unresolved_module(&ctx, &d),\n-            AnyDiagnostic::UnresolvedProcMacro(d) => unresolved_proc_macro::unresolved_proc_macro(&ctx, &d),\n-\n-            AnyDiagnostic::InactiveCode(d) => match inactive_code::inactive_code(&ctx, &d) {\n+            AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n+            AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n+            AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),\n+            AnyDiagnostic::MissingFields(d) => handlers::missing_fields::missing_fields(&ctx, &d),\n+            AnyDiagnostic::MissingMatchArms(d) => handlers::missing_match_arms::missing_match_arms(&ctx, &d),\n+            AnyDiagnostic::MissingOkOrSomeInTailExpr(d) => handlers::missing_ok_or_some_in_tail_expr::missing_ok_or_some_in_tail_expr(&ctx, &d),\n+            AnyDiagnostic::MissingUnsafe(d) => handlers::missing_unsafe::missing_unsafe(&ctx, &d),\n+            AnyDiagnostic::NoSuchField(d) => handlers::no_such_field::no_such_field(&ctx, &d),\n+            AnyDiagnostic::RemoveThisSemicolon(d) => handlers::remove_this_semicolon::remove_this_semicolon(&ctx, &d),\n+            AnyDiagnostic::ReplaceFilterMapNextWithFindMap(d) => handlers::replace_filter_map_next_with_find_map::replace_filter_map_next_with_find_map(&ctx, &d),\n+            AnyDiagnostic::UnimplementedBuiltinMacro(d) => handlers::unimplemented_builtin_macro::unimplemented_builtin_macro(&ctx, &d),\n+            AnyDiagnostic::UnresolvedExternCrate(d) => handlers::unresolved_extern_crate::unresolved_extern_crate(&ctx, &d),\n+            AnyDiagnostic::UnresolvedImport(d) => handlers::unresolved_import::unresolved_import(&ctx, &d),\n+            AnyDiagnostic::UnresolvedMacroCall(d) => handlers::unresolved_macro_call::unresolved_macro_call(&ctx, &d),\n+            AnyDiagnostic::UnresolvedModule(d) => handlers::unresolved_module::unresolved_module(&ctx, &d),\n+            AnyDiagnostic::UnresolvedProcMacro(d) => handlers::unresolved_proc_macro::unresolved_proc_macro(&ctx, &d),\n+\n+            AnyDiagnostic::InactiveCode(d) => match handlers::inactive_code::inactive_code(&ctx, &d) {\n                 Some(it) => it,\n                 None => continue,\n             }\n@@ -261,11 +286,15 @@ fn unresolved_fix(id: &'static str, label: &str, target: TextRange) -> Assist {\n #[cfg(test)]\n mod tests {\n     use expect_test::Expect;\n-    use ide_assists::AssistResolveStrategy;\n+    use ide_db::{\n+        assists::AssistResolveStrategy,\n+        base_db::{fixture::WithFixture, SourceDatabaseExt},\n+        RootDatabase,\n+    };\n     use stdx::trim_indent;\n     use test_utils::{assert_eq_text, extract_annotations};\n \n-    use crate::{fixture, DiagnosticsConfig};\n+    use crate::DiagnosticsConfig;\n \n     /// Takes a multi-file input fixture with annotated cursor positions,\n     /// and checks that:\n@@ -291,21 +320,20 @@ mod tests {\n     fn check_nth_fix(nth: usize, ra_fixture_before: &str, ra_fixture_after: &str) {\n         let after = trim_indent(ra_fixture_after);\n \n-        let (analysis, file_position) = fixture::position(ra_fixture_before);\n-        let diagnostic = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap()\n-            .pop()\n-            .expect(\"no diagnostics\");\n+        let (db, file_position) = RootDatabase::with_position(ra_fixture_before);\n+        let diagnostic = super::diagnostics(\n+            &db,\n+            &DiagnosticsConfig::default(),\n+            &AssistResolveStrategy::All,\n+            file_position.file_id,\n+        )\n+        .pop()\n+        .expect(\"no diagnostics\");\n         let fix = &diagnostic.fixes.expect(\"diagnostic misses fixes\")[nth];\n         let actual = {\n             let source_change = fix.source_change.as_ref().unwrap();\n             let file_id = *source_change.source_file_edits.keys().next().unwrap();\n-            let mut actual = analysis.file_text(file_id).unwrap().to_string();\n+            let mut actual = db.file_text(file_id).to_string();\n \n             for edit in source_change.source_file_edits.values() {\n                 edit.apply(&mut actual);\n@@ -324,24 +352,26 @@ mod tests {\n \n     /// Checks that there's a diagnostic *without* fix at `$0`.\n     pub(crate) fn check_no_fix(ra_fixture: &str) {\n-        let (analysis, file_position) = fixture::position(ra_fixture);\n-        let diagnostic = analysis\n-            .diagnostics(\n-                &DiagnosticsConfig::default(),\n-                AssistResolveStrategy::All,\n-                file_position.file_id,\n-            )\n-            .unwrap()\n-            .pop()\n-            .unwrap();\n+        let (db, file_position) = RootDatabase::with_position(ra_fixture);\n+        let diagnostic = super::diagnostics(\n+            &db,\n+            &DiagnosticsConfig::default(),\n+            &AssistResolveStrategy::All,\n+            file_position.file_id,\n+        )\n+        .pop()\n+        .unwrap();\n         assert!(diagnostic.fixes.is_none(), \"got a fix when none was expected: {:?}\", diagnostic);\n     }\n \n     pub(crate) fn check_expect(ra_fixture: &str, expect: Expect) {\n-        let (analysis, file_id) = fixture::file(ra_fixture);\n-        let diagnostics = analysis\n-            .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n-            .unwrap();\n+        let (db, file_id) = RootDatabase::with_single_file(ra_fixture);\n+        let diagnostics = super::diagnostics(\n+            &db,\n+            &DiagnosticsConfig::default(),\n+            &AssistResolveStrategy::All,\n+            file_id,\n+        );\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n@@ -354,12 +384,12 @@ mod tests {\n \n     #[track_caller]\n     pub(crate) fn check_diagnostics_with_config(config: DiagnosticsConfig, ra_fixture: &str) {\n-        let (analysis, files) = fixture::files(ra_fixture);\n+        let (db, files) = RootDatabase::with_many_files(ra_fixture);\n         for file_id in files {\n             let diagnostics =\n-                analysis.diagnostics(&config, AssistResolveStrategy::All, file_id).unwrap();\n+                super::diagnostics(&db, &config, &AssistResolveStrategy::All, file_id);\n \n-            let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n+            let expected = extract_annotations(&*db.file_text(file_id));\n             let mut actual =\n                 diagnostics.into_iter().map(|d| (d.range, d.message)).collect::<Vec<_>>();\n             actual.sort_by_key(|(range, _)| range.start());\n@@ -455,15 +485,17 @@ mod a {\n         let mut config = DiagnosticsConfig::default();\n         config.disabled.insert(\"unresolved-module\".into());\n \n-        let (analysis, file_id) = fixture::file(r#\"mod foo;\"#);\n+        let (db, file_id) = RootDatabase::with_single_file(r#\"mod foo;\"#);\n \n-        let diagnostics =\n-            analysis.diagnostics(&config, AssistResolveStrategy::All, file_id).unwrap();\n+        let diagnostics = super::diagnostics(&db, &config, &AssistResolveStrategy::All, file_id);\n         assert!(diagnostics.is_empty());\n \n-        let diagnostics = analysis\n-            .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n-            .unwrap();\n+        let diagnostics = super::diagnostics(\n+            &db,\n+            &DiagnosticsConfig::default(),\n+            &AssistResolveStrategy::All,\n+            file_id,\n+        );\n         assert!(!diagnostics.is_empty());\n     }\n ", "previous_filename": "crates/ide/src/diagnostics.rs"}]}