{"sha": "bc3f373cbb31174ab9956ea9de4b67a56065651d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjM2YzNzNjYmIzMTE3NGFiOTk1NmVhOWRlNGI2N2E1NjA2NTY1MWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-30T08:53:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-30T08:53:03Z"}, "message": "Rollup merge of #61321 - Centril:is_keyword_ahead, r=petrochenkov\n\nlibsyntax: introduce 'fn is_keyword_ahead(dist, keywords)'.\n\nIntroduces:\n```rust\n    /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n    fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n        self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n    }\n```\n\nr? @oli-obk", "tree": {"sha": "b8234e9642f2ffcc06021fe45dcd1dc20d8cc65a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8234e9642f2ffcc06021fe45dcd1dc20d8cc65a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc3f373cbb31174ab9956ea9de4b67a56065651d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc75nvCRBK7hj4Ov3rIwAAdHIIAI8Ckq/McAxjqFJam4mvxiLf\nx8nR3qXRm4JK3nOMjs2QG5Bp++8av0pAZGYg8j79gXf6mmoFu/pj/RaZJWi5n1Ya\nOwn9poq+ev5HncQ3N6A6wrVEy3KBmU6MTm/T62NGpdP1bCj6kdbHtFrXrjEiV2ao\nFK+L/Hl73X4p1YLsREgvzieq2JmP5fJS2KWYKX078sOW7nAZil966FZsTdPh6ei6\n1zvxJoNqkbiVgZpENTVuODnYxEU6Ehj33EgIahkJOP8J87swdn08jjoni/RH+OsF\nYz8RRUagwQAFYeQm6Vx4Z8DmtjYPXsknoAmN9cS0dShB5+uQDs0czCp1Jb12mXw=\n=4g38\n-----END PGP SIGNATURE-----\n", "payload": "tree b8234e9642f2ffcc06021fe45dcd1dc20d8cc65a\nparent 8cb5885adc2bab77e4dcbcf86f99ae4efa26a1f6\nparent 5d72ac36393cace0ef7845c39cc46a9555dfdcb8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559206383 +0200\ncommitter GitHub <noreply@github.com> 1559206383 +0200\n\nRollup merge of #61321 - Centril:is_keyword_ahead, r=petrochenkov\n\nlibsyntax: introduce 'fn is_keyword_ahead(dist, keywords)'.\n\nIntroduces:\n```rust\n    /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n    fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n        self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n    }\n```\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc3f373cbb31174ab9956ea9de4b67a56065651d", "html_url": "https://github.com/rust-lang/rust/commit/bc3f373cbb31174ab9956ea9de4b67a56065651d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc3f373cbb31174ab9956ea9de4b67a56065651d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cb5885adc2bab77e4dcbcf86f99ae4efa26a1f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cb5885adc2bab77e4dcbcf86f99ae4efa26a1f6", "html_url": "https://github.com/rust-lang/rust/commit/8cb5885adc2bab77e4dcbcf86f99ae4efa26a1f6"}, {"sha": "5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d72ac36393cace0ef7845c39cc46a9555dfdcb8", "html_url": "https://github.com/rust-lang/rust/commit/5d72ac36393cace0ef7845c39cc46a9555dfdcb8"}], "stats": {"total": 73, "additions": 38, "deletions": 35}, "files": [{"sha": "746e9cad4962ca4057e9214ef433aedaedade7f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bc3f373cbb31174ab9956ea9de4b67a56065651d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc3f373cbb31174ab9956ea9de4b67a56065651d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bc3f373cbb31174ab9956ea9de4b67a56065651d", "patch": "@@ -1087,6 +1087,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Returns whether any of the given keywords are `dist` tokens ahead of the current one.\n+    fn is_keyword_ahead(&self, dist: usize, kws: &[Symbol]) -> bool {\n+        self.look_ahead(dist, |t| kws.iter().any(|&kw| t.is_keyword(kw)))\n+    }\n+\n     /// Is the current token one of the keywords that signals a bare function type?\n     fn token_is_bare_fn_keyword(&mut self) -> bool {\n         self.check_keyword(kw::Fn) ||\n@@ -4270,7 +4275,7 @@ impl<'a> Parser<'a> {\n         self.token.is_keyword(kw::Async) &&\n         (\n             ( // `async move {`\n-                self.look_ahead(1, |t| t.is_keyword(kw::Move)) &&\n+                self.is_keyword_ahead(1, &[kw::Move]) &&\n                 self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace))\n             ) || ( // `async {`\n                 self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n@@ -4280,12 +4285,12 @@ impl<'a> Parser<'a> {\n \n     fn is_async_fn(&self) -> bool {\n         self.token.is_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n     }\n \n     fn is_do_catch_block(&self) -> bool {\n         self.token.is_keyword(kw::Do) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Catch)) &&\n+        self.is_keyword_ahead(1, &[kw::Catch]) &&\n         self.look_ahead(2, |t| *t == token::OpenDelim(token::Brace)) &&\n         !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n     }\n@@ -4309,17 +4314,17 @@ impl<'a> Parser<'a> {\n \n     fn is_existential_type_decl(&self) -> bool {\n         self.token.is_keyword(kw::Existential) &&\n-        self.look_ahead(1, |t| t.is_keyword(kw::Type))\n+        self.is_keyword_ahead(1, &[kw::Type])\n     }\n \n     fn is_auto_trait_item(&self) -> bool {\n         // auto trait\n-        (self.token.is_keyword(kw::Auto)\n-            && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+        (self.token.is_keyword(kw::Auto) &&\n+            self.is_keyword_ahead(1, &[kw::Trait]))\n         || // unsafe auto trait\n         (self.token.is_keyword(kw::Unsafe) &&\n-         self.look_ahead(1, |t| t.is_keyword(kw::Auto)) &&\n-         self.look_ahead(2, |t| t.is_keyword(kw::Trait)))\n+         self.is_keyword_ahead(1, &[kw::Auto]) &&\n+         self.is_keyword_ahead(2, &[kw::Trait]))\n     }\n \n     fn eat_macro_def(&mut self, attrs: &[Attribute], vis: &Visibility, lo: Span)\n@@ -5486,7 +5491,7 @@ impl<'a> Parser<'a> {\n                 (if isolated_self(self, 1) {\n                     self.bump();\n                     SelfKind::Region(None, Mutability::Immutable)\n-                } else if self.look_ahead(1, |t| t.is_keyword(kw::Mut)) &&\n+                } else if self.is_keyword_ahead(1, &[kw::Mut]) &&\n                           isolated_self(self, 2) {\n                     self.bump();\n                     self.bump();\n@@ -5497,7 +5502,7 @@ impl<'a> Parser<'a> {\n                     let lt = self.expect_lifetime();\n                     SelfKind::Region(Some(lt), Mutability::Immutable)\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n-                          self.look_ahead(2, |t| t.is_keyword(kw::Mut)) &&\n+                          self.is_keyword_ahead(2, &[kw::Mut]) &&\n                           isolated_self(self, 3) {\n                     self.bump();\n                     let lt = self.expect_lifetime();\n@@ -5676,8 +5681,7 @@ impl<'a> Parser<'a> {\n     /// (returns `false` for things like `const fn`, etc.).\n     fn is_const_item(&self) -> bool {\n         self.token.is_keyword(kw::Const) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Fn)) &&\n-            !self.look_ahead(1, |t| t.is_keyword(kw::Unsafe))\n+            !self.is_keyword_ahead(1, &[kw::Fn, kw::Unsafe])\n     }\n \n     /// Parses all the \"front matter\" for a `fn` declaration, up to\n@@ -5955,7 +5959,7 @@ impl<'a> Parser<'a> {\n              self.look_ahead(1, |t| t.is_lifetime() || t.is_ident()) &&\n                 self.look_ahead(2, |t| t == &token::Gt || t == &token::Comma ||\n                                        t == &token::Colon || t == &token::Eq) ||\n-             self.look_ahead(1, |t| t.is_keyword(kw::Const)))\n+            self.is_keyword_ahead(1, &[kw::Const]))\n     }\n \n     fn parse_impl_body(&mut self) -> PResult<'a, (Vec<ImplItem>, Vec<Attribute>)> {\n@@ -6316,7 +6320,7 @@ impl<'a> Parser<'a> {\n             // `()` or a tuple might be allowed. For example, `struct Struct(pub (), pub (usize));`.\n             // Because of this, we only `bump` the `(` if we're assured it is appropriate to do so\n             // by the following tokens.\n-            if self.look_ahead(1, |t| t.is_keyword(kw::Crate)) &&\n+            if self.is_keyword_ahead(1, &[kw::Crate]) &&\n                 self.look_ahead(2, |t| t != &token::ModSep) // account for `pub(crate::foo)`\n             {\n                 // `pub(crate)`\n@@ -6328,7 +6332,7 @@ impl<'a> Parser<'a> {\n                     VisibilityKind::Crate(CrateSugar::PubCrate),\n                 );\n                 return Ok(vis)\n-            } else if self.look_ahead(1, |t| t.is_keyword(kw::In)) {\n+            } else if self.is_keyword_ahead(1, &[kw::In]) {\n                 // `pub(in path)`\n                 self.bump(); // `(`\n                 self.bump(); // `in`\n@@ -6340,8 +6344,7 @@ impl<'a> Parser<'a> {\n                 });\n                 return Ok(vis)\n             } else if self.look_ahead(2, |t| t == &token::CloseDelim(token::Paren)) &&\n-                      self.look_ahead(1, |t| t.is_keyword(kw::Super) ||\n-                                             t.is_keyword(kw::SelfLower))\n+                      self.is_keyword_ahead(1, &[kw::Super, kw::SelfLower])\n             {\n                 // `pub(self)` or `pub(super)`\n                 self.bump(); // `(`\n@@ -6380,13 +6383,16 @@ impl<'a> Parser<'a> {\n     fn parse_defaultness(&mut self) -> Defaultness {\n         // `pub` is included for better error messages\n         if self.check_keyword(kw::Default) &&\n-           self.look_ahead(1, |t| t.is_keyword(kw::Impl) ||\n-                                  t.is_keyword(kw::Const) ||\n-                                  t.is_keyword(kw::Fn) ||\n-                                  t.is_keyword(kw::Unsafe) ||\n-                                  t.is_keyword(kw::Extern) ||\n-                                  t.is_keyword(kw::Type) ||\n-                                  t.is_keyword(kw::Pub)) {\n+            self.is_keyword_ahead(1, &[\n+                kw::Impl,\n+                kw::Const,\n+                kw::Fn,\n+                kw::Unsafe,\n+                kw::Extern,\n+                kw::Type,\n+                kw::Pub,\n+            ])\n+        {\n             self.bump(); // `default`\n             Defaultness::Default\n         } else {\n@@ -6880,7 +6886,7 @@ impl<'a> Parser<'a> {\n         //     Ident [\"<\"...\">\"] [\"where\" ...] (\"=\" | \":\") Ty \";\"\n         if self.check_keyword(kw::Type) ||\n            self.check_keyword(kw::Existential) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Type)) {\n+                self.is_keyword_ahead(1, &[kw::Type]) {\n             let existential = self.eat_keyword(kw::Existential);\n             assert!(self.eat_keyword(kw::Type));\n             Some(self.parse_existential_or_alias(existential))\n@@ -7157,7 +7163,7 @@ impl<'a> Parser<'a> {\n             let const_span = self.prev_span;\n             if self.check_keyword(kw::Fn)\n                 || (self.check_keyword(kw::Unsafe)\n-                    && self.look_ahead(1, |t| t.is_keyword(kw::Fn))) {\n+                    && self.is_keyword_ahead(1, &[kw::Fn])) {\n                 // CONST FUNCTION ITEM\n                 let unsafety = self.parse_unsafety();\n                 self.bump();\n@@ -7202,10 +7208,10 @@ impl<'a> Parser<'a> {\n         // `unsafe async fn` or `async fn`\n         if (\n             self.check_keyword(kw::Unsafe) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Async))\n+            self.is_keyword_ahead(1, &[kw::Async])\n         ) || (\n             self.check_keyword(kw::Async) &&\n-            self.look_ahead(1, |t| t.is_keyword(kw::Fn))\n+            self.is_keyword_ahead(1, &[kw::Fn])\n         )\n         {\n             // ASYNC FUNCTION ITEM\n@@ -7239,8 +7245,7 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item));\n         }\n         if self.check_keyword(kw::Unsafe) &&\n-            (self.look_ahead(1, |t| t.is_keyword(kw::Trait)) ||\n-            self.look_ahead(1, |t| t.is_keyword(kw::Auto)))\n+            self.is_keyword_ahead(1, &[kw::Trait, kw::Auto])\n         {\n             // UNSAFE TRAIT ITEM\n             self.bump(); // `unsafe`\n@@ -7263,11 +7268,9 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Impl) ||\n            self.check_keyword(kw::Unsafe) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n-           self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Impl)) ||\n+                self.is_keyword_ahead(1, &[kw::Impl]) ||\n            self.check_keyword(kw::Default) &&\n-                self.look_ahead(1, |t| t.is_keyword(kw::Unsafe)) {\n+                self.is_keyword_ahead(1, &[kw::Impl, kw::Unsafe]) {\n             // IMPL ITEM\n             let defaultness = self.parse_defaultness();\n             let unsafety = self.parse_unsafety();\n@@ -7360,7 +7363,7 @@ impl<'a> Parser<'a> {\n         }\n         if self.check_keyword(kw::Trait)\n             || (self.check_keyword(kw::Auto)\n-                && self.look_ahead(1, |t| t.is_keyword(kw::Trait)))\n+                && self.is_keyword_ahead(1, &[kw::Trait]))\n         {\n             let is_auto = if self.eat_keyword(kw::Trait) {\n                 IsAuto::No"}]}