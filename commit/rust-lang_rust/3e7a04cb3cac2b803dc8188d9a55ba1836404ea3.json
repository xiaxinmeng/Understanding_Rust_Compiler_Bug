{"sha": "3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlN2EwNGNiM2NhYzJiODAzZGM4MTg4ZDlhNTViYTE4MzY0MDRlYTM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:48:45Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T23:48:45Z"}, "message": "Round 2 test fixes and conflicts", "tree": {"sha": "e1dfe6c31004598375c57a042d81ab69eca1f068", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1dfe6c31004598375c57a042d81ab69eca1f068"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "html_url": "https://github.com/rust-lang/rust/commit/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8", "html_url": "https://github.com/rust-lang/rust/commit/231eeaa35b3a7700cfd05dcb30f01cd7a36313b8"}], "stats": {"total": 158, "additions": 131, "deletions": 27}, "files": [{"sha": "1bd8aa0a17ecc6ee43140b81d096350fca7523d7", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 115, "deletions": 11, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "patch": "@@ -231,7 +231,6 @@ pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> u64 {\n mod impls {\n     use prelude::*;\n \n-    use borrow::{Cow, ToOwned};\n     use mem;\n     use num::Int;\n     use super::*;\n@@ -364,22 +363,12 @@ mod impls {\n             (*self as uint).hash(state);\n         }\n     }\n-\n-    impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n-        where B: Hash<S> + ToOwned<T>\n-    {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            Hash::hash(&**self, state)\n-        }\n-    }\n }\n \n #[cfg(not(stage0))]\n mod impls {\n     use prelude::*;\n \n-    use borrow::{Cow, ToOwned};\n     use slice;\n     use super::*;\n \n@@ -399,4 +388,119 @@ mod impls {\n             }\n         )*}\n     }\n+\n+    impl_write! {\n+        (u8, write_u8),\n+        (u16, write_u16),\n+        (u32, write_u32),\n+        (u64, write_u64),\n+        (usize, write_usize),\n+        (i8, write_i8),\n+        (i16, write_i16),\n+        (i32, write_i32),\n+        (i64, write_i64),\n+        (isize, write_isize),\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for bool {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u8(*self as u8)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for char {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_u32(*self as u32)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl Hash for str {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write(self.as_bytes());\n+            state.write_u8(0xff)\n+        }\n+    }\n+\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl Hash for () {\n+                fn hash<H: Hasher>(&self, _state: &mut H) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            impl<$($name: Hash),*> Hash for ($($name,)*) {\n+                #[allow(non_snake_case)]\n+                fn hash<S: Hasher>(&self, state: &mut S) {\n+                    let ($(ref $name,)*) = *self;\n+                    $($name.hash(state);)*\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T: Hash> Hash for [T] {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            self.len().hash(state);\n+            Hash::hash_slice(self, state)\n+        }\n+    }\n+\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T: ?Sized + Hash> Hash for &'a mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *const T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<T> Hash for *mut T {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            state.write_usize(*self as usize)\n+        }\n+    }\n+\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    impl<'a, T, B: ?Sized> Hash for Cow<'a, T, B>\n+        where B: Hash + ToOwned<T>\n+    {\n+        fn hash<H: Hasher>(&self, state: &mut H) {\n+            Hash::hash(&**self, state)\n+        }\n+    }\n }"}, {"sha": "f9e5044c597616a129a687e25e0f3a35d8e7f786", "filename": "src/libstd/collections/hash/map_stage0.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap_stage0.rs?ref=3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "patch": "@@ -14,7 +14,7 @@ use self::Entry::*;\n use self::SearchResult::*;\n use self::VacantEntryState::*;\n \n-use borrow::BorrowFrom;\n+use borrow::Borrow;\n use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n@@ -453,18 +453,18 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where K: Borrow<Q>, Q: Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<H>\n+        where K: Borrow<Q>, Q: Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n-        search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n+        search_hashed(&mut self.table, hash, |k| q.eq(k.borrow()))\n             .into_option()\n     }\n \n@@ -1037,7 +1037,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1060,7 +1060,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         self.search(k).is_some()\n     }\n@@ -1086,7 +1086,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1138,7 +1138,7 @@ impl<K, V, S, H> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash<H> + Eq + BorrowFrom<K>\n+        where K: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1247,8 +1247,8 @@ impl<K, V, S, H> Default for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n+    where K: Eq + Hash<H> + Borrow<Q>,\n+          Q: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {\n@@ -1262,8 +1262,8 @@ impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n-    where K: Eq + Hash<H>,\n-          Q: Eq + Hash<H> + BorrowFrom<K>,\n+    where K: Eq + Hash<H> + Borrow<Q>,\n+          Q: Eq + Hash<H>,\n           S: HashState<Hasher=H>,\n           H: hash::Hasher<Output=u64>\n {"}, {"sha": "68c9e02d8ad7205483c7e577506fab2c4f3299a6", "filename": "src/libstd/collections/hash/set_stage0.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e7a04cb3cac2b803dc8188d9a55ba1836404ea3/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset_stage0.rs?ref=3e7a04cb3cac2b803dc8188d9a55ba1836404ea3", "patch": "@@ -10,7 +10,7 @@\n //\n // ignore-lexer-test FIXME #15883\n \n-use borrow::BorrowFrom;\n+use borrow::Borrow;\n use clone::Clone;\n use cmp::{Eq, PartialEq};\n use core::marker::Sized;\n@@ -462,7 +462,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<H> + Eq\n+        where T: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -572,7 +572,7 @@ impl<T, S, H> HashSet<T, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<H> + Eq\n+        where T: Borrow<Q>, Q: Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }"}]}