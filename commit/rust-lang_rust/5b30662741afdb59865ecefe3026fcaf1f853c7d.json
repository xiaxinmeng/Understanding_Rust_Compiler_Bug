{"sha": "5b30662741afdb59865ecefe3026fcaf1f853c7d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViMzA2NjI3NDFhZmRiNTk4NjVlY2VmZTMwMjZmY2FmMWY4NTNjN2Q=", "commit": {"author": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-11T05:05:39Z"}, "committer": {"name": "Christiaan Dirkx", "email": "christiaan@dirkx.email", "date": "2021-04-22T08:34:48Z"}, "message": "Rework `at_exit` to `cleanup`", "tree": {"sha": "02989ef53129cd47e844479dc397dc61ea78e6de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02989ef53129cd47e844479dc397dc61ea78e6de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b30662741afdb59865ecefe3026fcaf1f853c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b30662741afdb59865ecefe3026fcaf1f853c7d", "html_url": "https://github.com/rust-lang/rust/commit/5b30662741afdb59865ecefe3026fcaf1f853c7d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b30662741afdb59865ecefe3026fcaf1f853c7d/comments", "author": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CDirkx", "id": 11176562, "node_id": "MDQ6VXNlcjExMTc2NTYy", "avatar_url": "https://avatars.githubusercontent.com/u/11176562?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CDirkx", "html_url": "https://github.com/CDirkx", "followers_url": "https://api.github.com/users/CDirkx/followers", "following_url": "https://api.github.com/users/CDirkx/following{/other_user}", "gists_url": "https://api.github.com/users/CDirkx/gists{/gist_id}", "starred_url": "https://api.github.com/users/CDirkx/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CDirkx/subscriptions", "organizations_url": "https://api.github.com/users/CDirkx/orgs", "repos_url": "https://api.github.com/users/CDirkx/repos", "events_url": "https://api.github.com/users/CDirkx/events{/privacy}", "received_events_url": "https://api.github.com/users/CDirkx/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71965ab4d05b023cd29c914ef1262a72cac02e01", "url": "https://api.github.com/repos/rust-lang/rust/commits/71965ab4d05b023cd29c914ef1262a72cac02e01", "html_url": "https://github.com/rust-lang/rust/commit/71965ab4d05b023cd29c914ef1262a72cac02e01"}], "stats": {"total": 330, "additions": 134, "deletions": 196}, "files": [{"sha": "94c70c4f267b16a82892d0221428040c52c8a729", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -293,6 +293,10 @@ mod util;\n \n const DEFAULT_BUF_SIZE: usize = crate::sys_common::io::DEFAULT_BUF_SIZE;\n \n+pub(crate) fn cleanup() {\n+    stdio::cleanup()\n+}\n+\n struct Guard<'a> {\n     buf: &'a mut Vec<u8>,\n     len: usize,"}, {"sha": "2b0d2b7e0be23e87e3a674591c78d535c699589e", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 18, "deletions": 23, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -13,7 +13,6 @@ use crate::pin::Pin;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sync::{Arc, Mutex, MutexGuard};\n use crate::sys::stdio;\n-use crate::sys_common;\n use crate::sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n \n type LocalStream = Arc<Mutex<Vec<u8>>>;\n@@ -508,6 +507,8 @@ pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<StdoutRaw>>>,\n }\n \n+static STDOUT: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> = SyncOnceCell::new();\n+\n /// Constructs a new handle to the standard output of the current process.\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n@@ -549,34 +550,28 @@ pub struct StdoutLock<'a> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn stdout() -> Stdout {\n-    static INSTANCE: SyncOnceCell<ReentrantMutex<RefCell<LineWriter<StdoutRaw>>>> =\n-        SyncOnceCell::new();\n-\n-    fn cleanup() {\n-        if let Some(instance) = INSTANCE.get() {\n-            // Flush the data and disable buffering during shutdown\n-            // by replacing the line writer by one with zero\n-            // buffering capacity.\n-            // We use try_lock() instead of lock(), because someone\n-            // might have leaked a StdoutLock, which would\n-            // otherwise cause a deadlock here.\n-            if let Some(lock) = Pin::static_ref(instance).try_lock() {\n-                *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n-            }\n-        }\n-    }\n-\n     Stdout {\n-        inner: Pin::static_ref(&INSTANCE).get_or_init_pin(\n-            || unsafe {\n-                let _ = sys_common::at_exit(cleanup);\n-                ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw())))\n-            },\n+        inner: Pin::static_ref(&STDOUT).get_or_init_pin(\n+            || unsafe { ReentrantMutex::new(RefCell::new(LineWriter::new(stdout_raw()))) },\n             |mutex| unsafe { mutex.init() },\n         ),\n     }\n }\n \n+pub fn cleanup() {\n+    if let Some(instance) = STDOUT.get() {\n+        // Flush the data and disable buffering during shutdown\n+        // by replacing the line writer by one with zero\n+        // buffering capacity.\n+        // We use try_lock() instead of lock(), because someone\n+        // might have leaked a StdoutLock, which would\n+        // otherwise cause a deadlock here.\n+        if let Some(lock) = Pin::static_ref(instance).try_lock() {\n+            *lock.borrow_mut() = LineWriter::with_capacity(0, stdout_raw());\n+        }\n+    }\n+}\n+\n impl Stdout {\n     /// Locks this handle to the standard output stream, returning a writable\n     /// guard."}, {"sha": "b45c620fd0b068e25fbb2d27fb046a8f13a3bd30", "filename": "library/std/src/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -1749,7 +1749,7 @@ impl Child {\n /// [platform-specific behavior]: #platform-specific-behavior\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn exit(code: i32) -> ! {\n-    crate::sys_common::cleanup();\n+    crate::sys_common::rt::cleanup();\n     crate::sys::os::exit(code)\n }\n "}, {"sha": "ce6e318c9dec24e4d7d7d65327e87e65183cc237", "filename": "library/std/src/rt.rs", "status": "modified", "additions": 4, "deletions": 24, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Frt.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -26,33 +26,13 @@ fn lang_start_internal(\n     argv: *const *const u8,\n ) -> isize {\n     use crate::panic;\n-    use crate::sys;\n     use crate::sys_common;\n-    use crate::sys_common::thread_info;\n-    use crate::thread::Thread;\n \n-    sys::init();\n+    sys_common::rt::init(argc, argv);\n+    let exit_code = panic::catch_unwind(main);\n+    sys_common::rt::cleanup();\n \n-    unsafe {\n-        let main_guard = sys::thread::guard::init();\n-        sys::stack_overflow::init();\n-\n-        // Next, set up the current Thread with the guard information we just\n-        // created. Note that this isn't necessary in general for new threads,\n-        // but we just do this to name the main thread and to give it correct\n-        // info about the stack bounds.\n-        let thread = Thread::new(Some(\"main\".to_owned()));\n-        thread_info::set(main_guard, thread);\n-\n-        // Store our args if necessary in a squirreled away location\n-        sys::args::init(argc, argv);\n-\n-        // Let's run some code!\n-        let exit_code = panic::catch_unwind(main);\n-\n-        sys_common::cleanup();\n-        exit_code.unwrap_or(101) as isize\n-    }\n+    exit_code.unwrap_or(101) as isize\n }\n \n #[cfg(not(test))]"}, {"sha": "ebfc39bdef3463e443b1df303409fb14a580feab", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -96,11 +96,14 @@ pub extern \"C\" fn __rust_abort() {\n     abort_internal();\n }\n \n-#[cfg(not(test))]\n-pub fn init() {\n+// SAFETY: must be called only once during runtime initialization.\n+pub unsafe fn init() {\n     let _ = net::init();\n }\n \n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {}\n+\n #[cfg(not(test))]\n #[no_mangle]\n pub unsafe extern \"C\" fn runtime_entry("}, {"sha": "9681336631fb879c91cc1744918e4e56bb71e397", "filename": "library/std/src/sys/sgx/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -40,8 +40,11 @@ pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+pub unsafe fn init() {}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {}\n \n /// This function is used to implement functionality that simply doesn't exist.\n /// Programs relying on this functionality will need to deal with the error."}, {"sha": "3b86d37379695480f6db185df5a1009d5d1fb210", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -44,14 +44,12 @@ pub mod time;\n \n pub use crate::sys_common::os_str_bytes as os_str;\n \n-#[cfg(not(test))]\n-pub fn init() {\n+// SAFETY: must be called only once during runtime initialization.\n+pub unsafe fn init() {\n     // The standard streams might be closed on application startup. To prevent\n     // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n     // resources opened later, we reopen standards streams when they are closed.\n-    unsafe {\n-        sanitize_standard_fds();\n-    }\n+    sanitize_standard_fds();\n \n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n@@ -60,9 +58,7 @@ pub fn init() {\n     //\n     // Hence, we set SIGPIPE to ignore when the program starts up in order\n     // to prevent this problem.\n-    unsafe {\n-        reset_sigpipe();\n-    }\n+    reset_sigpipe();\n \n     cfg_if::cfg_if! {\n         if #[cfg(miri)] {\n@@ -129,6 +125,9 @@ pub fn init() {\n     unsafe fn reset_sigpipe() {}\n }\n \n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {}\n+\n #[cfg(target_os = \"android\")]\n pub use crate::sys::android::signal;\n #[cfg(not(target_os = \"android\"))]"}, {"sha": "5ab22bd3ff466fe35d5c24140b897ca35aaf7d6c", "filename": "library/std/src/sys/unsupported/common.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcommon.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -10,8 +10,11 @@ pub use crate::sys_common::os_str_bytes as os_str;\n // spec definition?\n use crate::os::raw::c_char;\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+pub unsafe fn init() {}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {}\n \n pub fn unsupported<T>() -> std_io::Result<T> {\n     Err(unsupported_err())"}, {"sha": "4563bca93b3ee9b266d7bcc0a963d948c5d50209", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -49,8 +49,13 @@ cfg_if::cfg_if! {\n     }\n }\n \n-#[cfg(not(test))]\n-pub fn init() {}\n+// SAFETY: must be called only once during runtime initialization.\n+pub unsafe fn init() {}\n+\n+// SAFETY: must be called only once during runtime cleanup.\n+pub unsafe fn cleanup() {\n+    net::cleanup();\n+}\n \n pub fn decode_error_kind(errno: i32) -> ErrorKind {\n     match errno as c::DWORD {"}, {"sha": "f577169e0e0ec725f4b4146e3e5617ffc3003536", "filename": "library/std/src/sys/windows/net.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fnet.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -9,7 +9,7 @@ use crate::sync::Once;\n use crate::sys;\n use crate::sys::c;\n use crate::sys_common::net;\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n use crate::time::Duration;\n \n use libc::{c_int, c_long, c_ulong, c_void};\n@@ -38,13 +38,15 @@ pub fn init() {\n             &mut data,\n         );\n         assert_eq!(ret, 0);\n-\n-        let _ = sys_common::at_exit(|| {\n-            c::WSACleanup();\n-        });\n     });\n }\n \n+pub fn cleanup() {\n+    unsafe {\n+        c::WSACleanup();\n+    }\n+}\n+\n /// Returns the last error from the Windows socket interface.\n fn last_error() -> io::Error {\n     io::Error::from_raw_os_error(unsafe { c::WSAGetLastError() })"}, {"sha": "90d5d3a78987fe6b289745fbc3490ab77af36a00", "filename": "library/std/src/sys_common/at_exit_imp.rs", "status": "removed", "additions": 0, "deletions": 74, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/71965ab4d05b023cd29c914ef1262a72cac02e01/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71965ab4d05b023cd29c914ef1262a72cac02e01/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fat_exit_imp.rs?ref=71965ab4d05b023cd29c914ef1262a72cac02e01", "patch": "@@ -1,74 +0,0 @@\n-//! Implementation of running at_exit routines\n-//!\n-//! Documentation can be found on the `rt::at_exit` function.\n-\n-use crate::mem;\n-use crate::ptr;\n-use crate::sys_common::mutex::StaticMutex;\n-\n-type Queue = Vec<Box<dyn FnOnce()>>;\n-\n-// NB these are specifically not types from `std::sync` as they currently rely\n-// on poisoning and this module needs to operate at a lower level than requiring\n-// the thread infrastructure to be in place (useful on the borders of\n-// initialization/destruction).\n-// It is UB to attempt to acquire this mutex reentrantly!\n-static LOCK: StaticMutex = StaticMutex::new();\n-static mut QUEUE: *mut Queue = ptr::null_mut();\n-\n-const DONE: *mut Queue = 1_usize as *mut _;\n-\n-// The maximum number of times the cleanup routines will be run. While running\n-// the at_exit closures new ones may be registered, and this count is the number\n-// of times the new closures will be allowed to register successfully. After\n-// this number of iterations all new registrations will return `false`.\n-const ITERS: usize = 10;\n-\n-unsafe fn init() -> bool {\n-    if QUEUE.is_null() {\n-        let state: Box<Queue> = box Vec::new();\n-        QUEUE = Box::into_raw(state);\n-    } else if QUEUE == DONE {\n-        // can't re-init after a cleanup\n-        return false;\n-    }\n-\n-    true\n-}\n-\n-pub fn cleanup() {\n-    for i in 1..=ITERS {\n-        unsafe {\n-            let queue = {\n-                let _guard = LOCK.lock();\n-                mem::replace(&mut QUEUE, if i == ITERS { DONE } else { ptr::null_mut() })\n-            };\n-\n-            // make sure we're not recursively cleaning up\n-            assert!(queue != DONE);\n-\n-            // If we never called init, not need to cleanup!\n-            if !queue.is_null() {\n-                let queue: Box<Queue> = Box::from_raw(queue);\n-                for to_run in *queue {\n-                    // We are not holding any lock, so reentrancy is fine.\n-                    to_run();\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-pub fn push(f: Box<dyn FnOnce()>) -> bool {\n-    unsafe {\n-        let _guard = LOCK.lock();\n-        if init() {\n-            // We are just moving `f` around, not calling it.\n-            // There is no possibility of reentrancy here.\n-            (*QUEUE).push(f);\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}"}, {"sha": "449ce509d2587013c9e43ed0c349431bae73b494", "filename": "library/std/src/sys_common/mod.rs", "status": "modified", "additions": 2, "deletions": 53, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmod.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -20,35 +20,6 @@\n #[cfg(test)]\n mod tests;\n \n-use crate::sync::Once;\n-use crate::sys;\n-\n-macro_rules! rtabort {\n-    ($($t:tt)*) => (crate::sys_common::util::abort(format_args!($($t)*)))\n-}\n-\n-macro_rules! rtassert {\n-    ($e:expr) => {\n-        if !$e {\n-            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n-        }\n-    };\n-}\n-\n-#[allow(unused_macros)] // not used on all platforms\n-macro_rules! rtunwrap {\n-    ($ok:ident, $e:expr) => {\n-        match $e {\n-            $ok(v) => v,\n-            ref err => {\n-                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n-                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n-            }\n-        }\n-    };\n-}\n-\n-pub mod at_exit_imp;\n pub mod backtrace;\n pub mod bytestring;\n pub mod condvar;\n@@ -62,6 +33,8 @@ pub mod os_str_bytes;\n pub mod poison;\n pub mod process;\n pub mod remutex;\n+#[macro_use]\n+pub mod rt;\n pub mod rwlock;\n pub mod thread;\n pub mod thread_info;\n@@ -109,30 +82,6 @@ pub trait FromInner<Inner> {\n     fn from_inner(inner: Inner) -> Self;\n }\n \n-/// Enqueues a procedure to run when the main thread exits.\n-///\n-/// Currently these closures are only run once the main *Rust* thread exits.\n-/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n-/// infinitely so. Eventually a handler registration will be forced to fail.\n-///\n-/// Returns `Ok` if the handler was successfully registered, meaning that the\n-/// closure will be run once the main thread exits. Returns `Err` to indicate\n-/// that the closure could not be registered, meaning that it is not scheduled\n-/// to be run.\n-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n-    if at_exit_imp::push(Box::new(f)) { Ok(()) } else { Err(()) }\n-}\n-\n-/// One-time runtime cleanup.\n-pub fn cleanup() {\n-    static CLEANUP: Once = Once::new();\n-    CLEANUP.call_once(|| unsafe {\n-        sys::args::cleanup();\n-        sys::stack_overflow::cleanup();\n-        at_exit_imp::cleanup();\n-    });\n-}\n-\n // Computes (value*numer)/denom without overflow, as long as both\n // (numer*denom) and the overall result fit into i64 (which is the case\n // for our time conversions)."}, {"sha": "2635aea68c943cd0e659ea9fb6158f7c0fa1ab72", "filename": "library/std/src/sys_common/rt.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b30662741afdb59865ecefe3026fcaf1f853c7d/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frt.rs?ref=5b30662741afdb59865ecefe3026fcaf1f853c7d", "patch": "@@ -0,0 +1,69 @@\n+use crate::sync::Once;\n+use crate::sys;\n+use crate::sys_common::thread_info;\n+use crate::thread::Thread;\n+\n+// One-time runtime initialization.\n+// Runs before `main`.\n+#[cfg_attr(test, allow(dead_code))]\n+pub fn init(argc: isize, argv: *const *const u8) {\n+    static INIT: Once = Once::new();\n+    INIT.call_once(|| unsafe {\n+        // SAFETY: Only called once during runtime initialization.\n+        sys::init();\n+\n+        let main_guard = sys::thread::guard::init();\n+        sys::stack_overflow::init();\n+\n+        // Next, set up the current Thread with the guard information we just\n+        // created. Note that this isn't necessary in general for new threads,\n+        // but we just do this to name the main thread and to give it correct\n+        // info about the stack bounds.\n+        let thread = Thread::new(Some(\"main\".to_owned()));\n+        thread_info::set(main_guard, thread);\n+\n+        // Store our args if necessary in a squirreled away location\n+        sys::args::init(argc, argv);\n+    });\n+}\n+\n+// One-time runtime cleanup.\n+// Runs after `main` or at program exit. Note however that this is not guaranteed to run,\n+// for example when the program aborts.\n+#[cfg_attr(test, allow(dead_code))]\n+pub fn cleanup() {\n+    static CLEANUP: Once = Once::new();\n+    CLEANUP.call_once(|| unsafe {\n+        // SAFETY: Only called once during runtime cleanup.\n+        sys::cleanup();\n+        sys::args::cleanup();\n+        sys::stack_overflow::cleanup();\n+        // Flush stdout and disable buffering.\n+        crate::io::cleanup();\n+    });\n+}\n+\n+macro_rules! rtabort {\n+    ($($t:tt)*) => (crate::sys_common::util::abort(format_args!($($t)*)))\n+}\n+\n+macro_rules! rtassert {\n+    ($e:expr) => {\n+        if !$e {\n+            rtabort!(concat!(\"assertion failed: \", stringify!($e)));\n+        }\n+    };\n+}\n+\n+#[allow(unused_macros)] // not used on all platforms\n+macro_rules! rtunwrap {\n+    ($ok:ident, $e:expr) => {\n+        match $e {\n+            $ok(v) => v,\n+            ref err => {\n+                let err = err.as_ref().map(drop); // map Ok/Some which might not be Debug\n+                rtabort!(concat!(\"unwrap failed: \", stringify!($e), \" = {:?}\"), err)\n+            }\n+        }\n+    };\n+}"}]}