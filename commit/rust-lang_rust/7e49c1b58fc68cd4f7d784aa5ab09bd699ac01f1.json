{"sha": "7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "node_id": "C_kwDOAAsO6NoAKDdlNDljMWI1OGZjNjhjZDRmN2Q3ODRhYTVhYjA5YmQ2OTlhYzAxZjE", "commit": {"author": {"name": "ridwanabdillahi", "email": "91507758+ridwanabdillahi@users.noreply.github.com", "date": "2022-08-12T20:24:17Z"}, "committer": {"name": "ridwanabdillahi", "email": "91507758+ridwanabdillahi@users.noreply.github.com", "date": "2022-08-12T20:24:17Z"}, "message": "Respond to PR comments. Cleanup documentation.", "tree": {"sha": "50cb838fe1473d1c750f5e8edddbe69c87dbc43a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50cb838fe1473d1c750f5e8edddbe69c87dbc43a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "html_url": "https://github.com/rust-lang/rust/commit/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1/comments", "author": {"login": "ridwanabdillahi", "id": 91507758, "node_id": "U_kgDOBXRMLg", "avatar_url": "https://avatars.githubusercontent.com/u/91507758?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ridwanabdillahi", "html_url": "https://github.com/ridwanabdillahi", "followers_url": "https://api.github.com/users/ridwanabdillahi/followers", "following_url": "https://api.github.com/users/ridwanabdillahi/following{/other_user}", "gists_url": "https://api.github.com/users/ridwanabdillahi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ridwanabdillahi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ridwanabdillahi/subscriptions", "organizations_url": "https://api.github.com/users/ridwanabdillahi/orgs", "repos_url": "https://api.github.com/users/ridwanabdillahi/repos", "events_url": "https://api.github.com/users/ridwanabdillahi/events{/privacy}", "received_events_url": "https://api.github.com/users/ridwanabdillahi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ridwanabdillahi", "id": 91507758, "node_id": "U_kgDOBXRMLg", "avatar_url": "https://avatars.githubusercontent.com/u/91507758?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ridwanabdillahi", "html_url": "https://github.com/ridwanabdillahi", "followers_url": "https://api.github.com/users/ridwanabdillahi/followers", "following_url": "https://api.github.com/users/ridwanabdillahi/following{/other_user}", "gists_url": "https://api.github.com/users/ridwanabdillahi/gists{/gist_id}", "starred_url": "https://api.github.com/users/ridwanabdillahi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ridwanabdillahi/subscriptions", "organizations_url": "https://api.github.com/users/ridwanabdillahi/orgs", "repos_url": "https://api.github.com/users/ridwanabdillahi/repos", "events_url": "https://api.github.com/users/ridwanabdillahi/events{/privacy}", "received_events_url": "https://api.github.com/users/ridwanabdillahi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "804579ca7716bbe8125481bffde555e5680b8824", "url": "https://api.github.com/repos/rust-lang/rust/commits/804579ca7716bbe8125481bffde555e5680b8824", "html_url": "https://github.com/rust-lang/rust/commit/804579ca7716bbe8125481bffde555e5680b8824"}], "stats": {"total": 30, "additions": 17, "deletions": 13}, "files": [{"sha": "38fd5c96997631d1ce77b3348e88b7754a8ca63b", "filename": "src/doc/rustc/src/instrument-coverage.md", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Finstrument-coverage.md?ref=7e49c1b58fc68cd4f7d784aa5ab09bd699ac01f1", "patch": "@@ -97,23 +97,16 @@ $ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n }\n ```\n \n-After running this program, a new file, `default_%m_%p.profraw`, should be in the current working directory. This file takes advantage ofLLVM's support for rewriting special pattern strings to ensure `.profraw` files generated are unique. The following special pattern strings are rewritten as:\n-\n--   `%p` - The process ID.\n--   `%h` - The hostname of the machine running the program.\n--   `%t` - The value of the TMPDIR environment variable.\n--   `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n--   `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n+After running this program, a new file named like `default_11699812450447639123_0_20944` should be in the current working directory.\n+A new, unique file name will be generated each time the program is run to avoid overwriting previous data.\n \n ```shell\n $ echo \"{some: 'thing'}\" | target/debug/examples/formatjson5 -\n ...\n-$ ls default_11699812450447639123_0_20944.profraw\n+$ ls default_*.profraw\n default_11699812450447639123_0_20944.profraw\n ```\n \n-In the example above, the value `11699812450447639123_0` in the generated filename is the instrumented binary's signature, which replaced the `%m` pattern and the value `20944` is the process ID of the binary being executed.\n-\n You can also set a specific file name or path for the generated `.profraw` files by using the environment variable `LLVM_PROFILE_FILE`:\n \n ```shell\n@@ -124,6 +117,17 @@ $ ls formatjson5.profraw\n formatjson5.profraw\n ```\n \n+If `LLVM_PROFILE_FILE` contains a path to a non-existent directory, the missing directory structure will be created. Additionally, the following special pattern strings are rewritten:\n+\n+-   `%p` - The process ID.\n+-   `%h` - The hostname of the machine running the program.\n+-   `%t` - The value of the TMPDIR environment variable.\n+-   `%Nm` - the instrumented binary\u2019s signature: The runtime creates a pool of N raw profiles, used for on-line profile merging. The runtime takes care of selecting a raw profile from the pool, locking it, and updating it before the program exits. `N` must be between `1` and `9`, and defaults to `1` if omitted (with simply `%m`).\n+-   `%c` - Does not add anything to the filename, but enables a mode (on some platforms, including Darwin) in which profile counter updates are continuously synced to a file. This means that if the instrumented program crashes, or is killed by a signal, perfect coverage information can still be recovered.\n+\n+In the first example above, the value `11699812450447639123_0` in the generated filename is the instrumented binary's signature,\n+which replaced the `%m` pattern and the value `20944` is the process ID of the binary being executed.\n+\n ## Installing LLVM coverage tools\n \n LLVM's supplies two tools\u2014`llvm-profdata` and `llvm-cov`\u2014that process coverage data and generate reports. There are several ways to find and/or install these tools, but note that the coverage mapping data generated by the Rust compiler requires LLVM version 12 or higher, and processing the *raw* data may require exactly the LLVM version used by the compiler. (`llvm-cov --version` typically shows the tool's LLVM version number, and `rustc --verbose --version` shows the version of LLVM used by the Rust compiler.)\n@@ -190,9 +194,7 @@ A typical use case for coverage analysis is test coverage. Rust's source-based c\n \n The following example (using the [`json5format`] crate, for demonstration purposes) show how to generate and analyze coverage results for all tests in a crate.\n \n-Since `cargo test` both builds and runs the tests, we set the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag. If setting `LLVM_PROFILE_FILE` to specify a custom filename for the raw profiling data generated during the test runs,\n-apply `%m` in the filename pattern since there may be more than one test binary. This generates unique names for each test binary which is not done by default when setting the `LLVM_PROFILE_FILE` environment variable.\n-(Otherwise, each executed test binary would overwrite the coverage results from the previous binary.) If not setting `LLVM_PROFILE_FILE`, the `%m` and `%p` filename patterns are added by default.\n+Since `cargo test` both builds and runs the tests, we set the additional `RUSTFLAGS`, to add the `-C instrument-coverage` flag.\n \n ```shell\n $ RUSTFLAGS=\"-C instrument-coverage\" \\\n@@ -240,6 +242,8 @@ $ llvm-cov show \\\n     --Xdemangler=rustfilt | less -R\n ```\n \n+> **Note**: If overriding the default `profraw` file name via the `LLVM_PROFILE_FILE` environment variable, it's highly recommended to use the `%m` and `%p` special pattern strings to generate unique file names in the case of more than a single test binary being executed.\n+\n > **Note**: The command line option `--ignore-filename-regex=/.cargo/registry`, which excludes the sources for dependencies from the coverage results.\\_\n \n ### Tips for listing the binaries automatically"}]}