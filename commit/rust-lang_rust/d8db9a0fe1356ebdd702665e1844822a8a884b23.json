{"sha": "d8db9a0fe1356ebdd702665e1844822a8a884b23", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZGI5YTBmZTEzNTZlYmRkNzAyNjY1ZTE4NDQ4MjJhOGE4ODRiMjM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-30T16:00:44Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-30T19:37:30Z"}, "message": "Kill unused variables", "tree": {"sha": "777fdd10b2bad6fbba081d4eee4239600eead924", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/777fdd10b2bad6fbba081d4eee4239600eead924"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8db9a0fe1356ebdd702665e1844822a8a884b23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8db9a0fe1356ebdd702665e1844822a8a884b23", "html_url": "https://github.com/rust-lang/rust/commit/d8db9a0fe1356ebdd702665e1844822a8a884b23", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8db9a0fe1356ebdd702665e1844822a8a884b23/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0cdb238920562467f390f0df69392bf70779384", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0cdb238920562467f390f0df69392bf70779384", "html_url": "https://github.com/rust-lang/rust/commit/a0cdb238920562467f390f0df69392bf70779384"}], "stats": {"total": 128, "additions": 37, "deletions": 91}, "files": [{"sha": "0c016afd97504612dde70ca86204e05a289f1d7a", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -137,7 +137,6 @@ mod write {\n         if (is_object_or_assembly_or_exe(opts.output_type)) {\n             let int LLVMAssemblyFile = 0;\n             let int LLVMObjectFile = 1;\n-            let int LLVMNullFile = 2;\n             let int LLVMOptNone = 0;        // -O0\n             let int LLVMOptLess = 1;        // -O1\n             let int LLVMOptDefault = 2;     // -O2, -Os"}, {"sha": "340793b9f237cac6264cee26ebe6517c466871da", "filename": "src/comp/front/fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ffold.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -138,7 +138,6 @@ fn noop_fold_crate(&crate_ c, ast_fold fld) -> crate_ {\n \n fn noop_fold_crate_directive(&crate_directive_ cd, ast_fold fld) \n     -> crate_directive_ {\n-    auto fold_meta_item = bind fold_meta_item_(_,fld);\n     ret alt(cd) {\n         case(cdir_expr(?e)) { cdir_expr(fld.fold_expr(e)) }\n         case(cdir_let(?id, ?e, ?cds)) {"}, {"sha": "c688f79d7cae4bb23523259faa47f34f5d37115a", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -148,7 +148,6 @@ fn consume_block_comment(&reader rdr) {\n \n fn digits_to_string(str s) -> int {\n     let int accum_int = 0;\n-    let int i = 0;\n     for (u8 c in s) {\n         accum_int *= 10;\n         accum_int += dec_digit_val(c as char);"}, {"sha": "a3d20d23b6b3272f9cf0b626ffc5041df41c9207", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -456,7 +456,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n     let ast::ty_ t;\n     // FIXME: do something with this\n \n-    let ast::layer lyr = parse_layer(p);\n+    parse_layer(p);\n     if (eat_word(p, \"bool\")) {\n         t = ast::ty_bool;\n     } else if (eat_word(p, \"int\")) {\n@@ -863,31 +863,26 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n         ex = ast::expr_fail(msg);\n     } else if (eat_word(p, \"log\")) {\n         auto e = parse_expr(p);\n-        auto hi = e.span.hi;\n         ex = ast::expr_log(1, e);\n     } else if (eat_word(p, \"log_err\")) {\n         auto e = parse_expr(p);\n-        auto hi = e.span.hi;\n         ex = ast::expr_log(0, e);\n     } else if (eat_word(p, \"assert\")) {\n         auto e = parse_expr(p);\n-        auto hi = e.span.hi;\n         ex = ast::expr_assert(e);\n     } else if (eat_word(p, \"check\")) {\n         /* Should be a predicate (pure boolean function) applied to \n            arguments that are all either slot variables or literals.\n            but the typechecker enforces that. */\n \n         auto e = parse_expr(p);\n-        auto hi = e.span.hi;\n         ex = ast::expr_check(ast::checked, e);\n     } else if (eat_word(p, \"claim\")) {\n         /* Same rules as check, except that if check-claims\n          is enabled (a command-line flag), then the parser turns\n         claims into check */\n         \n         auto e = parse_expr(p);\n-        auto hi = e.span.hi;\n         ex = ast::expr_check(ast::unchecked, e);\n     } else if (eat_word(p, \"ret\")) {\n         alt (p.peek()) {\n@@ -1253,7 +1248,6 @@ fn parse_if_expr_1(&parser p) -> tup(@ast::expr,\n }\n \n fn parse_if_expr(&parser p) -> @ast::expr {\n-    auto lo = p.get_last_lo_pos();\n     if (eat_word(p, \"check\")) {\n             auto q = parse_if_expr_1(p);\n             ret mk_expr(p, q._3, q._4, ast::expr_if_check(q._0, q._1, q._2));\n@@ -1282,7 +1276,6 @@ fn parse_else_expr(&parser p) -> @ast::expr {\n }\n \n fn parse_head_local(&parser p) -> @ast::local {\n-    auto lo = p.get_lo_pos();\n     if (is_word(p, \"auto\")) {\n         ret parse_auto_local(p);\n     } else { \n@@ -1507,11 +1500,9 @@ fn parse_source_stmt(&parser p) -> @ast::stmt {\n     auto lo = p.get_lo_pos();\n     if (eat_word(p, \"let\")) {\n         auto decl = parse_let(p);\n-        auto hi = p.get_span();\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else if (eat_word(p, \"auto\")) {\n         auto decl = parse_auto(p);\n-        auto hi = p.get_span();\n         ret @spanned(lo, decl.span.hi, ast::stmt_decl(decl, p.get_id()));\n     } else {\n \n@@ -1918,7 +1909,7 @@ fn parse_item_native_fn(&parser p) -> @ast::native_item {\n }\n \n fn parse_native_item(&parser p) -> @ast::native_item {\n-    let ast::layer lyr = parse_layer(p);\n+    parse_layer(p);\n     if (eat_word(p, \"type\")) {\n         ret parse_item_native_type(p);\n     } else if (eat_word(p, \"fn\")) {\n@@ -2010,7 +2001,7 @@ fn parse_item_tag(&parser p, vec[ast::attribute] attrs) -> @ast::item {\n                 }\n                 auto vhi = p.get_hi_pos();\n                 expect(p, token::SEMI);\n-                auto id = p.get_id();\n+                p.get_id();\n                 auto vr =\n                     rec(name=p.get_str(name),\n                         args=args,"}, {"sha": "b82029c21d28c7cfeb7d38ebf351d91f06307671", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -93,7 +93,6 @@ fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n         ret tup(this_cnum, external_def_id._1);\n     }\n     auto tp = ebml::get_doc(item, tag_items_data_item_type);\n-    auto s = str::unsafe_from_bytes(ebml::doc_data(tp));\n     ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n                       bind parse_external_def_id(this_cnum, _), tcx);\n }"}, {"sha": "0e19e3d2895968f54c0ad4cf6ef5d28586e0345d", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -64,7 +64,7 @@ fn parse_ty_data(vec[u8] data, int crate_num, uint pos, uint len, str_def sd,\n \n fn parse_ty_or_bang(@pstate st, str_def sd) -> ty_or_bang {\n     alt (peek(st) as char) {\n-        case ('!') { auto ignore = next(st); ret a_bang[ty::t]; }\n+        case ('!') { next(st); ret a_bang[ty::t]; }\n         case (_) { ret a_ty[ty::t](parse_ty(st, sd)); }\n     }\n }\n@@ -74,7 +74,7 @@ fn parse_constrs(@pstate st, str_def sd) -> vec[@ty::constr_def] {\n     alt (peek(st) as char) {\n         case (':') {\n             do  {\n-                auto ignore = next(st);\n+                next(st);\n                 vec::push(rslt, parse_constr(st, sd));\n             } while (peek(st) as char == ';')\n         }\n@@ -91,10 +91,7 @@ fn parse_path(@pstate st, str_def sd) -> ast::path {\n     idents += [parse_ident_(st, sd, is_last)];\n     while (true) {\n         alt (peek(st) as char) {\n-            case (':') {\n-                auto ignore = next(st);\n-                ignore = next(st);\n-            }\n+            case (':') { next(st); next(st); }\n             case (?c) {\n                 if (c == '(') {\n                     ret respan(rec(lo=0u, hi=0u),"}, {"sha": "68168713130c2f3399f1c4995934de5d50d120b0", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -61,7 +61,7 @@ fn enc_ty(&io::writer w, &@ctxt cx, &ty::t t) {\n                 case (some(?a)) { w.write_str(a.s); ret; }\n                 case (none) {\n                     auto pos = w.get_buf_writer().tell();\n-                    auto ss = enc_sty(w, cx, ty::struct(cx.tcx, t));\n+                    enc_sty(w, cx, ty::struct(cx.tcx, t));\n                     auto end = w.get_buf_writer().tell();\n                     auto len = end - pos;\n                     fn estimate_sz(uint u) -> uint {"}, {"sha": "7475d623f7196f57ab555f554dceea49463d55de", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -392,7 +392,6 @@ fn check_lval(&@ctx cx, &@ast::expr dest, &scope sc, &vt[scope] v) {\n                 cx.tcx.sess.span_fatal(dest.span,\n                                      \"assigning to immutable obj field\");\n             }\n-            auto var_t = ty::expr_ty(*cx.tcx, dest);\n             for (restrict r in sc) {\n                 if (vec::member(dnum, r.root_vars)) {\n                     r.ok = overwritten(dest.span, p);"}, {"sha": "7ee18e68f14fbd618bed66901400a1076f402f0e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 10, "deletions": 30, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -766,7 +766,6 @@ fn type_of_native_fn(&@crate_ctxt cx, &span sp, ast::native_abi abi,\n     let vec[TypeRef] atys = [];\n     if (abi == ast::native_abi_rust) {\n         atys += [T_taskptr(cx.tn)];\n-        auto t = ty::ty_native_fn(abi, inputs, output);\n         auto i = 0u;\n         while (i < ty_param_count) {\n             atys += [T_ptr(T_tydesc(cx.tn))];\n@@ -2684,7 +2683,6 @@ fn iter_structural_ty_full(&@block_ctxt cx, ValueRef av, ValueRef bv,\n                         case (ty::ty_fn(_, ?args, _, _, _)) {\n                             auto j = 0;\n                             for (ty::arg a in args) {\n-                                auto v = [C_int(0), C_int(j as int)];\n                                 auto rslt =\n                                     GEP_tag(variant_cx, llunion_a_ptr, tid,\n                                             variant.id, tps, j);\n@@ -3636,8 +3634,7 @@ mod ivec {\n                 auto p = stack_spill_cx.build.InBoundsGEP(spill_stub, stub_p);\n                 stack_spill_cx.build.Load(p)\n             };\n-        auto heap_len_ptr_spill =\n-            {\n+        {\n                 auto v = [C_int(0), C_uint(abi::ivec_heap_elt_len)];\n                 stack_spill_cx.build.InBoundsGEP(heap_ptr_spill, v)\n             };\n@@ -3673,10 +3670,9 @@ mod ivec {\n \n         auto unit_ty = ty::sequence_element_type(cx.fcx.lcx.ccx.tcx, t);\n         auto llunitty = type_of_or_i8(cx, unit_ty);\n-        auto skip_null;\n         alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n-            case (ty::ty_istr) { skip_null = true; }\n-            case (ty::ty_ivec(_)) { skip_null = false; }\n+            case (ty::ty_istr) {  }\n+            case (ty::ty_ivec(_)) {  }\n             case (_) {\n                 cx.fcx.lcx.ccx.tcx.sess.bug(\"non-istr/ivec in trans_append\");\n             }\n@@ -3692,10 +3688,8 @@ mod ivec {\n         auto no_tydesc_info = none;\n \n         rs = get_tydesc(bcx, t, false, no_tydesc_info);\n-        auto vec_tydesc = rs.val;\n         bcx = rs.bcx;\n         rs = get_tydesc(bcx, unit_ty, false, no_tydesc_info);\n-        auto unit_tydesc = rs.val;\n         bcx = rs.bcx;\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_copy_glue, none);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, none);\n@@ -4516,7 +4510,6 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     auto decl_ty = node_id_type(lcx.ccx, local.node.id);\n     auto decl_id = local.node.id;\n     auto upvars = collect_upvars(cx, body, decl_id);\n-    auto upvar_count = vec::len(upvars);\n \n     auto environment_data = build_environment(cx, upvars);\n     auto llenvptr = environment_data._0;\n@@ -4791,7 +4784,6 @@ fn lval_generic_fn(&@block_ctxt cx, &ty::ty_param_count_and_ty tpt,\n         lv = trans_external_path(cx, fn_id, tpt);\n     }\n     auto tys = ty::node_id_to_type_params(cx.fcx.lcx.ccx.tcx, id);\n-    auto monoty = ty::node_id_to_type(cx.fcx.lcx.ccx.tcx, id);\n     if (vec::len[ty::t](tys) != 0u) {\n         auto bcx = lv.res.bcx;\n         let vec[ValueRef] tydescs = [];\n@@ -5299,7 +5291,7 @@ fn trans_bind_thunk(&@local_ctxt cx, &span sp, &ty::t incoming_fty,\n                    outgoing_args, outgoing_ret_ty, ty_param_count);\n     lltargetfn = bcx.build.PointerCast(lltargetfn, T_ptr(T_ptr(lltargetty)));\n     lltargetfn = bcx.build.Load(lltargetfn);\n-    auto r = bcx.build.FastCall(lltargetfn, llargs);\n+    bcx.build.FastCall(lltargetfn, llargs);\n     bcx.build.RetVoid();\n     finish_fn(fcx, lltop);\n     ret llthunk;\n@@ -6459,7 +6451,6 @@ fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n         case (ty::ty_port(?t)) { unit_ty = t; }\n         case (_) { cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\"); }\n     }\n-    auto llunit_ty = type_of(cx.fcx.lcx.ccx, cx.sp, unit_ty);\n     auto bcx = cx;\n     auto unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n@@ -6587,7 +6578,6 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n    result {\n     auto llmod = cx.fcx.lcx.ccx.llmod;\n-    let TypeRef args_ty_tref = type_of(cx.fcx.lcx.ccx, cx.sp, args_ty);\n     let TypeRef wrapper_fn_type =\n         type_of_fn(cx.fcx.lcx.ccx, cx.sp, ast::proto_fn,\n                    [rec(mode=ty::mo_alias(false), ty=args_ty)], ty::idx_nil,\n@@ -6669,8 +6659,6 @@ fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t, ValueRef target_task)\n     } \n     else if(ty::type_is_structural(tcx, t)) {\n         fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n-            auto tcx = bcx.fcx.lcx.ccx.tcx;\n-    \n             log_err \"Unimplemented type for deep_copy.\";\n             fail;\n         }\n@@ -6841,7 +6829,6 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     // If with_obj (the object being extended) exists, translate it, producing\n     // a result.\n-    let option::t[result] with_obj_val = none;\n     let ty::t with_obj_ty = ty::mk_type(ccx.tcx);\n     let TypeRef llwith_obj_ty;\n     auto vtbl;\n@@ -6857,7 +6844,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n         case (some(?e)) {\n             // Translating with_obj returns a ValueRef (pointer to a 2-word\n             // value) wrapped in a result.\n-            with_obj_val  = some[result](trans_expr(bcx, e));\n+            trans_expr(bcx, e);\n \n             // TODO: What makes more sense to get the type of an expr --\n             // calling ty::expr_ty(ccx.tcx, e) on it or calling\n@@ -6992,7 +6979,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n             // FIXME (part of issue #538): make this work eventually, when we\n             // have additional field exprs in the AST.\n \n-            auto field_val = load_if_immediate(\n+            load_if_immediate(\n                 bcx,\n                 additional_field_vals.(i).val,\n                 additional_field_tys.(i));\n@@ -7992,7 +7979,6 @@ fn trans_const_expr(&@crate_ctxt cx, @ast::expr e) -> ValueRef {\n }\n \n fn trans_const(&@crate_ctxt cx, @ast::expr e, ast::node_id id) {\n-    auto t = node_id_type(cx, id);\n     auto v = trans_const_expr(cx, e);\n     // The scalars come back as 1st class LLVM vals\n     // which we have to stick into global constants.\n@@ -8179,15 +8165,9 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx, &span sp, vec[str] path,\n     auto lltop = bcx.llbb;\n     // Declare the function itself.\n \n-    auto item = alt (ccx.ast_map.get(id)) {\n-        case (ast_map::node_native_item(?i)) { i }\n-    };\n     auto fn_type = node_id_type(ccx, id); // NB: has no type params\n \n     auto abi = ty::ty_fn_abi(ccx.tcx, fn_type);\n-    auto llfnty =\n-        type_of_native_fn(ccx, sp, abi, ty::ty_fn_args(ccx.tcx, fn_type),\n-                          ty::ty_fn_ret(ccx.tcx, fn_type), num_ty_param);\n     // FIXME: If the returned type is not nil, then we assume it's 32 bits\n     // wide. This is obviously wildly unsafe. We should have a better FFI\n     // that allows types of different sizes to be returned.\n@@ -8561,11 +8541,11 @@ fn make_common_glue(&session::session sess, &str output) {\n                                                 llvm::LLVMGetGlobalContext());\n     llvm::LLVMSetDataLayout(llmod, str::buf(x86::get_data_layout()));\n     llvm::LLVMSetTarget(llmod, str::buf(x86::get_target_triple()));\n-    auto td = mk_target_data(x86::get_data_layout());\n+    mk_target_data(x86::get_data_layout());\n     auto tn = mk_type_names();\n-    auto intrinsics = declare_intrinsics(llmod);\n+    declare_intrinsics(llmod);\n     llvm::LLVMSetModuleInlineAsm(llmod, str::buf(x86::get_module_asm()));\n-    auto glues = make_glues(llmod, tn);\n+    make_glues(llmod, tn);\n     link::write::run_passes(sess, llmod, output);\n }\n \n@@ -8686,7 +8666,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     collect_tag_ctors(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n-    auto crate_map = create_crate_map(ccx);\n+    create_crate_map(ccx);\n     emit_tydescs(ccx);\n     // Translate the metadata:\n "}, {"sha": "9aa529c4e416881aff4bc88f0c191cba13beb81a", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -97,7 +97,6 @@ fn log_tritv(&fn_ctxt fcx, &tritv::t v) { log tritv_to_str(fcx, v); }\n fn first_difference_string(&fn_ctxt fcx, &tritv::t expected, &tritv::t actual)\n    -> str {\n     let str s = \"\";\n-    auto done = false;\n     for (norm_constraint c in constraints(fcx)) {\n         if (tritv_get(expected, c.bit_num) == ttrue &&\n             tritv_get(actual, c.bit_num) != ttrue) {"}, {"sha": "679ac234a7e665c9a6ddb672270e23b25b5de9cc", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -124,7 +124,8 @@ fn check_states_stmt(&fn_ctxt fcx, &@stmt s) {\n     }\n }\n \n-fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &vec[ast::ty_param] tps,\n+fn check_states_against_conditions(&fn_ctxt fcx, &_fn f,\n+                                   &vec[ast::ty_param] tps,\n                                    node_id id, &span sp, &fn_ident i) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement"}, {"sha": "2ec43efe0c9b7edb49855b821a33a90b57d3ff42", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -60,7 +60,8 @@ fn collect_pred(&@expr e, &ctxt cx, &visit::vt[ctxt] v) {\n     visit::visit_expr(e, cx, v);\n }\n \n-fn do_nothing(&@item i, &ctxt ignore1, &visit::vt[ctxt] ignore) {\n+fn do_nothing(&_fn f, &vec[ty_param] tp, &span sp, &fn_ident i,\n+              node_id iid, &ctxt cx, &visit::vt[ctxt] v) {\n }\n  \n fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ast::ty_param] tps,\n@@ -72,7 +73,7 @@ fn find_locals(&ty::ctxt tcx, &_fn f, &vec[ast::ty_param] tps,\n     visitor =\n         @rec(visit_local=collect_local,\n              visit_expr=collect_pred,\n-             visit_item=do_nothing\n+             visit_fn=do_nothing\n              with *visitor);\n     visit::visit_fn(f, tps, sp, i, id, cx, visit::vtor(visitor));\n     ret cx;\n@@ -119,9 +120,6 @@ fn mk_fn_info(&crate_ctxt ccx, &_fn f, &vec[ast::ty_param] tp,\n               node_id id) {\n     auto res_map = @new_int_hash[constraint]();\n     let uint next = 0u;\n-    let vec[arg] f_args = f.decl.inputs;\n-    /* ignore args, which we know are initialized;\n-       just collect locally declared vars */\n \n     let ctxt cx = find_locals(ccx.tcx, f, tp, f_sp, f_name, id);\n     /* now we have to add bit nums for both the constraints"}, {"sha": "ff3b6b8cf231fcd5bf7f820148b0392e0c5809a6", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -157,9 +157,6 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, node_id id) {\n         log \"find_pre_post_exprs: oper =\";\n         log_expr(*args.(0));\n     }\n-    auto enclosing = fcx.enclosing;\n-    auto fm = fcx.ccx.fm;\n-    auto nv = num_constraints(enclosing);\n     fn do_one(fn_ctxt fcx, &@expr e) { find_pre_post_expr(fcx, e); }\n     auto f = bind do_one(fcx, _);\n     vec::map[@expr, ()](f, args);\n@@ -194,7 +191,6 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@local l, &@expr index, &block body,\n // and alternative maybe_alt\n fn join_then_else(&fn_ctxt fcx, &@expr antec, &block conseq,\n                   &option::t[@expr] maybe_alt, node_id id, &if_ty chck) {\n-    auto num_local_vars = num_constraints(fcx.enclosing);\n     find_pre_post_expr(fcx, antec);\n     find_pre_post_block(fcx, conseq);\n     alt (maybe_alt) {\n@@ -580,8 +576,6 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) {\n fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s) {\n     log \"stmt =\";\n     log_stmt(s);\n-    auto enclosing = fcx.enclosing;\n-    auto num_local_vars = num_constraints(enclosing);\n     alt (s.node) {\n         case (stmt_decl(?adecl, ?id)) {\n             alt (adecl.node) {"}, {"sha": "dc64f64e6dfdc65b479578a3f120c5bfa44bbecb", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -670,7 +670,6 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n    returns a boolean flag saying whether any pre- or poststates changed */\n fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n     -> bool {\n-    auto num_local_vars = num_constraints(fcx.enclosing);\n     /* First, set the pre-states and post-states for every expression */\n \n     auto pres = pres0;"}, {"sha": "b4d36487db527e2074db54dc7837482785d986c3", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -689,7 +689,6 @@ fn walk_ty(&ctxt cx, ty_walk walker, t ty) {\n             walk_ty(cx, walker, ret_ty);\n         }\n         case (ty_obj(?methods)) {\n-            let vec[method] new_methods = [];\n             for (method m in methods) {\n                 for (arg a in m.inputs) { walk_ty(cx, walker, a.ty); }\n                 walk_ty(cx, walker, m.output);"}, {"sha": "524c4262cf2a082540921637d4ca6e8987a69533", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -133,7 +133,6 @@ fn instantiate_path(&@fn_ctxt fcx, &ast::path pth, &ty_param_count_and_ty tpt,\n         bind_params_in_type(sp, fcx.ccx.tcx, bind next_ty_var_id(fcx), tpt._1,\n                             ty_param_count);\n     auto ty_param_vars = bind_result._0;\n-    auto t = bind_result._1;\n     auto ty_substs_opt;\n     auto ty_substs_len = vec::len[@ast::ty](pth.node.types);\n     if (ty_substs_len > 0u) {\n@@ -260,7 +259,6 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                                        params_opt_and_ty._1);\n         ret typ;\n     }\n-    auto mut = ast::imm;\n     auto typ;\n     auto cname = none[str];\n     alt (ast_ty.node) {\n@@ -691,12 +689,11 @@ mod collect {\n                                       ty_params);\n             }\n             case (ast::item_obj(?object, ?ty_params, ?ctor_id)) {\n-                // This calls ty_of_obj().\n-\n-                auto t_obj = ty_of_item(cx, it);\n                 // Now we need to call ty_of_obj_ctor(); this is the type that\n                 // we write into the table for this item.\n \n+                ty_of_item(cx, it);\n+\n                 auto tpt =\n                     ty_of_obj_ctor(cx, it.ident, object, ctor_id, ty_params);\n                 write::ty_only(cx.tcx, ctor_id, tpt._1);\n@@ -924,7 +921,6 @@ fn are_compatible(&@fn_ctxt fcx, &ty::t expected, &ty::t actual) -> bool {\n // Returns the types of the arguments to a tag variant.\n fn variant_arg_types(&@crate_ctxt ccx, &span sp, &ast::def_id vid,\n                      &vec[ty::t] tag_ty_params) -> vec[ty::t] {\n-    auto ty_param_count = vec::len[ty::t](tag_ty_params);\n     let vec[ty::t] result = [];\n     auto tpt = ty::lookup_item_type(ccx.tcx, vid);\n     alt (ty::struct(ccx.tcx, tpt._1)) {\n@@ -1025,12 +1021,14 @@ mod writeback {\n         fn visit_item_post(@mutable bool ignore, &@ast::item item) {\n             *ignore = false;\n         }\n-        fn visit_fn_pre(@mutable bool ignore, &ast::_fn f, &vec[ast::ty_param] tps,\n-                        &span sp, &ast::fn_ident i, ast::node_id d) {\n+        fn visit_fn_pre(@mutable bool ignore, &ast::_fn f,\n+                        &vec[ast::ty_param] tps, &span sp,\n+                        &ast::fn_ident i, ast::node_id d) {\n             *ignore = true;\n         }\n-        fn visit_fn_post(@mutable bool ignore, &ast::_fn f, &vec[ast::ty_param] tps, \n-                         &span sp, &ast::fn_ident i, ast::node_id d) {\n+        fn visit_fn_post(@mutable bool ignore, &ast::_fn f,\n+                         &vec[ast::ty_param] tps, &span sp,\n+                         &ast::fn_ident i, ast::node_id d) {\n             *ignore = false;\n         }\n         fn keep_going(@mutable bool ignore) -> bool { ret !*ignore; }\n@@ -1555,7 +1553,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::ty_only_fixup(fcx, id, oper_t);\n         }\n         case (ast::expr_path(?pth)) {\n-            auto t = ty::mk_nil(fcx.ccx.tcx);\n             auto defn = fcx.ccx.tcx.def_map.get(id);\n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n             if (ty::def_has_ty_params(defn)) {\n@@ -1627,7 +1624,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n         case (ast::expr_log(?l, ?e)) {\n-            auto expr_t = check_expr(fcx, e);\n+            check_expr(fcx, e);\n             write::nil_ty(fcx.ccx.tcx, id);\n         }\n         case (ast::expr_check(_, ?e)) {\n@@ -1671,10 +1668,9 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             check_expr(fcx, rhs);\n             auto rhs_t = expr_ty(fcx.ccx.tcx, rhs);\n             auto chan_t = ty::mk_chan(fcx.ccx.tcx, rhs_t);\n-            auto item_t;\n             auto lhs_t = expr_ty(fcx.ccx.tcx, lhs);\n             alt (structure_of(fcx, expr.span, lhs_t)) {\n-                case (ty::ty_chan(?it)) { item_t = it; }\n+                case (ty::ty_chan(?it)) { }\n                 case (_) {\n                     auto s = #fmt(\"mismatched types: expected chan \\\n                                    but found %s\",\n@@ -1755,7 +1751,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             // Now typecheck the blocks.\n \n             auto result_ty = next_ty_var(fcx);\n-            let vec[ast::block] blocks = [];\n             for (ast::arm arm in arms) {\n                 check_block(fcx, arm.block);\n                 auto bty = block_ty(fcx.ccx.tcx, arm.block);\n@@ -2135,7 +2130,6 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n                                     this_obj=di));\n \n             // Typecheck 'with_obj', if it exists.\n-            let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n                 case (none) { }\n                 case (some(?e)) {\n@@ -2192,7 +2186,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast::expr expr) {\n             for (@ast::method method in anon_obj.methods) {\n                 check_method(fcx.ccx, method);\n             }\n-            auto t = next_ty_var(fcx);\n+            next_ty_var(fcx);\n             // Now remove the info from the stack.\n \n             vec::pop[obj_info](fcx.ccx.obj_infos);"}, {"sha": "8821db4914ac968010c69c83618bf095ea4d55bd", "filename": "src/comp/middle/walk.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8db9a0fe1356ebdd702665e1844822a8a884b23/src%2Fcomp%2Fmiddle%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fwalk.rs?ref=d8db9a0fe1356ebdd702665e1844822a8a884b23", "patch": "@@ -39,8 +39,10 @@ type ast_visitor =\n         fn(&@ast::ty)  visit_ty_pre,\n         fn(&@ast::ty)  visit_ty_post,\n         fn(&@ast::constr)  visit_constr,\n-        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident, ast::node_id) visit_fn_pre,\n-        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident, ast::node_id) visit_fn_post);\n+        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident,\n+           ast::node_id) visit_fn_pre,\n+        fn(&ast::_fn, &vec[ast::ty_param], &span, &ast::fn_ident,\n+           ast::node_id) visit_fn_post);\n \n fn walk_crate(&ast_visitor v, &ast::crate c) {\n     if (!v.keep_going()) { ret; }\n@@ -387,8 +389,6 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n         case (ast::expr_anon_obj(?anon_obj, _, _)) {\n             // Fields\n \n-            let option::t[vec[ast::anon_obj_field]] fields =\n-                none[vec[ast::anon_obj_field]];\n             alt (anon_obj.fields) {\n                 case (none) { }\n                 case (some(?fields)) {\n@@ -400,7 +400,6 @@ fn walk_expr(&ast_visitor v, @ast::expr e) {\n             }\n             // with_obj\n \n-            let option::t[@ast::expr] with_obj = none[@ast::expr];\n             alt (anon_obj.with_obj) {\n                 case (none) { }\n                 case (some(?e)) { walk_expr(v, e); }"}]}