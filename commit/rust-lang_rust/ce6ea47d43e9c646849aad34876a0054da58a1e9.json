{"sha": "ce6ea47d43e9c646849aad34876a0054da58a1e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlNmVhNDdkNDNlOWM2NDY4NDlhYWQzNDg3NmEwMDU0ZGE1OGExZTk=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-05-02T14:40:40Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-05-02T14:40:40Z"}, "message": "refactor infer function\n\nThere was no span available in the cast function, but we need to infer the `x` in `x as char` to `u8`.\nThe spans are now removed from all functions using `infer` and instead added in `eval_const_expr_partial`", "tree": {"sha": "1ff301c0c9bf5ffcc11dd6723836a798367791d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ff301c0c9bf5ffcc11dd6723836a798367791d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce6ea47d43e9c646849aad34876a0054da58a1e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce6ea47d43e9c646849aad34876a0054da58a1e9", "html_url": "https://github.com/rust-lang/rust/commit/ce6ea47d43e9c646849aad34876a0054da58a1e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce6ea47d43e9c646849aad34876a0054da58a1e9/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f080b13c6beaa409c2bb643dd997a73ce0e75b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/f080b13c6beaa409c2bb643dd997a73ce0e75b89", "html_url": "https://github.com/rust-lang/rust/commit/f080b13c6beaa409c2bb643dd997a73ce0e75b89"}], "stats": {"total": 40, "additions": 20, "deletions": 20}, "files": [{"sha": "fc933d567fbd366ea151ae6f524667c3deba1c34", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ce6ea47d43e9c646849aad34876a0054da58a1e9/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce6ea47d43e9c646849aad34876a0054da58a1e9/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=ce6ea47d43e9c646849aad34876a0054da58a1e9", "patch": "@@ -814,7 +814,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n       },\n-      hir::ExprLit(ref lit) => lit_to_const(&lit.node, tcx, ety, lit.span)?,\n+      hir::ExprLit(ref lit) => match lit_to_const(&lit.node, tcx, ety, lit.span) {\n+          Ok(val) => val,\n+          Err(err) => signal!(e, err),\n+      },\n       hir::ExprBlock(ref block) => {\n         match block.expr {\n             Some(ref expr) => eval_const_expr_partial(tcx, &expr, ty_hint, fn_args)?,\n@@ -920,7 +923,10 @@ pub fn eval_const_expr_partial<'tcx>(tcx: &TyCtxt<'tcx>,\n     };\n \n     match (ety.map(|t| &t.sty), result) {\n-        (Some(ref ty_hint), Integral(i)) => Ok(Integral(infer(i, tcx, ty_hint, e.span)?)),\n+        (Some(ref ty_hint), Integral(i)) => match infer(i, tcx, ty_hint) {\n+            Ok(inferred) => Ok(Integral(inferred)),\n+            Err(err) => signal!(e, err),\n+        },\n         (_, result) => Ok(result),\n     }\n }\n@@ -929,15 +935,9 @@ fn infer<'tcx>(\n     i: ConstInt,\n     tcx: &TyCtxt<'tcx>,\n     ty_hint: &ty::TypeVariants<'tcx>,\n-    span: Span\n-) -> Result<ConstInt, ConstEvalErr> {\n+) -> Result<ConstInt, ErrKind> {\n     use syntax::ast::*;\n \n-    let err = |e| ConstEvalErr {\n-        span: span,\n-        kind: e,\n-    };\n-\n     match (ty_hint, i) {\n         (&ty::TyInt(IntTy::I8), result @ I8(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n@@ -983,17 +983,17 @@ fn infer<'tcx>(\n                 Err(_) => Ok(Usize(ConstUsize::Us32(i as u32))),\n             }\n         },\n-        (&ty::TyUint(_), InferSigned(_)) => Err(err(IntermediateUnsignedNegative)),\n+        (&ty::TyUint(_), InferSigned(_)) => Err(IntermediateUnsignedNegative),\n \n-        (&ty::TyInt(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n-        (&ty::TyUint(ity), i) => Err(err(TypeMismatch(ity.to_string(), i))),\n+        (&ty::TyInt(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n+        (&ty::TyUint(ity), i) => Err(TypeMismatch(ity.to_string(), i)),\n \n         (&ty::TyEnum(ref adt, _), i) => {\n             let hints = tcx.lookup_repr_hints(adt.did);\n             let int_ty = tcx.enum_repr_type(hints.iter().next());\n-            infer(i, tcx, &int_ty.to_ty(tcx).sty, span)\n+            infer(i, tcx, &int_ty.to_ty(tcx).sty)\n         },\n-        (_, i) => Err(err(BadType(ConstVal::Integral(i)))),\n+        (_, i) => Err(BadType(ConstVal::Integral(i))),\n     }\n }\n \n@@ -1125,36 +1125,36 @@ fn lit_to_const<'tcx>(lit: &ast::LitKind,\n                       tcx: &TyCtxt<'tcx>,\n                       ty_hint: Option<Ty<'tcx>>,\n                       span: Span,\n-                      ) -> Result<ConstVal, ConstEvalErr> {\n+                      ) -> Result<ConstVal, ErrKind> {\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n         LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity), span).map(Integral)\n+                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty), span).map(Integral)\n+                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n                 None => Ok(Integral(Infer(n))),\n                 Some(&ty::TyEnum(ref adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty, span).map(Integral)\n+                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity), span).map(Integral)\n+            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(ref n, _) |"}]}