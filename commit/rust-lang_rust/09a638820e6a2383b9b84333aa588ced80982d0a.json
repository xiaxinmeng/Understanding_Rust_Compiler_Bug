{"sha": "09a638820e6a2383b9b84333aa588ced80982d0a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5YTYzODgyMGU2YTIzODNiOWI4NDMzM2FhNTg4Y2VkODA5ODJkMGE=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-11T21:06:45Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-03-19T18:35:22Z"}, "message": "Move raw bytes handling to Encoder/Decoder.", "tree": {"sha": "d34ae37323511392449bb99f992817b496950ce1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d34ae37323511392449bb99f992817b496950ce1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09a638820e6a2383b9b84333aa588ced80982d0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09a638820e6a2383b9b84333aa588ced80982d0a", "html_url": "https://github.com/rust-lang/rust/commit/09a638820e6a2383b9b84333aa588ced80982d0a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09a638820e6a2383b9b84333aa588ced80982d0a/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5d09fbbe99f87efdb9ed23d6770fa0f62fdffcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5d09fbbe99f87efdb9ed23d6770fa0f62fdffcf", "html_url": "https://github.com/rust-lang/rust/commit/e5d09fbbe99f87efdb9ed23d6770fa0f62fdffcf"}], "stats": {"total": 133, "additions": 84, "deletions": 49}, "files": [{"sha": "6b533f9f057906afe341c53320dee791a72956c8", "filename": "compiler/rustc_data_structures/src/fingerprint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffingerprint.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -1,7 +1,7 @@\n use crate::stable_hasher;\n use rustc_serialize::{\n     opaque::{self, EncodeResult, FileEncodeResult},\n-    Decodable, Encodable,\n+    Decodable, Decoder, Encodable, Encoder,\n };\n use std::hash::{Hash, Hasher};\n use std::mem::{self, MaybeUninit};\n@@ -158,7 +158,7 @@ impl<E: rustc_serialize::Encoder> FingerprintEncoder for E {\n impl FingerprintEncoder for opaque::Encoder {\n     fn encode_fingerprint(&mut self, f: &Fingerprint) -> EncodeResult {\n         let bytes: [u8; 16] = unsafe { mem::transmute([f.0.to_le(), f.1.to_le()]) };\n-        self.emit_raw_bytes(&bytes);\n+        self.emit_raw_bytes(&bytes)?;\n         Ok(())\n     }\n }"}, {"sha": "b821ed6cff9f83f2706f378f8ef953e823a323f9", "filename": "compiler/rustc_incremental/src/persist/file_format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Ffile_format.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -15,6 +15,7 @@ use std::io::{self, Read};\n use std::path::Path;\n \n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n+use rustc_serialize::Encoder;\n \n /// The first few bytes of files generated by incremental compilation.\n const FILE_MAGIC: &[u8] = b\"RSIC\";"}, {"sha": "a07e0476050da1586e22f544500013116c074793", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -116,6 +116,7 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n         emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n+        emit_raw_bytes(&[u8]);\n     }\n }\n \n@@ -2070,10 +2071,10 @@ pub(super) fn encode_metadata(tcx: TyCtxt<'_>) -> EncodedMetadata {\n \n fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n     let mut encoder = opaque::Encoder::new(vec![]);\n-    encoder.emit_raw_bytes(METADATA_HEADER);\n+    encoder.emit_raw_bytes(METADATA_HEADER).unwrap();\n \n     // Will be filled with the root position after encoding everything.\n-    encoder.emit_raw_bytes(&[0, 0, 0, 0]);\n+    encoder.emit_raw_bytes(&[0, 0, 0, 0]).unwrap();\n \n     let source_map_files = tcx.sess.source_map().files();\n     let source_file_cache = (source_map_files[0].clone(), 0);"}, {"sha": "62c0ce1584594afdb3d85d9b5b57bd2d15adc941", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -2,6 +2,7 @@ use crate::rmeta::*;\n \n use rustc_index::vec::Idx;\n use rustc_serialize::opaque::Encoder;\n+use rustc_serialize::Encoder as _;\n use std::convert::TryInto;\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n@@ -172,7 +173,7 @@ where\n \n     pub(crate) fn encode(&self, buf: &mut Encoder) -> Lazy<Table<I, T>> {\n         let pos = buf.position();\n-        buf.emit_raw_bytes(&self.bytes);\n+        buf.emit_raw_bytes(&self.bytes).unwrap();\n         Lazy::from_position_and_meta(NonZeroUsize::new(pos as usize).unwrap(), self.bytes.len())\n     }\n }"}, {"sha": "ea1caf58d780ff0e530d1279fb8d0b3503698113", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -472,6 +472,11 @@ macro_rules! implement_ty_decoder {\n                     read_str -> Cow<'_, str>;\n                 }\n \n+                #[inline]\n+                fn read_raw_bytes(&mut self, bytes: &mut [std::mem::MaybeUninit<u8>]) -> Result<(), Self::Error> {\n+                    self.opaque.read_raw_bytes(bytes)\n+                }\n+\n                 fn error(&mut self, err: &str) -> Self::Error {\n                     self.opaque.error(err)\n                 }"}, {"sha": "e4c5907f5a59398ff0c71cc1cbb6bf71d6693bd8", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -1167,6 +1167,7 @@ where\n         emit_f32(f32);\n         emit_char(char);\n         emit_str(&str);\n+        emit_raw_bytes(&[u8]);\n     }\n }\n "}, {"sha": "51945ab435eab164cd17befb99a94508bdf6b066", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -188,6 +188,7 @@ use std::collections::{BTreeMap, HashMap};\n use std::io;\n use std::io::prelude::*;\n use std::mem::swap;\n+use std::mem::MaybeUninit;\n use std::num::FpCategory as Fp;\n use std::ops::Index;\n use std::str::FromStr;\n@@ -553,6 +554,12 @@ impl<'a> crate::Encoder for Encoder<'a> {\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         escape_str(self.writer, v)\n     }\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n+        for &c in s.iter() {\n+            self.emit_u8(c)?;\n+        }\n+        Ok(())\n+    }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n     where\n@@ -879,6 +886,12 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         escape_str(self.writer, v)\n     }\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error> {\n+        for &c in s.iter() {\n+            self.emit_u8(c)?;\n+        }\n+        Ok(())\n+    }\n \n     fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n     where\n@@ -2354,6 +2367,14 @@ impl crate::Decoder for Decoder {\n         expect!(self.pop(), String).map(Cow::Owned)\n     }\n \n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), Self::Error> {\n+        for c in s.iter_mut() {\n+            let h = self.read_u8()?;\n+            unsafe { *c.as_mut_ptr() = h };\n+        }\n+        Ok(())\n+    }\n+\n     fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,"}, {"sha": "c171593ebdca604c96cc19d7d3a35de3df0981c0", "filename": "compiler/rustc_serialize/src/opaque.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fopaque.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -1,5 +1,5 @@\n use crate::leb128::{self, max_leb128_len};\n-use crate::serialize;\n+use crate::serialize::{self, Decoder as _, Encoder as _};\n use std::borrow::Cow;\n use std::fs::File;\n use std::io::{self, Write};\n@@ -30,11 +30,6 @@ impl Encoder {\n     pub fn position(&self) -> usize {\n         self.data.len()\n     }\n-\n-    #[inline]\n-    pub fn emit_raw_bytes(&mut self, s: &[u8]) {\n-        self.data.extend_from_slice(s);\n-    }\n }\n \n macro_rules! write_leb128 {\n@@ -154,7 +149,12 @@ impl serialize::Encoder for Encoder {\n     #[inline]\n     fn emit_str(&mut self, v: &str) -> EncodeResult {\n         self.emit_usize(v.len())?;\n-        self.emit_raw_bytes(v.as_bytes());\n+        self.emit_raw_bytes(v.as_bytes())\n+    }\n+\n+    #[inline]\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> EncodeResult {\n+        self.data.extend_from_slice(s);\n         Ok(())\n     }\n }\n@@ -208,11 +208,6 @@ impl FileEncoder {\n         self.flushed + self.buffered\n     }\n \n-    #[inline]\n-    pub fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n-        self.write_all(s)\n-    }\n-\n     pub fn flush(&mut self) -> FileEncodeResult {\n         // This is basically a copy of `BufWriter::flush`. If `BufWriter` ever\n         // offers a raw buffer access API, we can use it, and remove this.\n@@ -508,6 +503,11 @@ impl serialize::Encoder for FileEncoder {\n         self.emit_usize(v.len())?;\n         self.emit_raw_bytes(v.as_bytes())\n     }\n+\n+    #[inline]\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> FileEncodeResult {\n+        self.write_all(s)\n+    }\n }\n \n // -----------------------------------------------------------------------------\n@@ -539,26 +539,6 @@ impl<'a> Decoder<'a> {\n     pub fn advance(&mut self, bytes: usize) {\n         self.position += bytes;\n     }\n-\n-    #[inline]\n-    pub fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), String> {\n-        let start = self.position;\n-        let end = start + s.len();\n-        assert!(end <= self.data.len());\n-\n-        // SAFETY: Both `src` and `dst` point to at least `s.len()` elements:\n-        // `src` points to at least `s.len()` elements by above assert, and\n-        // `dst` points to `s.len()` elements by derivation from `s`.\n-        unsafe {\n-            let src = self.data.as_ptr().add(start);\n-            let dst = s.as_mut_ptr() as *mut u8;\n-            ptr::copy_nonoverlapping(src, dst, s.len());\n-        }\n-\n-        self.position = end;\n-\n-        Ok(())\n-    }\n }\n \n macro_rules! read_leb128 {\n@@ -677,6 +657,26 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n     fn error(&mut self, err: &str) -> Self::Error {\n         err.to_string()\n     }\n+\n+    #[inline]\n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), String> {\n+        let start = self.position;\n+        let end = start + s.len();\n+        assert!(end <= self.data.len());\n+\n+        // SAFETY: Both `src` and `dst` point to at least `s.len()` elements:\n+        // `src` points to at least `s.len()` elements by above assert, and\n+        // `dst` points to `s.len()` elements by derivation from `s`.\n+        unsafe {\n+            let src = self.data.as_ptr().add(start);\n+            let dst = s.as_mut_ptr() as *mut u8;\n+            ptr::copy_nonoverlapping(src, dst, s.len());\n+        }\n+\n+        self.position = end;\n+\n+        Ok(())\n+    }\n }\n \n // Specializations for contiguous byte sequences follow. The default implementations for slices\n@@ -689,8 +689,7 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n impl serialize::Encodable<Encoder> for [u8] {\n     fn encode(&self, e: &mut Encoder) -> EncodeResult {\n         serialize::Encoder::emit_usize(e, self.len())?;\n-        e.emit_raw_bytes(self);\n-        Ok(())\n+        e.emit_raw_bytes(self)\n     }\n }\n \n@@ -727,32 +726,35 @@ impl IntEncodedWithFixedSize {\n }\n \n impl serialize::Encodable<Encoder> for IntEncodedWithFixedSize {\n+    #[inline]\n     fn encode(&self, e: &mut Encoder) -> EncodeResult {\n-        let start_pos = e.position();\n-        e.emit_raw_bytes(&self.0.to_le_bytes());\n-        let end_pos = e.position();\n-        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        let _start_pos = e.position();\n+        e.emit_raw_bytes(&self.0.to_le_bytes())?;\n+        let _end_pos = e.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n         Ok(())\n     }\n }\n \n impl serialize::Encodable<FileEncoder> for IntEncodedWithFixedSize {\n+    #[inline]\n     fn encode(&self, e: &mut FileEncoder) -> FileEncodeResult {\n-        let start_pos = e.position();\n+        let _start_pos = e.position();\n         e.emit_raw_bytes(&self.0.to_le_bytes())?;\n-        let end_pos = e.position();\n-        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        let _end_pos = e.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n         Ok(())\n     }\n }\n \n impl<'a> serialize::Decodable<Decoder<'a>> for IntEncodedWithFixedSize {\n+    #[inline]\n     fn decode(decoder: &mut Decoder<'a>) -> Result<IntEncodedWithFixedSize, String> {\n         let mut bytes = MaybeUninit::uninit_array();\n-        let start_pos = decoder.position();\n+        let _start_pos = decoder.position();\n         decoder.read_raw_bytes(&mut bytes)?;\n-        let end_pos = decoder.position();\n-        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        let _end_pos = decoder.position();\n+        debug_assert_eq!((_end_pos - _start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n \n         let value = u64::from_le_bytes(unsafe { MaybeUninit::array_assume_init(bytes) });\n         Ok(IntEncodedWithFixedSize(value))"}, {"sha": "a3b02b7c34abab1d8e37160d305f1436401fb68b", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09a638820e6a2383b9b84333aa588ced80982d0a/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=09a638820e6a2383b9b84333aa588ced80982d0a", "patch": "@@ -7,6 +7,7 @@ Core encoding and decoding interfaces.\n use std::borrow::Cow;\n use std::cell::{Cell, RefCell};\n use std::marker::PhantomData;\n+use std::mem::MaybeUninit;\n use std::path;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -33,6 +34,7 @@ pub trait Encoder {\n     fn emit_f32(&mut self, v: f32) -> Result<(), Self::Error>;\n     fn emit_char(&mut self, v: char) -> Result<(), Self::Error>;\n     fn emit_str(&mut self, v: &str) -> Result<(), Self::Error>;\n+    fn emit_raw_bytes(&mut self, s: &[u8]) -> Result<(), Self::Error>;\n \n     // Compound types:\n     #[inline]\n@@ -224,6 +226,7 @@ pub trait Decoder {\n     fn read_f32(&mut self) -> Result<f32, Self::Error>;\n     fn read_char(&mut self) -> Result<char, Self::Error>;\n     fn read_str(&mut self) -> Result<Cow<'_, str>, Self::Error>;\n+    fn read_raw_bytes(&mut self, s: &mut [MaybeUninit<u8>]) -> Result<(), Self::Error>;\n \n     // Compound types:\n     #[inline]"}]}