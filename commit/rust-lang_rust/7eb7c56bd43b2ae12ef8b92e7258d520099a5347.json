{"sha": "7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlYjdjNTZiZDQzYjJhZTEyZWY4YjkyZTcyNThkNTIwMDk5YTUzNDc=", "commit": {"author": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-01-28T16:20:48Z"}, "committer": {"name": "Alex Burka", "email": "aburka@seas.upenn.edu", "date": "2016-02-27T07:01:41Z"}, "message": "add indexing with RangeInclusive in libcore and libcollections", "tree": {"sha": "9265a7f93946aa1536e79cb7c42bba9a5e138480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9265a7f93946aa1536e79cb7c42bba9a5e138480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "html_url": "https://github.com/rust-lang/rust/commit/7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/comments", "author": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "committer": {"login": "durka", "id": 47007, "node_id": "MDQ6VXNlcjQ3MDA3", "avatar_url": "https://avatars.githubusercontent.com/u/47007?v=4", "gravatar_id": "", "url": "https://api.github.com/users/durka", "html_url": "https://github.com/durka", "followers_url": "https://api.github.com/users/durka/followers", "following_url": "https://api.github.com/users/durka/following{/other_user}", "gists_url": "https://api.github.com/users/durka/gists{/gist_id}", "starred_url": "https://api.github.com/users/durka/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/durka/subscriptions", "organizations_url": "https://api.github.com/users/durka/orgs", "repos_url": "https://api.github.com/users/durka/repos", "events_url": "https://api.github.com/users/durka/events{/privacy}", "received_events_url": "https://api.github.com/users/durka/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1b4f50678ecd6aaeed9991b860c272be010fc9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1b4f50678ecd6aaeed9991b860c272be010fc9f", "html_url": "https://github.com/rust-lang/rust/commit/b1b4f50678ecd6aaeed9991b860c272be010fc9f"}], "stats": {"total": 198, "additions": 192, "deletions": 6}, "files": [{"sha": "2a81e7dcaf704029fd7307a6b35670edb1879591", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -40,7 +40,7 @@\n #![feature(fmt_internals)]\n #![feature(fmt_radix)]\n #![feature(heap_api)]\n-#![feature(iter_arith)]\n+#![feature(inclusive_range)]\n #![feature(iter_arith)]\n #![feature(lang_items)]\n #![feature(nonzero)]"}, {"sha": "cae6520bdb28683a2e5f6d436758d896b298c741", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -59,7 +59,7 @@ use core::fmt;\n use core::hash;\n use core::iter::FromIterator;\n use core::mem;\n-use core::ops::{self, Add};\n+use core::ops::{self, Add, Index, IndexMut};\n use core::ptr;\n use core::slice;\n use core::str::pattern::Pattern;\n@@ -1606,6 +1606,24 @@ impl ops::Index<ops::RangeFull> for String {\n         unsafe { str::from_utf8_unchecked(&self.vec) }\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::Index<ops::RangeInclusive<usize>> for String {\n+    type Output = str;\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n+        Index::index(&**self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::Index<ops::RangeToInclusive<usize>> for String {\n+    type Output = str;\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n+        Index::index(&**self, index)\n+    }\n+}\n \n #[stable(feature = \"derefmut_for_string\", since = \"1.2.0\")]\n impl ops::IndexMut<ops::Range<usize>> for String {\n@@ -1635,6 +1653,20 @@ impl ops::IndexMut<ops::RangeFull> for String {\n         unsafe { mem::transmute(&mut *self.vec) }\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::IndexMut<ops::RangeInclusive<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl ops::IndexMut<ops::RangeToInclusive<usize>> for String {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for String {"}, {"sha": "841748f388127811afe78a9b535f39230849b8a0", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -1225,6 +1225,24 @@ impl<T> ops::Index<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeInclusive<usize>> for Vec<T> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeToInclusive<usize>> for Vec<T> {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n+        Index::index(&**self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for Vec<T> {\n@@ -1254,6 +1272,20 @@ impl<T> ops::IndexMut<ops::RangeFull> for Vec<T> {\n         self\n     }\n }\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for Vec<T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for Vec<T> {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n+        IndexMut::index_mut(&mut **self, index)\n+    }\n+}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::Deref for Vec<T> {"}, {"sha": "2293e93eea72557f7ee3e69cb33fd752c84d2051", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 51, "deletions": 4, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -560,7 +560,7 @@ impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n \n     #[inline]\n     fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.index(ops::Range{ start: 0, end: index.end })\n+        self.index(0 .. index.end)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -569,7 +569,7 @@ impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n \n     #[inline]\n     fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.index(ops::Range{ start: index.start, end: self.len() })\n+        self.index(index.start .. self.len())\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -582,6 +582,32 @@ impl<T> ops::Index<RangeFull> for [T] {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n+        match index {\n+            ops::RangeInclusive::Empty { .. } => &[],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                panic!(\"attempted to index slice up to maximum usize\"),\n+            ops::RangeInclusive::NonEmpty { start, end } =>\n+                self.index(start .. end+1)\n+        }\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n+    type Output = [T];\n+\n+    #[inline]\n+    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n+        // SNAP 3391630 change this to `0...index.end`\n+        self.index(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n@@ -603,15 +629,15 @@ impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(ops::Range{ start: 0, end: index.end })\n+        self.index_mut(0 .. index.end)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n     fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n         let len = self.len();\n-        self.index_mut(ops::Range{ start: index.start, end: len })\n+        self.index_mut(index.start .. len)\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -622,6 +648,27 @@ impl<T> ops::IndexMut<RangeFull> for [T] {\n     }\n }\n \n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n+        match index {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                panic!(\"attempted to index slice up to maximum usize\"),\n+            ops::RangeInclusive::NonEmpty { start, end } =>\n+                self.index_mut(start .. end+1)\n+        }\n+    }\n+}\n+#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n+impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n+    #[inline]\n+    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n+        // SNAP 3391630 change this to `0...index.end`\n+        self.index_mut(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+    }\n+}\n \n ////////////////////////////////////////////////////////////////////////////////\n // Common traits"}, {"sha": "1c77ea84537cbf7bd0b9e1583aaadc9629d41a14", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -1462,6 +1462,62 @@ mod traits {\n             self\n         }\n     }\n+\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::Index<ops::RangeInclusive<usize>> for str {\n+        type Output = str;\n+\n+        #[inline]\n+        fn index(&self, index: ops::RangeInclusive<usize>) -> &str {\n+            match index {\n+                ops::RangeInclusive::Empty { .. } => \"\",\n+                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                    panic!(\"attempted to index slice up to maximum usize\"),\n+                ops::RangeInclusive::NonEmpty { start, end } =>\n+                    self.index(start .. end+1)\n+            }\n+        }\n+    }\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::Index<ops::RangeToInclusive<usize>> for str {\n+        type Output = str;\n+\n+        #[inline]\n+        fn index(&self, index: ops::RangeToInclusive<usize>) -> &str {\n+            // SNAP 3391630 change this to `0...index.end`\n+            self.index(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+        }\n+    }\n+\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::IndexMut<ops::RangeInclusive<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut str {\n+            match index {\n+                ops::RangeInclusive::Empty { .. } => &mut self[0..0], // `&mut \"\"` doesn't work\n+                ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n+                    panic!(\"attempted to index str up to maximum usize\"),\n+                    ops::RangeInclusive::NonEmpty { start, end } =>\n+                        self.index_mut(start .. end+1)\n+            }\n+        }\n+    }\n+    #[unstable(feature = \"inclusive_range\",\n+               reason = \"recently added, follows RFC\",\n+               issue = \"28237\")]\n+    impl ops::IndexMut<ops::RangeToInclusive<usize>> for str {\n+        #[inline]\n+        fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut str {\n+            // SNAP 3391630 change this to `0...index.end`\n+            self.index_mut(ops::RangeInclusive::NonEmpty { start: 0, end: index.end })\n+        }\n+    }\n }\n \n /// Methods for string slices"}, {"sha": "6ecf5c32bdbd1f3cf861b4e1af2d981c0aefddb5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -233,6 +233,7 @@\n #![feature(fnbox)]\n #![feature(heap_api)]\n #![feature(hashmap_hasher)]\n+#![feature(inclusive_range)]\n #![feature(int_error_internals)]\n #![feature(into_cow)]\n #![feature(lang_items)]"}, {"sha": "52c8353d00e990107f52758cd0359ef30199b2fc", "filename": "src/test/run-pass/range_inclusive.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7eb7c56bd43b2ae12ef8b92e7258d520099a5347/src%2Ftest%2Frun-pass%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange_inclusive.rs?ref=7eb7c56bd43b2ae12ef8b92e7258d520099a5347", "patch": "@@ -55,6 +55,24 @@ pub fn main() {\n         let _ = x...&y;\n     }\n \n+    // test collection indexing\n+    let vec = (0...10).collect::<Vec<_>>();\n+    let slice: &[_] = &*vec;\n+    let string = String::from(\"hello world\");\n+    let stir = \"hello world\";\n+\n+    assert_eq!(&vec[3...6], &[3, 4, 5, 6]);\n+    assert_eq!(&vec[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+\n+    assert_eq!(&slice[3...6], &[3, 4, 5, 6]);\n+    assert_eq!(&slice[ ...6], &[0, 1, 2, 3, 4, 5, 6]);\n+\n+    assert_eq!(&string[3...6], \"lo w\");\n+    assert_eq!(&string[ ...6], \"hello w\");\n+\n+    assert_eq!(&stir[3...6], \"lo w\");\n+    assert_eq!(&stir[ ...6], \"hello w\");\n+\n     // test the size hints and emptying\n     let mut long = 0...255u8;\n     let mut short = 42...42;"}]}