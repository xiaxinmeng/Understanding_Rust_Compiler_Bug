{"sha": "d46d012c3812338c5172ad61fee133efd3870edc", "node_id": "C_kwDOAAsO6NoAKGQ0NmQwMTJjMzgxMjMzOGM1MTcyYWQ2MWZlZTEzM2VmZDM4NzBlZGM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T10:30:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-20T10:30:18Z"}, "message": "Auto merge of #13978 - bvanjoi:array-match, r=Veykril\n\nfeat: array match\n\nfixed https://github.com/rust-lang/rust-analyzer/issues/13970", "tree": {"sha": "03d4b61d4a12f7fcf6183bcc497cc518f07d2148", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03d4b61d4a12f7fcf6183bcc497cc518f07d2148"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d46d012c3812338c5172ad61fee133efd3870edc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d46d012c3812338c5172ad61fee133efd3870edc", "html_url": "https://github.com/rust-lang/rust/commit/d46d012c3812338c5172ad61fee133efd3870edc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d46d012c3812338c5172ad61fee133efd3870edc/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e52c64031825920983515b9e975e93232739f7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e52c64031825920983515b9e975e93232739f7f", "html_url": "https://github.com/rust-lang/rust/commit/6e52c64031825920983515b9e975e93232739f7f"}, {"sha": "8fa69f9f7d815632c3b80ea0395dd51c2938525a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa69f9f7d815632c3b80ea0395dd51c2938525a", "html_url": "https://github.com/rust-lang/rust/commit/8fa69f9f7d815632c3b80ea0395dd51c2938525a"}], "stats": {"total": 168, "additions": 157, "deletions": 11}, "files": [{"sha": "012812cea24aad09707a8ffdba78c421f53914ab", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=d46d012c3812338c5172ad61fee133efd3870edc", "patch": "@@ -50,6 +50,7 @@ use hir_def::{\n     per_ns::PerNs,\n     resolver::{HasResolver, Resolver},\n     src::HasSource as _,\n+    type_ref::ConstScalar,\n     AdtId, AssocItemId, AssocItemLoc, AttrDefId, ConstId, ConstParamId, DefWithBodyId, EnumId,\n     EnumVariantId, FunctionId, GenericDefId, HasModule, ImplId, ItemContainerId, LifetimeParamId,\n     LocalEnumVariantId, LocalFieldId, Lookup, MacroExpander, MacroId, ModuleId, StaticId, StructId,\n@@ -65,8 +66,9 @@ use hir_ty::{\n     primitive::UintTy,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n-    GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n-    TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind, WhereClause,\n+    ConcreteConst, ConstValue, GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar,\n+    Substitution, TraitEnvironment, TraitRefExt, Ty, TyBuilder, TyDefId, TyExt, TyKind,\n+    WhereClause,\n };\n use itertools::Itertools;\n use nameres::diagnostics::DefDiagnosticKind;\n@@ -3232,6 +3234,19 @@ impl Type {\n         }\n     }\n \n+    pub fn as_array(&self, _db: &dyn HirDatabase) -> Option<(Type, usize)> {\n+        if let TyKind::Array(ty, len) = &self.ty.kind(Interner) {\n+            match len.data(Interner).value {\n+                ConstValue::Concrete(ConcreteConst { interned: ConstScalar::UInt(len) }) => {\n+                    Some((self.derived(ty.clone()), len as usize))\n+                }\n+                _ => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn autoderef<'a>(&'a self, db: &'a dyn HirDatabase) -> impl Iterator<Item = Type> + 'a {\n         self.autoderef_(db).map(move |ty| self.derived(ty))\n     }"}, {"sha": "5d81e8cfeacbc644bd68ac09acff16780c437484", "filename": "crates/ide-assists/src/handlers/add_missing_match_arms.rs", "status": "modified", "additions": 131, "deletions": 9, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_match_arms.rs?ref=d46d012c3812338c5172ad61fee133efd3870edc", "patch": "@@ -140,6 +140,31 @@ pub(crate) fn add_missing_match_arms(acc: &mut Assists, ctx: &AssistContext<'_>)\n             })\n             .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n         ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n+    } else if let Some((enum_def, len)) = resolve_array_of_enum_def(&ctx.sema, &expr) {\n+        let is_non_exhaustive = enum_def.is_non_exhaustive(ctx.db(), module.krate());\n+        let variants = enum_def.variants(ctx.db());\n+\n+        if len.pow(variants.len() as u32) > 256 {\n+            return None;\n+        }\n+\n+        let variants_of_enums = vec![variants.clone(); len];\n+\n+        let missing_pats = variants_of_enums\n+            .into_iter()\n+            .multi_cartesian_product()\n+            .inspect(|_| cov_mark::hit!(add_missing_match_arms_lazy_computation))\n+            .map(|variants| {\n+                let is_hidden = variants\n+                    .iter()\n+                    .any(|variant| variant.should_be_hidden(ctx.db(), module.krate()));\n+                let patterns = variants.into_iter().filter_map(|variant| {\n+                    build_pat(ctx.db(), module, variant.clone(), ctx.config.prefer_no_std)\n+                });\n+                (ast::Pat::from(make::slice_pat(patterns)), is_hidden)\n+            })\n+            .filter(|(variant_pat, _)| is_variant_missing(&top_lvl_pats, variant_pat));\n+        ((Box::new(missing_pats) as Box<dyn Iterator<Item = _>>).peekable(), is_non_exhaustive)\n     } else {\n         return None;\n     };\n@@ -266,6 +291,9 @@ fn is_variant_missing(existing_pats: &[Pat], var: &Pat) -> bool {\n fn does_pat_match_variant(pat: &Pat, var: &Pat) -> bool {\n     match (pat, var) {\n         (Pat::WildcardPat(_), _) => true,\n+        (Pat::SlicePat(spat), Pat::SlicePat(svar)) => {\n+            spat.pats().zip(svar.pats()).all(|(p, v)| does_pat_match_variant(&p, &v))\n+        }\n         (Pat::TuplePat(tpat), Pat::TuplePat(tvar)) => {\n             tpat.fields().zip(tvar.fields()).all(|(p, v)| does_pat_match_variant(&p, &v))\n         }\n@@ -280,7 +308,7 @@ enum ExtendedEnum {\n     Enum(hir::Enum),\n }\n \n-#[derive(Eq, PartialEq, Clone, Copy)]\n+#[derive(Eq, PartialEq, Clone, Copy, Debug)]\n enum ExtendedVariant {\n     True,\n     False,\n@@ -340,15 +368,30 @@ fn resolve_tuple_of_enum_def(\n         .tuple_fields(sema.db)\n         .iter()\n         .map(|ty| {\n-            ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n-                Some(Adt::Enum(e)) => Some(lift_enum(e)),\n-                // For now we only handle expansion for a tuple of enums. Here\n-                // we map non-enum items to None and rely on `collect` to\n-                // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n-                _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n+            ty.autoderef(sema.db).find_map(|ty| {\n+                match ty.as_adt() {\n+                    Some(Adt::Enum(e)) => Some(lift_enum(e)),\n+                    // For now we only handle expansion for a tuple of enums. Here\n+                    // we map non-enum items to None and rely on `collect` to\n+                    // convert Vec<Option<hir::Enum>> into Option<Vec<hir::Enum>>.\n+                    _ => ty.is_bool().then_some(ExtendedEnum::Bool),\n+                }\n             })\n         })\n-        .collect()\n+        .collect::<Option<Vec<ExtendedEnum>>>()\n+        .and_then(|list| if list.is_empty() { None } else { Some(list) })\n+}\n+\n+fn resolve_array_of_enum_def(\n+    sema: &Semantics<'_, RootDatabase>,\n+    expr: &ast::Expr,\n+) -> Option<(ExtendedEnum, usize)> {\n+    sema.type_of_expr(expr)?.adjusted().as_array(sema.db).and_then(|(ty, len)| {\n+        ty.autoderef(sema.db).find_map(|ty| match ty.as_adt() {\n+            Some(Adt::Enum(e)) => Some((lift_enum(e), len)),\n+            _ => ty.is_bool().then_some((ExtendedEnum::Bool, len)),\n+        })\n+    })\n }\n \n fn build_pat(\n@@ -377,7 +420,6 @@ fn build_pat(\n                 }\n                 ast::StructKind::Unit => make::path_pat(path),\n             };\n-\n             Some(pat)\n         }\n         ExtendedVariant::True => Some(ast::Pat::from(make::literal_pat(\"true\"))),\n@@ -573,6 +615,86 @@ fn foo(a: bool) {\n         )\n     }\n \n+    #[test]\n+    fn fill_boolean_array() {\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a] {\n+        $0[true] => todo!(),\n+        [false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a,]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a,] {\n+        $0[true] => todo!(),\n+        [false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a]$0 {\n+        [true, true] => todo!(),\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a] {\n+        [true, true] => todo!(),\n+        $0[true, false] => todo!(),\n+        [false, true] => todo!(),\n+        [false, false] => todo!(),\n+    }\n+}\n+\"#,\n+        );\n+\n+        check_assist(\n+            add_missing_match_arms,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a]$0 {\n+    }\n+}\n+\"#,\n+            r#\"\n+fn foo(a: bool) {\n+    match [a, a] {\n+        $0[true, true] => todo!(),\n+        [true, false] => todo!(),\n+        [false, true] => todo!(),\n+        [false, false] => todo!(),\n+    }\n+}\n+\"#,\n+        )\n+    }\n+\n     #[test]\n     fn partial_fill_boolean_tuple() {\n         check_assist("}, {"sha": "a35983435c7b49a9cd0fae62a9afecf1913b762e", "filename": "crates/syntax/src/ast/make.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d46d012c3812338c5172ad61fee133efd3870edc/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fmake.rs?ref=d46d012c3812338c5172ad61fee133efd3870edc", "patch": "@@ -520,6 +520,15 @@ pub fn literal_pat(lit: &str) -> ast::LiteralPat {\n     }\n }\n \n+pub fn slice_pat(pats: impl IntoIterator<Item = ast::Pat>) -> ast::SlicePat {\n+    let pats_str = pats.into_iter().join(\", \");\n+    return from_text(&format!(\"[{pats_str}]\"));\n+\n+    fn from_text(text: &str) -> ast::SlicePat {\n+        ast_from_text(&format!(\"fn f() {{ match () {{{text} => ()}} }}\"))\n+    }\n+}\n+\n /// Creates a tuple of patterns from an iterator of patterns.\n ///\n /// Invariant: `pats` must be length > 0"}]}