{"sha": "ac044e35aa4ce72569d59ab46b560eb37b930f52", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMDQ0ZTM1YWE0Y2U3MjU2OWQ1OWFiNDZiNTYwZWIzN2I5MzBmNTI=", "commit": {"author": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-04-10T17:08:31Z"}, "committer": {"name": "hyd-dev", "email": "yd-huang@outlook.com", "date": "2021-04-17T10:11:07Z"}, "message": "Do not ignore path segments in the middle in `#[allow]`/`#[warn]`/`#[deny]`/`#[forbid]` attributes", "tree": {"sha": "eaad93faaf2abc866b06e28bd3be3bcedec07ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eaad93faaf2abc866b06e28bd3be3bcedec07ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac044e35aa4ce72569d59ab46b560eb37b930f52", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niIsEABYIADMWIQRJ2jPMDdiQ+U4U42Z0+n/VuNoUuAUCYHq0OxUceWQtaHVhbmdA\nb3V0bG9vay5jb20ACgkQdPp/1bjaFLhlSwD/UO/QOj0NRMwL1uzLrMvWq7Q9Zo0U\npMrtLgi86CbrVl8BALMUm/ei5IGkMCyF2J/AuORoPAj1LzmzMcb6bfrpAdcI\n=L5vv\n-----END PGP SIGNATURE-----", "payload": "tree eaad93faaf2abc866b06e28bd3be3bcedec07ecf\nparent e43c2005f250b51e24d294da0b228e0a2dc4d9b2\nauthor hyd-dev <yd-huang@outlook.com> 1618074511 +0800\ncommitter hyd-dev <yd-huang@outlook.com> 1618654267 +0800\n\nDo not ignore path segments in the middle in `#[allow]`/`#[warn]`/`#[deny]`/`#[forbid]` attributes\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac044e35aa4ce72569d59ab46b560eb37b930f52", "html_url": "https://github.com/rust-lang/rust/commit/ac044e35aa4ce72569d59ab46b560eb37b930f52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac044e35aa4ce72569d59ab46b560eb37b930f52/comments", "author": null, "committer": null, "parents": [{"sha": "e43c2005f250b51e24d294da0b228e0a2dc4d9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e43c2005f250b51e24d294da0b228e0a2dc4d9b2", "html_url": "https://github.com/rust-lang/rust/commit/e43c2005f250b51e24d294da0b228e0a2dc4d9b2"}], "stats": {"total": 129, "additions": 85, "deletions": 44}, "files": [{"sha": "54909381a10a509dd1075146f6d399e7f5a6e815", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 38, "deletions": 43, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/ac044e35aa4ce72569d59ab46b560eb37b930f52/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac044e35aa4ce72569d59ab46b560eb37b930f52/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=ac044e35aa4ce72569d59ab46b560eb37b930f52", "patch": "@@ -236,10 +236,9 @@ impl<'s> LintLevelsBuilder<'s> {\n                 Some(lvl) => lvl,\n             };\n \n-            let meta = unwrap_or!(attr.meta(), continue);\n             self.sess.mark_attr_used(attr);\n \n-            let mut metas = unwrap_or!(meta.meta_item_list(), continue);\n+            let mut metas = unwrap_or!(attr.meta_item_list(), continue);\n \n             if metas.is_empty() {\n                 // FIXME (#55112): issue unused-attributes lint for `#[level()]`\n@@ -255,8 +254,6 @@ impl<'s> LintLevelsBuilder<'s> {\n                     ast::MetaItemKind::Word => {} // actual lint names handled later\n                     ast::MetaItemKind::NameValue(ref name_value) => {\n                         if item.path == sym::reason {\n-                            // found reason, reslice meta list to exclude it\n-                            metas = &metas[0..metas.len() - 1];\n                             // FIXME (#55112): issue unused-attributes lint if we thereby\n                             // don't have any lint names (`#[level(reason = \"foo\")]`)\n                             if let ast::LitKind::Str(rationale, _) = name_value.kind {\n@@ -275,6 +272,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     .span_label(name_value.span, \"reason must be a string literal\")\n                                     .emit();\n                             }\n+                            // found reason, reslice meta list to exclude it\n+                            metas.pop().unwrap();\n                         } else {\n                             bad_attr(item.span)\n                                 .span_label(item.span, \"bad attribute argument\")\n@@ -288,10 +287,10 @@ impl<'s> LintLevelsBuilder<'s> {\n             }\n \n             for li in metas {\n-                let meta_item = match li.meta_item() {\n-                    Some(meta_item) if meta_item.is_word() => meta_item,\n+                let sp = li.span();\n+                let mut meta_item = match li {\n+                    ast::NestedMetaItem::MetaItem(meta_item) if meta_item.is_word() => meta_item,\n                     _ => {\n-                        let sp = li.span();\n                         let mut err = bad_attr(sp);\n                         let mut add_label = true;\n                         if let Some(item) = li.meta_item() {\n@@ -330,15 +329,19 @@ impl<'s> LintLevelsBuilder<'s> {\n                         continue;\n                     }\n \n-                    Some(tool_ident.name)\n+                    Some(meta_item.path.segments.remove(0).ident.name)\n                 } else {\n                     None\n                 };\n-                let name = meta_item.path.segments.last().expect(\"empty lint name\").ident.name;\n-                let lint_result = store.check_lint_name(&name.as_str(), tool_name);\n+                let name = pprust::path_to_string(&meta_item.path);\n+                let lint_result = store.check_lint_name(&name, tool_name);\n                 match &lint_result {\n                     CheckLintNameResult::Ok(ids) => {\n-                        let src = LintLevelSource::Node(name, li.span(), reason);\n+                        let src = LintLevelSource::Node(\n+                            meta_item.path.segments.last().expect(\"empty lint name\").ident.name,\n+                            sp,\n+                            reason,\n+                        );\n                         for &id in *ids {\n                             self.check_gated_lint(id, attr.span);\n                             self.insert_spec(&mut specs, id, (level, src));\n@@ -351,7 +354,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 let complete_name = &format!(\"{}::{}\", tool_name.unwrap(), name);\n                                 let src = LintLevelSource::Node(\n                                     Symbol::intern(complete_name),\n-                                    li.span(),\n+                                    sp,\n                                     reason,\n                                 );\n                                 for id in ids {\n@@ -367,7 +370,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     lint,\n                                     lvl,\n                                     src,\n-                                    Some(li.span().into()),\n+                                    Some(sp.into()),\n                                     |lint| {\n                                         let msg = format!(\n                                             \"lint name `{}` is deprecated \\\n@@ -376,7 +379,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                                         );\n                                         lint.build(&msg)\n                                             .span_suggestion(\n-                                                li.span(),\n+                                                sp,\n                                                 \"change it to\",\n                                                 new_lint_name.to_string(),\n                                                 Applicability::MachineApplicable,\n@@ -387,7 +390,7 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                                 let src = LintLevelSource::Node(\n                                     Symbol::intern(&new_lint_name),\n-                                    li.span(),\n+                                    sp,\n                                     reason,\n                                 );\n                                 for id in ids {\n@@ -414,12 +417,12 @@ impl<'s> LintLevelsBuilder<'s> {\n                             lint,\n                             renamed_lint_level,\n                             src,\n-                            Some(li.span().into()),\n+                            Some(sp.into()),\n                             |lint| {\n                                 let mut err = lint.build(&msg);\n                                 if let Some(new_name) = &renamed {\n                                     err.span_suggestion(\n-                                        li.span(),\n+                                        sp,\n                                         \"use the new name\",\n                                         new_name.to_string(),\n                                         Applicability::MachineApplicable,\n@@ -433,30 +436,23 @@ impl<'s> LintLevelsBuilder<'s> {\n                         let lint = builtin::UNKNOWN_LINTS;\n                         let (level, src) =\n                             self.sets.get_lint_level(lint, self.cur, Some(&specs), self.sess);\n-                        struct_lint_level(\n-                            self.sess,\n-                            lint,\n-                            level,\n-                            src,\n-                            Some(li.span().into()),\n-                            |lint| {\n-                                let name = if let Some(tool_name) = tool_name {\n-                                    format!(\"{}::{}\", tool_name, name)\n-                                } else {\n-                                    name.to_string()\n-                                };\n-                                let mut db = lint.build(&format!(\"unknown lint: `{}`\", name));\n-                                if let Some(suggestion) = suggestion {\n-                                    db.span_suggestion(\n-                                        li.span(),\n-                                        \"did you mean\",\n-                                        suggestion.to_string(),\n-                                        Applicability::MachineApplicable,\n-                                    );\n-                                }\n-                                db.emit();\n-                            },\n-                        );\n+                        struct_lint_level(self.sess, lint, level, src, Some(sp.into()), |lint| {\n+                            let name = if let Some(tool_name) = tool_name {\n+                                format!(\"{}::{}\", tool_name, name)\n+                            } else {\n+                                name.to_string()\n+                            };\n+                            let mut db = lint.build(&format!(\"unknown lint: `{}`\", name));\n+                            if let Some(suggestion) = suggestion {\n+                                db.span_suggestion(\n+                                    sp,\n+                                    \"did you mean\",\n+                                    suggestion.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                            }\n+                            db.emit();\n+                        });\n                     }\n                 }\n                 // If this lint was renamed, apply the new lint instead of ignoring the attribute.\n@@ -466,8 +462,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                     // Ignore any errors or warnings that happen because the new name is inaccurate\n                     // NOTE: `new_name` already includes the tool name, so we don't have to add it again.\n                     if let CheckLintNameResult::Ok(ids) = store.check_lint_name(&new_name, None) {\n-                        let src =\n-                            LintLevelSource::Node(Symbol::intern(&new_name), li.span(), reason);\n+                        let src = LintLevelSource::Node(Symbol::intern(&new_name), sp, reason);\n                         for &id in ids {\n                             self.check_gated_lint(id, attr.span);\n                             self.insert_spec(&mut specs, id, (level, src));"}, {"sha": "0eba52acfa3d8c4e29fac5cad26fba05c114881b", "filename": "src/test/ui/lint/issue-83477.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftest%2Fui%2Flint%2Fissue-83477.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftest%2Fui%2Flint%2Fissue-83477.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-83477.rs?ref=ac044e35aa4ce72569d59ab46b560eb37b930f52", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+#![warn(rustc::internal)]\n+\n+#[allow(rustc::foo::bar::default_hash_types)]\n+//~^ WARN unknown lint: `rustc::foo::bar::default_hash_types`\n+//~| HELP did you mean\n+//~| SUGGESTION rustc::default_hash_types\n+#[allow(rustc::foo::default_hash_types)]\n+//~^ WARN unknown lint: `rustc::foo::default_hash_types`\n+//~| HELP did you mean\n+//~| SUGGESTION rustc::default_hash_types\n+fn main() {\n+    let _ = std::collections::HashMap::<String, String>::new();\n+    //~^ WARN Prefer FxHashMap over HashMap, it has better performance\n+    //~| HELP use\n+}"}, {"sha": "dbe0c9e01301fcc94db80679dc7bee0940847bde", "filename": "src/test/ui/lint/issue-83477.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftest%2Fui%2Flint%2Fissue-83477.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftest%2Fui%2Flint%2Fissue-83477.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-83477.stderr?ref=ac044e35aa4ce72569d59ab46b560eb37b930f52", "patch": "@@ -0,0 +1,30 @@\n+warning: unknown lint: `rustc::foo::bar::default_hash_types`\n+  --> $DIR/issue-83477.rs:4:9\n+   |\n+LL | #[allow(rustc::foo::bar::default_hash_types)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean: `rustc::default_hash_types`\n+   |\n+   = note: `#[warn(unknown_lints)]` on by default\n+\n+warning: unknown lint: `rustc::foo::default_hash_types`\n+  --> $DIR/issue-83477.rs:8:9\n+   |\n+LL | #[allow(rustc::foo::default_hash_types)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean: `rustc::default_hash_types`\n+\n+warning: Prefer FxHashMap over HashMap, it has better performance\n+  --> $DIR/issue-83477.rs:13:31\n+   |\n+LL |     let _ = std::collections::HashMap::<String, String>::new();\n+   |                               ^^^^^^^ help: use: `FxHashMap`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-83477.rs:2:9\n+   |\n+LL | #![warn(rustc::internal)]\n+   |         ^^^^^^^^^^^^^^^\n+   = note: `#[warn(rustc::default_hash_types)]` implied by `#[warn(rustc::internal)]`\n+   = note: a `use rustc_data_structures::fx::FxHashMap` may be necessary\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "96121b114ce6c8cfb5f77b18cfaadbf55cf3c991", "filename": "src/tools/clippy/tests/ui/filter_methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac044e35aa4ce72569d59ab46b560eb37b930f52/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffilter_methods.rs?ref=ac044e35aa4ce72569d59ab46b560eb37b930f52", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::all, clippy::pedantic)]\n-#![allow(clippy::clippy::let_underscore_drop)]\n+#![allow(clippy::let_underscore_drop)]\n #![allow(clippy::missing_docs_in_private_items)]\n \n fn main() {"}]}