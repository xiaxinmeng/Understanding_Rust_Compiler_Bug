{"sha": "37418b850f43fd95596c688c230f5e8d94e1962f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM3NDE4Yjg1MGY0M2ZkOTU1OTZjNjg4YzIzMGY1ZThkOTRlMTk2MmY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-29T21:37:19Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "stop using MatchCheckCtxt to hold the param-env for check_match", "tree": {"sha": "894f554899bb0388c9d8c1c93df2c0d0bee8f767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/894f554899bb0388c9d8c1c93df2c0d0bee8f767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37418b850f43fd95596c688c230f5e8d94e1962f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37418b850f43fd95596c688c230f5e8d94e1962f", "html_url": "https://github.com/rust-lang/rust/commit/37418b850f43fd95596c688c230f5e8d94e1962f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37418b850f43fd95596c688c230f5e8d94e1962f/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a", "html_url": "https://github.com/rust-lang/rust/commit/e313d8b290ddd129f35ce0a6ae319bbd2c19a73a"}], "stats": {"total": 296, "additions": 161, "deletions": 135}, "files": [{"sha": "cac486b743c7e7b14c5149d61fd31382ce5a0754", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=37418b850f43fd95596c688c230f5e8d94e1962f", "patch": "@@ -155,7 +155,6 @@ impl<'a, 'tcx> FromIterator<Vec<&'a Pattern<'tcx>>> for Matrix<'a, 'tcx> {\n //NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ty::ParameterEnvironment<'tcx>,\n     /// A wild pattern with an error type - it exists to avoid having to normalize\n     /// associated types to get field types.\n     pub wild_pattern: &'a Pattern<'tcx>,\n@@ -165,7 +164,6 @@ pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n     pub fn create_and_enter<F, R>(\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        param_env: ty::ParameterEnvironment<'tcx>,\n         f: F) -> R\n         where F: for<'b> FnOnce(MatchCheckCtxt<'b, 'tcx>) -> R\n     {\n@@ -179,7 +177,6 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n         f(MatchCheckCtxt {\n             tcx: tcx,\n-            param_env: param_env,\n             wild_pattern: &wild_pattern,\n             pattern_arena: &pattern_arena,\n         })\n@@ -675,18 +672,3 @@ fn specialize<'a, 'tcx>(\n         head\n     })\n }\n-\n-pub fn is_refutable<'a, 'tcx, A, F>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    pat: &'a Pattern<'tcx>,\n-    refutable: F)\n-    -> Option<A> where\n-    F: FnOnce(&Witness) -> A,\n-{\n-    let pats = Matrix(vec![vec![pat]]);\n-    match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n-        UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n-        NotUseful => None,\n-        Useful => bug!()\n-    }\n-}"}, {"sha": "a402db705b2e41792ea5765d8e2ad6856523d5eb", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 161, "deletions": 117, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37418b850f43fd95596c688c230f5e8d94e1962f/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=37418b850f43fd95596c688c230f5e8d94e1962f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use _match::{MatchCheckCtxt, Matrix, lower_pat, is_refutable, is_useful};\n+use _match::{MatchCheckCtxt, Matrix, lower_pat, is_useful};\n use _match::{DUMMY_WILD_PAT};\n use _match::Usefulness::*;\n use _match::WitnessPreference::*;\n@@ -44,89 +44,156 @@ use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n use syntax_pos::Span;\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n-        check_expr(self, ex);\n+struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n+\n+impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, _expr: &hir::Expr) {\n+        return // const, static and N in [T; N] - shouldn't contain anything\n     }\n-    fn visit_local(&mut self, l: &hir::Local) {\n-        check_local(self, l);\n+\n+    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+        if let hir::ConstTraitItem(..) = item.node {\n+            return // nothing worth match checking in a constant\n+        } else {\n+            intravisit::walk_trait_item(self, item);\n+        }\n     }\n+\n+    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Const(..) = item.node {\n+            return // nothing worth match checking in a constant\n+        } else {\n+            intravisit::walk_impl_item(self, item);\n+        }\n+    }\n+\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n-        check_fn(self, fk, fd, b, s, n);\n+                b: &'v hir::Block, s: Span, id: ast::NodeId) {\n+        if let FnKind::Closure(..) = fk {\n+            span_bug!(s, \"check_match: closure outside of function\")\n+        }\n+\n+        MatchVisitor {\n+            tcx: self.tcx,\n+            param_env: &ty::ParameterEnvironment::for_item(self.tcx, id)\n+        }.visit_fn(fk, fd, b, s, id);\n     }\n }\n \n+impl<'a, 'tcx> OuterVisitor<'a, 'tcx> {\n+}\n+\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    MatchCheckCtxt::create_and_enter(tcx, tcx.empty_parameter_environment(), |mut cx| {\n-        tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut cx);\n-    });\n+    tcx.visit_all_items_in_krate(DepNode::MatchCheck, &mut OuterVisitor { tcx: tcx });\n     tcx.sess.abort_if_errors();\n }\n \n fn create_e0004<'a>(sess: &'a Session, sp: Span, error_message: String) -> DiagnosticBuilder<'a> {\n     struct_span_err!(sess, sp, E0004, \"{}\", &error_message)\n }\n \n-fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n-    intravisit::walk_expr(cx, ex);\n-    match ex.node {\n-        hir::ExprMatch(ref scrut, ref arms, source) => {\n-            for arm in arms {\n-                // First, check legality of move bindings.\n-                check_legality_of_move_bindings(cx,\n-                                                arm.guard.is_some(),\n-                                                &arm.pats);\n-\n-                // Second, if there is a guard on each arm, make sure it isn't\n-                // assigning or borrowing anything mutably.\n-                if let Some(ref guard) = arm.guard {\n-                    check_for_mutation_in_guard(cx, &guard);\n-                }\n-            }\n+struct MatchVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    param_env: &'a ty::ParameterEnvironment<'tcx>\n+}\n \n-            let mut static_inliner = StaticInliner::new(cx.tcx);\n-            let inlined_arms = arms.iter().map(|arm| {\n-                (arm.pats.iter().map(|pat| {\n-                    static_inliner.fold_pat((*pat).clone())\n-                }).collect(), arm.guard.as_ref().map(|e| &**e))\n-            }).collect::<Vec<(Vec<P<Pat>>, Option<&hir::Expr>)>>();\n+impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, ex: &hir::Expr) {\n+        intravisit::walk_expr(self, ex);\n \n-            // Bail out early if inlining failed.\n-            if static_inliner.failed {\n-                return;\n+        match ex.node {\n+            hir::ExprMatch(ref scrut, ref arms, source) => {\n+                self.check_match(scrut, arms, source, ex.span);\n             }\n+            _ => {}\n+        }\n+    }\n \n-            for pat in inlined_arms\n-                .iter()\n-                .flat_map(|&(ref pats, _)| pats) {\n-                // Third, check legality of move bindings.\n-                check_legality_of_bindings_in_at_patterns(cx, &pat);\n+    fn visit_local(&mut self, loc: &hir::Local) {\n+        intravisit::walk_local(self, loc);\n+\n+        let pat = StaticInliner::new(self.tcx).fold_pat(loc.pat.clone());\n+        self.check_irrefutable(&pat, false);\n+\n+        // Check legality of move bindings and `@` patterns.\n+        self.check_patterns(false, slice::ref_slice(&loc.pat));\n+    }\n \n-                // Fourth, check if there are any references to NaN that we should warn about.\n-                check_for_static_nan(cx, &pat);\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n+        intravisit::walk_fn(self, fk, fd, b, s, n);\n \n-                // Fifth, check if for any of the patterns that match an enumerated type\n-                // are bindings with the same name as one of the variants of said type.\n-                check_for_bindings_named_the_same_as_variants(cx, &pat);\n+        for input in &fd.inputs {\n+            self.check_irrefutable(&input.pat, true);\n+            self.check_patterns(false, slice::ref_slice(&input.pat));\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n+    fn check_patterns(&self, has_guard: bool, pats: &[P<Pat>]) {\n+        check_legality_of_move_bindings(self, has_guard, pats);\n+        for pat in pats {\n+            check_legality_of_bindings_in_at_patterns(self, pat);\n+        }\n+    }\n+\n+    fn check_match(\n+        &self,\n+        scrut: &hir::Expr,\n+        arms: &[hir::Arm],\n+        source: hir::MatchSource,\n+        span: Span)\n+    {\n+        for arm in arms {\n+            // First, check legality of move bindings.\n+            self.check_patterns(arm.guard.is_some(), &arm.pats);\n+\n+            // Second, if there is a guard on each arm, make sure it isn't\n+            // assigning or borrowing anything mutably.\n+            if let Some(ref guard) = arm.guard {\n+                check_for_mutation_in_guard(self, &guard);\n             }\n+        }\n+\n+        let mut static_inliner = StaticInliner::new(self.tcx);\n+        let inlined_arms = arms.iter().map(|arm| {\n+            (arm.pats.iter().map(|pat| {\n+                static_inliner.fold_pat((*pat).clone())\n+            }).collect(), arm.guard.as_ref().map(|e| &**e))\n+        }).collect::<Vec<(Vec<P<Pat>>, Option<&hir::Expr>)>>();\n+\n+        // Bail out early if inlining failed.\n+        if static_inliner.failed {\n+            return;\n+        }\n \n+        for pat in inlined_arms.iter().flat_map(|&(ref pats, _)| pats) {\n+            // Fourth, check if there are any references to NaN that we should warn about.\n+            check_for_static_nan(self, &pat);\n+\n+            // Fifth, check if for any of the patterns that match an enumerated type\n+            // are bindings with the same name as one of the variants of said type.\n+            check_for_bindings_named_the_same_as_variants(self, &pat);\n+        }\n+\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n             // Fourth, check for unreachable arms.\n             check_arms(cx, &inlined_arms[..], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n-            let pat_ty = cx.tcx.node_id_to_type(scrut.id);\n+            let pat_ty = self.tcx.node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(cx.tcx) {\n+                if !pat_ty.is_uninhabited(self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n-                    let mut err = create_e0004(cx.tcx.sess, ex.span,\n+                    let mut err = create_e0004(self.tcx.sess, span,\n                                                format!(\"non-exhaustive patterns: type {} \\\n                                                         is non-empty\",\n                                                        pat_ty));\n-                    span_help!(&mut err, ex.span,\n-                        \"Please ensure that all possible cases are being handled; \\\n-                         possibly adding wildcards or more match arms.\");\n+                    span_help!(&mut err, span,\n+                               \"Please ensure that all possible cases are being handled; \\\n+                                possibly adding wildcards or more match arms.\");\n                     err.emit();\n                 }\n                 // If the type *is* uninhabited, it's vacuously exhaustive\n@@ -140,12 +207,40 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &hir::Expr) {\n                 .map(|pat| vec![lower_pat(cx, &pat)])\n                 .collect();\n             check_exhaustive(cx, scrut.span, &matrix, source);\n-        },\n-        _ => ()\n+        })\n+    }\n+\n+    fn check_irrefutable(&self, pat: &Pat, is_fn_arg: bool) {\n+        let origin = if is_fn_arg {\n+            \"function argument\"\n+        } else {\n+            \"local binding\"\n+        };\n+\n+        MatchCheckCtxt::create_and_enter(self.tcx, |ref cx| {\n+            let pats : Matrix = vec![vec![\n+                lower_pat(cx, pat)\n+            ]].into_iter().collect();\n+\n+            let witness = match is_useful(cx, &pats, &[cx.wild_pattern], ConstructWitness) {\n+                UsefulWithWitness(witness) => witness,\n+                NotUseful => return,\n+                Useful => bug!()\n+            };\n+\n+            let pattern_string = pat_to_string(witness[0].single_pattern());\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess, pat.span, E0005,\n+                \"refutable pattern in {}: `{}` not covered\",\n+                origin, pattern_string\n+            );\n+            diag.span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string));\n+            diag.emit();\n+        });\n     }\n }\n \n-fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat) {\n+fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n             let pat_ty = cx.tcx.pat_ty(p);\n@@ -175,7 +270,7 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchCheckCtxt, pat: &Pat)\n }\n \n // Check that we do not match against a static NaN (#6804)\n-fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n+fn check_for_static_nan(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n         if let PatKind::Lit(ref expr) = p.node {\n             match eval_const_expr_partial(cx.tcx, &expr, ExprTypeChecked, None) {\n@@ -444,56 +539,8 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n     }\n }\n \n-fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n-    intravisit::walk_local(cx, loc);\n-\n-    let pat = StaticInliner::new(cx.tcx).fold_pat(loc.pat.clone());\n-    check_irrefutable(cx, &pat, false);\n-\n-    // Check legality of move bindings and `@` patterns.\n-    check_legality_of_move_bindings(cx, false, slice::ref_slice(&loc.pat));\n-    check_legality_of_bindings_in_at_patterns(cx, &loc.pat);\n-}\n-\n-fn check_fn(cx: &mut MatchCheckCtxt,\n-            kind: FnKind,\n-            decl: &hir::FnDecl,\n-            body: &hir::Block,\n-            sp: Span,\n-            fn_id: ast::NodeId) {\n-    match kind {\n-        FnKind::Closure(_) => {}\n-        _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n-    }\n-\n-    intravisit::walk_fn(cx, kind, decl, body, sp, fn_id);\n-\n-    for input in &decl.inputs {\n-        check_irrefutable(cx, &input.pat, true);\n-        check_legality_of_move_bindings(cx, false, slice::ref_slice(&input.pat));\n-        check_legality_of_bindings_in_at_patterns(cx, &input.pat);\n-    }\n-}\n-\n-fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n-    let origin = if is_fn_arg {\n-        \"function argument\"\n-    } else {\n-        \"local binding\"\n-    };\n-\n-    is_refutable(cx, &lower_pat(cx, pat), |uncovered_pat| {\n-        let pattern_string = pat_to_string(uncovered_pat.single_pattern());\n-        struct_span_err!(cx.tcx.sess, pat.span, E0005,\n-            \"refutable pattern in {}: `{}` not covered\",\n-            origin,\n-            pattern_string,\n-        ).span_label(pat.span, &format!(\"pattern `{}` not covered\", pattern_string)).emit();\n-    });\n-}\n-\n // Legality of move bindings checking\n-fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n+fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    has_guard: bool,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n@@ -532,13 +579,9 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         pat.walk(|p| {\n             if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n                 let pat_ty = cx.tcx.node_id_to_type(p.id);\n-                //FIXME: (@jroesch) this code should be floated up as well\n-                cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                                  Reveal::NotSpecializable).enter(|infcx| {\n-                    if infcx.type_moves_by_default(pat_ty, pat.span) {\n-                        check_move(p, sub.as_ref().map(|p| &**p));\n-                    }\n-                });\n+                if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n+                    check_move(p, sub.as_ref().map(|p| &**p));\n+                }\n             }\n             true\n         });\n@@ -547,8 +590,9 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n \n /// Ensures that a pattern guard doesn't borrow by mutable reference or\n /// assign.\n-fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n-                                         guard: &hir::Expr) {\n+///\n+/// FIXME: this should be done by borrowck.\n+fn check_for_mutation_in_guard(cx: &MatchVisitor, guard: &hir::Expr) {\n     cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n                       Reveal::NotSpecializable).enter(|infcx| {\n         let mut checker = MutationChecker {\n@@ -560,7 +604,7 @@ fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n }\n \n struct MutationChecker<'a, 'gcx: 'a> {\n-    cx: &'a MatchCheckCtxt<'a, 'gcx>,\n+    cx: &'a MatchVisitor<'a, 'gcx>,\n }\n \n impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n@@ -600,12 +644,12 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n /// Forbids bindings in `@` patterns. This is necessary for memory safety,\n /// because of the way rvalues are handled in the borrow check. (See issue\n /// #14587.)\n-fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchVisitor, pat: &Pat) {\n     AtBindingPatternVisitor { cx: cx, bindings_allowed: true }.visit_pat(pat);\n }\n \n struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n-    cx: &'a MatchCheckCtxt<'b, 'tcx>,\n+    cx: &'a MatchVisitor<'b, 'tcx>,\n     bindings_allowed: bool\n }\n "}]}