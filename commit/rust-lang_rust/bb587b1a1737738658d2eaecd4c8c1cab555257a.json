{"sha": "bb587b1a1737738658d2eaecd4c8c1cab555257a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNTg3YjFhMTczNzczODY1OGQyZWFlY2Q0YzhjMWNhYjU1NTI1N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T22:25:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-07T22:25:14Z"}, "message": "Auto merge of #80652 - calebzulawski:simd-lanes, r=nagisa\n\nImprove SIMD type element count validation\n\nResolves rust-lang/stdsimd#53.\n\nThese changes are motivated by `stdsimd` moving in the direction of const generic vectors, e.g.:\n```rust\n#[repr(simd)]\nstruct SimdF32<const N: usize>([f32; N]);\n```\n\nThis makes a few changes:\n* Establishes a maximum SIMD lane count of 2^16 (65536).  This value is arbitrary, but attempts to validate lane count before hitting potential errors in the backend.  It's not clear what LLVM's maximum lane count is, but cranelift's appears to be much less than `usize::MAX`, at least.\n* Expands some SIMD intrinsics to support arbitrary lane counts.  This resolves the ICE in the linked issue.\n* Attempts to catch invalid-sized vectors during typeck when possible.\n\nUnresolved questions:\n* Generic-length vectors can't be validated in typeck and are only validated after monomorphization while computing layout.  This \"works\", but the errors simply bail out with no context beyond the name of the type.  Should these errors instead return `LayoutError` or otherwise provide context in some way?  As it stands, users of `stdsimd` could trivially produce monomorphization errors by making zero-length vectors.\n\ncc `@bjorn3`", "tree": {"sha": "dd6c0c0f7509d6c9d75e817485adb61ecf720c59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd6c0c0f7509d6c9d75e817485adb61ecf720c59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb587b1a1737738658d2eaecd4c8c1cab555257a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb587b1a1737738658d2eaecd4c8c1cab555257a", "html_url": "https://github.com/rust-lang/rust/commit/bb587b1a1737738658d2eaecd4c8c1cab555257a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb587b1a1737738658d2eaecd4c8c1cab555257a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9778068cbc1e06cc3685422323ff38a2f397de26", "url": "https://api.github.com/repos/rust-lang/rust/commits/9778068cbc1e06cc3685422323ff38a2f397de26", "html_url": "https://github.com/rust-lang/rust/commit/9778068cbc1e06cc3685422323ff38a2f397de26"}, {"sha": "a4bab7c6fab5a44f989321c1abf4cfc72ebb1d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4bab7c6fab5a44f989321c1abf4cfc72ebb1d28", "html_url": "https://github.com/rust-lang/rust/commit/a4bab7c6fab5a44f989321c1abf4cfc72ebb1d28"}], "stats": {"total": 716, "additions": 321, "deletions": 395}, "files": [{"sha": "ee099f93258b7d6f4ed5d720277d3c5f6cb70a04", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 3, "deletions": 121, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -380,7 +380,7 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                     \"rust_eh_personality\"\n                 };\n                 let fty = self.type_variadic_func(&[], self.type_i32());\n-                self.declare_cfn(name, fty)\n+                self.declare_cfn(name, llvm::UnnamedAddr::Global, fty)\n             }\n         };\n         attributes::apply_target_cpu_attr(self, llfn);\n@@ -429,7 +429,7 @@ impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n \n     fn declare_c_main(&self, fn_type: Self::Type) -> Option<Self::Function> {\n         if self.get_declared_value(\"main\").is_none() {\n-            Some(self.declare_cfn(\"main\", fn_type))\n+            Some(self.declare_cfn(\"main\", llvm::UnnamedAddr::Global, fn_type))\n         } else {\n             // If the symbol already exists, it is an error: for example, the user wrote\n             // #[no_mangle] extern \"C\" fn main(..) {..}\n@@ -459,8 +459,7 @@ impl CodegenCx<'b, 'tcx> {\n         } else {\n             self.type_variadic_func(&[], ret)\n         };\n-        let f = self.declare_cfn(name, fn_ty);\n-        llvm::SetUnnamedAddress(f, llvm::UnnamedAddr::No);\n+        let f = self.declare_cfn(name, llvm::UnnamedAddr::No, fn_ty);\n         self.intrinsics.borrow_mut().insert(name, f);\n         f\n     }\n@@ -498,25 +497,6 @@ impl CodegenCx<'b, 'tcx> {\n         let t_f32 = self.type_f32();\n         let t_f64 = self.type_f64();\n \n-        macro_rules! vector_types {\n-            ($id_out:ident: $elem_ty:ident, $len:expr) => {\n-                let $id_out = self.type_vector($elem_ty, $len);\n-            };\n-            ($($id_out:ident: $elem_ty:ident, $len:expr;)*) => {\n-                $(vector_types!($id_out: $elem_ty, $len);)*\n-            }\n-        }\n-        vector_types! {\n-            t_v2f32: t_f32, 2;\n-            t_v4f32: t_f32, 4;\n-            t_v8f32: t_f32, 8;\n-            t_v16f32: t_f32, 16;\n-\n-            t_v2f64: t_f64, 2;\n-            t_v4f64: t_f64, 4;\n-            t_v8f64: t_f64, 8;\n-        }\n-\n         ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f32\", fn(t_f32) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.saturate.unsigned.i32.f64\", fn(t_f64) -> t_i32);\n         ifn!(\"llvm.wasm.trunc.saturate.unsigned.i64.f32\", fn(t_f32) -> t_i64);\n@@ -540,149 +520,51 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.sideeffect\", fn() -> void);\n \n         ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n-        ifn!(\"llvm.powi.v2f32\", fn(t_v2f32, t_i32) -> t_v2f32);\n-        ifn!(\"llvm.powi.v4f32\", fn(t_v4f32, t_i32) -> t_v4f32);\n-        ifn!(\"llvm.powi.v8f32\", fn(t_v8f32, t_i32) -> t_v8f32);\n-        ifn!(\"llvm.powi.v16f32\", fn(t_v16f32, t_i32) -> t_v16f32);\n         ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n-        ifn!(\"llvm.powi.v2f64\", fn(t_v2f64, t_i32) -> t_v2f64);\n-        ifn!(\"llvm.powi.v4f64\", fn(t_v4f64, t_i32) -> t_v4f64);\n-        ifn!(\"llvm.powi.v8f64\", fn(t_v8f64, t_i32) -> t_v8f64);\n \n         ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n-        ifn!(\"llvm.pow.v2f32\", fn(t_v2f32, t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.pow.v4f32\", fn(t_v4f32, t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.pow.v8f32\", fn(t_v8f32, t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.pow.v16f32\", fn(t_v16f32, t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n-        ifn!(\"llvm.pow.v2f64\", fn(t_v2f64, t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.pow.v4f64\", fn(t_v4f64, t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.pow.v8f64\", fn(t_v8f64, t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.sqrt.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.sqrt.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.sqrt.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.sqrt.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.sqrt.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.sqrt.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.sqrt.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.sin.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.sin.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.sin.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.sin.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.sin.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.sin.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.sin.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.cos.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.cos.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.cos.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.cos.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.cos.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.cos.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.cos.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.exp.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.exp.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.exp.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.exp.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.exp.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.exp.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.exp.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.exp2.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.exp2.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.exp2.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.exp2.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.exp2.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.exp2.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.exp2.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.log.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.log.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.log.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.log.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.log.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.log.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.log.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.log10.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.log10.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.log10.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.log10.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.log10.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.log10.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.log10.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.log2.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.log2.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.log2.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.log2.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.log2.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.log2.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.log2.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n-        ifn!(\"llvm.fma.v2f32\", fn(t_v2f32, t_v2f32, t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.fma.v4f32\", fn(t_v4f32, t_v4f32, t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.fma.v8f32\", fn(t_v8f32, t_v8f32, t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.fma.v16f32\", fn(t_v16f32, t_v16f32, t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n-        ifn!(\"llvm.fma.v2f64\", fn(t_v2f64, t_v2f64, t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.fma.v4f64\", fn(t_v4f64, t_v4f64, t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.fma.v8f64\", fn(t_v8f64, t_v8f64, t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.fabs.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.fabs.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.fabs.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.fabs.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.fabs.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.minnum.f32\", fn(t_f32, t_f32) -> t_f32);\n         ifn!(\"llvm.minnum.f64\", fn(t_f64, t_f64) -> t_f64);\n         ifn!(\"llvm.maxnum.f32\", fn(t_f32, t_f32) -> t_f32);\n         ifn!(\"llvm.maxnum.f64\", fn(t_f64, t_f64) -> t_f64);\n \n         ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.floor.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.floor.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.floor.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.floor.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.floor.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n-        ifn!(\"llvm.ceil.v2f32\", fn(t_v2f32) -> t_v2f32);\n-        ifn!(\"llvm.ceil.v4f32\", fn(t_v4f32) -> t_v4f32);\n-        ifn!(\"llvm.ceil.v8f32\", fn(t_v8f32) -> t_v8f32);\n-        ifn!(\"llvm.ceil.v16f32\", fn(t_v16f32) -> t_v16f32);\n         ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n-        ifn!(\"llvm.ceil.v2f64\", fn(t_v2f64) -> t_v2f64);\n-        ifn!(\"llvm.ceil.v4f64\", fn(t_v4f64) -> t_v4f64);\n-        ifn!(\"llvm.ceil.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n         ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);"}, {"sha": "8977fa085b9bbe1093f14f4723a52abcf8dd04df", "filename": "compiler/rustc_codegen_llvm/src/declare.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdeclare.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -30,6 +30,7 @@ fn declare_raw_fn(\n     cx: &CodegenCx<'ll, '_>,\n     name: &str,\n     callconv: llvm::CallConv,\n+    unnamed: llvm::UnnamedAddr,\n     ty: &'ll Type,\n ) -> &'ll Value {\n     debug!(\"declare_raw_fn(name={:?}, ty={:?})\", name, ty);\n@@ -38,9 +39,7 @@ fn declare_raw_fn(\n     };\n \n     llvm::SetFunctionCallConv(llfn, callconv);\n-    // Function addresses in Rust are never significant, allowing functions to\n-    // be merged.\n-    llvm::SetUnnamedAddress(llfn, llvm::UnnamedAddr::Global);\n+    llvm::SetUnnamedAddress(llfn, unnamed);\n \n     if cx.tcx.sess.opts.cg.no_redzone.unwrap_or(cx.tcx.sess.target.disable_redzone) {\n         llvm::Attribute::NoRedZone.apply_llfn(Function, llfn);\n@@ -68,8 +67,13 @@ impl CodegenCx<'ll, 'tcx> {\n     ///\n     /// If there\u2019s a value with the same name already declared, the function will\n     /// update the declaration and return existing Value instead.\n-    pub fn declare_cfn(&self, name: &str, fn_type: &'ll Type) -> &'ll Value {\n-        declare_raw_fn(self, name, llvm::CCallConv, fn_type)\n+    pub fn declare_cfn(\n+        &self,\n+        name: &str,\n+        unnamed: llvm::UnnamedAddr,\n+        fn_type: &'ll Type,\n+    ) -> &'ll Value {\n+        declare_raw_fn(self, name, llvm::CCallConv, unnamed, fn_type)\n     }\n \n     /// Declare a Rust function.\n@@ -79,7 +83,15 @@ impl CodegenCx<'ll, 'tcx> {\n     pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> &'ll Value {\n         debug!(\"declare_rust_fn(name={:?}, fn_abi={:?})\", name, fn_abi);\n \n-        let llfn = declare_raw_fn(self, name, fn_abi.llvm_cconv(), fn_abi.llvm_type(self));\n+        // Function addresses in Rust are never significant, allowing functions to\n+        // be merged.\n+        let llfn = declare_raw_fn(\n+            self,\n+            name,\n+            fn_abi.llvm_cconv(),\n+            llvm::UnnamedAddr::Global,\n+            fn_abi.llvm_type(self),\n+        );\n         fn_abi.apply_attrs_llfn(self, llfn);\n         llfn\n     }"}, {"sha": "668daa52ed262edd9d42097de7407e549cbba9f9", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 61, "deletions": 82, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -1009,7 +1009,7 @@ fn generic_simd_intrinsic(\n     }\n \n     fn simd_simple_float_intrinsic(\n-        name: &str,\n+        name: Symbol,\n         in_elem: &::rustc_middle::ty::TyS<'_>,\n         in_ty: &::rustc_middle::ty::TyS<'_>,\n         in_len: u64,\n@@ -1036,93 +1036,69 @@ fn generic_simd_intrinsic(\n                 }\n             }\n         }\n-        let ety = match in_elem.kind() {\n-            ty::Float(f) if f.bit_width() == 32 => {\n-                if in_len < 2 || in_len > 16 {\n-                    return_error!(\n-                        \"unsupported floating-point vector `{}` with length `{}` \\\n-                         out-of-range [2, 16]\",\n-                        in_ty,\n-                        in_len\n-                    );\n-                }\n-                \"f32\"\n-            }\n-            ty::Float(f) if f.bit_width() == 64 => {\n-                if in_len < 2 || in_len > 8 {\n+\n+        let (elem_ty_str, elem_ty) = if let ty::Float(f) = in_elem.kind() {\n+            let elem_ty = bx.cx.type_float_from_ty(*f);\n+            match f.bit_width() {\n+                32 => (\"f32\", elem_ty),\n+                64 => (\"f64\", elem_ty),\n+                _ => {\n                     return_error!(\n-                        \"unsupported floating-point vector `{}` with length `{}` \\\n-                                   out-of-range [2, 8]\",\n-                        in_ty,\n-                        in_len\n+                        \"unsupported element type `{}` of floating-point vector `{}`\",\n+                        f.name_str(),\n+                        in_ty\n                     );\n                 }\n-                \"f64\"\n-            }\n-            ty::Float(f) => {\n-                return_error!(\n-                    \"unsupported element type `{}` of floating-point vector `{}`\",\n-                    f.name_str(),\n-                    in_ty\n-                );\n-            }\n-            _ => {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n             }\n+        } else {\n+            return_error!(\"`{}` is not a floating-point type\", in_ty);\n         };\n \n-        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", name, in_len, ety);\n-        let intrinsic = bx.get_intrinsic(&llvm_name);\n-        let c =\n-            bx.call(intrinsic, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n+        let vec_ty = bx.type_vector(elem_ty, in_len);\n+\n+        let (intr_name, fn_ty) = match name {\n+            sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fsin => (\"sin\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fcos => (\"cos\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fabs => (\"fabs\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_floor => (\"floor\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_ceil => (\"ceil\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fexp => (\"exp\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fexp2 => (\"exp2\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_flog10 => (\"log10\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_flog2 => (\"log2\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_flog => (\"log\", bx.type_func(&[vec_ty], vec_ty)),\n+            sym::simd_fpowi => (\"powi\", bx.type_func(&[vec_ty, bx.type_i32()], vec_ty)),\n+            sym::simd_fpow => (\"pow\", bx.type_func(&[vec_ty, vec_ty], vec_ty)),\n+            sym::simd_fma => (\"fma\", bx.type_func(&[vec_ty, vec_ty, vec_ty], vec_ty)),\n+            _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+        };\n+\n+        let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n+        let f = bx.declare_cfn(&llvm_name, llvm::UnnamedAddr::No, fn_ty);\n+        let c = bx.call(f, &args.iter().map(|arg| arg.immediate()).collect::<Vec<_>>(), None);\n         unsafe { llvm::LLVMRustSetHasUnsafeAlgebra(c) };\n         Ok(c)\n     }\n \n-    match name {\n-        sym::simd_fsqrt => {\n-            return simd_simple_float_intrinsic(\"sqrt\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fsin => {\n-            return simd_simple_float_intrinsic(\"sin\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fcos => {\n-            return simd_simple_float_intrinsic(\"cos\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fabs => {\n-            return simd_simple_float_intrinsic(\"fabs\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_floor => {\n-            return simd_simple_float_intrinsic(\"floor\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_ceil => {\n-            return simd_simple_float_intrinsic(\"ceil\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fexp => {\n-            return simd_simple_float_intrinsic(\"exp\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fexp2 => {\n-            return simd_simple_float_intrinsic(\"exp2\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_flog10 => {\n-            return simd_simple_float_intrinsic(\"log10\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_flog2 => {\n-            return simd_simple_float_intrinsic(\"log2\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_flog => {\n-            return simd_simple_float_intrinsic(\"log\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fpowi => {\n-            return simd_simple_float_intrinsic(\"powi\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fpow => {\n-            return simd_simple_float_intrinsic(\"pow\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        sym::simd_fma => {\n-            return simd_simple_float_intrinsic(\"fma\", in_elem, in_ty, in_len, bx, span, args);\n-        }\n-        _ => { /* fallthrough */ }\n+    if std::matches!(\n+        name,\n+        sym::simd_fsqrt\n+            | sym::simd_fsin\n+            | sym::simd_fcos\n+            | sym::simd_fabs\n+            | sym::simd_floor\n+            | sym::simd_ceil\n+            | sym::simd_fexp\n+            | sym::simd_fexp2\n+            | sym::simd_flog10\n+            | sym::simd_flog2\n+            | sym::simd_flog\n+            | sym::simd_fpowi\n+            | sym::simd_fpow\n+            | sym::simd_fma\n+    ) {\n+        return simd_simple_float_intrinsic(name, in_elem, in_ty, in_len, bx, span, args);\n     }\n \n     // FIXME: use:\n@@ -1278,12 +1254,12 @@ fn generic_simd_intrinsic(\n             format!(\"llvm.masked.gather.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = bx.declare_cfn(\n             &llvm_intrinsic,\n+            llvm::UnnamedAddr::No,\n             bx.type_func(\n                 &[llvm_pointer_vec_ty, alignment_ty, mask_ty, llvm_elem_vec_ty],\n                 llvm_elem_vec_ty,\n             ),\n         );\n-        llvm::SetUnnamedAddress(f, llvm::UnnamedAddr::No);\n         let v = bx.call(f, &[args[1].immediate(), alignment, mask, args[0].immediate()], None);\n         return Ok(v);\n     }\n@@ -1408,9 +1384,9 @@ fn generic_simd_intrinsic(\n             format!(\"llvm.masked.scatter.{}.{}\", llvm_elem_vec_str, llvm_pointer_vec_str);\n         let f = bx.declare_cfn(\n             &llvm_intrinsic,\n+            llvm::UnnamedAddr::No,\n             bx.type_func(&[llvm_elem_vec_ty, llvm_pointer_vec_ty, alignment_ty, mask_ty], ret_t),\n         );\n-        llvm::SetUnnamedAddress(f, llvm::UnnamedAddr::No);\n         let v = bx.call(f, &[args[0].immediate(), args[1].immediate(), alignment, mask], None);\n         return Ok(v);\n     }\n@@ -1714,8 +1690,11 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n         );\n         let vec_ty = bx.cx.type_vector(elem_ty, in_len as u64);\n \n-        let f = bx.declare_cfn(&llvm_intrinsic, bx.type_func(&[vec_ty, vec_ty], vec_ty));\n-        llvm::SetUnnamedAddress(f, llvm::UnnamedAddr::No);\n+        let f = bx.declare_cfn(\n+            &llvm_intrinsic,\n+            llvm::UnnamedAddr::No,\n+            bx.type_func(&[vec_ty, vec_ty], vec_ty),\n+        );\n         let v = bx.call(f, &[lhs, rhs], None);\n         return Ok(v);\n     }"}, {"sha": "785d6de226d3d17fda7e97b8b2726535cffdec0e", "filename": "compiler/rustc_error_codes/src/error_codes/E0074.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0074.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0074.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0074.md?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -11,7 +11,7 @@ This will cause an error:\n #![feature(repr_simd)]\n \n #[repr(simd)]\n-struct Bad<T>(T, T, T);\n+struct Bad<T>(T, T, T, T);\n ```\n \n This will not:\n@@ -20,5 +20,5 @@ This will not:\n #![feature(repr_simd)]\n \n #[repr(simd)]\n-struct Good(u32, u32, u32);\n+struct Good(u32, u32, u32, u32);\n ```"}, {"sha": "1da8caa9506d7e3b8ffb52ba65ceeed3e8d5ac8c", "filename": "compiler/rustc_error_codes/src/error_codes/E0076.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0076.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0076.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0076.md?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -7,7 +7,7 @@ Erroneous code example:\n #![feature(repr_simd)]\n \n #[repr(simd)]\n-struct Bad(u16, u32, u32); // error!\n+struct Bad(u16, u32, u32 u32); // error!\n ```\n \n When using the `#[simd]` attribute to automatically use SIMD operations in tuple\n@@ -20,5 +20,5 @@ Fixed example:\n #![feature(repr_simd)]\n \n #[repr(simd)]\n-struct Good(u32, u32, u32); // ok!\n+struct Good(u32, u32, u32, u32); // ok!\n ```"}, {"sha": "91aa24d1f52f417b74adc9f8c9f49e3d695d06b9", "filename": "compiler/rustc_error_codes/src/error_codes/E0077.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0077.md", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0077.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0077.md?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -19,5 +19,5 @@ Fixed example:\n #![feature(repr_simd)]\n \n #[repr(simd)]\n-struct Good(u32, u32, u32); // ok!\n+struct Good(u32, u32, u32, u32); // ok!\n ```"}, {"sha": "0b592ca4710b609a4aa3d40fe42c1d1a71a69b3f", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -188,6 +188,13 @@ pub const FAT_PTR_ADDR: usize = 0;\n /// - For a slice, this is the length.\n pub const FAT_PTR_EXTRA: usize = 1;\n \n+/// The maximum supported number of lanes in a SIMD vector.\n+///\n+/// This value is selected based on backend support:\n+/// * LLVM does not appear to have a vector width limit.\n+/// * Cranelift stores the base-2 log of the lane count in a 4 bit integer.\n+pub const MAX_SIMD_LANES: u64 = 1 << 0xF;\n+\n #[derive(Copy, Clone, Debug, TyEncodable, TyDecodable)]\n pub enum LayoutError<'tcx> {\n     Unknown(Ty<'tcx>),\n@@ -717,10 +724,22 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 };\n \n                 // SIMD vectors of zero length are not supported.\n+                // Additionally, lengths are capped at 2^16 as a fixed maximum backends must\n+                // support.\n                 //\n                 // Can't be caught in typeck if the array length is generic.\n                 if e_len == 0 {\n                     tcx.sess.fatal(&format!(\"monomorphising SIMD type `{}` of zero length\", ty));\n+                } else if !e_len.is_power_of_two() {\n+                    tcx.sess.fatal(&format!(\n+                        \"monomorphising SIMD type `{}` of non-power-of-two length\",\n+                        ty\n+                    ));\n+                } else if e_len > MAX_SIMD_LANES {\n+                    tcx.sess.fatal(&format!(\n+                        \"monomorphising SIMD type `{}` of length greater than {}\",\n+                        ty, MAX_SIMD_LANES,\n+                    ));\n                 }\n \n                 // Compute the ABI of the element type:"}, {"sha": "5f27355f0bab1983e1fd97951a0c4af614e0e9e8", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -12,6 +12,7 @@ use rustc_hir::{ItemKind, Node};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{RegionVariableOrigin, TyCtxtInferExt};\n use rustc_middle::ty::fold::TypeFoldable;\n+use rustc_middle::ty::layout::MAX_SIMD_LANES;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::util::{Discr, IntTypeExt, Representability};\n use rustc_middle::ty::{self, ParamEnv, RegionKind, ToPredicate, Ty, TyCtxt};\n@@ -1134,6 +1135,38 @@ pub fn check_simd(tcx: TyCtxt<'_>, sp: Span, def_id: LocalDefId) {\n                     .emit();\n                 return;\n             }\n+\n+            let len = if let ty::Array(_ty, c) = e.kind() {\n+                c.try_eval_usize(tcx, tcx.param_env(def.did))\n+            } else {\n+                Some(fields.len() as u64)\n+            };\n+            if let Some(len) = len {\n+                if len == 0 {\n+                    struct_span_err!(tcx.sess, sp, E0075, \"SIMD vector cannot be empty\").emit();\n+                    return;\n+                } else if !len.is_power_of_two() {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        sp,\n+                        E0075,\n+                        \"SIMD vector length must be a power of two\"\n+                    )\n+                    .emit();\n+                    return;\n+                } else if len > MAX_SIMD_LANES {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        sp,\n+                        E0075,\n+                        \"SIMD vector cannot have more than {} elements\",\n+                        MAX_SIMD_LANES,\n+                    )\n+                    .emit();\n+                    return;\n+                }\n+            }\n+\n             match e.kind() {\n                 ty::Param(_) => { /* struct<T>(T, T, T, T) is ok */ }\n                 _ if e.is_machine() => { /* struct(u8, u8, u8, u8) is ok */ }"}, {"sha": "9e5cb0d4eb1f83156d9b10f98974661a4a7d20bd", "filename": "src/test/ui/consts/const-eval/simd/insert_extract.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fsimd%2Finsert_extract.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -8,7 +8,7 @@\n \n #[repr(simd)] struct i8x1(i8);\n #[repr(simd)] struct u16x2(u16, u16);\n-#[repr(simd)] struct f32x3(f32, f32, f32);\n+#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n \n extern \"platform-intrinsic\" {\n     #[rustc_const_stable(feature = \"foo\", since = \"1.3.37\")]\n@@ -39,19 +39,23 @@ fn main() {\n         assert_eq!(Y1, 42);\n     }\n     {\n-        const U: f32x3 = f32x3(13., 14., 15.);\n-        const V: f32x3 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n+        const U: f32x4 = f32x4(13., 14., 15., 16.);\n+        const V: f32x4 = unsafe { simd_insert(U, 1_u32, 42_f32) };\n         const X0: f32 = V.0;\n         const X1: f32 = V.1;\n         const X2: f32 = V.2;\n+        const X3: f32 = V.3;\n         const Y0: f32 = unsafe { simd_extract(V, 0) };\n         const Y1: f32 = unsafe { simd_extract(V, 1) };\n         const Y2: f32 = unsafe { simd_extract(V, 2) };\n+        const Y3: f32 = unsafe { simd_extract(V, 3) };\n         assert_eq!(X0, 13.);\n         assert_eq!(X1, 42.);\n         assert_eq!(X2, 15.);\n+        assert_eq!(X3, 16.);\n         assert_eq!(Y0, 13.);\n         assert_eq!(Y1, 42.);\n         assert_eq!(Y2, 15.);\n+        assert_eq!(Y3, 16.);\n     }\n }"}, {"sha": "493cd7a477c7a861686519145ecb0355b2a320fd", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -9,10 +9,6 @@ struct i32x2(i32, i32);\n #[repr(simd)]\n #[derive(Copy, Clone)]\n #[allow(non_camel_case_types)]\n-struct i32x3(i32, i32, i32);\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-#[allow(non_camel_case_types)]\n struct i32x4(i32, i32, i32, i32);\n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -27,10 +23,6 @@ struct f32x2(f32, f32);\n #[repr(simd)]\n #[derive(Copy, Clone)]\n #[allow(non_camel_case_types)]\n-struct f32x3(f32, f32, f32);\n-#[repr(simd)]\n-#[derive(Copy, Clone)]\n-#[allow(non_camel_case_types)]\n struct f32x4(f32, f32, f32, f32);\n #[repr(simd)]\n #[derive(Copy, Clone)]\n@@ -43,7 +35,6 @@ extern \"platform-intrinsic\" {\n     fn simd_extract<T, E>(x: T, idx: u32) -> E;\n \n     fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n-    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n     fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n     fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n }\n@@ -61,28 +52,22 @@ fn main() {\n \n         simd_shuffle2::<i32, i32>(0, 0, [0; 2]);\n         //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n-        simd_shuffle3::<i32, i32>(0, 0, [0; 3]);\n-        //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n         simd_shuffle4::<i32, i32>(0, 0, [0; 4]);\n         //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n         simd_shuffle8::<i32, i32>(0, 0, [0; 8]);\n         //~^ ERROR expected SIMD input type, found non-SIMD `i32`\n \n         simd_shuffle2::<_, f32x2>(x, x, [0; 2]);\n //~^ ERROR element type `i32` (element of input `i32x4`), found `f32x2` with element type `f32`\n-        simd_shuffle3::<_, f32x3>(x, x, [0; 3]);\n-//~^ ERROR element type `i32` (element of input `i32x4`), found `f32x3` with element type `f32`\n         simd_shuffle4::<_, f32x4>(x, x, [0; 4]);\n //~^ ERROR element type `i32` (element of input `i32x4`), found `f32x4` with element type `f32`\n         simd_shuffle8::<_, f32x8>(x, x, [0; 8]);\n //~^ ERROR element type `i32` (element of input `i32x4`), found `f32x8` with element type `f32`\n \n         simd_shuffle2::<_, i32x8>(x, x, [0; 2]);\n         //~^ ERROR expected return type of length 2, found `i32x8` with length 8\n-        simd_shuffle3::<_, i32x4>(x, x, [0; 3]);\n-        //~^ ERROR expected return type of length 3, found `i32x4` with length 4\n-        simd_shuffle4::<_, i32x3>(x, x, [0; 4]);\n-        //~^ ERROR expected return type of length 4, found `i32x3` with length 3\n+        simd_shuffle4::<_, i32x8>(x, x, [0; 4]);\n+        //~^ ERROR expected return type of length 4, found `i32x8` with length 8\n         simd_shuffle8::<_, i32x2>(x, x, [0; 8]);\n         //~^ ERROR expected return type of length 8, found `i32x2` with length 2\n     }"}, {"sha": "703e64d1ddcc83c31a952cc5203a263ca114cb86", "filename": "src/test/ui/simd-intrinsic/simd-intrinsic-generic-elements.stderr", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-intrinsic%2Fsimd-intrinsic-generic-elements.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -1,93 +1,75 @@\n error[E0511]: invalid monomorphization of `simd_insert` intrinsic: expected SIMD input type, found non-SIMD `i32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:55:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:46:9\n    |\n LL |         simd_insert(0, 0, 0);\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_insert` intrinsic: expected inserted type `i32` (element of input `i32x4`), found `f64`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:57:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:48:9\n    |\n LL |         simd_insert(x, 0, 1.0);\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_extract` intrinsic: expected return type `i32` (element of input `i32x4`), found `f32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:59:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:50:9\n    |\n LL |         simd_extract::<_, f32>(x, 0);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle2` intrinsic: expected SIMD input type, found non-SIMD `i32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:62:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:53:9\n    |\n LL |         simd_shuffle2::<i32, i32>(0, 0, [0; 2]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_shuffle3` intrinsic: expected SIMD input type, found non-SIMD `i32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:64:9\n-   |\n-LL |         simd_shuffle3::<i32, i32>(0, 0, [0; 3]);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0511]: invalid monomorphization of `simd_shuffle4` intrinsic: expected SIMD input type, found non-SIMD `i32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:66:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:55:9\n    |\n LL |         simd_shuffle4::<i32, i32>(0, 0, [0; 4]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle8` intrinsic: expected SIMD input type, found non-SIMD `i32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:68:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:57:9\n    |\n LL |         simd_shuffle8::<i32, i32>(0, 0, [0; 8]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle2` intrinsic: expected return element type `i32` (element of input `i32x4`), found `f32x2` with element type `f32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:71:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:60:9\n    |\n LL |         simd_shuffle2::<_, f32x2>(x, x, [0; 2]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_shuffle3` intrinsic: expected return element type `i32` (element of input `i32x4`), found `f32x3` with element type `f32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:73:9\n-   |\n-LL |         simd_shuffle3::<_, f32x3>(x, x, [0; 3]);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n error[E0511]: invalid monomorphization of `simd_shuffle4` intrinsic: expected return element type `i32` (element of input `i32x4`), found `f32x4` with element type `f32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:75:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:62:9\n    |\n LL |         simd_shuffle4::<_, f32x4>(x, x, [0; 4]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle8` intrinsic: expected return element type `i32` (element of input `i32x4`), found `f32x8` with element type `f32`\n-  --> $DIR/simd-intrinsic-generic-elements.rs:77:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:64:9\n    |\n LL |         simd_shuffle8::<_, f32x8>(x, x, [0; 8]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle2` intrinsic: expected return type of length 2, found `i32x8` with length 8\n-  --> $DIR/simd-intrinsic-generic-elements.rs:80:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:67:9\n    |\n LL |         simd_shuffle2::<_, i32x8>(x, x, [0; 2]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_shuffle3` intrinsic: expected return type of length 3, found `i32x4` with length 4\n-  --> $DIR/simd-intrinsic-generic-elements.rs:82:9\n+error[E0511]: invalid monomorphization of `simd_shuffle4` intrinsic: expected return type of length 4, found `i32x8` with length 8\n+  --> $DIR/simd-intrinsic-generic-elements.rs:69:9\n    |\n-LL |         simd_shuffle3::<_, i32x4>(x, x, [0; 3]);\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error[E0511]: invalid monomorphization of `simd_shuffle4` intrinsic: expected return type of length 4, found `i32x3` with length 3\n-  --> $DIR/simd-intrinsic-generic-elements.rs:84:9\n-   |\n-LL |         simd_shuffle4::<_, i32x3>(x, x, [0; 4]);\n+LL |         simd_shuffle4::<_, i32x8>(x, x, [0; 4]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0511]: invalid monomorphization of `simd_shuffle8` intrinsic: expected return type of length 8, found `i32x2` with length 2\n-  --> $DIR/simd-intrinsic-generic-elements.rs:86:9\n+  --> $DIR/simd-intrinsic-generic-elements.rs:71:9\n    |\n LL |         simd_shuffle8::<_, i32x2>(x, x, [0; 8]);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 15 previous errors\n+error: aborting due to 12 previous errors\n \n For more information about this error, try `rustc --explain E0511`."}, {"sha": "a320df85138e55c0ea3515fb57de6a30ceacfea1", "filename": "src/test/ui/simd-type.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9778068cbc1e06cc3685422323ff38a2f397de26/src%2Ftest%2Fui%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd-type.rs?ref=9778068cbc1e06cc3685422323ff38a2f397de26", "patch": "@@ -1,20 +0,0 @@\n-#![feature(repr_simd)]\n-#![allow(non_camel_case_types)]\n-\n-// ignore-tidy-linelength\n-\n-#[repr(simd)]\n-struct empty; //~ ERROR SIMD vector cannot be empty\n-\n-#[repr(simd)]\n-struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n-\n-struct Foo;\n-\n-#[repr(simd)]\n-struct FooV(Foo, Foo); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n-\n-#[repr(simd)]\n-struct FooV2([Foo; 2]); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n-\n-fn main() {}"}, {"sha": "49cfbab9a3e6fdd42411d0683085e4b60d7d4473", "filename": "src/test/ui/simd/issue-17170.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -1,8 +1,8 @@\n-// run-pass\n #![feature(repr_simd)]\n \n #[repr(simd)]\n struct T(f64, f64, f64);\n+//~^ ERROR SIMD vector length must be a power of two\n \n static X: T = T(0.0, 0.0, 0.0);\n ", "previous_filename": "src/test/ui/issues/issue-17170.rs"}, {"sha": "b35c3c4dc980d7ffcb076322f5b7b39f84b7f14b", "filename": "src/test/ui/simd/issue-17170.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fissue-17170.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,11 @@\n+error[E0075]: SIMD vector length must be a power of two\n+  --> $DIR/issue-17170.rs:4:1\n+   |\n+LL | struct T(f64, f64, f64);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: monomorphising SIMD type `T` of non-power-of-two length\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0075`."}, {"sha": "7d5969265121caa0cf8c6ff6b2086f9d0a8a7ce9", "filename": "src/test/ui/simd/issue-39720.rs", "status": "renamed", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -1,15 +1,16 @@\n-// run-pass\n // ignore-emscripten FIXME(#45351)\n \n #![feature(repr_simd, platform_intrinsics)]\n \n #[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n pub struct Char3(pub i8, pub i8, pub i8);\n+//~^ ERROR SIMD vector length must be a power of two\n \n #[repr(simd)]\n #[derive(Copy, Clone, Debug)]\n pub struct Short3(pub i16, pub i16, pub i16);\n+//~^ ERROR SIMD vector length must be a power of two\n \n extern \"platform-intrinsic\" {\n     fn simd_cast<T, U>(x: T) -> U;", "previous_filename": "src/test/ui/issues/issue-39720.rs"}, {"sha": "355ceff00508aa0d44e692d41314f5390216162e", "filename": "src/test/ui/simd/issue-39720.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fissue-39720.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,15 @@\n+error[E0075]: SIMD vector length must be a power of two\n+  --> $DIR/issue-39720.rs:7:1\n+   |\n+LL | pub struct Char3(pub i8, pub i8, pub i8);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0075]: SIMD vector length must be a power of two\n+  --> $DIR/issue-39720.rs:12:1\n+   |\n+LL | pub struct Short3(pub i16, pub i16, pub i16);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0075`."}, {"sha": "a85ec7c58235ba8554c7ab750a4def27c2f9dd4e", "filename": "src/test/ui/simd/simd-intrinsic-generic-elements.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-elements.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-elements.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-intrinsic-generic-elements.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -10,10 +10,6 @@ struct i32x2(i32, i32);\n #[repr(simd)]\n #[derive(Copy, Clone, Debug, PartialEq)]\n #[allow(non_camel_case_types)]\n-struct i32x3(i32, i32, i32);\n-#[repr(simd)]\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-#[allow(non_camel_case_types)]\n struct i32x4(i32, i32, i32, i32);\n #[repr(simd)]\n #[derive(Copy, Clone, Debug, PartialEq)]\n@@ -26,7 +22,6 @@ extern \"platform-intrinsic\" {\n     fn simd_extract<T, E>(x: T, idx: u32) -> E;\n \n     fn simd_shuffle2<T, U>(x: T, y: T, idx: [u32; 2]) -> U;\n-    fn simd_shuffle3<T, U>(x: T, y: T, idx: [u32; 3]) -> U;\n     fn simd_shuffle4<T, U>(x: T, y: T, idx: [u32; 4]) -> U;\n     fn simd_shuffle8<T, U>(x: T, y: T, idx: [u32; 8]) -> U;\n }\n@@ -45,17 +40,12 @@ macro_rules! all_eq {\n \n fn main() {\n     let x2 = i32x2(20, 21);\n-    let x3 = i32x3(30, 31, 32);\n     let x4 = i32x4(40, 41, 42, 43);\n     let x8 = i32x8(80, 81, 82, 83, 84, 85, 86, 87);\n     unsafe {\n         all_eq!(simd_insert(x2, 0, 100), i32x2(100, 21));\n         all_eq!(simd_insert(x2, 1, 100), i32x2(20, 100));\n \n-        all_eq!(simd_insert(x3, 0, 100), i32x3(100, 31, 32));\n-        all_eq!(simd_insert(x3, 1, 100), i32x3(30, 100, 32));\n-        all_eq!(simd_insert(x3, 2, 100), i32x3(30, 31, 100));\n-\n         all_eq!(simd_insert(x4, 0, 100), i32x4(100, 41, 42, 43));\n         all_eq!(simd_insert(x4, 1, 100), i32x4(40, 100, 42, 43));\n         all_eq!(simd_insert(x4, 2, 100), i32x4(40, 41, 100, 43));\n@@ -73,10 +63,6 @@ fn main() {\n         all_eq!(simd_extract(x2, 0), 20);\n         all_eq!(simd_extract(x2, 1), 21);\n \n-        all_eq!(simd_extract(x3, 0), 30);\n-        all_eq!(simd_extract(x3, 1), 31);\n-        all_eq!(simd_extract(x3, 2), 32);\n-\n         all_eq!(simd_extract(x4, 0), 40);\n         all_eq!(simd_extract(x4, 1), 41);\n         all_eq!(simd_extract(x4, 2), 42);\n@@ -93,30 +79,20 @@ fn main() {\n     }\n \n     let y2 = i32x2(120, 121);\n-    let y3 = i32x3(130, 131, 132);\n     let y4 = i32x4(140, 141, 142, 143);\n     let y8 = i32x8(180, 181, 182, 183, 184, 185, 186, 187);\n     unsafe {\n         all_eq!(simd_shuffle2(x2, y2, [3, 0]), i32x2(121, 20));\n-        all_eq!(simd_shuffle3(x2, y2, [3, 0, 1]), i32x3(121, 20, 21));\n         all_eq!(simd_shuffle4(x2, y2, [3, 0, 1, 2]), i32x4(121, 20, 21, 120));\n         all_eq!(simd_shuffle8(x2, y2, [3, 0, 1, 2, 1, 2, 3, 0]),\n                 i32x8(121, 20, 21, 120, 21, 120, 121, 20));\n \n-        all_eq!(simd_shuffle2(x3, y3, [4, 2]), i32x2(131, 32));\n-        all_eq!(simd_shuffle3(x3, y3, [4, 2, 3]), i32x3(131, 32, 130));\n-        all_eq!(simd_shuffle4(x3, y3, [4, 2, 3, 0]), i32x4(131, 32, 130, 30));\n-        all_eq!(simd_shuffle8(x3, y3, [4, 2, 3, 0, 1, 5, 5, 1]),\n-                i32x8(131, 32, 130, 30, 31, 132, 132, 31));\n-\n         all_eq!(simd_shuffle2(x4, y4, [7, 2]), i32x2(143, 42));\n-        all_eq!(simd_shuffle3(x4, y4, [7, 2, 5]), i32x3(143, 42, 141));\n         all_eq!(simd_shuffle4(x4, y4, [7, 2, 5, 0]), i32x4(143, 42, 141, 40));\n         all_eq!(simd_shuffle8(x4, y4, [7, 2, 5, 0, 3, 6, 4, 1]),\n                 i32x8(143, 42, 141, 40, 43, 142, 140, 41));\n \n         all_eq!(simd_shuffle2(x8, y8, [11, 5]), i32x2(183, 85));\n-        all_eq!(simd_shuffle3(x8, y8, [11, 5, 15]), i32x3(183, 85, 187));\n         all_eq!(simd_shuffle4(x8, y8, [11, 5, 15, 0]), i32x4(183, 85, 187, 80));\n         all_eq!(simd_shuffle8(x8, y8, [11, 5, 15, 0, 3, 8, 12, 1]),\n                 i32x8(183, 85, 187, 80, 83, 180, 184, 81));"}, {"sha": "0afa4947225d3b719a0b92bd3fcf6d9280fccf48", "filename": "src/test/ui/simd/simd-size-align.rs", "status": "modified", "additions": 30, "deletions": 73, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-size-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-size-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-size-align.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -10,87 +10,44 @@ use std::mem;\n /// `T` should satisfy `size_of T (mod min_align_of T) === 0` to be stored at `Vec<T>` properly\n /// Please consult the issue #20460\n fn check<T>() {\n-    assert_eq!(mem::size_of::<T>() % mem::min_align_of::<T>(), 0)\n+    assert_eq!(mem::size_of::<T>() % mem::min_align_of::<T>(), 0);\n+    assert_eq!(mem::size_of::<T>() % mem::min_align_of::<T>(), 0);\n+    assert_eq!(mem::size_of::<T>() % mem::min_align_of::<T>(), 0);\n }\n \n-fn main() {\n-    check::<u8x2>();\n-    check::<u8x3>();\n-    check::<u8x4>();\n-    check::<u8x5>();\n-    check::<u8x6>();\n-    check::<u8x7>();\n-    check::<u8x8>();\n+#[repr(simd)]\n+struct U8<const N: usize>([u8; N]);\n \n-    check::<i16x2>();\n-    check::<i16x3>();\n-    check::<i16x4>();\n-    check::<i16x5>();\n-    check::<i16x6>();\n-    check::<i16x7>();\n-    check::<i16x8>();\n+#[repr(simd)]\n+struct I16<const N: usize>([i16; N]);\n \n-    check::<f32x2>();\n-    check::<f32x3>();\n-    check::<f32x4>();\n-    check::<f32x5>();\n-    check::<f32x6>();\n-    check::<f32x7>();\n-    check::<f32x8>();\n+#[repr(simd)]\n+struct F32<const N: usize>([f32; N]);\n \n-    check::<usizex2>();\n-    check::<usizex3>();\n-    check::<usizex4>();\n-    check::<usizex5>();\n-    check::<usizex6>();\n-    check::<usizex7>();\n-    check::<usizex8>();\n+#[repr(simd)]\n+struct Usize<const N: usize>([usize; N]);\n \n-    check::<isizex2>();\n-    check::<isizex3>();\n-    check::<isizex4>();\n-    check::<isizex5>();\n-    check::<isizex6>();\n-    check::<isizex7>();\n-    check::<isizex8>();\n-}\n+#[repr(simd)]\n+struct Isize<const N: usize>([isize; N]);\n \n-#[repr(simd)] struct u8x2(u8, u8);\n-#[repr(simd)] struct u8x3(u8, u8, u8);\n-#[repr(simd)] struct u8x4(u8, u8, u8, u8);\n-#[repr(simd)] struct u8x5(u8, u8, u8, u8, u8);\n-#[repr(simd)] struct u8x6(u8, u8, u8, u8, u8, u8);\n-#[repr(simd)] struct u8x7(u8, u8, u8, u8, u8, u8, u8);\n-#[repr(simd)] struct u8x8(u8, u8, u8, u8, u8, u8, u8, u8);\n+fn main() {\n+    check::<U8<2>>();\n+    check::<U8<4>>();\n+    check::<U8<8>>();\n \n-#[repr(simd)] struct i16x2(i16, i16);\n-#[repr(simd)] struct i16x3(i16, i16, i16);\n-#[repr(simd)] struct i16x4(i16, i16, i16, i16);\n-#[repr(simd)] struct i16x5(i16, i16, i16, i16, i16);\n-#[repr(simd)] struct i16x6(i16, i16, i16, i16, i16, i16);\n-#[repr(simd)] struct i16x7(i16, i16, i16, i16, i16, i16, i16);\n-#[repr(simd)] struct i16x8(i16, i16, i16, i16, i16, i16, i16, i16);\n+    check::<I16<2>>();\n+    check::<I16<4>>();\n+    check::<I16<8>>();\n \n-#[repr(simd)] struct f32x2(f32, f32);\n-#[repr(simd)] struct f32x3(f32, f32, f32);\n-#[repr(simd)] struct f32x4(f32, f32, f32, f32);\n-#[repr(simd)] struct f32x5(f32, f32, f32, f32, f32);\n-#[repr(simd)] struct f32x6(f32, f32, f32, f32, f32, f32);\n-#[repr(simd)] struct f32x7(f32, f32, f32, f32, f32, f32, f32);\n-#[repr(simd)] struct f32x8(f32, f32, f32, f32, f32, f32, f32, f32);\n+    check::<F32<2>>();\n+    check::<F32<4>>();\n+    check::<F32<8>>();\n \n-#[repr(simd)] struct usizex2(usize, usize);\n-#[repr(simd)] struct usizex3(usize, usize, usize);\n-#[repr(simd)] struct usizex4(usize, usize, usize, usize);\n-#[repr(simd)] struct usizex5(usize, usize, usize, usize, usize);\n-#[repr(simd)] struct usizex6(usize, usize, usize, usize, usize, usize);\n-#[repr(simd)] struct usizex7(usize, usize, usize, usize, usize, usize, usize);\n-#[repr(simd)] struct usizex8(usize, usize, usize, usize, usize, usize, usize, usize);\n+    check::<Usize<2>>();\n+    check::<Usize<4>>();\n+    check::<Usize<8>>();\n \n-#[repr(simd)] struct isizex2(isize, isize);\n-#[repr(simd)] struct isizex3(isize, isize, isize);\n-#[repr(simd)] struct isizex4(isize, isize, isize, isize);\n-#[repr(simd)] struct isizex5(isize, isize, isize, isize, isize);\n-#[repr(simd)] struct isizex6(isize, isize, isize, isize, isize, isize);\n-#[repr(simd)] struct isizex7(isize, isize, isize, isize, isize, isize, isize);\n-#[repr(simd)] struct isizex8(isize, isize, isize, isize, isize, isize, isize, isize);\n+    check::<Isize<2>>();\n+    check::<Isize<4>>();\n+    check::<Isize<8>>();\n+}"}, {"sha": "0121404c749355ffe680f9760987163903521596", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-empty.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,12 @@\n+// build-fail\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+// error-pattern:monomorphising SIMD type `Simd<0_usize>` of zero length\n+\n+#[repr(simd)]\n+struct Simd<const N: usize>([f32; N]);\n+\n+fn main() {\n+    let _ = Simd::<0>([]);\n+}"}, {"sha": "00fde199b12a27ea6a6bca710d20f374ecd42542", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-empty.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-empty.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,4 @@\n+error: monomorphising SIMD type `Simd<0_usize>` of zero length\n+\n+error: aborting due to previous error\n+"}, {"sha": "bd0d457b35e2763ef03dbdc5bf089f57979d7551", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-oversized.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,12 @@\n+// build-fail\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+// error-pattern:monomorphising SIMD type `Simd<65536_usize>` of length greater than 32768\n+\n+#[repr(simd)]\n+struct Simd<const N: usize>([f32; N]);\n+\n+fn main() {\n+    let _ = Simd::<65536>([0.; 65536]);\n+}"}, {"sha": "f4418350115321c9e8be87b778251e4ed363ef6a", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-oversized.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-oversized.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,4 @@\n+error: monomorphising SIMD type `Simd<65536_usize>` of length greater than 32768\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a0b9e02663d81b64882dc84470ab05bcc75df6b", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-power-of-two.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,12 @@\n+// build-fail\n+\n+#![feature(repr_simd, platform_intrinsics)]\n+\n+// error-pattern:monomorphising SIMD type `Simd<3_usize>` of non-power-of-two length\n+\n+#[repr(simd)]\n+struct Simd<const N: usize>([f32; N]);\n+\n+fn main() {\n+    let _ = Simd::<3>([0.; 3]);\n+}"}, {"sha": "82cc0d8714aba77a2de487f1241506d6b62946b7", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation-power-of-two.stderr", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation-power-of-two.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -0,0 +1,4 @@\n+error: monomorphising SIMD type `Simd<3_usize>` of non-power-of-two length\n+\n+error: aborting due to previous error\n+"}, {"sha": "0275f0ce4c159042c74dc2795c059d623ada90ec", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "previous_filename": "src/test/ui/simd-type-generic-monomorphisation.rs"}, {"sha": "7f23893ac853645391cc109cb1ce71822c297c65", "filename": "src/test/ui/simd/simd-type-generic-monomorphisation.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type-generic-monomorphisation.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "previous_filename": "src/test/ui/simd-type-generic-monomorphisation.stderr"}, {"sha": "cc7443d04856cba2acb4397449b684b823cae9d9", "filename": "src/test/ui/simd/simd-type.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.rs?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -1,9 +1,33 @@\n-// run-pass\n-#![allow(dead_code)]\n+#![feature(repr_simd)]\n+#![allow(non_camel_case_types)]\n \n-// pretty-expanded FIXME #23616\n+// ignore-tidy-linelength\n \n-#![feature(repr_simd)]\n+#[repr(simd)]\n+struct empty; //~ ERROR SIMD vector cannot be empty\n+\n+#[repr(simd)]\n+struct empty2([f32; 0]); //~ ERROR SIMD vector cannot be empty\n+\n+#[repr(simd)]\n+struct pow2([f32; 7]); //~ ERROR SIMD vector length must be a power of two\n+\n+#[repr(simd)]\n+struct i64f64(i64, f64); //~ ERROR SIMD vector should be homogeneous\n+\n+struct Foo;\n+\n+#[repr(simd)]\n+struct FooV(Foo, Foo); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+\n+#[repr(simd)]\n+struct FooV2([Foo; 2]); //~ ERROR SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n+\n+#[repr(simd)]\n+struct TooBig([f32; 65536]); //~ ERROR SIMD vector cannot have more than 32768 elements\n+\n+#[repr(simd)]\n+struct JustRight([u128; 32768]);\n \n #[repr(simd)]\n struct RGBA {\n@@ -13,4 +37,4 @@ struct RGBA {\n     a: f32\n }\n \n-pub fn main() {}\n+fn main() {}"}, {"sha": "8b15ef05e032b4f461e81d0f0e1d89f7ea583ce4", "filename": "src/test/ui/simd/simd-type.stderr", "status": "renamed", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bb587b1a1737738658d2eaecd4c8c1cab555257a/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fsimd-type.stderr?ref=bb587b1a1737738658d2eaecd4c8c1cab555257a", "patch": "@@ -4,25 +4,43 @@ error[E0075]: SIMD vector cannot be empty\n LL | struct empty;\n    | ^^^^^^^^^^^^^\n \n-error[E0076]: SIMD vector should be homogeneous\n+error[E0075]: SIMD vector cannot be empty\n   --> $DIR/simd-type.rs:10:1\n    |\n+LL | struct empty2([f32; 0]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0075]: SIMD vector length must be a power of two\n+  --> $DIR/simd-type.rs:13:1\n+   |\n+LL | struct pow2([f32; 7]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error[E0076]: SIMD vector should be homogeneous\n+  --> $DIR/simd-type.rs:16:1\n+   |\n LL | struct i64f64(i64, f64);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ SIMD elements must have the same type\n \n error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n-  --> $DIR/simd-type.rs:15:1\n+  --> $DIR/simd-type.rs:21:1\n    |\n LL | struct FooV(Foo, Foo);\n    | ^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0077]: SIMD vector element type should be a primitive scalar (integer/float/pointer) type\n-  --> $DIR/simd-type.rs:18:1\n+  --> $DIR/simd-type.rs:24:1\n    |\n LL | struct FooV2([Foo; 2]);\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 4 previous errors\n+error[E0075]: SIMD vector cannot have more than 32768 elements\n+  --> $DIR/simd-type.rs:27:1\n+   |\n+LL | struct TooBig([f32; 65536]);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0075, E0076, E0077.\n For more information about an error, try `rustc --explain E0075`.", "previous_filename": "src/test/ui/simd-type.stderr"}]}