{"sha": "ef70b7666e4846f02cd37eed26999b71d0c21326", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzBiNzY2NmU0ODQ2ZjAyY2QzN2VlZDI2OTk5YjcxZDBjMjEzMjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T12:56:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-26T12:56:49Z"}, "message": "auto merge of #10668 : vky/rust/closure-doc-update, r=alexcrichton", "tree": {"sha": "3065809f102d64be7159081b5c416b35dbbeb3ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3065809f102d64be7159081b5c416b35dbbeb3ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef70b7666e4846f02cd37eed26999b71d0c21326", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef70b7666e4846f02cd37eed26999b71d0c21326", "html_url": "https://github.com/rust-lang/rust/commit/ef70b7666e4846f02cd37eed26999b71d0c21326", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef70b7666e4846f02cd37eed26999b71d0c21326/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa", "html_url": "https://github.com/rust-lang/rust/commit/4fe129651167e4ba1a16d6ee93bc0ca38c7cf7fa"}, {"sha": "9c6bba91a899e5296b81dbf910fdb2dc0821ed25", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6bba91a899e5296b81dbf910fdb2dc0821ed25", "html_url": "https://github.com/rust-lang/rust/commit/9c6bba91a899e5296b81dbf910fdb2dc0821ed25"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "24f07337df9ffde26cc7b9f6aa07700c79d0fc8c", "filename": "doc/po/ja/rust.md.po", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Fja%2Frust.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Fja%2Frust.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Frust.md.po?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -1817,10 +1817,10 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n-\"fn iter<T>(seq: &[T], f: &fn(T)) {\\n\"\n+\"fn iter<T>(seq: &[T], f: |T|) {\\n\"\n \"    for elt in seq.iter() { f(elt); }\\n\"\n \"}\\n\"\n-\"fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\\n\"\n+\"fn map<T, U>(seq: &[T], f: |T| -> U) -> ~[U] {\\n\"\n \"    let mut acc = ~[];\\n\"\n \"    for elt in seq.iter() { acc.push(f(elt)); }\\n\"\n \"    acc\\n\"\n@@ -2404,7 +2404,7 @@ msgid \"\"\n \"trait Seq<T> {\\n\"\n \"   fn len(&self) -> uint;\\n\"\n \"   fn elt_at(&self, n: uint) -> T;\\n\"\n-\"   fn iter(&self, &fn(T));\\n\"\n+\"   fn iter(&self, |T|);\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n@@ -4243,7 +4243,7 @@ msgid \"\"\n \"[function definitions](#functions) do not.  The exact type of capture \"\n \"depends on the [function type](#function-types) inferred for the lambda \"\n \"expression.  In the simplest and least-expensive form (analogous to a \"\n-\"```&fn() { }``` expression), the lambda expression captures its environment \"\n+\"```|| { }``` expression), the lambda expression captures its environment \"\n \"by reference, effectively borrowing pointers to all outer variables \"\n \"mentioned inside the function.  Alternately, the compiler may infer that a \"\n \"lambda expression should copy or move values (depending on their type.)  \"\n@@ -4262,7 +4262,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn ten_times(f: &fn(int)) {\\n\"\n+\"fn ten_times(f: |int|) {\\n\"\n \"    let mut i = 0;\\n\"\n \"    while i < 10 {\\n\"\n \"        f(i);\\n\"\n@@ -4455,7 +4455,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/rust.md:2339\n-msgid \"~~~~ # fn f(f: &fn(int)) { } # fn g(i: int) { }\"\n+msgid \"~~~~ # fn f(f: |int|) { } # fn g(i: int) { }\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -4481,7 +4481,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/rust.md:2352\n-msgid \"~~~~ # fn k(x:int, f: &fn(int)) { } # fn l(i: int) { }\"\n+msgid \"~~~~ # fn k(x:int, f: |int|) { } # fn l(i: int) { }\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -5483,7 +5483,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~~~~\\n\"\n-\"fn map<A: Clone, B: Clone>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\\n\"\n+\"fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\\n\"\n \"    if xs.len() == 0 {\\n\"\n \"       return ~[];\\n\"\n \"    }\\n\""}, {"sha": "1d3fc494efac042d07c5ba2232d1c8ad2d1babfd", "filename": "doc/po/ja/tutorial.md.po", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Fja%2Ftutorial.md.po", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Fja%2Ftutorial.md.po", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Fja%2Ftutorial.md.po?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -3340,10 +3340,10 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial.md:1434\n-msgid \"~~~~ fn call_closure_with_ten(b: &fn(int)) { b(10); }\"\n+msgid \"~~~~ fn call_closure_with_ten(b: |int|) { b(10); }\"\n msgstr \"\"\n \"~~~~\\n\"\n-\"fn call_closure_with_ten(b: &fn(int)) { b(10); }\"\n+\"fn call_closure_with_ten(b: |int|) { b(10); }\"\n \n #. type: Plain text\n #: doc/tutorial.md:1437\n@@ -3400,11 +3400,11 @@ msgstr \"\"\n #: doc/tutorial.md:1459\n msgid \"\"\n \"There are several forms of closure, each with its own role. The most common, \"\n-\"called a _stack closure_, has type `&fn` and can directly access local \"\n+\"called a _stack closure_, has type `||` and can directly access local \"\n \"variables in the enclosing scope.\"\n msgstr \"\"\n \"\u30af\u30ed\u30fc\u30b8\u30e3\u306b\u306f\u3044\u304f\u3064\u304b\u306e\u5f62\u614b\u304c\u3042\u308a\u3001\u305d\u308c\u305e\u308c\u306b\u72ec\u81ea\u306e\u5f79\u5272\u304c\u3042\u308a\u307e\u3059\u3002\u6700\u3082\u4e00\u822c\"\n-\"\u7684\u306a\u306e\u306f\u30b9\u30bf\u30c3\u30af\u30af\u30ed\u30fc\u30b8\u30e3\u3068\u547c\u3070\u308c\u308b\u3082\u306e\u3067\u3001 `&fn` \u3068\u3044\u3046\u578b\u3092\u6301\u3061\u3001\u5916\u5074\u306e\u30ed\u30fc\"\n+\"\u7684\u306a\u306e\u306f\u30b9\u30bf\u30c3\u30af\u30af\u30ed\u30fc\u30b8\u30e3\u3068\u547c\u3070\u308c\u308b\u3082\u306e\u3067\u3001 `||` \u3068\u3044\u3046\u578b\u3092\u6301\u3061\u3001\u5916\u5074\u306e\u30ed\u30fc\"\n \"\u30ab\u30eb\u5909\u6570\u306b\u76f4\u63a5\u30a2\u30af\u30bb\u30b9\u3059\u308b\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\"\n \n #. type: Plain text\n@@ -3531,27 +3531,27 @@ msgstr \"## \u30af\u30ed\u30fc\u30b8\u30e3\u306e\u4e92\u63db\u6027\"\n msgid \"\"\n \"Rust closures have a convenient subtyping property: you can pass any kind of \"\n \"closure (as long as the arguments and return types match) to functions that \"\n-\"expect a `&fn()`. Thus, when writing a higher-order function that only calls \"\n+\"expect a `||`. Thus, when writing a higher-order function that only calls \"\n \"its function argument, and does nothing else with it, you should almost \"\n-\"always declare the type of that argument as `&fn()`. That way, callers may \"\n+\"always declare the type of that argument as `||`. That way, callers may \"\n \"pass any kind of closure.\"\n msgstr \"\"\n \"Rust \u306e\u30af\u30ed\u30fc\u30b8\u30e3\u306f\u578b\u306e\u6d3e\u751f (subtyping) \u3068\u3044\u3046\u4fbf\u5229\u306a\u6027\u8cea\u3092\u6301\u3063\u3066\u3044\u307e\u3059\u3002\u3053\u306e\"\n-\"\u6027\u8cea\u306b\u3088\u308a\u3001`&fn()` \u578b\u3092\u671f\u5f85\u3059\u308b\u95a2\u6570\u306b\u306f (\u5f15\u6570\u3068\u623b\u308a\u5024\u306e\u578b\u304c\u4e00\u81f4\u3059\u308b\u9650\u308a) \u4efb\"\n+\"\u6027\u8cea\u306b\u3088\u308a\u3001`||` \u578b\u3092\u671f\u5f85\u3059\u308b\u95a2\u6570\u306b\u306f (\u5f15\u6570\u3068\u623b\u308a\u5024\u306e\u578b\u304c\u4e00\u81f4\u3059\u308b\u9650\u308a) \u4efb\"\n \"\u610f\u306e\u7a2e\u985e\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u307e\u3059\u3002\u3057\u305f\u304c\u3063\u3066\u3001\u5f15\u6570\u3067\u6e21\u3055\u308c\u305f\u95a2\u6570\u306b\u3064\"\n \"\u3044\u3066\u306f\u547c\u3073\u51fa\u3059\u3060\u3051\u3067\u4ed6\u306b\u4f55\u3082\u3057\u306a\u3044\u9ad8\u968e\u95a2\u6570\u3092\u66f8\u304f\u3068\u304d\u306b\u306f\u3001\u307b\u307c\u3059\u3079\u3066\u306e\u30b1\u30fc\u30b9\"\n-\"\u3067\u5f15\u6570\u306e\u578b\u3092 `&fn` \u3068\u5ba3\u8a00\u3059\u308b\u3079\u304d\u3067\u3059\u3002\u305d\u3046\u3059\u308b\u3053\u3068\u3067\u3001\u547c\u3073\u51fa\u3057\u5143\u306f\u4efb\u610f\u306e\u7a2e\u985e\"\n+\"\u3067\u5f15\u6570\u306e\u578b\u3092 `||` \u3068\u5ba3\u8a00\u3059\u308b\u3079\u304d\u3067\u3059\u3002\u305d\u3046\u3059\u308b\u3053\u3068\u3067\u3001\u547c\u3073\u51fa\u3057\u5143\u306f\u4efb\u610f\u306e\u7a2e\u985e\"\n \"\u306e\u30af\u30ed\u30fc\u30b8\u30e3\u3092\u6e21\u3059\u3053\u3068\u304c\u3067\u304d\u308b\u3088\u306b\u306a\u308a\u307e\u3059\u3002\"\n \n #. type: Plain text\n #: doc/tutorial.md:1527\n msgid \"\"\n-\"~~~~ fn call_twice(f: &fn()) { f(); f(); } let closure = || { \\\"I'm a \"\n+\"~~~~ fn call_twice(f: ||) { f(); f(); } let closure = || { \\\"I'm a \"\n \"closure, and it doesn't matter what type I am\\\"; }; fn function() { \\\"I'm a \"\n \"normal function\\\"; } call_twice(closure); call_twice(function); ~~~~\"\n msgstr \"\"\n \"~~~~\\n\"\n-\"fn call_twice(f: &fn()) { f(); f(); }\\n\"\n+\"fn call_twice(f: ||) { f(); f(); }\\n\"\n \"let closure = || { \\\"I'm a closure, and it doesn't matter what type I am\"\n \"\\\"; };\\n\"\n \"fn function() { \\\"I'm a normal function\\\"; }\\n\"\n@@ -3598,7 +3598,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn each(v: &[int], op: &fn(v: &int)) {\\n\"\n+\"fn each(v: &[int], op: |v: &int|) {\\n\"\n \"   let mut n = 0;\\n\"\n \"   while n < v.len() {\\n\"\n \"       op(&v[n]);\\n\"\n@@ -3622,7 +3622,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"# fn each(v: &[int], op: &fn(v: &int)) { }\\n\"\n+\"# fn each(v: &[int], op: |v: &int|) { }\\n\"\n \"# fn do_some_work(i: &int) { }\\n\"\n \"each([1, 2, 3], |n| {\\n\"\n \"    do_some_work(n);\\n\"\n@@ -3644,7 +3644,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"# fn each(v: &[int], op: &fn(v: &int)) { }\\n\"\n+\"# fn each(v: &[int], op: |v: &int|) { }\\n\"\n \"# fn do_some_work(i: &int) { }\\n\"\n \"do each([1, 2, 3]) |n| {\\n\"\n \"    do_some_work(n);\\n\"\n@@ -4011,7 +4011,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\\n\"\n+\"fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\\n\"\n \"    let mut accumulator = ~[];\\n\"\n \"    for element in vector.iter() {\\n\"\n \"        accumulator.push(function(element));\\n\""}, {"sha": "80116dad4d33c0e737ccbd9c6c8aab948ffe014f", "filename": "doc/po/rust.md.pot", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Frust.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Frust.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Frust.md.pot?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -1817,10 +1817,10 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~ {.xfail-test}\\n\"\n-\"fn iter<T>(seq: &[T], f: &fn(T)) {\\n\"\n+\"fn iter<T>(seq: &[T], f: |T|) {\\n\"\n \"    for elt in seq.iter() { f(elt); }\\n\"\n \"}\\n\"\n-\"fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\\n\"\n+\"fn map<T, U>(seq: &[T], f: |T| -> U) -> ~[U] {\\n\"\n \"    let mut acc = ~[];\\n\"\n \"    for elt in seq.iter() { acc.push(f(elt)); }\\n\"\n \"    acc\\n\"\n@@ -2404,7 +2404,7 @@ msgid \"\"\n \"trait Seq<T> {\\n\"\n \"   fn len(&self) -> uint;\\n\"\n \"   fn elt_at(&self, n: uint) -> T;\\n\"\n-\"   fn iter(&self, &fn(T));\\n\"\n+\"   fn iter(&self, |T|);\\n\"\n \"}\\n\"\n \"~~~~\\n\"\n msgstr \"\"\n@@ -4230,7 +4230,7 @@ msgid \"\"\n \"[function definitions](#functions) do not.  The exact type of capture \"\n \"depends on the [function type](#function-types) inferred for the lambda \"\n \"expression.  In the simplest and least-expensive form (analogous to a \"\n-\"```&fn() { }``` expression), the lambda expression captures its environment \"\n+\"```|| { }``` expression), the lambda expression captures its environment \"\n \"by reference, effectively borrowing pointers to all outer variables \"\n \"mentioned inside the function.  Alternately, the compiler may infer that a \"\n \"lambda expression should copy or move values (depending on their type.)  \"\n@@ -4249,7 +4249,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn ten_times(f: &fn(int)) {\\n\"\n+\"fn ten_times(f: |int|) {\\n\"\n \"    let mut i = 0;\\n\"\n \"    while i < 10 {\\n\"\n \"        f(i);\\n\"\n@@ -4442,7 +4442,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/rust.md:2339\n-msgid \"~~~~ # fn f(f: &fn(int)) { } # fn g(i: int) { }\"\n+msgid \"~~~~ # fn f(f: |int|) { } # fn g(i: int) { }\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -4468,7 +4468,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/rust.md:2352\n-msgid \"~~~~ # fn k(x:int, f: &fn(int)) { } # fn l(i: int) { }\"\n+msgid \"~~~~ # fn k(x:int, f: |int|) { } # fn l(i: int) { }\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -5470,7 +5470,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~~~~\\n\"\n-\"fn map<A: Clone, B: Clone>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\\n\"\n+\"fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\\n\"\n \"    if xs.len() == 0 {\\n\"\n \"       return ~[];\\n\"\n \"    }\\n\""}, {"sha": "4573c0904c85dace3abb1e1d0af8f4ad2bea8e39", "filename": "doc/po/tutorial.md.pot", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Ftutorial.md.pot", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Fpo%2Ftutorial.md.pot", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fpo%2Ftutorial.md.pot?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -2558,7 +2558,7 @@ msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial.md:1434\n-msgid \"~~~~ fn call_closure_with_ten(b: &fn(int)) { b(10); }\"\n+msgid \"~~~~ fn call_closure_with_ten(b: |int|) { b(10); }\"\n msgstr \"\"\n \n #. type: Plain text\n@@ -2601,7 +2601,7 @@ msgstr \"\"\n #: doc/tutorial.md:1459\n msgid \"\"\n \"There are several forms of closure, each with its own role. The most common, \"\n-\"called a _stack closure_, has type `&fn` and can directly access local \"\n+\"called a _stack closure_, has type `||` and can directly access local \"\n \"variables in the enclosing scope.\"\n msgstr \"\"\n \n@@ -2700,16 +2700,16 @@ msgstr \"\"\n msgid \"\"\n \"Rust closures have a convenient subtyping property: you can pass any kind of \"\n \"closure (as long as the arguments and return types match) to functions that \"\n-\"expect a `&fn()`. Thus, when writing a higher-order function that only calls \"\n+\"expect a `||`. Thus, when writing a higher-order function that only calls \"\n \"its function argument, and does nothing else with it, you should almost \"\n-\"always declare the type of that argument as `&fn()`. That way, callers may \"\n+\"always declare the type of that argument as `||`. That way, callers may \"\n \"pass any kind of closure.\"\n msgstr \"\"\n \n #. type: Plain text\n #: doc/tutorial.md:1527\n msgid \"\"\n-\"~~~~ fn call_twice(f: &fn()) { f(); f(); } let closure = || { \\\"I'm a \"\n+\"~~~~ fn call_twice(f: ||) { f(); f(); } let closure = || { \\\"I'm a \"\n \"closure, and it doesn't matter what type I am\\\"; }; fn function() { \\\"I'm a \"\n \"normal function\\\"; } call_twice(closure); call_twice(function); ~~~~\"\n msgstr \"\"\n@@ -2746,7 +2746,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn each(v: &[int], op: &fn(v: &int)) {\\n\"\n+\"fn each(v: &[int], op: |v: &int|) {\\n\"\n \"   let mut n = 0;\\n\"\n \"   while n < v.len() {\\n\"\n \"       op(&v[n]);\\n\"\n@@ -2768,7 +2768,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"# fn each(v: &[int], op: &fn(v: &int)) { }\\n\"\n+\"# fn each(v: &[int], op: |v: &int|) { }\\n\"\n \"# fn do_some_work(i: &int) { }\\n\"\n \"each([1, 2, 3], |n| {\\n\"\n \"    do_some_work(n);\\n\"\n@@ -2788,7 +2788,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"# fn each(v: &[int], op: &fn(v: &int)) { }\\n\"\n+\"# fn each(v: &[int], op: |v: &int|) { }\\n\"\n \"# fn do_some_work(i: &int) { }\\n\"\n \"do each([1, 2, 3]) |n| {\\n\"\n \"    do_some_work(n);\\n\"\n@@ -3080,7 +3080,7 @@ msgstr \"\"\n #, no-wrap\n msgid \"\"\n \"~~~~\\n\"\n-\"fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\\n\"\n+\"fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\\n\"\n \"    let mut accumulator = ~[];\\n\"\n \"    for element in vector.iter() {\\n\"\n \"        accumulator.push(function(element));\\n\""}, {"sha": "fe8d0a834e3e416d1d652a9f689617aad173a8ce", "filename": "doc/rust.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -950,10 +950,10 @@ declared, in an angle-bracket-enclosed, comma-separated list following\n the function name.\n \n ~~~~ {.xfail-test}\n-fn iter<T>(seq: &[T], f: &fn(T)) {\n+fn iter<T>(seq: &[T], f: |T|) {\n     for elt in seq.iter() { f(elt); }\n }\n-fn map<T, U>(seq: &[T], f: &fn(T) -> U) -> ~[U] {\n+fn map<T, U>(seq: &[T], f: |T| -> U) -> ~[U] {\n     let mut acc = ~[];\n     for elt in seq.iter() { acc.push(f(elt)); }\n     acc\n@@ -1314,7 +1314,7 @@ These appear after the trait name, using the same syntax used in [generic functi\n trait Seq<T> {\n    fn len(&self) -> uint;\n    fn elt_at(&self, n: uint) -> T;\n-   fn iter(&self, &fn(T));\n+   fn iter(&self, |T|);\n }\n ~~~~\n \n@@ -2607,7 +2607,7 @@ as an abbreviation for defining and capturing a separate function.\n Significantly, lambda expressions _capture their environment_,\n which regular [function definitions](#functions) do not.\n The exact type of capture depends on the [function type](#function-types) inferred for the lambda expression.\n-In the simplest and least-expensive form (analogous to a ```&fn() { }``` expression),\n+In the simplest and least-expensive form (analogous to a ```|| { }``` expression),\n the lambda expression captures its environment by reference,\n effectively borrowing pointers to all outer variables mentioned inside the function.\n Alternately, the compiler may infer that a lambda expression should copy or move values (depending on their type.)\n@@ -2617,7 +2617,7 @@ In this example, we define a function `ten_times` that takes a higher-order func\n and call it with a lambda expression as an argument.\n \n ~~~~\n-fn ten_times(f: &fn(int)) {\n+fn ten_times(f: |int|) {\n     let mut i = 0;\n     while i < 10 {\n         f(i);\n@@ -2726,7 +2726,7 @@ If the `expr` is a [field expression](#field-expressions), it is parsed as thoug\n In this example, both calls to `f` are equivalent:\n \n ~~~~\n-# fn f(f: &fn(int)) { }\n+# fn f(f: |int|) { }\n # fn g(i: int) { }\n \n f(|j| g(j));\n@@ -2739,7 +2739,7 @@ do f |j| {\n In this example, both calls to the (binary) function `k` are equivalent:\n \n ~~~~\n-# fn k(x:int, f: &fn(int)) { }\n+# fn k(x:int, f: |int|) { }\n # fn l(i: int) { }\n \n k(3, |j| l(j));\n@@ -3241,7 +3241,7 @@ and the cast expression in `main`.\n Within the body of an item that has type parameter declarations, the names of its type parameters are types:\n \n ~~~~\n-fn map<A: Clone, B: Clone>(f: &fn(A) -> B, xs: &[A]) -> ~[B] {\n+fn map<A: Clone, B: Clone>(f: |A| -> B, xs: &[A]) -> ~[B] {\n     if xs.len() == 0 {\n        return ~[];\n     }"}, {"sha": "4e6fd9e18d257d70a3f1754248a8f7ccc80dd719", "filename": "doc/tutorial.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/ef70b7666e4846f02cd37eed26999b71d0c21326/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=ef70b7666e4846f02cd37eed26999b71d0c21326", "patch": "@@ -1366,7 +1366,7 @@ Rust also supports _closures_, functions that can access variables in\n the enclosing scope.\n \n ~~~~\n-fn call_closure_with_ten(b: &fn(int)) { b(10); }\n+fn call_closure_with_ten(b: |int|) { b(10); }\n \n let captured_var = 20;\n let closure = |arg| println!(\"captured_var={}, arg={}\", captured_var, arg);\n@@ -1390,7 +1390,7 @@ let square = |x: int| -> uint { (x * x) as uint };\n ~~~~\n \n There are several forms of closure, each with its own role. The most\n-common, called a _stack closure_, has type `&fn` and can directly\n+common, called a _stack closure_, has type `||` and can directly\n access local variables in the enclosing scope.\n \n ~~~~\n@@ -1420,13 +1420,13 @@ for spawning [tasks][tasks].\n \n Rust closures have a convenient subtyping property: you can pass any kind of\n closure (as long as the arguments and return types match) to functions\n-that expect a `&fn()`. Thus, when writing a higher-order function that\n+that expect a `||`. Thus, when writing a higher-order function that\n only calls its function argument, and does nothing else with it, you\n-should almost always declare the type of that argument as `&fn()`. That way,\n+should almost always declare the type of that argument as `||`. That way,\n callers may pass any kind of closure.\n \n ~~~~\n-fn call_twice(f: &fn()) { f(); f(); }\n+fn call_twice(f: ||) { f(); f(); }\n let closure = || { \"I'm a closure, and it doesn't matter what type I am\"; };\n fn function() { \"I'm a normal function\"; }\n call_twice(closure);\n@@ -1446,7 +1446,7 @@ Consider this function that iterates over a vector of\n integers, passing in a pointer to each integer in the vector:\n \n ~~~~\n-fn each(v: &[int], op: &fn(v: &int)) {\n+fn each(v: &[int], op: |v: &int|) {\n    let mut n = 0;\n    while n < v.len() {\n        op(&v[n]);\n@@ -1460,7 +1460,7 @@ argument, we can write it in a way that has a pleasant, block-like\n structure.\n \n ~~~~\n-# fn each(v: &[int], op: &fn(v: &int)) { }\n+# fn each(v: &[int], op: |v: &int|) { }\n # fn do_some_work(i: &int) { }\n each([1, 2, 3], |n| {\n     do_some_work(n);\n@@ -1471,7 +1471,7 @@ This is such a useful pattern that Rust has a special form of function\n call that can be written more like a built-in control structure:\n \n ~~~~\n-# fn each(v: &[int], op: &fn(v: &int)) { }\n+# fn each(v: &[int], op: |v: &int|) { }\n # fn do_some_work(i: &int) { }\n do each([1, 2, 3]) |n| {\n     do_some_work(n);\n@@ -1650,7 +1650,7 @@ vector consisting of the result of applying `function` to each element\n of `vector`:\n \n ~~~~\n-fn map<T, U>(vector: &[T], function: &fn(v: &T) -> U) -> ~[U] {\n+fn map<T, U>(vector: &[T], function: |v: &T| -> U) -> ~[U] {\n     let mut accumulator = ~[];\n     for element in vector.iter() {\n         accumulator.push(function(element));"}]}