{"sha": "cf20d8c3887f96f990276cf6a0e6cee2687b1048", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMjBkOGMzODg3Zjk2Zjk5MDI3NmNmNmEwZTZjZWUyNjg3YjEwNDg=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T11:50:48Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-10T18:24:42Z"}, "message": "lowering: move lower_expr -> expr.rs", "tree": {"sha": "75d17825ad54c3486ea4bbb9fba2181260818fce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75d17825ad54c3486ea4bbb9fba2181260818fce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf20d8c3887f96f990276cf6a0e6cee2687b1048", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf20d8c3887f96f990276cf6a0e6cee2687b1048", "html_url": "https://github.com/rust-lang/rust/commit/cf20d8c3887f96f990276cf6a0e6cee2687b1048", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf20d8c3887f96f990276cf6a0e6cee2687b1048/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be3fb0cd2cc408eb4cc9c1d71f9cedb2c974dcd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/be3fb0cd2cc408eb4cc9c1d71f9cedb2c974dcd9", "html_url": "https://github.com/rust-lang/rust/commit/be3fb0cd2cc408eb4cc9c1d71f9cedb2c974dcd9"}], "stats": {"total": 1615, "additions": 815, "deletions": 800}, "files": [{"sha": "2abcbc9cfdc3393474aa5fffac9f65e1e67e2ca8", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 2, "deletions": 800, "changes": 802, "blob_url": "https://github.com/rust-lang/rust/blob/cf20d8c3887f96f990276cf6a0e6cee2687b1048/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf20d8c3887f96f990276cf6a0e6cee2687b1048/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=cf20d8c3887f96f990276cf6a0e6cee2687b1048", "patch": "@@ -32,6 +32,8 @@\n //! get confused if the spans from leaf AST nodes occur in multiple places\n //! in the HIR, especially for multiple identifiers.\n \n+mod expr;\n+\n use crate::dep_graph::DepGraph;\n use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n@@ -4440,806 +4442,6 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n-        exprs.iter().map(|x| self.lower_expr(x)).collect()\n-    }\n-\n-    fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n-        let kind = match e.node {\n-            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n-            ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n-            ExprKind::Repeat(ref expr, ref count) => {\n-                let expr = P(self.lower_expr(expr));\n-                let count = self.lower_anon_const(count);\n-                hir::ExprKind::Repeat(expr, count)\n-            }\n-            ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n-            ExprKind::Call(ref f, ref args) => {\n-                let f = P(self.lower_expr(f));\n-                hir::ExprKind::Call(f, self.lower_exprs(args))\n-            }\n-            ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = P(self.lower_path_segment(\n-                    e.span,\n-                    seg,\n-                    ParamMode::Optional,\n-                    0,\n-                    ParenthesizedGenericArgs::Err,\n-                    ImplTraitContext::disallowed(),\n-                    None,\n-                ));\n-                let args = self.lower_exprs(args);\n-                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n-            }\n-            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n-                let binop = self.lower_binop(binop);\n-                let lhs = P(self.lower_expr(lhs));\n-                let rhs = P(self.lower_expr(rhs));\n-                hir::ExprKind::Binary(binop, lhs, rhs)\n-            }\n-            ExprKind::Unary(op, ref ohs) => {\n-                let op = self.lower_unop(op);\n-                let ohs = P(self.lower_expr(ohs));\n-                hir::ExprKind::Unary(op, ohs)\n-            }\n-            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n-            ExprKind::Cast(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n-            }\n-            ExprKind::Type(ref expr, ref ty) => {\n-                let expr = P(self.lower_expr(expr));\n-                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n-            }\n-            ExprKind::AddrOf(m, ref ohs) => {\n-                let m = self.lower_mutability(m);\n-                let ohs = P(self.lower_expr(ohs));\n-                hir::ExprKind::AddrOf(m, ohs)\n-            }\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n-                // If we got here, the `let` expression is not allowed.\n-                self.sess\n-                    .struct_span_err(e.span, \"`let` expressions are not supported here\")\n-                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n-                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n-                    .emit();\n-\n-                // For better recovery, we emit:\n-                // ```\n-                // match scrutinee { pats => true, _ => false }\n-                // ```\n-                // While this doesn't fully match the user's intent, it has key advantages:\n-                // 1. We can avoid using `abort_if_errors`.\n-                // 2. We can typeck both `pats` and `scrutinee`.\n-                // 3. `pats` is allowed to be refutable.\n-                // 4. The return type of the block is `bool` which seems like what the user wanted.\n-                let scrutinee = self.lower_expr(scrutinee);\n-                let then_arm = {\n-                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                    let expr = self.expr_bool(e.span, true);\n-                    self.arm(pats, P(expr))\n-                };\n-                let else_arm = {\n-                    let pats = hir_vec![self.pat_wild(e.span)];\n-                    let expr = self.expr_bool(e.span, false);\n-                    self.arm(pats, P(expr))\n-                };\n-                hir::ExprKind::Match(\n-                    P(scrutinee),\n-                    vec![then_arm, else_arm].into(),\n-                    hir::MatchSource::Normal,\n-                )\n-            }\n-            // FIXME(#53667): handle lowering of && and parens.\n-            ExprKind::If(ref cond, ref then, ref else_opt) => {\n-                // `_ => else_block` where `else_block` is `{}` if there's `None`:\n-                let else_pat = self.pat_wild(e.span);\n-                let (else_expr, contains_else_clause) = match else_opt {\n-                    None => (self.expr_block_empty(e.span), false),\n-                    Some(els) => (self.lower_expr(els), true),\n-                };\n-                let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n-\n-                // Handle then + scrutinee:\n-                let then_blk = self.lower_block(then, false);\n-                let then_expr = self.expr_block(then_blk, ThinVec::new());\n-                let (then_pats, scrutinee, desugar) = match cond.node {\n-                    // `<pat> => <then>`:\n-                    ExprKind::Let(ref pats, ref scrutinee) => {\n-                        let scrutinee = self.lower_expr(scrutinee);\n-                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                        let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                        (pats, scrutinee, desugar)\n-                    }\n-                    // `true => <then>`:\n-                    _ => {\n-                        // Lower condition:\n-                        let cond = self.lower_expr(cond);\n-                        let span_block = self.mark_span_with_reason(\n-                            DesugaringKind::CondTemporary, cond.span, None\n-                        );\n-                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `if cond { ... }` does not\n-                        // let temporaries live outside of `cond`.\n-                        let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                        let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                        let pats = hir_vec![self.pat_bool(e.span, true)];\n-                        (pats, cond, desugar)\n-                    }\n-                };\n-                let then_arm = self.arm(then_pats, P(then_expr));\n-\n-                hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n-            }\n-            // FIXME(#53667): handle lowering of && and parens.\n-            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                // Note that the block AND the condition are evaluated in the loop scope.\n-                // This is done to allow `break` from inside the condition of the loop.\n-\n-                // `_ => break`:\n-                let else_arm = {\n-                    let else_pat = this.pat_wild(e.span);\n-                    let else_expr = this.expr_break(e.span, ThinVec::new());\n-                    this.arm(hir_vec![else_pat], else_expr)\n-                };\n-\n-                // Handle then + scrutinee:\n-                let then_blk = this.lower_block(body, false);\n-                let then_expr = this.expr_block(then_blk, ThinVec::new());\n-                let (then_pats, scrutinee, desugar, source) = match cond.node {\n-                    ExprKind::Let(ref pats, ref scrutinee) => {\n-                        // to:\n-                        //\n-                        //   [opt_ident]: loop {\n-                        //     match <sub_expr> {\n-                        //       <pat> => <body>,\n-                        //       _ => break\n-                        //     }\n-                        //   }\n-                        let scrutinee = this.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                        let pats = pats.iter().map(|pat| this.lower_pat(pat)).collect();\n-                        let desugar = hir::MatchSource::WhileLetDesugar;\n-                        (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n-                    }\n-                    _ => {\n-                        // We desugar: `'label: while $cond $body` into:\n-                        //\n-                        // ```\n-                        // 'label: loop {\n-                        //     match DropTemps($cond) {\n-                        //         true => $body,\n-                        //         _ => break,\n-                        //     }\n-                        // }\n-                        // ```\n-\n-                        // Lower condition:\n-                        let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n-                        let span_block = this.mark_span_with_reason(\n-                            DesugaringKind::CondTemporary, cond.span, None\n-                        );\n-                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n-                        // to preserve drop semantics since `while cond { ... }` does not\n-                        // let temporaries live outside of `cond`.\n-                        let cond = this.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                        let desugar = hir::MatchSource::WhileDesugar;\n-                        // `true => <then>`:\n-                        let pats = hir_vec![this.pat_bool(e.span, true)];\n-                        (pats, cond, desugar, hir::LoopSource::While)\n-                    }\n-                };\n-                let then_arm = this.arm(then_pats, P(then_expr));\n-\n-                // `match <scrutinee> { ... }`\n-                let match_expr = this.expr_match(\n-                    scrutinee.span,\n-                    P(scrutinee),\n-                    hir_vec![then_arm, else_arm],\n-                    desugar,\n-                );\n-\n-                // `[opt_ident]: loop { ... }`\n-                hir::ExprKind::Loop(\n-                    P(this.block_expr(P(match_expr))),\n-                    this.lower_label(opt_label),\n-                    source\n-                )\n-            }),\n-            ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n-                hir::ExprKind::Loop(\n-                    this.lower_block(body, false),\n-                    this.lower_label(opt_label),\n-                    hir::LoopSource::Loop,\n-                )\n-            }),\n-            ExprKind::TryBlock(ref body) => {\n-                self.with_catch_scope(body.id, |this| {\n-                    let unstable_span = this.mark_span_with_reason(\n-                        DesugaringKind::TryBlock,\n-                        body.span,\n-                        this.allow_try_trait.clone(),\n-                    );\n-                    let mut block = this.lower_block(body, true).into_inner();\n-                    let tail = block.expr.take().map_or_else(\n-                        || {\n-                            let span = this.sess.source_map().end_point(unstable_span);\n-                            hir::Expr {\n-                                span,\n-                                node: hir::ExprKind::Tup(hir_vec![]),\n-                                attrs: ThinVec::new(),\n-                                hir_id: this.next_id(),\n-                            }\n-                        },\n-                        |x: P<hir::Expr>| x.into_inner(),\n-                    );\n-                    block.expr = Some(this.wrap_in_try_constructor(\n-                        sym::from_ok, tail, unstable_span));\n-                    hir::ExprKind::Block(P(block), None)\n-                })\n-            }\n-            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n-                P(self.lower_expr(expr)),\n-                arms.iter().map(|x| self.lower_arm(x)).collect(),\n-                hir::MatchSource::Normal,\n-            ),\n-            ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n-                self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n-                    this.with_new_scopes(|this| {\n-                        let block = this.lower_block(block, false);\n-                        this.expr_block(block, ThinVec::new())\n-                    })\n-                })\n-            }\n-            ExprKind::Await(ref expr) => self.lower_await(e.span, expr),\n-            ExprKind::Closure(\n-                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n-            ) => {\n-                if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let outer_decl = FnDecl {\n-                        inputs: decl.inputs.clone(),\n-                        output: FunctionRetTy::Default(fn_decl_span),\n-                        c_variadic: false,\n-                    };\n-                    // We need to lower the declaration outside the new scope, because we\n-                    // have to conserve the state of being inside a loop condition for the\n-                    // closure argument types.\n-                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n-\n-                    self.with_new_scopes(|this| {\n-                        // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n-                        if capture_clause == CaptureBy::Ref &&\n-                            !decl.inputs.is_empty()\n-                        {\n-                            struct_span_err!(\n-                                this.sess,\n-                                fn_decl_span,\n-                                E0708,\n-                                \"`async` non-`move` closures with arguments \\\n-                                are not currently supported\",\n-                            )\n-                                .help(\"consider using `let` statements to manually capture \\\n-                                       variables by reference before entering an \\\n-                                       `async move` closure\")\n-                                .emit();\n-                        }\n-\n-                        // Transform `async |x: u8| -> X { ... }` into\n-                        // `|x: u8| future_from_generator(|| -> X { ... })`.\n-                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n-                            let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n-                                Some(ty.clone())\n-                            } else { None };\n-                            let async_body = this.make_async_expr(\n-                                capture_clause, closure_id, async_ret_ty, body.span,\n-                                |this| {\n-                                    this.with_new_scopes(|this| this.lower_expr(body))\n-                                });\n-                            this.expr(fn_decl_span, async_body, ThinVec::new())\n-                        });\n-                        hir::ExprKind::Closure(\n-                            this.lower_capture_clause(capture_clause),\n-                            fn_decl,\n-                            body_id,\n-                            fn_decl_span,\n-                            None,\n-                        )\n-                    })\n-                } else {\n-                    // Lower outside new scope to preserve `is_in_loop_condition`.\n-                    let fn_decl = self.lower_fn_decl(decl, None, false, None);\n-\n-                    self.with_new_scopes(|this| {\n-                        this.current_item = Some(fn_decl_span);\n-                        let mut generator_kind = None;\n-                        let body_id = this.lower_fn_body(decl, |this| {\n-                            let e = this.lower_expr(body);\n-                            generator_kind = this.generator_kind;\n-                            e\n-                        });\n-                        let generator_option = this.generator_movability_for_fn(\n-                            &decl,\n-                            fn_decl_span,\n-                            generator_kind,\n-                            movability,\n-                        );\n-                        hir::ExprKind::Closure(\n-                            this.lower_capture_clause(capture_clause),\n-                            fn_decl,\n-                            body_id,\n-                            fn_decl_span,\n-                            generator_option,\n-                        )\n-                    })\n-                }\n-            }\n-            ExprKind::Block(ref blk, opt_label) => {\n-                hir::ExprKind::Block(self.lower_block(blk,\n-                                                      opt_label.is_some()),\n-                                                      self.lower_label(opt_label))\n-            }\n-            ExprKind::Assign(ref el, ref er) => {\n-                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n-            }\n-            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n-                self.lower_binop(op),\n-                P(self.lower_expr(el)),\n-                P(self.lower_expr(er)),\n-            ),\n-            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n-            ExprKind::Index(ref el, ref er) => {\n-                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n-            }\n-            // Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n-            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n-                let id = self.next_id();\n-                let e1 = self.lower_expr(e1);\n-                let e2 = self.lower_expr(e2);\n-                self.expr_call_std_assoc_fn(\n-                    id,\n-                    e.span,\n-                    &[sym::ops, sym::RangeInclusive],\n-                    \"new\",\n-                    hir_vec![e1, e2],\n-                )\n-            }\n-            ExprKind::Range(ref e1, ref e2, lims) => {\n-                use syntax::ast::RangeLimits::*;\n-\n-                let path = match (e1, e2, lims) {\n-                    (&None, &None, HalfOpen) => sym::RangeFull,\n-                    (&Some(..), &None, HalfOpen) => sym::RangeFrom,\n-                    (&None, &Some(..), HalfOpen) => sym::RangeTo,\n-                    (&Some(..), &Some(..), HalfOpen) => sym::Range,\n-                    (&None, &Some(..), Closed) => sym::RangeToInclusive,\n-                    (&Some(..), &Some(..), Closed) => unreachable!(),\n-                    (_, &None, Closed) => self.diagnostic()\n-                        .span_fatal(e.span, \"inclusive range with no end\")\n-                        .raise(),\n-                };\n-\n-                let fields = e1.iter()\n-                    .map(|e| (\"start\", e))\n-                    .chain(e2.iter().map(|e| (\"end\", e)))\n-                    .map(|(s, e)| {\n-                        let expr = P(self.lower_expr(&e));\n-                        let ident = Ident::new(Symbol::intern(s), e.span);\n-                        self.field(ident, expr, e.span)\n-                    })\n-                    .collect::<P<[hir::Field]>>();\n-\n-                let is_unit = fields.is_empty();\n-                let struct_path = [sym::ops, path];\n-                let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n-                let struct_path = hir::QPath::Resolved(None, P(struct_path));\n-\n-                return hir::Expr {\n-                    hir_id: self.lower_node_id(e.id),\n-                    node: if is_unit {\n-                        hir::ExprKind::Path(struct_path)\n-                    } else {\n-                        hir::ExprKind::Struct(P(struct_path), fields, None)\n-                    },\n-                    span: e.span,\n-                    attrs: e.attrs.clone(),\n-                };\n-            }\n-            ExprKind::Path(ref qself, ref path) => {\n-                let qpath = self.lower_qpath(\n-                    e.id,\n-                    qself,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                );\n-                hir::ExprKind::Path(qpath)\n-            }\n-            ExprKind::Break(opt_label, ref opt_expr) => {\n-                let destination = if self.is_in_loop_condition && opt_label.is_none() {\n-                    hir::Destination {\n-                        label: None,\n-                        target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n-                    }\n-                } else {\n-                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n-                };\n-                hir::ExprKind::Break(\n-                    destination,\n-                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-                )\n-            }\n-            ExprKind::Continue(opt_label) => {\n-                hir::ExprKind::Continue(if self.is_in_loop_condition && opt_label.is_none() {\n-                    hir::Destination {\n-                        label: None,\n-                        target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n-                    }\n-                } else {\n-                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n-                })\n-            }\n-            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n-            ExprKind::InlineAsm(ref asm) => {\n-                let hir_asm = hir::InlineAsm {\n-                    inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n-                    outputs: asm.outputs\n-                        .iter()\n-                        .map(|out| hir::InlineAsmOutput {\n-                            constraint: out.constraint.clone(),\n-                            is_rw: out.is_rw,\n-                            is_indirect: out.is_indirect,\n-                            span: out.expr.span,\n-                        })\n-                        .collect(),\n-                    asm: asm.asm.clone(),\n-                    asm_str_style: asm.asm_str_style,\n-                    clobbers: asm.clobbers.clone().into(),\n-                    volatile: asm.volatile,\n-                    alignstack: asm.alignstack,\n-                    dialect: asm.dialect,\n-                    ctxt: asm.ctxt,\n-                };\n-                let outputs = asm.outputs\n-                    .iter()\n-                    .map(|out| self.lower_expr(&out.expr))\n-                    .collect();\n-                let inputs = asm.inputs\n-                    .iter()\n-                    .map(|&(_, ref input)| self.lower_expr(input))\n-                    .collect();\n-                hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n-            }\n-            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n-                P(self.lower_qpath(\n-                    e.id,\n-                    &None,\n-                    path,\n-                    ParamMode::Optional,\n-                    ImplTraitContext::disallowed(),\n-                )),\n-                fields.iter().map(|x| self.lower_field(x)).collect(),\n-                maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n-            ),\n-            ExprKind::Paren(ref ex) => {\n-                let mut ex = self.lower_expr(ex);\n-                // Include parens in span, but only if it is a super-span.\n-                if e.span.contains(ex.span) {\n-                    ex.span = e.span;\n-                }\n-                // Merge attributes into the inner expression.\n-                let mut attrs = e.attrs.clone();\n-                attrs.extend::<Vec<_>>(ex.attrs.into());\n-                ex.attrs = attrs;\n-                return ex;\n-            }\n-\n-            ExprKind::Yield(ref opt_expr) => {\n-                match self.generator_kind {\n-                    Some(hir::GeneratorKind::Gen) => {},\n-                    Some(hir::GeneratorKind::Async) => {\n-                        span_err!(\n-                            self.sess,\n-                            e.span,\n-                            E0727,\n-                            \"`async` generators are not yet supported\",\n-                        );\n-                        self.sess.abort_if_errors();\n-                    },\n-                    None => {\n-                        self.generator_kind = Some(hir::GeneratorKind::Gen);\n-                    }\n-                }\n-                let expr = opt_expr\n-                    .as_ref()\n-                    .map(|x| self.lower_expr(x))\n-                    .unwrap_or_else(|| self.expr_unit(e.span));\n-                hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n-            }\n-\n-            ExprKind::Err => hir::ExprKind::Err,\n-\n-            // Desugar `ExprForLoop`\n-            // from: `[opt_ident]: for <pat> in <head> <body>`\n-            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n-                // to:\n-                //\n-                //   {\n-                //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n-                //       mut iter => {\n-                //         [opt_ident]: loop {\n-                //           let mut __next;\n-                //           match ::std::iter::Iterator::next(&mut iter) {\n-                //             ::std::option::Option::Some(val) => __next = val,\n-                //             ::std::option::Option::None => break\n-                //           };\n-                //           let <pat> = __next;\n-                //           StmtKind::Expr(<body>);\n-                //         }\n-                //       }\n-                //     };\n-                //     result\n-                //   }\n-\n-                // expand <head>\n-                let mut head = self.lower_expr(head);\n-                let head_sp = head.span;\n-                let desugared_span = self.mark_span_with_reason(\n-                    DesugaringKind::ForLoop,\n-                    head_sp,\n-                    None,\n-                );\n-                head.span = desugared_span;\n-\n-                let iter = Ident::with_empty_ctxt(sym::iter);\n-\n-                let next_ident = Ident::with_empty_ctxt(sym::__next);\n-                let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n-                    desugared_span,\n-                    next_ident,\n-                    hir::BindingAnnotation::Mutable,\n-                );\n-\n-                // `::std::option::Option::Some(val) => __next = val`\n-                let pat_arm = {\n-                    let val_ident = Ident::with_empty_ctxt(sym::val);\n-                    let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n-                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n-                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n-                    let assign = P(self.expr(\n-                        pat.span,\n-                        hir::ExprKind::Assign(next_expr, val_expr),\n-                        ThinVec::new(),\n-                    ));\n-                    let some_pat = self.pat_some(pat.span, val_pat);\n-                    self.arm(hir_vec![some_pat], assign)\n-                };\n-\n-                // `::std::option::Option::None => break`\n-                let break_arm = {\n-                    let break_expr =\n-                        self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n-                    let pat = self.pat_none(e.span);\n-                    self.arm(hir_vec![pat], break_expr)\n-                };\n-\n-                // `mut iter`\n-                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n-                    desugared_span,\n-                    iter,\n-                    hir::BindingAnnotation::Mutable\n-                );\n-\n-                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n-                let match_expr = {\n-                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n-                    let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n-                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n-                    let next_expr = P(self.expr_call_std_path(\n-                        head_sp,\n-                        next_path,\n-                        hir_vec![ref_mut_iter],\n-                    ));\n-                    let arms = hir_vec![pat_arm, break_arm];\n-\n-                    self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n-                };\n-                let match_stmt = self.stmt_expr(head_sp, match_expr);\n-\n-                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n-\n-                // `let mut __next`\n-                let next_let = self.stmt_let_pat(\n-                    ThinVec::new(),\n-                    desugared_span,\n-                    None,\n-                    next_pat,\n-                    hir::LocalSource::ForLoopDesugar,\n-                );\n-\n-                // `let <pat> = __next`\n-                let pat = self.lower_pat(pat);\n-                let pat_let = self.stmt_let_pat(\n-                    ThinVec::new(),\n-                    head_sp,\n-                    Some(next_expr),\n-                    pat,\n-                    hir::LocalSource::ForLoopDesugar,\n-                );\n-\n-                let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-                let body_expr = self.expr_block(body_block, ThinVec::new());\n-                let body_stmt = self.stmt_expr(body.span, body_expr);\n-\n-                let loop_block = P(self.block_all(\n-                    e.span,\n-                    hir_vec![next_let, match_stmt, pat_let, body_stmt],\n-                    None,\n-                ));\n-\n-                // `[opt_ident]: loop { ... }`\n-                let loop_expr = hir::ExprKind::Loop(\n-                    loop_block,\n-                    self.lower_label(opt_label),\n-                    hir::LoopSource::ForLoop,\n-                );\n-                let loop_expr = P(hir::Expr {\n-                    hir_id: self.lower_node_id(e.id),\n-                    node: loop_expr,\n-                    span: e.span,\n-                    attrs: ThinVec::new(),\n-                });\n-\n-                // `mut iter => { ... }`\n-                let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n-\n-                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n-                let into_iter_expr = {\n-                    let into_iter_path =\n-                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n-                    P(self.expr_call_std_path(\n-                        head_sp,\n-                        into_iter_path,\n-                        hir_vec![head],\n-                    ))\n-                };\n-\n-                let match_expr = P(self.expr_match(\n-                    head_sp,\n-                    into_iter_expr,\n-                    hir_vec![iter_arm],\n-                    hir::MatchSource::ForLoopDesugar,\n-                ));\n-\n-                // This is effectively `{ let _result = ...; _result }`.\n-                // The construct was introduced in #21984 and is necessary to make sure that\n-                // temporaries in the `head` expression are dropped and do not leak to the\n-                // surrounding scope of the `match` since the `match` is not a terminating scope.\n-                //\n-                // Also, add the attributes to the outer returned expr node.\n-                return self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n-            }\n-\n-            // Desugar `ExprKind::Try`\n-            // from: `<expr>?`\n-            ExprKind::Try(ref sub_expr) => {\n-                // into:\n-                //\n-                // match Try::into_result(<expr>) {\n-                //     Ok(val) => #[allow(unreachable_code)] val,\n-                //     Err(err) => #[allow(unreachable_code)]\n-                //                 // If there is an enclosing `catch {...}`\n-                //                 break 'catch_target Try::from_error(From::from(err)),\n-                //                 // Otherwise\n-                //                 return Try::from_error(From::from(err)),\n-                // }\n-\n-                let unstable_span = self.mark_span_with_reason(\n-                    DesugaringKind::QuestionMark,\n-                    e.span,\n-                    self.allow_try_trait.clone(),\n-                );\n-                let try_span = self.sess.source_map().end_point(e.span);\n-                let try_span = self.mark_span_with_reason(\n-                    DesugaringKind::QuestionMark,\n-                    try_span,\n-                    self.allow_try_trait.clone(),\n-                );\n-\n-                // `Try::into_result(<expr>)`\n-                let discr = {\n-                    // expand <expr>\n-                    let sub_expr = self.lower_expr(sub_expr);\n-\n-                    let path = &[sym::ops, sym::Try, sym::into_result];\n-                    P(self.expr_call_std_path(\n-                        unstable_span,\n-                        path,\n-                        hir_vec![sub_expr],\n-                    ))\n-                };\n-\n-                // `#[allow(unreachable_code)]`\n-                let attr = {\n-                    // `allow(unreachable_code)`\n-                    let allow = {\n-                        let allow_ident = Ident::new(sym::allow, e.span);\n-                        let uc_ident = Ident::new(sym::unreachable_code, e.span);\n-                        let uc_nested = attr::mk_nested_word_item(uc_ident);\n-                        attr::mk_list_item(allow_ident, vec![uc_nested])\n-                    };\n-                    attr::mk_attr_outer(allow)\n-                };\n-                let attrs = vec![attr];\n-\n-                // `Ok(val) => #[allow(unreachable_code)] val,`\n-                let ok_arm = {\n-                    let val_ident = Ident::with_empty_ctxt(sym::val);\n-                    let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n-                    let val_expr = P(self.expr_ident_with_attrs(\n-                        e.span,\n-                        val_ident,\n-                        val_pat_nid,\n-                        ThinVec::from(attrs.clone()),\n-                    ));\n-                    let ok_pat = self.pat_ok(e.span, val_pat);\n-\n-                    self.arm(hir_vec![ok_pat], val_expr)\n-                };\n-\n-                // `Err(err) => #[allow(unreachable_code)]\n-                //              return Try::from_error(From::from(err)),`\n-                let err_arm = {\n-                    let err_ident = Ident::with_empty_ctxt(sym::err);\n-                    let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n-                    let from_expr = {\n-                        let from_path = &[sym::convert, sym::From, sym::from];\n-                        let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n-                        self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n-                    };\n-                    let from_err_expr =\n-                        self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n-                    let thin_attrs = ThinVec::from(attrs);\n-                    let catch_scope = self.catch_scopes.last().map(|x| *x);\n-                    let ret_expr = if let Some(catch_node) = catch_scope {\n-                        let target_id = Ok(self.lower_node_id(catch_node));\n-                        P(self.expr(\n-                            try_span,\n-                            hir::ExprKind::Break(\n-                                hir::Destination {\n-                                    label: None,\n-                                    target_id,\n-                                },\n-                                Some(from_err_expr),\n-                            ),\n-                            thin_attrs,\n-                        ))\n-                    } else {\n-                        P(self.expr(try_span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n-                    };\n-\n-                    let err_pat = self.pat_err(try_span, err_local);\n-                    self.arm(hir_vec![err_pat], ret_expr)\n-                };\n-\n-                hir::ExprKind::Match(\n-                    discr,\n-                    hir_vec![err_arm, ok_arm],\n-                    hir::MatchSource::TryDesugar,\n-                )\n-            }\n-\n-            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n-        };\n-\n-        hir::Expr {\n-            hir_id: self.lower_node_id(e.id),\n-            node: kind,\n-            span: e.span,\n-            attrs: e.attrs.clone(),\n-        }\n-    }\n-\n     fn lower_stmt(&mut self, s: &Stmt) -> SmallVec<[hir::Stmt; 1]> {\n         let node = match s.node {\n             StmtKind::Local(ref l) => {"}, {"sha": "089fec51ca2c1c7991468e7864f99422ff2d58b6", "filename": "src/librustc/hir/lowering/expr.rs", "status": "added", "additions": 813, "deletions": 0, "changes": 813, "blob_url": "https://github.com/rust-lang/rust/blob/cf20d8c3887f96f990276cf6a0e6cee2687b1048/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf20d8c3887f96f990276cf6a0e6cee2687b1048/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=cf20d8c3887f96f990276cf6a0e6cee2687b1048", "patch": "@@ -0,0 +1,813 @@\n+use super::{LoweringContext, ParamMode, ParenthesizedGenericArgs, ImplTraitContext};\n+use crate::hir::{self, HirVec};\n+use crate::hir::ptr::P;\n+\n+use rustc_data_structures::thin_vec::ThinVec;\n+\n+use syntax::attr;\n+use syntax::ptr::P as AstP;\n+use syntax::ast::*;\n+use syntax::source_map::{respan, DesugaringKind};\n+use syntax::symbol::{sym, Symbol};\n+\n+impl LoweringContext<'_> {\n+    fn lower_exprs(&mut self, exprs: &[AstP<Expr>]) -> HirVec<hir::Expr> {\n+        exprs.iter().map(|x| self.lower_expr(x)).collect()\n+    }\n+\n+    pub(super) fn lower_expr(&mut self, e: &Expr) -> hir::Expr {\n+        let kind = match e.node {\n+            ExprKind::Box(ref inner) => hir::ExprKind::Box(P(self.lower_expr(inner))),\n+            ExprKind::Array(ref exprs) => hir::ExprKind::Array(self.lower_exprs(exprs)),\n+            ExprKind::Repeat(ref expr, ref count) => {\n+                let expr = P(self.lower_expr(expr));\n+                let count = self.lower_anon_const(count);\n+                hir::ExprKind::Repeat(expr, count)\n+            }\n+            ExprKind::Tup(ref elts) => hir::ExprKind::Tup(self.lower_exprs(elts)),\n+            ExprKind::Call(ref f, ref args) => {\n+                let f = P(self.lower_expr(f));\n+                hir::ExprKind::Call(f, self.lower_exprs(args))\n+            }\n+            ExprKind::MethodCall(ref seg, ref args) => {\n+                let hir_seg = P(self.lower_path_segment(\n+                    e.span,\n+                    seg,\n+                    ParamMode::Optional,\n+                    0,\n+                    ParenthesizedGenericArgs::Err,\n+                    ImplTraitContext::disallowed(),\n+                    None,\n+                ));\n+                let args = self.lower_exprs(args);\n+                hir::ExprKind::MethodCall(hir_seg, seg.ident.span, args)\n+            }\n+            ExprKind::Binary(binop, ref lhs, ref rhs) => {\n+                let binop = self.lower_binop(binop);\n+                let lhs = P(self.lower_expr(lhs));\n+                let rhs = P(self.lower_expr(rhs));\n+                hir::ExprKind::Binary(binop, lhs, rhs)\n+            }\n+            ExprKind::Unary(op, ref ohs) => {\n+                let op = self.lower_unop(op);\n+                let ohs = P(self.lower_expr(ohs));\n+                hir::ExprKind::Unary(op, ohs)\n+            }\n+            ExprKind::Lit(ref l) => hir::ExprKind::Lit(respan(l.span, l.node.clone())),\n+            ExprKind::Cast(ref expr, ref ty) => {\n+                let expr = P(self.lower_expr(expr));\n+                hir::ExprKind::Cast(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+            }\n+            ExprKind::Type(ref expr, ref ty) => {\n+                let expr = P(self.lower_expr(expr));\n+                hir::ExprKind::Type(expr, self.lower_ty(ty, ImplTraitContext::disallowed()))\n+            }\n+            ExprKind::AddrOf(m, ref ohs) => {\n+                let m = self.lower_mutability(m);\n+                let ohs = P(self.lower_expr(ohs));\n+                hir::ExprKind::AddrOf(m, ohs)\n+            }\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                // If we got here, the `let` expression is not allowed.\n+                self.sess\n+                    .struct_span_err(e.span, \"`let` expressions are not supported here\")\n+                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                    .emit();\n+\n+                // For better recovery, we emit:\n+                // ```\n+                // match scrutinee { pats => true, _ => false }\n+                // ```\n+                // While this doesn't fully match the user's intent, it has key advantages:\n+                // 1. We can avoid using `abort_if_errors`.\n+                // 2. We can typeck both `pats` and `scrutinee`.\n+                // 3. `pats` is allowed to be refutable.\n+                // 4. The return type of the block is `bool` which seems like what the user wanted.\n+                let scrutinee = self.lower_expr(scrutinee);\n+                let then_arm = {\n+                    let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                    let expr = self.expr_bool(e.span, true);\n+                    self.arm(pats, P(expr))\n+                };\n+                let else_arm = {\n+                    let pats = hir_vec![self.pat_wild(e.span)];\n+                    let expr = self.expr_bool(e.span, false);\n+                    self.arm(pats, P(expr))\n+                };\n+                hir::ExprKind::Match(\n+                    P(scrutinee),\n+                    vec![then_arm, else_arm].into(),\n+                    hir::MatchSource::Normal,\n+                )\n+            }\n+            // FIXME(#53667): handle lowering of && and parens.\n+            ExprKind::If(ref cond, ref then, ref else_opt) => {\n+                // `_ => else_block` where `else_block` is `{}` if there's `None`:\n+                let else_pat = self.pat_wild(e.span);\n+                let (else_expr, contains_else_clause) = match else_opt {\n+                    None => (self.expr_block_empty(e.span), false),\n+                    Some(els) => (self.lower_expr(els), true),\n+                };\n+                let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n+\n+                // Handle then + scrutinee:\n+                let then_blk = self.lower_block(then, false);\n+                let then_expr = self.expr_block(then_blk, ThinVec::new());\n+                let (then_pats, scrutinee, desugar) = match cond.node {\n+                    // `<pat> => <then>`:\n+                    ExprKind::Let(ref pats, ref scrutinee) => {\n+                        let scrutinee = self.lower_expr(scrutinee);\n+                        let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+                        let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n+                        (pats, scrutinee, desugar)\n+                    }\n+                    // `true => <then>`:\n+                    _ => {\n+                        // Lower condition:\n+                        let cond = self.lower_expr(cond);\n+                        let span_block = self.mark_span_with_reason(\n+                            DesugaringKind::CondTemporary, cond.span, None\n+                        );\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `if cond { ... }` does not\n+                        // let temporaries live outside of `cond`.\n+                        let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                        let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n+                        let pats = hir_vec![self.pat_bool(e.span, true)];\n+                        (pats, cond, desugar)\n+                    }\n+                };\n+                let then_arm = self.arm(then_pats, P(then_expr));\n+\n+                hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n+            }\n+            // FIXME(#53667): handle lowering of && and parens.\n+            ExprKind::While(ref cond, ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                // Note that the block AND the condition are evaluated in the loop scope.\n+                // This is done to allow `break` from inside the condition of the loop.\n+\n+                // `_ => break`:\n+                let else_arm = {\n+                    let else_pat = this.pat_wild(e.span);\n+                    let else_expr = this.expr_break(e.span, ThinVec::new());\n+                    this.arm(hir_vec![else_pat], else_expr)\n+                };\n+\n+                // Handle then + scrutinee:\n+                let then_blk = this.lower_block(body, false);\n+                let then_expr = this.expr_block(then_blk, ThinVec::new());\n+                let (then_pats, scrutinee, desugar, source) = match cond.node {\n+                    ExprKind::Let(ref pats, ref scrutinee) => {\n+                        // to:\n+                        //\n+                        //   [opt_ident]: loop {\n+                        //     match <sub_expr> {\n+                        //       <pat> => <body>,\n+                        //       _ => break\n+                        //     }\n+                        //   }\n+                        let scrutinee = this.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n+                        let pats = pats.iter().map(|pat| this.lower_pat(pat)).collect();\n+                        let desugar = hir::MatchSource::WhileLetDesugar;\n+                        (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                    }\n+                    _ => {\n+                        // We desugar: `'label: while $cond $body` into:\n+                        //\n+                        // ```\n+                        // 'label: loop {\n+                        //     match DropTemps($cond) {\n+                        //         true => $body,\n+                        //         _ => break,\n+                        //     }\n+                        // }\n+                        // ```\n+\n+                        // Lower condition:\n+                        let cond = this.with_loop_condition_scope(|this| this.lower_expr(cond));\n+                        let span_block = this.mark_span_with_reason(\n+                            DesugaringKind::CondTemporary, cond.span, None\n+                        );\n+                        // Wrap in a construct equivalent to `{ let _t = $cond; _t }`\n+                        // to preserve drop semantics since `while cond { ... }` does not\n+                        // let temporaries live outside of `cond`.\n+                        let cond = this.expr_drop_temps(span_block, P(cond), ThinVec::new());\n+\n+                        let desugar = hir::MatchSource::WhileDesugar;\n+                        // `true => <then>`:\n+                        let pats = hir_vec![this.pat_bool(e.span, true)];\n+                        (pats, cond, desugar, hir::LoopSource::While)\n+                    }\n+                };\n+                let then_arm = this.arm(then_pats, P(then_expr));\n+\n+                // `match <scrutinee> { ... }`\n+                let match_expr = this.expr_match(\n+                    scrutinee.span,\n+                    P(scrutinee),\n+                    hir_vec![then_arm, else_arm],\n+                    desugar,\n+                );\n+\n+                // `[opt_ident]: loop { ... }`\n+                hir::ExprKind::Loop(\n+                    P(this.block_expr(P(match_expr))),\n+                    this.lower_label(opt_label),\n+                    source\n+                )\n+            }),\n+            ExprKind::Loop(ref body, opt_label) => self.with_loop_scope(e.id, |this| {\n+                hir::ExprKind::Loop(\n+                    this.lower_block(body, false),\n+                    this.lower_label(opt_label),\n+                    hir::LoopSource::Loop,\n+                )\n+            }),\n+            ExprKind::TryBlock(ref body) => {\n+                self.with_catch_scope(body.id, |this| {\n+                    let unstable_span = this.mark_span_with_reason(\n+                        DesugaringKind::TryBlock,\n+                        body.span,\n+                        this.allow_try_trait.clone(),\n+                    );\n+                    let mut block = this.lower_block(body, true).into_inner();\n+                    let tail = block.expr.take().map_or_else(\n+                        || {\n+                            let span = this.sess.source_map().end_point(unstable_span);\n+                            hir::Expr {\n+                                span,\n+                                node: hir::ExprKind::Tup(hir_vec![]),\n+                                attrs: ThinVec::new(),\n+                                hir_id: this.next_id(),\n+                            }\n+                        },\n+                        |x: P<hir::Expr>| x.into_inner(),\n+                    );\n+                    block.expr = Some(this.wrap_in_try_constructor(\n+                        sym::from_ok, tail, unstable_span));\n+                    hir::ExprKind::Block(P(block), None)\n+                })\n+            }\n+            ExprKind::Match(ref expr, ref arms) => hir::ExprKind::Match(\n+                P(self.lower_expr(expr)),\n+                arms.iter().map(|x| self.lower_arm(x)).collect(),\n+                hir::MatchSource::Normal,\n+            ),\n+            ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n+                self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n+                    this.with_new_scopes(|this| {\n+                        let block = this.lower_block(block, false);\n+                        this.expr_block(block, ThinVec::new())\n+                    })\n+                })\n+            }\n+            ExprKind::Await(ref expr) => self.lower_await(e.span, expr),\n+            ExprKind::Closure(\n+                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n+            ) => {\n+                if let IsAsync::Async { closure_id, .. } = asyncness {\n+                    let outer_decl = FnDecl {\n+                        inputs: decl.inputs.clone(),\n+                        output: FunctionRetTy::Default(fn_decl_span),\n+                        c_variadic: false,\n+                    };\n+                    // We need to lower the declaration outside the new scope, because we\n+                    // have to conserve the state of being inside a loop condition for the\n+                    // closure argument types.\n+                    let fn_decl = self.lower_fn_decl(&outer_decl, None, false, None);\n+\n+                    self.with_new_scopes(|this| {\n+                        // FIXME(cramertj): allow `async` non-`move` closures with arguments.\n+                        if capture_clause == CaptureBy::Ref &&\n+                            !decl.inputs.is_empty()\n+                        {\n+                            struct_span_err!(\n+                                this.sess,\n+                                fn_decl_span,\n+                                E0708,\n+                                \"`async` non-`move` closures with arguments \\\n+                                are not currently supported\",\n+                            )\n+                                .help(\"consider using `let` statements to manually capture \\\n+                                       variables by reference before entering an \\\n+                                       `async move` closure\")\n+                                .emit();\n+                        }\n+\n+                        // Transform `async |x: u8| -> X { ... }` into\n+                        // `|x: u8| future_from_generator(|| -> X { ... })`.\n+                        let body_id = this.lower_fn_body(&outer_decl, |this| {\n+                            let async_ret_ty = if let FunctionRetTy::Ty(ty) = &decl.output {\n+                                Some(ty.clone())\n+                            } else { None };\n+                            let async_body = this.make_async_expr(\n+                                capture_clause, closure_id, async_ret_ty, body.span,\n+                                |this| {\n+                                    this.with_new_scopes(|this| this.lower_expr(body))\n+                                });\n+                            this.expr(fn_decl_span, async_body, ThinVec::new())\n+                        });\n+                        hir::ExprKind::Closure(\n+                            this.lower_capture_clause(capture_clause),\n+                            fn_decl,\n+                            body_id,\n+                            fn_decl_span,\n+                            None,\n+                        )\n+                    })\n+                } else {\n+                    // Lower outside new scope to preserve `is_in_loop_condition`.\n+                    let fn_decl = self.lower_fn_decl(decl, None, false, None);\n+\n+                    self.with_new_scopes(|this| {\n+                        this.current_item = Some(fn_decl_span);\n+                        let mut generator_kind = None;\n+                        let body_id = this.lower_fn_body(decl, |this| {\n+                            let e = this.lower_expr(body);\n+                            generator_kind = this.generator_kind;\n+                            e\n+                        });\n+                        let generator_option = this.generator_movability_for_fn(\n+                            &decl,\n+                            fn_decl_span,\n+                            generator_kind,\n+                            movability,\n+                        );\n+                        hir::ExprKind::Closure(\n+                            this.lower_capture_clause(capture_clause),\n+                            fn_decl,\n+                            body_id,\n+                            fn_decl_span,\n+                            generator_option,\n+                        )\n+                    })\n+                }\n+            }\n+            ExprKind::Block(ref blk, opt_label) => {\n+                hir::ExprKind::Block(self.lower_block(blk,\n+                                                      opt_label.is_some()),\n+                                                      self.lower_label(opt_label))\n+            }\n+            ExprKind::Assign(ref el, ref er) => {\n+                hir::ExprKind::Assign(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            }\n+            ExprKind::AssignOp(op, ref el, ref er) => hir::ExprKind::AssignOp(\n+                self.lower_binop(op),\n+                P(self.lower_expr(el)),\n+                P(self.lower_expr(er)),\n+            ),\n+            ExprKind::Field(ref el, ident) => hir::ExprKind::Field(P(self.lower_expr(el)), ident),\n+            ExprKind::Index(ref el, ref er) => {\n+                hir::ExprKind::Index(P(self.lower_expr(el)), P(self.lower_expr(er)))\n+            }\n+            // Desugar `<start>..=<end>` into `std::ops::RangeInclusive::new(<start>, <end>)`.\n+            ExprKind::Range(Some(ref e1), Some(ref e2), RangeLimits::Closed) => {\n+                let id = self.next_id();\n+                let e1 = self.lower_expr(e1);\n+                let e2 = self.lower_expr(e2);\n+                self.expr_call_std_assoc_fn(\n+                    id,\n+                    e.span,\n+                    &[sym::ops, sym::RangeInclusive],\n+                    \"new\",\n+                    hir_vec![e1, e2],\n+                )\n+            }\n+            ExprKind::Range(ref e1, ref e2, lims) => {\n+                use syntax::ast::RangeLimits::*;\n+\n+                let path = match (e1, e2, lims) {\n+                    (&None, &None, HalfOpen) => sym::RangeFull,\n+                    (&Some(..), &None, HalfOpen) => sym::RangeFrom,\n+                    (&None, &Some(..), HalfOpen) => sym::RangeTo,\n+                    (&Some(..), &Some(..), HalfOpen) => sym::Range,\n+                    (&None, &Some(..), Closed) => sym::RangeToInclusive,\n+                    (&Some(..), &Some(..), Closed) => unreachable!(),\n+                    (_, &None, Closed) => self.diagnostic()\n+                        .span_fatal(e.span, \"inclusive range with no end\")\n+                        .raise(),\n+                };\n+\n+                let fields = e1.iter()\n+                    .map(|e| (\"start\", e))\n+                    .chain(e2.iter().map(|e| (\"end\", e)))\n+                    .map(|(s, e)| {\n+                        let expr = P(self.lower_expr(&e));\n+                        let ident = Ident::new(Symbol::intern(s), e.span);\n+                        self.field(ident, expr, e.span)\n+                    })\n+                    .collect::<P<[hir::Field]>>();\n+\n+                let is_unit = fields.is_empty();\n+                let struct_path = [sym::ops, path];\n+                let struct_path = self.std_path(e.span, &struct_path, None, is_unit);\n+                let struct_path = hir::QPath::Resolved(None, P(struct_path));\n+\n+                return hir::Expr {\n+                    hir_id: self.lower_node_id(e.id),\n+                    node: if is_unit {\n+                        hir::ExprKind::Path(struct_path)\n+                    } else {\n+                        hir::ExprKind::Struct(P(struct_path), fields, None)\n+                    },\n+                    span: e.span,\n+                    attrs: e.attrs.clone(),\n+                };\n+            }\n+            ExprKind::Path(ref qself, ref path) => {\n+                let qpath = self.lower_qpath(\n+                    e.id,\n+                    qself,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                );\n+                hir::ExprKind::Path(qpath)\n+            }\n+            ExprKind::Break(opt_label, ref opt_expr) => {\n+                let destination = if self.is_in_loop_condition && opt_label.is_none() {\n+                    hir::Destination {\n+                        label: None,\n+                        target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                    }\n+                } else {\n+                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n+                };\n+                hir::ExprKind::Break(\n+                    destination,\n+                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))),\n+                )\n+            }\n+            ExprKind::Continue(opt_label) => {\n+                hir::ExprKind::Continue(if self.is_in_loop_condition && opt_label.is_none() {\n+                    hir::Destination {\n+                        label: None,\n+                        target_id: Err(hir::LoopIdError::UnlabeledCfInWhileCondition).into(),\n+                    }\n+                } else {\n+                    self.lower_loop_destination(opt_label.map(|label| (e.id, label)))\n+                })\n+            }\n+            ExprKind::Ret(ref e) => hir::ExprKind::Ret(e.as_ref().map(|x| P(self.lower_expr(x)))),\n+            ExprKind::InlineAsm(ref asm) => {\n+                let hir_asm = hir::InlineAsm {\n+                    inputs: asm.inputs.iter().map(|&(ref c, _)| c.clone()).collect(),\n+                    outputs: asm.outputs\n+                        .iter()\n+                        .map(|out| hir::InlineAsmOutput {\n+                            constraint: out.constraint.clone(),\n+                            is_rw: out.is_rw,\n+                            is_indirect: out.is_indirect,\n+                            span: out.expr.span,\n+                        })\n+                        .collect(),\n+                    asm: asm.asm.clone(),\n+                    asm_str_style: asm.asm_str_style,\n+                    clobbers: asm.clobbers.clone().into(),\n+                    volatile: asm.volatile,\n+                    alignstack: asm.alignstack,\n+                    dialect: asm.dialect,\n+                    ctxt: asm.ctxt,\n+                };\n+                let outputs = asm.outputs\n+                    .iter()\n+                    .map(|out| self.lower_expr(&out.expr))\n+                    .collect();\n+                let inputs = asm.inputs\n+                    .iter()\n+                    .map(|&(_, ref input)| self.lower_expr(input))\n+                    .collect();\n+                hir::ExprKind::InlineAsm(P(hir_asm), outputs, inputs)\n+            }\n+            ExprKind::Struct(ref path, ref fields, ref maybe_expr) => hir::ExprKind::Struct(\n+                P(self.lower_qpath(\n+                    e.id,\n+                    &None,\n+                    path,\n+                    ParamMode::Optional,\n+                    ImplTraitContext::disallowed(),\n+                )),\n+                fields.iter().map(|x| self.lower_field(x)).collect(),\n+                maybe_expr.as_ref().map(|x| P(self.lower_expr(x))),\n+            ),\n+            ExprKind::Paren(ref ex) => {\n+                let mut ex = self.lower_expr(ex);\n+                // Include parens in span, but only if it is a super-span.\n+                if e.span.contains(ex.span) {\n+                    ex.span = e.span;\n+                }\n+                // Merge attributes into the inner expression.\n+                let mut attrs = e.attrs.clone();\n+                attrs.extend::<Vec<_>>(ex.attrs.into());\n+                ex.attrs = attrs;\n+                return ex;\n+            }\n+\n+            ExprKind::Yield(ref opt_expr) => {\n+                match self.generator_kind {\n+                    Some(hir::GeneratorKind::Gen) => {},\n+                    Some(hir::GeneratorKind::Async) => {\n+                        span_err!(\n+                            self.sess,\n+                            e.span,\n+                            E0727,\n+                            \"`async` generators are not yet supported\",\n+                        );\n+                        self.sess.abort_if_errors();\n+                    },\n+                    None => {\n+                        self.generator_kind = Some(hir::GeneratorKind::Gen);\n+                    }\n+                }\n+                let expr = opt_expr\n+                    .as_ref()\n+                    .map(|x| self.lower_expr(x))\n+                    .unwrap_or_else(|| self.expr_unit(e.span));\n+                hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n+            }\n+\n+            ExprKind::Err => hir::ExprKind::Err,\n+\n+            // Desugar `ExprForLoop`\n+            // from: `[opt_ident]: for <pat> in <head> <body>`\n+            ExprKind::ForLoop(ref pat, ref head, ref body, opt_label) => {\n+                // to:\n+                //\n+                //   {\n+                //     let result = match ::std::iter::IntoIterator::into_iter(<head>) {\n+                //       mut iter => {\n+                //         [opt_ident]: loop {\n+                //           let mut __next;\n+                //           match ::std::iter::Iterator::next(&mut iter) {\n+                //             ::std::option::Option::Some(val) => __next = val,\n+                //             ::std::option::Option::None => break\n+                //           };\n+                //           let <pat> = __next;\n+                //           StmtKind::Expr(<body>);\n+                //         }\n+                //       }\n+                //     };\n+                //     result\n+                //   }\n+\n+                // expand <head>\n+                let mut head = self.lower_expr(head);\n+                let head_sp = head.span;\n+                let desugared_span = self.mark_span_with_reason(\n+                    DesugaringKind::ForLoop,\n+                    head_sp,\n+                    None,\n+                );\n+                head.span = desugared_span;\n+\n+                let iter = Ident::with_empty_ctxt(sym::iter);\n+\n+                let next_ident = Ident::with_empty_ctxt(sym::__next);\n+                let (next_pat, next_pat_hid) = self.pat_ident_binding_mode(\n+                    desugared_span,\n+                    next_ident,\n+                    hir::BindingAnnotation::Mutable,\n+                );\n+\n+                // `::std::option::Option::Some(val) => __next = val`\n+                let pat_arm = {\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n+                    let (val_pat, val_pat_hid) = self.pat_ident(pat.span, val_ident);\n+                    let val_expr = P(self.expr_ident(pat.span, val_ident, val_pat_hid));\n+                    let next_expr = P(self.expr_ident(pat.span, next_ident, next_pat_hid));\n+                    let assign = P(self.expr(\n+                        pat.span,\n+                        hir::ExprKind::Assign(next_expr, val_expr),\n+                        ThinVec::new(),\n+                    ));\n+                    let some_pat = self.pat_some(pat.span, val_pat);\n+                    self.arm(hir_vec![some_pat], assign)\n+                };\n+\n+                // `::std::option::Option::None => break`\n+                let break_arm = {\n+                    let break_expr =\n+                        self.with_loop_scope(e.id, |this| this.expr_break(e.span, ThinVec::new()));\n+                    let pat = self.pat_none(e.span);\n+                    self.arm(hir_vec![pat], break_expr)\n+                };\n+\n+                // `mut iter`\n+                let (iter_pat, iter_pat_nid) = self.pat_ident_binding_mode(\n+                    desugared_span,\n+                    iter,\n+                    hir::BindingAnnotation::Mutable\n+                );\n+\n+                // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n+                let match_expr = {\n+                    let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n+                    let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n+                    let next_path = &[sym::iter, sym::Iterator, sym::next];\n+                    let next_expr = P(self.expr_call_std_path(\n+                        head_sp,\n+                        next_path,\n+                        hir_vec![ref_mut_iter],\n+                    ));\n+                    let arms = hir_vec![pat_arm, break_arm];\n+\n+                    self.expr_match(head_sp, next_expr, arms, hir::MatchSource::ForLoopDesugar)\n+                };\n+                let match_stmt = self.stmt_expr(head_sp, match_expr);\n+\n+                let next_expr = P(self.expr_ident(head_sp, next_ident, next_pat_hid));\n+\n+                // `let mut __next`\n+                let next_let = self.stmt_let_pat(\n+                    ThinVec::new(),\n+                    desugared_span,\n+                    None,\n+                    next_pat,\n+                    hir::LocalSource::ForLoopDesugar,\n+                );\n+\n+                // `let <pat> = __next`\n+                let pat = self.lower_pat(pat);\n+                let pat_let = self.stmt_let_pat(\n+                    ThinVec::new(),\n+                    head_sp,\n+                    Some(next_expr),\n+                    pat,\n+                    hir::LocalSource::ForLoopDesugar,\n+                );\n+\n+                let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n+                let body_expr = self.expr_block(body_block, ThinVec::new());\n+                let body_stmt = self.stmt_expr(body.span, body_expr);\n+\n+                let loop_block = P(self.block_all(\n+                    e.span,\n+                    hir_vec![next_let, match_stmt, pat_let, body_stmt],\n+                    None,\n+                ));\n+\n+                // `[opt_ident]: loop { ... }`\n+                let loop_expr = hir::ExprKind::Loop(\n+                    loop_block,\n+                    self.lower_label(opt_label),\n+                    hir::LoopSource::ForLoop,\n+                );\n+                let loop_expr = P(hir::Expr {\n+                    hir_id: self.lower_node_id(e.id),\n+                    node: loop_expr,\n+                    span: e.span,\n+                    attrs: ThinVec::new(),\n+                });\n+\n+                // `mut iter => { ... }`\n+                let iter_arm = self.arm(hir_vec![iter_pat], loop_expr);\n+\n+                // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n+                let into_iter_expr = {\n+                    let into_iter_path =\n+                        &[sym::iter, sym::IntoIterator, sym::into_iter];\n+                    P(self.expr_call_std_path(\n+                        head_sp,\n+                        into_iter_path,\n+                        hir_vec![head],\n+                    ))\n+                };\n+\n+                let match_expr = P(self.expr_match(\n+                    head_sp,\n+                    into_iter_expr,\n+                    hir_vec![iter_arm],\n+                    hir::MatchSource::ForLoopDesugar,\n+                ));\n+\n+                // This is effectively `{ let _result = ...; _result }`.\n+                // The construct was introduced in #21984 and is necessary to make sure that\n+                // temporaries in the `head` expression are dropped and do not leak to the\n+                // surrounding scope of the `match` since the `match` is not a terminating scope.\n+                //\n+                // Also, add the attributes to the outer returned expr node.\n+                return self.expr_drop_temps(head_sp, match_expr, e.attrs.clone())\n+            }\n+\n+            // Desugar `ExprKind::Try`\n+            // from: `<expr>?`\n+            ExprKind::Try(ref sub_expr) => {\n+                // into:\n+                //\n+                // match Try::into_result(<expr>) {\n+                //     Ok(val) => #[allow(unreachable_code)] val,\n+                //     Err(err) => #[allow(unreachable_code)]\n+                //                 // If there is an enclosing `catch {...}`\n+                //                 break 'catch_target Try::from_error(From::from(err)),\n+                //                 // Otherwise\n+                //                 return Try::from_error(From::from(err)),\n+                // }\n+\n+                let unstable_span = self.mark_span_with_reason(\n+                    DesugaringKind::QuestionMark,\n+                    e.span,\n+                    self.allow_try_trait.clone(),\n+                );\n+                let try_span = self.sess.source_map().end_point(e.span);\n+                let try_span = self.mark_span_with_reason(\n+                    DesugaringKind::QuestionMark,\n+                    try_span,\n+                    self.allow_try_trait.clone(),\n+                );\n+\n+                // `Try::into_result(<expr>)`\n+                let discr = {\n+                    // expand <expr>\n+                    let sub_expr = self.lower_expr(sub_expr);\n+\n+                    let path = &[sym::ops, sym::Try, sym::into_result];\n+                    P(self.expr_call_std_path(\n+                        unstable_span,\n+                        path,\n+                        hir_vec![sub_expr],\n+                    ))\n+                };\n+\n+                // `#[allow(unreachable_code)]`\n+                let attr = {\n+                    // `allow(unreachable_code)`\n+                    let allow = {\n+                        let allow_ident = Ident::new(sym::allow, e.span);\n+                        let uc_ident = Ident::new(sym::unreachable_code, e.span);\n+                        let uc_nested = attr::mk_nested_word_item(uc_ident);\n+                        attr::mk_list_item(allow_ident, vec![uc_nested])\n+                    };\n+                    attr::mk_attr_outer(allow)\n+                };\n+                let attrs = vec![attr];\n+\n+                // `Ok(val) => #[allow(unreachable_code)] val,`\n+                let ok_arm = {\n+                    let val_ident = Ident::with_empty_ctxt(sym::val);\n+                    let (val_pat, val_pat_nid) = self.pat_ident(e.span, val_ident);\n+                    let val_expr = P(self.expr_ident_with_attrs(\n+                        e.span,\n+                        val_ident,\n+                        val_pat_nid,\n+                        ThinVec::from(attrs.clone()),\n+                    ));\n+                    let ok_pat = self.pat_ok(e.span, val_pat);\n+\n+                    self.arm(hir_vec![ok_pat], val_expr)\n+                };\n+\n+                // `Err(err) => #[allow(unreachable_code)]\n+                //              return Try::from_error(From::from(err)),`\n+                let err_arm = {\n+                    let err_ident = Ident::with_empty_ctxt(sym::err);\n+                    let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n+                    let from_expr = {\n+                        let from_path = &[sym::convert, sym::From, sym::from];\n+                        let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n+                        self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n+                    };\n+                    let from_err_expr =\n+                        self.wrap_in_try_constructor(sym::from_error, from_expr, unstable_span);\n+                    let thin_attrs = ThinVec::from(attrs);\n+                    let catch_scope = self.catch_scopes.last().map(|x| *x);\n+                    let ret_expr = if let Some(catch_node) = catch_scope {\n+                        let target_id = Ok(self.lower_node_id(catch_node));\n+                        P(self.expr(\n+                            try_span,\n+                            hir::ExprKind::Break(\n+                                hir::Destination {\n+                                    label: None,\n+                                    target_id,\n+                                },\n+                                Some(from_err_expr),\n+                            ),\n+                            thin_attrs,\n+                        ))\n+                    } else {\n+                        P(self.expr(try_span, hir::ExprKind::Ret(Some(from_err_expr)), thin_attrs))\n+                    };\n+\n+                    let err_pat = self.pat_err(try_span, err_local);\n+                    self.arm(hir_vec![err_pat], ret_expr)\n+                };\n+\n+                hir::ExprKind::Match(\n+                    discr,\n+                    hir_vec![err_arm, ok_arm],\n+                    hir::MatchSource::TryDesugar,\n+                )\n+            }\n+\n+            ExprKind::Mac(_) => panic!(\"Shouldn't exist here\"),\n+        };\n+\n+        hir::Expr {\n+            hir_id: self.lower_node_id(e.id),\n+            node: kind,\n+            span: e.span,\n+            attrs: e.attrs.clone(),\n+        }\n+    }\n+}"}]}