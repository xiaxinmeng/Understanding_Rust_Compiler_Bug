{"sha": "df2518955275c3a912dda8951a570abd2daddac4", "node_id": "C_kwDOAAsO6NoAKGRmMjUxODk1NTI3NWMzYTkxMmRkYTg5NTFhNTcwYWJkMmRhZGRhYzQ", "commit": {"author": {"name": "Takayuki Maeda", "email": "41065217+TaKO8Ki@users.noreply.github.com", "date": "2022-04-28T07:54:28Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2022-05-05T07:44:09Z"}, "message": "suggest calling `Self::associated_function()`\n\ndo not suggest when trait_ref is some\n\nUpdate compiler/rustc_resolve/src/late/diagnostics.rs\n\nCo-authored-by: lcnr <rust@lcnr.de>\n\nuse helper struct\n\nadd a test for functions with some params\n\nrefactor debug log", "tree": {"sha": "6711132bad50d62f49f9be2a09f46aa985aa7b91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6711132bad50d62f49f9be2a09f46aa985aa7b91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df2518955275c3a912dda8951a570abd2daddac4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df2518955275c3a912dda8951a570abd2daddac4", "html_url": "https://github.com/rust-lang/rust/commit/df2518955275c3a912dda8951a570abd2daddac4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df2518955275c3a912dda8951a570abd2daddac4/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99b70ee230a363220d97148d567f07366d7ea4e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/99b70ee230a363220d97148d567f07366d7ea4e0", "html_url": "https://github.com/rust-lang/rust/commit/99b70ee230a363220d97148d567f07366d7ea4e0"}], "stats": {"total": 181, "additions": 147, "deletions": 34}, "files": [{"sha": "ff2ab152ca43202a7eefe0ce51709a7523fd4440", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/df2518955275c3a912dda8951a570abd2daddac4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2518955275c3a912dda8951a570abd2daddac4/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=df2518955275c3a912dda8951a570abd2daddac4", "patch": "@@ -470,6 +470,9 @@ struct DiagnosticMetadata<'ast> {\n     current_where_predicate: Option<&'ast WherePredicate>,\n \n     current_type_path: Option<&'ast Ty>,\n+\n+    /// The current impl items (used to suggest).\n+    current_impl_items: Option<&'ast [P<AssocItem>]>,\n }\n \n struct LateResolutionVisitor<'a, 'b, 'ast> {\n@@ -1478,7 +1481,9 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 items: ref impl_items,\n                 ..\n             }) => {\n+                self.diagnostic_metadata.current_impl_items = Some(impl_items);\n                 self.resolve_implementation(generics, of_trait, &self_ty, item.id, impl_items);\n+                self.diagnostic_metadata.current_impl_items = None;\n             }\n \n             ItemKind::Trait(box Trait { ref generics, ref bounds, ref items, .. }) => {"}, {"sha": "82d2d9ce26eaa6c160c0e5515552956021914039", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 75, "deletions": 34, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/df2518955275c3a912dda8951a570abd2daddac4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2518955275c3a912dda8951a570abd2daddac4/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=df2518955275c3a912dda8951a570abd2daddac4", "patch": "@@ -6,7 +6,7 @@ use crate::path_names_to_string;\n use crate::{Finalize, Module, ModuleKind, ModuleOrUniformRoot};\n use crate::{PathResult, PathSource, Segment};\n \n-use rustc_ast::visit::FnKind;\n+use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast::{\n     self as ast, AssocItemKind, Expr, ExprKind, GenericParam, GenericParamKind, Item, ItemKind,\n     NodeId, Path, Ty, TyKind,\n@@ -144,15 +144,22 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         let is_enum_variant = &|res| matches!(res, Res::Def(DefKind::Variant, _));\n \n         // Make the base error.\n+        struct BaseError<'a> {\n+            msg: String,\n+            fallback_label: String,\n+            span: Span,\n+            could_be_expr: bool,\n+            suggestion: Option<(Span, &'a str, String)>,\n+        }\n         let mut expected = source.descr_expected();\n         let path_str = Segment::names_to_string(path);\n         let item_str = path.last().unwrap().ident;\n-        let (base_msg, fallback_label, base_span, could_be_expr) = if let Some(res) = res {\n-            (\n-                format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n-                format!(\"not a {}\", expected),\n+        let base_error = if let Some(res) = res {\n+            BaseError {\n+                msg: format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n+                fallback_label: format!(\"not a {expected}\"),\n                 span,\n-                match res {\n+                could_be_expr: match res {\n                     Res::Def(DefKind::Fn, _) => {\n                         // Verify whether this is a fn call or an Fn used as a type.\n                         self.r\n@@ -171,45 +178,78 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     | Res::Local(_) => true,\n                     _ => false,\n                 },\n-            )\n+                suggestion: None,\n+            }\n         } else {\n             let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str) = if path.len() == 1 {\n-                (String::new(), \"this scope\".to_string())\n+            let (mod_prefix, mod_str, suggestion) = if path.len() == 1 {\n+                debug!(?self.diagnostic_metadata.current_impl_items);\n+                debug!(?self.diagnostic_metadata.current_function);\n+                let suggestion = if let Some(items) = self.diagnostic_metadata.current_impl_items\n+                    && let Some((fn_kind, _)) = self.diagnostic_metadata.current_function\n+                    && self.current_trait_ref.is_none()\n+                    && let Some(FnCtxt::Assoc(_)) = fn_kind.ctxt()\n+                    && let Some(item) = items.iter().find(|i| {\n+                        if let AssocItemKind::Fn(fn_) = &i.kind\n+                            && !fn_.sig.decl.has_self()\n+                            && i.ident.name == item_str.name\n+                        {\n+                            debug!(?item_str.name);\n+                            debug!(?fn_.sig.decl.inputs);\n+                            return true\n+                        }\n+                        false\n+                    })\n+                {\n+                    Some((\n+                        item_span,\n+                        \"consider using the associated function\",\n+                        format!(\"Self::{}\", item.ident)\n+                    ))\n+                } else {\n+                    None\n+                };\n+                (String::new(), \"this scope\".to_string(), suggestion)\n             } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n                 if self.r.session.edition() > Edition::Edition2015 {\n                     // In edition 2018 onwards, the `::foo` syntax may only pull from the extern prelude\n                     // which overrides all other expectations of item type\n                     expected = \"crate\";\n-                    (String::new(), \"the list of imported crates\".to_string())\n+                    (String::new(), \"the list of imported crates\".to_string(), None)\n                 } else {\n-                    (String::new(), \"the crate root\".to_string())\n+                    (String::new(), \"the crate root\".to_string(), None)\n                 }\n             } else if path.len() == 2 && path[0].ident.name == kw::Crate {\n-                (String::new(), \"the crate root\".to_string())\n+                (String::new(), \"the crate root\".to_string(), None)\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n                 let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), Finalize::No) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n                     _ => None,\n                 }\n                 .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)), None)\n             };\n-            (\n-                format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                if path_str == \"async\" && expected.starts_with(\"struct\") {\n+            BaseError {\n+                msg: format!(\"cannot find {expected} `{item_str}` in {mod_prefix}{mod_str}\"),\n+                fallback_label: if path_str == \"async\" && expected.starts_with(\"struct\") {\n                     \"`async` blocks are only allowed in Rust 2018 or later\".to_string()\n                 } else {\n-                    format!(\"not found in {}\", mod_str)\n+                    format!(\"not found in {mod_str}\")\n                 },\n-                item_span,\n-                false,\n-            )\n+                span: item_span,\n+                could_be_expr: false,\n+                suggestion,\n+            }\n         };\n \n         let code = source.error_code(res.is_some());\n-        let mut err = self.r.session.struct_span_err_with_code(base_span, &base_msg, code);\n+        let mut err =\n+            self.r.session.struct_span_err_with_code(base_error.span, &base_error.msg, code);\n+\n+        if let Some(sugg) = base_error.suggestion {\n+            err.span_suggestion_verbose(sugg.0, sugg.1, sugg.2, Applicability::MaybeIncorrect);\n+        }\n \n         if let Some(span) = self.diagnostic_metadata.current_block_could_be_bare_struct_literal {\n             err.multipart_suggestion(\n@@ -269,7 +309,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n \n-        self.detect_assoct_type_constraint_meant_as_path(base_span, &mut err);\n+        self.detect_assoct_type_constraint_meant_as_path(base_error.span, &mut err);\n \n         // Emit special messages for unresolved `Self` and `self`.\n         if is_self_type(path, ns) {\n@@ -471,16 +511,17 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 source,\n                 res,\n                 &path_str,\n-                &fallback_label,\n+                &base_error.fallback_label,\n             ) {\n                 // We do this to avoid losing a secondary span when we override the main error span.\n                 self.r.add_typo_suggestion(&mut err, typo_sugg, ident_span);\n                 return (err, candidates);\n             }\n         }\n \n-        let is_macro = base_span.from_expansion() && base_span.desugaring_kind().is_none();\n-        if !self.type_ascription_suggestion(&mut err, base_span) {\n+        let is_macro =\n+            base_error.span.from_expansion() && base_error.span.desugaring_kind().is_none();\n+        if !self.type_ascription_suggestion(&mut err, base_error.span) {\n             let mut fallback = false;\n             if let (\n                 PathSource::Trait(AliasPossibility::Maybe),\n@@ -493,7 +534,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     let spans: Vec<Span> = bounds\n                         .iter()\n                         .map(|bound| bound.span())\n-                        .filter(|&sp| sp != base_span)\n+                        .filter(|&sp| sp != base_error.span)\n                         .collect();\n \n                     let start_span = bounds.iter().map(|bound| bound.span()).next().unwrap();\n@@ -515,7 +556,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         multi_span.push_span_label(sp, msg);\n                     }\n                     multi_span.push_span_label(\n-                        base_span,\n+                        base_error.span,\n                         \"expected this type to be a trait...\".to_string(),\n                     );\n                     err.span_help(\n@@ -525,14 +566,14 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                     );\n                     if bounds.iter().all(|bound| match bound {\n                         ast::GenericBound::Outlives(_) => true,\n-                        ast::GenericBound::Trait(tr, _) => tr.span == base_span,\n+                        ast::GenericBound::Trait(tr, _) => tr.span == base_error.span,\n                     }) {\n                         let mut sugg = vec![];\n-                        if base_span != start_span {\n-                            sugg.push((start_span.until(base_span), String::new()));\n+                        if base_error.span != start_span {\n+                            sugg.push((start_span.until(base_error.span), String::new()));\n                         }\n-                        if base_span != end_span {\n-                            sugg.push((base_span.shrink_to_hi().to(end_span), String::new()));\n+                        if base_error.span != end_span {\n+                            sugg.push((base_error.span.shrink_to_hi().to(end_span), String::new()));\n                         }\n \n                         err.multipart_suggestion(\n@@ -550,7 +591,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 fallback = true;\n                 match self.diagnostic_metadata.current_let_binding {\n                     Some((pat_sp, Some(ty_sp), None))\n-                        if ty_sp.contains(base_span) && could_be_expr =>\n+                        if ty_sp.contains(base_error.span) && base_error.could_be_expr =>\n                     {\n                         err.span_suggestion_short(\n                             pat_sp.between(ty_sp),\n@@ -568,7 +609,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             }\n             if fallback {\n                 // Fallback label.\n-                err.span_label(base_span, fallback_label);\n+                err.span_label(base_error.span, base_error.fallback_label);\n             }\n         }\n         if let Some(err_code) = &err.code {"}, {"sha": "b8d528efc15909eaf42223a3153e7c4cf8205898", "filename": "src/test/ui/resolve/issue-2356.stderr", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-2356.stderr?ref=df2518955275c3a912dda8951a570abd2daddac4", "patch": "@@ -48,6 +48,11 @@ error[E0425]: cannot find function `static_method` in this scope\n    |\n LL |         static_method();\n    |         ^^^^^^^^^^^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::static_method();\n+   |         ~~~~~~~~~~~~~~~~~~~\n \n error[E0425]: cannot find function `purr` in this scope\n   --> $DIR/issue-2356.rs:54:9\n@@ -85,6 +90,11 @@ error[E0425]: cannot find function `grow_older` in this scope\n    |\n LL |     grow_older();\n    |     ^^^^^^^^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |     Self::grow_older();\n+   |     ~~~~~~~~~~~~~~~~\n \n error[E0425]: cannot find function `shave` in this scope\n   --> $DIR/issue-2356.rs:74:5"}, {"sha": "778d9847773f35633b4db608c914835434c1ae11", "filename": "src/test/ui/suggestions/assoc_fn_without_self.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.rs?ref=df2518955275c3a912dda8951a570abd2daddac4", "patch": "@@ -0,0 +1,20 @@\n+fn main() {}\n+\n+struct S;\n+\n+impl S {\n+    fn foo() {}\n+\n+    fn bar(&self) {}\n+\n+    fn baz(a: u8, b: u8) {}\n+\n+    fn b() {\n+        fn c() {\n+            foo(); //~ ERROR cannot find function `foo` in this scope\n+        }\n+        foo(); //~ ERROR cannot find function `foo` in this scope\n+        bar(); //~ ERROR cannot find function `bar` in this scope\n+        baz(2, 3); //~ ERROR cannot find function `baz` in this scope\n+    }\n+}"}, {"sha": "4a0e62e73093b564c7c70a612e271dcc5d78c1ee", "filename": "src/test/ui/suggestions/assoc_fn_without_self.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/df2518955275c3a912dda8951a570abd2daddac4/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc_fn_without_self.stderr?ref=df2518955275c3a912dda8951a570abd2daddac4", "patch": "@@ -0,0 +1,37 @@\n+error[E0425]: cannot find function `foo` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:14:13\n+   |\n+LL |             foo();\n+   |             ^^^ not found in this scope\n+\n+error[E0425]: cannot find function `foo` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:16:9\n+   |\n+LL |         foo();\n+   |         ^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::foo();\n+   |         ~~~~~~~~~\n+\n+error[E0425]: cannot find function `bar` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:17:9\n+   |\n+LL |         bar();\n+   |         ^^^ not found in this scope\n+\n+error[E0425]: cannot find function `baz` in this scope\n+  --> $DIR/assoc_fn_without_self.rs:18:9\n+   |\n+LL |         baz(2, 3);\n+   |         ^^^ not found in this scope\n+   |\n+help: consider using the associated function\n+   |\n+LL |         Self::baz(2, 3);\n+   |         ~~~~~~~~~\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0425`."}]}