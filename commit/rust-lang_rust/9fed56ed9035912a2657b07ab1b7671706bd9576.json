{"sha": "9fed56ed9035912a2657b07ab1b7671706bd9576", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmZWQ1NmVkOTAzNTkxMmEyNjU3YjA3YWIxYjc2NzE3MDZiZDk1NzY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-17T14:13:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-18T02:45:45Z"}, "message": "When decoding types, indicate to the def-id conversion function what kind of\ndef-id we have, so that the inliner can distinguish between external and\ninternal def-ids.  Also add some comments explaining the distinction!\n\nFixes #4516.\n\nr=graydon", "tree": {"sha": "2d3baf85bb14086963376c7f156fcb9df4b84c62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3baf85bb14086963376c7f156fcb9df4b84c62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fed56ed9035912a2657b07ab1b7671706bd9576", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fed56ed9035912a2657b07ab1b7671706bd9576", "html_url": "https://github.com/rust-lang/rust/commit/9fed56ed9035912a2657b07ab1b7671706bd9576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fed56ed9035912a2657b07ab1b7671706bd9576/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7abdd38473ef2ef3fe50a0d234b8cd27fc53f0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7abdd38473ef2ef3fe50a0d234b8cd27fc53f0e", "html_url": "https://github.com/rust-lang/rust/commit/c7abdd38473ef2ef3fe50a0d234b8cd27fc53f0e"}], "stats": {"total": 165, "additions": 143, "deletions": 22}, "files": [{"sha": "8634cc7381890fc68b79a16749a00ce52a73cea1", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9fed56ed9035912a2657b07ab1b7671706bd9576", "patch": "@@ -264,9 +264,8 @@ fn variant_disr_val(d: ebml::Doc) -> Option<int> {\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx, |did| {\n-        translate_def_id(cdata, did)\n-    })\n+    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n+                  |_, did| translate_def_id(cdata, did))\n }\n \n fn item_type(item_id: ast::def_id, item: ebml::Doc,\n@@ -289,9 +288,8 @@ fn item_ty_param_bounds(item: ebml::Doc, tcx: ty::ctxt, cdata: cmd)\n     -> @~[ty::param_bounds] {\n     let mut bounds = ~[];\n     for reader::tagged_docs(item, tag_items_data_item_ty_param_bounds) |p| {\n-        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx, |did| {\n-            translate_def_id(cdata, did)\n-        });\n+        let bd = parse_bounds_data(p.data, p.start, cdata.cnum, tcx,\n+                                   |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n     }\n     @bounds"}, {"sha": "6a09ae14d01dc26b403d7f05a0a753cca2f4322a", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9fed56ed9035912a2657b07ab1b7671706bd9576", "patch": "@@ -33,13 +33,33 @@ export parse_state_from_data;\n export parse_arg_data, parse_ty_data, parse_def_id, parse_ident;\n export parse_bounds_data;\n export pstate;\n+export DefIdSource, NominalType, TypeWithId, TypeParameter;\n \n // Compact string representation for ty::t values. API ty_str &\n // parse_from_str. Extra parameters are for converting to/from def_ids in the\n // data buffer. Whatever format you choose should not contain pipe characters.\n \n-// Callback to translate defs to strs or back:\n-type conv_did = fn(ast::def_id) -> ast::def_id;\n+// Def id conversion: when we encounter def-ids, they have to be translated.\n+// For example, the crate number must be converted from the crate number used\n+// in the library we are reading from into the local crate numbers in use\n+// here.  To perform this translation, the type decoder is supplied with a\n+// conversion function of type `conv_did`.\n+//\n+// Sometimes, particularly when inlining, the correct translation of the\n+// def-id will depend on where it originated from.  Therefore, the conversion\n+// function is given an indicator of the source of the def-id.  See\n+// astencode.rs for more information.\n+enum DefIdSource {\n+    // Identifies a struct, trait, enum, etc.\n+    NominalType,\n+\n+    // Identifies a type alias (`type X = ...`).\n+    TypeWithId,\n+\n+    // Identifies a type parameter (`fn foo<X>() { ... }`).\n+    TypeParameter\n+}\n+type conv_did = fn(source: DefIdSource, ast::def_id) -> ast::def_id;\n \n type pstate = {data: @~[u8], crate: int, mut pos: uint, tcx: ty::ctxt};\n \n@@ -245,21 +265,21 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n       'c' => return ty::mk_char(st.tcx),\n       't' => {\n         assert (next(st) == '[');\n-        let def = parse_def(st, conv);\n+        let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         assert next(st) == ']';\n         return ty::mk_enum(st.tcx, def, substs);\n       }\n       'x' => {\n         assert next(st) == '[';\n-        let def = parse_def(st, conv);\n+        let def = parse_def(st, NominalType, conv);\n         let substs = parse_substs(st, conv);\n         let vstore = parse_vstore(st);\n         assert next(st) == ']';\n         return ty::mk_trait(st.tcx, def, substs, vstore);\n       }\n       'p' => {\n-        let did = parse_def(st, conv);\n+        let did = parse_def(st, TypeParameter, conv);\n         return ty::mk_param(st.tcx, parse_int(st) as uint, did);\n       }\n       's' => {\n@@ -327,17 +347,14 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n         }\n       }\n       '\"' => {\n-        let def = parse_def(st, conv);\n+        let def = parse_def(st, TypeWithId, conv);\n         let inner = parse_ty(st, conv);\n         ty::mk_with_id(st.tcx, inner, def)\n       }\n       'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n-          debug!(\"saw a class\");\n           assert (next(st) == '[');\n-          debug!(\"saw a [\");\n-          let did = parse_def(st, conv);\n-          debug!(\"parsed a def_id %?\", did);\n+          let did = parse_def(st, NominalType, conv);\n           let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n           return ty::mk_struct(st.tcx, did, substs);\n@@ -356,11 +373,12 @@ fn parse_mt(st: @pstate, conv: conv_did) -> ty::mt {\n     ty::mt { ty: parse_ty(st, conv), mutbl: m }\n }\n \n-fn parse_def(st: @pstate, conv: conv_did) -> ast::def_id {\n+fn parse_def(st: @pstate, source: DefIdSource,\n+             conv: conv_did) -> ast::def_id {\n     let mut def = ~[];\n     while peek(st) != '|' { def.push(next_byte(st)); }\n     st.pos = st.pos + 1u;\n-    return conv(parse_def_id(def));\n+    return conv(source, parse_def_id(def));\n }\n \n fn parse_int(st: @pstate) -> int {"}, {"sha": "aa98d19465a57209a094c373a7d8653eb7c3d948", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 71, "deletions": 4, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9fed56ed9035912a2657b07ab1b7671706bd9576", "patch": "@@ -17,6 +17,7 @@ use e = metadata::encoder;\n use metadata::decoder;\n use metadata::encoder;\n use metadata::tydecode;\n+use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n use metadata::tyencode;\n use middle::freevars::freevar_entry;\n use middle::typeck::{method_origin, method_map_entry, vtable_res};\n@@ -168,14 +169,55 @@ fn reserve_id_range(sess: Session,\n \n impl extended_decode_ctxt {\n     fn tr_id(id: ast::node_id) -> ast::node_id {\n+        /*!\n+         *\n+         * Translates an internal id, meaning a node id that is known\n+         * to refer to some part of the item currently being inlined,\n+         * such as a local variable or argument.  All naked node-ids\n+         * that appear in types have this property, since if something\n+         * might refer to an external item we would use a def-id to\n+         * allow for the possibility that the item resides in another\n+         * crate.\n+         */\n+\n         // from_id_range should be non-empty\n         assert !ast_util::empty(self.from_id_range);\n         (id - self.from_id_range.min + self.to_id_range.min)\n     }\n     fn tr_def_id(did: ast::def_id) -> ast::def_id {\n+        /*!\n+         *\n+         * Translates an EXTERNAL def-id, converting the crate number\n+         * from the one used in the encoded data to the current crate\n+         * numbers..  By external, I mean that it be translated to a\n+         * reference to the item in its original crate, as opposed to\n+         * being translated to a reference to the inlined version of\n+         * the item.  This is typically, but not always, what you\n+         * want, because most def-ids refer to external things like\n+         * types or other fns that may or may not be inlined.  Note\n+         * that even when the inlined function is referencing itself\n+         * recursively, we would want `tr_def_id` for that\n+         * reference--- conceptually the function calls the original,\n+         * non-inlined version, and trans deals with linking that\n+         * recursive call to the inlined copy.\n+         *\n+         * However, there are a *few* cases where def-ids are used but\n+         * we know that the thing being referenced is in fact *internal*\n+         * to the item being inlined.  In those cases, you should use\n+         * `tr_intern_def_id()` below.\n+         */\n+\n         decoder::translate_def_id(self.dcx.cdata, did)\n     }\n     fn tr_intern_def_id(did: ast::def_id) -> ast::def_id {\n+        /*!\n+         *\n+         * Translates an INTERNAL def-id, meaning a def-id that is\n+         * known to refer to some part of the item currently being\n+         * inlined.  In that case, we want to convert the def-id to\n+         * refer to the current crate and to the new, inlined node-id.\n+         */\n+\n         assert did.crate == ast::local_crate;\n         ast::def_id { crate: ast::local_crate, node: self.tr_id(did.node) }\n     }\n@@ -906,15 +948,17 @@ trait ebml_decoder_decoder_helpers {\n     fn read_bounds(xcx: extended_decode_ctxt) -> @~[ty::param_bound];\n     fn read_ty_param_bounds_and_ty(xcx: extended_decode_ctxt)\n                                 -> ty::ty_param_bounds_and_ty;\n+    fn convert_def_id(xcx: extended_decode_ctxt,\n+                      source: DefIdSource,\n+                      did: ast::def_id) -> ast::def_id;\n }\n \n impl reader::Decoder: ebml_decoder_decoder_helpers {\n-\n     fn read_arg(xcx: extended_decode_ctxt) -> ty::arg {\n         do self.read_opaque |doc| {\n             tydecode::parse_arg_data(\n                 doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |a| xcx.tr_def_id(a))\n+                |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n@@ -927,7 +971,7 @@ impl reader::Decoder: ebml_decoder_decoder_helpers {\n         do self.read_opaque |doc| {\n             tydecode::parse_ty_data(\n                 doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n-                |a| xcx.tr_def_id(a))\n+                |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n@@ -939,7 +983,7 @@ impl reader::Decoder: ebml_decoder_decoder_helpers {\n         do self.read_opaque |doc| {\n             tydecode::parse_bounds_data(\n                 doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n-                |a| xcx.tr_def_id(a))\n+                |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n@@ -960,6 +1004,29 @@ impl reader::Decoder: ebml_decoder_decoder_helpers {\n             }\n         }\n     }\n+\n+    fn convert_def_id(xcx: extended_decode_ctxt,\n+                      source: tydecode::DefIdSource,\n+                      did: ast::def_id) -> ast::def_id {\n+        /*!\n+         *\n+         * Converts a def-id that appears in a type.  The correct\n+         * translation will depend on what kind of def-id this is.\n+         * This is a subtle point: type definitions are not\n+         * inlined into the current crate, so if the def-id names\n+         * a nominal type or type alias, then it should be\n+         * translated to refer to the source crate.\n+         *\n+         * However, *type parameters* are cloned along with the function\n+         * they are attached to.  So we should translate those def-ids\n+         * to refer to the new, cloned copy of the type parameter.\n+         */\n+\n+        match source {\n+            NominalType | TypeWithId => xcx.tr_def_id(did),\n+            TypeParameter => xcx.tr_intern_def_id(did)\n+        }\n+    }\n }\n \n fn decode_side_tables(xcx: extended_decode_ctxt,"}, {"sha": "3f93540e64f62c42792b967f969792e888e807d8", "filename": "src/test/auxiliary/issue4516_ty_param_lib.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue4516_ty_param_lib.rs?ref=9fed56ed9035912a2657b07ab1b7671706bd9576", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn to_closure<A: Durable Copy>(x: A) -> @fn() -> A {\n+    fn@() -> A { copy x }\n+}\n\\ No newline at end of file"}, {"sha": "279766d9bbfe1ac84885d032fb6b3a344f7d1066", "filename": "src/test/run-pass/issue4516_ty_param.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fed56ed9035912a2657b07ab1b7671706bd9576/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue4516_ty_param.rs?ref=9fed56ed9035912a2657b07ab1b7671706bd9576", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// xfail-fast - check-fast doesn't understand aux-build\n+// aux-build:issue4516_ty_param_lib.rs\n+\n+// Trigger a bug concerning inlining of generic functions.\n+// The def-ids in type parameters were not being correctly\n+// resolved and hence when we checked the type of the closure\n+// variable (see the library mod) to determine if the value\n+// should be moved into the closure, trans failed to find\n+// the relevant kind bounds.\n+\n+extern mod issue4516_ty_param_lib;\n+use issue4516_ty_param_lib::to_closure;\n+fn main() {\n+    to_closure(22)();\n+}"}]}