{"sha": "9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "node_id": "C_kwDOAAsO6NoAKDlmM2I2ZTlhY2QzNjdiNTNiODAwMzFhZjdlOGI2MTIyNmIxZWFhYmM", "commit": {"author": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-11-16T05:31:07Z"}, "committer": {"name": "Kartavya Vashishtha", "email": "sendtokartavya@gmail.com", "date": "2022-11-16T05:31:07Z"}, "message": "don't emit AlwaysBreaks if it targets a block\n\nIntroduced an ignored_ids parameter.\nTakes O(n^2) time in the worst case.\n\nCan be changed to collect block ids in first phase,\nand then filter with binary search in second.", "tree": {"sha": "45f9012c257b1d2e9b63c7e18c9d33f0579c27de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45f9012c257b1d2e9b63c7e18c9d33f0579c27de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE+fRQYdEX7Emd36W/pQASwjJOXfAFAmN0dZ0ACgkQpQASwjJO\nXfBCKQ/7BvdpO0OJlc/4ShLtELQlp+kPXTujDT4mwTARkc5RZl5+XBIdn3v4+AlP\nrRIIHx0tZkiHJVfb+7Jsuu+aWJ3oSIRa0Eq6mUN2YC2rBzSL09lLQFHKtoQS7pmW\nu8VV8V23vZF2aq7qtToFvIXlzCtOIbMIBY+zi6xnAFU5vvJ5SbTKGIDqO75sEnsb\nhvYanCDefL5G+R6YxWUP1A5Oqy8rskvXynb4x0L316VnZU5YTHHRA/HByJwXWrcV\n55cS8OWo9rd7tDMxoJdxGgjT2bJS0C+/AH78Zb8LiV9Tv9clgE0QKmvG1C+j/t2c\nMScP2ifnsYAWTUdGegiGBfaf8NL5gw1i//0bBf3p/VNZdC625QVFYT+pjowS4SN+\n1XKsuKwoSVUylCc3zsUDHv1lY5B646llPZBuPzwJLuYQmzbaAEzw6h+wBGum0dLc\nzBj2fa2Bxq9UJ/Y/n67KCwXDt92pqQKkI//ij3tdD5EfEy//C4YEeyy+CUei4Q0V\nhH+J9ZQ0DAOvKVNxPW/tGxepIuOYBVEgBe3tCkVCZzEVROQnM9xHYBI4gh5CXVva\n47B71srYdd3Phm2+SLvQ+fhO3g+3vcr6glEfpu8msucl6HUWe2HBqedvIBOXNFFv\nK6KLfae/oyQzIrtbQ9of1jSk5bxdlK4+i4+nDRmjOn14GZN21YE=\n=zCwu\n-----END PGP SIGNATURE-----", "payload": "tree 45f9012c257b1d2e9b63c7e18c9d33f0579c27de\nparent 989986144c889051eb3014cc1fdc0891bbb483f5\nauthor Kartavya Vashishtha <sendtokartavya@gmail.com> 1668576667 +0530\ncommitter Kartavya Vashishtha <sendtokartavya@gmail.com> 1668576667 +0530\n\ndon't emit AlwaysBreaks if it targets a block\n\nIntroduced an ignored_ids parameter.\nTakes O(n^2) time in the worst case.\n\nCan be changed to collect block ids in first phase,\nand then filter with binary search in second.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "html_url": "https://github.com/rust-lang/rust/commit/9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f3b6e9acd367b53b80031af7e8b61226b1eaabc/comments", "author": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DesmondWillowbrook", "id": 51814158, "node_id": "MDQ6VXNlcjUxODE0MTU4", "avatar_url": "https://avatars.githubusercontent.com/u/51814158?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DesmondWillowbrook", "html_url": "https://github.com/DesmondWillowbrook", "followers_url": "https://api.github.com/users/DesmondWillowbrook/followers", "following_url": "https://api.github.com/users/DesmondWillowbrook/following{/other_user}", "gists_url": "https://api.github.com/users/DesmondWillowbrook/gists{/gist_id}", "starred_url": "https://api.github.com/users/DesmondWillowbrook/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DesmondWillowbrook/subscriptions", "organizations_url": "https://api.github.com/users/DesmondWillowbrook/orgs", "repos_url": "https://api.github.com/users/DesmondWillowbrook/repos", "events_url": "https://api.github.com/users/DesmondWillowbrook/events{/privacy}", "received_events_url": "https://api.github.com/users/DesmondWillowbrook/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "989986144c889051eb3014cc1fdc0891bbb483f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/989986144c889051eb3014cc1fdc0891bbb483f5", "html_url": "https://github.com/rust-lang/rust/commit/989986144c889051eb3014cc1fdc0891bbb483f5"}], "stats": {"total": 124, "additions": 79, "deletions": 45}, "files": [{"sha": "123e1e3cce15ab5df9adf201025b54fe81ad1dd4", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 69, "deletions": 44, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9f3b6e9acd367b53b80031af7e8b61226b1eaabc/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3b6e9acd367b53b80031af7e8b61226b1eaabc/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n+use rustc_hir::{Block, Destination, Expr, ExprKind, HirId, InlineAsmOperand, Pat, Stmt, StmtKind};\n use rustc_lint::LateContext;\n use rustc_span::Span;\n use std::iter::{once, Iterator};\n@@ -16,7 +16,7 @@ pub(super) fn check(\n     span: Span,\n     for_loop: Option<&ForLoop<'_>>,\n ) {\n-    match never_loop_block(block, loop_id) {\n+    match never_loop_block(block, &mut Vec::new(), loop_id) {\n         NeverLoopResult::AlwaysBreak => {\n             span_lint_and_then(cx, NEVER_LOOP, span, \"this loop never actually loops\", |diag| {\n                 if let Some(ForLoop {\n@@ -92,35 +92,33 @@ fn combine_branches(b1: NeverLoopResult, b2: NeverLoopResult) -> NeverLoopResult\n     }\n }\n \n-fn never_loop_block(block: &Block<'_>, main_loop_id: HirId) -> NeverLoopResult {\n-    let mut iter = block\n+fn never_loop_block(block: &Block<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n+    let iter = block\n         .stmts\n         .iter()\n         .filter_map(stmt_to_expr)\n         .chain(block.expr.map(|expr| (expr, None)));\n-    never_loop_expr_seq(&mut iter, main_loop_id)\n-}\n \n-fn never_loop_expr_seq<'a, T: Iterator<Item = (&'a Expr<'a>, Option<&'a Block<'a>>)>>(\n-    es: &mut T,\n-    main_loop_id: HirId,\n-) -> NeverLoopResult {\n-    es.map(|(e, els)| {\n-        let e = never_loop_expr(e, main_loop_id);\n-        els.map_or(e, |els| combine_branches(e, never_loop_block(els, main_loop_id)))\n+    iter.map(|(e, els)| {\n+        let e = never_loop_expr(e, ignore_ids, main_loop_id);\n+        // els is an else block in a let...else binding\n+        els.map_or(e, |els| {\n+            combine_branches(e, never_loop_block(els, ignore_ids, main_loop_id))\n+        })\n     })\n     .fold(NeverLoopResult::Otherwise, combine_seq)\n }\n \n fn stmt_to_expr<'tcx>(stmt: &Stmt<'tcx>) -> Option<(&'tcx Expr<'tcx>, Option<&'tcx Block<'tcx>>)> {\n     match stmt.kind {\n-        StmtKind::Semi(e, ..) | StmtKind::Expr(e, ..) => Some((e, None)),\n+        StmtKind::Semi(e) | StmtKind::Expr(e) => Some((e, None)),\n+        // add the let...else expression (if present)\n         StmtKind::Local(local) => local.init.map(|init| (init, local.els)),\n         StmtKind::Item(..) => None,\n     }\n }\n \n-fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n+fn never_loop_expr(expr: &Expr<'_>, ignore_ids: &mut Vec<HirId>, main_loop_id: HirId) -> NeverLoopResult {\n     match expr.kind {\n         ExprKind::Box(e)\n         | ExprKind::Unary(_, e)\n@@ -129,48 +127,56 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Repeat(e, _)\n-        | ExprKind::DropTemps(e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, main_loop_id),\n-        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), main_loop_id),\n-        ExprKind::MethodCall(_, receiver, es, _) => {\n-            never_loop_expr_all(&mut std::iter::once(receiver).chain(es.iter()), main_loop_id)\n-        },\n+        | ExprKind::DropTemps(e) => never_loop_expr(e, ignore_ids, main_loop_id),\n+        ExprKind::Let(let_expr) => never_loop_expr(let_expr.init, ignore_ids, main_loop_id),\n+        ExprKind::Array(es) | ExprKind::Tup(es) => never_loop_expr_all(&mut es.iter(), ignore_ids, main_loop_id),\n+        ExprKind::MethodCall(_, receiver, es, _) => never_loop_expr_all(\n+            &mut std::iter::once(receiver).chain(es.iter()),\n+            ignore_ids,\n+            main_loop_id,\n+        ),\n         ExprKind::Struct(_, fields, base) => {\n-            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), main_loop_id);\n+            let fields = never_loop_expr_all(&mut fields.iter().map(|f| f.expr), ignore_ids, main_loop_id);\n             if let Some(base) = base {\n-                combine_both(fields, never_loop_expr(base, main_loop_id))\n+                combine_both(fields, never_loop_expr(base, ignore_ids, main_loop_id))\n             } else {\n                 fields\n             }\n         },\n-        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), main_loop_id),\n+        ExprKind::Call(e, es) => never_loop_expr_all(&mut once(e).chain(es.iter()), ignore_ids, main_loop_id),\n         ExprKind::Binary(_, e1, e2)\n         | ExprKind::Assign(e1, e2, _)\n         | ExprKind::AssignOp(_, e1, e2)\n-        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), main_loop_id),\n+        | ExprKind::Index(e1, e2) => never_loop_expr_all(&mut [e1, e2].iter().copied(), ignore_ids, main_loop_id),\n         ExprKind::Loop(b, _, _, _) => {\n             // Break can come from the inner loop so remove them.\n-            absorb_break(never_loop_block(b, main_loop_id))\n+            absorb_break(never_loop_block(b, ignore_ids, main_loop_id))\n         },\n         ExprKind::If(e, e2, e3) => {\n-            let e1 = never_loop_expr(e, main_loop_id);\n-            let e2 = never_loop_expr(e2, main_loop_id);\n-            let e3 = e3\n-                .as_ref()\n-                .map_or(NeverLoopResult::Otherwise, |e| never_loop_expr(e, main_loop_id));\n+            let e1 = never_loop_expr(e, ignore_ids, main_loop_id);\n+            let e2 = never_loop_expr(e2, ignore_ids, main_loop_id);\n+            let e3 = e3.as_ref().map_or(NeverLoopResult::Otherwise, |e| {\n+                never_loop_expr(e, ignore_ids, main_loop_id)\n+            });\n             combine_seq(e1, combine_branches(e2, e3))\n         },\n         ExprKind::Match(e, arms, _) => {\n-            let e = never_loop_expr(e, main_loop_id);\n+            let e = never_loop_expr(e, ignore_ids, main_loop_id);\n             if arms.is_empty() {\n                 e\n             } else {\n-                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), main_loop_id);\n+                let arms = never_loop_expr_branch(&mut arms.iter().map(|a| a.body), ignore_ids, main_loop_id);\n                 combine_seq(e, arms)\n             }\n         },\n-        ExprKind::Block(b, None) => never_loop_block(b, main_loop_id),\n-        ExprKind::Block(b, Some(_label)) => absorb_break(never_loop_block(b, main_loop_id)),\n+        ExprKind::Block(b, l) => {\n+            if let Some(_) = l {\n+                ignore_ids.push(b.hir_id);\n+            }\n+            let ret = never_loop_block(b, ignore_ids, main_loop_id);\n+            ignore_ids.pop();\n+            ret\n+        },\n         ExprKind::Continue(d) => {\n             let id = d\n                 .target_id\n@@ -181,20 +187,31 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n+        ExprKind::Break(Destination { target_id: Ok(t), .. }, e) if ignore_ids.contains(&t) => e\n+            .map_or(NeverLoopResult::Otherwise, |e| {\n+                combine_seq(never_loop_expr(e, ignore_ids, main_loop_id), NeverLoopResult::Otherwise)\n+            }),\n         ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n-            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+            combine_seq(\n+                never_loop_expr(e, ignore_ids, main_loop_id),\n+                NeverLoopResult::AlwaysBreak,\n+            )\n         }),\n         ExprKind::InlineAsm(asm) => asm\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n                 InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n-                    never_loop_expr(expr, main_loop_id)\n+                    never_loop_expr(expr, ignore_ids, main_loop_id)\n                 },\n-                InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter().copied(), main_loop_id),\n-                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                    never_loop_expr_all(&mut once(*in_expr).chain(out_expr.iter().copied()), main_loop_id)\n+                InlineAsmOperand::Out { expr, .. } => {\n+                    never_loop_expr_all(&mut expr.iter().copied(), ignore_ids, main_loop_id)\n                 },\n+                InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => never_loop_expr_all(\n+                    &mut once(*in_expr).chain(out_expr.iter().copied()),\n+                    ignore_ids,\n+                    main_loop_id,\n+                ),\n                 InlineAsmOperand::Const { .. }\n                 | InlineAsmOperand::SymFn { .. }\n                 | InlineAsmOperand::SymStatic { .. } => NeverLoopResult::Otherwise,\n@@ -209,13 +226,21 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n     }\n }\n \n-fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(es: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    es.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_all<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    es: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    es.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::Otherwise, combine_both)\n }\n \n-fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(e: &mut T, main_loop_id: HirId) -> NeverLoopResult {\n-    e.map(|e| never_loop_expr(e, main_loop_id))\n+fn never_loop_expr_branch<'a, T: Iterator<Item = &'a Expr<'a>>>(\n+    e: &mut T,\n+    ignore_ids: &mut Vec<HirId>,\n+    main_loop_id: HirId,\n+) -> NeverLoopResult {\n+    e.map(|e| never_loop_expr(e, ignore_ids, main_loop_id))\n         .fold(NeverLoopResult::AlwaysBreak, combine_branches)\n }\n "}, {"sha": "28e8f459d4429cae47078cd349795a6509b17045", "filename": "tests/ui/never_loop.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f3b6e9acd367b53b80031af7e8b61226b1eaabc/tests%2Fui%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f3b6e9acd367b53b80031af7e8b61226b1eaabc/tests%2Fui%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnever_loop.rs?ref=9f3b6e9acd367b53b80031af7e8b61226b1eaabc", "patch": "@@ -234,13 +234,22 @@ pub fn test19() {\n     fn thing(iter: impl Iterator) {\n         for _ in iter {\n             'b: {\n-                // error goes away if we just have the block's value be ().\n                 break 'b;\n             }\n         }\n     }\n }\n \n+pub fn test20() {\n+    'a: loop {\n+        'b: {\n+            break 'b 'c: {\n+                break 'a;\n+            };\n+        }\n+    }\n+}\n+\n fn main() {\n     test1();\n     test2();"}]}