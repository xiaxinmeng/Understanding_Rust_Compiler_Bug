{"sha": "33a2191d0b880242b3bf9a32477a6b432f931c80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYTIxOTFkMGI4ODAyNDJiM2JmOWEzMjQ3N2E2YjQzMmY5MzFjODA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-03T22:34:15Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-10T00:09:37Z"}, "message": "std: Clean up process spawn impl on unix\n\n* De-indent quite a bit by removing usage of FnOnce closures\n* Clearly separate code for the parent/child after the fork\n* Use `fs2::{File, OpenOptions}` instead of calling `open` manually\n* Use RAII to close I/O objects wherever possible\n* Remove loop for closing all file descriptors, all our own ones are now\n  `CLOEXEC` by default so they cannot be inherited", "tree": {"sha": "1a03accf8685cbaeefdde4a93cdb70ea2532a71c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a03accf8685cbaeefdde4a93cdb70ea2532a71c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33a2191d0b880242b3bf9a32477a6b432f931c80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33a2191d0b880242b3bf9a32477a6b432f931c80", "html_url": "https://github.com/rust-lang/rust/commit/33a2191d0b880242b3bf9a32477a6b432f931c80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33a2191d0b880242b3bf9a32477a6b432f931c80/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6c72306c8fc2ec0fd9d6e499c32f2bf52f0b8ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6c72306c8fc2ec0fd9d6e499c32f2bf52f0b8ba", "html_url": "https://github.com/rust-lang/rust/commit/d6c72306c8fc2ec0fd9d6e499c32f2bf52f0b8ba"}], "stats": {"total": 464, "additions": 214, "deletions": 250}, "files": [{"sha": "9929593ffcb47401e550300e60163c6a48c721c4", "filename": "src/libstd/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -340,7 +340,7 @@ fn setup_io(io: &StdioImp, fd: libc::c_int, readable: bool)\n             (Some(AnonPipe::from_fd(fd)), None)\n         }\n         Piped => {\n-            let (reader, writer) = try!(unsafe { pipe2::anon_pipe() });\n+            let (reader, writer) = try!(pipe2::anon_pipe());\n             if readable {\n                 (Some(reader), Some(writer))\n             } else {"}, {"sha": "aa4bf821207648a3c4fe7cab02c37115bc2bae81", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -159,6 +159,8 @@ extern {\n     pub fn utimes(filename: *const libc::c_char,\n                   times: *const libc::timeval) -> libc::c_int;\n     pub fn gai_strerror(errcode: libc::c_int) -> *const libc::c_char;\n+    pub fn setgroups(ngroups: libc::c_int,\n+                     ptr: *const libc::c_void) -> libc::c_int;\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]"}, {"sha": "ac121f1c82e09ddedade920cbea8f2e6a8300935", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -205,13 +205,17 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n+        let path = try!(cstr(path));\n+        File::open_c(&path, opts)\n+    }\n+\n+    pub fn open_c(path: &CStr, opts: &OpenOptions) -> io::Result<File> {\n         let flags = opts.flags | match (opts.read, opts.write) {\n             (true, true) => libc::O_RDWR,\n             (false, true) => libc::O_WRONLY,\n             (true, false) |\n             (false, false) => libc::O_RDONLY,\n         };\n-        let path = try!(cstr(path));\n         let fd = try!(cvt_r(|| unsafe {\n             libc::open(path.as_ptr(), flags, opts.mode)\n         }));\n@@ -220,6 +224,8 @@ impl File {\n         Ok(File(fd))\n     }\n \n+    pub fn into_fd(self) -> FileDesc { self.0 }\n+\n     pub fn file_attr(&self) -> io::Result<FileAttr> {\n         let mut stat: libc::stat = unsafe { mem::zeroed() };\n         try!(cvt(unsafe { libc::fstat(self.0.raw(), &mut stat) }));"}, {"sha": "e9d8c69fefb52035cbdb2a341211dcbf76ccab48", "filename": "src/libstd/sys/unix/pipe2.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe2.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -20,11 +20,10 @@ use libc;\n \n pub struct AnonPipe(FileDesc);\n \n-pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     let mut fds = [0; 2];\n-    if libc::pipe(fds.as_mut_ptr()) == 0 {\n-        Ok((AnonPipe::from_fd(fds[0]),\n-            AnonPipe::from_fd(fds[1])))\n+    if unsafe { libc::pipe(fds.as_mut_ptr()) == 0 } {\n+        Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n     } else {\n         Err(io::Error::last_os_error())\n     }\n@@ -45,7 +44,7 @@ impl AnonPipe {\n         self.0.write(buf)\n     }\n \n-    pub fn raw(&self) -> libc::c_int {\n-        self.0.raw()\n+    pub fn into_fd(self) -> FileDesc {\n+        self.0\n     }\n }"}, {"sha": "dc6897fec8e3165e1abfb3db99c8cb5c8b8907ef", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 189, "deletions": 234, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -13,14 +13,14 @@ use os::unix::prelude::*;\n \n use collections::HashMap;\n use env;\n-use ffi::{OsString, OsStr, CString};\n+use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n use io::{self, Error, ErrorKind};\n use libc::{self, pid_t, c_void, c_int, gid_t, uid_t};\n-use mem;\n use ptr;\n use sys::pipe2::AnonPipe;\n use sys::{self, retry, c, cvt};\n+use sys::fs2::{File, OpenOptions};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -128,221 +128,178 @@ impl Process {\n     }\n \n     pub fn spawn(cfg: &Command,\n-                 in_fd: Option<AnonPipe>, out_fd: Option<AnonPipe>, err_fd: Option<AnonPipe>)\n-                 -> io::Result<Process>\n-    {\n-        use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-\n-        mod rustrt {\n-            extern {\n-                pub fn rust_unset_sigprocmask();\n+                 in_fd: Option<AnonPipe>,\n+                 out_fd: Option<AnonPipe>,\n+                 err_fd: Option<AnonPipe>) -> io::Result<Process> {\n+        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n+\n+        let (envp, _a, _b) = make_envp(cfg.env.as_ref());\n+        let (argv, _a) = make_argv(&cfg.program, &cfg.args);\n+        let (input, output) = try!(sys::pipe2::anon_pipe());\n+\n+        let pid = unsafe {\n+            match libc::fork() {\n+                0 => {\n+                    drop(input);\n+                    Process::child_after_fork(cfg, output, argv, envp, dirp,\n+                                              in_fd, out_fd, err_fd)\n+                }\n+                n if n < 0 => return Err(Error::last_os_error()),\n+                n => n,\n+            }\n+        };\n+\n+        let p = Process{ pid: pid };\n+        drop(output);\n+        let mut bytes = [0; 8];\n+\n+        // loop to handle EINTR\n+        loop {\n+            match input.read(&mut bytes) {\n+                Ok(0) => return Ok(p),\n+                Ok(8) => {\n+                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                    let errno = combine(&bytes[0.. 4]);\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    return Err(Error::from_raw_os_error(errno))\n+                }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => {\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                },\n+                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"short read on the CLOEXEC pipe\")\n+                }\n             }\n         }\n \n-        unsafe fn set_cloexec(fd: c_int) {\n-            let ret = c::ioctl(fd, c::FIOCLEX);\n-            assert_eq!(ret, 0);\n-        }\n+        fn combine(arr: &[u8]) -> i32 {\n+            let a = arr[0] as u32;\n+            let b = arr[1] as u32;\n+            let c = arr[2] as u32;\n+            let d = arr[3] as u32;\n \n-        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n+            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n         }\n+    }\n \n-        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n-        unsafe fn getdtablesize() -> c_int {\n-            libc::funcs::bsd44::getdtablesize()\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke libc::exit)\n+    unsafe fn child_after_fork(cfg: &Command,\n+                               mut output: AnonPipe,\n+                               argv: *const *const libc::c_char,\n+                               envp: *const libc::c_void,\n+                               dirp: *const libc::c_char,\n+                               in_fd: Option<AnonPipe>,\n+                               out_fd: Option<AnonPipe>,\n+                               err_fd: Option<AnonPipe>) -> ! {\n+        fn fail(output: &mut AnonPipe) -> ! {\n+            let errno = sys::os::errno() as u32;\n+            let bytes = [\n+                (errno >> 24) as u8,\n+                (errno >> 16) as u8,\n+                (errno >>  8) as u8,\n+                (errno >>  0) as u8,\n+                CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+            ];\n+            // pipe I/O up to PIPE_BUF bytes should be atomic, and then we want\n+            // to be sure we *don't* run at_exit destructors as we're being torn\n+            // down regardless\n+            assert!(output.write(&bytes).is_ok());\n+            unsafe { libc::_exit(1) }\n         }\n \n-        let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n-\n-        with_envp(cfg.env.as_ref(), |envp: *const c_void| {\n-            with_argv(&cfg.program, &cfg.args, |argv: *const *const libc::c_char| unsafe {\n-                let (input, mut output) = try!(sys::pipe2::anon_pipe());\n-\n-                // We may use this in the child, so perform allocations before the\n-                // fork\n-                let devnull = b\"/dev/null\\0\";\n-\n-                set_cloexec(output.raw());\n-\n-                let pid = fork();\n-                if pid < 0 {\n-                    return Err(Error::last_os_error())\n-                } else if pid > 0 {\n-                    #[inline]\n-                    fn combine(arr: &[u8]) -> i32 {\n-                        let a = arr[0] as u32;\n-                        let b = arr[1] as u32;\n-                        let c = arr[2] as u32;\n-                        let d = arr[3] as u32;\n-\n-                        ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-                    }\n-\n-                    let p = Process{ pid: pid };\n-                    drop(output);\n-                    let mut bytes = [0; 8];\n-\n-                    // loop to handle EINTER\n-                    loop {\n-                        match input.read(&mut bytes) {\n-                            Ok(8) => {\n-                                assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                                        \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                                let errno = combine(&bytes[0.. 4]);\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                return Err(Error::from_raw_os_error(errno))\n-                            }\n-                            Ok(0) => return Ok(p),\n-                            Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                            Err(e) => {\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                            },\n-                            Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                                assert!(p.wait().is_ok(),\n-                                        \"wait() should either return Ok or panic\");\n-                                panic!(\"short read on the CLOEXEC pipe\")\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // And at this point we've reached a special time in the life of the\n-                // child. The child must now be considered hamstrung and unable to\n-                // do anything other than syscalls really. Consider the following\n-                // scenario:\n-                //\n-                //      1. Thread A of process 1 grabs the malloc() mutex\n-                //      2. Thread B of process 1 forks(), creating thread C\n-                //      3. Thread C of process 2 then attempts to malloc()\n-                //      4. The memory of process 2 is the same as the memory of\n-                //         process 1, so the mutex is locked.\n-                //\n-                // This situation looks a lot like deadlock, right? It turns out\n-                // that this is what pthread_atfork() takes care of, which is\n-                // presumably implemented across platforms. The first thing that\n-                // threads to *before* forking is to do things like grab the malloc\n-                // mutex, and then after the fork they unlock it.\n-                //\n-                // Despite this information, libnative's spawn has been witnessed to\n-                // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-                // all collected backtraces point at malloc/free traffic in the\n-                // child spawned process.\n-                //\n-                // For this reason, the block of code below should contain 0\n-                // invocations of either malloc of free (or their related friends).\n-                //\n-                // As an example of not having malloc/free traffic, we don't close\n-                // this file descriptor by dropping the FileDesc (which contains an\n-                // allocation). Instead we just close it manually. This will never\n-                // have the drop glue anyway because this code never returns (the\n-                // child will either exec() or invoke libc::exit)\n-                let _ = libc::close(input.raw());\n-\n-                fn fail(output: &mut AnonPipe) -> ! {\n-                    let errno = sys::os::errno() as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(output.write(&bytes).is_ok());\n-                    unsafe { libc::_exit(1) }\n-                }\n-\n-                rustrt::rust_unset_sigprocmask();\n-\n-                // If a stdio file descriptor is set to be ignored, we don't\n-                // actually close it, but rather open up /dev/null into that\n-                // file descriptor. Otherwise, the first file descriptor opened\n-                // up in the child would be numbered as one of the stdio file\n-                // descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<AnonPipe>, dst: c_int| {\n-                    let src = match src {\n-                        None => {\n-                            let flags = if dst == libc::STDIN_FILENO {\n-                                libc::O_RDONLY\n-                            } else {\n-                                libc::O_RDWR\n-                            };\n-                            libc::open(devnull.as_ptr() as *const _, flags, 0)\n-                        }\n-                        Some(obj) => {\n-                            let fd = obj.raw();\n-                            // Leak the memory and the file descriptor. We're in the\n-                            // child now an all our resources are going to be\n-                            // cleaned up very soon\n-                            mem::forget(obj);\n-                            fd\n-                        }\n-                    };\n-                    src != -1 && retry(|| dup2(src, dst)) != -1\n-                };\n-\n-                if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n-                if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n-                if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n-\n-                // close all other fds\n-                for fd in (3..getdtablesize()).rev() {\n-                    if fd != output.raw() {\n-                        let _ = close(fd as c_int);\n-                    }\n-                }\n-\n-                match cfg.gid {\n-                    Some(u) => {\n-                        if libc::setgid(u as libc::gid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                match cfg.uid {\n-                    Some(u) => {\n-                        // When dropping privileges from root, the `setgroups` call\n-                        // will remove any extraneous groups. If we don't call this,\n-                        // then even though our uid has dropped, we may still have\n-                        // groups that enable us to do super-user things. This will\n-                        // fail if we aren't root, so don't bother checking the\n-                        // return value, this is just done as an optimistic\n-                        // privilege dropping function.\n-                        extern {\n-                            fn setgroups(ngroups: libc::c_int,\n-                                         ptr: *const libc::c_void) -> libc::c_int;\n-                        }\n-                        let _ = setgroups(0, ptr::null());\n-\n-                        if libc::setuid(u as libc::uid_t) != 0 {\n-                            fail(&mut output);\n-                        }\n-                    }\n-                    None => {}\n-                }\n-                if cfg.detach {\n-                    // Don't check the error of setsid because it fails if we're the\n-                    // process leader already. We just forked so it shouldn't return\n-                    // error, but ignore it anyway.\n-                    let _ = libc::setsid();\n-                }\n-                if !dirp.is_null() && chdir(dirp) == -1 {\n-                    fail(&mut output);\n-                }\n-                if !envp.is_null() {\n-                    *sys::os::environ() = envp as *const _;\n-                }\n-                let _ = execvp(*argv, argv as *mut _);\n+        // If a stdio file descriptor is set to be ignored, we don't\n+        // actually close it, but rather open up /dev/null into that\n+        // file descriptor. Otherwise, the first file descriptor opened\n+        // up in the child would be numbered as one of the stdio file\n+        // descriptors, which is likely to wreak havoc.\n+        let setup = |src: Option<AnonPipe>, dst: c_int| {\n+            src.map(|p| p.into_fd()).or_else(|| {\n+                let mut opts = OpenOptions::new();\n+                opts.read(dst == libc::STDIN_FILENO);\n+                opts.write(dst != libc::STDIN_FILENO);\n+                let devnull = CStr::from_ptr(b\"/dev/null\\0\".as_ptr()\n+                                                as *const _);\n+                File::open_c(devnull, &opts).ok().map(|f| f.into_fd())\n+            }).map(|fd| {\n+                fd.unset_cloexec();\n+                retry(|| libc::dup2(fd.raw(), dst)) != -1\n+            }).unwrap_or(false)\n+        };\n+\n+        if !setup(in_fd, libc::STDIN_FILENO) { fail(&mut output) }\n+        if !setup(out_fd, libc::STDOUT_FILENO) { fail(&mut output) }\n+        if !setup(err_fd, libc::STDERR_FILENO) { fail(&mut output) }\n+\n+        if let Some(u) = cfg.gid {\n+            if libc::setgid(u as libc::gid_t) != 0 {\n                 fail(&mut output);\n-            })\n-        })\n+            }\n+        }\n+        if let Some(u) = cfg.uid {\n+            // When dropping privileges from root, the `setgroups` call\n+            // will remove any extraneous groups. If we don't call this,\n+            // then even though our uid has dropped, we may still have\n+            // groups that enable us to do super-user things. This will\n+            // fail if we aren't root, so don't bother checking the\n+            // return value, this is just done as an optimistic\n+            // privilege dropping function.\n+            let _ = c::setgroups(0, ptr::null());\n+\n+            if libc::setuid(u as libc::uid_t) != 0 {\n+                fail(&mut output);\n+            }\n+        }\n+        if cfg.detach {\n+            // Don't check the error of setsid because it fails if we're the\n+            // process leader already. We just forked so it shouldn't return\n+            // error, but ignore it anyway.\n+            let _ = libc::setsid();\n+        }\n+        if !dirp.is_null() && libc::chdir(dirp) == -1 {\n+            fail(&mut output);\n+        }\n+        if !envp.is_null() {\n+            *sys::os::environ() = envp as *const _;\n+        }\n+        let _ = libc::execvp(*argv, argv as *mut _);\n+        fail(&mut output)\n     }\n \n     pub fn wait(&self) -> io::Result<ExitStatus> {\n@@ -364,8 +321,8 @@ impl Process {\n     }\n }\n \n-fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T\n-    where F : FnOnce(*const *const libc::c_char) -> T\n+fn make_argv(prog: &CString, args: &[CString])\n+             -> (*const *const libc::c_char, Vec<*const libc::c_char>)\n {\n     let mut ptrs: Vec<*const libc::c_char> = Vec::with_capacity(args.len()+1);\n \n@@ -380,40 +337,38 @@ fn with_argv<T,F>(prog: &CString, args: &[CString], cb: F) -> T\n     // Add a terminating null pointer (required by libc).\n     ptrs.push(ptr::null());\n \n-    cb(ptrs.as_ptr())\n+    (ptrs.as_ptr(), ptrs)\n }\n \n-fn with_envp<T, F>(env: Option<&HashMap<OsString, OsString>>, cb: F) -> T\n-    where F : FnOnce(*const c_void) -> T\n+fn make_envp(env: Option<&HashMap<OsString, OsString>>)\n+             -> (*const c_void, Vec<Vec<u8>>, Vec<*const libc::c_char>)\n {\n     // On posixy systems we can pass a char** for envp, which is a\n     // null-terminated array of \"k=v\\0\" strings. Since we must create\n     // these strings locally, yet expose a raw pointer to them, we\n     // create a temporary vector to own the CStrings that outlives the\n     // call to cb.\n-    match env {\n-        Some(env) => {\n-            let mut tmps = Vec::with_capacity(env.len());\n-\n-            for pair in env {\n-                let mut kv = Vec::new();\n-                kv.push_all(pair.0.as_bytes());\n-                kv.push('=' as u8);\n-                kv.push_all(pair.1.as_bytes());\n-                kv.push(0); // terminating null\n-                tmps.push(kv);\n-            }\n+    if let Some(env) = env {\n+        let mut tmps = Vec::with_capacity(env.len());\n+\n+        for pair in env {\n+            let mut kv = Vec::new();\n+            kv.push_all(pair.0.as_bytes());\n+            kv.push('=' as u8);\n+            kv.push_all(pair.1.as_bytes());\n+            kv.push(0); // terminating null\n+            tmps.push(kv);\n+        }\n \n-            // As with `with_argv`, this is unsafe, since cb could leak the pointers.\n-            let mut ptrs: Vec<*const libc::c_char> =\n-                tmps.iter()\n-                    .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n-                    .collect();\n-            ptrs.push(ptr::null());\n+        let mut ptrs: Vec<*const libc::c_char> =\n+            tmps.iter()\n+                .map(|tmp| tmp.as_ptr() as *const libc::c_char)\n+                .collect();\n+        ptrs.push(ptr::null());\n \n-            cb(ptrs.as_ptr() as *const c_void)\n-        }\n-        _ => cb(ptr::null())\n+        (ptrs.as_ptr() as *const _, tmps, ptrs)\n+    } else {\n+        (0 as *const _, Vec::new(), Vec::new())\n     }\n }\n "}, {"sha": "ed41c95978289f508a481ec922f7ddc6128b5733", "filename": "src/libstd/sys/windows/pipe2.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33a2191d0b880242b3bf9a32477a6b432f931c80/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe2.rs?ref=33a2191d0b880242b3bf9a32477a6b432f931c80", "patch": "@@ -22,22 +22,24 @@ pub struct AnonPipe {\n     fd: c_int\n }\n \n-pub unsafe fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n+pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     // Windows pipes work subtly differently than unix pipes, and their\n     // inheritance has to be handled in a different way that I do not\n     // fully understand. Here we explicitly make the pipe non-inheritable,\n     // which means to pass it to a subprocess they need to be duplicated\n     // first, as in std::run.\n     let mut fds = [0; 2];\n-    match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n-    (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n-        0 => {\n-            assert!(fds[0] != -1 && fds[0] != 0);\n-            assert!(fds[1] != -1 && fds[1] != 0);\n+    unsafe {\n+        match libc::pipe(fds.as_mut_ptr(), 1024 as ::libc::c_uint,\n+                         (libc::O_BINARY | libc::O_NOINHERIT) as c_int) {\n+            0 => {\n+                assert!(fds[0] != -1 && fds[0] != 0);\n+                assert!(fds[1] != -1 && fds[1] != 0);\n \n-            Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n+                Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n+            }\n+            _ => Err(io::Error::last_os_error()),\n         }\n-        _ => Err(io::Error::last_os_error()),\n     }\n }\n "}]}