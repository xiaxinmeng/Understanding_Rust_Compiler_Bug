{"sha": "e75ffb0f1c566e11011b72ac04c3afcad3bf2b13", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NWZmYjBmMWM1NjZlMTEwMTFiNzJhYzA0YzNhZmNhZDNiZjJiMTM=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-31T06:24:39Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-31T06:25:23Z"}, "message": "use Iter<'_, [T; N]> in array_chunks", "tree": {"sha": "c22554c416a88b9027e73a91ed9dede5bb7d6c90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c22554c416a88b9027e73a91ed9dede5bb7d6c90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13", "html_url": "https://github.com/rust-lang/rust/commit/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a410ebc5ea44c0cea23a8e6d05aab2fe66b17203", "url": "https://api.github.com/repos/rust-lang/rust/commits/a410ebc5ea44c0cea23a8e6d05aab2fe66b17203", "html_url": "https://github.com/rust-lang/rust/commit/a410ebc5ea44c0cea23a8e6d05aab2fe66b17203"}], "stats": {"total": 78, "additions": 20, "deletions": 58}, "files": [{"sha": "d2d42d4be4b571cc4c05ba586ba2275a3f63aa65", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 20, "deletions": 58, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75ffb0f1c566e11011b72ac04c3afcad3bf2b13/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=e75ffb0f1c566e11011b72ac04c3afcad3bf2b13", "patch": "@@ -852,7 +852,8 @@ impl<T> [T] {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `N` is 0.\n+    /// Panics if `N` is 0. This check will most probably get changed to a compile time\n+    /// error before this method gets stabilized.\n     ///\n     /// # Examples\n     ///\n@@ -871,10 +872,12 @@ impl<T> [T] {\n     #[inline]\n     pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n         assert_ne!(N, 0);\n-        let rem = self.len() % N;\n-        let len = self.len() - rem;\n-        let (fst, snd) = self.split_at(len);\n-        ArrayChunks { v: fst, rem: snd }\n+        let len = self.len() / N;\n+        let (fst, snd) = self.split_at(len * N);\n+        // SAFETY: We cast a slice of `len * N` elements into\n+        // a slice of `len` many `N` elements chunks.\n+        let array_slice: &[[T; N]] = unsafe { from_raw_parts(fst.as_ptr().cast(), len) };\n+        ArrayChunks { iter: array_slice.iter(), rem: snd }\n     }\n \n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n@@ -5483,7 +5486,7 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n #[derive(Debug)]\n #[unstable(feature = \"array_chunks\", issue = \"none\")]\n pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n-    v: &'a [T],\n+    iter: Iter<'a, [T; N]>,\n     rem: &'a [T],\n }\n \n@@ -5501,7 +5504,7 @@ impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n #[unstable(feature = \"array_chunks\", issue = \"none\")]\n impl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n     fn clone(&self) -> Self {\n-        ArrayChunks { v: self.v, rem: self.rem }\n+        ArrayChunks { iter: self.iter.clone(), rem: self.rem }\n     }\n }\n \n@@ -5511,84 +5514,47 @@ impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a [T; N]> {\n-        if self.v.len() < N {\n-            None\n-        } else {\n-            let (fst, snd) = self.v.split_at(N);\n-            self.v = snd;\n-            // SAFETY: This is safe as fst is exactly N elements long.\n-            let ptr = fst.as_ptr() as *const [T; N];\n-            unsafe { Some(&*ptr) }\n-        }\n+        self.iter.next()\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let n = self.v.len() / N;\n-        (n, Some(n))\n+        self.iter.size_hint()\n     }\n \n     #[inline]\n     fn count(self) -> usize {\n-        self.len()\n+        self.iter.count()\n     }\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let (start, overflow) = n.overflowing_mul(N);\n-        if start >= self.v.len() || overflow {\n-            self.v = &[];\n-            None\n-        } else {\n-            let (_, snd) = self.v.split_at(start);\n-            self.v = snd;\n-            self.next()\n-        }\n+        self.iter.nth(n)\n     }\n \n     #[inline]\n-    fn last(mut self) -> Option<Self::Item> {\n-        self.next_back()\n+    fn last(self) -> Option<Self::Item> {\n+        self.iter.last()\n     }\n }\n \n #[unstable(feature = \"array_chunks\", issue = \"none\")]\n impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T; N]> {\n-        if self.v.len() < N {\n-            None\n-        } else {\n-            let (fst, snd) = self.v.split_at(self.v.len() - N);\n-            self.v = fst;\n-            // SAFETY: This is safe as snd is exactly N elements long.\n-            let ptr = snd.as_ptr() as *const [T; N];\n-            unsafe { Some(&*ptr) }\n-        }\n+        self.iter.next_back()\n     }\n \n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n-        let len = self.len();\n-        if n >= len {\n-            self.v = &[];\n-            None\n-        } else {\n-            let start = (len - 1 - n) * N;\n-            let end = start + N;\n-            let nth_back = &self.v[start..end];\n-            self.v = &self.v[..start];\n-            // SAFETY: This is safe as snd is exactly N elements long.\n-            let ptr = nth_back.as_ptr() as *const [T; N];\n-            unsafe { Some(&*ptr) }\n-        }\n+        self.iter.nth_back(n)\n     }\n }\n \n #[unstable(feature = \"array_chunks\", issue = \"none\")]\n impl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n     fn is_empty(&self) -> bool {\n-        self.v.is_empty()\n+        self.iter.is_empty()\n     }\n }\n \n@@ -5602,11 +5568,7 @@ impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n #[unstable(feature = \"array_chunks\", issue = \"none\")]\n unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n     unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n-        let start = i * N;\n-        // SAFETY: This is safe as `i` must be less than `self.size_hint`.\n-        let segment = unsafe { from_raw_parts(self.v.as_ptr().add(start), N) };\n-        // SAFETY: This is safe as segment is exactly `N` elements long.\n-        unsafe { &*(segment.as_ptr() as *const [T; N]) }\n+        unsafe { self.iter.get_unchecked(i) }\n     }\n     fn may_have_side_effect() -> bool {\n         false"}]}