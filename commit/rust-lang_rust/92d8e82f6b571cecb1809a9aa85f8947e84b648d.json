{"sha": "92d8e82f6b571cecb1809a9aa85f8947e84b648d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZDhlODJmNmI1NzFjZWNiMTgwOWE5YWE4NWY4OTQ3ZTg0YjY0OGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T22:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-12T22:43:20Z"}, "message": "Auto merge of #69105 - Dylan-DPC:rollup-n73lh5h, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67954 (Support new LLVM pass manager)\n - #68981 ( Account for type params on method without parentheses)\n - #69002 (miri: improve and simplify overflow detection)\n - #69038 (Add initial debug fmt for Backtrace)\n - #69040 (Cleanup SGX entry code)\n - #69086 (Update compiler-builtins to 0.1.25)\n - #69095 (Minified theme check)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "389649e7fcb8d8ad1709183e482bc0f158441f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389649e7fcb8d8ad1709183e482bc0f158441f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92d8e82f6b571cecb1809a9aa85f8947e84b648d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92d8e82f6b571cecb1809a9aa85f8947e84b648d", "html_url": "https://github.com/rust-lang/rust/commit/92d8e82f6b571cecb1809a9aa85f8947e84b648d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92d8e82f6b571cecb1809a9aa85f8947e84b648d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49", "html_url": "https://github.com/rust-lang/rust/commit/a1912f2e89b77cfe2a0e64b96f444848fe4e2d49"}, {"sha": "839adda4be859bac6518d3d3e0f6093defefae65", "url": "https://api.github.com/repos/rust-lang/rust/commits/839adda4be859bac6518d3d3e0f6093defefae65", "html_url": "https://github.com/rust-lang/rust/commit/839adda4be859bac6518d3d3e0f6093defefae65"}], "stats": {"total": 1073, "additions": 893, "deletions": 180}, "files": [{"sha": "7ed732e41605c7bf30508658548fa81a505a2e75", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -576,9 +576,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.24\"\n+version = \"0.1.25\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9975aefa63997ef75ca9cf013ff1bb81487aaa0b622c21053afd3b92979a7af\"\n+checksum = \"438ac08ddc5efe81452f984a9e33ba425b00b31d1f48e6acd9e2210aa28cc52e\"\n dependencies = [\n  \"cc\",\n  \"rustc-std-workspace-core\","}, {"sha": "e3d69fc5c76dfcc87f39ec1b6c9c558959b7380c", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -584,6 +584,20 @@ pub(crate) fn run_pass_manager(\n     //      tools/lto/LTOCodeGenerator.cpp\n     debug!(\"running the pass manager\");\n     unsafe {\n+        if write::should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = if thin { llvm::OptStage::ThinLTO } else { llvm::OptStage::FatLTO };\n+            let opt_level = config.opt_level.unwrap_or(config::OptLevel::No);\n+            // See comment below for why this is necessary.\n+            let opt_level = if let config::OptLevel::No = opt_level {\n+                config::OptLevel::Less\n+            } else {\n+                opt_level\n+            };\n+            write::optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            debug!(\"lto done\");\n+            return;\n+        }\n+\n         let pm = llvm::LLVMCreatePassManager();\n         llvm::LLVMAddAnalysisPasses(module.module_llvm.tm, pm);\n "}, {"sha": "9008970847a59987204b4dd3e6ca4261eef0db86", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 107, "deletions": 18, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -111,6 +111,18 @@ pub fn to_llvm_opt_settings(\n     }\n }\n \n+fn to_pass_builder_opt_level(cfg: config::OptLevel) -> llvm::PassBuilderOptLevel {\n+    use config::OptLevel::*;\n+    match cfg {\n+        No => llvm::PassBuilderOptLevel::O0,\n+        Less => llvm::PassBuilderOptLevel::O1,\n+        Default => llvm::PassBuilderOptLevel::O2,\n+        Aggressive => llvm::PassBuilderOptLevel::O3,\n+        Size => llvm::PassBuilderOptLevel::Os,\n+        SizeMin => llvm::PassBuilderOptLevel::Oz,\n+    }\n+}\n+\n // If find_features is true this won't access `sess.crate_types` by assuming\n // that `is_pie_binary` is false. When we discover LLVM target features\n // `sess.crate_types` is uninitialized so we cannot access it.\n@@ -303,6 +315,88 @@ unsafe extern \"C\" fn diagnostic_handler(info: &DiagnosticInfo, user: *mut c_void\n     }\n }\n \n+fn get_pgo_gen_path(config: &ModuleConfig) -> Option<CString> {\n+    match config.pgo_gen {\n+        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n+            let path = if let Some(dir_path) = opt_dir_path {\n+                dir_path.join(\"default_%m.profraw\")\n+            } else {\n+                PathBuf::from(\"default_%m.profraw\")\n+            };\n+\n+            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n+        }\n+        SwitchWithOptPath::Disabled => None,\n+    }\n+}\n+\n+fn get_pgo_use_path(config: &ModuleConfig) -> Option<CString> {\n+    config\n+        .pgo_use\n+        .as_ref()\n+        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap())\n+}\n+\n+pub(crate) fn should_use_new_llvm_pass_manager(config: &ModuleConfig) -> bool {\n+    // We only support the new pass manager starting with LLVM 9.\n+    if llvm_util::get_major_version() < 9 {\n+        return false;\n+    }\n+\n+    // The new pass manager is disabled by default.\n+    config.new_llvm_pass_manager.unwrap_or(false)\n+}\n+\n+pub(crate) unsafe fn optimize_with_new_llvm_pass_manager(\n+    module: &ModuleCodegen<ModuleLlvm>,\n+    config: &ModuleConfig,\n+    opt_level: config::OptLevel,\n+    opt_stage: llvm::OptStage,\n+) {\n+    let unroll_loops =\n+        opt_level != config::OptLevel::Size && opt_level != config::OptLevel::SizeMin;\n+    let using_thin_buffers = opt_stage == llvm::OptStage::PreLinkThinLTO || config.bitcode_needed();\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n+    let is_lto = opt_stage == llvm::OptStage::ThinLTO || opt_stage == llvm::OptStage::FatLTO;\n+    // Sanitizer instrumentation is only inserted during the pre-link optimization stage.\n+    let sanitizer_options = if !is_lto {\n+        config.sanitizer.as_ref().map(|s| llvm::SanitizerOptions {\n+            sanitize_memory: *s == Sanitizer::Memory,\n+            sanitize_thread: *s == Sanitizer::Thread,\n+            sanitize_address: *s == Sanitizer::Address,\n+            sanitize_recover: config.sanitizer_recover.contains(s),\n+            sanitize_memory_track_origins: config.sanitizer_memory_track_origins as c_int,\n+        })\n+    } else {\n+        None\n+    };\n+\n+    // FIXME: NewPM doesn't provide a facility to pass custom InlineParams.\n+    // We would have to add upstream support for this first, before we can support\n+    // config.inline_threshold and our more aggressive default thresholds.\n+    // FIXME: NewPM uses an different and more explicit way to textually represent\n+    // pass pipelines. It would probably make sense to expose this, but it would\n+    // require a different format than the current -C passes.\n+    llvm::LLVMRustOptimizeWithNewPassManager(\n+        module.module_llvm.llmod(),\n+        &*module.module_llvm.tm,\n+        to_pass_builder_opt_level(opt_level),\n+        opt_stage,\n+        config.no_prepopulate_passes,\n+        config.verify_llvm_ir,\n+        using_thin_buffers,\n+        config.merge_functions,\n+        unroll_loops,\n+        config.vectorize_slp,\n+        config.vectorize_loop,\n+        config.no_builtins,\n+        sanitizer_options.as_ref(),\n+        pgo_gen_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+        pgo_use_path.as_ref().map_or(std::ptr::null(), |s| s.as_ptr()),\n+    );\n+}\n+\n // Unsafe due to LLVM calls.\n pub(crate) unsafe fn optimize(\n     cgcx: &CodegenContext<LlvmCodegenBackend>,\n@@ -327,6 +421,17 @@ pub(crate) unsafe fn optimize(\n     }\n \n     if let Some(opt_level) = config.opt_level {\n+        if should_use_new_llvm_pass_manager(config) {\n+            let opt_stage = match cgcx.lto {\n+                Lto::Fat => llvm::OptStage::PreLinkFatLTO,\n+                Lto::Thin | Lto::ThinLocal => llvm::OptStage::PreLinkThinLTO,\n+                _ if cgcx.opts.cg.linker_plugin_lto.enabled() => llvm::OptStage::PreLinkThinLTO,\n+                _ => llvm::OptStage::PreLinkNoLTO,\n+            };\n+            optimize_with_new_llvm_pass_manager(module, config, opt_level, opt_stage);\n+            return Ok(());\n+        }\n+\n         // Create the two optimizing pass managers. These mirror what clang\n         // does, and are by populated by LLVM's default PassManagerBuilder.\n         // Each manager has a different set of passes, but they also share\n@@ -757,24 +862,8 @@ pub unsafe fn with_llvm_pmb(\n     let opt_size =\n         config.opt_size.map(|x| to_llvm_opt_settings(x).1).unwrap_or(llvm::CodeGenOptSizeNone);\n     let inline_threshold = config.inline_threshold;\n-\n-    let pgo_gen_path = match config.pgo_gen {\n-        SwitchWithOptPath::Enabled(ref opt_dir_path) => {\n-            let path = if let Some(dir_path) = opt_dir_path {\n-                dir_path.join(\"default_%m.profraw\")\n-            } else {\n-                PathBuf::from(\"default_%m.profraw\")\n-            };\n-\n-            Some(CString::new(format!(\"{}\", path.display())).unwrap())\n-        }\n-        SwitchWithOptPath::Disabled => None,\n-    };\n-\n-    let pgo_use_path = config\n-        .pgo_use\n-        .as_ref()\n-        .map(|path_buf| CString::new(path_buf.to_string_lossy().as_bytes()).unwrap());\n+    let pgo_gen_path = get_pgo_gen_path(config);\n+    let pgo_use_path = get_pgo_use_path(config);\n \n     llvm::LLVMRustConfigurePassManagerBuilder(\n         builder,"}, {"sha": "ab6c55becdb0249acc3c03d8dd15228278cff994", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -781,13 +781,18 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n         align: Align,\n         flags: MemFlags,\n     ) {\n-        let ptr_width = &self.sess().target.target.target_pointer_width;\n-        let intrinsic_key = format!(\"llvm.memset.p0i8.i{}\", ptr_width);\n-        let llintrinsicfn = self.get_intrinsic(&intrinsic_key);\n+        let is_volatile = flags.contains(MemFlags::VOLATILE);\n         let ptr = self.pointercast(ptr, self.type_i8p());\n-        let align = self.const_u32(align.bytes() as u32);\n-        let volatile = self.const_bool(flags.contains(MemFlags::VOLATILE));\n-        self.call(llintrinsicfn, &[ptr, fill_byte, size, align, volatile], None);\n+        unsafe {\n+            llvm::LLVMRustBuildMemSet(\n+                self.llbuilder,\n+                ptr,\n+                align.bytes() as c_uint,\n+                fill_byte,\n+                size,\n+                is_volatile,\n+            );\n+        }\n     }\n \n     fn select(\n@@ -985,11 +990,11 @@ impl BuilderMethods<'a, 'tcx> for Builder<'a, 'll, 'tcx> {\n     }\n \n     fn lifetime_start(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.start\", ptr, size);\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.start.p0i8\", ptr, size);\n     }\n \n     fn lifetime_end(&mut self, ptr: &'ll Value, size: Size) {\n-        self.call_lifetime_intrinsic(\"llvm.lifetime.end\", ptr, size);\n+        self.call_lifetime_intrinsic(\"llvm.lifetime.end.p0i8\", ptr, size);\n     }\n \n     fn call("}, {"sha": "46f461b98c8de0ee7207a78769002305c64978da", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -562,10 +562,6 @@ impl CodegenCx<'b, 'tcx> {\n             t_v8f64: t_f64, 8;\n         }\n \n-        ifn!(\"llvm.memset.p0i8.i16\", fn(i8p, t_i8, t_i16, t_i32, i1) -> void);\n-        ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-        ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n         ifn!(\"llvm.trap\", fn() -> void);\n         ifn!(\"llvm.debugtrap\", fn() -> void);\n         ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n@@ -830,8 +826,8 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.usub.sat.i64\", fn(t_i64, t_i64) -> t_i64);\n         ifn!(\"llvm.usub.sat.i128\", fn(t_i128, t_i128) -> t_i128);\n \n-        ifn!(\"llvm.lifetime.start\", fn(t_i64, i8p) -> void);\n-        ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n+        ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n+        ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);"}, {"sha": "f12bfe0e80ace578c220bfcfb9cad59258291b41", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -402,6 +402,38 @@ pub enum CodeGenOptLevel {\n     Aggressive,\n }\n \n+/// LLVMRustPassBuilderOptLevel\n+#[repr(C)]\n+pub enum PassBuilderOptLevel {\n+    O0,\n+    O1,\n+    O2,\n+    O3,\n+    Os,\n+    Oz,\n+}\n+\n+/// LLVMRustOptStage\n+#[derive(PartialEq)]\n+#[repr(C)]\n+pub enum OptStage {\n+    PreLinkNoLTO,\n+    PreLinkThinLTO,\n+    PreLinkFatLTO,\n+    ThinLTO,\n+    FatLTO,\n+}\n+\n+/// LLVMRustSanitizerOptions\n+#[repr(C)]\n+pub struct SanitizerOptions {\n+    pub sanitize_memory: bool,\n+    pub sanitize_thread: bool,\n+    pub sanitize_address: bool,\n+    pub sanitize_recover: bool,\n+    pub sanitize_memory_track_origins: c_int,\n+}\n+\n /// LLVMRelocMode\n #[derive(Copy, Clone, PartialEq)]\n #[repr(C)]\n@@ -1316,6 +1348,14 @@ extern \"C\" {\n         Size: &'a Value,\n         IsVolatile: bool,\n     ) -> &'a Value;\n+    pub fn LLVMRustBuildMemSet(\n+        B: &Builder<'a>,\n+        Dst: &'a Value,\n+        DstAlign: c_uint,\n+        Val: &'a Value,\n+        Size: &'a Value,\n+        IsVolatile: bool,\n+    ) -> &'a Value;\n     pub fn LLVMBuildSelect(\n         B: &Builder<'a>,\n         If: &'a Value,\n@@ -1889,6 +1929,23 @@ extern \"C\" {\n         Output: *const c_char,\n         FileType: FileType,\n     ) -> LLVMRustResult;\n+    pub fn LLVMRustOptimizeWithNewPassManager(\n+        M: &'a Module,\n+        TM: &'a TargetMachine,\n+        OptLevel: PassBuilderOptLevel,\n+        OptStage: OptStage,\n+        NoPrepopulatePasses: bool,\n+        VerifyIR: bool,\n+        UseThinLTOBuffers: bool,\n+        MergeFunctions: bool,\n+        UnrollLoops: bool,\n+        SLPVectorize: bool,\n+        LoopVectorize: bool,\n+        DisableSimplifyLibCalls: bool,\n+        SanitizerOptions: Option<&SanitizerOptions>,\n+        PGOGenPath: *const c_char,\n+        PGOUsePath: *const c_char,\n+    );\n     pub fn LLVMRustPrintModule(\n         M: &'a Module,\n         Output: *const c_char,"}, {"sha": "92f795acc543805912c670656eb2e9239289190d", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -88,6 +88,7 @@ pub struct ModuleConfig {\n     pub vectorize_slp: bool,\n     pub merge_functions: bool,\n     pub inline_threshold: Option<usize>,\n+    pub new_llvm_pass_manager: Option<bool>,\n     // Instead of creating an object file by doing LLVM codegen, just\n     // make the object file bitcode. Provides easy compatibility with\n     // emscripten's ecc compiler, when used as the linker.\n@@ -132,6 +133,7 @@ impl ModuleConfig {\n             vectorize_slp: false,\n             merge_functions: false,\n             inline_threshold: None,\n+            new_llvm_pass_manager: None,\n         }\n     }\n \n@@ -140,6 +142,7 @@ impl ModuleConfig {\n         self.no_prepopulate_passes = sess.opts.cg.no_prepopulate_passes;\n         self.no_builtins = no_builtins || sess.target.target.options.no_builtins;\n         self.inline_threshold = sess.opts.cg.inline_threshold;\n+        self.new_llvm_pass_manager = sess.opts.debugging_opts.new_llvm_pass_manager;\n         self.obj_is_bitcode =\n             sess.target.target.options.obj_is_bitcode || sess.opts.cg.linker_plugin_lto.enabled();\n         let embed_bitcode ="}, {"sha": "2e8c94903ca46e9df220a91008edb8f1c7e2d3e7", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -134,9 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let mut r = r as u32;\n             let size = left_layout.size;\n             oflo |= r >= size.bits() as u32;\n-            if oflo {\n-                r %= size.bits() as u32;\n-            }\n+            r %= size.bits() as u32;\n             let result = if signed {\n                 let l = self.sign_extend(l, left_layout) as i128;\n                 let result = match bin_op {\n@@ -168,6 +166,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             )\n         }\n \n+        let size = left_layout.size;\n+\n         // Operations that need special treatment for signed integers\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n@@ -195,32 +195,31 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             if let Some(op) = op {\n                 let l128 = self.sign_extend(l, left_layout) as i128;\n                 let r = self.sign_extend(r, right_layout) as i128;\n-                let size = left_layout.size;\n+                // We need a special check for overflowing remainder:\n+                // \"int_min % -1\" overflows and returns 0, but after casting things to a larger int\n+                // type it does *not* overflow nor give an unrepresentable result!\n                 match bin_op {\n-                    Rem | Div => {\n-                        // int_min / -1\n+                    Rem => {\n                         if r == -1 && l == (1 << (size.bits() - 1)) {\n-                            return Ok((Scalar::from_uint(l, size), true, left_layout.ty));\n+                            return Ok((Scalar::from_int(0, size), true, left_layout.ty));\n                         }\n                     }\n                     _ => {}\n                 }\n-                trace!(\"{}, {}, {}\", l, l128, r);\n-                let (result, mut oflo) = op(l128, r);\n-                trace!(\"{}, {}\", result, oflo);\n-                if !oflo && size.bits() != 128 {\n-                    let max = 1 << (size.bits() - 1);\n-                    oflo = result >= max || result < -max;\n-                }\n-                // this may be out-of-bounds for the result type, so we have to truncate ourselves\n+\n+                let (result, oflo) = op(l128, r);\n+                // This may be out-of-bounds for the result type, so we have to truncate ourselves.\n+                // If that truncation loses any information, we have an overflow.\n                 let result = result as u128;\n                 let truncated = self.truncate(result, left_layout);\n-                return Ok((Scalar::from_uint(truncated, size), oflo, left_layout.ty));\n+                return Ok((\n+                    Scalar::from_uint(truncated, size),\n+                    oflo || self.sign_extend(truncated, left_layout) != result,\n+                    left_layout.ty,\n+                ));\n             }\n         }\n \n-        let size = left_layout.size;\n-\n         let (val, ty) = match bin_op {\n             Eq => (Scalar::from_bool(l == r), self.tcx.types.bool),\n             Ne => (Scalar::from_bool(l != r), self.tcx.types.bool),\n@@ -247,6 +246,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     _ => bug!(),\n                 };\n                 let (result, oflo) = op(l, r);\n+                // Truncate to target type.\n+                // If that truncation loses any information, we have an overflow.\n                 let truncated = self.truncate(result, left_layout);\n                 return Ok((\n                     Scalar::from_uint(truncated, size),\n@@ -341,7 +342,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n     }\n \n-    /// Typed version of `checked_binary_op`, returning an `ImmTy`. Also ignores overflows.\n+    /// Typed version of `overflowing_binary_op`, returning an `ImmTy`. Also ignores overflows.\n     #[inline]\n     pub fn binary_op(\n         &self,\n@@ -353,11 +354,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n     }\n \n-    pub fn unary_op(\n+    /// Returns the result of the specified operation, whether it overflowed, and\n+    /// the result type.\n+    pub fn overflowing_unary_op(\n         &self,\n         un_op: mir::UnOp,\n         val: ImmTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool, Ty<'tcx>)> {\n         use rustc::mir::UnOp::*;\n \n         let layout = val.layout;\n@@ -371,29 +374,44 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     Not => !val,\n                     _ => bug!(\"Invalid bool op {:?}\", un_op),\n                 };\n-                Ok(ImmTy::from_scalar(Scalar::from_bool(res), self.layout_of(self.tcx.types.bool)?))\n+                Ok((Scalar::from_bool(res), false, self.tcx.types.bool))\n             }\n             ty::Float(fty) => {\n                 let res = match (un_op, fty) {\n                     (Neg, FloatTy::F32) => Scalar::from_f32(-val.to_f32()?),\n                     (Neg, FloatTy::F64) => Scalar::from_f64(-val.to_f64()?),\n                     _ => bug!(\"Invalid float op {:?}\", un_op),\n                 };\n-                Ok(ImmTy::from_scalar(res, layout))\n+                Ok((res, false, layout.ty))\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());\n                 let val = self.force_bits(val, layout.size)?;\n-                let res = match un_op {\n-                    Not => !val,\n+                let (res, overflow) = match un_op {\n+                    Not => (self.truncate(!val, layout), false), // bitwise negation, then truncate\n                     Neg => {\n+                        // arithmetic negation\n                         assert!(layout.abi.is_signed());\n-                        (-(val as i128)) as u128\n+                        let val = self.sign_extend(val, layout) as i128;\n+                        let (res, overflow) = val.overflowing_neg();\n+                        let res = res as u128;\n+                        // Truncate to target type.\n+                        // If that truncation loses any information, we have an overflow.\n+                        let truncated = self.truncate(res, layout);\n+                        (truncated, overflow || self.sign_extend(truncated, layout) != res)\n                     }\n                 };\n-                // res needs tuncating\n-                Ok(ImmTy::from_uint(self.truncate(res, layout), layout))\n+                Ok((Scalar::from_uint(res, layout.size), overflow, layout.ty))\n             }\n         }\n     }\n+\n+    pub fn unary_op(\n+        &self,\n+        un_op: mir::UnOp,\n+        val: ImmTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        let (val, _overflow, ty) = self.overflowing_unary_op(un_op, val)?;\n+        Ok(ImmTy::from_scalar(val, self.layout_of(ty)?))\n+    }\n }"}, {"sha": "a7da4f7c164fecfdc4226bca48f565ce27d77579", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -518,18 +518,19 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n     }\n \n-    fn check_unary_op(&mut self, arg: &Operand<'tcx>, source_info: SourceInfo) -> Option<()> {\n+    fn check_unary_op(\n+        &mut self,\n+        op: UnOp,\n+        arg: &Operand<'tcx>,\n+        source_info: SourceInfo,\n+    ) -> Option<()> {\n         self.use_ecx(source_info, |this| {\n-            let ty = arg.ty(&this.local_decls, this.tcx);\n-\n-            if ty.is_integral() {\n-                let arg = this.ecx.eval_operand(arg, None)?;\n-                let prim = this.ecx.read_immediate(arg)?;\n-                // Need to do overflow check here: For actual CTFE, MIR\n-                // generation emits code that does this before calling the op.\n-                if prim.to_bits()? == (1 << (prim.layout.size.bits() - 1)) {\n-                    throw_panic!(OverflowNeg)\n-                }\n+            let val = this.ecx.read_immediate(this.ecx.eval_operand(arg, None)?)?;\n+            let (_res, overflow, _ty) = this.ecx.overflowing_unary_op(op, val)?;\n+\n+            if overflow {\n+                assert_eq!(op, UnOp::Neg, \"Neg is the only UnOp that can overflow\");\n+                throw_panic!(OverflowNeg);\n             }\n \n             Ok(())\n@@ -576,11 +577,10 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         if !overflow_check {\n             self.use_ecx(source_info, |this| {\n                 let l = this.ecx.read_immediate(this.ecx.eval_operand(left, None)?)?;\n-                let (_, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n \n                 if overflow {\n-                    let err = err_panic!(Overflow(op)).into();\n-                    return Err(err);\n+                    throw_panic!(Overflow(op));\n                 }\n \n                 Ok(())\n@@ -620,9 +620,9 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             // Additional checking: if overflow checks are disabled (which is usually the case in\n             // release mode), then we need to do additional checking here to give lints to the user\n             // if an overflow would occur.\n-            Rvalue::UnaryOp(UnOp::Neg, arg) if !overflow_check => {\n-                trace!(\"checking UnaryOp(op = Neg, arg = {:?})\", arg);\n-                self.check_unary_op(arg, source_info)?;\n+            Rvalue::UnaryOp(op, arg) if !overflow_check => {\n+                trace!(\"checking UnaryOp(op = {:?}, arg = {:?})\", op, arg);\n+                self.check_unary_op(*op, arg, source_info)?;\n             }\n \n             // Additional checking: check for overflows on integer binary operations and report"}, {"sha": "77748d16653a7e4e4ed9e9e0e8ace81bc38ac452", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -823,7 +823,7 @@ impl<'a> Parser<'a> {\n             if let Some(args) = segment.args {\n                 self.struct_span_err(\n                     args.span(),\n-                    \"field expressions may not have generic arguments\",\n+                    \"field expressions cannot have generic arguments\",\n                 )\n                 .emit();\n             }"}, {"sha": "a794670d7b8fe58b4ba4a6e9b094f1df2d312146", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -968,4 +968,6 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"compile without linking\"),\n     link_only: bool = (false, parse_bool, [TRACKED],\n         \"link the `.rlink` file generated by `-Z no-link`\"),\n+    new_llvm_pass_manager: Option<bool> = (None, parse_opt_bool, [TRACKED],\n+        \"use new LLVM pass manager\"),\n }"}, {"sha": "90b7b300da9d5c51b4f42427a96cb8768c592788", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -1586,7 +1586,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &format!(\"a method `{}` also exists, call it with parentheses\", field),\n                 field,\n                 expr_t,\n-                expr.hir_id,\n+                expr,\n             );\n         }\n         err.emit();\n@@ -1609,7 +1609,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 \"use parentheses to call the method\",\n                 field,\n                 expr_t,\n-                expr.hir_id,\n+                expr,\n             );\n         } else {\n             err.help(\"methods are immutable and cannot be assigned to\");"}, {"sha": "c3e15c507b30d0869d2fe75a0d5d99637ab265b9", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -135,7 +135,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         msg: &str,\n         method_name: ast::Ident,\n         self_ty: Ty<'tcx>,\n-        call_expr_id: hir::HirId,\n+        call_expr: &hir::Expr<'_>,\n     ) {\n         let has_params = self\n             .probe_for_name(\n@@ -144,21 +144,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 method_name,\n                 IsSuggestion(false),\n                 self_ty,\n-                call_expr_id,\n+                call_expr.hir_id,\n                 ProbeScope::TraitsInScope,\n             )\n             .and_then(|pick| {\n                 let sig = self.tcx.fn_sig(pick.item.def_id);\n                 Ok(sig.inputs().skip_binder().len() > 1)\n             });\n \n+        // Account for `foo.bar<T>`;\n+        let sugg_span = method_name.span.with_hi(call_expr.span.hi());\n+        let snippet = self\n+            .tcx\n+            .sess\n+            .source_map()\n+            .span_to_snippet(sugg_span)\n+            .unwrap_or_else(|_| method_name.to_string());\n         let (suggestion, applicability) = if has_params.unwrap_or_default() {\n-            (format!(\"{}(...)\", method_name), Applicability::HasPlaceholders)\n+            (format!(\"{}(...)\", snippet), Applicability::HasPlaceholders)\n         } else {\n-            (format!(\"{}()\", method_name), Applicability::MaybeIncorrect)\n+            (format!(\"{}()\", snippet), Applicability::MaybeIncorrect)\n         };\n \n-        err.span_suggestion(method_name.span, msg, suggestion, applicability);\n+        err.span_suggestion(sugg_span, msg, suggestion, applicability);\n     }\n \n     /// Performs method lookup. If lookup is successful, it will return the callee"}, {"sha": "eb8eabe1c03ebf8422e136ec82f96acd3fee63c8", "filename": "src/librustdoc/theme.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustdoc%2Ftheme.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustdoc%2Ftheme.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -179,20 +179,23 @@ fn get_previous_positions(events: &[Events], mut pos: usize) -> Vec<usize> {\n }\n \n fn build_rule(v: &[u8], positions: &[usize]) -> String {\n-    positions\n-        .chunks(2)\n-        .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n-        .collect::<String>()\n-        .trim()\n-        .replace(\"\\n\", \" \")\n-        .replace(\"/\", \"\")\n-        .replace(\"\\t\", \" \")\n-        .replace(\"{\", \"\")\n-        .replace(\"}\", \"\")\n-        .split(' ')\n-        .filter(|s| s.len() > 0)\n-        .collect::<Vec<&str>>()\n-        .join(\" \")\n+    minifier::css::minify(\n+        &positions\n+            .chunks(2)\n+            .map(|x| ::std::str::from_utf8(&v[x[0]..x[1]]).unwrap_or(\"\"))\n+            .collect::<String>()\n+            .trim()\n+            .replace(\"\\n\", \" \")\n+            .replace(\"/\", \"\")\n+            .replace(\"\\t\", \" \")\n+            .replace(\"{\", \"\")\n+            .replace(\"}\", \"\")\n+            .split(' ')\n+            .filter(|s| s.len() > 0)\n+            .collect::<Vec<&str>>()\n+            .join(\" \"),\n+    )\n+    .unwrap_or_else(|_| String::new())\n }\n \n fn inner(v: &[u8], events: &[Events], pos: &mut usize) -> FxHashSet<CssPath> {"}, {"sha": "b924215733d5584b8fab86dd51ed0b2291fffb9c", "filename": "src/librustdoc/theme/tests.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibrustdoc%2Ftheme%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftheme%2Ftests.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -102,3 +102,16 @@ fn check_invalid_css() {\n     let events = load_css_events(b\"*\");\n     assert_eq!(events.len(), 0);\n }\n+\n+#[test]\n+fn test_with_minification() {\n+    let text = include_str!(\"../html/static/themes/dark.css\");\n+    let minified = minifier::css::minify(&text).expect(\"CSS minification failed\");\n+\n+    let against = load_css_paths(text.as_bytes());\n+    let other = load_css_paths(minified.as_bytes());\n+\n+    let mut ret = Vec::new();\n+    get_differences(&against, &other, &mut ret);\n+    assert!(ret.is_empty());\n+}"}, {"sha": "a1c9aa75d779a82e58e647d733752388fcb5b5b0", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 63, "deletions": 6, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -159,6 +159,69 @@ enum BytesOrWide {\n     Wide(Vec<u16>),\n }\n \n+impl fmt::Debug for Backtrace {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut capture = match &self.inner {\n+            Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n+            Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n+            Inner::Captured(c) => c.lock().unwrap(),\n+        };\n+        capture.resolve();\n+\n+        let frames = &capture.frames[capture.actual_start..];\n+\n+        write!(fmt, \"Backtrace \")?;\n+\n+        let mut dbg = fmt.debug_list();\n+\n+        for frame in frames {\n+            if frame.frame.ip().is_null() {\n+                continue;\n+            }\n+\n+            dbg.entries(&frame.symbols);\n+        }\n+\n+        dbg.finish()\n+    }\n+}\n+\n+impl fmt::Debug for BacktraceSymbol {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"{{ \")?;\n+\n+        if let Some(fn_name) = self.name.as_ref().map(|b| backtrace::SymbolName::new(b)) {\n+            write!(fmt, \"fn: \\\"{:#}\\\"\", fn_name)?;\n+        } else {\n+            write!(fmt, \"fn: \\\"<unknown>\\\"\")?;\n+        }\n+\n+        if let Some(fname) = self.filename.as_ref() {\n+            write!(fmt, \", file: {:?}\", fname)?;\n+        }\n+\n+        if let Some(line) = self.lineno.as_ref() {\n+            write!(fmt, \", line: {:?}\", line)?;\n+        }\n+\n+        write!(fmt, \" }}\")\n+    }\n+}\n+\n+impl fmt::Debug for BytesOrWide {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        output_filename(\n+            fmt,\n+            match self {\n+                BytesOrWide::Bytes(w) => BytesOrWideString::Bytes(w),\n+                BytesOrWide::Wide(w) => BytesOrWideString::Wide(w),\n+            },\n+            backtrace::PrintFmt::Short,\n+            crate::env::current_dir().as_ref().ok(),\n+        )\n+    }\n+}\n+\n impl Backtrace {\n     /// Returns whether backtrace captures are enabled through environment\n     /// variables.\n@@ -267,12 +330,6 @@ impl Backtrace {\n }\n \n impl fmt::Display for Backtrace {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Debug::fmt(self, fmt)\n-    }\n-}\n-\n-impl fmt::Debug for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut capture = match &self.inner {\n             Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),"}, {"sha": "ed4db287229dce8726c9ab5e2d911c6bbd3bbe61", "filename": "src/libstd/sys/sgx/abi/entry.S", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fentry.S?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -30,6 +30,14 @@ IMAGE_BASE:\n \n /*  We can store a bunch of data in the gap between MXCSR and the XSAVE header */\n \n+/* MXCSR initialization value for ABI */\n+.Lmxcsr_init:\n+    .int 0x1f80\n+\n+/* x87 FPU control word initialization value for ABI */\n+.Lfpucw_init:\n+    .int 0x037f\n+\n /*  The following symbols point at read-only data that will be filled in by the */\n /*  post-linker. */\n \n@@ -134,6 +142,19 @@ elf_entry:\n     ud2                               /* should not be reached  */\n /*  end elf_entry */\n \n+/* This code needs to be called *after* the enclave stack has been setup. */\n+/* There are 3 places where this needs to happen, so this is put in a macro. */\n+.macro entry_sanitize_final\n+/*  Sanitize rflags received from user */\n+/*    - DF flag: x86-64 ABI requires DF to be unset at function entry/exit */\n+/*    - AC flag: AEX on misaligned memory accesses leaks side channel info */\n+    pushfq\n+    andq $~0x40400, (%rsp)\n+    popfq\n+    bt $0,.Laborted(%rip)\n+    jc .Lreentry_panic\n+.endm\n+\n .text\n .global sgx_entry\n .type sgx_entry,function\n@@ -150,25 +171,18 @@ sgx_entry:\n     stmxcsr %gs:tcsls_user_mxcsr\n     fnstcw %gs:tcsls_user_fcw\n \n-/*  reset user state */\n-/*    - DF flag: x86-64 ABI requires DF to be unset at function entry/exit */\n-/*    - AC flag: AEX on misaligned memory accesses leaks side channel info */\n-    pushfq\n-    andq $~0x40400, (%rsp)\n-    popfq\n-\n /*  check for debug buffer pointer */\n     testb  $0xff,DEBUG(%rip)\n     jz .Lskip_debug_init\n     mov %r10,%gs:tcsls_debug_panic_buf_ptr\n .Lskip_debug_init:\n-/*  check for abort */\n-    bt $0,.Laborted(%rip)\n-    jc .Lreentry_panic\n /*  check if returning from usercall */\n     mov %gs:tcsls_last_rsp,%r11\n     test %r11,%r11\n     jnz .Lusercall_ret\n+/*  reset user state */\n+    ldmxcsr .Lmxcsr_init(%rip)\n+    fldcw .Lfpucw_init(%rip)\n /*  setup stack */\n     mov %gs:tcsls_tos,%rsp /*  initially, RSP is not set to the correct value */\n                            /*  here. This is fixed below under \"adjust stack\". */\n@@ -179,6 +193,7 @@ sgx_entry:\n     lea IMAGE_BASE(%rip),%rax\n     add %rax,%rsp\n     mov %rsp,%gs:tcsls_tos\n+    entry_sanitize_final\n /*  call tcs_init */\n /*  store caller-saved registers in callee-saved registers */\n     mov %rdi,%rbx\n@@ -194,7 +209,10 @@ sgx_entry:\n     mov %r13,%rdx\n     mov %r14,%r8\n     mov %r15,%r9\n+    jmp .Lafter_init\n .Lskip_init:\n+    entry_sanitize_final\n+.Lafter_init:\n /*  call into main entry point */\n     load_tcsls_flag_secondary_bool cx /* RCX = entry() argument: secondary: bool */\n     call entry /* RDI, RSI, RDX, R8, R9 passed in from userspace */\n@@ -295,6 +313,7 @@ usercall:\n     ldmxcsr (%rsp)\n     fldcw 4(%rsp)\n     add $8, %rsp\n+    entry_sanitize_final\n     pop %rbx\n     pop %rbp\n     pop %r12"}, {"sha": "15e2251d763214789e515070d8b870bfddd78f5c", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 243, "deletions": 1, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -12,6 +12,11 @@\n #include \"llvm/IR/AutoUpgrade.h\"\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n+#include \"llvm/IR/Verifier.h\"\n+#include \"llvm/Passes/PassBuilder.h\"\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Passes/StandardInstrumentations.h\"\n+#endif\n #include \"llvm/Support/CBindingWrapping.h\"\n #include \"llvm/Support/FileSystem.h\"\n #include \"llvm/Support/Host.h\"\n@@ -32,9 +37,12 @@\n #include \"llvm/Transforms/Instrumentation/ThreadSanitizer.h\"\n #include \"llvm/Transforms/Instrumentation/MemorySanitizer.h\"\n #endif\n+#if LLVM_VERSION_GE(9, 0)\n+#include \"llvm/Transforms/Utils/CanonicalizeAliases.h\"\n+#endif\n+#include \"llvm/Transforms/Utils/NameAnonGlobals.h\"\n \n using namespace llvm;\n-using namespace llvm::legacy;\n \n typedef struct LLVMOpaquePass *LLVMPassRef;\n typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n@@ -314,6 +322,34 @@ static CodeGenOpt::Level fromRust(LLVMRustCodeGenOptLevel Level) {\n   }\n }\n \n+enum class LLVMRustPassBuilderOptLevel {\n+  O0,\n+  O1,\n+  O2,\n+  O3,\n+  Os,\n+  Oz,\n+};\n+\n+static PassBuilder::OptimizationLevel fromRust(LLVMRustPassBuilderOptLevel Level) {\n+  switch (Level) {\n+  case LLVMRustPassBuilderOptLevel::O0:\n+    return PassBuilder::O0;\n+  case LLVMRustPassBuilderOptLevel::O1:\n+    return PassBuilder::O1;\n+  case LLVMRustPassBuilderOptLevel::O2:\n+    return PassBuilder::O2;\n+  case LLVMRustPassBuilderOptLevel::O3:\n+    return PassBuilder::O3;\n+  case LLVMRustPassBuilderOptLevel::Os:\n+    return PassBuilder::Os;\n+  case LLVMRustPassBuilderOptLevel::Oz:\n+    return PassBuilder::Oz;\n+  default:\n+    report_fatal_error(\"Bad PassBuilderOptLevel.\");\n+  }\n+}\n+\n enum class LLVMRustRelocMode {\n   Default,\n   Static,\n@@ -604,6 +640,212 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n   return LLVMRustResult::Success;\n }\n \n+enum class LLVMRustOptStage {\n+  PreLinkNoLTO,\n+  PreLinkThinLTO,\n+  PreLinkFatLTO,\n+  ThinLTO,\n+  FatLTO,\n+};\n+\n+struct LLVMRustSanitizerOptions {\n+  bool SanitizeMemory;\n+  bool SanitizeThread;\n+  bool SanitizeAddress;\n+  bool SanitizeRecover;\n+  int SanitizeMemoryTrackOrigins;\n+};\n+\n+extern \"C\" void\n+LLVMRustOptimizeWithNewPassManager(\n+    LLVMModuleRef ModuleRef,\n+    LLVMTargetMachineRef TMRef,\n+    LLVMRustPassBuilderOptLevel OptLevelRust,\n+    LLVMRustOptStage OptStage,\n+    bool NoPrepopulatePasses, bool VerifyIR, bool UseThinLTOBuffers,\n+    bool MergeFunctions, bool UnrollLoops, bool SLPVectorize, bool LoopVectorize,\n+    bool DisableSimplifyLibCalls,\n+    LLVMRustSanitizerOptions *SanitizerOptions,\n+    const char *PGOGenPath, const char *PGOUsePath) {\n+#if LLVM_VERSION_GE(9, 0)\n+  Module *TheModule = unwrap(ModuleRef);\n+  TargetMachine *TM = unwrap(TMRef);\n+  PassBuilder::OptimizationLevel OptLevel = fromRust(OptLevelRust);\n+\n+  // FIXME: MergeFunctions is not supported by NewPM yet.\n+  (void) MergeFunctions;\n+\n+  PipelineTuningOptions PTO;\n+  PTO.LoopUnrolling = UnrollLoops;\n+  PTO.LoopInterleaving = UnrollLoops;\n+  PTO.LoopVectorization = LoopVectorize;\n+  PTO.SLPVectorization = SLPVectorize;\n+\n+  PassInstrumentationCallbacks PIC;\n+  StandardInstrumentations SI;\n+  SI.registerCallbacks(PIC);\n+\n+  Optional<PGOOptions> PGOOpt;\n+  if (PGOGenPath) {\n+    assert(!PGOUsePath);\n+    PGOOpt = PGOOptions(PGOGenPath, \"\", \"\", PGOOptions::IRInstr);\n+  } else if (PGOUsePath) {\n+    assert(!PGOGenPath);\n+    PGOOpt = PGOOptions(PGOUsePath, \"\", \"\", PGOOptions::IRUse);\n+  }\n+\n+  PassBuilder PB(TM, PTO, PGOOpt, &PIC);\n+\n+  // FIXME: We may want to expose this as an option.\n+  bool DebugPassManager = false;\n+  LoopAnalysisManager LAM(DebugPassManager);\n+  FunctionAnalysisManager FAM(DebugPassManager);\n+  CGSCCAnalysisManager CGAM(DebugPassManager);\n+  ModuleAnalysisManager MAM(DebugPassManager);\n+\n+  FAM.registerPass([&] { return PB.buildDefaultAAPipeline(); });\n+\n+  Triple TargetTriple(TheModule->getTargetTriple());\n+  std::unique_ptr<TargetLibraryInfoImpl> TLII(new TargetLibraryInfoImpl(TargetTriple));\n+  if (DisableSimplifyLibCalls)\n+    TLII->disableAllFunctions();\n+  FAM.registerPass([&] { return TargetLibraryAnalysis(*TLII); });\n+\n+  PB.registerModuleAnalyses(MAM);\n+  PB.registerCGSCCAnalyses(CGAM);\n+  PB.registerFunctionAnalyses(FAM);\n+  PB.registerLoopAnalyses(LAM);\n+  PB.crossRegisterProxies(LAM, FAM, CGAM, MAM);\n+\n+  // We manually collect pipeline callbacks so we can apply them at O0, where the\n+  // PassBuilder does not create a pipeline.\n+  std::vector<std::function<void(ModulePassManager &)>> PipelineStartEPCallbacks;\n+  std::vector<std::function<void(FunctionPassManager &, PassBuilder::OptimizationLevel)>>\n+      OptimizerLastEPCallbacks;\n+\n+  if (VerifyIR) {\n+    PipelineStartEPCallbacks.push_back([VerifyIR](ModulePassManager &MPM) {\n+        MPM.addPass(VerifierPass());\n+    });\n+  }\n+\n+  if (SanitizerOptions) {\n+    if (SanitizerOptions->SanitizeMemory) {\n+      MemorySanitizerOptions Options(\n+          SanitizerOptions->SanitizeMemoryTrackOrigins,\n+          SanitizerOptions->SanitizeRecover,\n+          /*CompileKernel=*/false);\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([Options](ModulePassManager &MPM) {\n+        MPM.addPass(MemorySanitizerPass(Options));\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [Options](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(MemorySanitizerPass(Options));\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeThread) {\n+#if LLVM_VERSION_GE(10, 0)\n+      PipelineStartEPCallbacks.push_back([](ModulePassManager &MPM) {\n+        MPM.addPass(ThreadSanitizerPass());\n+      });\n+#endif\n+      OptimizerLastEPCallbacks.push_back(\n+        [](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(ThreadSanitizerPass());\n+        }\n+      );\n+    }\n+\n+    if (SanitizerOptions->SanitizeAddress) {\n+      // FIXME: Rust does not expose the UseAfterScope option.\n+      PipelineStartEPCallbacks.push_back([&](ModulePassManager &MPM) {\n+        MPM.addPass(RequireAnalysisPass<ASanGlobalsMetadataAnalysis, Module>());\n+      });\n+      OptimizerLastEPCallbacks.push_back(\n+        [SanitizerOptions](FunctionPassManager &FPM, PassBuilder::OptimizationLevel Level) {\n+          FPM.addPass(AddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+      PipelineStartEPCallbacks.push_back(\n+        [SanitizerOptions](ModulePassManager &MPM) {\n+          MPM.addPass(ModuleAddressSanitizerPass(\n+              /*CompileKernel=*/false, SanitizerOptions->SanitizeRecover));\n+        }\n+      );\n+    }\n+  }\n+\n+  ModulePassManager MPM(DebugPassManager);\n+  if (!NoPrepopulatePasses) {\n+    if (OptLevel == PassBuilder::O0) {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        C(MPM);\n+\n+      if (!OptimizerLastEPCallbacks.empty()) {\n+        FunctionPassManager FPM(DebugPassManager);\n+        for (const auto &C : OptimizerLastEPCallbacks)\n+          C(FPM, OptLevel);\n+        MPM.addPass(createModuleToFunctionPassAdaptor(std::move(FPM)));\n+      }\n+\n+      MPM.addPass(AlwaysInlinerPass(/*InsertLifetimeIntrinsics=*/false));\n+\n+#if LLVM_VERSION_GE(10, 0)\n+      if (PGOOpt) {\n+        PB.addPGOInstrPassesForO0(\n+            MPM, DebugPassManager, PGOOpt->Action == PGOOptions::IRInstr,\n+            /*IsCS=*/false, PGOOpt->ProfileFile, PGOOpt->ProfileRemappingFile);\n+      }\n+#endif\n+    } else {\n+      for (const auto &C : PipelineStartEPCallbacks)\n+        PB.registerPipelineStartEPCallback(C);\n+      for (const auto &C : OptimizerLastEPCallbacks)\n+        PB.registerOptimizerLastEPCallback(C);\n+\n+      switch (OptStage) {\n+      case LLVMRustOptStage::PreLinkNoLTO:\n+        MPM = PB.buildPerModuleDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkThinLTO:\n+        MPM = PB.buildThinLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::PreLinkFatLTO:\n+        MPM = PB.buildLTOPreLinkDefaultPipeline(OptLevel, DebugPassManager);\n+        break;\n+      case LLVMRustOptStage::ThinLTO:\n+        // FIXME: Does it make sense to pass the ModuleSummaryIndex?\n+        // It only seems to be needed for C++ specific optimizations.\n+        MPM = PB.buildThinLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      case LLVMRustOptStage::FatLTO:\n+        MPM = PB.buildLTODefaultPipeline(OptLevel, DebugPassManager, nullptr);\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (UseThinLTOBuffers) {\n+    MPM.addPass(CanonicalizeAliasesPass());\n+    MPM.addPass(NameAnonGlobalPass());\n+  }\n+\n+  // Upgrade all calls to old intrinsics first.\n+  for (Module::iterator I = TheModule->begin(), E = TheModule->end(); I != E;)\n+    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n+\n+  MPM.run(*TheModule, MAM);\n+#else\n+  // The new pass manager has been available for a long time,\n+  // but we don't bother supporting it on old LLVM versions.\n+  report_fatal_error(\"New pass manager only supported since LLVM 9\");\n+#endif\n+}\n \n // Callback to demangle function name\n // Parameters:"}, {"sha": "49b6e1bfec38d1aa86144af2b3da3a89a777d67f", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -1296,6 +1296,14 @@ extern \"C\" LLVMValueRef LLVMRustBuildMemMove(LLVMBuilderRef B,\n #endif\n }\n \n+extern \"C\" LLVMValueRef LLVMRustBuildMemSet(LLVMBuilderRef B,\n+                                            LLVMValueRef Dst, unsigned DstAlign,\n+                                            LLVMValueRef Val,\n+                                            LLVMValueRef Size, bool IsVolatile) {\n+  return wrap(unwrap(B)->CreateMemSet(\n+      unwrap(Dst), unwrap(Val), unwrap(Size), DstAlign, IsVolatile));\n+}\n+\n extern \"C\" LLVMValueRef\n LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n                     unsigned NumArgs, LLVMBasicBlockRef Then,"}, {"sha": "8ea41c5d44bb1fe410807d3324a003fc8504d2ca", "filename": "src/test/codegen/sanitizer-memory-track-orgins.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fsanitizer-memory-track-orgins.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -15,10 +15,10 @@\n #![crate_type=\"lib\"]\n \n // MSAN-0-NOT: @__msan_track_origins\n-// MSAN-1:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2:     @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n-// MSAN-1-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 1\n-// MSAN-2-LTO: @__msan_track_origins = weak_odr local_unnamed_addr constant i32 2\n+// MSAN-1:     @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2:     @__msan_track_origins = weak_odr {{.*}}constant i32 2\n+// MSAN-1-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 1\n+// MSAN-2-LTO: @__msan_track_origins = weak_odr {{.*}}constant i32 2\n //\n // MSAN-0-LABEL: define void @copy(\n // MSAN-1-LABEL: define void @copy("}, {"sha": "7c5aaedda35fa484baf97b385a8e70f465037b60", "filename": "src/test/ui/consts/const-err2.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -17,16 +17,22 @@ fn black_box<T>(_: T) {\n fn main() {\n     let a = -std::i8::MIN;\n     //~^ ERROR const_err\n+    let a_i128 = -std::i128::MIN;\n+    //~^ ERROR const_err\n     let b = 200u8 + 200u8 + 200u8;\n     //~^ ERROR const_err\n+    let b_i128 = std::i128::MIN - std::i128::MAX;\n+    //~^ ERROR const_err\n     let c = 200u8 * 4;\n     //~^ ERROR const_err\n     let d = 42u8 - (42u8 + 1);\n     //~^ ERROR const_err\n     let _e = [5u8][1];\n-    //~^ ERROR index out of bounds\n+    //~^ ERROR const_err\n     black_box(a);\n+    black_box(a_i128);\n     black_box(b);\n+    black_box(b_i128);\n     black_box(c);\n     black_box(d);\n }"}, {"sha": "f135bf0b06cadb3f061a45199bfe7143b2bf3885", "filename": "src/test/ui/consts/const-err2.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err2.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -11,28 +11,40 @@ LL | #![deny(const_err)]\n    |         ^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/const-err2.rs:20:13\n+  --> $DIR/const-err2.rs:20:18\n+   |\n+LL |     let a_i128 = -std::i128::MIN;\n+   |                  ^^^^^^^^^^^^^^^ attempt to negate with overflow\n+\n+error: this expression will panic at runtime\n+  --> $DIR/const-err2.rs:22:13\n    |\n LL |     let b = 200u8 + 200u8 + 200u8;\n    |             ^^^^^^^^^^^^^ attempt to add with overflow\n \n error: this expression will panic at runtime\n-  --> $DIR/const-err2.rs:22:13\n+  --> $DIR/const-err2.rs:24:18\n+   |\n+LL |     let b_i128 = std::i128::MIN - std::i128::MAX;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to subtract with overflow\n+\n+error: this expression will panic at runtime\n+  --> $DIR/const-err2.rs:26:13\n    |\n LL |     let c = 200u8 * 4;\n    |             ^^^^^^^^^ attempt to multiply with overflow\n \n error: this expression will panic at runtime\n-  --> $DIR/const-err2.rs:24:13\n+  --> $DIR/const-err2.rs:28:13\n    |\n LL |     let d = 42u8 - (42u8 + 1);\n    |             ^^^^^^^^^^^^^^^^^ attempt to subtract with overflow\n \n error: index out of bounds: the len is 1 but the index is 1\n-  --> $DIR/const-err2.rs:26:14\n+  --> $DIR/const-err2.rs:30:14\n    |\n LL |     let _e = [5u8][1];\n    |              ^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "43aba4a8b012b00a6022751d586c24a74c90bb4f", "filename": "src/test/ui/consts/const-err3.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -17,16 +17,22 @@ fn black_box<T>(_: T) {\n fn main() {\n     let a = -std::i8::MIN;\n     //~^ ERROR const_err\n+    let a_i128 = -std::i128::MIN;\n+    //~^ ERROR const_err\n     let b = 200u8 + 200u8 + 200u8;\n     //~^ ERROR const_err\n+    let b_i128 = std::i128::MIN - std::i128::MAX;\n+    //~^ ERROR const_err\n     let c = 200u8 * 4;\n     //~^ ERROR const_err\n     let d = 42u8 - (42u8 + 1);\n     //~^ ERROR const_err\n     let _e = [5u8][1];\n     //~^ ERROR const_err\n     black_box(a);\n+    black_box(a_i128);\n     black_box(b);\n+    black_box(b_i128);\n     black_box(c);\n     black_box(d);\n }"}, {"sha": "05f64b87fcce6debabaeb621523f95f9cb275e8c", "filename": "src/test/ui/consts/const-err3.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-err3.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -10,29 +10,41 @@ note: the lint level is defined here\n LL | #![deny(const_err)]\n    |         ^^^^^^^^^\n \n+error: attempt to negate with overflow\n+  --> $DIR/const-err3.rs:20:18\n+   |\n+LL |     let a_i128 = -std::i128::MIN;\n+   |                  ^^^^^^^^^^^^^^^\n+\n error: attempt to add with overflow\n-  --> $DIR/const-err3.rs:20:13\n+  --> $DIR/const-err3.rs:22:13\n    |\n LL |     let b = 200u8 + 200u8 + 200u8;\n    |             ^^^^^^^^^^^^^\n \n+error: attempt to subtract with overflow\n+  --> $DIR/const-err3.rs:24:18\n+   |\n+LL |     let b_i128 = std::i128::MIN - std::i128::MAX;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: attempt to multiply with overflow\n-  --> $DIR/const-err3.rs:22:13\n+  --> $DIR/const-err3.rs:26:13\n    |\n LL |     let c = 200u8 * 4;\n    |             ^^^^^^^^^\n \n error: attempt to subtract with overflow\n-  --> $DIR/const-err3.rs:24:13\n+  --> $DIR/const-err3.rs:28:13\n    |\n LL |     let d = 42u8 - (42u8 + 1);\n    |             ^^^^^^^^^^^^^^^^^\n \n error: index out of bounds: the len is 1 but the index is 1\n-  --> $DIR/const-err3.rs:26:14\n+  --> $DIR/const-err3.rs:30:14\n    |\n LL |     let _e = [5u8][1];\n    |              ^^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "75dac812f1e3a749e1ecb7786965fc9be1633742", "filename": "src/test/ui/consts/const-int-arithmetic-overflow.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic-overflow.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+// compile-flags: -O\n+#![allow(const_err)]\n+\n+// Make sure arithmetic unary/binary ops actually return the right result, even when overflowing.\n+// We have to put them in `const fn` and turn on optimizations to avoid overflow checks.\n+\n+const fn add(x: i8, y: i8) -> i8 { x+y }\n+const fn sub(x: i8, y: i8) -> i8 { x-y }\n+const fn mul(x: i8, y: i8) -> i8 { x*y }\n+// div and rem are always checked, so we cannot test their result in case of oveflow.\n+const fn neg(x: i8) -> i8 { -x }\n+\n+fn main() {\n+    const ADD_OFLOW: i8 = add(100, 100);\n+    assert_eq!(ADD_OFLOW, -56);\n+\n+    const SUB_OFLOW: i8 = sub(100, -100);\n+    assert_eq!(SUB_OFLOW, -56);\n+\n+    const MUL_OFLOW: i8 = mul(-100, -2);\n+    assert_eq!(MUL_OFLOW, -56);\n+\n+    const NEG_OFLOW: i8 = neg(-128);\n+    assert_eq!(NEG_OFLOW, -128);\n+}"}, {"sha": "2c3421b7a8d0b4dd347bf6f86f6d1c3cbc96de3c", "filename": "src/test/ui/consts/const-int-arithmetic.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-arithmetic.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -7,7 +7,7 @@\n #![feature(const_saturating_int_methods)]\n #![feature(const_wrapping_int_methods)]\n \n-use std::i8;\n+use std::{i8, i128};\n \n macro_rules! suite {\n     ($(\n@@ -65,6 +65,10 @@ suite!(\n         C26: 5i8.checked_rem_euclid(0), None;\n         C27: i8::MIN.checked_rem_euclid(-1), None;\n     }\n+    checked_i128 -> Option<i128> {\n+        CHK_ADD_I128: i128::MAX.checked_add(1), None;\n+        CHK_MUL_I128: i128::MIN.checked_mul(-1), None;\n+    }\n \n     saturating_and_wrapping -> i8 {\n         // `const_saturating_int_methods`\n@@ -104,6 +108,13 @@ suite!(\n         C47: 100i8.wrapping_rem_euclid(10), 0;\n         C48: (-128i8).wrapping_rem_euclid(-1), 0;\n     }\n+    saturating_and_wrapping_i128 -> i128 {\n+        SAT_ADD_I128: i128::MAX.saturating_add(1), i128::MAX;\n+        SAT_MUL_I128: i128::MAX.saturating_mul(2), i128::MAX;\n+\n+        WRP_ADD_I128: i128::MAX.wrapping_add(1), i128::MIN;\n+        WRP_MUL_I128: i128::MAX.wrapping_mul(3), i128::MAX-2;\n+    }\n \n     overflowing -> (i8, bool) {\n         // `const_overflowing_int_methods`\n@@ -119,12 +130,18 @@ suite!(\n \n         C55: 5i8.overflowing_rem_euclid(2), (1, false);\n         C56: i8::MIN.overflowing_rem_euclid(-1), (0, true);\n-\n+    }\n+    overflowing_i128 -> (i128, bool) {\n+        OFL_ADD_I128: i128::MAX.overflowing_add(1), (i128::MIN, true);\n+        OFL_MUL_I128: i128::MAX.overflowing_mul(3), (i128::MAX-2, true);\n     }\n );\n \n fn main() {\n    checked();\n+   checked_i128();\n    saturating_and_wrapping();\n+   saturating_and_wrapping_i128();\n    overflowing();\n+   overflowing_i128();\n }"}, {"sha": "5866cef2d2c70ceff2143217583a3a3232a08773", "filename": "src/test/ui/issues/issue-8460-const.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(const_err)]\n \n-use std::{isize, i8, i16, i32, i64};\n+use std::{isize, i8, i16, i32, i64, i128};\n use std::thread;\n \n fn main() {\n@@ -22,6 +22,9 @@ fn main() {\n     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n     //~| ERROR this expression will panic at runtime\n+    assert!(thread::spawn(move|| { i128::MIN / -1; }).join().is_err());\n+    //~^ ERROR attempt to divide with overflow\n+    //~| ERROR this expression will panic at runtime\n     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n@@ -32,6 +35,8 @@ fn main() {\n     //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    assert!(thread::spawn(move|| { 1i128 / 0; }).join().is_err());\n+    //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n     //~| ERROR this expression will panic at runtime\n@@ -47,6 +52,9 @@ fn main() {\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n     //~| ERROR this expression will panic at runtime\n+    assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n+    //~^ ERROR attempt to calculate the remainder with overflow\n+    //~| ERROR this expression will panic at runtime\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n@@ -57,4 +65,6 @@ fn main() {\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    assert!(thread::spawn(move|| { 1i128 % 0; }).join().is_err());\n+    //~^ ERROR attempt to calculate the remainder with a divisor of zero\n }"}, {"sha": "d7373948cb9e0519b03ba75aee12fcf156ecc2ff", "filename": "src/test/ui/issues/issue-8460-const.stderr", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -64,125 +64,161 @@ error: this expression will panic at runtime\n LL |     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^ attempt to divide with overflow\n \n-error: attempt to divide by zero\n+error: attempt to divide with overflow\n+  --> $DIR/issue-8460-const.rs:25:36\n+   |\n+LL |     assert!(thread::spawn(move|| { i128::MIN / -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^\n+\n+error: this expression will panic at runtime\n   --> $DIR/issue-8460-const.rs:25:36\n    |\n+LL |     assert!(thread::spawn(move|| { i128::MIN / -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^ attempt to divide with overflow\n+\n+error: attempt to divide by zero\n+  --> $DIR/issue-8460-const.rs:28:36\n+   |\n LL |     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n    |                                    ^^^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const.rs:27:36\n+  --> $DIR/issue-8460-const.rs:30:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n    |                                    ^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const.rs:29:36\n+  --> $DIR/issue-8460-const.rs:32:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const.rs:31:36\n+  --> $DIR/issue-8460-const.rs:34:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const.rs:33:36\n+  --> $DIR/issue-8460-const.rs:36:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n+error: attempt to divide by zero\n+  --> $DIR/issue-8460-const.rs:38:36\n+   |\n+LL |     assert!(thread::spawn(move|| { 1i128 / 0; }).join().is_err());\n+   |                                    ^^^^^^^^^\n+\n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const.rs:35:36\n+  --> $DIR/issue-8460-const.rs:40:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/issue-8460-const.rs:35:36\n+  --> $DIR/issue-8460-const.rs:40:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const.rs:38:36\n+  --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/issue-8460-const.rs:38:36\n+  --> $DIR/issue-8460-const.rs:43:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const.rs:41:36\n+  --> $DIR/issue-8460-const.rs:46:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/issue-8460-const.rs:41:36\n+  --> $DIR/issue-8460-const.rs:46:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const.rs:44:36\n+  --> $DIR/issue-8460-const.rs:49:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/issue-8460-const.rs:44:36\n+  --> $DIR/issue-8460-const.rs:49:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const.rs:47:36\n+  --> $DIR/issue-8460-const.rs:52:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n error: this expression will panic at runtime\n-  --> $DIR/issue-8460-const.rs:47:36\n+  --> $DIR/issue-8460-const.rs:52:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n \n+error: attempt to calculate the remainder with overflow\n+  --> $DIR/issue-8460-const.rs:55:36\n+   |\n+LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^\n+\n+error: this expression will panic at runtime\n+  --> $DIR/issue-8460-const.rs:55:36\n+   |\n+LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^ attempt to calculate the remainder with overflow\n+\n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const.rs:50:36\n+  --> $DIR/issue-8460-const.rs:58:36\n    |\n LL |     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n    |                                    ^^^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const.rs:52:36\n+  --> $DIR/issue-8460-const.rs:60:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n    |                                    ^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const.rs:54:36\n+  --> $DIR/issue-8460-const.rs:62:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const.rs:56:36\n+  --> $DIR/issue-8460-const.rs:64:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const.rs:58:36\n+  --> $DIR/issue-8460-const.rs:66:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n-error: aborting due to 30 previous errors\n+error: attempt to calculate the remainder with a divisor of zero\n+  --> $DIR/issue-8460-const.rs:68:36\n+   |\n+LL |     assert!(thread::spawn(move|| { 1i128 % 0; }).join().is_err());\n+   |                                    ^^^^^^^^^\n+\n+error: aborting due to 36 previous errors\n "}, {"sha": "afea859bb65a905ea32ed8f151d90c4833fdc4b7", "filename": "src/test/ui/issues/issue-8460-const2.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -3,7 +3,7 @@\n \n #![deny(const_err)]\n \n-use std::{isize, i8, i16, i32, i64};\n+use std::{isize, i8, i16, i32, i64, i128};\n use std::thread;\n \n fn main() {\n@@ -17,6 +17,8 @@ fn main() {\n     //~^ ERROR attempt to divide with overflow\n     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n     //~^ ERROR attempt to divide with overflow\n+    assert!(thread::spawn(move|| { i128::MIN / -1; }).join().is_err());\n+    //~^ ERROR attempt to divide with overflow\n     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n@@ -27,6 +29,8 @@ fn main() {\n     //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n     //~^ ERROR attempt to divide by zero\n+    assert!(thread::spawn(move|| { 1i128 / 0; }).join().is_err());\n+    //~^ ERROR attempt to divide by zero\n     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n@@ -37,6 +41,8 @@ fn main() {\n     //~^ ERROR attempt to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with overflow\n+    assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n+    //~^ ERROR attempt to calculate the remainder with overflow\n     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n@@ -47,4 +53,6 @@ fn main() {\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n     //~^ ERROR attempt to calculate the remainder with a divisor of zero\n+    assert!(thread::spawn(move|| { 1i128 % 0; }).join().is_err());\n+    //~^ ERROR attempt to calculate the remainder with a divisor of zero\n }"}, {"sha": "e25d560fe0ce34e03b2cb53b030343fcb7e9b48c", "filename": "src/test/ui/issues/issue-8460-const2.stderr", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-8460-const2.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -34,95 +34,119 @@ error: attempt to divide with overflow\n LL |     assert!(thread::spawn(move|| { i64::MIN / -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n-error: attempt to divide by zero\n+error: attempt to divide with overflow\n   --> $DIR/issue-8460-const2.rs:20:36\n    |\n+LL |     assert!(thread::spawn(move|| { i128::MIN / -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^\n+\n+error: attempt to divide by zero\n+  --> $DIR/issue-8460-const2.rs:22:36\n+   |\n LL |     assert!(thread::spawn(move|| { 1isize / 0; }).join().is_err());\n    |                                    ^^^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const2.rs:22:36\n+  --> $DIR/issue-8460-const2.rs:24:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i8 / 0; }).join().is_err());\n    |                                    ^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const2.rs:24:36\n+  --> $DIR/issue-8460-const2.rs:26:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i16 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const2.rs:26:36\n+  --> $DIR/issue-8460-const2.rs:28:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i32 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to divide by zero\n-  --> $DIR/issue-8460-const2.rs:28:36\n+  --> $DIR/issue-8460-const2.rs:30:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i64 / 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n+error: attempt to divide by zero\n+  --> $DIR/issue-8460-const2.rs:32:36\n+   |\n+LL |     assert!(thread::spawn(move|| { 1i128 / 0; }).join().is_err());\n+   |                                    ^^^^^^^^^\n+\n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const2.rs:30:36\n+  --> $DIR/issue-8460-const2.rs:34:36\n    |\n LL |     assert!(thread::spawn(move|| { isize::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^^^\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const2.rs:32:36\n+  --> $DIR/issue-8460-const2.rs:36:36\n    |\n LL |     assert!(thread::spawn(move|| { i8::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const2.rs:34:36\n+  --> $DIR/issue-8460-const2.rs:38:36\n    |\n LL |     assert!(thread::spawn(move|| { i16::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const2.rs:36:36\n+  --> $DIR/issue-8460-const2.rs:40:36\n    |\n LL |     assert!(thread::spawn(move|| { i32::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n error: attempt to calculate the remainder with overflow\n-  --> $DIR/issue-8460-const2.rs:38:36\n+  --> $DIR/issue-8460-const2.rs:42:36\n    |\n LL |     assert!(thread::spawn(move|| { i64::MIN % -1; }).join().is_err());\n    |                                    ^^^^^^^^^^^^^\n \n+error: attempt to calculate the remainder with overflow\n+  --> $DIR/issue-8460-const2.rs:44:36\n+   |\n+LL |     assert!(thread::spawn(move|| { i128::MIN % -1; }).join().is_err());\n+   |                                    ^^^^^^^^^^^^^^\n+\n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const2.rs:40:36\n+  --> $DIR/issue-8460-const2.rs:46:36\n    |\n LL |     assert!(thread::spawn(move|| { 1isize % 0; }).join().is_err());\n    |                                    ^^^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const2.rs:42:36\n+  --> $DIR/issue-8460-const2.rs:48:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i8 % 0; }).join().is_err());\n    |                                    ^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const2.rs:44:36\n+  --> $DIR/issue-8460-const2.rs:50:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i16 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const2.rs:46:36\n+  --> $DIR/issue-8460-const2.rs:52:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i32 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n error: attempt to calculate the remainder with a divisor of zero\n-  --> $DIR/issue-8460-const2.rs:48:36\n+  --> $DIR/issue-8460-const2.rs:54:36\n    |\n LL |     assert!(thread::spawn(move|| { 1i64 % 0; }).join().is_err());\n    |                                    ^^^^^^^^\n \n-error: aborting due to 20 previous errors\n+error: attempt to calculate the remainder with a divisor of zero\n+  --> $DIR/issue-8460-const2.rs:56:36\n+   |\n+LL |     assert!(thread::spawn(move|| { 1i128 % 0; }).join().is_err());\n+   |                                    ^^^^^^^^^\n+\n+error: aborting due to 24 previous errors\n "}, {"sha": "4cd77ebbd862f10aadf490de82c01732a6eee0c2", "filename": "src/test/ui/parser/type-parameters-in-field-exprs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -9,9 +9,9 @@ fn main() {\n         y: 2,\n     };\n     f.x::<isize>;\n-    //~^ ERROR field expressions may not have generic arguments\n+    //~^ ERROR field expressions cannot have generic arguments\n     f.x::<>;\n-    //~^ ERROR field expressions may not have generic arguments\n+    //~^ ERROR field expressions cannot have generic arguments\n     f.x::();\n-    //~^ ERROR field expressions may not have generic arguments\n+    //~^ ERROR field expressions cannot have generic arguments\n }"}, {"sha": "ce7364d3534f61cdcbc8696c9c1fa47945e7d4a5", "filename": "src/test/ui/parser/type-parameters-in-field-exprs.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Ftype-parameters-in-field-exprs.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -1,16 +1,16 @@\n-error: field expressions may not have generic arguments\n+error: field expressions cannot have generic arguments\n   --> $DIR/type-parameters-in-field-exprs.rs:11:10\n    |\n LL |     f.x::<isize>;\n    |          ^^^^^^^\n \n-error: field expressions may not have generic arguments\n+error: field expressions cannot have generic arguments\n   --> $DIR/type-parameters-in-field-exprs.rs:13:10\n    |\n LL |     f.x::<>;\n    |          ^^\n \n-error: field expressions may not have generic arguments\n+error: field expressions cannot have generic arguments\n   --> $DIR/type-parameters-in-field-exprs.rs:15:7\n    |\n LL |     f.x::();"}, {"sha": "f10bfb56d2e1271a0b13d66ae2a31802a809ef14", "filename": "src/test/ui/suggestions/method-missing-parentheses.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.rs?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let _ = vec![].into_iter().collect::<usize>;\n+    //~^ ERROR attempted to take value of method `collect` on type `std::vec::IntoIter<_>`\n+    //~| ERROR field expressions cannot have generic arguments\n+}"}, {"sha": "6e4f7a84724bf7aaeee8302504d89659297d3b2f", "filename": "src/test/ui/suggestions/method-missing-parentheses.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/92d8e82f6b571cecb1809a9aa85f8947e84b648d/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fmethod-missing-parentheses.stderr?ref=92d8e82f6b571cecb1809a9aa85f8947e84b648d", "patch": "@@ -0,0 +1,17 @@\n+error: field expressions cannot have generic arguments\n+  --> $DIR/method-missing-parentheses.rs:2:41\n+   |\n+LL |     let _ = vec![].into_iter().collect::<usize>;\n+   |                                         ^^^^^^^\n+\n+error[E0615]: attempted to take value of method `collect` on type `std::vec::IntoIter<_>`\n+  --> $DIR/method-missing-parentheses.rs:2:32\n+   |\n+LL |     let _ = vec![].into_iter().collect::<usize>;\n+   |                                ^^^^^^^---------\n+   |                                |\n+   |                                help: use parentheses to call the method: `collect::<usize>()`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0615`."}]}