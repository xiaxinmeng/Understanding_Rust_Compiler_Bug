{"sha": "9900178cba95369cd5822c8ce579edcc89ffeb76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MDAxNzhjYmE5NTM2OWNkNTgyMmM4Y2U1NzllZGNjODlmZmViNzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T18:13:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-19T18:13:03Z"}, "message": "Auto merge of #75715 - tmandry:rollup-18atkj4, r=tmandry\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #75069 (move const param structural match checks to wfcheck)\n - #75587 (mir building: fix some comments)\n - #75593 (Adjust installation place for compiler docs)\n - #75648 (Make OnceCell<T> transparent to dropck)\n - #75649 (Fix intra-doc links for inherent impls that are both lang items and not the default impl)\n - #75674 (Move to intra doc links for std::io)\n - #75696 (Remove `#[cfg(miri)]` from OnceCell tests)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d3005c84ee82e922dc2d27aa7a2426c9de49571d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3005c84ee82e922dc2d27aa7a2426c9de49571d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9900178cba95369cd5822c8ce579edcc89ffeb76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9900178cba95369cd5822c8ce579edcc89ffeb76", "html_url": "https://github.com/rust-lang/rust/commit/9900178cba95369cd5822c8ce579edcc89ffeb76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9900178cba95369cd5822c8ce579edcc89ffeb76/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "443e177c7f0f94fc85b0e13e076b21e9eac60189", "url": "https://api.github.com/repos/rust-lang/rust/commits/443e177c7f0f94fc85b0e13e076b21e9eac60189", "html_url": "https://github.com/rust-lang/rust/commit/443e177c7f0f94fc85b0e13e076b21e9eac60189"}, {"sha": "ad3db41182a6f256fb6d44d4b8e67cd2ab6e7922", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad3db41182a6f256fb6d44d4b8e67cd2ab6e7922", "html_url": "https://github.com/rust-lang/rust/commit/ad3db41182a6f256fb6d44d4b8e67cd2ab6e7922"}], "stats": {"total": 1359, "additions": 604, "deletions": 755}, "files": [{"sha": "f8fa2971b49d8fced1cebb6e8c0042c6fdba29fa", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -4106,6 +4106,7 @@ dependencies = [\n  \"rustc-rayon\",\n  \"serde\",\n  \"serde_json\",\n+ \"smallvec 1.4.2\",\n  \"tempfile\",\n ]\n "}, {"sha": "24f921ca7e4dc7a277d30c737577197cb8f72d06", "filename": "library/core/tests/lazy.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fcore%2Ftests%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fcore%2Ftests%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flazy.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -122,3 +122,12 @@ fn reentrant_init() {\n     });\n     eprintln!(\"use after free: {:?}\", dangling_ref.get().unwrap());\n }\n+\n+#[test]\n+fn dropck() {\n+    let cell = OnceCell::new();\n+    {\n+        let s = String::new();\n+        cell.set(&s).unwrap();\n+    }\n+}"}, {"sha": "f3aadf29b2f2b403360ac535cc9c4d3fc0822a97", "filename": "library/std/src/io/buffered.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fbuffered.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -21,17 +21,16 @@ use crate::memchr;\n /// *repeated* read calls to the same file or network socket. It does not\n /// help when reading very large amounts at once, or reading just one or a few\n /// times. It also provides no advantage when reading from a source that is\n-/// already in memory, like a `Vec<u8>`.\n+/// already in memory, like a [`Vec`]`<u8>`.\n ///\n /// When the `BufReader<R>` is dropped, the contents of its buffer will be\n /// discarded. Creating multiple instances of a `BufReader<R>` on the same\n /// stream can cause data loss. Reading from the underlying reader after\n-/// unwrapping the `BufReader<R>` with `BufReader::into_inner` can also cause\n+/// unwrapping the `BufReader<R>` with [`BufReader::into_inner`] can also cause\n /// data loss.\n ///\n-/// [`Read`]: ../../std/io/trait.Read.html\n-/// [`TcpStream::read`]: ../../std/net/struct.TcpStream.html#method.read\n-/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n+/// [`TcpStream::read`]: Read::read\n+/// [`TcpStream`]: crate::net::TcpStream\n ///\n /// # Examples\n ///\n@@ -155,7 +154,9 @@ impl<R> BufReader<R> {\n \n     /// Returns a reference to the internally buffered data.\n     ///\n-    /// Unlike `fill_buf`, this will not attempt to fill the buffer if it is empty.\n+    /// Unlike [`fill_buf`], this will not attempt to fill the buffer if it is empty.\n+    ///\n+    /// [`fill_buf`]: BufRead::fill_buf\n     ///\n     /// # Examples\n     ///\n@@ -338,27 +339,26 @@ where\n impl<R: Seek> Seek for BufReader<R> {\n     /// Seek to an offset, in bytes, in the underlying reader.\n     ///\n-    /// The position used for seeking with `SeekFrom::Current(_)` is the\n+    /// The position used for seeking with [`SeekFrom::Current`]`(_)` is the\n     /// position the underlying reader would be at if the `BufReader<R>` had no\n     /// internal buffer.\n     ///\n     /// Seeking always discards the internal buffer, even if the seek position\n     /// would otherwise fall within it. This guarantees that calling\n-    /// `.into_inner()` immediately after a seek yields the underlying reader\n+    /// [`BufReader::into_inner()`] immediately after a seek yields the underlying reader\n     /// at the same position.\n     ///\n     /// To seek without discarding the internal buffer, use [`BufReader::seek_relative`].\n     ///\n     /// See [`std::io::Seek`] for more details.\n     ///\n-    /// Note: In the edge case where you're seeking with `SeekFrom::Current(n)`\n+    /// Note: In the edge case where you're seeking with [`SeekFrom::Current`]`(n)`\n     /// where `n` minus the internal buffer length overflows an `i64`, two\n     /// seeks will be performed instead of one. If the second seek returns\n-    /// `Err`, the underlying reader will be left at the same position it would\n-    /// have if you called `seek` with `SeekFrom::Current(0)`.\n+    /// [`Err`], the underlying reader will be left at the same position it would\n+    /// have if you called `seek` with [`SeekFrom::Current`]`(0)`.\n     ///\n-    /// [`BufReader::seek_relative`]: struct.BufReader.html#method.seek_relative\n-    /// [`std::io::Seek`]: trait.Seek.html\n+    /// [`std::io::Seek`]: Seek\n     fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {\n         let result: u64;\n         if let SeekFrom::Current(n) = pos {\n@@ -397,7 +397,7 @@ impl<R: Seek> Seek for BufReader<R> {\n /// *repeated* write calls to the same file or network socket. It does not\n /// help when writing very large amounts at once, or writing just one or a few\n /// times. It also provides no advantage when writing to a destination that is\n-/// in memory, like a `Vec<u8>`.\n+/// in memory, like a [`Vec`]<u8>`.\n ///\n /// It is critical to call [`flush`] before `BufWriter<W>` is dropped. Though\n /// dropping will attempt to flush the contents of the buffer, any errors\n@@ -441,10 +441,9 @@ impl<R: Seek> Seek for BufReader<R> {\n /// together by the buffer and will all be written out in one system call when\n /// the `stream` is flushed.\n ///\n-/// [`Write`]: ../../std/io/trait.Write.html\n-/// [`TcpStream::write`]: ../../std/net/struct.TcpStream.html#method.write\n-/// [`TcpStream`]: ../../std/net/struct.TcpStream.html\n-/// [`flush`]: #method.flush\n+/// [`TcpStream::write`]: Write::write\n+/// [`TcpStream`]: crate::net::TcpStream\n+/// [`flush`]: Write::flush\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n@@ -455,7 +454,7 @@ pub struct BufWriter<W: Write> {\n     panicked: bool,\n }\n \n-/// An error returned by `into_inner` which combines an error that\n+/// An error returned by [`BufWriter::into_inner`] which combines an error that\n /// happened while writing out the buffer, and the buffered writer object\n /// which may be used to recover from the condition.\n ///\n@@ -629,7 +628,7 @@ impl<W: Write> BufWriter<W> {\n     ///\n     /// # Errors\n     ///\n-    /// An `Err` will be returned if an error occurs while flushing the buffer.\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n     ///\n     /// # Examples\n     ///\n@@ -725,7 +724,8 @@ impl<W: Write> Drop for BufWriter<W> {\n }\n \n impl<W> IntoInnerError<W> {\n-    /// Returns the error which caused the call to `into_inner()` to fail.\n+    /// Returns the error which caused the call to [`BufWriter::into_inner()`]\n+    /// to fail.\n     ///\n     /// This error was returned when attempting to write the internal buffer.\n     ///\n@@ -819,17 +819,15 @@ impl<W> fmt::Display for IntoInnerError<W> {\n /// Wraps a writer and buffers output to it, flushing whenever a newline\n /// (`0x0a`, `'\\n'`) is detected.\n ///\n-/// The [`BufWriter`][bufwriter] struct wraps a writer and buffers its output.\n+/// The [`BufWriter`] struct wraps a writer and buffers its output.\n /// But it only does this batched write when it goes out of scope, or when the\n /// internal buffer is full. Sometimes, you'd prefer to write each line as it's\n /// completed, rather than the entire buffer at once. Enter `LineWriter`. It\n /// does exactly that.\n ///\n-/// Like [`BufWriter`][bufwriter], a `LineWriter`\u2019s buffer will also be flushed when the\n+/// Like [`BufWriter`], a `LineWriter`\u2019s buffer will also be flushed when the\n /// `LineWriter` goes out of scope or when its internal buffer is full.\n ///\n-/// [bufwriter]: struct.BufWriter.html\n-///\n /// If there's still a partial line in the buffer when the `LineWriter` is\n /// dropped, it will flush those contents.\n ///\n@@ -979,7 +977,7 @@ impl<W: Write> LineWriter<W> {\n     ///\n     /// # Errors\n     ///\n-    /// An `Err` will be returned if an error occurs while flushing the buffer.\n+    /// An [`Err`] will be returned if an error occurs while flushing the buffer.\n     ///\n     /// # Examples\n     ///"}, {"sha": "58343f66f3ffd18a24282e41afd277fb3b256101", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -9,7 +9,7 @@ use core::convert::TryInto;\n /// [`Seek`] implementation.\n ///\n /// `Cursor`s are used with in-memory buffers, anything implementing\n-/// `AsRef<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n+/// [`AsRef`]`<[u8]>`, to allow them to implement [`Read`] and/or [`Write`],\n /// allowing these buffers to be used anywhere you might use a reader or writer\n /// that does actual I/O.\n ///\n@@ -23,12 +23,8 @@ use core::convert::TryInto;\n /// code, but use an in-memory buffer in our tests. We can do this with\n /// `Cursor`:\n ///\n-/// [`Seek`]: trait.Seek.html\n-/// [`Read`]: ../../std/io/trait.Read.html\n-/// [`Write`]: ../../std/io/trait.Write.html\n-/// [`Vec`]: ../../std/vec/struct.Vec.html\n-/// [bytes]: ../../std/primitive.slice.html\n-/// [`File`]: ../fs/struct.File.html\n+/// [bytes]: crate::slice\n+/// [`File`]: crate::fs::File\n ///\n /// ```no_run\n /// use std::io::prelude::*;\n@@ -81,8 +77,8 @@ pub struct Cursor<T> {\n impl<T> Cursor<T> {\n     /// Creates a new cursor wrapping the provided underlying in-memory buffer.\n     ///\n-    /// Cursor initial position is `0` even if underlying buffer (e.g., `Vec`)\n-    /// is not empty. So writing to cursor starts with overwriting `Vec`\n+    /// Cursor initial position is `0` even if underlying buffer (e.g., [`Vec`])\n+    /// is not empty. So writing to cursor starts with overwriting [`Vec`]\n     /// content, not with appending to it.\n     ///\n     /// # Examples"}, {"sha": "e6eda2caf758f88c5296fc44a023d98726f76920", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 35, "deletions": 30, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -4,8 +4,7 @@ use crate::fmt;\n use crate::result;\n use crate::sys;\n \n-/// A specialized [`Result`](../result/enum.Result.html) type for I/O\n-/// operations.\n+/// A specialized [`Result`] type for I/O operations.\n ///\n /// This type is broadly used across [`std::io`] for any operation which may\n /// produce an error.\n@@ -16,12 +15,13 @@ use crate::sys;\n /// While usual Rust style is to import types directly, aliases of [`Result`]\n /// often are not, to make it easier to distinguish between them. [`Result`] is\n /// generally assumed to be [`std::result::Result`][`Result`], and so users of this alias\n-/// will generally use `io::Result` instead of shadowing the prelude's import\n+/// will generally use `io::Result` instead of shadowing the [prelude]'s import\n /// of [`std::result::Result`][`Result`].\n ///\n-/// [`std::io`]: ../io/index.html\n-/// [`io::Error`]: ../io/struct.Error.html\n-/// [`Result`]: ../result/enum.Result.html\n+/// [`std::io`]: crate::io\n+/// [`io::Error`]: Error\n+/// [`Result`]: crate::result::Result\n+/// [prelude]: crate::prelude\n ///\n /// # Examples\n ///\n@@ -48,10 +48,9 @@ pub type Result<T> = result::Result<T, Error>;\n /// `Error` can be created with crafted error messages and a particular value of\n /// [`ErrorKind`].\n ///\n-/// [`Read`]: ../io/trait.Read.html\n-/// [`Write`]: ../io/trait.Write.html\n-/// [`Seek`]: ../io/trait.Seek.html\n-/// [`ErrorKind`]: enum.ErrorKind.html\n+/// [`Read`]: crate::io::Read\n+/// [`Write`]: crate::io::Write\n+/// [`Seek`]: crate::io::Seek\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Error {\n     repr: Repr,\n@@ -83,7 +82,7 @@ struct Custom {\n ///\n /// It is used with the [`io::Error`] type.\n ///\n-/// [`io::Error`]: struct.Error.html\n+/// [`io::Error`]: Error\n #[derive(Clone, Copy, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated)]\n@@ -137,7 +136,7 @@ pub enum ErrorKind {\n     /// For example, a function that reads a file into a string will error with\n     /// `InvalidData` if the file's contents are not valid UTF-8.\n     ///\n-    /// [`InvalidInput`]: #variant.InvalidInput\n+    /// [`InvalidInput`]: ErrorKind::InvalidInput\n     #[stable(feature = \"io_invalid_data\", since = \"1.2.0\")]\n     InvalidData,\n     /// The I/O operation's timeout expired, causing it to be canceled.\n@@ -150,8 +149,8 @@ pub enum ErrorKind {\n     /// particular number of bytes but only a smaller number of bytes could be\n     /// written.\n     ///\n-    /// [`write`]: ../../std/io/trait.Write.html#tymethod.write\n-    /// [`Ok(0)`]: ../../std/io/type.Result.html\n+    /// [`write`]: crate::io::Write::write\n+    /// [`Ok(0)`]: Ok\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     WriteZero,\n     /// This operation was interrupted.\n@@ -220,9 +219,6 @@ impl From<ErrorKind> for Error {\n     /// let error = Error::from(not_found);\n     /// assert_eq!(\"entity not found\", format!(\"{}\", error));\n     /// ```\n-    ///\n-    /// [`ErrorKind`]: ../../std/io/enum.ErrorKind.html\n-    /// [`Error`]: ../../std/io/struct.Error.html\n     #[inline]\n     fn from(kind: ErrorKind) -> Error {\n         Error { repr: Repr::Simple(kind) }\n@@ -235,7 +231,7 @@ impl Error {\n     ///\n     /// This function is used to generically create I/O errors which do not\n     /// originate from the OS itself. The `error` argument is an arbitrary\n-    /// payload which will be contained in this `Error`.\n+    /// payload which will be contained in this [`Error`].\n     ///\n     /// # Examples\n     ///\n@@ -264,7 +260,7 @@ impl Error {\n     ///\n     /// This function reads the value of `errno` for the target platform (e.g.\n     /// `GetLastError` on Windows) and will return a corresponding instance of\n-    /// `Error` for the error code.\n+    /// [`Error`] for the error code.\n     ///\n     /// # Examples\n     ///\n@@ -278,7 +274,7 @@ impl Error {\n         Error::from_raw_os_error(sys::os::errno() as i32)\n     }\n \n-    /// Creates a new instance of an `Error` from a particular OS error code.\n+    /// Creates a new instance of an [`Error`] from a particular OS error code.\n     ///\n     /// # Examples\n     ///\n@@ -310,9 +306,12 @@ impl Error {\n \n     /// Returns the OS error that this error represents (if any).\n     ///\n-    /// If this `Error` was constructed via `last_os_error` or\n-    /// `from_raw_os_error`, then this function will return `Some`, otherwise\n-    /// it will return `None`.\n+    /// If this [`Error`] was constructed via [`last_os_error`] or\n+    /// [`from_raw_os_error`], then this function will return [`Some`], otherwise\n+    /// it will return [`None`].\n+    ///\n+    /// [`last_os_error`]: Error::last_os_error\n+    /// [`from_raw_os_error`]: Error::from_raw_os_error\n     ///\n     /// # Examples\n     ///\n@@ -345,8 +344,10 @@ impl Error {\n \n     /// Returns a reference to the inner error wrapped by this error (if any).\n     ///\n-    /// If this `Error` was constructed via `new` then this function will\n-    /// return `Some`, otherwise it will return `None`.\n+    /// If this [`Error`] was constructed via [`new`] then this function will\n+    /// return [`Some`], otherwise it will return [`None`].\n+    ///\n+    /// [`new`]: Error::new\n     ///\n     /// # Examples\n     ///\n@@ -380,8 +381,10 @@ impl Error {\n     /// Returns a mutable reference to the inner error wrapped by this error\n     /// (if any).\n     ///\n-    /// If this `Error` was constructed via `new` then this function will\n-    /// return `Some`, otherwise it will return `None`.\n+    /// If this [`Error`] was constructed via [`new`] then this function will\n+    /// return [`Some`], otherwise it will return [`None`].\n+    ///\n+    /// [`new`]: Error::new\n     ///\n     /// # Examples\n     ///\n@@ -448,8 +451,10 @@ impl Error {\n \n     /// Consumes the `Error`, returning its inner error (if any).\n     ///\n-    /// If this `Error` was constructed via `new` then this function will\n-    /// return `Some`, otherwise it will return `None`.\n+    /// If this [`Error`] was constructed via [`new`] then this function will\n+    /// return [`Some`], otherwise it will return [`None`].\n+    ///\n+    /// [`new`]: Error::new\n     ///\n     /// # Examples\n     ///\n@@ -480,7 +485,7 @@ impl Error {\n         }\n     }\n \n-    /// Returns the corresponding `ErrorKind` for this error.\n+    /// Returns the corresponding [`ErrorKind`] for this error.\n     ///\n     /// # Examples\n     ///"}, {"sha": "324562948382890d5ba99d7fd91bc617d8d75c7e", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 51, "deletions": 48, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -240,9 +240,9 @@\n //!\n //! [`File`]: crate::fs::File\n //! [`TcpStream`]: crate::net::TcpStream\n-//! [`Vec<T>`]: crate::vec::Vec\n+//! [`Vec<T>`]: Vec\n //! [`io::stdout`]: stdout\n-//! [`io::Result`]: crate::io::Result\n+//! [`io::Result`]: self::Result\n //! [`?` operator]: ../../book/appendix-02-operators.html\n //! [`Result`]: crate::result::Result\n //! [`.unwrap()`]: crate::result::Result::unwrap\n@@ -671,15 +671,15 @@ pub trait Read {\n     /// If the data in this stream is *not* valid UTF-8 then an error is\n     /// returned and `buf` is unchanged.\n     ///\n-    /// See [`read_to_end`][readtoend] for other error semantics.\n+    /// See [`read_to_end`] for other error semantics.\n     ///\n-    /// [readtoend]: Self::read_to_end\n+    /// [`read_to_end`]: Read::read_to_end\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: crate::fs::File\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -790,9 +790,9 @@ pub trait Read {\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: crate::fs::File\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -834,10 +834,9 @@ pub trait Read {\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: crate::fs::File\n-    /// [`Iterator`]: crate::iter::Iterator\n+    /// [`File`]: crate::fs::File\n     /// [`Result`]: crate::result::Result\n     /// [`io::Error`]: self::Error\n     ///\n@@ -871,9 +870,9 @@ pub trait Read {\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: crate::fs::File\n+    /// [`File`]: crate::fs::File\n     ///\n     /// ```no_run\n     /// use std::io;\n@@ -1210,8 +1209,8 @@ impl Initializer {\n /// throughout [`std::io`] take and provide types which implement the `Write`\n /// trait.\n ///\n-/// [`write`]: Self::write\n-/// [`flush`]: Self::flush\n+/// [`write`]: Write::write\n+/// [`flush`]: Write::flush\n /// [`std::io`]: self\n ///\n /// # Examples\n@@ -1237,7 +1236,7 @@ impl Initializer {\n /// The trait also provides convenience methods like [`write_all`], which calls\n /// `write` in a loop until its entire input has been written.\n ///\n-/// [`write_all`]: Self::write_all\n+/// [`write_all`]: Write::write_all\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(spotlight)]\n pub trait Write {\n@@ -1283,30 +1282,36 @@ pub trait Write {\n     ///     Ok(())\n     /// }\n     /// ```\n+    ///\n+    /// [`Ok(n)`]: Ok\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n-    /// Like `write`, except that it writes from a slice of buffers.\n+    /// Like [`write`], except that it writes from a slice of buffers.\n     ///\n     /// Data is copied from each buffer in order, with the final buffer\n     /// read from possibly being only partially consumed. This method must\n-    /// behave as a call to `write` with the buffers concatenated would.\n+    /// behave as a call to [`write`] with the buffers concatenated would.\n     ///\n-    /// The default implementation calls `write` with either the first nonempty\n+    /// The default implementation calls [`write`] with either the first nonempty\n     /// buffer provided, or an empty one if none exists.\n+    ///\n+    /// [`write`]: Write::write\n     #[stable(feature = \"iovec\", since = \"1.36.0\")]\n     fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> Result<usize> {\n         default_write_vectored(|b| self.write(b), bufs)\n     }\n \n-    /// Determines if this `Write`er has an efficient `write_vectored`\n+    /// Determines if this `Write`er has an efficient [`write_vectored`]\n     /// implementation.\n     ///\n-    /// If a `Write`er does not override the default `write_vectored`\n+    /// If a `Write`er does not override the default [`write_vectored`]\n     /// implementation, code using it may want to avoid the method all together\n     /// and coalesce writes into a single buffer for higher performance.\n     ///\n     /// The default implementation returns `false`.\n+    ///\n+    /// [`write_vectored`]: Write::write_vectored\n     #[unstable(feature = \"can_vector\", issue = \"69941\")]\n     fn is_write_vectored(&self) -> bool {\n         false\n@@ -1354,7 +1359,7 @@ pub trait Write {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write`] returns.\n     ///\n-    /// [`write`]: Self::write\n+    /// [`write`]: Write::write\n     ///\n     /// # Examples\n     ///\n@@ -1395,22 +1400,21 @@ pub trait Write {\n     ///\n     /// If the buffer contains no data, this will never call [`write_vectored`].\n     ///\n-    /// [`write_vectored`]: Self::write_vectored\n-    ///\n     /// # Notes\n     ///\n-    ///\n-    /// Unlike `io::Write::write_vectored`, this takes a *mutable* reference to\n-    /// a slice of `IoSlice`s, not an immutable one. That's because we need to\n+    /// Unlike [`write_vectored`], this takes a *mutable* reference to\n+    /// a slice of [`IoSlice`]s, not an immutable one. That's because we need to\n     /// modify the slice to keep track of the bytes already written.\n     ///\n     /// Once this function returns, the contents of `bufs` are unspecified, as\n-    /// this depends on how many calls to `write_vectored` were necessary. It is\n+    /// this depends on how many calls to [`write_vectored`] were necessary. It is\n     /// best to understand this function as taking ownership of `bufs` and to\n     /// not use `bufs` afterwards. The underlying buffers, to which the\n-    /// `IoSlice`s point (but not the `IoSlice`s themselves), are unchanged and\n+    /// [`IoSlice`]s point (but not the [`IoSlice`]s themselves), are unchanged and\n     /// can be reused.\n     ///\n+    /// [`write_vectored`]: Write::write_vectored\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1458,12 +1462,12 @@ pub trait Write {\n     /// explicitly be called. The [`write!()`] macro should be favored to\n     /// invoke this method instead.\n     ///\n-    /// This function internally uses the [`write_all`][writeall] method on\n+    /// This function internally uses the [`write_all`] method on\n     /// this trait and hence will continuously write data so long as no errors\n     /// are received. This also means that partial writes are not indicated in\n     /// this signature.\n     ///\n-    /// [writeall]: Self::write_all\n+    /// [`write_all`]: Write::write_all\n     ///\n     /// # Errors\n     ///\n@@ -1558,9 +1562,9 @@ pub trait Write {\n ///\n /// # Examples\n ///\n-/// [`File`][file]s implement `Seek`:\n+/// [`File`]s implement `Seek`:\n ///\n-/// [file]: crate::fs::File\n+/// [`File`]: crate::fs::File\n ///\n /// ```no_run\n /// use std::io;\n@@ -1610,7 +1614,6 @@ pub trait Seek {\n     /// data is appended to a file). So calling this method multiple times does\n     /// not necessarily return the same length each time.\n     ///\n-    ///\n     /// # Example\n     ///\n     /// ```no_run\n@@ -1646,7 +1649,6 @@ pub trait Seek {\n     ///\n     /// This is equivalent to `self.seek(SeekFrom::Current(0))`.\n     ///\n-    ///\n     /// # Example\n     ///\n     /// ```no_run\n@@ -1756,8 +1758,8 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n /// [`BufReader`] to the rescue!\n ///\n /// [`File`]: crate::fs::File\n-/// [`read_line`]: Self::read_line\n-/// [`lines`]: Self::lines\n+/// [`read_line`]: BufRead::read_line\n+/// [`lines`]: BufRead::lines\n ///\n /// ```no_run\n /// use std::io::{self, BufReader};\n@@ -1775,7 +1777,6 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>) -> R\n ///     Ok(())\n /// }\n /// ```\n-///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n     /// Returns the contents of the internal buffer, filling it with more data\n@@ -1788,7 +1789,7 @@ pub trait BufRead: Read {\n     /// be called with the number of bytes that are consumed from this buffer to\n     /// ensure that the bytes are never returned twice.\n     ///\n-    /// [`consume`]: Self::consume\n+    /// [`consume`]: BufRead::consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n@@ -1838,7 +1839,7 @@ pub trait BufRead: Read {\n     /// Since `consume()` is meant to be used with [`fill_buf`],\n     /// that method's example includes an example of `consume()`.\n     ///\n-    /// [`fill_buf`]: Self::fill_buf\n+    /// [`fill_buf`]: BufRead::fill_buf\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n@@ -1862,7 +1863,7 @@ pub trait BufRead: Read {\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n     ///\n-    /// [`fill_buf`]: Self::fill_buf\n+    /// [`fill_buf`]: BufRead::fill_buf\n     ///\n     /// # Examples\n     ///\n@@ -1901,30 +1902,32 @@ pub trait BufRead: Read {\n         read_until(self, byte, buf)\n     }\n \n-    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n+    /// Read all bytes until a newline (the `0xA` byte) is reached, and append\n     /// them to the provided buffer.\n     ///\n     /// This function will read bytes from the underlying stream until the\n-    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n+    /// newline delimiter (the `0xA` byte) or EOF is found. Once found, all bytes\n     /// up to, and including, the delimiter (if found) will be appended to\n     /// `buf`.\n     ///\n     /// If successful, this function will return the total number of bytes read.\n     ///\n-    /// If this function returns `Ok(0)`, the stream has reached EOF.\n+    /// If this function returns [`Ok(0)`], the stream has reached EOF.\n     ///\n     /// This function is blocking and should be used carefully: it is possible for\n     /// an attacker to continuously send bytes without ever sending a newline\n     /// or EOF.\n     ///\n+    /// [`Ok(0)`]: Ok\n+    ///\n     /// # Errors\n     ///\n     /// This function has the same error semantics as [`read_until`] and will\n     /// also return an error if the read bytes are not valid UTF-8. If an I/O\n     /// error is encountered then `buf` may contain some bytes already read in\n     /// the event that all data read so far was valid UTF-8.\n     ///\n-    /// [`read_until`]: Self::read_until\n+    /// [`read_until`]: BufRead::read_until\n     ///\n     /// # Examples\n     ///\n@@ -1976,8 +1979,8 @@ pub trait BufRead: Read {\n     /// also yielded an error.\n     ///\n     /// [`io::Result`]: self::Result\n-    /// [`Vec<u8>`]: crate::vec::Vec\n-    /// [`read_until`]: Self::read_until\n+    /// [`Vec<u8>`]: Vec\n+    /// [`read_until`]: BufRead::read_until\n     ///\n     /// # Examples\n     ///\n@@ -2008,7 +2011,7 @@ pub trait BufRead: Read {\n     ///\n     /// The iterator returned from this function will yield instances of\n     /// [`io::Result`]`<`[`String`]`>`. Each string returned will *not* have a newline\n-    /// byte (the 0xA byte) or CRLF (0xD, 0xA bytes) at the end.\n+    /// byte (the `0xA` byte) or `CRLF` (`0xD`, `0xA` bytes) at the end.\n     ///\n     /// [`io::Result`]: self::Result\n     ///"}, {"sha": "286eb92915e49381a0dd1c42d870cfa28da28b6e", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -252,8 +252,7 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n ///\n /// Created by the [`io::stdin`] method.\n ///\n-/// [`io::stdin`]: fn.stdin.html\n-/// [`BufRead`]: trait.BufRead.html\n+/// [`io::stdin`]: stdin\n ///\n /// ### Note: Windows Portability Consideration\n ///\n@@ -283,10 +282,6 @@ pub struct Stdin {\n /// This handle implements both the [`Read`] and [`BufRead`] traits, and\n /// is constructed via the [`Stdin::lock`] method.\n ///\n-/// [`Read`]: trait.Read.html\n-/// [`BufRead`]: trait.BufRead.html\n-/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n-///\n /// ### Note: Windows Portability Consideration\n ///\n /// When operating in a console, the Windows implementation of this stream does not support\n@@ -319,8 +314,6 @@ pub struct StdinLock<'a> {\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdin::lock`] method.\n ///\n-/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n-///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to read bytes that are not valid UTF-8 will return\n@@ -380,9 +373,6 @@ impl Stdin {\n     /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n     /// accessing the underlying data.\n     ///\n-    /// [`Read`]: trait.Read.html\n-    /// [`BufRead`]: trait.BufRead.html\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -407,8 +397,6 @@ impl Stdin {\n     /// For detailed semantics of this method, see the documentation on\n     /// [`BufRead::read_line`].\n     ///\n-    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n-    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -542,8 +530,8 @@ impl fmt::Debug for StdinLock<'_> {\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n ///\n-/// [`lock`]: #method.lock\n-/// [`io::stdout`]: fn.stdout.html\n+/// [`lock`]: Stdout::lock\n+/// [`io::stdout`]: stdout\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n@@ -561,9 +549,6 @@ pub struct Stdout {\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n /// an error.\n-///\n-/// [`Write`]: trait.Write.html\n-/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n@@ -575,8 +560,6 @@ pub struct StdoutLock<'a> {\n /// is synchronized via a mutex. If you need more explicit control over\n /// locking, see the [`Stdout::lock`] method.\n ///\n-/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n-///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n@@ -724,7 +707,7 @@ impl fmt::Debug for StdoutLock<'_> {\n ///\n /// For more information, see the [`io::stderr`] method.\n ///\n-/// [`io::stderr`]: fn.stderr.html\n+/// [`io::stderr`]: stderr\n ///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support\n@@ -740,8 +723,6 @@ pub struct Stderr {\n /// This handle implements the `Write` trait and is constructed via\n /// the [`Stderr::lock`] method.\n ///\n-/// [`Stderr::lock`]: struct.Stderr.html#method.lock\n-///\n /// ### Note: Windows Portability Consideration\n /// When operating in a console, the Windows implementation of this stream does not support\n /// non-UTF-8 byte sequences. Attempting to write bytes that are not valid UTF-8 will return\n@@ -819,7 +800,7 @@ impl Stderr {\n     /// guard.\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n-    /// returned guard also implements the `Write` trait for writing data.\n+    /// returned guard also implements the [`Write`] trait for writing data.\n     ///\n     /// # Examples\n     ///"}, {"sha": "a093b745b0c13cd970134465d752a69bdf541a06", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -16,14 +16,17 @@ use crate::mem::MaybeUninit;\n /// If you\u2019re wanting to copy the contents of one file to another and you\u2019re\n /// working with filesystem paths, see the [`fs::copy`] function.\n ///\n-/// [`fs::copy`]: ../fs/fn.copy.html\n+/// [`fs::copy`]: crate::fs::copy\n ///\n /// # Errors\n ///\n-/// This function will return an error immediately if any call to `read` or\n-/// `write` returns an error. All instances of `ErrorKind::Interrupted` are\n+/// This function will return an error immediately if any call to [`read`] or\n+/// [`write`] returns an error. All instances of [`ErrorKind::Interrupted`] are\n /// handled by this function and the underlying operation is retried.\n ///\n+/// [`read`]: Read::read\n+/// [`write`]: Write::write\n+///\n /// # Examples\n ///\n /// ```\n@@ -70,10 +73,8 @@ where\n \n /// A reader which is always at EOF.\n ///\n-/// This struct is generally created by calling [`empty`]. Please see\n-/// the documentation of [`empty()`][`empty`] for more details.\n-///\n-/// [`empty`]: fn.empty.html\n+/// This struct is generally created by calling [`empty()`]. Please see\n+/// the documentation of [`empty()`] for more details.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Empty {\n     _priv: (),\n@@ -83,8 +84,6 @@ pub struct Empty {\n ///\n /// All reads from the returned reader will return [`Ok`]`(0)`.\n ///\n-/// [`Ok`]: ../result/enum.Result.html#variant.Ok\n-///\n /// # Examples\n ///\n /// A slightly sad example of not reading anything into a buffer:\n@@ -132,10 +131,8 @@ impl fmt::Debug for Empty {\n \n /// A reader which yields one byte over and over and over and over and over and...\n ///\n-/// This struct is generally created by calling [`repeat`][repeat]. Please\n-/// see the documentation of `repeat()` for more details.\n-///\n-/// [repeat]: fn.repeat.html\n+/// This struct is generally created by calling [`repeat()`]. Please\n+/// see the documentation of [`repeat()`] for more details.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Repeat {\n     byte: u8,\n@@ -199,20 +196,20 @@ impl fmt::Debug for Repeat {\n \n /// A writer which will move data into the void.\n ///\n-/// This struct is generally created by calling [`sink`][sink]. Please\n-/// see the documentation of `sink()` for more details.\n-///\n-/// [sink]: fn.sink.html\n+/// This struct is generally created by calling [`sink`]. Please\n+/// see the documentation of [`sink()`] for more details.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Sink {\n     _priv: (),\n }\n \n /// Creates an instance of a writer which will successfully consume all data.\n ///\n-/// All calls to `write` on the returned instance will return `Ok(buf.len())`\n+/// All calls to [`write`] on the returned instance will return `Ok(buf.len())`\n /// and the contents of the buffer will not be inspected.\n ///\n+/// [`write`]: Write::write\n+///\n /// # Examples\n ///\n /// ```rust"}, {"sha": "f0548582d2f5d0bab4ee461616ba84ab190779ae", "filename": "library/std/src/lazy.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/library%2Fstd%2Fsrc%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flazy.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -386,9 +386,10 @@ impl<T> SyncOnceCell<T> {\n     }\n }\n \n-impl<T> Drop for SyncOnceCell<T> {\n+unsafe impl<#[may_dangle] T> Drop for SyncOnceCell<T> {\n     fn drop(&mut self) {\n-        // Safety: The cell is being dropped, so it can't be accessed again\n+        // Safety: The cell is being dropped, so it can't be accessed again.\n+        // We also don't touch the `T`, which validates our usage of #[may_dangle].\n         unsafe { self.take_inner() };\n     }\n }\n@@ -516,6 +517,7 @@ mod tests {\n             mpsc::channel,\n             Mutex,\n         },\n+        thread,\n     };\n \n     #[test]\n@@ -552,26 +554,8 @@ mod tests {\n         }\n     }\n \n-    // miri doesn't support threads\n-    #[cfg(not(miri))]\n     fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n-        crate::thread::spawn(f).join().unwrap()\n-    }\n-\n-    #[cfg(not(miri))]\n-    fn spawn(f: impl FnOnce() + Send + 'static) {\n-        let _ = crate::thread::spawn(f);\n-    }\n-\n-    // \"stub threads\" for Miri\n-    #[cfg(miri)]\n-    fn spawn_and_wait<R: Send + 'static>(f: impl FnOnce() -> R + Send + 'static) -> R {\n-        f(())\n-    }\n-\n-    #[cfg(miri)]\n-    fn spawn(f: impl FnOnce() + Send + 'static) {\n-        f(())\n+        thread::spawn(f).join().unwrap()\n     }\n \n     #[test]\n@@ -734,7 +718,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(miri, ignore)] // leaks memory\n     fn static_sync_lazy() {\n         static XS: SyncLazy<Vec<i32>> = SyncLazy::new(|| {\n             let mut xs = Vec::new();\n@@ -752,7 +735,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(miri, ignore)] // leaks memory\n     fn static_sync_lazy_via_fn() {\n         fn xs() -> &'static Vec<i32> {\n             static XS: SyncOnceCell<Vec<i32>> = SyncOnceCell::new();\n@@ -811,7 +793,6 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(miri, ignore)] // deadlocks without real threads\n     fn sync_once_cell_does_not_leak_partially_constructed_boxes() {\n         static ONCE_CELL: SyncOnceCell<String> = SyncOnceCell::new();\n \n@@ -823,7 +804,7 @@ mod tests {\n \n         for _ in 0..n_readers {\n             let tx = tx.clone();\n-            spawn(move || {\n+            thread::spawn(move || {\n                 loop {\n                     if let Some(msg) = ONCE_CELL.get() {\n                         tx.send(msg).unwrap();\n@@ -835,7 +816,7 @@ mod tests {\n             });\n         }\n         for _ in 0..n_writers {\n-            spawn(move || {\n+            thread::spawn(move || {\n                 let _ = ONCE_CELL.set(MSG.to_owned());\n             });\n         }\n@@ -845,4 +826,13 @@ mod tests {\n             assert_eq!(msg, MSG);\n         }\n     }\n+\n+    #[test]\n+    fn dropck() {\n+        let cell = SyncOnceCell::new();\n+        {\n+            let s = String::new();\n+            cell.set(&s).unwrap();\n+        }\n+    }\n }"}, {"sha": "01121977f130b66d678070bc1a13b491ead6faa6", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -162,7 +162,7 @@ impl Step for RustcDocs {\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host.triple));\n         let _ = fs::remove_dir_all(&image);\n \n-        let dst = image.join(\"share/doc/rust/html\");\n+        let dst = image.join(\"share/doc/rust/html/rustc\");\n         t!(fs::create_dir_all(&dst));\n         let src = builder.compiler_doc_out(host);\n         builder.cp_r(&src, &dst);\n@@ -181,7 +181,7 @@ impl Step for RustcDocs {\n             .arg(format!(\"--package-name={}-{}\", name, host.triple))\n             .arg(\"--component-name=rustc-docs\")\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n-            .arg(\"--bulk-dirs=share/doc/rust/html\");\n+            .arg(\"--bulk-dirs=share/doc/rust/html/rustc\");\n \n         builder.info(&format!(\"Dist compiler docs ({})\", host));\n         let _time = timeit(builder);"}, {"sha": "1c1c54434d619400e9da64ea9a276d34dfaafeed", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -321,6 +321,7 @@ fn mir_validated(\n \n     // Ensure that we compute the `mir_const_qualif` for constants at\n     // this point, before we steal the mir-const result.\n+    // Also this means promotion can rely on all const checks having been done.\n     let _ = tcx.mir_const_qualif_opt_const_arg(def);\n \n     let mut body = tcx.mir_const(def).steal();\n@@ -336,7 +337,7 @@ fn mir_validated(\n     let promote: &[&dyn MirPass<'tcx>] = &[\n         // What we need to run borrowck etc.\n         &promote_pass,\n-        &simplify::SimplifyCfg::new(\"qualify-consts\"),\n+        &simplify::SimplifyCfg::new(\"promote-consts\"),\n     ];\n \n     let opt_coverage: &[&dyn MirPass<'tcx>] = if tcx.sess.opts.debugging_opts.instrument_coverage {"}, {"sha": "810bf59ea6c35ad936da1cbcdd6266520379b658", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 135, "deletions": 2, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -6,9 +6,12 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::intravisit as hir_visit;\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::itemlikevisit::ParItemLikeVisitor;\n use rustc_hir::lang_items;\n use rustc_hir::ItemKind;\n+use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n use rustc_middle::ty::trait_def::TraitSpecializationKind;\n use rustc_middle::ty::{\n@@ -275,6 +278,107 @@ pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     check_associated_item(tcx, impl_item.hir_id, impl_item.span, method_sig);\n }\n \n+fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n+    match param.kind {\n+        // We currently only check wf of const params here.\n+        hir::GenericParamKind::Lifetime { .. } | hir::GenericParamKind::Type { .. } => (),\n+\n+        // Const parameters are well formed if their\n+        // type is structural match.\n+        hir::GenericParamKind::Const { ty: hir_ty } => {\n+            let ty = tcx.type_of(tcx.hir().local_def_id(param.hir_id));\n+\n+            let err_ty_str;\n+            let mut is_ptr = true;\n+            let err = if tcx.features().min_const_generics {\n+                match ty.kind {\n+                    ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n+                    ty::FnPtr(_) => Some(\"function pointers\"),\n+                    ty::RawPtr(_) => Some(\"raw pointers\"),\n+                    _ => {\n+                        is_ptr = false;\n+                        err_ty_str = format!(\"`{}`\", ty);\n+                        Some(err_ty_str.as_str())\n+                    }\n+                }\n+            } else {\n+                match ty.peel_refs().kind {\n+                    ty::FnPtr(_) => Some(\"function pointers\"),\n+                    ty::RawPtr(_) => Some(\"raw pointers\"),\n+                    _ => None,\n+                }\n+            };\n+            if let Some(unsupported_type) = err {\n+                if is_ptr {\n+                    tcx.sess.span_err(\n+                        hir_ty.span,\n+                        &format!(\n+                            \"using {} as const generic parameters is forbidden\",\n+                            unsupported_type\n+                        ),\n+                    )\n+                } else {\n+                    tcx.sess\n+                        .struct_span_err(\n+                            hir_ty.span,\n+                            &format!(\n+                                \"{} is forbidden as the type of a const generic parameter\",\n+                                unsupported_type\n+                            ),\n+                        )\n+                        .note(\"the only supported types are integers, `bool` and `char`\")\n+                        .note(\"more complex types are supported with `#[feature(const_generics)]`\")\n+                        .emit()\n+                }\n+            };\n+\n+            if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n+                .is_some()\n+            {\n+                // We use the same error code in both branches, because this is really the same\n+                // issue: we just special-case the message for type parameters to make it\n+                // clearer.\n+                if let ty::Param(_) = ty.peel_refs().kind {\n+                    // Const parameters may not have type parameters as their types,\n+                    // because we cannot be sure that the type parameter derives `PartialEq`\n+                    // and `Eq` (just implementing them is not enough for `structural_match`).\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n+                            used as the type of a const parameter\",\n+                        ty,\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .note(\n+                        \"it is not currently possible to use a type parameter as the type of a \\\n+                            const parameter\",\n+                    )\n+                    .emit();\n+                } else {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n+                            the type of a const parameter\",\n+                        ty,\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+}\n+\n fn check_associated_item(\n     tcx: TyCtxt<'_>,\n     item_id: hir::HirId,\n@@ -1282,6 +1386,7 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     fcx.select_all_obligations_or_error();\n }\n \n+#[derive(Clone, Copy)]\n pub struct CheckTypeWellFormedVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n }\n@@ -1294,21 +1399,49 @@ impl CheckTypeWellFormedVisitor<'tcx> {\n \n impl ParItemLikeVisitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n     fn visit_item(&self, i: &'tcx hir::Item<'tcx>) {\n+        Visitor::visit_item(&mut self.clone(), i);\n+    }\n+\n+    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        Visitor::visit_trait_item(&mut self.clone(), trait_item);\n+    }\n+\n+    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        Visitor::visit_impl_item(&mut self.clone(), impl_item);\n+    }\n+}\n+\n+impl Visitor<'tcx> for CheckTypeWellFormedVisitor<'tcx> {\n+    type Map = hir_map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> hir_visit::NestedVisitorMap<Self::Map> {\n+        hir_visit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx hir::Item<'tcx>) {\n         debug!(\"visit_item: {:?}\", i);\n         let def_id = self.tcx.hir().local_def_id(i.hir_id);\n         self.tcx.ensure().check_item_well_formed(def_id);\n+        hir_visit::walk_item(self, i);\n     }\n \n-    fn visit_trait_item(&self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n         let def_id = self.tcx.hir().local_def_id(trait_item.hir_id);\n         self.tcx.ensure().check_trait_item_well_formed(def_id);\n+        hir_visit::walk_trait_item(self, trait_item);\n     }\n \n-    fn visit_impl_item(&self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n         let def_id = self.tcx.hir().local_def_id(impl_item.hir_id);\n         self.tcx.ensure().check_impl_item_well_formed(def_id);\n+        hir_visit::walk_impl_item(self, impl_item);\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        check_param_wf(self.tcx, p);\n+        hir_visit::walk_generic_param(self, p);\n     }\n }\n "}, {"sha": "70ed92c5614a1ad8e88099ad867cff7309dca6f4", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 2, "deletions": 83, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -12,7 +12,6 @@ use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_span::symbol::Ident;\n use rustc_span::{Span, DUMMY_SP};\n-use rustc_trait_selection::traits;\n \n use super::ItemCtxt;\n use super::{bad_placeholder_type, is_suggestable_infer_ty};\n@@ -323,88 +322,8 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         }\n \n         Node::GenericParam(param) => match &param.kind {\n-            GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n-            GenericParamKind::Const { ty: ref hir_ty, .. } => {\n-                let ty = icx.to_ty(hir_ty);\n-                let err_ty_str;\n-                let err = if tcx.features().min_const_generics {\n-                    match ty.kind {\n-                        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Error(_) => None,\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => {\n-                            err_ty_str = format!(\"`{}`\", ty);\n-                            Some(err_ty_str.as_str())\n-                        }\n-                    }\n-                } else {\n-                    match ty.peel_refs().kind {\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => None,\n-                    }\n-                };\n-                if let Some(unsupported_type) = err {\n-                    let mut err = tcx.sess.struct_span_err(\n-                        hir_ty.span,\n-                        &format!(\n-                            \"using {} as const generic parameters is forbidden\",\n-                            unsupported_type\n-                        ),\n-                    );\n-\n-                    if tcx.features().min_const_generics {\n-                        err.note(\"the only supported types are integers, `bool` and `char`\")\n-                        .note(\"more complex types are supported with `#[feature(const_generics)]`\").emit()\n-                    } else {\n-                        err.emit();\n-                    }\n-                };\n-                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                    .is_some()\n-                {\n-                    // We use the same error code in both branches, because this is really the same\n-                    // issue: we just special-case the message for type parameters to make it\n-                    // clearer.\n-                    if let ty::Param(_) = ty.peel_refs().kind {\n-                        // Const parameters may not have type parameters as their types,\n-                        // because we cannot be sure that the type parameter derives `PartialEq`\n-                        // and `Eq` (just implementing them is not enough for `structural_match`).\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` is not guaranteed to `#[derive(PartialEq, Eq)]`, so may not be \\\n-                             used as the type of a const parameter\",\n-                            ty,\n-                        )\n-                        .span_label(\n-                            hir_ty.span,\n-                            format!(\"`{}` may not derive both `PartialEq` and `Eq`\", ty),\n-                        )\n-                        .note(\n-                            \"it is not currently possible to use a type parameter as the type of a \\\n-                             const parameter\",\n-                        )\n-                        .emit();\n-                    } else {\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            hir_ty.span,\n-                            E0741,\n-                            \"`{}` must be annotated with `#[derive(PartialEq, Eq)]` to be used as \\\n-                             the type of a const parameter\",\n-                            ty,\n-                        )\n-                        .span_label(\n-                            hir_ty.span,\n-                            format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                        )\n-                        .emit();\n-                    }\n-                }\n-                ty\n-            }\n+            GenericParamKind::Type { default: Some(ty), .. }\n+            | GenericParamKind::Const { ty, .. } => icx.to_ty(ty),\n             x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n         },\n "}, {"sha": "1354ef5cbdeb4982aef4b7ca5fc222f3e29c5d13", "filename": "src/librustdoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2FCargo.toml?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -14,5 +14,6 @@ minifier = \"0.0.33\"\n rayon = { version = \"0.3.0\", package = \"rustc-rayon\" }\n serde = { version = \"1.0\", features = [\"derive\"] }\n serde_json = \"1.0\"\n+smallvec = \"1.0\"\n tempfile = \"3\"\n itertools = \"0.8\""}, {"sha": "3eac5bbda007898b9c5f31a3df2e2ba0037d2049", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -3,6 +3,7 @@ use std::default::Default;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n use std::iter::FromIterator;\n+use std::lazy::SyncOnceCell as OnceCell;\n use std::num::NonZeroU32;\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -19,12 +20,14 @@ use rustc_hir::lang_items;\n use rustc_hir::Mutability;\n use rustc_index::vec::IndexVec;\n use rustc_middle::middle::stability;\n+use rustc_middle::ty::TyCtxt;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::DUMMY_SP;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{self, FileName};\n use rustc_target::abi::VariantIdx;\n use rustc_target::spec::abi::Abi;\n+use smallvec::{smallvec, SmallVec};\n \n use crate::clean::cfg::Cfg;\n use crate::clean::external_path;\n@@ -1264,6 +1267,86 @@ impl PrimitiveType {\n         }\n     }\n \n+    pub fn impls(&self, tcx: TyCtxt<'_>) -> &'static SmallVec<[DefId; 4]> {\n+        Self::all_impls(tcx).get(self).expect(\"missing impl for primitive type\")\n+    }\n+\n+    pub fn all_impls(tcx: TyCtxt<'_>) -> &'static FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>> {\n+        static CELL: OnceCell<FxHashMap<PrimitiveType, SmallVec<[DefId; 4]>>> = OnceCell::new();\n+\n+        CELL.get_or_init(move || {\n+            use self::PrimitiveType::*;\n+\n+            /// A macro to create a FxHashMap.\n+            ///\n+            /// Example:\n+            ///\n+            /// ```\n+            /// let letters = map!{\"a\" => \"b\", \"c\" => \"d\"};\n+            /// ```\n+            ///\n+            /// Trailing commas are allowed.\n+            /// Commas between elements are required (even if the expression is a block).\n+            macro_rules! map {\n+                ($( $key: expr => $val: expr ),* $(,)*) => {{\n+                    let mut map = ::rustc_data_structures::fx::FxHashMap::default();\n+                    $( map.insert($key, $val); )*\n+                    map\n+                }}\n+            }\n+\n+            let single = |a: Option<DefId>| a.into_iter().collect();\n+            let both = |a: Option<DefId>, b: Option<DefId>| -> SmallVec<_> {\n+                a.into_iter().chain(b).collect()\n+            };\n+\n+            let lang_items = tcx.lang_items();\n+            map! {\n+                Isize => single(lang_items.isize_impl()),\n+                I8 => single(lang_items.i8_impl()),\n+                I16 => single(lang_items.i16_impl()),\n+                I32 => single(lang_items.i32_impl()),\n+                I64 => single(lang_items.i64_impl()),\n+                I128 => single(lang_items.i128_impl()),\n+                Usize => single(lang_items.usize_impl()),\n+                U8 => single(lang_items.u8_impl()),\n+                U16 => single(lang_items.u16_impl()),\n+                U32 => single(lang_items.u32_impl()),\n+                U64 => single(lang_items.u64_impl()),\n+                U128 => single(lang_items.u128_impl()),\n+                F32 => both(lang_items.f32_impl(), lang_items.f32_runtime_impl()),\n+                F64 => both(lang_items.f64_impl(), lang_items.f64_runtime_impl()),\n+                Char => single(lang_items.char_impl()),\n+                Bool => single(lang_items.bool_impl()),\n+                Str => both(lang_items.str_impl(), lang_items.str_alloc_impl()),\n+                Slice => {\n+                    lang_items\n+                        .slice_impl()\n+                        .into_iter()\n+                        .chain(lang_items.slice_u8_impl())\n+                        .chain(lang_items.slice_alloc_impl())\n+                        .chain(lang_items.slice_u8_alloc_impl())\n+                        .collect()\n+                },\n+                Array => single(lang_items.array_impl()),\n+                Tuple => smallvec![],\n+                Unit => smallvec![],\n+                RawPointer => {\n+                    lang_items\n+                        .const_ptr_impl()\n+                        .into_iter()\n+                        .chain(lang_items.mut_ptr_impl())\n+                        .chain(lang_items.const_slice_ptr_impl())\n+                        .chain(lang_items.mut_slice_ptr_impl())\n+                        .collect()\n+                },\n+                Reference => smallvec![],\n+                Fn => smallvec![],\n+                Never => smallvec![],\n+            }\n+        })\n+    }\n+\n     pub fn to_url_str(&self) -> &'static str {\n         self.as_str()\n     }"}, {"sha": "75fdcd5ec1c9c75d395f7e0e5d0381dc82acd6e6", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -351,7 +351,6 @@ pub fn qpath_to_string(p: &hir::QPath<'_>) -> String {\n }\n \n pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut Vec<Item>) {\n-    use self::PrimitiveType::*;\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -370,34 +369,7 @@ pub fn build_deref_target_impls(cx: &DocContext<'_>, items: &[Item], ret: &mut V\n                 None => continue,\n             },\n         };\n-        let did = match primitive {\n-            Isize => tcx.lang_items().isize_impl(),\n-            I8 => tcx.lang_items().i8_impl(),\n-            I16 => tcx.lang_items().i16_impl(),\n-            I32 => tcx.lang_items().i32_impl(),\n-            I64 => tcx.lang_items().i64_impl(),\n-            I128 => tcx.lang_items().i128_impl(),\n-            Usize => tcx.lang_items().usize_impl(),\n-            U8 => tcx.lang_items().u8_impl(),\n-            U16 => tcx.lang_items().u16_impl(),\n-            U32 => tcx.lang_items().u32_impl(),\n-            U64 => tcx.lang_items().u64_impl(),\n-            U128 => tcx.lang_items().u128_impl(),\n-            F32 => tcx.lang_items().f32_impl(),\n-            F64 => tcx.lang_items().f64_impl(),\n-            Char => tcx.lang_items().char_impl(),\n-            Bool => tcx.lang_items().bool_impl(),\n-            Str => tcx.lang_items().str_impl(),\n-            Slice => tcx.lang_items().slice_impl(),\n-            Array => tcx.lang_items().array_impl(),\n-            Tuple => None,\n-            Unit => None,\n-            RawPointer => tcx.lang_items().const_ptr_impl(),\n-            Reference => None,\n-            Fn => None,\n-            Never => None,\n-        };\n-        if let Some(did) = did {\n+        for &did in primitive.impls(tcx) {\n             if !did.is_local() {\n                 inline::build_impl(cx, did, None, ret);\n             }"}, {"sha": "3dfa7b529e34cc42e084af05fe31f2e8294e5b87", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -12,6 +12,7 @@\n #![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n+#![feature(once_cell)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "97b9fcce05b362e72d2ddd06926a5151256cea00", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 23, "deletions": 34, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -16,6 +16,7 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::Ident;\n use rustc_span::symbol::Symbol;\n use rustc_span::DUMMY_SP;\n+use smallvec::SmallVec;\n \n use std::cell::Cell;\n use std::ops::Range;\n@@ -270,18 +271,26 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .ok_or(ErrorKind::ResolutionFailure)?;\n \n             if let Some((path, prim)) = is_primitive(&path, TypeNS) {\n-                let did = primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)?;\n-                return cx\n-                    .tcx\n-                    .associated_items(did)\n-                    .filter_by_name_unhygienic(item_name)\n-                    .next()\n-                    .and_then(|item| match item.kind {\n-                        ty::AssocKind::Fn => Some(\"method\"),\n-                        _ => None,\n-                    })\n-                    .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))))\n-                    .ok_or(ErrorKind::ResolutionFailure);\n+                for &impl_ in primitive_impl(cx, &path).ok_or(ErrorKind::ResolutionFailure)? {\n+                    let link = cx\n+                        .tcx\n+                        .associated_items(impl_)\n+                        .find_by_name_and_namespace(\n+                            cx.tcx,\n+                            Ident::with_dummy_span(item_name),\n+                            ns,\n+                            impl_,\n+                        )\n+                        .and_then(|item| match item.kind {\n+                            ty::AssocKind::Fn => Some(\"method\"),\n+                            _ => None,\n+                        })\n+                        .map(|out| (prim, Some(format!(\"{}#{}.{}\", path, out, item_name))));\n+                    if let Some(link) = link {\n+                        return Ok(link);\n+                    }\n+                }\n+                return Err(ErrorKind::ResolutionFailure);\n             }\n \n             let (_, ty_res) = cx\n@@ -1238,26 +1247,6 @@ fn is_primitive(path_str: &str, ns: Namespace) -> Option<(&'static str, Res)> {\n     }\n }\n \n-fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<DefId> {\n-    let tcx = cx.tcx;\n-    match path_str {\n-        \"u8\" => tcx.lang_items().u8_impl(),\n-        \"u16\" => tcx.lang_items().u16_impl(),\n-        \"u32\" => tcx.lang_items().u32_impl(),\n-        \"u64\" => tcx.lang_items().u64_impl(),\n-        \"u128\" => tcx.lang_items().u128_impl(),\n-        \"usize\" => tcx.lang_items().usize_impl(),\n-        \"i8\" => tcx.lang_items().i8_impl(),\n-        \"i16\" => tcx.lang_items().i16_impl(),\n-        \"i32\" => tcx.lang_items().i32_impl(),\n-        \"i64\" => tcx.lang_items().i64_impl(),\n-        \"i128\" => tcx.lang_items().i128_impl(),\n-        \"isize\" => tcx.lang_items().isize_impl(),\n-        \"f32\" => tcx.lang_items().f32_impl(),\n-        \"f64\" => tcx.lang_items().f64_impl(),\n-        \"str\" => tcx.lang_items().str_impl(),\n-        \"bool\" => tcx.lang_items().bool_impl(),\n-        \"char\" => tcx.lang_items().char_impl(),\n-        _ => None,\n-    }\n+fn primitive_impl(cx: &DocContext<'_>, path_str: &str) -> Option<&'static SmallVec<[DefId; 4]>> {\n+    Some(PrimitiveType::from_symbol(Symbol::intern(path_str))?.impls(cx.tcx))\n }"}, {"sha": "24baff46dcfa5404d33ceea58e156f042083a163", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -34,40 +34,7 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n \n     // Also try to inline primitive impls from other crates.\n-    let lang_items = cx.tcx.lang_items();\n-    let primitive_impls = [\n-        lang_items.isize_impl(),\n-        lang_items.i8_impl(),\n-        lang_items.i16_impl(),\n-        lang_items.i32_impl(),\n-        lang_items.i64_impl(),\n-        lang_items.i128_impl(),\n-        lang_items.usize_impl(),\n-        lang_items.u8_impl(),\n-        lang_items.u16_impl(),\n-        lang_items.u32_impl(),\n-        lang_items.u64_impl(),\n-        lang_items.u128_impl(),\n-        lang_items.f32_impl(),\n-        lang_items.f64_impl(),\n-        lang_items.f32_runtime_impl(),\n-        lang_items.f64_runtime_impl(),\n-        lang_items.bool_impl(),\n-        lang_items.char_impl(),\n-        lang_items.str_impl(),\n-        lang_items.array_impl(),\n-        lang_items.slice_impl(),\n-        lang_items.slice_u8_impl(),\n-        lang_items.str_alloc_impl(),\n-        lang_items.slice_alloc_impl(),\n-        lang_items.slice_u8_alloc_impl(),\n-        lang_items.const_ptr_impl(),\n-        lang_items.mut_ptr_impl(),\n-        lang_items.const_slice_ptr_impl(),\n-        lang_items.mut_slice_ptr_impl(),\n-    ];\n-\n-    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+    for &def_id in PrimitiveType::all_impls(cx.tcx).values().flatten() {\n         if !def_id.is_local() {\n             inline::build_impl(cx, def_id, None, &mut new_items);\n "}, {"sha": "2c4f7544844d06eb2644c1213b87ce7813a28fe8", "filename": "src/test/mir-opt/issue-41697.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue-41697.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue-41697.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n }\n \n // EMIT_MIR_FOR_EACH_BIT_WIDTH\n-// EMIT_MIR issue_41697.{{impl}}-{{constant}}.SimplifyCfg-qualify-consts.after.mir\n+// EMIT_MIR issue_41697.{{impl}}-{{constant}}.SimplifyCfg-promote-consts.after.mir\n impl Foo for [u8; 1+1] {\n     fn get(&self) -> [u8; 2] {\n         *self"}, {"sha": "1cef88fd1096b19b460cb27ad23f90f89b87474c", "filename": "src/test/mir-opt/issue_41697.{{impl}}-{{constant}}.SimplifyCfg-promote-consts.after.mir.32bit", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.32bit", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.32bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.32bit?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-// MIR for `<impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0` after SimplifyCfg-qualify-consts\n+// MIR for `<impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0` after SimplifyCfg-promote-consts\n \n <impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0: usize = {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/issue-41697.rs:18:19: 18:22", "previous_filename": "src/test/mir-opt/issue_41697.{{impl}}-{{constant}}.SimplifyCfg-qualify-consts.after.mir.32bit"}, {"sha": "1cef88fd1096b19b460cb27ad23f90f89b87474c", "filename": "src/test/mir-opt/issue_41697.{{impl}}-{{constant}}.SimplifyCfg-promote-consts.after.mir.64bit", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.64bit", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.64bit", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_41697.%7B%7Bimpl%7D%7D-%7B%7Bconstant%7D%7D.SimplifyCfg-promote-consts.after.mir.64bit?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-// MIR for `<impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0` after SimplifyCfg-qualify-consts\n+// MIR for `<impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0` after SimplifyCfg-promote-consts\n \n <impl at $DIR/issue-41697.rs:18:1: 22:2>::{{constant}}#0: usize = {\n     let mut _0: usize;                   // return place in scope 0 at $DIR/issue-41697.rs:18:19: 18:22", "previous_filename": "src/test/mir-opt/issue_41697.{{impl}}-{{constant}}.SimplifyCfg-qualify-consts.after.mir.64bit"}, {"sha": "b95e73854e35266ece9615039427493460a9bea3", "filename": "src/test/mir-opt/loop_test.main.SimplifyCfg-promote-consts.after.mir", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.main.SimplifyCfg-promote-consts.after.mir?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-// MIR for `main` after SimplifyCfg-qualify-consts\n+// MIR for `main` after SimplifyCfg-promote-consts\n \n fn main() -> () {\n     let mut _0: ();                      // return place in scope 0 at $DIR/loop_test.rs:6:11: 6:11", "previous_filename": "src/test/mir-opt/loop_test.main.SimplifyCfg-qualify-consts.after.mir"}, {"sha": "7ded5b5757f55d0d16223f830a6b85796e113541", "filename": "src/test/mir-opt/loop_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Floop_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fmir-opt%2Floop_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Floop_test.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -2,7 +2,7 @@\n \n // Tests to make sure we correctly generate falseUnwind edges in loops\n \n-// EMIT_MIR loop_test.main.SimplifyCfg-qualify-consts.after.mir\n+// EMIT_MIR loop_test.main.SimplifyCfg-promote-consts.after.mir\n fn main() {\n     // Exit early at runtime. Since only care about the generated MIR\n     // and not the runtime behavior (which is exercised by other tests)"}, {"sha": "160b18a967b201167553f912eae22fc99593c3b7", "filename": "src/test/rustdoc/intra-link-primitive-non-default-impl.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Frustdoc%2Fintra-link-primitive-non-default-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Frustdoc%2Fintra-link-primitive-non-default-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-link-primitive-non-default-impl.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -0,0 +1,32 @@\n+#![deny(broken_intra_doc_links)]\n+\n+// ignore-tidy-linelength\n+\n+// @has intra_link_primitive_non_default_impl/fn.str_methods.html\n+/// [`str::trim`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim\"]' 'str::trim'\n+/// [`str::to_lowercase`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html#method.to_lowercase\"]' 'str::to_lowercase'\n+/// [`str::into_boxed_bytes`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html#method.into_boxed_bytes\"]' 'str::into_boxed_bytes'\n+/// [`str::replace`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html#method.replace\"]' 'str::replace'\n+pub fn str_methods() {}\n+\n+// @has intra_link_primitive_non_default_impl/fn.f32_methods.html\n+/// [f32::powi]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f32.html#method.powi\"]' 'f32::powi'\n+/// [f32::sqrt]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f32.html#method.sqrt\"]' 'f32::sqrt'\n+/// [f32::mul_add]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f32.html#method.mul_add\"]' 'f32::mul_add'\n+pub fn f32_methods() {}\n+\n+// @has intra_link_primitive_non_default_impl/fn.f64_methods.html\n+/// [`f64::powi`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f64.html#method.powi\"]' 'f64::powi'\n+/// [`f64::sqrt`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f64.html#method.sqrt\"]' 'f64::sqrt'\n+/// [`f64::mul_add`]\n+// @has - '//*[@href=\"https://doc.rust-lang.org/nightly/std/primitive.f64.html#method.mul_add\"]' 'f64::mul_add'\n+pub fn f64_methods() {}"}, {"sha": "809514e8a1c9da2ecdebddeb3cbf309a61eb098a", "filename": "src/test/ui/const-generics/array-size-in-generic-struct-param.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -14,7 +14,7 @@ LL |     arr: [u8; CFG.arr_size],\n    |\n    = help: it is currently only allowed to use either `CFG` or `{ CFG }` as generic constants\n \n-error: using `Config` as const generic parameters is forbidden\n+error: `Config` is forbidden as the type of a const generic parameter\n   --> $DIR/array-size-in-generic-struct-param.rs:18:21\n    |\n LL | struct B<const CFG: Config> {"}, {"sha": "8bd3b78725957785ddf5f7509e52e60c0d020fdd", "filename": "src/test/ui/const-generics/array-size-in-generic-struct-param.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-size-in-generic-struct-param.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -16,7 +16,7 @@ struct Config {\n }\n \n struct B<const CFG: Config> {\n-    //[min]~^ ERROR using `Config` as const generic parameters is forbidden\n+    //[min]~^ ERROR `Config` is forbidden\n     arr: [u8; CFG.arr_size],\n     //[full]~^ ERROR constant expression depends on a generic parameter\n     //[min]~^^ ERROR generic parameters must not be used inside of non trivial"}, {"sha": "81dbaee0ec514ff062cd597731958f1d6d483e59", "filename": "src/test/ui/const-generics/const-param-elided-lifetime.min.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -28,7 +28,7 @@ error[E0637]: `&` without an explicit lifetime name cannot be used here\n LL | fn bar<const N: &u8>() {}\n    |                 ^ explicit lifetime name needed here\n \n-error: using `&'static u8` as const generic parameters is forbidden\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:11:19\n    |\n LL | struct A<const N: &u8>;\n@@ -37,7 +37,7 @@ LL | struct A<const N: &u8>;\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static u8` as const generic parameters is forbidden\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:16:15\n    |\n LL | impl<const N: &u8> A<N> {\n@@ -46,7 +46,7 @@ LL | impl<const N: &u8> A<N> {\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static u8` as const generic parameters is forbidden\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:24:15\n    |\n LL | impl<const N: &u8> B for A<N> {}\n@@ -55,7 +55,7 @@ LL | impl<const N: &u8> B for A<N> {}\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static u8` as const generic parameters is forbidden\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:28:17\n    |\n LL | fn bar<const N: &u8>() {}\n@@ -64,7 +64,7 @@ LL | fn bar<const N: &u8>() {}\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static u8` as const generic parameters is forbidden\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-elided-lifetime.rs:19:21\n    |\n LL |     fn foo<const M: &u8>(&self) {}"}, {"sha": "633e876f1d7dd29c054eed348a3c317a848fc591", "filename": "src/test/ui/const-generics/const-param-elided-lifetime.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-elided-lifetime.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -10,23 +10,23 @@\n \n struct A<const N: &u8>;\n //~^ ERROR `&` without an explicit lifetime name cannot be used here\n-//[min]~^^ ERROR using `&'static u8` as const generic parameters is forbidden\n+//[min]~^^ ERROR `&'static u8` is forbidden\n trait B {}\n \n impl<const N: &u8> A<N> {\n //~^ ERROR `&` without an explicit lifetime name cannot be used here\n-//[min]~^^ ERROR using `&'static u8` as const generic parameters is forbidden\n+//[min]~^^ ERROR `&'static u8` is forbidden\n     fn foo<const M: &u8>(&self) {}\n     //~^ ERROR `&` without an explicit lifetime name cannot be used here\n-    //[min]~^^ ERROR using `&'static u8` as const generic parameters is forbidden\n+    //[min]~^^ ERROR `&'static u8` is forbidden\n }\n \n impl<const N: &u8> B for A<N> {}\n //~^ ERROR `&` without an explicit lifetime name cannot be used here\n-//[min]~^^ ERROR using `&'static u8` as const generic parameters is forbidden\n+//[min]~^^ ERROR `&'static u8` is forbidden\n \n fn bar<const N: &u8>() {}\n //~^ ERROR `&` without an explicit lifetime name cannot be used here\n-//[min]~^^ ERROR using `&'static u8` as const generic parameters is forbidden\n+//[min]~^^ ERROR `&'static u8` is forbidden\n \n fn main() {}"}, {"sha": "b00a160787629a1be9be1ba90b4de8e57d82592a", "filename": "src/test/ui/const-generics/const-param-type-depends-on-const-param.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -10,7 +10,7 @@ error[E0770]: the type of const parameters must not depend on other generic para\n LL | pub struct SelfDependent<const N: [u8; N]>;\n    |                                        ^ the type must not depend on the parameter `N`\n \n-error: using `[u8; _]` as const generic parameters is forbidden\n+error: `[u8; _]` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-type-depends-on-const-param.rs:12:47\n    |\n LL | pub struct Dependent<const N: usize, const X: [u8; N]>([(); N]);\n@@ -19,7 +19,7 @@ LL | pub struct Dependent<const N: usize, const X: [u8; N]>([(); N]);\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `[u8; _]` as const generic parameters is forbidden\n+error: `[u8; _]` is forbidden as the type of a const generic parameter\n   --> $DIR/const-param-type-depends-on-const-param.rs:16:35\n    |\n LL | pub struct SelfDependent<const N: [u8; N]>;"}, {"sha": "29371eeb21d1cf0721c0370982eb6009d6f1a910", "filename": "src/test/ui/const-generics/const-param-type-depends-on-const-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst-param-type-depends-on-const-param.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -11,10 +11,10 @@\n \n pub struct Dependent<const N: usize, const X: [u8; N]>([(); N]);\n //~^ ERROR: the type of const parameters must not depend on other generic parameters\n-//[min]~^^ ERROR using `[u8; _]` as const generic parameters is forbidden\n+//[min]~^^ ERROR `[u8; _]` is forbidden\n \n pub struct SelfDependent<const N: [u8; N]>;\n //~^ ERROR: the type of const parameters must not depend on other generic parameters\n-//[min]~^^ ERROR using `[u8; _]` as const generic parameters is forbidden\n+//[min]~^^ ERROR `[u8; _]` is forbidden\n \n fn main() {}"}, {"sha": "050b28abe5088168cdc1c8f402489ed3d7a1d6f9", "filename": "src/test/ui/const-generics/different_byref.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `[usize; 1]` as const generic parameters is forbidden\n+error: `[usize; 1]` is forbidden as the type of a const generic parameter\n   --> $DIR/different_byref.rs:8:23\n    |\n LL | struct Const<const V: [usize; 1]> {}"}, {"sha": "cd3960eeb8e0d16cab324fcfe6468f020ca149cb", "filename": "src/test/ui/const-generics/different_byref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_byref.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -6,7 +6,7 @@\n #![cfg_attr(min, feature(min_const_generics))]\n \n struct Const<const V: [usize; 1]> {}\n-//[min]~^ using `[usize; 1]` as const generic parameters is forbidden\n+//[min]~^ ERROR `[usize; 1]` is forbidden\n \n fn main() {\n     let mut x = Const::<{ [3] }> {};"}, {"sha": "f1bd8def9ff161cf89c88289aaf01f5315ab2bba", "filename": "src/test/ui/const-generics/fn-const-param-call.min.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-call.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -3,18 +3,12 @@ error: using function pointers as const generic parameters is forbidden\n    |\n LL | struct Wrapper<const F: fn() -> u32>;\n    |                         ^^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: using function pointers as const generic parameters is forbidden\n   --> $DIR/fn-const-param-call.rs:14:15\n    |\n LL | impl<const F: fn() -> u32> Wrapper<F> {\n    |               ^^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4bdc9b89af607d25e63f90cbbb4292a034dd1c39", "filename": "src/test/ui/const-generics/fn-const-param-infer.min.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ffn-const-param-infer.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -3,9 +3,6 @@ error: using function pointers as const generic parameters is forbidden\n    |\n LL | struct Checked<const F: fn(usize) -> bool>;\n    |                         ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "40d8f44cafc04c8f5dc1d678c4e6849de2b30ce8", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `A` as const generic parameters is forbidden\n+error: `A` is forbidden as the type of a const generic parameter\n   --> $DIR/forbid-non-structural_match-types.rs:10:19\n    |\n LL | struct B<const X: A>; // ok\n@@ -7,7 +7,7 @@ LL | struct B<const X: A>; // ok\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `C` as const generic parameters is forbidden\n+error: `C` is forbidden as the type of a const generic parameter\n   --> $DIR/forbid-non-structural_match-types.rs:15:19\n    |\n LL | struct D<const X: C>;"}, {"sha": "e7356d485dbffa662f21f30259e03e1846598a11", "filename": "src/test/ui/const-generics/forbid-non-structural_match-types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fforbid-non-structural_match-types.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -8,11 +8,11 @@\n struct A;\n \n struct B<const X: A>; // ok\n-//[min]~^ ERROR using `A` as const generic parameters is forbidden\n+//[min]~^ ERROR `A` is forbidden\n \n struct C;\n \n struct D<const X: C>; //~ ERROR `C` must be annotated with `#[derive(PartialEq, Eq)]`\n-//[min]~^ ERROR using `C` as const generic parameters is forbidden\n+//[min]~^ ERROR `C` is forbidden\n \n fn main() {}"}, {"sha": "786ded3c2fe42aabc4b2201d3fcb021fd410db84", "filename": "src/test/ui/const-generics/issue-66596-impl-trait-for-str-const-arg.min.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `&'static str` as const generic parameters is forbidden\n+error: `&'static str` is forbidden as the type of a const generic parameter\n   --> $DIR/issue-66596-impl-trait-for-str-const-arg.rs:9:25\n    |\n LL | trait Trait<const NAME: &'static str> {"}, {"sha": "11d4bf4c3e6aa87f58b688f0f6a20d69457fcade", "filename": "src/test/ui/const-generics/issue-66596-impl-trait-for-str-const-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66596-impl-trait-for-str-const-arg.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -7,7 +7,7 @@\n \n \n trait Trait<const NAME: &'static str> {\n-//[min]~^ ERROR using `&'static str` as const generic parameters is forbidden\n+//[min]~^ ERROR `&'static str` is forbidden\n     type Assoc;\n }\n "}, {"sha": "bcb27d8d1e19740a4f1a3c975c01393077b354a2", "filename": "src/test/ui/const-generics/issues/issue-56445.min.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -6,15 +6,6 @@ LL | struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n    |\n    = note: for more information, see issue #74052 <https://github.com/rust-lang/rust/issues/74052>\n \n-error: using `&'static str` as const generic parameters is forbidden\n-  --> $DIR/issue-56445.rs:9:25\n-   |\n-LL | struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n-   |                         ^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n-\n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0771`."}, {"sha": "0bcde348b05d5d1ef52d007fe1941481162ae5a3", "filename": "src/test/ui/const-generics/issues/issue-56445.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-56445.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -8,6 +8,5 @@ use std::marker::PhantomData;\n \n struct Bug<'a, const S: &'a str>(PhantomData<&'a ()>);\n //~^ ERROR: use of non-static lifetime `'a` in const generic\n-//[min]~| ERROR: using `&'static str` as const\n \n impl Bug<'_, \"\"> {}"}, {"sha": "f093e6651bc2826bd14c7536ea3264f3a32e31c4", "filename": "src/test/ui/const-generics/issues/issue-74950.min.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -0,0 +1,47 @@\n+error: `Inner` is forbidden as the type of a const generic parameter\n+  --> $DIR/issue-74950.rs:18:23\n+   |\n+LL | struct Outer<const I: Inner>;\n+   |                       ^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `Inner` is forbidden as the type of a const generic parameter\n+  --> $DIR/issue-74950.rs:18:23\n+   |\n+LL | struct Outer<const I: Inner>;\n+   |                       ^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `Inner` is forbidden as the type of a const generic parameter\n+  --> $DIR/issue-74950.rs:18:23\n+   |\n+LL | struct Outer<const I: Inner>;\n+   |                       ^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `Inner` is forbidden as the type of a const generic parameter\n+  --> $DIR/issue-74950.rs:18:23\n+   |\n+LL | struct Outer<const I: Inner>;\n+   |                       ^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: `Inner` is forbidden as the type of a const generic parameter\n+  --> $DIR/issue-74950.rs:18:23\n+   |\n+LL | struct Outer<const I: Inner>;\n+   |                       ^^^^^\n+   |\n+   = note: the only supported types are integers, `bool` and `char`\n+   = note: more complex types are supported with `#[feature(const_generics)]`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "39f91f2b83dfbe7a08687457e57a5abf124c57ca", "filename": "src/test/ui/const-generics/issues/issue-74950.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74950.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -0,0 +1,25 @@\n+// [full] build-pass\n+// revisions: full min\n+#![cfg_attr(full, feature(const_generics))]\n+#![cfg_attr(full, allow(incomplete_features))]\n+#![cfg_attr(min, feature(min_const_generics))]\n+\n+\n+#[derive(PartialEq, Eq)]\n+struct Inner;\n+\n+// Note: We emit the error 5 times if we don't deduplicate:\n+// - struct definition\n+// - impl PartialEq\n+// - impl Eq\n+// - impl StructuralPartialEq\n+// - impl StructuralEq\n+#[derive(PartialEq, Eq)]\n+struct Outer<const I: Inner>;\n+//[min]~^ `Inner` is forbidden\n+//[min]~| `Inner` is forbidden\n+//[min]~| `Inner` is forbidden\n+//[min]~| `Inner` is forbidden\n+//[min]~| `Inner` is forbidden\n+\n+fn main() {}"}, {"sha": "5d068d851c10bcb3965fec486c6abce352b56bb1", "filename": "src/test/ui/const-generics/issues/issue-75047.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-75047.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -0,0 +1,15 @@\n+// check-pass\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+struct Bar<T>(T);\n+\n+impl<T> Bar<T> {\n+    const fn value() -> usize {\n+        42\n+    }\n+}\n+\n+struct Foo<const N: [u8; Bar::<u32>::value()]>;\n+\n+fn main() {}"}, {"sha": "98bc99d019421f3c6f69344d3df62502678d3999", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,18 +1,17 @@\n #![feature(min_const_generics)]\n \n struct Foo<const N: [u8; 0]>;\n-//~^ ERROR using `[u8; 0]` as const generic parameters is forbidden\n+//~^ ERROR `[u8; 0]` is forbidden\n \n struct Bar<const N: ()>;\n-//~^ ERROR using `()` as const generic parameters is forbidden\n-\n+//~^ ERROR `()` is forbidden\n #[derive(PartialEq, Eq)]\n struct No;\n \n struct Fez<const N: No>;\n-//~^ ERROR using `No` as const generic parameters is forbidden\n+//~^ ERROR `No` is forbidden\n \n struct Faz<const N: &'static u8>;\n-//~^ ERROR using `&'static u8` as const generic parameters is forbidden\n+//~^ ERROR `&'static u8` is forbidden\n \n fn main() {}"}, {"sha": "4772aaf1b3e0c252c2fdec741953387892dc79b5", "filename": "src/test/ui/const-generics/min_const_generics/complex-types.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fmin_const_generics%2Fcomplex-types.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `[u8; 0]` as const generic parameters is forbidden\n+error: `[u8; 0]` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:3:21\n    |\n LL | struct Foo<const N: [u8; 0]>;\n@@ -7,7 +7,7 @@ LL | struct Foo<const N: [u8; 0]>;\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `()` as const generic parameters is forbidden\n+error: `()` is forbidden as the type of a const generic parameter\n   --> $DIR/complex-types.rs:6:21\n    |\n LL | struct Bar<const N: ()>;\n@@ -16,17 +16,17 @@ LL | struct Bar<const N: ()>;\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `No` as const generic parameters is forbidden\n-  --> $DIR/complex-types.rs:12:21\n+error: `No` is forbidden as the type of a const generic parameter\n+  --> $DIR/complex-types.rs:11:21\n    |\n LL | struct Fez<const N: No>;\n    |                     ^^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static u8` as const generic parameters is forbidden\n-  --> $DIR/complex-types.rs:15:21\n+error: `&'static u8` is forbidden as the type of a const generic parameter\n+  --> $DIR/complex-types.rs:14:21\n    |\n LL | struct Faz<const N: &'static u8>;\n    |                     ^^^^^^^^^^^"}, {"sha": "ded6f882caf42f139cd5a2850645ca3ec5c66b88", "filename": "src/test/ui/const-generics/nested-type.full.stderr", "status": "modified", "additions": 10, "deletions": 153, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,159 +1,16 @@\n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/nested-type.rs:16:5\n    |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n-   |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/nested-type.rs:16:5\n    |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^ calling non-const function `Foo::{{constant}}#0::Foo::<17_usize>::value`\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "55f6fe7cc16e85eab2dc01521212e4a21576fdbd", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 14, "deletions": 157, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,175 +1,32 @@\n-error: using `[u8; _]` as const generic parameters is forbidden\n+error: `[u8; _]` is forbidden as the type of a const generic parameter\n   --> $DIR/nested-type.rs:7:21\n    |\n LL |   struct Foo<const N: [u8; {\n    |  _____________________^\n+LL | |     struct Foo<const N: usize>;\n LL | |\n-LL | |\n-LL | |\n+LL | |     impl<const N: usize> Foo<N> {\n ...  |\n-LL | |     Foo::<17>::value()\n+LL | |\n LL | | }]>;\n    | |__^\n    |\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n+error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+  --> $DIR/nested-type.rs:16:5\n    |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n-   |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^\n \n-error[E0391]: cycle detected when computing type of `Foo`\n-  --> $DIR/nested-type.rs:7:1\n-   |\n-LL | struct Foo<const N: [u8; {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: ...which requires computing type of `Foo::N`...\n-  --> $DIR/nested-type.rs:7:18\n-   |\n-LL | struct Foo<const N: [u8; {\n-   |                  ^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating + checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires const-evaluating `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/nested-type.rs:16:5\n    |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires type-checking `Foo::{{constant}}#0`...\n-  --> $DIR/nested-type.rs:7:26\n-   |\n-LL |   struct Foo<const N: [u8; {\n-   |  __________________________^\n-LL | |\n-LL | |\n-LL | |\n-...  |\n-LL | |     Foo::<17>::value()\n-LL | | }]>;\n-   | |_^\n-note: ...which requires computing the variances of `Foo::{{constant}}#0::Foo`...\n-  --> $DIR/nested-type.rs:11:5\n-   |\n-LL |     struct Foo<const N: usize>;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: ...which requires computing the variances for items in this crate...\n-   = note: ...which again requires computing type of `Foo`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/nested-type.rs:3:1\n-   |\n-LL | / #![cfg_attr(full, feature(const_generics))]\n-LL | | #![cfg_attr(full, allow(incomplete_features))]\n-LL | | #![cfg_attr(min, feature(min_const_generics))]\n-LL | |\n-...  |\n-LL | |\n-LL | | fn main() {}\n-   | |____________^\n+LL |     Foo::<17>::value()\n+   |     ^^^^^^^^^^^^^^^^^^ calling non-const function `Foo::{{constant}}#0::Foo::<17_usize>::value`\n \n error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0391`.\n+Some errors have detailed explanations: E0015, E0080.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "8372551fb450b5293254031f60a3a0b0d26b840c", "filename": "src/test/ui/const-generics/nested-type.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -4,10 +4,7 @@\n #![cfg_attr(full, allow(incomplete_features))]\n #![cfg_attr(min, feature(min_const_generics))]\n \n-struct Foo<const N: [u8; {\n-//~^ ERROR cycle detected\n-//~| ERROR cycle detected\n-//[min]~| ERROR using `[u8; _]` as const generic\n+struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     struct Foo<const N: usize>;\n \n     impl<const N: usize> Foo<N> {\n@@ -17,6 +14,8 @@ struct Foo<const N: [u8; {\n     }\n \n     Foo::<17>::value()\n+    //~^ ERROR calls in constants are limited to constant functions\n+    //~| ERROR evaluation of constant value failed\n }]>;\n \n fn main() {}"}, {"sha": "ffaab51f766d8d8b264c03f9096935041fc9a7cc", "filename": "src/test/ui/const-generics/raw-ptr-const-param-deref.min.stderr", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param-deref.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -3,18 +3,12 @@ error: using raw pointers as const generic parameters is forbidden\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: using raw pointers as const generic parameters is forbidden\n   --> $DIR/raw-ptr-const-param-deref.rs:12:15\n    |\n LL | impl<const P: *const u32> Const<P> {\n    |               ^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "d317aa0f585cf9c616ae74b02b5f952ee24a5faa", "filename": "src/test/ui/const-generics/raw-ptr-const-param.min.stderr", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fraw-ptr-const-param.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -3,9 +3,6 @@ error: using raw pointers as const generic parameters is forbidden\n    |\n LL | struct Const<const P: *const u32>;\n    |                       ^^^^^^^^^^\n-   |\n-   = note: the only supported types are integers, `bool` and `char`\n-   = note: more complex types are supported with `#[feature(const_generics)]`\n \n error: aborting due to previous error\n "}, {"sha": "1f711bef4aa633bed823f9ec73383956e8d4ce6a", "filename": "src/test/ui/const-generics/slice-const-param-mismatch.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param-mismatch.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `&'static str` as const generic parameters is forbidden\n+error: `&'static str` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param-mismatch.rs:8:29\n    |\n LL | struct ConstString<const T: &'static str>;\n@@ -7,7 +7,7 @@ LL | struct ConstString<const T: &'static str>;\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static [u8]` as const generic parameters is forbidden\n+error: `&'static [u8]` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param-mismatch.rs:10:28\n    |\n LL | struct ConstBytes<const T: &'static [u8]>;"}, {"sha": "2a49619e6614ae308b4f554b9dab88001f6299c1", "filename": "src/test/ui/const-generics/slice-const-param.min.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.min.stderr?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -1,4 +1,4 @@\n-error: using `&'static str` as const generic parameters is forbidden\n+error: `&'static str` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param.rs:8:40\n    |\n LL | pub fn function_with_str<const STRING: &'static str>() -> &'static str {\n@@ -7,7 +7,7 @@ LL | pub fn function_with_str<const STRING: &'static str>() -> &'static str {\n    = note: the only supported types are integers, `bool` and `char`\n    = note: more complex types are supported with `#[feature(const_generics)]`\n \n-error: using `&'static [u8]` as const generic parameters is forbidden\n+error: `&'static [u8]` is forbidden as the type of a const generic parameter\n   --> $DIR/slice-const-param.rs:13:41\n    |\n LL | pub fn function_with_bytes<const BYTES: &'static [u8]>() -> &'static [u8] {"}, {"sha": "f76e948c4af2b81ef0fce0735719e073ff6d8ccd", "filename": "src/test/ui/const-generics/slice-const-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9900178cba95369cd5822c8ce579edcc89ffeb76/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fslice-const-param.rs?ref=9900178cba95369cd5822c8ce579edcc89ffeb76", "patch": "@@ -6,12 +6,12 @@\n #![cfg_attr(min, feature(min_const_generics))]\n \n pub fn function_with_str<const STRING: &'static str>() -> &'static str {\n-    //[min]~^ ERROR using `&'static str` as const\n+    //[min]~^ ERROR `&'static str` is forbidden\n     STRING\n }\n \n pub fn function_with_bytes<const BYTES: &'static [u8]>() -> &'static [u8] {\n-    //[min]~^ ERROR using `&'static [u8]` as const\n+    //[min]~^ ERROR `&'static [u8]` is forbidden\n     BYTES\n }\n "}]}