{"sha": "8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMzRhOGU0MjIzYTc0NGJjYzRmYjJkNzdjMDZmYjZjMTgzZGNjMjY=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-12-14T16:27:39Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-12-17T00:14:16Z"}, "message": "Definitions: Extract DefPath interning into its own data structure.", "tree": {"sha": "34dd41baffd173df74d38c8f93164c4d5e87667e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34dd41baffd173df74d38c8f93164c4d5e87667e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26", "html_url": "https://github.com/rust-lang/rust/commit/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b407136b7b0ba60af3a6c282b5bef15282d76d", "url": "https://api.github.com/repos/rust-lang/rust/commits/87b407136b7b0ba60af3a6c282b5bef15282d76d", "html_url": "https://github.com/rust-lang/rust/commit/87b407136b7b0ba60af3a6c282b5bef15282d76d"}], "stats": {"total": 108, "additions": 85, "deletions": 23}, "files": [{"sha": "159e80d7d3975ef2b2df5456a2eb9b6268d60fe0", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 85, "deletions": 23, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=8e34a8e4223a744bcc4fb2d77c06fb6c183dcc26", "patch": "@@ -8,28 +8,92 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+\n+//! For each definition, we track the following data.  A definition\n+//! here is defined somewhat circularly as \"something with a def-id\",\n+//! but it generally corresponds to things like structs, enums, etc.\n+//! There are also some rather random cases (like const initializer\n+//! expressions) that are mostly just leftovers.\n+\n+\n+\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::fmt::Write;\n use std::hash::{Hash, Hasher};\n use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use ty::TyCtxt;\n use util::nodemap::NodeMap;\n \n-//! For each definition, we track the following data.  A definition\n-//! here is defined somewhat circularly as \"something with a def-id\",\n-//! but it generally corresponds to things like structs, enums, etc.\n-//! There are also some rather random cases (like const initializer\n-//! expressions) that are mostly just leftovers.\n+#[derive(Clone)]\n+pub struct DefPathTable {\n+    index_to_key: Vec<DefKey>,\n+    key_to_index: FxHashMap<DefKey, DefIndex>,\n+}\n+\n+impl DefPathTable {\n+    fn insert(&mut self, key: DefKey) -> DefIndex {\n+        let index = DefIndex::new(self.index_to_key.len());\n+        debug!(\"DefPathTable::insert() - {:?} <-> {:?}\", key, index);\n+        self.index_to_key.push(key.clone());\n+        self.key_to_index.insert(key, index);\n+        index\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_key(&self, index: DefIndex) -> DefKey {\n+        self.index_to_key[index.as_usize()].clone()\n+    }\n+\n+    #[inline(always)]\n+    pub fn def_index_for_def_key(&self, key: &DefKey) -> Option<DefIndex> {\n+        self.key_to_index.get(key).cloned()\n+    }\n+\n+    #[inline(always)]\n+    pub fn contains_key(&self, key: &DefKey) -> bool {\n+        self.key_to_index.contains_key(key)\n+    }\n+\n+    /// Returns the path from the crate root to `index`. The root\n+    /// nodes are not included in the path (i.e., this will be an\n+    /// empty vector for the crate root). For an inlined item, this\n+    /// will be the path of the item in the external crate (but the\n+    /// path will begin with the path to the external crate).\n+    pub fn def_path(&self, index: DefIndex) -> DefPath {\n+        DefPath::make(LOCAL_CRATE, index, |p| self.def_key(p))\n+    }\n+}\n+\n+\n+impl Encodable for DefPathTable {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        self.index_to_key.encode(s)\n+    }\n+}\n+\n+impl Decodable for DefPathTable {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<DefPathTable, D::Error> {\n+        let index_to_key: Vec<DefKey> = Decodable::decode(d)?;\n+        let key_to_index = index_to_key.iter()\n+                                       .enumerate()\n+                                       .map(|(index, key)| (key.clone(), DefIndex::new(index)))\n+                                       .collect();\n+        Ok(DefPathTable {\n+            index_to_key: index_to_key,\n+            key_to_index: key_to_index,\n+        })\n+    }\n+}\n \n \n /// The definition table containing node definitions\n #[derive(Clone)]\n pub struct Definitions {\n-    data: Vec<DefKey>,\n-    key_map: FxHashMap<DefKey, DefIndex>,\n+    table: DefPathTable,\n     node_to_def_index: NodeMap<DefIndex>,\n     def_index_to_node: Vec<ast::NodeId>,\n }\n@@ -214,24 +278,26 @@ impl Definitions {\n     /// Create new empty definition map.\n     pub fn new() -> Definitions {\n         Definitions {\n-            data: vec![],\n-            key_map: FxHashMap(),\n+            table: DefPathTable {\n+                index_to_key: vec![],\n+                key_to_index: FxHashMap(),\n+            },\n             node_to_def_index: NodeMap(),\n             def_index_to_node: vec![],\n         }\n     }\n \n     /// Get the number of definitions.\n     pub fn len(&self) -> usize {\n-        self.data.len()\n+        self.def_index_to_node.len()\n     }\n \n     pub fn def_key(&self, index: DefIndex) -> DefKey {\n-        self.data[index.as_usize()].key.clone()\n+        self.table.def_key(index)\n     }\n \n     pub fn def_index_for_def_key(&self, key: DefKey) -> Option<DefIndex> {\n-        self.key_map.get(&key).cloned()\n+        self.table.def_index_for_def_key(&key)\n     }\n \n     /// Returns the path from the crate root to `index`. The root\n@@ -257,8 +323,7 @@ impl Definitions {\n \n     pub fn as_local_node_id(&self, def_id: DefId) -> Option<ast::NodeId> {\n         if def_id.krate == LOCAL_CRATE {\n-            assert!(def_id.index.as_usize() < self.data.len());\n-            // Some(self.data[def_id.index.as_usize()].node_id)\n+            assert!(def_id.index.as_usize() < self.def_index_to_node.len());\n             Some(self.def_index_to_node[def_id.index.as_usize()])\n         } else {\n             None\n@@ -278,7 +343,7 @@ impl Definitions {\n                 \"adding a def'n for node-id {:?} and data {:?} but a previous def'n exists: {:?}\",\n                 node_id,\n                 data,\n-                self.data[self.node_to_def_index[&node_id].as_usize()]);\n+                self.table.def_key(self.node_to_def_index[&node_id]));\n \n         assert!(parent.is_some() ^ match data {\n             DefPathData::CrateRoot | DefPathData::InlinedRoot(_) => true,\n@@ -295,21 +360,18 @@ impl Definitions {\n             }\n         };\n \n-        while self.key_map.contains_key(&key) {\n+        while self.table.contains_key(&key) {\n             key.disambiguated_data.disambiguator += 1;\n         }\n \n         debug!(\"create_def_with_parent: after disambiguation, key = {:?}\", key);\n \n         // Create the definition.\n-        let index = DefIndex::new(self.data.len());\n-        self.data.push(DefData { key: key.clone() });\n-        self.def_index_to_node.push(node_id);\n-        debug!(\"create_def_with_parent: node_to_def_index[{:?}] = {:?}\", node_id, index);\n+        let index = self.table.insert(key);\n+        debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n         self.node_to_def_index.insert(node_id, index);\n-        debug!(\"create_def_with_parent: key_map[{:?}] = {:?}\", key, index);\n-        self.key_map.insert(key, index);\n-\n+        assert_eq!(index.as_usize(), self.def_index_to_node.len());\n+        self.def_index_to_node.push(node_id);\n \n         index\n     }"}]}