{"sha": "a6cbf2d1344418cd2807cc5380ef1247647a1e12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2Y2JmMmQxMzQ0NDE4Y2QyODA3Y2M1MzgwZWYxMjQ3NjQ3YTFlMTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T06:49:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-19T06:49:13Z"}, "message": "Auto merge of #61945 - Centril:rollup-xdqo2mn, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #61505 (Only show methods that appear in `impl` blocks in the Implementors sections of trait doc pages)\n - #61701 (move stray run-pass const tests into const/ folder)\n - #61748 (Tweak transparent enums and unions diagnostic spans)\n - #61802 (Make MaybeUninit #[repr(transparent)])\n - #61839 (ci: Add a script for generating CPU usage graphs)\n - #61842 (Remove unnecessary lift calls)\n - #61843 (Turn down the myriad-closures test)\n - #61896 (rustc_typeck: correctly compute `Substs` for `Res::SelfCtor`.)\n - #61898 (syntax: Factor out common fields from `SyntaxExtension` variants)\n - #61938 (create an issue for miri even in status test-fail)\n - #61941 (Preserve generator and yield source for error messages)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "cd2c5efba7fae486762161de293c684b1d66d962", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd2c5efba7fae486762161de293c684b1d66d962"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6cbf2d1344418cd2807cc5380ef1247647a1e12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6cbf2d1344418cd2807cc5380ef1247647a1e12", "html_url": "https://github.com/rust-lang/rust/commit/a6cbf2d1344418cd2807cc5380ef1247647a1e12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6cbf2d1344418cd2807cc5380ef1247647a1e12/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "605ea9d05c48957a291eec11eb7339788c3140ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/605ea9d05c48957a291eec11eb7339788c3140ed", "html_url": "https://github.com/rust-lang/rust/commit/605ea9d05c48957a291eec11eb7339788c3140ed"}, {"sha": "fde341a4ef6a5728dfd1acb5de0b238918a2dd44", "url": "https://api.github.com/repos/rust-lang/rust/commits/fde341a4ef6a5728dfd1acb5de0b238918a2dd44", "html_url": "https://github.com/rust-lang/rust/commit/fde341a4ef6a5728dfd1acb5de0b238918a2dd44"}], "stats": {"total": 1889, "additions": 966, "deletions": 923}, "files": [{"sha": "daf21670b33391d49cbe9f26d6c7fd7b347f6943", "filename": "src/ci/cpu-usage-over-time.py", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -30,23 +30,8 @@\n # the second column is always zero.\n #\n # Once you've downloaded a file there's various ways to plot it and visualize\n-# it. For command line usage you can use a script like so:\n-#\n-#      set timefmt '%Y-%m-%dT%H:%M:%S'\n-#      set xdata time\n-#      set ylabel \"Idle CPU %\"\n-#      set xlabel \"Time\"\n-#      set datafile sep ','\n-#      set term png\n-#      set output \"printme.png\"\n-#      set grid\n-#      builder = \"i686-apple\"\n-#      plot \"cpu-\".builder.\".csv\" using 1:2 with lines title builder\n-#\n-# Executed as `gnuplot < ./foo.plot` it will generate a graph called\n-# `printme.png` which you can then open up. If you know how to improve this\n-# script or the viewing process that would be much appreciated :) (or even if\n-# you know how to automate it!)\n+# it. For command line usage you use the `src/etc/cpu-usage-over-time-plot.sh`\n+# script in this repository.\n \n import datetime\n import sys"}, {"sha": "0e38e2865d89372c53e6489dda43924efe03727d", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -132,7 +132,7 @@ The advantages over a simple `fn(&str) -> u32` are:\n In addition to procedural macros, you can define new\n [`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n "}, {"sha": "724a21c3fc2697838c3336ca04ecc62955d1b828", "filename": "src/etc/cpu-usage-over-time-plot.sh", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcpu-usage-over-time-plot.sh?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,49 @@\n+#!/bin/bash\n+\n+# A small script to help visualizing CPU usage over time data collected on CI\n+# using `gnuplot`.\n+#\n+# This script is expected to be called with two arguments. The first is the full\n+# commit SHA of the build you're interested in, and the second is the name of\n+# the builder. For example:\n+#\n+#  ./src/etc/cpu-usage-over-time-plot.sh e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f i686-mingw-1\n+#\n+# That will generate `$builder.png` in the current directory which you can open\n+# up to see a hopefully pretty graph.\n+#\n+# Improvements to this script are greatly appreciated!\n+\n+set -ex\n+\n+bucket=rust-lang-ci-evalazure\n+commit=$1\n+builder=$2\n+\n+curl -O https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+\n+gnuplot <<-EOF\n+reset\n+set timefmt '%Y-%m-%dT%H:%M:%S'\n+set xdata time\n+set ylabel \"CPU Usage %\"\n+set xlabel \"Time\"\n+set datafile sep ','\n+set term png size 3000,1000\n+set output \"$builder.png\"\n+set grid\n+\n+f(x) = mean_y\n+fit f(x) 'cpu-$builder.csv' using 1:(100-\\$2) via mean_y\n+\n+set label 1 gprintf(\"Average = %g%%\", mean_y) center font \",18\"\n+set label 1 at graph 0.50, 0.25\n+set xtics rotate by 45 offset -2,-2.4 300\n+set ytics 10\n+set boxwidth 0.5\n+\n+plot \\\\\n+   mean_y with lines linetype 1 linecolor rgb \"#ff0000\" title \"average\", \\\\\n+   \"cpu-$builder.csv\" using 1:(100-\\$2) with points pointtype 7 pointsize 0.4 title \"$builder\", \\\\\n+   \"\" using 1:(100-\\$2) smooth bezier linewidth 3 title \"bezier\"\n+EOF"}, {"sha": "1bfb852424d63a69f047a2c4555565203eee4d12", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -100,6 +100,7 @@\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stmt_expr_attributes)]\n+#![cfg_attr(not(bootstrap), feature(transparent_unions))]\n #![feature(unboxed_closures)]\n #![feature(unsized_locals)]\n #![feature(untagged_unions)]"}, {"sha": "28e1e22ba7ff298e4800f4c5219b66cc5372442c", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -172,7 +172,7 @@ use crate::mem::ManuallyDrop;\n ///\n /// # Layout\n ///\n-/// `MaybeUninit<T>` is guaranteed to have the same size and alignment as `T`:\n+/// `MaybeUninit<T>` is guaranteed to have the same size, alignment, and ABI as `T`:\n ///\n /// ```rust\n /// use std::mem::{MaybeUninit, size_of, align_of};\n@@ -191,9 +191,23 @@ use crate::mem::ManuallyDrop;\n /// assert_eq!(size_of::<Option<bool>>(), 1);\n /// assert_eq!(size_of::<Option<MaybeUninit<bool>>>(), 2);\n /// ```\n+///\n+/// If `T` is FFI-safe, then so is `MaybeUninit<T>`.\n+///\n+/// While `MaybeUninit` is `#[repr(transparent)]` (indicating it guarantees the same size,\n+/// alignment, and ABI as `T`), this does *not* change any of the previous caveats. `Option<T>` and\n+/// `Option<MaybeUninit<T>>` may still have different sizes, and types containing a field of type\n+/// `T` may be laid out (and sized) differently than if that field were `MaybeUninit<T>`.\n+/// `MaybeUninit` is a union type, and `#[repr(transparent)]` on unions is unstable (see [the\n+/// tracking issue](https://github.com/rust-lang/rust/issues/60405)). Over time, the exact\n+/// guarantees of `#[repr(transparent)]` on unions may evolve, and `MaybeUninit` may or may not\n+/// remain `#[repr(transparent)]`. That said, `MaybeUninit<T>` will *always* guarantee that it has\n+/// the same size, alignment, and ABI as `T`; it's just that the way `MaybeUninit` implements that\n+/// guarantee may evolve.\n #[allow(missing_debug_implementations)]\n #[stable(feature = \"maybe_uninit\", since = \"1.36.0\")]\n #[derive(Copy)]\n+#[cfg_attr(not(bootstrap), repr(transparent))]\n pub union MaybeUninit<T> {\n     uninit: (),\n     value: ManuallyDrop<T>,"}, {"sha": "a7750edbb6f485f77d89bcc1a463f0c90abba14b", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -330,7 +330,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n             hir::ExprKind::Field(ref e, _) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.straightline(expr, pred, Some(&**e).into_iter())\n             }"}, {"sha": "8d7e51d1ea6c0cf79f8d14e8eba8064237870ff4", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1089,7 +1089,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n                 visitor.visit_expr(expr)\n             }\n         }\n-        ExprKind::Yield(ref subexpression) => {\n+        ExprKind::Yield(ref subexpression, _) => {\n             visitor.visit_expr(subexpression);\n         }\n         ExprKind::Lit(_) | ExprKind::Err => {}"}, {"sha": "60b099b0fed12078e0c7c9e900cb4a0b177ae2c0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 101, "deletions": 74, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -62,14 +62,14 @@ use syntax::errors;\n use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::print::pprust;\n use syntax::ptr::P;\n-use syntax::source_map::{self, respan, CompilerDesugaringKind, Spanned};\n+use syntax::source_map::{self, respan, ExpnInfo, CompilerDesugaringKind, Spanned};\n use syntax::source_map::CompilerDesugaringKind::IfTemporary;\n use syntax::std_inject;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax::parse::token::{self, Token};\n use syntax::visit::{self, Visitor};\n-use syntax_pos::{DUMMY_SP, edition, Span};\n+use syntax_pos::{DUMMY_SP, Span};\n \n const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n \n@@ -95,8 +95,7 @@ pub struct LoweringContext<'a> {\n \n     modules: BTreeMap<NodeId, hir::ModuleItems>,\n \n-    is_generator: bool,\n-    is_async_body: bool,\n+    generator_kind: Option<hir::GeneratorKind>,\n \n     /// Used to get the current `fn`'s def span to point to when using `await`\n     /// outside of an `async fn`.\n@@ -142,6 +141,9 @@ pub struct LoweringContext<'a> {\n     current_hir_id_owner: Vec<(DefIndex, u32)>,\n     item_local_id_counters: NodeMap<u32>,\n     node_id_to_hir_id: IndexVec<NodeId, hir::HirId>,\n+\n+    allow_try_trait: Option<Lrc<[Symbol]>>,\n+    allow_gen_future: Option<Lrc<[Symbol]>>,\n }\n \n pub trait Resolver {\n@@ -261,12 +263,13 @@ pub fn lower_crate(\n         current_hir_id_owner: vec![(CRATE_DEF_INDEX, 0)],\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n-        is_generator: false,\n-        is_async_body: false,\n+        generator_kind: None,\n         current_item: None,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n         in_scope_lifetimes: Vec::new(),\n+        allow_try_trait: Some([sym::try_trait][..].into()),\n+        allow_gen_future: Some([sym::gen_future][..].into()),\n     }.lower_crate(krate)\n }\n \n@@ -790,18 +793,49 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n-        if self.is_generator && self.is_async_body {\n-            span_err!(\n-                self.sess,\n-                value.span,\n-                E0727,\n-                \"`async` generators are not yet supported\",\n-            );\n-            self.sess.abort_if_errors();\n+    fn generator_movability_for_fn(\n+        &mut self,\n+        decl: &ast::FnDecl,\n+        fn_decl_span: Span,\n+        generator_kind: Option<hir::GeneratorKind>,\n+        movability: Movability,\n+    ) -> Option<hir::GeneratorMovability> {\n+        match generator_kind {\n+            Some(hir::GeneratorKind::Gen) =>  {\n+                if !decl.inputs.is_empty() {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0628,\n+                        \"generators cannot have explicit arguments\"\n+                    );\n+                    self.sess.abort_if_errors();\n+                }\n+                Some(match movability {\n+                    Movability::Movable => hir::GeneratorMovability::Movable,\n+                    Movability::Static => hir::GeneratorMovability::Static,\n+                })\n+            },\n+            Some(hir::GeneratorKind::Async) => {\n+                bug!(\"non-`async` closure body turned `async` during lowering\");\n+            },\n+            None => {\n+                if movability == Movability::Static {\n+                    span_err!(\n+                        self.sess,\n+                        fn_decl_span,\n+                        E0697,\n+                        \"closures cannot be static\"\n+                    );\n+                }\n+                None\n+            },\n         }\n+    }\n+\n+    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n-            is_generator: self.is_generator || self.is_async_body,\n+            generator_kind: self.generator_kind,\n             arguments,\n             value,\n         };\n@@ -848,14 +882,10 @@ impl<'a> LoweringContext<'a> {\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(source_map::ExpnInfo {\n-            call_site: span,\n+        mark.set_expn_info(ExpnInfo {\n             def_site: Some(span),\n-            format: source_map::CompilerDesugaring(reason),\n             allow_internal_unstable,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: edition::Edition::from_session(),\n+            ..ExpnInfo::default(source_map::CompilerDesugaring(reason), span, self.sess.edition())\n         });\n         span.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     }\n@@ -1142,7 +1172,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         let decl = self.lower_fn_decl(&ast_decl, None, /* impl trait allowed */ false, None);\n         let body_id = self.lower_fn_body(&ast_decl, |this| {\n-            this.is_async_body = true;\n+            this.generator_kind = Some(hir::GeneratorKind::Async);\n             body(this)\n         });\n         let generator = hir::Expr {\n@@ -1156,7 +1186,7 @@ impl<'a> LoweringContext<'a> {\n         let unstable_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Async,\n             span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n         let gen_future = self.expr_std_path(\n             unstable_span, &[sym::future, sym::from_generator], None, ThinVec::new());\n@@ -1167,12 +1197,10 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n     ) -> hir::BodyId {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n-        let prev_is_async_body = mem::replace(&mut self.is_async_body, false);\n+        let prev_gen_kind = self.generator_kind.take();\n         let (arguments, result) = f(self);\n         let body_id = self.record_body(arguments, result);\n-        self.is_generator = prev_is_generator;\n-        self.is_async_body = prev_is_async_body;\n+        self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n@@ -4382,7 +4410,7 @@ impl<'a> LoweringContext<'a> {\n                     let unstable_span = this.mark_span_with_reason(\n                         CompilerDesugaringKind::TryBlock,\n                         body.span,\n-                        Some(vec![sym::try_trait].into()),\n+                        this.allow_try_trait.clone(),\n                     );\n                     let mut block = this.lower_block(body, true).into_inner();\n                     let tail = block.expr.take().map_or_else(\n@@ -4475,37 +4503,18 @@ impl<'a> LoweringContext<'a> {\n \n                     self.with_new_scopes(|this| {\n                         this.current_item = Some(fn_decl_span);\n-                        let mut is_generator = false;\n+                        let mut generator_kind = None;\n                         let body_id = this.lower_fn_body(decl, |this| {\n                             let e = this.lower_expr(body);\n-                            is_generator = this.is_generator;\n+                            generator_kind = this.generator_kind;\n                             e\n                         });\n-                        let generator_option = if is_generator {\n-                            if !decl.inputs.is_empty() {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0628,\n-                                    \"generators cannot have explicit arguments\"\n-                                );\n-                                this.sess.abort_if_errors();\n-                            }\n-                            Some(match movability {\n-                                Movability::Movable => hir::GeneratorMovability::Movable,\n-                                Movability::Static => hir::GeneratorMovability::Static,\n-                            })\n-                        } else {\n-                            if movability == Movability::Static {\n-                                span_err!(\n-                                    this.sess,\n-                                    fn_decl_span,\n-                                    E0697,\n-                                    \"closures cannot be static\"\n-                                );\n-                            }\n-                            None\n-                        };\n+                        let generator_option = this.generator_movability_for_fn(\n+                            &decl,\n+                            fn_decl_span,\n+                            generator_kind,\n+                            movability,\n+                        );\n                         hir::ExprKind::Closure(\n                             this.lower_capture_clause(capture_clause),\n                             fn_decl,\n@@ -4677,12 +4686,26 @@ impl<'a> LoweringContext<'a> {\n             }\n \n             ExprKind::Yield(ref opt_expr) => {\n-                self.is_generator = true;\n+                match self.generator_kind {\n+                    Some(hir::GeneratorKind::Gen) => {},\n+                    Some(hir::GeneratorKind::Async) => {\n+                        span_err!(\n+                            self.sess,\n+                            e.span,\n+                            E0727,\n+                            \"`async` generators are not yet supported\",\n+                        );\n+                        self.sess.abort_if_errors();\n+                    },\n+                    None => {\n+                        self.generator_kind = Some(hir::GeneratorKind::Gen);\n+                    }\n+                }\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n                     .unwrap_or_else(|| self.expr_unit(e.span));\n-                hir::ExprKind::Yield(P(expr))\n+                hir::ExprKind::Yield(P(expr), hir::YieldSource::Yield)\n             }\n \n             ExprKind::Err => hir::ExprKind::Err,\n@@ -4968,13 +4991,13 @@ impl<'a> LoweringContext<'a> {\n                 let unstable_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     e.span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n                 let try_span = self.sess.source_map().end_point(e.span);\n                 let try_span = self.mark_span_with_reason(\n                     CompilerDesugaringKind::QuestionMark,\n                     try_span,\n-                    Some(vec![sym::try_trait].into()),\n+                    self.allow_try_trait.clone(),\n                 );\n \n                 // `Try::into_result(<expr>)`\n@@ -5754,19 +5777,23 @@ impl<'a> LoweringContext<'a> {\n         //         yield ();\n         //     }\n         // }\n-        if !self.is_async_body {\n-            let mut err = struct_span_err!(\n-                self.sess,\n-                await_span,\n-                E0728,\n-                \"`await` is only allowed inside `async` functions and blocks\"\n-            );\n-            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n-            if let Some(item_sp) = self.current_item {\n-                err.span_label(item_sp, \"this is not `async`\");\n+        match self.generator_kind {\n+            Some(hir::GeneratorKind::Async) => {},\n+            Some(hir::GeneratorKind::Gen) |\n+            None => {\n+                let mut err = struct_span_err!(\n+                    self.sess,\n+                    await_span,\n+                    E0728,\n+                    \"`await` is only allowed inside `async` functions and blocks\"\n+                );\n+                err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+                if let Some(item_sp) = self.current_item {\n+                    err.span_label(item_sp, \"this is not `async`\");\n+                }\n+                err.emit();\n+                return hir::ExprKind::Err;\n             }\n-            err.emit();\n-            return hir::ExprKind::Err;\n         }\n         let span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n@@ -5776,7 +5803,7 @@ impl<'a> LoweringContext<'a> {\n         let gen_future_span = self.mark_span_with_reason(\n             CompilerDesugaringKind::Await,\n             await_span,\n-            Some(vec![sym::gen_future].into()),\n+            self.allow_gen_future.clone(),\n         );\n \n         // let mut pinned = <expr>;\n@@ -5864,7 +5891,7 @@ impl<'a> LoweringContext<'a> {\n             let unit = self.expr_unit(span);\n             let yield_expr = P(self.expr(\n                 span,\n-                hir::ExprKind::Yield(P(unit)),\n+                hir::ExprKind::Yield(P(unit), hir::YieldSource::Await),\n                 ThinVec::new(),\n             ));\n             self.stmt(span, hir::StmtKind::Expr(yield_expr))"}, {"sha": "69bd4d3f1f6a30dfa181e5a5fb396c9b07647302", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1306,15 +1306,15 @@ pub struct BodyId {\n ///\n /// - an `arguments` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n-/// - `is_generator` would be false\n+/// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n     pub arguments: HirVec<Arg>,\n     pub value: Expr,\n-    pub is_generator: bool,\n+    pub generator_kind: Option<GeneratorKind>,\n }\n \n impl Body {\n@@ -1325,6 +1325,26 @@ impl Body {\n     }\n }\n \n+/// The type of source expression that caused this generator to be created.\n+// Not `IsAsync` because we want to eventually add support for `AsyncGen`\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n+         RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub enum GeneratorKind {\n+    /// An `async` block or function.\n+    Async,\n+    /// A generator literal created via a `yield` inside a closure.\n+    Gen,\n+}\n+\n+impl fmt::Display for GeneratorKind {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            GeneratorKind::Async => \"`async` object\",\n+            GeneratorKind::Gen => \"generator\",\n+        })\n+    }\n+}\n+\n #[derive(Copy, Clone, Debug)]\n pub enum BodyOwnerKind {\n     /// Functions and methods.\n@@ -1531,8 +1551,8 @@ pub enum ExprKind {\n     ///\n     /// The final span is the span of the argument block `|...|`.\n     ///\n-    /// This may also be a generator literal, indicated by the final boolean,\n-    /// in that case there is an `GeneratorClause`.\n+    /// This may also be a generator literal or an `async block` as indicated by the\n+    /// `Option<GeneratorMovability>`.\n     Closure(CaptureClause, P<FnDecl>, BodyId, Span, Option<GeneratorMovability>),\n     /// A block (e.g., `'label: { ... }`).\n     Block(P<Block>, Option<Label>),\n@@ -1576,7 +1596,7 @@ pub enum ExprKind {\n     Repeat(P<Expr>, AnonConst),\n \n     /// A suspension point for generators (i.e., `yield <expr>`).\n-    Yield(P<Expr>),\n+    Yield(P<Expr>, YieldSource),\n \n     /// A placeholder for an expression that wasn't syntactically well formed in some way.\n     Err,\n@@ -1668,12 +1688,12 @@ pub enum LoopIdError {\n \n impl fmt::Display for LoopIdError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n+        f.write_str(match self {\n             LoopIdError::OutsideLoopScope => \"not inside loop scope\",\n             LoopIdError::UnlabeledCfInWhileCondition =>\n                 \"unlabeled control flow (break or continue) in while condition\",\n             LoopIdError::UnresolvedLabel => \"label not found\",\n-        }, f)\n+        })\n     }\n }\n \n@@ -1687,13 +1707,34 @@ pub struct Destination {\n     pub target_id: Result<HirId, LoopIdError>,\n }\n \n+/// Whether a generator contains self-references, causing it to be `!Unpin`.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, HashStable,\n          RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum GeneratorMovability {\n+    /// May contain self-references, `!Unpin`.\n     Static,\n+    /// Must not contain self-references, `Unpin`.\n     Movable,\n }\n \n+/// The yield kind that caused an `ExprKind::Yield`.\n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub enum YieldSource {\n+    /// An `<expr>.await`.\n+    Await,\n+    /// A plain `yield`.\n+    Yield,\n+}\n+\n+impl fmt::Display for YieldSource {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match self {\n+            YieldSource::Await => \"`await`\",\n+            YieldSource::Yield => \"`yield`\",\n+        })\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, HashStable)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -2058,11 +2099,10 @@ impl Defaultness {\n \n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(match *self {\n-                              Unsafety::Normal => \"normal\",\n-                              Unsafety::Unsafe => \"unsafe\",\n-                          },\n-                          f)\n+        f.write_str(match self {\n+            Unsafety::Normal => \"normal\",\n+            Unsafety::Unsafe => \"unsafe\",\n+        })\n     }\n }\n \n@@ -2076,10 +2116,10 @@ pub enum ImplPolarity {\n \n impl fmt::Debug for ImplPolarity {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ImplPolarity::Positive => \"positive\".fmt(f),\n-            ImplPolarity::Negative => \"negative\".fmt(f),\n-        }\n+        f.write_str(match self {\n+            ImplPolarity::Positive => \"positive\",\n+            ImplPolarity::Negative => \"negative\",\n+        })\n     }\n }\n "}, {"sha": "69ee84dfa4393c5432b896ff55206321d5e3670d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1501,7 +1501,7 @@ impl<'a> State<'a> {\n \n                 self.pclose()?;\n             }\n-            hir::ExprKind::Yield(ref expr) => {\n+            hir::ExprKind::Yield(ref expr, _) => {\n                 self.word_space(\"yield\")?;\n                 self.print_expr_maybe_paren(&expr, parser::PREC_JUMP)?;\n             }"}, {"sha": "30d76f240d1faa431cb24941d076827f4b258488", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -335,15 +335,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            ref arguments,\n-            ref value,\n-            is_generator,\n-        } = *self;\n+            arguments,\n+            value,\n+            generator_kind,\n+        } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n             arguments.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n-            is_generator.hash_stable(hcx, hasher);\n+            generator_kind.hash_stable(hcx, hasher);\n         });\n     }\n }"}, {"sha": "9430661f75ab79b3d19878c147a161a33c55c556", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -391,10 +391,17 @@ impl_stable_hash_for!(enum ::syntax::ast::MetaItemKind {\n     NameValue(lit)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::Transparency {\n+    Transparent,\n+    SemiTransparent,\n+    Opaque,\n+});\n+\n impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnInfo {\n     call_site,\n-    def_site,\n     format,\n+    def_site,\n+    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,"}, {"sha": "3d57a89493e1ea7aaf0c09d7e186c6e82ac647fb", "filename": "src/librustc/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 8, "deletions": 22, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -14,7 +14,7 @@ use crate::mir::interpret::ConstValue;\n use std::sync::atomic::Ordering;\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n use crate::ty::subst::Kind;\n-use crate::ty::{self, BoundVar, InferConst, Lift, List, Ty, TyCtxt, TypeFlags};\n+use crate::ty::{self, BoundVar, InferConst, List, Ty, TyCtxt, TypeFlags};\n use crate::ty::flags::FlagComputation;\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -43,7 +43,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -87,7 +87,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html#canonicalizing-the-query-result\n     pub fn canonicalize_response<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n     pub fn canonicalize_user_type_annotation<V>(&self, value: &V) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let mut query_state = OriginalQueryValues::default();\n         Canonicalizer::canonicalize(\n@@ -132,7 +132,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         self.tcx\n             .sess\n@@ -506,7 +506,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n-        V: TypeFoldable<'tcx> + Lift<'tcx>,\n+        V: TypeFoldable<'tcx>,\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::KEEP_IN_LOCAL_TCX |\n@@ -520,20 +520,12 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n             TypeFlags::HAS_CT_PLACEHOLDER\n         };\n \n-        let gcx = tcx.global_tcx();\n-\n         // Fast path: nothing that needs to be canonicalized.\n         if !value.has_type_flags(needs_canonical_flags) {\n-            let out_value = gcx.lift(value).unwrap_or_else(|| {\n-                bug!(\n-                    \"failed to lift `{:?}` (nothing to canonicalize)\",\n-                    value\n-                )\n-            });\n             let canon_value = Canonical {\n                 max_universe: ty::UniverseIndex::ROOT,\n                 variables: List::empty(),\n-                value: out_value,\n+                value: value.clone(),\n             };\n             return canon_value;\n         }\n@@ -553,13 +545,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n         // anymore, so it should live in the global arena.\n-        let out_value = gcx.lift(&out_value).unwrap_or_else(|| {\n-            bug!(\n-                \"failed to lift `{:?}`, canonicalized from `{:?}`\",\n-                out_value,\n-                value\n-            )\n-        });\n+        debug_assert!(!out_value.has_type_flags(TypeFlags::KEEP_IN_LOCAL_TCX));\n \n         let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n "}, {"sha": "b2c7bd73b6812833d0aa3d95521894ffe6fb6533", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -194,10 +194,10 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, <V as Lift<'tcx>>::Lifted>;\n+pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n \n pub type CanonicalizedQueryResponse<'tcx, T> =\n-    &'tcx Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>;\n+    &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n \n /// Indicates whether or not we were able to prove the query to be\n /// true."}, {"sha": "3e92fed005cd1f141c4d66c341ac71648395733c", "filename": "src/librustc/infer/canonical/query_response.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -26,7 +26,7 @@ use crate::traits::TraitEngine;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{Kind, UnpackedKind};\n-use crate::ty::{self, BoundVar, InferConst, Lift, Ty, TyCtxt};\n+use crate::ty::{self, BoundVar, InferConst, Ty, TyCtxt};\n use crate::util::captures::Captures;\n \n impl<'tcx> InferCtxtBuilder<'tcx> {\n@@ -53,8 +53,8 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, R>>\n     where\n         K: TypeFoldable<'tcx>,\n-        R: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n-        Canonical<'tcx, <QueryResponse<'tcx, R> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n+        R: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, R>>: ArenaAllocatable,\n     {\n         self.enter_with_canonical(\n             DUMMY_SP,\n@@ -99,8 +99,8 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Fallible<CanonicalizedQueryResponse<'tcx, T>>\n     where\n-        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n-        Canonical<'tcx, <QueryResponse<'tcx, T> as Lift<'tcx>>::Lifted>: ArenaAllocatable,\n+        T: Debug + TypeFoldable<'tcx>,\n+        Canonical<'tcx, QueryResponse<'tcx, T>>: ArenaAllocatable,\n     {\n         let query_response = self.make_query_response(inference_vars, answer, fulfill_cx)?;\n         let canonical_result = self.canonicalize_response(&query_response);\n@@ -126,9 +126,9 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         &self,\n         inference_vars: CanonicalVarValues<'tcx>,\n         answer: T,\n-    ) -> Canonical<'tcx, QueryResponse<'tcx, <T as Lift<'tcx>>::Lifted>>\n+    ) -> Canonical<'tcx, QueryResponse<'tcx, T>>\n     where\n-        T: Debug + Lift<'tcx> + TypeFoldable<'tcx>,\n+        T: Debug + TypeFoldable<'tcx>,\n     {\n         self.canonicalize_response(&QueryResponse {\n             var_values: inference_vars,\n@@ -147,7 +147,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         fulfill_cx: &mut dyn TraitEngine<'tcx>,\n     ) -> Result<QueryResponse<'tcx, T>, NoSolution>\n     where\n-        T: Debug + TypeFoldable<'tcx> + Lift<'tcx>,\n+        T: Debug + TypeFoldable<'tcx>,\n     {\n         let tcx = self.tcx;\n "}, {"sha": "fe151bdec6a841ed927666103dfcf08c678b6e85", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -227,16 +227,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn need_type_info_err_in_generator(\n         &self,\n+        kind: hir::GeneratorKind,\n         span: Span,\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                       span,\n-                       E0698,\n-                       \"type inside generator must be known in this context\");\n+        let mut err = struct_span_err!(\n+            self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n+        );\n         err.span_label(span, InferCtxt::missing_type_msg(&name));\n         err\n     }"}, {"sha": "60554a30060bbc2ee39febfea04f628046ac642e", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -469,11 +469,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             definition_ty\n         );\n \n-        // We can unwrap here because our reverse mapper always\n-        // produces things with 'tcx lifetime, though the type folder\n-        // obscures that.\n-        let definition_ty = gcx.lift(&definition_ty).unwrap();\n-\n         definition_ty\n     }\n }"}, {"sha": "086ddfd7e33bfc996b41735fc479ac9e363983c0", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -546,7 +546,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                 self.consume_expr(&base);\n             }\n \n-            hir::ExprKind::Yield(ref value) => {\n+            hir::ExprKind::Yield(ref value, _) => {\n                 self.consume_expr(&value);\n             }\n         }"}, {"sha": "bf054d68b704a5ff297af58799966a8998543dd0", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1218,7 +1218,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Type(ref e, _) |\n             hir::ExprKind::DropTemps(ref e) |\n             hir::ExprKind::Unary(_, ref e) |\n-            hir::ExprKind::Yield(ref e) |\n+            hir::ExprKind::Yield(ref e, _) |\n             hir::ExprKind::Repeat(ref e, _) => {\n                 self.propagate_through_expr(&e, succ)\n             }"}, {"sha": "c0f56a33eec8f031308ca6007ae2dc4af275620c", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -817,10 +817,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n                              .unwrap_or(ty::ClosureKind::LATTICE_BOTTOM),\n \n                     None =>\n-                        self.tcx.global_tcx()\n-                                .lift(&closure_substs)\n-                                .expect(\"no inference cx, but inference variables in closure ty\")\n-                                .closure_kind(closure_def_id, self.tcx.global_tcx()),\n+                        closure_substs.closure_kind(closure_def_id, self.tcx.global_tcx()),\n                 }\n             }\n             _ => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", ty),"}, {"sha": "93cb6ab96f8837a062df14e49eec7bb1fe977686", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -331,14 +331,23 @@ pub struct ScopeTree {\n     /// The reason is that semantically, until the `box` expression returns,\n     /// the values are still owned by their containing expressions. So\n     /// we'll see that `&x`.\n-    yield_in_scope: FxHashMap<Scope, (Span, usize)>,\n+    yield_in_scope: FxHashMap<Scope, YieldData>,\n \n     /// The number of visit_expr and visit_pat calls done in the body.\n     /// Used to sanity check visit_expr/visit_pat call count when\n     /// calculating generator interiors.\n     body_expr_count: FxHashMap<hir::BodyId, usize>,\n }\n \n+#[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n+pub struct YieldData {\n+    /// `Span` of the yield.\n+    pub span: Span,\n+    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    pub expr_and_pat_count: usize,\n+    pub source: hir::YieldSource,\n+}\n+\n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n     /// the root of the current region tree. This is typically the id\n@@ -695,7 +704,7 @@ impl<'tcx> ScopeTree {\n     /// returns `Some((span, expr_count))` with the span of a yield we found and\n     /// the number of expressions and patterns appearing before the `yield` in the body + 1.\n     /// If there a are multiple yields in a scope, the one with the highest number is returned.\n-    pub fn yield_in_scope(&self, scope: Scope) -> Option<(Span, usize)> {\n+    pub fn yield_in_scope(&self, scope: Scope) -> Option<YieldData> {\n         self.yield_in_scope.get(&scope).cloned()\n     }\n \n@@ -706,14 +715,14 @@ impl<'tcx> ScopeTree {\n                                    scope: Scope,\n                                    expr_hir_id: hir::HirId,\n                                    body: &'tcx hir::Body) -> Option<Span> {\n-        self.yield_in_scope(scope).and_then(|(span, count)| {\n+        self.yield_in_scope(scope).and_then(|YieldData { span, expr_and_pat_count, .. }| {\n             let mut visitor = ExprLocatorVisitor {\n                 hir_id: expr_hir_id,\n                 result: None,\n                 expr_and_pat_count: 0,\n             };\n             visitor.visit_body(body);\n-            if count >= visitor.result.unwrap() {\n+            if expr_and_pat_count >= visitor.result.unwrap() {\n                 Some(span)\n             } else {\n                 None\n@@ -953,12 +962,16 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n \n     debug!(\"resolve_expr post-increment {}, expr = {:?}\", visitor.expr_and_pat_count, expr);\n \n-    if let hir::ExprKind::Yield(..) = expr.node {\n+    if let hir::ExprKind::Yield(_, source) = &expr.node {\n         // Mark this expr's scope and all parent scopes as containing `yield`.\n         let mut scope = Scope { id: expr.hir_id.local_id, data: ScopeData::Node };\n         loop {\n-            visitor.scope_tree.yield_in_scope.insert(scope,\n-                (expr.span, visitor.expr_and_pat_count));\n+            let data = YieldData {\n+                span: expr.span,\n+                expr_and_pat_count: visitor.expr_and_pat_count,\n+                source: *source,\n+            };\n+            visitor.scope_tree.yield_in_scope.insert(scope, data);\n \n             // Keep traversing up while we can.\n             match visitor.scope_tree.parent_map.get(&scope) {\n@@ -1302,7 +1315,7 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n             resolve_local(self, None, Some(&body.value));\n         }\n \n-        if body.is_generator {\n+        if body.generator_kind.is_some() {\n             self.scope_tree.body_expr_count.insert(body_id, self.expr_and_pat_count);\n         }\n "}, {"sha": "97fb430a3e0519af9d9e1fa975e9b3b4fdc08140", "filename": "src/librustc/traits/codegen/mod.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcodegen%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -141,9 +141,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         fulfill_cx: &mut FulfillmentContext<'tcx>,\n         result: &T,\n-    ) -> T::Lifted\n+    ) -> T\n     where\n-        T: TypeFoldable<'tcx> + ty::Lift<'tcx>,\n+        T: TypeFoldable<'tcx>,\n     {\n         debug!(\"drain_fulfillment_cx_or_panic()\");\n \n@@ -155,10 +155,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         let result = self.resolve_vars_if_possible(result);\n-        let result = self.tcx.erase_regions(&result);\n-\n-        self.tcx.lift_to_global(&result).unwrap_or_else(||\n-            bug!(\"Uninferred types/regions/consts in `{:?}`\", result)\n-        )\n+        self.tcx.erase_regions(&result)\n     }\n }"}, {"sha": "0f4b7aff82bce82cb1646be85f7145f00f7381e9", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -409,7 +409,6 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n                             promoted: None\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }"}, {"sha": "5dd1b9e3d53f3a6db5d9e7b2ad831c6527ae7af4", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -203,7 +203,6 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n                             promoted: None,\n                         };\n                         if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let substs = tcx.lift_to_global(&substs).unwrap();\n                             let evaluated = evaluated.subst(tcx, substs);\n                             return evaluated;\n                         }"}, {"sha": "4a07a3120f3e83b61409caf691e7cdf72f29a64f", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -8,7 +8,7 @@ use std::rc::Rc;\n use crate::traits::query::Fallible;\n use crate::traits::ObligationCause;\n use crate::ty::fold::TypeFoldable;\n-use crate::ty::{Lift, ParamEnvAnd, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n pub mod ascribe_user_type;\n pub mod custom;\n@@ -44,8 +44,8 @@ pub trait TypeOp<'tcx>: Sized + fmt::Debug {\n /// which produces the resulting query region constraints.\n ///\n /// [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n-pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + Lift<'tcx> {\n-    type QueryResponse: TypeFoldable<'tcx> + Lift<'tcx>;\n+pub trait QueryTypeOp<'tcx>: fmt::Debug + Sized + TypeFoldable<'tcx> + 'tcx {\n+    type QueryResponse: TypeFoldable<'tcx>;\n \n     /// Give query the option for a simple fast path that never\n     /// actually hits the tcx cache lookup etc. Return `Some(r)` with"}, {"sha": "3fe85d8d83eb9c39eb67d5e7ec9c4eb2e74611a9", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -20,7 +20,7 @@ where\n \n impl<'tcx, T> super::QueryTypeOp<'tcx> for Normalize<T>\n where\n-    T: Normalizable<'tcx>,\n+    T: Normalizable<'tcx> + 'tcx,\n {\n     type QueryResponse = T;\n "}, {"sha": "43bb4edd9b27d8e75d1501e9915cc93289a0a838", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -132,12 +132,7 @@ pub fn find_associated_item<'tcx>(\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, param_env, impl_data.impl_def_id,\n                                               substs, node_item.node);\n-                let substs = infcx.tcx.erase_regions(&substs);\n-                tcx.lift(&substs).unwrap_or_else(||\n-                    bug!(\"find_method: translate_substs \\\n-                          returned {:?} which contains inference types/regions\",\n-                         substs)\n-                )\n+                infcx.tcx.erase_regions(&substs)\n             });\n             (node_item.item.def_id, substs)\n         }"}, {"sha": "b8bdde4a787380a4e110e8691c578107413fe821", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -192,9 +192,12 @@ impl<'tcx> ty::TyS<'tcx> {\n \n             ty::Adt(def, _) => format!(\"{} `{}`\", def.descr(), tcx.def_path_str(def.did)).into(),\n             ty::Foreign(def_id) => format!(\"extern type `{}`\", tcx.def_path_str(def_id)).into(),\n-            ty::Array(_, n) => match n.assert_usize(tcx) {\n-                Some(n) => format!(\"array of {} elements\", n).into(),\n-                None => \"array\".into(),\n+            ty::Array(_, n) => {\n+                let n = tcx.lift_to_global(&n).unwrap();\n+                match n.assert_usize(tcx) {\n+                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    None => \"array\".into(),\n+                }\n             }\n             ty::Slice(_) => \"slice\".into(),\n             ty::RawPtr(_) => \"*-ptr\".into(),"}, {"sha": "8bfbd8b854b03589506ff74ba39a709086a3bd58", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -2262,7 +2262,6 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn from_bits(tcx: TyCtxt<'tcx>, bits: u128, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> &'tcx Self {\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).unwrap_or_else(|e| {\n             panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n         }).size;\n@@ -2289,7 +2288,6 @@ impl<'tcx> Const<'tcx> {\n         if self.ty != ty.value {\n             return None;\n         }\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n         self.val.try_to_bits(size)\n     }\n@@ -2300,15 +2298,14 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n+    pub fn assert_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> Option<u128> {\n         assert_eq!(self.ty, ty.value);\n-        let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n         self.val.try_to_bits(size)\n     }\n \n     #[inline]\n-    pub fn assert_bool(&self, tcx: TyCtxt<'_>) -> Option<bool> {\n+    pub fn assert_bool(&self, tcx: TyCtxt<'tcx>) -> Option<bool> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n@@ -2317,18 +2314,18 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_usize(&self, tcx: TyCtxt<'_>) -> Option<u64> {\n+    pub fn assert_usize(&self, tcx: TyCtxt<'tcx>) -> Option<u64> {\n         self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, tcx: TyCtxt<'_>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n+    pub fn unwrap_bits(&self, tcx: TyCtxt<'tcx>, ty: ParamEnvAnd<'tcx, Ty<'tcx>>) -> u128 {\n         self.assert_bits(tcx, ty).unwrap_or_else(||\n             bug!(\"expected bits of {}, got {:#?}\", ty.value, self))\n     }\n \n     #[inline]\n-    pub fn unwrap_usize(&self, tcx: TyCtxt<'_>) -> u64 {\n+    pub fn unwrap_usize(&self, tcx: TyCtxt<'tcx>) -> u64 {\n         self.assert_usize(tcx).unwrap_or_else(||\n             bug!(\"expected constant usize, got {:#?}\", self))\n     }"}, {"sha": "d402b0ddf6e85f3be4a3fb18c3ca159ab0a3724b", "filename": "src/librustc_allocator/expand.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_allocator%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_allocator%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_allocator%2Fexpand.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -19,7 +19,7 @@ use syntax::{\n     mut_visit::{self, MutVisitor},\n     parse::ParseSess,\n     ptr::P,\n-    symbol::{kw, sym, Symbol}\n+    symbol::{kw, sym}\n };\n use syntax_pos::Span;\n \n@@ -58,11 +58,10 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n     fn flat_map_item(&mut self, item: P<Item>) -> SmallVec<[P<Item>; 1]> {\n         debug!(\"in submodule {}\", self.in_submod);\n \n-        let name = if attr::contains_name(&item.attrs, sym::global_allocator) {\n-            \"global_allocator\"\n-        } else {\n+        if !attr::contains_name(&item.attrs, sym::global_allocator) {\n             return mut_visit::noop_flat_map_item(item, self);\n-        };\n+        }\n+\n         match item.node {\n             ItemKind::Static(..) => {}\n             _ => {\n@@ -87,15 +86,9 @@ impl MutVisitor for ExpandAllocatorDirectives<'_> {\n \n         // Create a fresh Mark for the new macro expansion we are about to do\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: item.span, // use the call site of the static\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(name)),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: self.sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::global_allocator), item.span, self.sess.edition, &[sym::rustc_attrs]\n+        ));\n \n         // Tie the span to the macro expansion info we just created\n         let span = item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark));"}, {"sha": "df0957254cc093fc2340954b3916ee98ff529e2c", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -26,7 +26,7 @@ use std::{cmp, fs};\n \n use syntax::ast;\n use syntax::attr;\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::symbol::{Symbol, sym};\n use syntax::visit;\n use syntax::{span_err, span_fatal};\n@@ -611,33 +611,31 @@ impl<'a> CrateLoader<'a> {\n         };\n \n         let extensions = decls.iter().map(|&decl| {\n-            match decl {\n+            let (name, kind, helper_attrs) = match decl {\n                 ProcMacro::CustomDerive { trait_name, attributes, client } => {\n-                    let attrs = attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n-                    (trait_name, SyntaxExtension::Derive(\n-                        Box::new(ProcMacroDerive {\n-                            client,\n-                            attrs: attrs.clone(),\n-                        }),\n-                        attrs,\n-                        root.edition,\n-                    ))\n+                    let helper_attrs =\n+                        attributes.iter().cloned().map(Symbol::intern).collect::<Vec<_>>();\n+                    (\n+                        trait_name,\n+                        SyntaxExtensionKind::Derive(Box::new(ProcMacroDerive {\n+                            client, attrs: helper_attrs.clone()\n+                        })),\n+                        helper_attrs,\n+                    )\n                 }\n-                ProcMacro::Attr { name, client } => {\n-                    (name, SyntaxExtension::Attr(\n-                        Box::new(AttrProcMacro { client }),\n-                        root.edition,\n-                    ))\n-                }\n-                ProcMacro::Bang { name, client } => {\n-                    (name, SyntaxExtension::Bang {\n-                        expander: Box::new(BangProcMacro { client }),\n-                        allow_internal_unstable: None,\n-                        edition: root.edition,\n-                    })\n-                }\n-            }\n-        }).map(|(name, ext)| (Symbol::intern(name), Lrc::new(ext))).collect();\n+                ProcMacro::Attr { name, client } => (\n+                    name, SyntaxExtensionKind::Attr(Box::new(AttrProcMacro { client })), Vec::new()\n+                ),\n+                ProcMacro::Bang { name, client } => (\n+                    name, SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client })), Vec::new()\n+                )\n+            };\n+\n+            (Symbol::intern(name), Lrc::new(SyntaxExtension {\n+                helper_attrs,\n+                ..SyntaxExtension::default(kind, root.edition)\n+            }))\n+        }).collect();\n \n         // Intentionally leak the dynamic library. We can't ever unload it\n         // since the library can make things that will live arbitrarily long."}, {"sha": "04a9c4e9a1a11c1083f8d50778965b80c65f6521", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -30,9 +30,11 @@ use syntax::ast;\n use syntax::attr;\n use syntax::source_map;\n use syntax::edition::Edition;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::parse::source_file_to_stream;\n use syntax::parse::parser::emit_unclosed_delims;\n use syntax::symbol::{Symbol, sym};\n+use syntax_ext::proc_macro_impl::BangProcMacro;\n use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::bit_set::BitSet;\n \n@@ -427,14 +429,11 @@ impl cstore::CStore {\n         if let Some(ref proc_macros) = data.proc_macros {\n             return LoadedMacro::ProcMacro(proc_macros[id.index.to_proc_macro_index()].1.clone());\n         } else if data.name == sym::proc_macro && data.item_name(id.index) == sym::quote {\n-            use syntax::ext::base::SyntaxExtension;\n-            use syntax_ext::proc_macro_impl::BangProcMacro;\n-\n             let client = proc_macro::bridge::client::Client::expand1(proc_macro::quote);\n-            let ext = SyntaxExtension::Bang {\n-                expander: Box::new(BangProcMacro { client }),\n-                allow_internal_unstable: Some(vec![sym::proc_macro_def_site].into()),\n-                edition: data.root.edition,\n+            let kind = SyntaxExtensionKind::Bang(Box::new(BangProcMacro { client }));\n+            let ext = SyntaxExtension {\n+                allow_internal_unstable: Some([sym::proc_macro_def_site][..].into()),\n+                ..SyntaxExtension::default(kind, data.root.edition)\n             };\n             return LoadedMacro::ProcMacro(Lrc::new(ext));\n         }"}, {"sha": "6a5f62aec1537f35fd5a7d43c0630ae28b78d241", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -509,8 +509,9 @@ impl<'a, 'tcx> CrateMetadata {\n         if !self.is_proc_macro(index) {\n             self.entry(index).kind.def_kind()\n         } else {\n-            let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(DefKind::Macro(kind))\n+            Some(DefKind::Macro(\n+                self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.macro_kind()\n+            ))\n         }\n     }\n \n@@ -737,7 +738,7 @@ impl<'a, 'tcx> CrateMetadata {\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n                     let res = Res::Def(\n-                        DefKind::Macro(ext.kind()),\n+                        DefKind::Macro(ext.macro_kind()),\n                         self.local_def_id(DefIndex::from_proc_macro_index(id)),\n                     );\n                     let ident = Ident::with_empty_ctxt(name);"}, {"sha": "ed56d351e90d0f047b9f5614b90591bed09dc6f4", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -670,7 +670,7 @@ impl<'cx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx\n                 // \"Lift\" into the gcx -- once regions are erased, this type should be in the\n                 // global arenas; this \"lift\" operation basically just asserts that is true, but\n                 // that is useful later.\n-                let drop_place_ty = gcx.lift(&drop_place_ty).unwrap();\n+                gcx.lift_to_global(&drop_place_ty).unwrap();\n \n                 debug!(\"visit_terminator_drop \\\n                         loc: {:?} term: {:?} drop_place: {:?} drop_place_ty: {:?} span: {:?}\","}, {"sha": "41ed564d0f0e1a91ca73b798ae4464b8ca2b5293", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -863,8 +863,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         });\n         debug!(\"try_promote_type_test_subject: folded ty = {:?}\", ty);\n \n-        // `lift` will only fail if we failed to promote some region.\n-        let ty = gcx.lift(&ty)?;\n+        // `lift_to_global` will only fail if we failed to promote some region.\n+        gcx.lift_to_global(&ty)?;\n \n         Some(ClosureOutlivesSubject::Ty(ty))\n     }"}, {"sha": "e1f5964ff9340e6b2701fe5564c9f1a298aa053c", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let gcx = tcx.global_tcx();\n-        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        let erased_ty = tcx.erase_regions(&ty);\n         if !erased_ty.is_sized(gcx.at(span), self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n@@ -2650,7 +2650,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n \n     fn normalize<T>(&mut self, value: T, location: impl NormalizeLocation) -> T\n     where\n-        T: type_op::normalize::Normalizable<'tcx> + Copy,\n+        T: type_op::normalize::Normalizable<'tcx> + Copy + 'tcx,\n     {\n         debug!(\"normalize(value={:?}, location={:?})\", value, location);\n         let param_env = self.param_env;"}, {"sha": "243c13c2982d0fb0aadda0731742fdf9b49cc1f5", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -569,7 +569,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);\n@@ -580,7 +580,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         assert!(ty.is_signed());\n-        let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());\n+        let param_ty = ty::ParamEnv::empty().and(ty);\n         let bits = self.hir.tcx().layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n         let literal = ty::Const::from_bits(self.hir.tcx(), n, param_ty);"}, {"sha": "f7958434afa64b326b7941d6fb47ed56c8313562", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -126,7 +126,7 @@ pub fn mir_build<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Body<'tcx> {\n \n             let arguments = implicit_argument.into_iter().chain(explicit_arguments);\n \n-            let (yield_ty, return_ty) = if body.is_generator {\n+            let (yield_ty, return_ty) = if body.generator_kind.is_some() {\n                 let gen_sig = match ty.sty {\n                     ty::Generator(gen_def_id, gen_substs, ..) =>\n                         gen_substs.sig(gen_def_id, tcx),\n@@ -590,7 +590,7 @@ where\n         return_ty_span,\n         upvar_debuginfo,\n         upvar_mutbls,\n-        body.is_generator);\n+        body.generator_kind.is_some());\n \n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,"}, {"sha": "37f2a915782497cd4065490a29e0254df3866ef5", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -151,7 +151,7 @@ pub(crate) fn on_all_drop_children_bits<'tcx, F>(\n         debug!(\"on_all_drop_children_bits({:?}, {:?} : {:?})\", path, place, ty);\n \n         let gcx = tcx.global_tcx();\n-        let erased_ty = gcx.lift(&tcx.erase_regions(&ty)).unwrap();\n+        let erased_ty = tcx.erase_regions(&ty);\n         if erased_ty.needs_drop(gcx, ctxt.param_env) {\n             each_child(child);\n         } else {"}, {"sha": "bc01e3ee95b978871b92e9a878bee65bf62ba707", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -18,7 +18,7 @@ crate fn lit_to_const<'tcx>(\n     use syntax::ast::*;\n \n     let trunc = |n| {\n-        let param_ty = ParamEnv::reveal_all().and(tcx.lift_to_global(&ty).unwrap());\n+        let param_ty = ParamEnv::reveal_all().and(ty);\n         let width = tcx.layout_of(param_ty).map_err(|_| LitToConstError::Reported)?.size;\n         trace!(\"trunc {} with size {} and shift {}\", n, width.bits(), 128 - width.bits());\n         let result = truncate(n, width);"}, {"sha": "baf9086a4800e4a0ab184c075c5c5759f87947bd", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -763,7 +763,7 @@ fn make_mirror_unadjusted<'a, 'tcx>(\n         hir::ExprKind::Array(ref fields) => ExprKind::Array { fields: fields.to_ref() },\n         hir::ExprKind::Tup(ref fields) => ExprKind::Tuple { fields: fields.to_ref() },\n \n-        hir::ExprKind::Yield(ref v) => ExprKind::Yield { value: v.to_ref() },\n+        hir::ExprKind::Yield(ref v, _) => ExprKind::Yield { value: v.to_ref() },\n         hir::ExprKind::Err => unreachable!(),\n     };\n "}, {"sha": "4e197f1ed4ecf8aa82c37c9215014ea67b1bf076", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -190,12 +190,7 @@ impl<'a, 'tcx> Cx<'a, 'tcx> {\n     }\n \n     pub fn needs_drop(&mut self, ty: Ty<'tcx>) -> bool {\n-        let (ty, param_env) = self.tcx.lift_to_global(&(ty, self.param_env)).unwrap_or_else(|| {\n-            bug!(\"MIR: Cx::needs_drop({:?}, {:?}) got \\\n-                  type with inference types/regions\",\n-                 ty, self.param_env);\n-        });\n-        ty.needs_drop(self.tcx.global_tcx(), param_env)\n+        ty.needs_drop(self.tcx.global_tcx(), self.param_env)\n     }\n \n     pub fn tcx(&self) -> TyCtxt<'tcx> {"}, {"sha": "764ff0e15d5a43bfc152c5eb0003055bdfbe6374", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1310,7 +1310,7 @@ fn is_useful_specialized<'p, 'a, 'tcx>(\n /// Returns `None` in case of a catch-all, which can't be specialized.\n fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n                           pat: &Pattern<'tcx>,\n-                          pcx: PatternContext<'_>)\n+                          pcx: PatternContext<'tcx>)\n                           -> Option<Vec<Constructor<'tcx>>>\n {\n     match *pat.kind {"}, {"sha": "bc1151974bb70bd4367ffd2c40288e5780892f04", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -545,7 +545,7 @@ fn check_expr_kind<'a, 'tcx>(\n         }\n \n         // Generator expressions\n-        hir::ExprKind::Yield(ref expr) => {\n+        hir::ExprKind::Yield(ref expr, _) => {\n             let _ = v.check_expr(&expr);\n             NotPromotable\n         }"}, {"sha": "16d484e2a98f2e699edc0078c41c61bdd1972544", "filename": "src/librustc_plugin/registry.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_plugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_plugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Fregistry.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -4,9 +4,8 @@ use rustc::lint::{EarlyLintPassObject, LateLintPassObject, LintId, Lint};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n \n-use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind, NamedSyntaxExtension};\n use syntax::ext::base::MacroExpanderFn;\n-use syntax::ext::hygiene::Transparency;\n use syntax::symbol::{Symbol, sym};\n use syntax::ast;\n use syntax::feature_gate::AttributeType;\n@@ -89,28 +88,21 @@ impl<'a> Registry<'a> {\n         if name == sym::macro_rules {\n             panic!(\"user-defined macros may not be named `macro_rules`\");\n         }\n-        if let SyntaxExtension::LegacyBang { def_info: ref mut def_info @ None, .. } = extension {\n-            *def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n+        if extension.def_info.is_none() {\n+            extension.def_info = Some((ast::CRATE_NODE_ID, self.krate_span));\n         }\n         self.syntax_exts.push((name, extension));\n     }\n \n     /// Register a macro of the usual kind.\n     ///\n     /// This is a convenience wrapper for `register_syntax_extension`.\n-    /// It builds for you a `SyntaxExtension::LegacyBang` that calls `expander`,\n+    /// It builds for you a `SyntaxExtensionKind::LegacyBang` that calls `expander`,\n     /// and also takes care of interning the macro's name.\n     pub fn register_macro(&mut self, name: &str, expander: MacroExpanderFn) {\n-        self.register_syntax_extension(Symbol::intern(name), SyntaxExtension::LegacyBang {\n-            expander: Box::new(expander),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: self.sess.edition(),\n-        });\n+        let kind = SyntaxExtensionKind::LegacyBang(Box::new(expander));\n+        let ext = SyntaxExtension::default(kind, self.sess.edition());\n+        self.register_syntax_extension(Symbol::intern(name), ext);\n     }\n \n     /// Register a compiler lint pass."}, {"sha": "616728d5418483a01364b5cdb1d37db32cf1b274", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -772,9 +772,8 @@ impl<'a> Resolver<'a> {\n     pub fn get_macro(&mut self, res: Res) -> Lrc<SyntaxExtension> {\n         let def_id = match res {\n             Res::Def(DefKind::Macro(..), def_id) => def_id,\n-            Res::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n-                mark_used: attr_kind == NonMacroAttrKind::Tool,\n-            }),\n+            Res::NonMacroAttr(attr_kind) =>\n+                return self.non_macro_attr(attr_kind == NonMacroAttrKind::Tool),\n             _ => panic!(\"expected `DefKind::Macro` or `Res::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {"}, {"sha": "0fbd0666ad1c13c4af4c30c955861b66c7c9656c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -41,7 +41,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{Mark, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::SyntaxExtension;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::base::Determinacy::{self, Determined, Undetermined};\n use syntax::ext::base::MacroKind;\n use syntax::symbol::{Symbol, kw, sym};\n@@ -1668,6 +1668,7 @@ pub struct Resolver<'a> {\n     macro_use_prelude: FxHashMap<Name, &'a NameBinding<'a>>,\n     pub all_macros: FxHashMap<Name, Res>,\n     macro_map: FxHashMap<DefId, Lrc<SyntaxExtension>>,\n+    non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<Mark, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n \n@@ -1941,6 +1942,10 @@ impl<'a> Resolver<'a> {\n         let mut macro_defs = FxHashMap::default();\n         macro_defs.insert(Mark::root(), root_def_id);\n \n+        let non_macro_attr = |mark_used| Lrc::new(SyntaxExtension::default(\n+            SyntaxExtensionKind::NonMacroAttr { mark_used }, session.edition()\n+        ));\n+\n         Resolver {\n             session,\n \n@@ -2014,6 +2019,7 @@ impl<'a> Resolver<'a> {\n             macro_use_prelude: FxHashMap::default(),\n             all_macros: FxHashMap::default(),\n             macro_map: FxHashMap::default(),\n+            non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocations,\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -2030,6 +2036,10 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n+    fn non_macro_attr(&self, mark_used: bool) -> Lrc<SyntaxExtension> {\n+        self.non_macro_attrs[mark_used as usize].clone()\n+    }\n+\n     /// Runs the function on each namespace.\n     fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n         f(self, TypeNS);"}, {"sha": "5623016c2e5e7e988b50879cd3e73cf065ac87ba", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 34, "deletions": 23, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -114,6 +114,22 @@ fn sub_namespace_match(candidate: Option<MacroKind>, requirement: Option<MacroKi\n     candidate.is_none() || requirement.is_none() || candidate == requirement\n }\n \n+// We don't want to format a path using pretty-printing,\n+// `format!(\"{}\", path)`, because that tries to insert\n+// line-breaks and is slow.\n+fn fast_print_path(path: &ast::Path) -> String {\n+    let mut path_str = String::with_capacity(64);\n+    for (i, segment) in path.segments.iter().enumerate() {\n+        if i != 0 {\n+            path_str.push_str(\"::\");\n+        }\n+        if segment.ident.name != kw::PathRoot {\n+            path_str.push_str(&segment.ident.as_str())\n+        }\n+    }\n+    path_str\n+}\n+\n impl<'a> base::Resolver for Resolver<'a> {\n     fn next_node_id(&mut self) -> ast::NodeId {\n         self.session.next_node_id()\n@@ -174,7 +190,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             krate: CrateNum::BuiltinMacros,\n             index: DefIndex::from(self.macro_map.len()),\n         };\n-        let kind = ext.kind();\n+        let kind = ext.macro_kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n             kind: NameBindingKind::Res(Res::Def(DefKind::Macro(kind), def_id), false),\n@@ -209,14 +225,19 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n         let (res, ext) = match self.resolve_macro_to_res(path, kind, &parent_scope, true, force) {\n             Ok((res, ext)) => (res, ext),\n-            Err(Determinacy::Determined) if kind == MacroKind::Attr => {\n-                // Replace unresolved attributes with used inert attributes for better recovery.\n-                return Ok(Some(Lrc::new(SyntaxExtension::NonMacroAttr { mark_used: true })));\n-            }\n+            // Replace unresolved attributes with used inert attributes for better recovery.\n+            Err(Determinacy::Determined) if kind == MacroKind::Attr =>\n+                (Res::Err, self.non_macro_attr(true)),\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Res::Def(DefKind::Macro(_), def_id) = res {\n+        let format = match kind {\n+            MacroKind::Derive => format!(\"derive({})\", fast_print_path(path)),\n+            _ => fast_print_path(path),\n+        };\n+        invoc.expansion_data.mark.set_expn_info(ext.expn_info(invoc.span(), &format));\n+\n+        if let Res::Def(_, def_id) = res {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");\n@@ -226,7 +247,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 self.macro_def_scope(invoc.expansion_data.mark).normal_ancestor_id;\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n-            invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n         }\n \n         Ok(Some(ext))\n@@ -241,11 +261,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n \n     fn check_unused_macros(&self) {\n         for did in self.unused_macros.iter() {\n-            let id_span = match *self.macro_map[did] {\n-                SyntaxExtension::LegacyBang { def_info, .. } => def_info,\n-                _ => None,\n-            };\n-            if let Some((id, span)) = id_span {\n+            if let Some((id, span)) = self.macro_map[did].def_info {\n                 let lint = lint::builtin::UNUSED_MACROS;\n                 let msg = \"unused macro definition\";\n                 self.session.buffer_lint(lint, id, span, msg);\n@@ -585,17 +601,12 @@ impl<'a> Resolver<'a> {\n                         let parent_scope = ParentScope { derives: Vec::new(), ..*parent_scope };\n                         match self.resolve_macro_to_res(derive, MacroKind::Derive,\n                                                         &parent_scope, true, force) {\n-                            Ok((_, ext)) => {\n-                                if let SyntaxExtension::Derive(_, helpers, _) = &*ext {\n-                                    if helpers.contains(&ident.name) {\n-                                        let binding =\n-                                            (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n-                                            ty::Visibility::Public, derive.span, Mark::root())\n-                                            .to_name_binding(self.arenas);\n-                                        result = Ok((binding, Flags::empty()));\n-                                        break;\n-                                    }\n-                                }\n+                            Ok((_, ext)) => if ext.helper_attrs.contains(&ident.name) {\n+                                let binding = (Res::NonMacroAttr(NonMacroAttrKind::DeriveHelper),\n+                                               ty::Visibility::Public, derive.span, Mark::root())\n+                                               .to_name_binding(self.arenas);\n+                                result = Ok((binding, Flags::empty()));\n+                                break;\n                             }\n                             Err(Determinacy::Determined) => {}\n                             Err(Determinacy::Undetermined) =>"}, {"sha": "d138ce753b07e4be6eb18047e728050834faf07f", "filename": "src/librustc_traits/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fnormalize_erasing_regions.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -37,8 +37,7 @@ fn normalize_ty_after_erasing_regions<'tcx>(\n                 );\n \n                 let normalized_value = infcx.resolve_vars_if_possible(&normalized_value);\n-                let normalized_value = infcx.tcx.erase_regions(&normalized_value);\n-                tcx.lift_to_global(&normalized_value).unwrap()\n+                infcx.tcx.erase_regions(&normalized_value)\n             }\n             Err(NoSolution) => bug!(\"could not fully normalize `{:?}`\", value),\n         }"}, {"sha": "563bb5760a94e31e07cdcaf941a74509aa97884d", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ExprKind::Index(ref base, ref idx) => {\n                 self.check_expr_index(base, idx, needs, expr)\n             }\n-            ExprKind::Yield(ref value) => {\n+            ExprKind::Yield(ref value, _) => {\n                 self.check_expr_yield(value, expr)\n             }\n             hir::ExprKind::Err => {"}, {"sha": "72f42c85eadafd7faed079eab35c9904c4cb4f66", "filename": "src/librustc_typeck/check/generator_interior.rs", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fgenerator_interior.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -6,7 +6,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Pat, PatKind, Expr};\n-use rustc::middle::region;\n+use rustc::middle::region::{self, YieldData};\n use rustc::ty::{self, Ty};\n use syntax_pos::Span;\n use super::FnCtxt;\n@@ -17,6 +17,7 @@ struct InteriorVisitor<'a, 'tcx> {\n     types: FxHashMap<Ty<'tcx>, usize>,\n     region_scope_tree: &'tcx region::ScopeTree,\n     expr_count: usize,\n+    kind: hir::GeneratorKind,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -27,8 +28,8 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n               source_span: Span) {\n         use syntax_pos::DUMMY_SP;\n \n-        let live_across_yield = scope.map_or(Some(DUMMY_SP), |s| {\n-            self.region_scope_tree.yield_in_scope(s).and_then(|(yield_span, expr_count)| {\n+        let live_across_yield = scope.map(|s| {\n+            self.region_scope_tree.yield_in_scope(s).and_then(|yield_data| {\n                 // If we are recording an expression that is the last yield\n                 // in the scope, or that has a postorder CFG index larger\n                 // than the one of all of the yields, then its value can't\n@@ -37,31 +38,43 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                 // See the mega-comment at `yield_in_scope` for a proof.\n \n                 debug!(\"comparing counts yield: {} self: {}, source_span = {:?}\",\n-                       expr_count, self.expr_count, source_span);\n+                       yield_data.expr_and_pat_count, self.expr_count, source_span);\n \n-                if expr_count >= self.expr_count {\n-                    Some(yield_span)\n+                if yield_data.expr_and_pat_count >= self.expr_count {\n+                    Some(yield_data)\n                 } else {\n                     None\n                 }\n             })\n-        });\n-\n-        if let Some(yield_span) = live_across_yield {\n+        }).unwrap_or_else(|| Some(YieldData {\n+            span: DUMMY_SP,\n+            expr_and_pat_count: 0,\n+            source: match self.kind { // Guess based on the kind of the current generator.\n+                hir::GeneratorKind::Gen => hir::YieldSource::Yield,\n+                hir::GeneratorKind::Async => hir::YieldSource::Await,\n+            },\n+        }));\n+\n+        if let Some(yield_data) = live_across_yield {\n             let ty = self.fcx.resolve_vars_if_possible(&ty);\n \n             debug!(\"type in expr = {:?}, scope = {:?}, type = {:?}, count = {}, yield_span = {:?}\",\n-                   expr, scope, ty, self.expr_count, yield_span);\n+                   expr, scope, ty, self.expr_count, yield_data.span);\n \n             if let Some((unresolved_type, unresolved_type_span)) =\n                 self.fcx.unresolved_type_vars(&ty)\n             {\n+                let note = format!(\"the type is part of the {} because of this {}\",\n+                                   self.kind,\n+                                   yield_data.source);\n+\n                 // If unresolved type isn't a ty_var then unresolved_type_span is None\n                 self.fcx.need_type_info_err_in_generator(\n-                    unresolved_type_span.unwrap_or(yield_span),\n-                    unresolved_type)\n-                    .span_note(yield_span,\n-                               \"the type is part of the generator because of this `yield`\")\n+                    self.kind,\n+                    unresolved_type_span.unwrap_or(yield_data.span),\n+                    unresolved_type,\n+                )\n+                    .span_note(yield_data.span, &*note)\n                     .emit();\n             } else {\n                 // Map the type to the number of types added before it\n@@ -80,13 +93,15 @@ pub fn resolve_interior<'a, 'tcx>(\n     def_id: DefId,\n     body_id: hir::BodyId,\n     interior: Ty<'tcx>,\n+    kind: hir::GeneratorKind,\n ) {\n     let body = fcx.tcx.hir().body(body_id);\n     let mut visitor = InteriorVisitor {\n         fcx,\n         types: FxHashMap::default(),\n         region_scope_tree: fcx.tcx.region_scope_tree(def_id),\n         expr_count: 0,\n+        kind,\n     };\n     intravisit::walk_body(&mut visitor, body);\n "}, {"sha": "177e2158044082fb82c95a45a65b13555e3d37f1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 117, "deletions": 92, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -217,7 +217,7 @@ pub struct Inherited<'a, 'tcx> {\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n \n-    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>)>>,\n+    deferred_generator_interiors: RefCell<Vec<(hir::BodyId, Ty<'tcx>, hir::GeneratorKind)>>,\n \n     // Opaque types found in explicit return types and their\n     // associated fresh inference variable. Writeback resolves these\n@@ -1071,7 +1071,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    if body.is_generator && can_be_generator.is_some() {\n+    if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::TypeInference,\n             span,\n@@ -1108,12 +1108,12 @@ fn check_fn<'a, 'tcx>(\n     // We insert the deferred_generator_interiors entry after visiting the body.\n     // This ensures that all nested generators appear before the entry of this generator.\n     // resolve_generator_interiors relies on this property.\n-    let gen_ty = if can_be_generator.is_some() && body.is_generator {\n+    let gen_ty = if let (Some(_), Some(gen_kind)) = (can_be_generator, body.generator_kind) {\n         let interior = fcx.next_ty_var(TypeVariableOrigin {\n             kind: TypeVariableOriginKind::MiscVariable,\n             span,\n         });\n-        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior));\n+        fcx.deferred_generator_interiors.borrow_mut().push((body.id(), interior, gen_kind));\n         Some(GeneratorTypes {\n             yield_ty: fcx.yield_ty.unwrap(),\n             interior,\n@@ -1788,32 +1788,71 @@ fn check_packed_inner<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, stack: &mut Vec<De\n     false\n }\n \n+/// Emit an error when encountering more or less than one variant in a transparent enum.\n+fn bad_variant_count<'tcx>(tcx: TyCtxt<'tcx>, adt: &'tcx ty::AdtDef, sp: Span, did: DefId) {\n+    let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n+        tcx.hir().span_if_local(variant.def_id).unwrap()\n+    }).collect();\n+    let msg = format!(\n+        \"needs exactly one variant, but has {}\",\n+        adt.variants.len(),\n+    );\n+    let mut err = struct_span_err!(tcx.sess, sp, E0731, \"transparent enum {}\", msg);\n+    err.span_label(sp, &msg);\n+    if let &[ref start.., ref end] = &variant_spans[..] {\n+        for variant_span in start {\n+            err.span_label(*variant_span, \"\");\n+        }\n+        err.span_label(*end, &format!(\"too many variants in `{}`\", tcx.def_path_str(did)));\n+    }\n+    err.emit();\n+}\n+\n+/// Emit an error when encountering more or less than one non-zero-sized field in a transparent\n+/// enum.\n+fn bad_non_zero_sized_fields<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    adt: &'tcx ty::AdtDef,\n+    field_count: usize,\n+    field_spans: impl Iterator<Item = Span>,\n+    sp: Span,\n+) {\n+    let msg = format!(\"needs exactly one non-zero-sized field, but has {}\", field_count);\n+    let mut err = struct_span_err!(\n+        tcx.sess,\n+        sp,\n+        E0690,\n+        \"{}transparent {} {}\",\n+        if adt.is_enum() { \"the variant of a \" } else { \"\" },\n+        adt.descr(),\n+        msg,\n+    );\n+    err.span_label(sp, &msg);\n+    for sp in field_spans {\n+        err.span_label(sp, \"this field is non-zero-sized\");\n+    }\n+    err.emit();\n+}\n+\n fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n     let adt = tcx.adt_def(def_id);\n     if !adt.repr.transparent() {\n         return;\n     }\n+    let sp = tcx.sess.source_map().def_span(sp);\n \n     if adt.is_enum() {\n         if !tcx.features().transparent_enums {\n-            emit_feature_err(&tcx.sess.parse_sess,\n-                             sym::transparent_enums,\n-                             sp,\n-                             GateIssue::Language,\n-                             \"transparent enums are unstable\");\n+            emit_feature_err(\n+                &tcx.sess.parse_sess,\n+                sym::transparent_enums,\n+                sp,\n+                GateIssue::Language,\n+                \"transparent enums are unstable\",\n+            );\n         }\n         if adt.variants.len() != 1 {\n-            let variant_spans: Vec<_> = adt.variants.iter().map(|variant| {\n-                tcx.hir().span_if_local(variant.def_id).unwrap()\n-            }).collect();\n-            let mut err = struct_span_err!(tcx.sess, sp, E0731,\n-                            \"transparent enum needs exactly one variant, but has {}\",\n-                            adt.variants.len());\n-            if !variant_spans.is_empty() {\n-                err.span_note(variant_spans, &format!(\"the following variants exist on `{}`\",\n-                                                      tcx.def_path_str(def_id)));\n-            }\n-            err.emit();\n+            bad_variant_count(tcx, adt, sp, def_id);\n             if adt.variants.is_empty() {\n                 // Don't bother checking the fields. No variants (and thus no fields) exist.\n                 return;\n@@ -1841,28 +1880,24 @@ fn check_transparent<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, def_id: DefId) {\n         (span, zst, align1)\n     });\n \n-    let non_zst_fields = field_infos.clone().filter(|(_span, zst, _align1)| !*zst);\n+    let non_zst_fields = field_infos.clone().filter_map(|(span, zst, _align1)| if !zst {\n+        Some(span)\n+    } else {\n+        None\n+    });\n     let non_zst_count = non_zst_fields.clone().count();\n     if non_zst_count != 1 {\n-        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| span).collect();\n-\n-        let mut err = struct_span_err!(tcx.sess, sp, E0690,\n-                         \"{}transparent {} needs exactly one non-zero-sized field, but has {}\",\n-                         if adt.is_enum() { \"the variant of a \" } else { \"\" },\n-                         adt.descr(),\n-                         non_zst_count);\n-        if !field_spans.is_empty() {\n-            err.span_note(field_spans,\n-                          &format!(\"the following non-zero-sized fields exist on `{}`:\",\n-                                   tcx.def_path_str(def_id)));\n-        }\n-        err.emit();\n+        bad_non_zero_sized_fields(tcx, adt, non_zst_count, non_zst_fields, sp);\n     }\n     for (span, zst, align1) in field_infos {\n         if zst && !align1 {\n-            span_err!(tcx.sess, span, E0691,\n-                      \"zero-sized field in transparent {} has alignment larger than 1\",\n-                      adt.descr());\n+            struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0691,\n+                \"zero-sized field in transparent {} has alignment larger than 1\",\n+                adt.descr(),\n+            ).span_label(span, \"has alignment larger than 1\").emit();\n         }\n     }\n }\n@@ -2598,9 +2633,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn resolve_generator_interiors(&self, def_id: DefId) {\n         let mut generators = self.deferred_generator_interiors.borrow_mut();\n-        for (body_id, interior) in generators.drain(..) {\n+        for (body_id, interior, kind) in generators.drain(..) {\n             self.select_obligations_where_possible(false);\n-            generator_interior::resolve_interior(self, def_id, body_id, interior);\n+            generator_interior::resolve_interior(self, def_id, body_id, interior, kind);\n         }\n     }\n \n@@ -3922,52 +3957,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(original_span.with_lo(original_span.hi() - BytePos(1)))\n     }\n \n-    // Rewrite `SelfCtor` to `Ctor`\n-    pub fn rewrite_self_ctor(\n-        &self,\n-        res: Res,\n-        span: Span,\n-    ) -> Result<Res, ErrorReported> {\n-        let tcx = self.tcx;\n-        if let Res::SelfCtor(impl_def_id) = res {\n-            let ty = self.impl_self_ty(span, impl_def_id).ty;\n-            let adt_def = ty.ty_adt_def();\n-\n-            match adt_def {\n-                Some(adt_def) if adt_def.has_ctor() => {\n-                    let variant = adt_def.non_enum_variant();\n-                    let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    Ok(Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id))\n-                }\n-                _ => {\n-                    let mut err = tcx.sess.struct_span_err(span,\n-                        \"the `Self` constructor can only be used with tuple or unit structs\");\n-                    if let Some(adt_def) = adt_def {\n-                        match adt_def.adt_kind() {\n-                            AdtKind::Enum => {\n-                                err.help(\"did you mean to use one of the enum's variants?\");\n-                            },\n-                            AdtKind::Struct |\n-                            AdtKind::Union => {\n-                                err.span_suggestion(\n-                                    span,\n-                                    \"use curly brackets\",\n-                                    String::from(\"Self { /* fields */ }\"),\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                            }\n-                        }\n-                    }\n-                    err.emit();\n-\n-                    Err(ErrorReported)\n-                }\n-            }\n-        } else {\n-            Ok(res)\n-        }\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     pub fn instantiate_value_path(&self,\n@@ -3987,12 +3976,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let tcx = self.tcx;\n \n-        let res = match self.rewrite_self_ctor(res, span) {\n-            Ok(res) => res,\n-            Err(ErrorReported) => return (tcx.types.err, res),\n-        };\n         let path_segs = match res {\n-            Res::Local(_) => vec![],\n+            Res::Local(_) | Res::SelfCtor(_) => vec![],\n             Res::Def(kind, def_id) =>\n                 AstConv::def_ids_for_value_path_segments(self, segments, self_ty, kind, def_id),\n             _ => bug!(\"instantiate_value_path on {:?}\", res),\n@@ -4097,13 +4082,53 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n+        let (res, self_ctor_substs) = if let Res::SelfCtor(impl_def_id) = res {\n+            let ty = self.impl_self_ty(span, impl_def_id).ty;\n+            let adt_def = ty.ty_adt_def();\n+\n+            match ty.sty {\n+                ty::Adt(adt_def, substs) if adt_def.has_ctor() => {\n+                    let variant = adt_def.non_enum_variant();\n+                    let ctor_def_id = variant.ctor_def_id.unwrap();\n+                    (\n+                        Res::Def(DefKind::Ctor(CtorOf::Struct, variant.ctor_kind), ctor_def_id),\n+                        Some(substs),\n+                    )\n+                }\n+                _ => {\n+                    let mut err = tcx.sess.struct_span_err(span,\n+                        \"the `Self` constructor can only be used with tuple or unit structs\");\n+                    if let Some(adt_def) = adt_def {\n+                        match adt_def.adt_kind() {\n+                            AdtKind::Enum => {\n+                                err.help(\"did you mean to use one of the enum's variants?\");\n+                            },\n+                            AdtKind::Struct |\n+                            AdtKind::Union => {\n+                                err.span_suggestion(\n+                                    span,\n+                                    \"use curly brackets\",\n+                                    String::from(\"Self { /* fields */ }\"),\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            }\n+                        }\n+                    }\n+                    err.emit();\n+\n+                    return (tcx.types.err, res)\n+                }\n+            }\n+        } else {\n+            (res, None)\n+        };\n         let def_id = res.def_id();\n \n         // The things we are substituting into the type should not contain\n         // escaping late-bound regions, and nor should the base type scheme.\n         let ty = tcx.type_of(def_id);\n \n-        let substs = AstConv::create_substs_for_generic_args(\n+        let substs = self_ctor_substs.unwrap_or_else(|| AstConv::create_substs_for_generic_args(\n             tcx,\n             def_id,\n             &[][..],\n@@ -4173,7 +4198,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-        );\n+        ));\n         assert!(!substs.has_escaping_bound_vars());\n         assert!(!ty.has_escaping_bound_vars());\n "}, {"sha": "9259b3b5d3abb1b1ed91505ee9590550fac3616a", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -3,7 +3,7 @@\n use std::iter::once;\n \n use syntax::ast;\n-use syntax::ext::base::{MacroKind, SyntaxExtension};\n+use syntax::ext::base::MacroKind;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n@@ -470,18 +470,12 @@ fn build_macro(cx: &DocContext<'_>, did: DefId, name: ast::Name) -> clean::ItemE\n             })\n         }\n         LoadedMacro::ProcMacro(ext) => {\n-            let helpers = match &*ext {\n-                &SyntaxExtension::Derive(_, ref syms, ..) => { syms.clean(cx) }\n-                _ => Vec::new(),\n-            };\n-\n             clean::ProcMacroItem(clean::ProcMacro {\n-                kind: ext.kind(),\n-                helpers,\n+                kind: ext.macro_kind(),\n+                helpers: ext.helper_attrs.clean(cx),\n             })\n         }\n     }\n-\n }\n \n /// A trait's generics clause actually contains all of the predicates for all of"}, {"sha": "b42a78f1e226a58d1539ddd267ac161e28278bac", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -3066,7 +3066,7 @@ fn render_implementor(cx: &Context, implementor: &Impl, w: &mut fmt::Formatter<'\n         _ => false,\n     };\n     render_impl(w, cx, implementor, AssocItemLink::Anchor(None), RenderMode::Normal,\n-                implementor.impl_item.stable_since(), false, Some(use_absolute), false)?;\n+                implementor.impl_item.stable_since(), false, Some(use_absolute), false, false)?;\n     Ok(())\n }\n \n@@ -3077,7 +3077,7 @@ fn render_impls(cx: &Context, w: &mut fmt::Formatter<'_>,\n         let did = i.trait_did().unwrap();\n         let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n         render_impl(w, cx, i, assoc_link,\n-                    RenderMode::Normal, containing_item.stable_since(), true, None, false)?;\n+                    RenderMode::Normal, containing_item.stable_since(), true, None, false, true)?;\n     }\n     Ok(())\n }\n@@ -3307,7 +3307,7 @@ fn item_trait(\n                 );\n                 render_impl(w, cx, &implementor, assoc_link,\n                             RenderMode::Normal, implementor.impl_item.stable_since(), false,\n-                            None, true)?;\n+                            None, true, false)?;\n             }\n             write_loading_content(w, \"\")?;\n         }\n@@ -3979,7 +3979,7 @@ fn render_assoc_items(w: &mut fmt::Formatter<'_>,\n         };\n         for i in &non_trait {\n             render_impl(w, cx, i, AssocItemLink::Anchor(None), render_mode,\n-                        containing_item.stable_since(), true, None, false)?;\n+                        containing_item.stable_since(), true, None, false, true)?;\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n@@ -4161,7 +4161,8 @@ fn spotlight_decl(decl: &clean::FnDecl) -> Result<String, fmt::Error> {\n \n fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n                render_mode: RenderMode, outer_version: Option<&str>, show_def_docs: bool,\n-               use_absolute: Option<bool>, is_on_foreign_type: bool) -> fmt::Result {\n+               use_absolute: Option<bool>, is_on_foreign_type: bool,\n+               show_default_items: bool) -> fmt::Result {\n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n             Some(ref t) => if is_on_foreign_type {\n@@ -4345,9 +4346,13 @@ fn render_impl(w: &mut fmt::Formatter<'_>, cx: &Context, i: &Impl, link: AssocIt\n \n     // If we've implemented a trait, then also emit documentation for all\n     // default items which weren't overridden in the implementation block.\n-    if let Some(t) = trait_ {\n-        render_default_items(w, cx, t, &i.inner_impl(),\n-                             render_mode, outer_version, show_def_docs)?;\n+    // We don't emit documentation for default items if they appear in the\n+    // Implementations on Foreign Types or Implementors sections.\n+    if show_default_items {\n+        if let Some(t) = trait_ {\n+            render_default_items(w, cx, t, &i.inner_impl(),\n+                                render_mode, outer_version, show_def_docs)?;\n+        }\n     }\n     write!(w, \"</div>\")?;\n "}, {"sha": "68b96a408294b9429aff7b525d47d575ef6355f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -423,7 +423,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n /// Resolves a string as a macro.\n fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n-    use syntax::ext::base::{MacroKind, SyntaxExtension};\n+    use syntax::ext::base::{MacroKind, SyntaxExtensionKind};\n     let segment = ast::PathSegment::from_ident(Ident::from_str(path_str));\n     let path = ast::Path { segments: vec![segment], span: DUMMY_SP };\n     cx.enter_resolver(|resolver| {\n@@ -433,7 +433,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Res> {\n             if let Res::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = res {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n-                if let SyntaxExtension::LegacyBang { .. } = *resolver.get_macro(res) {\n+                if let SyntaxExtensionKind::LegacyBang(..) = resolver.get_macro(res).kind {\n                     return Some(res.map_id(|_| panic!(\"unexpected id\")));\n                 }\n             }"}, {"sha": "318a5a3a82a2e6010f9a7d1bd2d46d847eb14a2d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 88, "deletions": 86, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -15,6 +15,7 @@ use crate::tokenstream::{self, TokenStream};\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, MultiSpan, DUMMY_SP};\n+use syntax_pos::hygiene::{ExpnInfo, ExpnFormat};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -548,46 +549,26 @@ impl MacroKind {\n     }\n }\n \n-/// An enum representing the different kinds of syntax extensions.\n-pub enum SyntaxExtension {\n+/// A syntax extension kind.\n+pub enum SyntaxExtensionKind {\n     /// A token-based function-like macro.\n-    Bang {\n+    Bang(\n         /// An expander with signature TokenStream -> TokenStream.\n-        expander: Box<dyn ProcMacro + sync::Sync + sync::Send>,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn ProcMacro + sync::Sync + sync::Send>,\n+    ),\n \n     /// An AST-based function-like macro.\n-    LegacyBang {\n+    LegacyBang(\n         /// An expander with signature TokenStream -> AST.\n-        expander: Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n-        /// Some info about the macro's definition point.\n-        def_info: Option<(ast::NodeId, Span)>,\n-        /// Hygienic properties of identifiers produced by this macro.\n-        transparency: Transparency,\n-        /// Whitelist of unstable features that are treated as stable inside this macro.\n-        allow_internal_unstable: Option<Lrc<[Symbol]>>,\n-        /// Suppresses the `unsafe_code` lint for code produced by this macro.\n-        allow_internal_unsafe: bool,\n-        /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n-        local_inner_macros: bool,\n-        /// The macro's feature name and tracking issue number if it is unstable.\n-        unstable_feature: Option<(Symbol, u32)>,\n-        /// Edition of the crate in which this macro is defined.\n-        edition: Edition,\n-    },\n+        Box<dyn TTMacroExpander + sync::Sync + sync::Send>,\n+    ),\n \n     /// A token-based attribute macro.\n     Attr(\n         /// An expander with signature (TokenStream, TokenStream) -> TokenStream.\n         /// The first TokenSteam is the attribute itself, the second is the annotated item.\n         /// The produced TokenSteam replaces the input TokenSteam.\n         Box<dyn AttrProcMacro + sync::Sync + sync::Send>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based attribute macro.\n@@ -599,7 +580,8 @@ pub enum SyntaxExtension {\n     ),\n \n     /// A trivial attribute \"macro\" that does nothing,\n-    /// only keeps the attribute and marks it as known.\n+    /// only keeps the attribute and marks it as inert,\n+    /// thus making it ineligible for further expansion.\n     NonMacroAttr {\n         /// Suppresses the `unused_attributes` lint for this attribute.\n         mark_used: bool,\n@@ -610,10 +592,6 @@ pub enum SyntaxExtension {\n         /// An expander with signature TokenStream -> TokenStream (not yet).\n         /// The produced TokenSteam is appended to the input TokenSteam.\n         Box<dyn MultiItemModifier + sync::Sync + sync::Send>,\n-        /// Names of helper attributes registered by this macro.\n-        Vec<Symbol>,\n-        /// Edition of the crate in which this macro is defined.\n-        Edition,\n     ),\n \n     /// An AST-based derive macro.\n@@ -624,42 +602,91 @@ pub enum SyntaxExtension {\n     ),\n }\n \n+/// A struct representing a macro definition in \"lowered\" form ready for expansion.\n+pub struct SyntaxExtension {\n+    /// A syntax extension kind.\n+    pub kind: SyntaxExtensionKind,\n+    /// Some info about the macro's definition point.\n+    pub def_info: Option<(ast::NodeId, Span)>,\n+    /// Hygienic properties of spans produced by this macro by default.\n+    pub default_transparency: Transparency,\n+    /// Whitelist of unstable features that are treated as stable inside this macro.\n+    pub allow_internal_unstable: Option<Lrc<[Symbol]>>,\n+    /// Suppresses the `unsafe_code` lint for code produced by this macro.\n+    pub allow_internal_unsafe: bool,\n+    /// Enables the macro helper hack (`ident!(...)` -> `$crate::ident!(...)`) for this macro.\n+    pub local_inner_macros: bool,\n+    /// The macro's feature name and tracking issue number if it is unstable.\n+    pub unstable_feature: Option<(Symbol, u32)>,\n+    /// Names of helper attributes registered by this macro.\n+    pub helper_attrs: Vec<Symbol>,\n+    /// Edition of the crate in which this macro is defined.\n+    pub edition: Edition,\n+}\n+\n+impl SyntaxExtensionKind {\n+    /// When a syntax extension is constructed,\n+    /// its transparency can often be inferred from its kind.\n+    fn default_transparency(&self) -> Transparency {\n+        match self {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => Transparency::Opaque,\n+            SyntaxExtensionKind::LegacyBang(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => Transparency::SemiTransparent,\n+        }\n+    }\n+}\n+\n impl SyntaxExtension {\n     /// Returns which kind of macro calls this syntax extension.\n-    pub fn kind(&self) -> MacroKind {\n-        match *self {\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::LegacyBang { .. } => MacroKind::Bang,\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => MacroKind::Attr,\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::LegacyDerive(..) => MacroKind::Derive,\n+    pub fn macro_kind(&self) -> MacroKind {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => MacroKind::Bang,\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => MacroKind::Attr,\n+            SyntaxExtensionKind::Derive(..) |\n+            SyntaxExtensionKind::LegacyDerive(..) => MacroKind::Derive,\n         }\n     }\n \n-    pub fn default_transparency(&self) -> Transparency {\n-        match *self {\n-            SyntaxExtension::LegacyBang { transparency, .. } => transparency,\n-            SyntaxExtension::Bang { .. } |\n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::Derive(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => Transparency::Opaque,\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => Transparency::SemiTransparent,\n+    /// Constructs a syntax extension with default properties.\n+    pub fn default(kind: SyntaxExtensionKind, edition: Edition) -> SyntaxExtension {\n+        SyntaxExtension {\n+            def_info: None,\n+            default_transparency: kind.default_transparency(),\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            unstable_feature: None,\n+            helper_attrs: Vec::new(),\n+            edition,\n+            kind,\n         }\n     }\n \n-    pub fn edition(&self, default_edition: Edition) -> Edition {\n-        match *self {\n-            SyntaxExtension::Bang { edition, .. } |\n-            SyntaxExtension::LegacyBang { edition, .. } |\n-            SyntaxExtension::Attr(.., edition) |\n-            SyntaxExtension::Derive(.., edition) => edition,\n-            // Unstable legacy stuff\n-            SyntaxExtension::NonMacroAttr { .. } |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::LegacyDerive(..) => default_edition,\n+    fn expn_format(&self, symbol: Symbol) -> ExpnFormat {\n+        match self.kind {\n+            SyntaxExtensionKind::Bang(..) |\n+            SyntaxExtensionKind::LegacyBang(..) => ExpnFormat::MacroBang(symbol),\n+            _ => ExpnFormat::MacroAttribute(symbol),\n+        }\n+    }\n+\n+    pub fn expn_info(&self, call_site: Span, format: &str) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format: self.expn_format(Symbol::intern(format)),\n+            def_site: self.def_info.map(|(_, span)| span),\n+            default_transparency: self.default_transparency,\n+            allow_internal_unstable: self.allow_internal_unstable.clone(),\n+            allow_internal_unsafe: self.allow_internal_unsafe,\n+            local_inner_macros: self.local_inner_macros,\n+            edition: self.edition,\n         }\n     }\n }\n@@ -699,31 +726,6 @@ impl Determinacy {\n     }\n }\n \n-pub struct DummyResolver;\n-\n-impl Resolver for DummyResolver {\n-    fn next_node_id(&mut self) -> ast::NodeId { ast::DUMMY_NODE_ID }\n-\n-    fn get_module_scope(&mut self, _id: ast::NodeId) -> Mark { Mark::root() }\n-\n-    fn resolve_dollar_crates(&mut self, _fragment: &AstFragment) {}\n-    fn visit_ast_fragment_with_placeholders(&mut self, _invoc: Mark, _fragment: &AstFragment,\n-                                            _derives: &[Mark]) {}\n-    fn add_builtin(&mut self, _ident: ast::Ident, _ext: Lrc<SyntaxExtension>) {}\n-\n-    fn resolve_imports(&mut self) {}\n-    fn resolve_macro_invocation(&mut self, _invoc: &Invocation, _invoc_id: Mark, _force: bool)\n-                                -> Result<Option<Lrc<SyntaxExtension>>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn resolve_macro_path(&mut self, _path: &ast::Path, _kind: MacroKind, _invoc_id: Mark,\n-                          _derives_in_scope: Vec<ast::Path>, _force: bool)\n-                          -> Result<Lrc<SyntaxExtension>, Determinacy> {\n-        Err(Determinacy::Determined)\n-    }\n-    fn check_unused_macros(&self) {}\n-}\n-\n #[derive(Clone)]\n pub struct ModuleData {\n     pub mod_path: Vec<ast::Ident>,"}, {"sha": "abc451c96ae0ef9f1cdc794fb08a6e6f0f42e39b", "filename": "src/libsyntax/ext/derive.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderive.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -60,15 +60,10 @@ pub fn add_derived_markers<T>(cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::P\n     }\n     pretty_name.push(')');\n \n-    cx.current_expansion.mark.set_expn_info(ExpnInfo {\n-        call_site: span,\n-        def_site: None,\n-        format: ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)),\n-        allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::structural_match].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    cx.current_expansion.mark.set_expn_info(ExpnInfo::with_unstable(\n+        ExpnFormat::MacroAttribute(Symbol::intern(&pretty_name)), span, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, sym::structural_match],\n+    ));\n \n     let span = span.with_ctxt(cx.backtrace());\n     item.visit_attrs(|attrs| {"}, {"sha": "be90def0bdd2a2de5de6ba6ba916ed7498850e36", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 35, "deletions": 145, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1,7 +1,7 @@\n use crate::ast::{self, Block, Ident, LitKind, NodeId, PatKind, Path};\n use crate::ast::{MacStmtStyle, StmtKind, ItemKind};\n use crate::attr::{self, HasAttrs};\n-use crate::source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n+use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n use crate::ext::derive::{add_derived_markers, collect_derives};\n@@ -22,7 +22,6 @@ use crate::util::map_in_place::MapInPlace;\n use errors::{Applicability, FatalError};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{Span, DUMMY_SP, FileName};\n-use syntax_pos::hygiene::ExpnFormat;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n@@ -189,23 +188,6 @@ impl AstFragmentKind {\n     }\n }\n \n-fn macro_bang_format(path: &ast::Path) -> ExpnFormat {\n-    // We don't want to format a path using pretty-printing,\n-    // `format!(\"{}\", path)`, because that tries to insert\n-    // line-breaks and is slow.\n-    let mut path_str = String::with_capacity(64);\n-    for (i, segment) in path.segments.iter().enumerate() {\n-        if i != 0 {\n-            path_str.push_str(\"::\");\n-        }\n-        if segment.ident.name != kw::PathRoot {\n-            path_str.push_str(&segment.ident.as_str())\n-        }\n-    }\n-\n-    MacroBang(Symbol::intern(&path_str))\n-}\n-\n pub struct Invocation {\n     pub kind: InvocationKind,\n     fragment_kind: AstFragmentKind,\n@@ -388,8 +370,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                         derives.push(mark);\n                         let item = match self.cx.resolver.resolve_macro_path(\n                                 path, MacroKind::Derive, Mark::root(), Vec::new(), false) {\n-                            Ok(ext) => match *ext {\n-                                SyntaxExtension::LegacyDerive(..) => item_with_markers.clone(),\n+                            Ok(ext) => match ext.kind {\n+                                SyntaxExtensionKind::LegacyDerive(..) => item_with_markers.clone(),\n                                 _ => item.clone(),\n                             },\n                             _ => item.clone(),\n@@ -509,7 +491,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     fn expand_invoc(&mut self, invoc: Invocation, ext: &SyntaxExtension) -> Option<AstFragment> {\n         if invoc.fragment_kind == AstFragmentKind::ForeignItems &&\n            !self.cx.ecfg.macros_in_extern_enabled() {\n-            if let SyntaxExtension::NonMacroAttr { .. } = *ext {} else {\n+            if let SyntaxExtensionKind::NonMacroAttr { .. } = ext.kind {} else {\n                 emit_feature_err(&self.cx.parse_sess, sym::macros_in_extern,\n                                  invoc.span(), GateIssue::Language,\n                                  \"macro invocations in `extern {}` blocks are experimental\");\n@@ -548,34 +530,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             _ => unreachable!(),\n         };\n \n-        if let SyntaxExtension::NonMacroAttr { mark_used: false } = *ext {} else {\n-            // Macro attrs are always used when expanded,\n-            // non-macro attrs are considered used when the field says so.\n-            attr::mark_used(&attr);\n-        }\n-        invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-            call_site: attr.span,\n-            def_site: None,\n-            format: MacroAttribute(Symbol::intern(&attr.path.to_string())),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        });\n-\n-        match *ext {\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+        match &ext.kind {\n+            SyntaxExtensionKind::NonMacroAttr { mark_used } => {\n                 attr::mark_known(&attr);\n+                if *mark_used {\n+                    attr::mark_used(&attr);\n+                }\n                 item.visit_attrs(|attrs| attrs.push(attr));\n                 Some(invoc.fragment_kind.expect_from_annotatables(iter::once(item)))\n             }\n-            SyntaxExtension::LegacyAttr(ref mac) => {\n+            SyntaxExtensionKind::LegacyAttr(expander) => {\n                 let meta = attr.parse_meta(self.cx.parse_sess)\n                                .map_err(|mut e| { e.emit(); }).ok()?;\n-                let item = mac.expand(self.cx, attr.span, &meta, item);\n+                let item = expander.expand(self.cx, attr.span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(item))\n             }\n-            SyntaxExtension::Attr(ref mac, ..) => {\n+            SyntaxExtensionKind::Attr(expander) => {\n                 self.gate_proc_macro_attr_item(attr.span, &item);\n                 let item_tok = TokenTree::token(token::Interpolated(Lrc::new(match item {\n                     Annotatable::Item(item) => token::NtItem(item),\n@@ -586,13 +556,13 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     Annotatable::Expr(expr) => token::NtExpr(expr),\n                 })), DUMMY_SP).into();\n                 let input = self.extract_proc_macro_attr_input(attr.tokens, attr.span);\n-                let tok_result = mac.expand(self.cx, attr.span, input, item_tok);\n+                let tok_result = expander.expand(self.cx, attr.span, input, item_tok);\n                 let res = self.parse_ast_fragment(tok_result, invoc.fragment_kind,\n                                                   &attr.path, attr.span);\n                 self.gate_proc_macro_expansion(attr.span, &res);\n                 res\n             }\n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(attr.span, &format!(\"`{}` is a derive macro\", attr.path));\n                 self.cx.trace_macros_diag();\n                 invoc.fragment_kind.dummy(attr.span)\n@@ -693,29 +663,21 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                          invoc: Invocation,\n                          ext: &SyntaxExtension)\n                          -> Option<AstFragment> {\n-        let (mark, kind) = (invoc.expansion_data.mark, invoc.fragment_kind);\n+        let kind = invoc.fragment_kind;\n         let (mac, ident, span) = match invoc.kind {\n             InvocationKind::Bang { mac, ident, span } => (mac, ident, span),\n             _ => unreachable!(),\n         };\n         let path = &mac.node.path;\n \n         let ident = ident.unwrap_or_else(|| Ident::invalid());\n-        let validate_and_set_expn_info = |this: &mut Self, // arg instead of capture\n-                                          def_site_span: Option<Span>,\n-                                          allow_internal_unstable,\n-                                          allow_internal_unsafe,\n-                                          local_inner_macros,\n-                                          // can't infer this type\n-                                          unstable_feature: Option<(Symbol, u32)>,\n-                                          edition| {\n-\n+        let validate = |this: &mut Self| {\n             // feature-gate the macro invocation\n-            if let Some((feature, issue)) = unstable_feature {\n+            if let Some((feature, issue)) = ext.unstable_feature {\n                 let crate_span = this.cx.current_expansion.crate_span.unwrap();\n                 // don't stability-check macros in the same crate\n                 // (the only time this is null is for syntax extensions registered as macros)\n-                if def_site_span.map_or(false, |def_span| !crate_span.contains(def_span))\n+                if ext.def_info.map_or(false, |(_, def_span)| !crate_span.contains(def_span))\n                     && !span.allows_unstable(feature)\n                     && this.cx.ecfg.features.map_or(true, |feats| {\n                     // macro features will count as lib features\n@@ -734,62 +696,39 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 this.cx.trace_macros_diag();\n                 return Err(kind.dummy(span));\n             }\n-            mark.set_expn_info(ExpnInfo {\n-                call_site: span,\n-                def_site: def_site_span,\n-                format: macro_bang_format(path),\n-                allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                edition,\n-            });\n             Ok(())\n         };\n \n-        let opt_expanded = match *ext {\n-            SyntaxExtension::LegacyBang {\n-                ref expander,\n-                def_info,\n-                ref allow_internal_unstable,\n-                allow_internal_unsafe,\n-                local_inner_macros,\n-                unstable_feature,\n-                edition,\n-                ..\n-            } => {\n-                if let Err(dummy_span) = validate_and_set_expn_info(self, def_info.map(|(_, s)| s),\n-                                                                    allow_internal_unstable.clone(),\n-                                                                    allow_internal_unsafe,\n-                                                                    local_inner_macros,\n-                                                                    unstable_feature,\n-                                                                    edition) {\n+        let opt_expanded = match &ext.kind {\n+            SyntaxExtensionKind::LegacyBang(expander) => {\n+                if let Err(dummy_span) = validate(self) {\n                     dummy_span\n                 } else {\n                     kind.make_from(expander.expand(\n                         self.cx,\n                         span,\n                         mac.node.stream(),\n-                        def_info.map(|(_, s)| s),\n+                        ext.def_info.map(|(_, s)| s),\n                     ))\n                 }\n             }\n \n-            SyntaxExtension::Attr(..) |\n-            SyntaxExtension::LegacyAttr(..) |\n-            SyntaxExtension::NonMacroAttr { .. } => {\n+            SyntaxExtensionKind::Attr(..) |\n+            SyntaxExtensionKind::LegacyAttr(..) |\n+            SyntaxExtensionKind::NonMacroAttr { .. } => {\n                 self.cx.span_err(path.span,\n                                  &format!(\"`{}` can only be used in attributes\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Derive(..) | SyntaxExtension::LegacyDerive(..) => {\n+            SyntaxExtensionKind::Derive(..) | SyntaxExtensionKind::LegacyDerive(..) => {\n                 self.cx.span_err(path.span, &format!(\"`{}` is a derive macro\", path));\n                 self.cx.trace_macros_diag();\n                 kind.dummy(span)\n             }\n \n-            SyntaxExtension::Bang { ref expander, ref allow_internal_unstable, edition } => {\n+            SyntaxExtensionKind::Bang(expander) => {\n                 if ident.name != kw::Invalid {\n                     let msg =\n                         format!(\"macro {}! expects no ident argument, given '{}'\", path, ident);\n@@ -798,19 +737,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     kind.dummy(span)\n                 } else {\n                     self.gate_proc_macro_expansion_kind(span, kind);\n-                    invoc.expansion_data.mark.set_expn_info(ExpnInfo {\n-                        call_site: span,\n-                        // FIXME procedural macros do not have proper span info\n-                        // yet, when they do, we should use it here.\n-                        def_site: None,\n-                        format: macro_bang_format(path),\n-                        // FIXME probably want to follow macro_rules macros here.\n-                        allow_internal_unstable: allow_internal_unstable.clone(),\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        edition,\n-                    });\n-\n                     let tok_result = expander.expand(self.cx, span, mac.node.stream());\n                     let result = self.parse_ast_fragment(tok_result, kind, path, span);\n                     self.gate_proc_macro_expansion(span, &result);\n@@ -867,55 +793,19 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             return None;\n         }\n \n-        let pretty_name = Symbol::intern(&format!(\"derive({})\", path));\n-        let span = path.span;\n-        let attr = ast::Attribute {\n-            path, span,\n-            tokens: TokenStream::empty(),\n-            // irrelevant:\n-            id: ast::AttrId(0), style: ast::AttrStyle::Outer, is_sugared_doc: false,\n-        };\n-\n-        let mut expn_info = ExpnInfo {\n-            call_site: span,\n-            def_site: None,\n-            format: MacroAttribute(pretty_name),\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ext.edition(self.cx.parse_sess.edition),\n-        };\n-\n-        match ext {\n-            SyntaxExtension::Derive(expander, ..) | SyntaxExtension::LegacyDerive(expander) => {\n-                let meta = match ext {\n-                    SyntaxExtension::Derive(..) => ast::MetaItem { // FIXME(jseyfried) avoid this\n-                        path: Path::from_ident(Ident::invalid()),\n-                        span: DUMMY_SP,\n-                        node: ast::MetaItemKind::Word,\n-                    },\n-                    _ => {\n-                        expn_info.allow_internal_unstable = Some(vec![\n-                            sym::rustc_attrs,\n-                            Symbol::intern(\"derive_clone_copy\"),\n-                            Symbol::intern(\"derive_eq\"),\n-                            // RustcDeserialize and RustcSerialize\n-                            Symbol::intern(\"libstd_sys_internals\"),\n-                        ].into());\n-                        attr.meta()?\n-                    }\n-                };\n-\n-                invoc.expansion_data.mark.set_expn_info(expn_info);\n-                let span = span.with_ctxt(self.cx.backtrace());\n+        match &ext.kind {\n+            SyntaxExtensionKind::Derive(expander) |\n+            SyntaxExtensionKind::LegacyDerive(expander) => {\n+                let meta = ast::MetaItem { node: ast::MetaItemKind::Word, span: path.span, path };\n+                let span = meta.span.with_ctxt(self.cx.backtrace());\n                 let items = expander.expand(self.cx, span, &meta, item);\n                 Some(invoc.fragment_kind.expect_from_annotatables(items))\n             }\n             _ => {\n-                let msg = &format!(\"macro `{}` may not be used for derive attributes\", attr.path);\n-                self.cx.span_err(span, msg);\n+                let msg = &format!(\"macro `{}` may not be used for derive attributes\", path);\n+                self.cx.span_err(path.span, msg);\n                 self.cx.trace_macros_diag();\n-                invoc.fragment_kind.dummy(span)\n+                invoc.fragment_kind.dummy(path.span)\n             }\n         }\n     }"}, {"sha": "7f051c260ec822a88b50dea9e0293bb160e46ff0", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1,6 +1,7 @@\n use crate::{ast, attr};\n use crate::edition::Edition;\n-use crate::ext::base::{DummyResult, ExtCtxt, MacResult, SyntaxExtension, TTMacroExpander};\n+use crate::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use crate::ext::base::{DummyResult, ExtCtxt, MacResult, TTMacroExpander};\n use crate::ext::expand::{AstFragment, AstFragmentKind};\n use crate::ext::hygiene::Transparency;\n use crate::ext::tt::macro_parser::{Success, Error, Failure};\n@@ -376,7 +377,7 @@ pub fn compile(\n         valid,\n     });\n \n-    let transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n+    let default_transparency = if attr::contains_name(&def.attrs, sym::rustc_transparent_macro) {\n         Transparency::Transparent\n     } else if body.legacy {\n         Transparency::SemiTransparent\n@@ -426,14 +427,15 @@ pub fn compile(\n         }\n     });\n \n-    SyntaxExtension::LegacyBang {\n-        expander,\n+    SyntaxExtension {\n+        kind: SyntaxExtensionKind::LegacyBang(expander),\n         def_info: Some((def.id, def.span)),\n-        transparency,\n+        default_transparency,\n         allow_internal_unstable,\n         allow_internal_unsafe,\n         local_inner_macros,\n         unstable_feature,\n+        helper_attrs: Vec::new(),\n         edition,\n     }\n }"}, {"sha": "6630bf9081546de2a712a73d7355e09debf9465a", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -16,15 +16,9 @@ use syntax_pos::{DUMMY_SP, Span};\n /// The expanded code uses the unstable `#[prelude_import]` attribute.\n fn ignored_span(sp: Span, edition: Edition) -> Span {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"std_inject\")),\n-        allow_internal_unstable: Some(vec![sym::prelude_import].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(Symbol::intern(\"std_inject\")), sp, edition, &[sym::prelude_import]\n+    ));\n     sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n }\n "}, {"sha": "f90b76721ee16a29402eb3e432505abb288df948", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -280,15 +280,10 @@ fn generate_test_harness(sess: &ParseSess,\n         test_runner\n     };\n \n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::test_case),\n-        allow_internal_unstable: Some(vec![sym::main, sym::test, sym::rustc_attrs].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::test_case), DUMMY_SP, sess.edition,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+    ));\n \n     TestHarnessGenerator {\n         cx,"}, {"sha": "1fe6094fca6861eeb1f2ba417f99769b2e5ed0ef", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -2,9 +2,10 @@\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast::{self, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt, SyntaxExtension, Resolver, MultiItemModifier};\n+use syntax::edition::Edition;\n+use syntax::ext::base::{Annotatable, ExtCtxt, Resolver, MultiItemModifier};\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, sym};\n use syntax_pos::Span;\n@@ -67,11 +68,25 @@ macro_rules! derive_traits {\n             }\n         }\n \n-        pub fn register_builtin_derives(resolver: &mut dyn Resolver) {\n+        pub fn register_builtin_derives(resolver: &mut dyn Resolver, edition: Edition) {\n+            let allow_internal_unstable = Some([\n+                sym::core_intrinsics,\n+                sym::rustc_attrs,\n+                Symbol::intern(\"derive_clone_copy\"),\n+                Symbol::intern(\"derive_eq\"),\n+                Symbol::intern(\"libstd_sys_internals\"), // RustcDeserialize and RustcSerialize\n+            ][..].into());\n+\n             $(\n                 resolver.add_builtin(\n                     ast::Ident::with_empty_ctxt(Symbol::intern($name)),\n-                    Lrc::new(SyntaxExtension::LegacyDerive(Box::new(BuiltinDerive($func))))\n+                    Lrc::new(SyntaxExtension {\n+                        allow_internal_unstable: allow_internal_unstable.clone(),\n+                        ..SyntaxExtension::default(\n+                            SyntaxExtensionKind::LegacyDerive(Box::new(BuiltinDerive($func))),\n+                            edition,\n+                        )\n+                    }),\n                 );\n             )*\n         }\n@@ -148,24 +163,11 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n \n /// Constructs an expression that calls an intrinsic\n fn call_intrinsic(cx: &ExtCtxt<'_>,\n-                  mut span: Span,\n+                  span: Span,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)\n                   -> P<ast::Expr> {\n-    let intrinsic_allowed_via_allow_internal_unstable = cx\n-        .current_expansion.mark.expn_info().unwrap()\n-        .allow_internal_unstable.map_or(false, |features| features.iter().any(|&s|\n-            s == sym::core_intrinsics\n-        ));\n-    if intrinsic_allowed_via_allow_internal_unstable {\n-        span = span.with_ctxt(cx.backtrace());\n-    } else { // Avoid instability errors with user defined curstom derives, cc #36316\n-        let mut info = cx.current_expansion.mark.expn_info().unwrap();\n-        info.allow_internal_unstable = Some(vec![sym::core_intrinsics].into());\n-        let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(info);\n-        span = span.with_ctxt(SyntaxContext::empty().apply_mark(mark));\n-    }\n+    let span = span.with_ctxt(cx.backtrace());\n     let path = cx.std_path(&[sym::intrinsics, Symbol::intern(intrinsic)]);\n     let call = cx.expr_call_global(span, path, args);\n "}, {"sha": "b868f5b273c4e6942671bc09f1276a5af34a4274", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 31, "deletions": 39, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -43,32 +43,31 @@ pub mod proc_macro_impl;\n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n \n-use syntax::ext::base::{MacroExpanderFn, NamedSyntaxExtension, SyntaxExtension};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::MacroExpanderFn;\n+use syntax::ext::base::{NamedSyntaxExtension, SyntaxExtension, SyntaxExtensionKind};\n use syntax::edition::Edition;\n use syntax::symbol::{sym, Symbol};\n \n pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n                          user_exts: Vec<NamedSyntaxExtension>,\n                          edition: Edition) {\n-    deriving::register_builtin_derives(resolver);\n+    deriving::register_builtin_derives(resolver, edition);\n \n     let mut register = |name, ext| {\n         resolver.add_builtin(ast::Ident::with_empty_ctxt(name), Lrc::new(ext));\n     };\n     macro_rules! register {\n         ($( $name:ident: $f:expr, )*) => { $(\n-            register(Symbol::intern(stringify!($name)),\n-                     SyntaxExtension::LegacyBang {\n-                        expander: Box::new($f as MacroExpanderFn),\n-                        def_info: None,\n-                        transparency: Transparency::SemiTransparent,\n-                        allow_internal_unstable: None,\n-                        allow_internal_unsafe: false,\n-                        local_inner_macros: false,\n-                        unstable_feature: None,\n-                        edition,\n-                    });\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyBang(Box::new($f as MacroExpanderFn)), edition\n+            ));\n+        )* }\n+    }\n+    macro_rules! register_attr {\n+        ($( $name:ident: $f:expr, )*) => { $(\n+            register(Symbol::intern(stringify!($name)), SyntaxExtension::default(\n+                SyntaxExtensionKind::LegacyAttr(Box::new($f)), edition\n+            ));\n         )* }\n     }\n \n@@ -97,33 +96,26 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n-    register(sym::test_case, SyntaxExtension::LegacyAttr(Box::new(test_case::expand)));\n-    register(sym::test, SyntaxExtension::LegacyAttr(Box::new(test::expand_test)));\n-    register(sym::bench, SyntaxExtension::LegacyAttr(Box::new(test::expand_bench)));\n+    register_attr! {\n+        test_case: test_case::expand,\n+        test: test::expand_test,\n+        bench: test::expand_bench,\n+    }\n \n     // format_args uses `unstable` things internally.\n-    register(Symbol::intern(\"format_args\"),\n-             SyntaxExtension::LegacyBang {\n-                expander: Box::new(format::expand_format_args),\n-                def_info: None,\n-                transparency: Transparency::SemiTransparent,\n-                allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                allow_internal_unsafe: false,\n-                local_inner_macros: false,\n-                unstable_feature: None,\n-                edition,\n-            });\n-    register(sym::format_args_nl,\n-             SyntaxExtension::LegacyBang {\n-                 expander: Box::new(format::expand_format_args_nl),\n-                 def_info: None,\n-                 transparency: Transparency::SemiTransparent,\n-                 allow_internal_unstable: Some(vec![sym::fmt_internals].into()),\n-                 allow_internal_unsafe: false,\n-                 local_inner_macros: false,\n-                 unstable_feature: None,\n-                 edition,\n-             });\n+    let allow_internal_unstable = Some([sym::fmt_internals][..].into());\n+    register(Symbol::intern(\"format_args\"), SyntaxExtension {\n+        allow_internal_unstable: allow_internal_unstable.clone(),\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args)), edition\n+        )\n+    });\n+    register(sym::format_args_nl, SyntaxExtension {\n+        allow_internal_unstable,\n+        ..SyntaxExtension::default(\n+            SyntaxExtensionKind::LegacyBang(Box::new(format::expand_format_args_nl)), edition\n+        )\n+    });\n \n     for (name, ext) in user_exts {\n         register(name, ext);"}, {"sha": "45e65288a24ee6a3b7614f24ef77d961812cb321", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -347,18 +347,10 @@ fn mk_decls(\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n     let mark = Mark::fresh(Mark::root());\n-    mark.set_expn_info(ExpnInfo {\n-        call_site: DUMMY_SP,\n-        def_site: None,\n-        format: MacroAttribute(sym::proc_macro),\n-        allow_internal_unstable: Some(vec![\n-            sym::rustc_attrs,\n-            Symbol::intern(\"proc_macro_internals\"),\n-        ].into()),\n-        allow_internal_unsafe: false,\n-        local_inner_macros: false,\n-        edition: cx.parse_sess.edition,\n-    });\n+    mark.set_expn_info(ExpnInfo::with_unstable(\n+        MacroAttribute(sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n+        &[sym::rustc_attrs, Symbol::intern(\"proc_macro_internals\")],\n+    ));\n     let span = DUMMY_SP.apply_mark(mark);\n \n     let hidden = cx.meta_list_item_word(span, sym::hidden);"}, {"sha": "24d3055e7114087192cb2ccfa784ac31ebe96425", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -8,7 +8,7 @@ use syntax::attr;\n use syntax::ast;\n use syntax::print::pprust;\n use syntax::symbol::{Symbol, sym};\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n \n@@ -62,15 +62,10 @@ pub fn expand_test_or_bench(\n \n     let (sp, attr_sp) = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test),\n-            allow_internal_unstable: Some(vec![sym::rustc_attrs, sym::test].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: cx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test), attr_sp, cx.parse_sess.edition,\n+            &[sym::rustc_attrs, sym::test],\n+        ));\n         (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n          attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n     };"}, {"sha": "6e3bc05b65e4ee38234135437b9da2b4971b9945", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -15,7 +15,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, Span};\n+use syntax_pos::Span;\n use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n \n@@ -37,15 +37,10 @@ pub fn expand(\n \n     let sp = {\n         let mark = Mark::fresh(Mark::root());\n-        mark.set_expn_info(ExpnInfo {\n-            call_site: DUMMY_SP,\n-            def_site: None,\n-            format: MacroAttribute(sym::test_case),\n-            allow_internal_unstable: Some(vec![sym::test, sym::rustc_attrs].into()),\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            edition: ecx.parse_sess.edition,\n-        });\n+        mark.set_expn_info(ExpnInfo::with_unstable(\n+            MacroAttribute(sym::test_case), attr_sp, ecx.parse_sess.edition,\n+            &[sym::test, sym::rustc_attrs],\n+        ));\n         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark))\n     };\n "}, {"sha": "4dbd4ccda910a6ef99c4ed010cfe0e07525788be", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 44, "deletions": 29, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -59,13 +59,12 @@ pub struct Mark(u32);\n #[derive(Clone, Debug)]\n struct MarkData {\n     parent: Mark,\n-    default_transparency: Transparency,\n     expn_info: Option<ExpnInfo>,\n }\n \n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum Transparency {\n     /// Identifier produced by a transparent expansion is always resolved at call-site.\n     /// Call-site spans in procedural macros, hygiene opt-out in `macro` should use this.\n@@ -85,12 +84,7 @@ pub enum Transparency {\n impl Mark {\n     pub fn fresh(parent: Mark) -> Self {\n         HygieneData::with(|data| {\n-            data.marks.push(MarkData {\n-                parent,\n-                // By default expansions behave like `macro_rules`.\n-                default_transparency: Transparency::SemiTransparent,\n-                expn_info: None,\n-            });\n+            data.marks.push(MarkData { parent, expn_info: None });\n             Mark(data.marks.len() as u32 - 1)\n         })\n     }\n@@ -118,20 +112,14 @@ impl Mark {\n \n     #[inline]\n     pub fn expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(self))\n+        HygieneData::with(|data| data.expn_info(self).cloned())\n     }\n \n     #[inline]\n     pub fn set_expn_info(self, info: ExpnInfo) {\n         HygieneData::with(|data| data.marks[self.0 as usize].expn_info = Some(info))\n     }\n \n-    #[inline]\n-    pub fn set_default_transparency(self, transparency: Transparency) {\n-        assert_ne!(self, Mark::root());\n-        HygieneData::with(|data| data.marks[self.0 as usize].default_transparency = transparency)\n-    }\n-\n     pub fn is_descendant_of(self, ancestor: Mark) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, ancestor))\n     }\n@@ -172,9 +160,8 @@ impl Mark {\n     #[inline]\n     pub fn looks_like_proc_macro_derive(self) -> bool {\n         HygieneData::with(|data| {\n-            let mark_data = &data.marks[self.0 as usize];\n-            if mark_data.default_transparency == Transparency::Opaque {\n-                if let Some(expn_info) = &mark_data.expn_info {\n+            if data.default_transparency(self) == Transparency::Opaque {\n+                if let Some(expn_info) = &data.marks[self.0 as usize].expn_info {\n                     if let ExpnFormat::MacroAttribute(name) = expn_info.format {\n                         if name.as_str().starts_with(\"derive(\") {\n                             return true;\n@@ -199,9 +186,6 @@ impl HygieneData {\n         HygieneData {\n             marks: vec![MarkData {\n                 parent: Mark::root(),\n-                // If the root is opaque, then loops searching for an opaque mark\n-                // will automatically stop after reaching it.\n-                default_transparency: Transparency::Opaque,\n                 expn_info: None,\n             }],\n             syntax_contexts: vec![SyntaxContextData {\n@@ -220,8 +204,8 @@ impl HygieneData {\n         GLOBALS.with(|globals| f(&mut *globals.hygiene_data.borrow_mut()))\n     }\n \n-    fn expn_info(&self, mark: Mark) -> Option<ExpnInfo> {\n-        self.marks[mark.0 as usize].expn_info.clone()\n+    fn expn_info(&self, mark: Mark) -> Option<&ExpnInfo> {\n+        self.marks[mark.0 as usize].expn_info.as_ref()\n     }\n \n     fn is_descendant_of(&self, mut mark: Mark, ancestor: Mark) -> bool {\n@@ -235,7 +219,9 @@ impl HygieneData {\n     }\n \n     fn default_transparency(&self, mark: Mark) -> Transparency {\n-        self.marks[mark.0 as usize].default_transparency\n+        self.marks[mark.0 as usize].expn_info.as_ref().map_or(\n+            Transparency::SemiTransparent, |einfo| einfo.default_transparency\n+        )\n     }\n \n     fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n@@ -427,7 +413,6 @@ impl SyntaxContext {\n         HygieneData::with(|data| {\n             data.marks.push(MarkData {\n                 parent: Mark::root(),\n-                default_transparency: Transparency::SemiTransparent,\n                 expn_info: Some(expansion_info),\n             });\n \n@@ -613,7 +598,7 @@ impl SyntaxContext {\n     /// `ctxt.outer().expn_info()`.\n     #[inline]\n     pub fn outer_expn_info(self) -> Option<ExpnInfo> {\n-        HygieneData::with(|data| data.expn_info(data.outer(self)))\n+        HygieneData::with(|data| data.expn_info(data.outer(self)).cloned())\n     }\n \n     /// `ctxt.outer_and_expn_info()` is equivalent to but faster than\n@@ -622,7 +607,7 @@ impl SyntaxContext {\n     pub fn outer_and_expn_info(self) -> (Mark, Option<ExpnInfo>) {\n         HygieneData::with(|data| {\n             let outer = data.outer(self);\n-            (outer, data.expn_info(outer))\n+            (outer, data.expn_info(outer).cloned())\n         })\n     }\n \n@@ -651,6 +636,7 @@ impl fmt::Debug for SyntaxContext {\n /// Extra information for tracking spans of macro and syntax sugar expansion\n #[derive(Clone, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub struct ExpnInfo {\n+    // --- The part unique to each expansion.\n     /// The location of the actual macro invocation or syntax sugar , e.g.\n     /// `let x = foo!();` or `if let Some(y) = x {}`\n     ///\n@@ -661,13 +647,18 @@ pub struct ExpnInfo {\n     /// call_site span would have its own ExpnInfo, with the call_site\n     /// pointing to the `foo!` invocation.\n     pub call_site: Span,\n+    /// The format with which the macro was invoked.\n+    pub format: ExpnFormat,\n+\n+    // --- The part specific to the macro/desugaring definition.\n+    // --- FIXME: Share it between expansions with the same definition.\n     /// The span of the macro definition itself. The macro may not\n     /// have a sensible definition span (e.g., something defined\n     /// completely inside libsyntax) in which case this is None.\n     /// This span serves only informational purpose and is not used for resolution.\n     pub def_site: Option<Span>,\n-    /// The format with which the macro was invoked.\n-    pub format: ExpnFormat,\n+    /// Transparency used by `apply_mark` for mark with this expansion info by default.\n+    pub default_transparency: Transparency,\n     /// List of #[unstable]/feature-gated features that the macro is allowed to use\n     /// internally without forcing the whole crate to opt-in\n     /// to them.\n@@ -682,6 +673,30 @@ pub struct ExpnInfo {\n     pub edition: Edition,\n }\n \n+impl ExpnInfo {\n+    /// Constructs an expansion info with default properties.\n+    pub fn default(format: ExpnFormat, call_site: Span, edition: Edition) -> ExpnInfo {\n+        ExpnInfo {\n+            call_site,\n+            format,\n+            def_site: None,\n+            default_transparency: Transparency::SemiTransparent,\n+            allow_internal_unstable: None,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition,\n+        }\n+    }\n+\n+    pub fn with_unstable(format: ExpnFormat, call_site: Span, edition: Edition,\n+                         allow_internal_unstable: &[Symbol]) -> ExpnInfo {\n+        ExpnInfo {\n+            allow_internal_unstable: Some(allow_internal_unstable.into()),\n+            ..ExpnInfo::default(format, call_site, edition)\n+        }\n+    }\n+}\n+\n /// The source of expansion.\n #[derive(Clone, Hash, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum ExpnFormat {"}, {"sha": "4cf8a4e33c52626bee51f84611cc645fb083d051", "filename": "src/test/run-pass-fulldeps/auxiliary/plugin-args.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fplugin-args.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -11,8 +11,8 @@ extern crate rustc_plugin;\n use std::borrow::ToOwned;\n use syntax::ast;\n use syntax::ext::build::AstBuilder;\n-use syntax::ext::base::{SyntaxExtension, TTMacroExpander, ExtCtxt, MacResult, MacEager};\n-use syntax::ext::hygiene::Transparency;\n+use syntax::ext::base::{SyntaxExtension, SyntaxExtensionKind};\n+use syntax::ext::base::{TTMacroExpander, ExtCtxt, MacResult, MacEager};\n use syntax::print::pprust;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -38,15 +38,7 @@ impl TTMacroExpander for Expander {\n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {\n     let args = reg.args().to_owned();\n-    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"),\n-        SyntaxExtension::LegacyBang {\n-            expander: Box::new(Expander { args: args, }),\n-            def_info: None,\n-            transparency: Transparency::SemiTransparent,\n-            allow_internal_unstable: None,\n-            allow_internal_unsafe: false,\n-            local_inner_macros: false,\n-            unstable_feature: None,\n-            edition: reg.sess.edition(),\n-        });\n+    reg.register_syntax_extension(Symbol::intern(\"plugin_args\"), SyntaxExtension::default(\n+        SyntaxExtensionKind::LegacyBang(Box::new(Expander { args })), reg.sess.edition()\n+    ));\n }"}, {"sha": "a6d3530f1390235777689ea79b123542ba7ec0ca", "filename": "src/test/run-pass-fulldeps/myriad-closures.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass-fulldeps%2Fmyriad-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass-fulldeps%2Fmyriad-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmyriad-closures.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -32,7 +32,7 @@ macro_rules! mk_fn {\n }\n \n fn main() {\n-    // Make 2^12 functions, each containing 16 closures,\n-    // resulting in 2^16 closures overall.\n-    go_bacterial!(mk_fn 1 1 1 1  1 1 1 1  1 1 1 1);\n+    // Make 2^8 functions, each containing 16 closures,\n+    // resulting in 2^12 closures overall.\n+    go_bacterial!(mk_fn 1 1 1 1  1 1 1 1);\n }"}, {"sha": "b70479d255b5ff26ee3f144f563bf2dc6d5110f4", "filename": "src/test/run-pass/consts/assoc-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fassoc-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fassoc-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fassoc-const.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/assoc-const.rs"}, {"sha": "3145c21acc9889b5e7c0a221b1166b288b292e3a", "filename": "src/test/run-pass/consts/bswap-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fbswap-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fbswap-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fbswap-const.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/bswap-const.rs"}, {"sha": "a171567c5d2fa0e185dc0c7a554a532c2580bc73", "filename": "src/test/run-pass/consts/chained-constants-stackoverflow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fchained-constants-stackoverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fchained-constants-stackoverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fchained-constants-stackoverflow.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/chained-constants-stackoverflow.rs"}, {"sha": "10a4c31f24ed4eb25c6c41d101842463c10185ee", "filename": "src/test/run-pass/consts/const-block-non-item-statement-3.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement-3.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/const-block-non-item-statement-3.rs"}, {"sha": "a1b9b586ad0384e70e2fffc0c66a141c51972dd9", "filename": "src/test/run-pass/consts/const-block-non-item-statement.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-block-non-item-statement.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/const-block-non-item-statement.rs"}, {"sha": "2ee6415aa68b75e042bff1be0ce2c40b823e438a", "filename": "src/test/run-pass/consts/const-fn-type-name.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-fn-type-name.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/const-fn-type-name.rs"}, {"sha": "1d3123d216ebfb53ae63ebe190c6961c5f30c6de", "filename": "src/test/run-pass/consts/const-int-conversion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-conversion.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-conversion.rs"}, {"sha": "9597393df72d27940010170a42fc6edcdbf61584", "filename": "src/test/run-pass/consts/const-int-overflowing.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-overflowing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-overflowing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-overflowing.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-overflowing.rs"}, {"sha": "16946eadd632aeb7c6dd1d652c729ab47b8fd9cc", "filename": "src/test/run-pass/consts/const-int-rotate.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-rotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-rotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-rotate.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-rotate.rs"}, {"sha": "dae4c7216b2c03c61005621d3cecc7b898ea32a8", "filename": "src/test/run-pass/consts/const-int-saturating-arith.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-saturating-arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-saturating-arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-saturating-arith.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-saturating-arith.rs"}, {"sha": "fcd3ef4ea025b805c7b8f20ab7261861bbaa47e4", "filename": "src/test/run-pass/consts/const-int-sign.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-sign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-sign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-sign.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-sign.rs"}, {"sha": "db86c25194f08585d3e6824242a0dd807531461e", "filename": "src/test/run-pass/consts/const-int-wrapping.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-wrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-wrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-int-wrapping.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-int-wrapping.rs"}, {"sha": "871300defaf8a7a656f8ab92799a362cf22d1112", "filename": "src/test/run-pass/consts/const-needs_drop.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-needs_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-needs_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fconst-needs_drop.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/const-needs_drop.rs"}, {"sha": "cc47b5b49c0b3d54c50f48cc5a134cd85e45dc51", "filename": "src/test/run-pass/consts/deref_in_pattern.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fderef_in_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fderef_in_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fderef_in_pattern.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/deref_in_pattern.rs"}, {"sha": "d1d90df240ca5bd3fd44af118eee2e22ca45000f", "filename": "src/test/run-pass/consts/ice-48279.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fice-48279.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fice-48279.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fice-48279.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/ice-48279.rs"}, {"sha": "04865830df2ebec06bb9e8550be08dd39c9579e6", "filename": "src/test/run-pass/consts/issue-37550.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-37550.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-37550.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-37550.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/issue-37550.rs"}, {"sha": "36f0ff92104e1de6bd2cbe5c9ece618307f5206d", "filename": "src/test/run-pass/consts/issue-broken-mir.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-broken-mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-broken-mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fissue-broken-mir.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/issue-broken-mir.rs"}, {"sha": "95d50171a847bca7d0db0f0a2705106d669ffc58", "filename": "src/test/run-pass/consts/locals-in-const-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Flocals-in-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Flocals-in-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Flocals-in-const-fn.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/locals-in-const-fn.rs"}, {"sha": "5a68048c47725085c34afccea0d66454dbefed2f", "filename": "src/test/run-pass/consts/match-const-fn-structs.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fmatch-const-fn-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fmatch-const-fn-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fmatch-const-fn-structs.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/match-const-fn-structs.rs"}, {"sha": "7edcadbf2cbf826a187f8fbe4ef356afd48307b2", "filename": "src/test/run-pass/consts/mozjs-error.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fmozjs-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fmozjs-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fmozjs-error.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/mozjs-error.rs"}, {"sha": "671366c90ec8ea7a8319127b4a8bcfbeeaf7fe6d", "filename": "src/test/run-pass/consts/non-scalar-cast.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fnon-scalar-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fnon-scalar-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fnon-scalar-cast.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/non-scalar-cast.rs"}, {"sha": "3c5401e4212164541d75d36a29ccef7b97c06b9f", "filename": "src/test/run-pass/consts/promotion.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fpromotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fpromotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fpromotion.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/promotion.rs"}, {"sha": "d0af47a8ea85e1370da8af2d0279206b37c8d387", "filename": "src/test/run-pass/consts/references.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Freferences.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/references.rs"}, {"sha": "20983184a473a4d5cd397bc57ebe865edab40216", "filename": "src/test/run-pass/consts/repeat_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Frepeat_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Frepeat_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Frepeat_match.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/repeat_match.rs"}, {"sha": "077a33c081ba8816e04d8c96ee9c4e6797680e32", "filename": "src/test/run-pass/consts/return-in-const-fn.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Freturn-in-const-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Freturn-in-const-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Freturn-in-const-fn.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/return-in-const-fn.rs"}, {"sha": "2e4395ccf2277a7faee3c83e757c9e70f79942f9", "filename": "src/test/run-pass/consts/signed_enum_discr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fsigned_enum_discr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Fsigned_enum_discr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Fsigned_enum_discr.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/signed_enum_discr.rs"}, {"sha": "e24f89cdffdff8abaaf15063faac878fbecadab7", "filename": "src/test/run-pass/consts/transmute-const.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Ftransmute-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Ftransmute-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Ftransmute-const.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/transmute-const.rs"}, {"sha": "1655f0eb850381678412c95c5df32477d9b76436", "filename": "src/test/run-pass/consts/tuple-struct-constructors.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Ftuple-struct-constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Frun-pass%2Fconsts%2Ftuple-struct-constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconsts%2Ftuple-struct-constructors.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "previous_filename": "src/test/run-pass/ctfe/tuple-struct-constructors.rs"}, {"sha": "578d41fe0df0bc238acf0abd2743c8b4666c6155", "filename": "src/test/ui/async-await/unresolved_type_param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -7,9 +7,9 @@ async fn bar<T>() -> () {}\n \n async fn foo() {\n     bar().await;\n-    //~^ ERROR type inside generator must be known in this context\n+    //~^ ERROR type inside `async` object must be known in this context\n     //~| NOTE cannot infer type for `T`\n-    //~| NOTE the type is part of the generator because of this `yield`\n+    //~| NOTE the type is part of the `async` object because of this `await`\n     //~| NOTE in this expansion of desugaring of `await`\n }\n fn main() {}"}, {"sha": "f3090a2b980e8d34eb80d93f333b86ad2ac90363", "filename": "src/test/ui/async-await/unresolved_type_param.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Funresolved_type_param.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1,10 +1,10 @@\n-error[E0698]: type inside generator must be known in this context\n+error[E0698]: type inside `async` object must be known in this context\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;\n    |     ^^^ cannot infer type for `T`\n    |\n-note: the type is part of the generator because of this `yield`\n+note: the type is part of the `async` object because of this `await`\n   --> $DIR/unresolved_type_param.rs:9:5\n    |\n LL |     bar().await;"}, {"sha": "8ba079b89f50952841fc9f304fe4895c23d6c914", "filename": "src/test/ui/feature-gates/feature-gate-transparent_enums.stderr", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_enums.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_enums.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_enums.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1,10 +1,8 @@\n error[E0658]: transparent enums are unstable\n   --> $DIR/feature-gate-transparent_enums.rs:2:1\n    |\n-LL | / enum OkButUnstableEnum {\n-LL | |     Foo((), String, ()),\n-LL | | }\n-   | |_^\n+LL | enum OkButUnstableEnum {\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/60405\n    = help: add #![feature(transparent_enums)] to the crate attributes to enable"}, {"sha": "341324c3d6764f87b38c02bba96add7fcede6594", "filename": "src/test/ui/feature-gates/feature-gate-transparent_unions.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-transparent_unions.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -1,11 +1,8 @@\n error[E0658]: transparent unions are unstable\n   --> $DIR/feature-gate-transparent_unions.rs:2:1\n    |\n-LL | / union OkButUnstableUnion {\n-LL | |     field: u8,\n-LL | |     zst: (),\n-LL | | }\n-   | |_^\n+LL | union OkButUnstableUnion {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: for more information, see https://github.com/rust-lang/rust/issues/60405\n    = help: add #![feature(transparent_unions)] to the crate attributes to enable"}, {"sha": "dc2942225e3de6205b0e6d1c723acbda0b768304", "filename": "src/test/ui/issues/issue-57924.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -3,6 +3,7 @@ pub struct Gcm<E>(E);\n impl<E> Gcm<E> {\n     pub fn crash(e: E) -> Self {\n         Self::<E>(e)\n+        //~^ ERROR type arguments are not allowed for this type\n     }\n }\n ", "previous_filename": "src/test/run-pass/issues/issue-57924.rs"}, {"sha": "2f184b1aae171847761d1aa750b09411866fa899", "filename": "src/test/ui/issues/issue-57924.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,9 @@\n+error[E0109]: type arguments are not allowed for this type\n+  --> $DIR/issue-57924.rs:5:16\n+   |\n+LL |         Self::<E>(e)\n+   |                ^ type argument not allowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0109`."}, {"sha": "1209b54bc410e8b4bd93b05fc5a348d01e18d64f", "filename": "src/test/ui/issues/issue-61882-2.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,11 @@\n+struct A<T>(T);\n+\n+impl A<&'static u8> {\n+    fn f() {\n+        let x = 0;\n+        Self(&x);\n+        //~^ ERROR `x` does not live long enough\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "03a65540ced04a549eba45fb8917f849868a3a53", "filename": "src/test/ui/issues/issue-61882-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61882-2.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `x` does not live long enough\n+  --> $DIR/issue-61882-2.rs:6:14\n+   |\n+LL |         Self(&x);\n+   |              ^^\n+   |              |\n+   |              borrowed value does not live long enough\n+   |              requires that `x` is borrowed for `'static`\n+LL |\n+LL |     }\n+   |     - `x` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "013398b4598a8fc58905d13eb289cac3f390fdce", "filename": "src/test/ui/issues/issue-61882.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61882.rs?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,9 @@\n+struct A<T>(T);\n+\n+impl A<bool> {\n+    const B: A<u8> = Self(0);\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "a14e1a4dd4d44aea6de4edb1b4b9a0ccd6c2fcea", "filename": "src/test/ui/issues/issue-61882.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Fissues%2Fissue-61882.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-61882.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -0,0 +1,21 @@\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61882.rs:4:27\n+   |\n+LL |     const B: A<u8> = Self(0);\n+   |                           ^ expected bool, found integer\n+   |\n+   = note: expected type `bool`\n+              found type `{integer}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-61882.rs:4:22\n+   |\n+LL |     const B: A<u8> = Self(0);\n+   |                      ^^^^^^^ expected u8, found bool\n+   |\n+   = note: expected type `A<u8>`\n+              found type `A<bool>`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "f0c1fbe8ac9e1ba1df67730e303384df3c6eb45c", "filename": "src/test/ui/repr/repr-transparent.stderr", "status": "modified", "additions": 34, "deletions": 60, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Frepr%2Frepr-transparent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftest%2Fui%2Frepr%2Frepr-transparent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frepr%2Frepr-transparent.stderr?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -2,61 +2,57 @@ error[E0690]: transparent struct needs exactly one non-zero-sized field, but has\n   --> $DIR/repr-transparent.rs:11:1\n    |\n LL | struct NoFields;\n-   | ^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: transparent struct needs exactly one non-zero-sized field, but has 0\n   --> $DIR/repr-transparent.rs:14:1\n    |\n LL | struct ContainsOnlyZst(());\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: transparent struct needs exactly one non-zero-sized field, but has 0\n   --> $DIR/repr-transparent.rs:17:1\n    |\n LL | struct ContainsOnlyZstArray([bool; 0]);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: transparent struct needs exactly one non-zero-sized field, but has 0\n   --> $DIR/repr-transparent.rs:20:1\n    |\n LL | struct ContainsMultipleZst(PhantomData<*const i32>, NoFields);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: transparent struct needs exactly one non-zero-sized field, but has 2\n   --> $DIR/repr-transparent.rs:24:1\n    |\n LL | struct MultipleNonZst(u8, u8);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the following non-zero-sized fields exist on `MultipleNonZst`:\n-  --> $DIR/repr-transparent.rs:24:23\n-   |\n-LL | struct MultipleNonZst(u8, u8);\n-   |                       ^^  ^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^--^^--^^\n+   | |                     |   |\n+   | |                     |   this field is non-zero-sized\n+   | |                     this field is non-zero-sized\n+   | needs exactly one non-zero-sized field, but has 2\n \n error[E0690]: transparent struct needs exactly one non-zero-sized field, but has 2\n   --> $DIR/repr-transparent.rs:30:1\n    |\n LL | pub struct StructWithProjection(f32, <f32 as Mirror>::It);\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the following non-zero-sized fields exist on `StructWithProjection`:\n-  --> $DIR/repr-transparent.rs:30:33\n-   |\n-LL | pub struct StructWithProjection(f32, <f32 as Mirror>::It);\n-   |                                 ^^^  ^^^^^^^^^^^^^^^^^^^\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---^^-------------------^^\n+   | |                               |    |\n+   | |                               |    this field is non-zero-sized\n+   | |                               this field is non-zero-sized\n+   | needs exactly one non-zero-sized field, but has 2\n \n error[E0691]: zero-sized field in transparent struct has alignment larger than 1\n   --> $DIR/repr-transparent.rs:34:32\n    |\n LL | struct NontrivialAlignZst(u32, [u16; 0]);\n-   |                                ^^^^^^^^\n+   |                                ^^^^^^^^ has alignment larger than 1\n \n error[E0691]: zero-sized field in transparent struct has alignment larger than 1\n   --> $DIR/repr-transparent.rs:40:24\n    |\n LL | struct GenericAlign<T>(ZstAlign32<T>, u32);\n-   |                        ^^^^^^^^^^^^^\n+   |                        ^^^^^^^^^^^^^ has alignment larger than 1\n \n error[E0084]: unsupported representation for zero-variant enum\n   --> $DIR/repr-transparent.rs:42:1\n@@ -70,71 +66,49 @@ error[E0731]: transparent enum needs exactly one variant, but has 0\n   --> $DIR/repr-transparent.rs:43:1\n    |\n LL | enum Void {}\n-   | ^^^^^^^^^^^^\n+   | ^^^^^^^^^ needs exactly one variant, but has 0\n \n error[E0690]: the variant of a transparent enum needs exactly one non-zero-sized field, but has 0\n   --> $DIR/repr-transparent.rs:47:1\n    |\n-LL | / enum FieldlessEnum {\n-LL | |     Foo,\n-LL | | }\n-   | |_^\n+LL | enum FieldlessEnum {\n+   | ^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: the variant of a transparent enum needs exactly one non-zero-sized field, but has 2\n   --> $DIR/repr-transparent.rs:52:1\n    |\n-LL | / enum TooManyFieldsEnum {\n-LL | |     Foo(u32, String),\n-LL | | }\n-   | |_^\n-   |\n-note: the following non-zero-sized fields exist on `TooManyFieldsEnum`:\n-  --> $DIR/repr-transparent.rs:53:9\n-   |\n+LL | enum TooManyFieldsEnum {\n+   | ^^^^^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 2\n LL |     Foo(u32, String),\n-   |         ^^^  ^^^^^^\n+   |         ---  ------ this field is non-zero-sized\n+   |         |\n+   |         this field is non-zero-sized\n \n error[E0731]: transparent enum needs exactly one variant, but has 2\n   --> $DIR/repr-transparent.rs:58:1\n    |\n-LL | / enum TooManyVariants {\n-LL | |     Foo(String),\n-LL | |     Bar,\n-LL | | }\n-   | |_^\n-   |\n-note: the following variants exist on `TooManyVariants`\n-  --> $DIR/repr-transparent.rs:59:5\n-   |\n+LL | enum TooManyVariants {\n+   | ^^^^^^^^^^^^^^^^^^^^ needs exactly one variant, but has 2\n LL |     Foo(String),\n-   |     ^^^^^^^^^^^\n+   |     -----------\n LL |     Bar,\n-   |     ^^^\n+   |     --- too many variants in `TooManyVariants`\n \n error[E0690]: transparent union needs exactly one non-zero-sized field, but has 0\n   --> $DIR/repr-transparent.rs:64:1\n    |\n-LL | / union UnitUnion {\n-LL | |     u: (),\n-LL | | }\n-   | |_^\n+LL | union UnitUnion {\n+   | ^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 0\n \n error[E0690]: transparent union needs exactly one non-zero-sized field, but has 2\n   --> $DIR/repr-transparent.rs:69:1\n    |\n-LL | / union TooManyFields {\n-LL | |     u: u32,\n-LL | |     s: i32\n-LL | | }\n-   | |_^\n-   |\n-note: the following non-zero-sized fields exist on `TooManyFields`:\n-  --> $DIR/repr-transparent.rs:70:5\n-   |\n+LL | union TooManyFields {\n+   | ^^^^^^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 2\n LL |     u: u32,\n-   |     ^^^^^^\n+   |     ------ this field is non-zero-sized\n LL |     s: i32\n-   |     ^^^^^^\n+   |     ------ this field is non-zero-sized\n \n error: aborting due to 15 previous errors\n "}, {"sha": "9e7c18b7f566b1920321f7120923cffa4f2f5ee2", "filename": "src/tools/publish_toolstate.py", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftools%2Fpublish_toolstate.py", "raw_url": "https://github.com/rust-lang/rust/raw/a6cbf2d1344418cd2807cc5380ef1247647a1e12/src%2Ftools%2Fpublish_toolstate.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fpublish_toolstate.py?ref=a6cbf2d1344418cd2807cc5380ef1247647a1e12", "patch": "@@ -64,6 +64,7 @@ def maybe_delink(message):\n \n def issue(\n     tool,\n+    status,\n     maintainers,\n     relevant_pr_number,\n     relevant_pr_user,\n@@ -72,20 +73,27 @@ def issue(\n     # Open an issue about the toolstate failure.\n     assignees = [x.strip() for x in maintainers.split('@') if x != '']\n     assignees.append(relevant_pr_user)\n+    if status == 'test-fail':\n+        status_description = 'has failing tests'\n+    else:\n+        status_description = 'no longer builds'\n     response = urllib2.urlopen(urllib2.Request(\n         gh_url(),\n         json.dumps({\n             'body': maybe_delink(textwrap.dedent('''\\\n             Hello, this is your friendly neighborhood mergebot.\n-            After merging PR {}, I observed that the tool {} no longer builds.\n+            After merging PR {}, I observed that the tool {} {}.\n             A follow-up PR to the repository {} is needed to fix the fallout.\n \n             cc @{}, do you think you would have time to do the follow-up work?\n             If so, that would be great!\n \n             cc @{}, the PR reviewer, and @rust-lang/compiler -- nominating for prioritization.\n \n-            ''').format(relevant_pr_number, tool, REPOS.get(tool), relevant_pr_user, pr_reviewer)),\n+            ''').format(\n+                relevant_pr_number, tool, status_description,\n+                REPOS.get(tool), relevant_pr_user, pr_reviewer\n+            )),\n             'title': '`{}` no longer builds after {}'.format(tool, relevant_pr_number),\n             'assignees': assignees,\n             'labels': ['T-compiler', 'I-nominated'],\n@@ -127,7 +135,7 @@ def update_latest(\n         for status in latest:\n             tool = status['tool']\n             changed = False\n-            build_failed = False\n+            create_issue = False\n \n             for os, s in current_status.items():\n                 old = status[os]\n@@ -145,14 +153,15 @@ def update_latest(\n                         .format(tool, os, old, new)\n                     message += '{} (cc {}, @rust-lang/infra).\\n' \\\n                         .format(title, MAINTAINERS.get(tool))\n-                    # only create issues for build failures. Other failures can be spurious\n-                    if new == 'build-fail':\n-                        build_failed = True\n+                    # Most tools only create issues for build failures.\n+                    # Other failures can be spurious.\n+                    if new == 'build-fail' or (tool == 'miri' and new == 'test-fail'):\n+                        create_issue = True\n \n-            if build_failed:\n+            if create_issue:\n                 try:\n                     issue(\n-                        tool, MAINTAINERS.get(tool, ''),\n+                        tool, new, MAINTAINERS.get(tool, ''),\n                         relevant_pr_number, relevant_pr_user, pr_reviewer,\n                     )\n                 except IOError as e:"}]}