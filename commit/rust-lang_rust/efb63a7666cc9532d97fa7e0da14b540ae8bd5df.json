{"sha": "efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjYzYTc2NjZjYzk1MzJkOTdmYTdlMGRhMTRiNTQwYWU4YmQ1ZGY=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T20:33:47Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-27T20:33:47Z"}, "message": "Merge #330\n\n330: WIP: introduce hir::Name r=matklad a=matklad\n\nCurrently we are using `SmolStr` throughout the hir as a name, but that is really suboptimal choice: we'll probably want some kind of interning in the future, and we'll definitely need to add hygene info to names. This PR aims to replace strings with a slightly more abstract `Name` type. \n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "c4c1b80d8e2dfbb6533cfbdf0bb647ddbeff9419", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4c1b80d8e2dfbb6533cfbdf0bb647ddbeff9419"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "html_url": "https://github.com/rust-lang/rust/commit/efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "b26ab3603d8f73c8e57e9e90d44486a608bc9370", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26ab3603d8f73c8e57e9e90d44486a608bc9370", "html_url": "https://github.com/rust-lang/rust/commit/b26ab3603d8f73c8e57e9e90d44486a608bc9370"}, {"sha": "e0660506719476a0546e10bee816d7220be85440", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0660506719476a0546e10bee816d7220be85440", "html_url": "https://github.com/rust-lang/rust/commit/e0660506719476a0546e10bee816d7220be85440"}], "stats": {"total": 396, "additions": 286, "deletions": 110}, "files": [{"sha": "0471a2fca560fb7ecae764cf7df6afe6b7903da8", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -243,7 +243,7 @@ impl AnalysisImpl {\n                     rr.add_resolution(\n                         position.file_id,\n                         FileSymbol {\n-                            name: entry.name().clone(),\n+                            name: entry.name().to_string().into(),\n                             node_range: entry.ptr().range(),\n                             kind: NAME,\n                         },\n@@ -261,23 +261,21 @@ impl AnalysisImpl {\n             let mut rr = ReferenceResolution::new(name.syntax().range());\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n-                    let parent_module =\n-                        source_binder::module_from_file_id(&*self.db, position.file_id)?;\n-                    let child_name = module.name();\n-                    match (parent_module, child_name) {\n-                        (Some(parent_module), Some(child_name)) => {\n-                            if let Some(child) = parent_module.child(&child_name.text()) {\n-                                let file_id = child.source().file_id();\n-                                let symbol = FileSymbol {\n-                                    name: child_name.text(),\n-                                    node_range: TextRange::offset_len(0.into(), 0.into()),\n-                                    kind: MODULE,\n-                                };\n-                                rr.add_resolution(file_id, symbol);\n-                                return Ok(Some(rr));\n-                            }\n-                        }\n-                        _ => (),\n+                    if let Some(child_module) =\n+                        source_binder::module_from_declaration(&*self.db, position.file_id, module)?\n+                    {\n+                        let file_id = child_module.source().file_id();\n+                        let name = match child_module.name() {\n+                            Some(name) => name.to_string().into(),\n+                            None => \"\".into(),\n+                        };\n+                        let symbol = FileSymbol {\n+                            name,\n+                            node_range: TextRange::offset_len(0.into(), 0.into()),\n+                            kind: MODULE,\n+                        };\n+                        rr.add_resolution(file_id, symbol);\n+                        return Ok(Some(rr));\n                     }\n                 }\n             }"}, {"sha": "3028db17c2d05f0f56270cba909ae6e140c460f7", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -14,7 +14,7 @@ pub use crate::{\n     cancelation::{Canceled, Cancelable},\n     syntax_ptr::LocalSyntaxPtr,\n     input::{\n-        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph,\n+        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n         FileTextQuery, FileSourceRootQuery, SourceRootQuery, LocalRootsQuery, LibraryRootsQuery, CrateGraphQuery,\n         FileRelativePathQuery\n     },"}, {"sha": "3e4cfad0c4b8178bc1238707bbfa8ee474cdde55", "filename": "crates/ra_hir/src/function/scope.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -1,14 +1,15 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    AstNode, SmolStr, SyntaxNodeRef, TextUnit, TextRange,\n+    AstNode, SyntaxNodeRef, TextUnit, TextRange,\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n };\n use ra_db::LocalSyntaxPtr;\n \n use crate::{\n     arena::{Arena, Id},\n+    Name, AsName,\n };\n \n pub(crate) type ScopeId = Id<ScopeData>;\n@@ -22,7 +23,7 @@ pub struct FnScopes {\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct ScopeEntry {\n-    name: SmolStr,\n+    name: Name,\n     ptr: LocalSyntaxPtr,\n }\n \n@@ -101,11 +102,12 @@ impl FnScopes {\n \n     pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n         let mut shadowed = FxHashSet::default();\n+        let name = name_ref.as_name();\n         let ret = self\n             .scope_chain(name_ref.syntax())\n             .flat_map(|scope| self.entries(scope).iter())\n             .filter(|entry| shadowed.insert(entry.name()))\n-            .filter(|entry| entry.name() == &name_ref.text())\n+            .filter(|entry| entry.name() == &name)\n             .nth(0);\n         ret\n     }\n@@ -170,14 +172,14 @@ impl FnScopes {\n \n impl ScopeEntry {\n     fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n-        let name = pat.name()?;\n+        let name = pat.name()?.as_name();\n         let res = ScopeEntry {\n-            name: name.text(),\n+            name,\n             ptr: LocalSyntaxPtr::new(pat.syntax()),\n         };\n         Some(res)\n     }\n-    pub fn name(&self) -> &SmolStr {\n+    pub fn name(&self) -> &Name {\n         &self.name\n     }\n     pub fn ptr(&self) -> LocalSyntaxPtr {\n@@ -334,7 +336,7 @@ pub struct ReferenceDescriptor {\n mod tests {\n     use ra_editor::find_node_at_offset;\n     use ra_syntax::SourceFileNode;\n-    use test_utils::extract_offset;\n+    use test_utils::{extract_offset, assert_eq_text};\n \n     use super::*;\n \n@@ -355,9 +357,11 @@ mod tests {\n         let actual = scopes\n             .scope_chain(marker.syntax())\n             .flat_map(|scope| scopes.entries(scope))\n-            .map(|it| it.name())\n-            .collect::<Vec<_>>();\n-        assert_eq!(actual.as_slice(), expected);\n+            .map(|it| it.name().to_string())\n+            .collect::<Vec<_>>()\n+            .join(\"\\n\");\n+        let expected = expected.join(\"\\n\");\n+        assert_eq_text!(&actual, &expected);\n     }\n \n     #[test]"}, {"sha": "89b1e639efdd1daf2d9964c96ceee0a8d557e0f9", "filename": "crates/ra_hir/src/krate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fkrate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fkrate.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -1,7 +1,6 @@\n-use ra_syntax::SmolStr;\n pub use ra_db::CrateId;\n \n-use crate::{HirDatabase, Module, Cancelable};\n+use crate::{HirDatabase, Module, Cancelable, Name, AsName};\n \n /// hir::Crate describes a single crate. It's the main inteface with which\n /// crate's dependencies interact. Mostly, it should be just a proxy for the\n@@ -14,7 +13,7 @@ pub struct Crate {\n #[derive(Debug)]\n pub struct CrateDependency {\n     pub krate: Crate,\n-    pub name: SmolStr,\n+    pub name: Name,\n }\n \n impl Crate {\n@@ -27,7 +26,7 @@ impl Crate {\n             .dependencies(self.crate_id)\n             .map(|dep| {\n                 let krate = Crate::new(dep.crate_id());\n-                let name = dep.name.clone();\n+                let name = dep.as_name();\n                 CrateDependency { krate, name }\n             })\n             .collect()"}, {"sha": "5bbb09c01c9fe58765fbf629b4b31b1e8391a3e4", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -22,6 +22,7 @@ mod path;\n mod arena;\n pub mod source_binder;\n \n+mod name;\n mod krate;\n mod module;\n mod function;\n@@ -37,10 +38,12 @@ use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n use crate::{\n     db::HirDatabase,\n     arena::{Arena, Id},\n+    name::{AsName, KnownName},\n };\n \n pub use self::{\n     path::{Path, PathKind},\n+    name::Name,\n     krate::Crate,\n     module::{Module, ModuleId, Problem, nameres::{ItemMap, PerNs, Namespace}, ModuleScope, Resolution},\n     function::{Function, FnScopes},"}, {"sha": "43413acb8b9125ac6f0423c2a01e18ea61f3f2d2", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -7,13 +7,14 @@ use log;\n use ra_syntax::{\n     algo::generate,\n     ast::{self, AstNode, NameOwner},\n-    SmolStr, SyntaxNode,\n+    SyntaxNode,\n };\n use ra_db::{SourceRootId, FileId, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n     DefKind, DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId, SourceFileItemId, Crate,\n+    Name,\n     arena::{Arena, Id},\n };\n \n@@ -84,7 +85,7 @@ impl Module {\n     }\n \n     /// `name` is `None` for the crate's root module\n-    pub fn name(&self) -> Option<SmolStr> {\n+    pub fn name(&self) -> Option<&Name> {\n         let link = self.module_id.parent_link(&self.tree)?;\n         Some(link.name(&self.tree))\n     }\n@@ -100,7 +101,7 @@ impl Module {\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &str) -> Option<Module> {\n+    pub fn child(&self, name: &Name) -> Option<Module> {\n         let child_id = self.module_id.child(&self.tree, name)?;\n         Some(Module {\n             module_id: child_id,\n@@ -230,15 +231,15 @@ impl ModuleId {\n             .last()\n             .unwrap()\n     }\n-    fn child(self, tree: &ModuleTree, name: &str) -> Option<ModuleId> {\n+    fn child(self, tree: &ModuleTree, name: &Name) -> Option<ModuleId> {\n         let link = tree.mods[self]\n             .children\n             .iter()\n             .map(|&it| &tree.links[it])\n-            .find(|it| it.name == name)?;\n+            .find(|it| it.name == *name)?;\n         Some(*link.points_to.first()?)\n     }\n-    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (SmolStr, ModuleId)> + 'a {\n+    fn children<'a>(self, tree: &'a ModuleTree) -> impl Iterator<Item = (Name, ModuleId)> + 'a {\n         tree.mods[self].children.iter().filter_map(move |&it| {\n             let link = &tree.links[it];\n             let module = *link.points_to.first()?;\n@@ -263,8 +264,8 @@ impl LinkId {\n     fn owner(self, tree: &ModuleTree) -> ModuleId {\n         tree.links[self].owner\n     }\n-    fn name(self, tree: &ModuleTree) -> SmolStr {\n-        tree.links[self].name.clone()\n+    fn name(self, tree: &ModuleTree) -> &Name {\n+        &tree.links[self].name\n     }\n     fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n         let owner = self.owner(tree);\n@@ -328,7 +329,7 @@ impl ModuleSource {\n #[derive(Hash, Debug, PartialEq, Eq)]\n struct LinkData {\n     owner: ModuleId,\n-    name: SmolStr,\n+    name: Name,\n     points_to: Vec<ModuleId>,\n     problem: Option<Problem>,\n }"}, {"sha": "eded85a63399481b7d1fb0527cf9a324a7ea61a2", "filename": "crates/ra_hir/src/module/imp.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -1,16 +1,13 @@\n use std::sync::Arc;\n \n-use ra_syntax::{\n-    ast::{self, NameOwner},\n-    SmolStr,\n-};\n+use ra_syntax::ast::{self, NameOwner};\n use relative_path::RelativePathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n use arrayvec::ArrayVec;\n use ra_db::{SourceRoot, SourceRootId, Cancelable, FileId};\n \n use crate::{\n-    HirDatabase,\n+    HirDatabase, Name, AsName,\n };\n \n use super::{\n@@ -20,12 +17,12 @@ use super::{\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n pub enum Submodule {\n-    Declaration(SmolStr),\n-    Definition(SmolStr, ModuleSource),\n+    Declaration(Name),\n+    Definition(Name, ModuleSource),\n }\n \n impl Submodule {\n-    fn name(&self) -> &SmolStr {\n+    fn name(&self) -> &Name {\n         match self {\n             Submodule::Declaration(name) => name,\n             Submodule::Definition(name, _) => name,\n@@ -35,14 +32,14 @@ impl Submodule {\n \n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n     root.items()\n         .filter_map(|item| match item {\n             ast::ModuleItem::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {\n-            let name = module.name()?.text();\n+            let name = module.name()?.as_name();\n             Some((name, module))\n         })\n }\n@@ -155,7 +152,7 @@ fn build_subtree(\n fn resolve_submodule(\n     db: &impl HirDatabase,\n     source: ModuleSource,\n-    name: &SmolStr,\n+    name: &Name,\n ) -> (Vec<FileId>, Option<Problem>) {\n     // FIXME: handle submodules of inline modules properly\n     let file_id = source.file_id();"}, {"sha": "68eb02a980a0490740e2b5e66a5247b08dca9d7c", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -14,14 +14,12 @@\n //! modifications (that is, typing inside a function shold not change IMIs),\n //! such that the results of name resolution can be preserved unless the module\n //! structure itself is modified.\n-use std::{\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n use ra_syntax::{\n     TextRange,\n-    SmolStr, SyntaxKind::{self, *},\n+    SyntaxKind::{self, *},\n     ast::{self, AstNode}\n };\n use ra_db::SourceRootId;\n@@ -32,6 +30,7 @@ use crate::{\n     SourceItemId, SourceFileItemId, SourceFileItems,\n     Path, PathKind,\n     HirDatabase, Crate,\n+    Name, AsName,\n     module::{Module, ModuleId, ModuleTree},\n };\n \n@@ -45,14 +44,14 @@ pub struct ItemMap {\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n pub struct ModuleScope {\n-    items: FxHashMap<SmolStr, Resolution>,\n+    items: FxHashMap<Name, Resolution>,\n }\n \n impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &'a Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n         self.items.iter()\n     }\n-    pub fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n+    pub fn get(&self, name: &Name) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n }\n@@ -72,7 +71,7 @@ pub struct InputModuleItems {\n #[derive(Debug, PartialEq, Eq)]\n struct ModuleItem {\n     id: SourceFileItemId,\n-    name: SmolStr,\n+    name: Name,\n     kind: SyntaxKind,\n     vis: Vis,\n }\n@@ -260,7 +259,7 @@ impl InputModuleItems {\n \n impl ModuleItem {\n     fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n-        let name = item.name()?.text();\n+        let name = item.name()?.as_name();\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n         let id = file_items.id_of_unchecked(item.syntax());\n@@ -328,7 +327,11 @@ where\n                 for dep in krate.dependencies(self.db) {\n                     if let Some(module) = dep.krate.root_module(self.db)? {\n                         let def_id = module.def_id(self.db);\n-                        self.add_module_item(&mut module_items, dep.name, PerNs::types(def_id));\n+                        self.add_module_item(\n+                            &mut module_items,\n+                            dep.name.clone(),\n+                            PerNs::types(def_id),\n+                        );\n                     }\n                 }\n             };\n@@ -389,7 +392,7 @@ where\n         Ok(())\n     }\n \n-    fn add_module_item(&self, module_items: &mut ModuleScope, name: SmolStr, def_id: PerNs<DefId>) {\n+    fn add_module_item(&self, module_items: &mut ModuleScope, name: Name, def_id: PerNs<DefId>) {\n         let resolution = Resolution {\n             def_id,\n             import: None,"}, {"sha": "ca20f064f1151c12d0dde1697e111f301255bf0d", "filename": "crates/ra_hir/src/module/nameres/tests.rs", "status": "modified", "additions": 55, "deletions": 11, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres%2Ftests.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -2,8 +2,8 @@ use std::sync::Arc;\n \n use salsa::Database;\n use ra_db::{FilesDatabase, CrateGraph};\n-use ra_syntax::SmolStr;\n use relative_path::RelativePath;\n+use test_utils::assert_eq_text;\n \n use crate::{\n     self as hir,\n@@ -21,6 +21,35 @@ fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n     (db.item_map(source_root).unwrap(), module_id)\n }\n \n+fn check_module_item_map(map: &hir::ItemMap, module_id: hir::ModuleId, expected: &str) {\n+    let mut lines = map.per_module[&module_id]\n+        .items\n+        .iter()\n+        .map(|(name, res)| format!(\"{}: {}\", name, dump_resolution(res)))\n+        .collect::<Vec<_>>();\n+    lines.sort();\n+    let actual = lines.join(\"\\n\");\n+    let expected = expected\n+        .trim()\n+        .lines()\n+        .map(|it| it.trim())\n+        .collect::<Vec<_>>()\n+        .join(\"\\n\");\n+    assert_eq_text!(&actual, &expected);\n+\n+    fn dump_resolution(resolution: &hir::Resolution) -> &'static str {\n+        match (\n+            resolution.def_id.types.is_some(),\n+            resolution.def_id.values.is_some(),\n+        ) {\n+            (true, true) => \"t v\",\n+            (true, false) => \"t\",\n+            (false, true) => \"v\",\n+            (false, false) => \"_\",\n+        }\n+    }\n+}\n+\n #[test]\n fn item_map_smoke_test() {\n     let (item_map, module_id) = item_map(\n@@ -38,13 +67,18 @@ fn item_map_smoke_test() {\n         pub struct Baz;\n     \",\n     );\n-    let name = SmolStr::from(\"Baz\");\n-    let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.take_types().is_some());\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            foo: t\n+        \",\n+    );\n }\n \n #[test]\n-fn test_self() {\n+fn item_map_using_self() {\n     let (item_map, module_id) = item_map(\n         \"\n             //- /lib.rs\n@@ -57,9 +91,14 @@ fn test_self() {\n             pub struct Baz;\n         \",\n     );\n-    let name = SmolStr::from(\"Baz\");\n-    let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.take_types().is_some());\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            foo: t\n+        \",\n+    );\n }\n \n #[test]\n@@ -90,9 +129,14 @@ fn item_map_across_crates() {\n     let module_id = module.module_id;\n     let item_map = db.item_map(source_root).unwrap();\n \n-    let name = SmolStr::from(\"Baz\");\n-    let resolution = &item_map.per_module[&module_id].items[&name];\n-    assert!(resolution.def_id.take_types().is_some());\n+    check_module_item_map(\n+        &item_map,\n+        module_id,\n+        \"\n+            Baz: t v\n+            test_crate: t\n+        \",\n+    );\n }\n \n #[test]"}, {"sha": "e4fc141a67611c366f03026d0c908ebde4439377", "filename": "crates/ra_hir/src/name.rs", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fname.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -0,0 +1,97 @@\n+use std::fmt;\n+\n+use ra_syntax::{ast, SmolStr};\n+\n+/// `Name` is a wrapper around string, which is used in hir for both references\n+/// and declarations. In theory, names should also carry hygene info, but we are\n+/// not there yet!\n+#[derive(Clone, PartialEq, Eq, Hash)]\n+pub struct Name {\n+    text: SmolStr,\n+}\n+\n+impl fmt::Display for Name {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.text, f)\n+    }\n+}\n+\n+impl fmt::Debug for Name {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.text, f)\n+    }\n+}\n+\n+impl Name {\n+    pub(crate) fn as_known_name(&self) -> Option<KnownName> {\n+        let name = match self.text.as_str() {\n+            \"isize\" => KnownName::Isize,\n+            \"i8\" => KnownName::I8,\n+            \"i16\" => KnownName::I16,\n+            \"i32\" => KnownName::I32,\n+            \"i64\" => KnownName::I64,\n+            \"i128\" => KnownName::I128,\n+            \"usize\" => KnownName::Usize,\n+            \"u8\" => KnownName::U8,\n+            \"u16\" => KnownName::U16,\n+            \"u32\" => KnownName::U32,\n+            \"u64\" => KnownName::U64,\n+            \"u128\" => KnownName::U128,\n+            \"f32\" => KnownName::F32,\n+            \"f64\" => KnownName::F64,\n+            _ => return None,\n+        };\n+        Some(name)\n+    }\n+\n+    fn new(text: SmolStr) -> Name {\n+        Name { text }\n+    }\n+}\n+\n+pub(crate) trait AsName {\n+    fn as_name(&self) -> Name;\n+}\n+\n+impl AsName for ast::NameRef<'_> {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.text())\n+    }\n+}\n+\n+impl AsName for ast::Name<'_> {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.text())\n+    }\n+}\n+\n+impl AsName for ra_db::Dependency {\n+    fn as_name(&self) -> Name {\n+        Name::new(self.name.clone())\n+    }\n+}\n+\n+// Ideally, should be replaced with\n+// ```\n+// const ISIZE: Name = Name::new(\"isize\")\n+// ```\n+// but const-fn is not that powerful yet.\n+#[derive(Debug)]\n+pub(crate) enum KnownName {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+\n+    F32,\n+    F64,\n+}"}, {"sha": "93f7203fe26587388c8392689da2d9464f62f57f", "filename": "crates/ra_hir/src/path.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -1,9 +1,11 @@\n-use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n+use ra_syntax::{ast, AstNode, TextRange};\n+\n+use crate::{Name, AsName};\n \n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct Path {\n     pub kind: PathKind,\n-    pub segments: Vec<SmolStr>,\n+    pub segments: Vec<Name>,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -29,7 +31,7 @@ impl Path {\n         loop {\n             let segment = path.segment()?;\n             match segment.kind()? {\n-                ast::PathSegmentKind::Name(name) => segments.push(name.text()),\n+                ast::PathSegmentKind::Name(name) => segments.push(name.as_name()),\n                 ast::PathSegmentKind::CrateKw => {\n                     kind = PathKind::Crate;\n                     break;\n@@ -67,6 +69,14 @@ impl Path {\n     pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n+\n+    /// If this path is a single identifier, like `foo`, return its name.\n+    pub fn as_ident(&self) -> Option<&Name> {\n+        if self.kind != PathKind::Plain || self.segments.len() > 1 {\n+            return None;\n+        }\n+        self.segments.first()\n+    }\n }\n \n fn expand_use_tree(\n@@ -130,7 +140,7 @@ fn convert_path(prefix: Option<Path>, path: ast::Path) -> Option<Path> {\n                 kind: PathKind::Plain,\n                 segments: Vec::with_capacity(1),\n             });\n-            res.segments.push(name.text());\n+            res.segments.push(name.as_name());\n             res\n         }\n         ast::PathSegmentKind::CrateKw => {"}, {"sha": "e6241342acd8c599c1608b9022c0bc5e61942491", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -11,7 +11,7 @@ use ra_syntax::{\n use ra_db::{SourceRootId, FileId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind, Function, DefId,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId, Name, AsName,\n     db::HirDatabase,\n     function::{FnScopes, FnId},\n     module::{\n@@ -130,14 +130,14 @@ pub(crate) fn submodules(\n \n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n-) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+) -> impl Iterator<Item = (Name, ast::Module<'a>)> {\n     root.items()\n         .filter_map(|item| match item {\n             ast::ModuleItem::Module(m) => Some(m),\n             _ => None,\n         })\n         .filter_map(|module| {\n-            let name = module.name()?.text();\n+            let name = module.name()?.as_name();\n             Some((name, module))\n         })\n }"}, {"sha": "a0d1daf7111352dd220ca7add60ddc21a98a291c", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -8,14 +8,14 @@\n use ra_db::{FileId, FilePosition, Cancelable};\n use ra_editor::find_node_at_offset;\n use ra_syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NameOwner},\n     SyntaxNodeRef,\n };\n \n use crate::{\n     HirDatabase, Module, Function, SourceItemId,\n     module::ModuleSource,\n-    DefKind, DefLoc\n+    DefKind, DefLoc, AsName,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -24,6 +24,25 @@ pub fn module_from_file_id(db: &impl HirDatabase, file_id: FileId) -> Cancelable\n     module_from_source(db, module_source)\n }\n \n+/// Locates the child module by `mod child;` declaration.\n+pub fn module_from_declaration(\n+    db: &impl HirDatabase,\n+    file_id: FileId,\n+    decl: ast::Module,\n+) -> Cancelable<Option<Module>> {\n+    let parent_module = module_from_file_id(db, file_id)?;\n+    let child_name = decl.name();\n+    match (parent_module, child_name) {\n+        (Some(parent_module), Some(child_name)) => {\n+            if let Some(child) = parent_module.child(&child_name.as_name()) {\n+                return Ok(Some(child));\n+            }\n+        }\n+        _ => (),\n+    }\n+    Ok(None)\n+}\n+\n /// Locates the module by position in the source code.\n pub fn module_from_position(\n     db: &impl HirDatabase,"}, {"sha": "ad097d1f139dc5f385a750a40bb4211d77d26a80", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -95,7 +95,7 @@ pub enum Ty {\n     Tuple(Vec<Ty>),\n \n     // The projection of an associated type.  For example,\n-    // `<T as Trait<..>>::N`.\n+    // `<T as Trait<..>>::N`.pub\n     // Projection(ProjectionTy),\n \n     // Opaque (`impl Trait`) type found in a return type.\n@@ -179,13 +179,12 @@ impl Ty {\n         module: &Module,\n         path: &Path,\n     ) -> Cancelable<Self> {\n-        if path.is_ident() {\n-            let name = &path.segments[0];\n-            if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n+        if let Some(name) = path.as_ident() {\n+            if let Some(int_ty) = primitive::IntTy::from_name(name) {\n                 return Ok(Ty::Int(int_ty));\n-            } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n+            } else if let Some(uint_ty) = primitive::UintTy::from_name(name) {\n                 return Ok(Ty::Uint(uint_ty));\n-            } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n+            } else if let Some(float_ty) = primitive::FloatTy::from_name(name) {\n                 return Ok(Ty::Float(float_ty));\n             }\n         }"}, {"sha": "498d42d52ed8c64a10dd3e676a5b7ff7149ed1d9", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb63a7666cc9532d97fa7e0da14b540ae8bd5df/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=efb63a7666cc9532d97fa7e0da14b540ae8bd5df", "patch": "@@ -1,5 +1,7 @@\n use std::fmt;\n \n+use crate::{Name, KnownName};\n+\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n pub enum IntTy {\n     Isize,\n@@ -34,14 +36,14 @@ impl IntTy {\n         }\n     }\n \n-    pub fn from_string(s: &str) -> Option<IntTy> {\n-        match s {\n-            \"isize\" => Some(IntTy::Isize),\n-            \"i8\" => Some(IntTy::I8),\n-            \"i16\" => Some(IntTy::I16),\n-            \"i32\" => Some(IntTy::I32),\n-            \"i64\" => Some(IntTy::I64),\n-            \"i128\" => Some(IntTy::I128),\n+    pub fn from_name(name: &Name) -> Option<IntTy> {\n+        match name.as_known_name()? {\n+            KnownName::Isize => Some(IntTy::Isize),\n+            KnownName::I8 => Some(IntTy::I8),\n+            KnownName::I16 => Some(IntTy::I16),\n+            KnownName::I32 => Some(IntTy::I32),\n+            KnownName::I64 => Some(IntTy::I64),\n+            KnownName::I128 => Some(IntTy::I128),\n             _ => None,\n         }\n     }\n@@ -69,14 +71,14 @@ impl UintTy {\n         }\n     }\n \n-    pub fn from_string(s: &str) -> Option<UintTy> {\n-        match s {\n-            \"usize\" => Some(UintTy::Usize),\n-            \"u8\" => Some(UintTy::U8),\n-            \"u16\" => Some(UintTy::U16),\n-            \"u32\" => Some(UintTy::U32),\n-            \"u64\" => Some(UintTy::U64),\n-            \"u128\" => Some(UintTy::U128),\n+    pub fn from_name(name: &Name) -> Option<UintTy> {\n+        match name.as_known_name()? {\n+            KnownName::Usize => Some(UintTy::Usize),\n+            KnownName::U8 => Some(UintTy::U8),\n+            KnownName::U16 => Some(UintTy::U16),\n+            KnownName::U32 => Some(UintTy::U32),\n+            KnownName::U64 => Some(UintTy::U64),\n+            KnownName::U128 => Some(UintTy::U128),\n             _ => None,\n         }\n     }\n@@ -120,10 +122,10 @@ impl FloatTy {\n         }\n     }\n \n-    pub fn from_string(s: &str) -> Option<FloatTy> {\n-        match s {\n-            \"f32\" => Some(FloatTy::F32),\n-            \"f64\" => Some(FloatTy::F64),\n+    pub fn from_name(name: &Name) -> Option<FloatTy> {\n+        match name.as_known_name()? {\n+            KnownName::F32 => Some(FloatTy::F32),\n+            KnownName::F64 => Some(FloatTy::F64),\n             _ => None,\n         }\n     }"}]}