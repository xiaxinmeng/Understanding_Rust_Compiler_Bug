{"sha": "9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZDNiOTQ4NDdkYjhjYmVlMjc5NDdkN2Q2MmE2YWRkMjhhOWMwZTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-17T20:26:48Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-04-20T11:39:31Z"}, "message": "rustc: replace TypeContents::needs_drop with Ty::may_drop.", "tree": {"sha": "b4e856bea6e2c8e1fb450f1f833956debcafc46d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4e856bea6e2c8e1fb450f1f833956debcafc46d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "html_url": "https://github.com/rust-lang/rust/commit/9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6563374ed2e518ea5fec2b7411dc4331772c46d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/6563374ed2e518ea5fec2b7411dc4331772c46d2", "html_url": "https://github.com/rust-lang/rust/commit/6563374ed2e518ea5fec2b7411dc4331772c46d2"}], "stats": {"total": 241, "additions": 87, "deletions": 154}, "files": [{"sha": "a1cb848213a8f5043f973f5f07f6e8ff57e94b30", "filename": "src/librustc/ty/contents.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/6563374ed2e518ea5fec2b7411dc4331772c46d2/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6563374ed2e518ea5fec2b7411dc4331772c46d2/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=6563374ed2e518ea5fec2b7411dc4331772c46d2", "patch": "@@ -1,139 +0,0 @@\n-// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use ty::{self, Ty, TyCtxt};\n-use util::common::MemoizationMap;\n-use util::nodemap::FxHashMap;\n-\n-bitflags! {\n-    /// Type contents is how the type checker reasons about kinds.\n-    /// They track what kinds of things are found within a type.  You can\n-    /// think of them as kind of an \"anti-kind\".  They track the kinds of values\n-    /// and thinks that are contained in types.  Having a larger contents for\n-    /// a type tends to rule that type *out* from various kinds.  For example,\n-    /// a type that contains a reference is not sendable.\n-    ///\n-    /// The reason we compute type contents and not kinds is that it is\n-    /// easier for me (nmatsakis) to think about what is contained within\n-    /// a type than to think about what is *not* contained within a type.\n-    flags TypeContents: u8 {\n-        const OWNS_DTOR         = 0b1,\n-    }\n-}\n-\n-impl TypeContents {\n-    pub fn when(&self, cond: bool) -> TypeContents {\n-        if cond {*self} else {TypeContents::empty()}\n-    }\n-\n-    pub fn needs_drop(&self, _: TyCtxt) -> bool {\n-        self.intersects(TypeContents::OWNS_DTOR)\n-    }\n-\n-    pub fn union<I, T, F>(v: I, mut f: F) -> TypeContents where\n-        I: IntoIterator<Item=T>,\n-        F: FnMut(T) -> TypeContents,\n-    {\n-        v.into_iter().fold(TypeContents::empty(), |tc, ty| tc | f(ty))\n-    }\n-}\n-\n-impl<'a, 'tcx> ty::TyS<'tcx> {\n-    pub fn type_contents(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> TypeContents {\n-        return tcx.tc_cache.memoize(self, || tc_ty(tcx, self, &mut FxHashMap()));\n-\n-        fn tc_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                           ty: Ty<'tcx>,\n-                           cache: &mut FxHashMap<Ty<'tcx>, TypeContents>) -> TypeContents\n-        {\n-            // Subtle: Note that we are *not* using tcx.tc_cache here but rather a\n-            // private cache for this walk.  This is needed in the case of cyclic\n-            // types like:\n-            //\n-            //     struct List { next: Box<Option<List>>, ... }\n-            //\n-            // When computing the type contents of such a type, we wind up deeply\n-            // recursing as we go.  So when we encounter the recursive reference\n-            // to List, we temporarily use TypeContents::empty() as its contents.  Later we'll\n-            // patch up the cache with the correct value, once we've computed it\n-            // (this is basically a co-inductive process, if that helps).  So in\n-            // the end we'll compute TypeContents::OwnsOwned, in this case.\n-            //\n-            // The problem is, as we are doing the computation, we will also\n-            // compute an *intermediate* contents for, e.g., Option<List> of\n-            // TypeContents::empty().  This is ok during the computation of List itself, but if\n-            // we stored this intermediate value into tcx.tc_cache, then later\n-            // requests for the contents of Option<List> would also yield TypeContents::empty()\n-            // which is incorrect.  This value was computed based on the crutch\n-            // value for the type contents of list.  The correct value is\n-            // TypeContents::OwnsOwned.  This manifested as issue #4821.\n-            if let Some(tc) = cache.get(&ty) {\n-                return *tc;\n-            }\n-            // Must check both caches!\n-            if let Some(tc) = tcx.tc_cache.borrow().get(&ty) {\n-                return *tc;\n-            }\n-            cache.insert(ty, TypeContents::empty());\n-\n-            let result = match ty.sty {\n-                ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n-                ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n-                ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n-                ty::TyRawPtr(_) | ty::TyRef(..) |\n-                ty::TyStr => TypeContents::empty(),\n-\n-                ty::TyArray(ty, _) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-\n-                ty::TySlice(ty) => {\n-                    tc_ty(tcx, ty, cache)\n-                }\n-\n-                ty::TyClosure(def_id, ref substs) => {\n-                    TypeContents::union(\n-                        substs.upvar_tys(def_id, tcx),\n-                        |ty| tc_ty(tcx, &ty, cache))\n-                }\n-\n-                ty::TyTuple(ref tys, _) => {\n-                    TypeContents::union(&tys[..],\n-                                        |ty| tc_ty(tcx, *ty, cache))\n-                }\n-\n-                ty::TyAdt(def, substs) => {\n-                    TypeContents::union(&def.variants, |v| {\n-                        TypeContents::union(&v.fields, |f| {\n-                            tc_ty(tcx, f.ty(tcx, substs), cache)\n-                        })\n-                    })\n-\n-                    // unions don't have destructors regardless of the child types\n-                        - TypeContents::OWNS_DTOR.when(def.is_union())\n-                        | TypeContents::OWNS_DTOR.when(def.has_dtor(tcx))\n-                }\n-\n-                ty::TyDynamic(..) |\n-                ty::TyProjection(..) |\n-                ty::TyParam(_) |\n-                ty::TyAnon(..) => TypeContents::OWNS_DTOR,\n-\n-                ty::TyInfer(_) |\n-                ty::TyError => {\n-                    bug!(\"asked to compute contents of error type\");\n-                }\n-            };\n-\n-            cache.insert(ty, result);\n-            result\n-        }\n-    }\n-}"}, {"sha": "a41629258716d51dc991639bc4654c129daaa48e", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "patch": "@@ -436,9 +436,6 @@ pub struct GlobalCtxt<'tcx> {\n     // Internal cache for metadata decoding. No need to track deps on this.\n     pub rcache: RefCell<FxHashMap<ty::CReaderCacheKey, Ty<'tcx>>>,\n \n-    // Cache for the type-contents routine. FIXME -- track deps?\n-    pub tc_cache: RefCell<FxHashMap<Ty<'tcx>, ty::contents::TypeContents>>,\n-\n     // FIXME dep tracking -- should be harmless enough\n     pub normalized_cache: RefCell<FxHashMap<Ty<'tcx>, Ty<'tcx>>>,\n \n@@ -708,7 +705,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             freevars: RefCell::new(resolutions.freevars),\n             maybe_unused_trait_imports: resolutions.maybe_unused_trait_imports,\n             rcache: RefCell::new(FxHashMap()),\n-            tc_cache: RefCell::new(FxHashMap()),\n             normalized_cache: RefCell::new(FxHashMap()),\n             inhabitedness_cache: RefCell::new(FxHashMap()),\n             lang_items: lang_items,"}, {"sha": "b6e47568ff4dbfa927f787c33cf454a0226d5c58", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "patch": "@@ -71,7 +71,6 @@ pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n-pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, GlobalArenas, tls};\n pub use self::context::{Lift, TypeckTables};\n \n@@ -99,7 +98,6 @@ pub mod walk;\n pub mod wf;\n pub mod util;\n \n-mod contents;\n mod context;\n mod flags;\n mod instance;\n@@ -427,6 +425,8 @@ bitflags! {\n         const MOVES_BY_DEFAULT  = 1 << 19,\n         const FREEZENESS_CACHED = 1 << 20,\n         const IS_FREEZE         = 1 << 21,\n+        const MAY_DROP_CACHED   = 1 << 22,\n+        const MAY_DROP          = 1 << 23,\n     }\n }\n \n@@ -2400,19 +2400,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if implements_copy { return false; }\n \n         // ... (issue #22536 continued) but as an optimization, still use\n-        // prior logic of asking if the `needs_drop` bit is set; we need\n-        // not zero non-Copy types if they have no destructor.\n+        // prior logic of asking for the structural `may_drop`.\n \n-        // FIXME(#22815): Note that calling `ty::type_contents` is a\n-        // conservative heuristic; it may report that `needs_drop` is set\n+        // FIXME(#22815): Note that calling `ty::may_drop` is a\n+        // conservative heuristic; it may report `true` (\"may drop\")\n         // when actual type does not actually have a destructor associated\n         // with it. But since `ty` absolutely did not have the `Copy`\n         // bound attached (see above), it is sound to treat it as having a\n-        // destructor (e.g. zero its memory on move).\n+        // destructor.\n \n-        let contents = ty.type_contents(tcx);\n-        debug!(\"type_needs_drop ty={:?} contents={:?}\", ty, contents.bits());\n-        contents.needs_drop(tcx)\n+        let may_drop = ty.may_drop(tcx);\n+        debug!(\"type_needs_drop ty={:?} may_drop={:?}\", ty, may_drop);\n+        may_drop\n     }\n \n     /// Get the attributes of a definition."}, {"sha": "a3d2518909d749e6e0e44432eae71f36f04015d4", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 78, "deletions": 1, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ad3b94847db8cbee27947d7d62a6add28a9c0e9/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=9ad3b94847db8cbee27947d7d62a6add28a9c0e9", "patch": "@@ -21,7 +21,7 @@ use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::common::ErrorReported;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{FxHashMap, FxHashSet};\n use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n@@ -699,6 +699,83 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         result\n     }\n \n+    #[inline]\n+    pub fn may_drop(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        if self.flags.get().intersects(TypeFlags::MAY_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::MAY_DROP);\n+        }\n+\n+        self.may_drop_inner(tcx, &mut FxHashSet())\n+    }\n+\n+    fn may_drop_inner(&'tcx self,\n+                      tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                      visited: &mut FxHashSet<Ty<'tcx>>)\n+                      -> bool {\n+        if self.flags.get().intersects(TypeFlags::MAY_DROP_CACHED) {\n+            return self.flags.get().intersects(TypeFlags::MAY_DROP);\n+        }\n+\n+        // This should be reported as an error by `check_representable`.\n+        //\n+        // Consider the type as not needing drop in the meanwhile to avoid\n+        // further errors.\n+        if visited.replace(self).is_some() {\n+            return false;\n+        }\n+\n+        assert!(!self.needs_infer());\n+\n+        let result = match self.sty {\n+            // Fast-path for primitive types\n+            ty::TyInfer(ty::FreshIntTy(_)) | ty::TyInfer(ty::FreshFloatTy(_)) |\n+            ty::TyBool | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) | ty::TyNever |\n+            ty::TyFnDef(..) | ty::TyFnPtr(_) | ty::TyChar |\n+            ty::TyRawPtr(_) | ty::TyRef(..) | ty::TyStr => false,\n+\n+            // User destructors are the only way to have concrete drop types.\n+            ty::TyAdt(def, _) if def.has_dtor(tcx) => true,\n+\n+            // Can refer to a type which may drop.\n+            // FIXME(eddyb) check this against a ParameterEnvironment.\n+            ty::TyDynamic(..) | ty::TyProjection(..) | ty::TyParam(_) |\n+            ty::TyAnon(..) | ty::TyInfer(_) | ty::TyError => true,\n+\n+            // Structural recursion.\n+            ty::TyArray(ty, _) | ty::TySlice(ty) => {\n+                ty.may_drop_inner(tcx, visited)\n+            }\n+\n+            ty::TyClosure(def_id, ref substs) => {\n+                substs.upvar_tys(def_id, tcx)\n+                    .any(|ty| ty.may_drop_inner(tcx, visited))\n+            }\n+\n+            ty::TyTuple(ref tys, _) => {\n+                tys.iter().any(|ty| ty.may_drop_inner(tcx, visited))\n+            }\n+\n+            // unions don't have destructors regardless of the child types\n+            ty::TyAdt(def, _) if def.is_union() => false,\n+\n+            ty::TyAdt(def, substs) => {\n+                def.variants.iter().any(|v| {\n+                    v.fields.iter().any(|f| {\n+                        f.ty(tcx, substs).may_drop_inner(tcx, visited)\n+                    })\n+                })\n+            }\n+        };\n+\n+        self.flags.set(self.flags.get() | if result {\n+            TypeFlags::MAY_DROP_CACHED | TypeFlags::MAY_DROP\n+        } else {\n+            TypeFlags::MAY_DROP_CACHED\n+        });\n+\n+        result\n+    }\n+\n     #[inline]\n     pub fn layout<'lcx>(&'tcx self, infcx: &InferCtxt<'a, 'tcx, 'lcx>)\n                         -> Result<&'tcx Layout, LayoutError<'tcx>> {"}]}