{"sha": "47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZWNhMjExM2M1YzU1YTRmZmJiOGMxMWEzOGM4Y2E3YTc5YTFkNzI=", "commit": {"author": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-06T04:57:11Z"}, "committer": {"name": "James Miller", "email": "bladeon@gmail.com", "date": "2013-07-07T10:51:10Z"}, "message": "De-share ast::Ty", "tree": {"sha": "264e2191016cfc1b83d7a79169a3f6bc19706c1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/264e2191016cfc1b83d7a79169a3f6bc19706c1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "html_url": "https://github.com/rust-lang/rust/commit/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/comments", "author": null, "committer": null, "parents": [{"sha": "46a1f54666dbeb9a926c75b380f62571963cbacc", "url": "https://api.github.com/repos/rust-lang/rust/commits/46a1f54666dbeb9a926c75b380f62571963cbacc", "html_url": "https://github.com/rust-lang/rust/commit/46a1f54666dbeb9a926c75b380f62571963cbacc"}], "stats": {"total": 511, "additions": 256, "deletions": 255}, "files": [{"sha": "df829d5e2096132416b390d52f19201fa4a2da4f", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -98,10 +98,10 @@ fn fold_foreign_mod(\n fn fold_item_underscore(cx: @Context, item: &ast::item_,\n                         fld: @fold::ast_fold) -> ast::item_ {\n     let item = match *item {\n-        ast::item_impl(ref a, ref b, c, ref methods) => {\n+        ast::item_impl(ref a, ref b, ref c, ref methods) => {\n             let methods = methods.iter().filter(|m| method_in_cfg(cx, **m))\n                 .transform(|x| *x).collect();\n-            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, c, methods)\n+            ast::item_impl(/*bad*/ copy *a, /*bad*/ copy *b, /*bad*/ copy *c, methods)\n         }\n         ast::item_trait(ref a, ref b, ref methods) => {\n             let methods = methods.iter().filter(|m| trait_method_in_cfg(cx, *m) )"}, {"sha": "a9f3200af1284882f15075416ad13637e849937d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -1003,7 +1003,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                         index);\n         }\n       }\n-      item_impl(ref generics, ref opt_trait, ty, ref methods) => {\n+      item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));"}, {"sha": "335a54a97535370deb9b5a1c9be7e979914b0123", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -117,7 +117,7 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n     // If this is a destructor, check kinds.\n     if !attrs_contains_name(item.attrs, \"unsafe_destructor\") {\n         match item.node {\n-            item_impl(_, Some(ref trait_ref), self_type, _) => {\n+            item_impl(_, Some(ref trait_ref), ref self_type, _) => {\n                 match cx.tcx.def_map.find(&trait_ref.ref_id) {\n                     None => cx.tcx.sess.bug(\"trait ref not in def map!\"),\n                     Some(&trait_def) => {\n@@ -321,7 +321,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n     visit::visit_expr(e, (cx, v));\n }\n \n-fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n+fn check_ty(aty: &Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n       ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);"}, {"sha": "0dce9c69bfdbe2fe5a515c09190a558fcbc3af92", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -747,9 +747,9 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n \n     fn check_foreign_fn(cx: &Context, decl: &ast::fn_decl) {\n         for decl.inputs.iter().advance |in| {\n-            check_ty(cx, in.ty);\n+            check_ty(cx, &in.ty);\n         }\n-        check_ty(cx, decl.output)\n+        check_ty(cx, &decl.output)\n     }\n \n     match it.node {\n@@ -759,7 +759,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                 ast::foreign_item_fn(ref decl, _, _) => {\n                     check_foreign_fn(cx, decl);\n                 }\n-                ast::foreign_item_static(t, _) => { check_ty(cx, t); }\n+                ast::foreign_item_static(ref t, _) => { check_ty(cx, t); }\n             }\n         }\n       }"}, {"sha": "b1b2a0083acc364e5550dd0e99a3c3c3d56f8eb5", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -713,10 +713,10 @@ fn determine_rp_in_fn(fk: &visit::fn_kind,\n     do cx.with(cx.item_id, false) {\n         do cx.with_ambient_variance(rv_contravariant) {\n             for decl.inputs.iter().advance |a| {\n-                (visitor.visit_ty)(a.ty, (cx, visitor));\n+                (visitor.visit_ty)(&a.ty, (cx, visitor));\n             }\n         }\n-        (visitor.visit_ty)(decl.output, (cx, visitor));\n+        (visitor.visit_ty)(&decl.output, (cx, visitor));\n         let generics = visit::generics_of_fn(fk);\n         (visitor.visit_generics)(&generics, (cx, visitor));\n         (visitor.visit_block)(body, (cx, visitor));\n@@ -731,7 +731,7 @@ fn determine_rp_in_ty_method(ty_m: &ast::ty_method,\n     }\n }\n \n-fn determine_rp_in_ty(ty: @ast::Ty,\n+fn determine_rp_in_ty(ty: &ast::Ty,\n                       (cx, visitor): (@mut DetermineRpCtxt,\n                                       visit::vt<@mut DetermineRpCtxt>)) {\n     // we are only interested in types that will require an item to\n@@ -815,16 +815,16 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     }\n \n     match ty.node {\n-      ast::ty_box(mt) | ast::ty_uniq(mt) | ast::ty_vec(mt) |\n-      ast::ty_rptr(_, mt) | ast::ty_ptr(mt) => {\n+      ast::ty_box(ref mt) | ast::ty_uniq(ref mt) | ast::ty_vec(ref mt) |\n+      ast::ty_rptr(_, ref mt) | ast::ty_ptr(ref mt) => {\n         visit_mt(mt, (cx, visitor));\n       }\n \n       ast::ty_path(ref path, _, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {\n-                (visitor.visit_ty)(*tp, (cx, visitor));\n+                (visitor.visit_ty)(tp, (cx, visitor));\n             }\n         }\n       }\n@@ -837,10 +837,10 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n             // parameters are contravariant\n             do cx.with_ambient_variance(rv_contravariant) {\n                 for decl.inputs.iter().advance |a| {\n-                    (visitor.visit_ty)(a.ty, (cx, visitor));\n+                    (visitor.visit_ty)(&a.ty, (cx, visitor));\n                 }\n             }\n-            (visitor.visit_ty)(decl.output, (cx, visitor));\n+            (visitor.visit_ty)(&decl.output, (cx, visitor));\n         }\n       }\n \n@@ -849,7 +849,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n       }\n     }\n \n-    fn visit_mt(mt: ast::mt,\n+    fn visit_mt(mt: &ast::mt,\n                 (cx, visitor): (@mut DetermineRpCtxt,\n                                 visit::vt<@mut DetermineRpCtxt>)) {\n         // mutability is invariant"}, {"sha": "861c61e497aa815e018e0e84d1c6a423174d11a9", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -1233,7 +1233,7 @@ impl Resolver {\n                 visit_item(item, (new_parent, visitor));\n             }\n \n-            item_impl(_, None, ty, ref methods) => {\n+            item_impl(_, None, ref ty, ref methods) => {\n                 // If this implements an anonymous trait, then add all the\n                 // methods within to a new module, if the type was defined\n                 // within this module.\n@@ -1243,8 +1243,8 @@ impl Resolver {\n                 // the same module that declared the type.\n \n                 // Create the module and add all methods.\n-                match *ty {\n-                    Ty {\n+                match ty {\n+                    &Ty {\n                         node: ty_path(ref path, _, _),\n                         _\n                     } if path.idents.len() == 1 => {\n@@ -1313,7 +1313,7 @@ impl Resolver {\n                 visit_item(item, (parent, visitor));\n             }\n \n-            item_impl(_, Some(_), _ty, ref _methods) => {\n+            item_impl(_, Some(_), _, _) => {\n                 visit_item(item, (parent, visitor));\n             }\n \n@@ -3534,7 +3534,7 @@ impl Resolver {\n \n             item_impl(ref generics,\n                       ref implemented_traits,\n-                      self_type,\n+                      ref self_type,\n                       ref methods) => {\n                 self.resolve_implementation(item.id,\n                                             generics,\n@@ -3585,10 +3585,10 @@ impl Resolver {\n                                     visitor);\n \n                                 for ty_m.decl.inputs.iter().advance |argument| {\n-                                    self.resolve_type(argument.ty, visitor);\n+                                    self.resolve_type(&argument.ty, visitor);\n                                 }\n \n-                                self.resolve_type(ty_m.decl.output, visitor);\n+                                self.resolve_type(&ty_m.decl.output, visitor);\n                             }\n                           }\n                           provided(m) => {\n@@ -3778,12 +3778,12 @@ impl Resolver {\n                                              None,\n                                              visitor);\n \n-                        self.resolve_type(argument.ty, visitor);\n+                        self.resolve_type(&argument.ty, visitor);\n \n                         debug!(\"(resolving function) recorded argument\");\n                     }\n \n-                    self.resolve_type(declaration.output, visitor);\n+                    self.resolve_type(&declaration.output, visitor);\n                 }\n             }\n \n@@ -3878,7 +3878,7 @@ impl Resolver {\n \n             // Resolve fields.\n             for fields.iter().advance |field| {\n-                self.resolve_type(field.node.ty, visitor);\n+                self.resolve_type(&field.node.ty, visitor);\n             }\n         }\n     }\n@@ -3914,7 +3914,7 @@ impl Resolver {\n                                   id: node_id,\n                                   generics: &Generics,\n                                   opt_trait_reference: &Option<trait_ref>,\n-                                  self_type: @Ty,\n+                                  self_type: &Ty,\n                                   methods: &[@method],\n                                   visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n@@ -4001,7 +4001,7 @@ impl Resolver {\n         let mutability = if local.node.is_mutbl {Mutable} else {Immutable};\n \n         // Resolve the type.\n-        self.resolve_type(local.node.ty, visitor);\n+        self.resolve_type(&local.node.ty, visitor);\n \n         // Resolve the initializer, if necessary.\n         match local.node.init {\n@@ -4112,7 +4112,7 @@ impl Resolver {\n         debug!(\"(resolving block) leaving block\");\n     }\n \n-    pub fn resolve_type(@mut self, ty: @Ty, visitor: ResolveVisitor) {\n+    pub fn resolve_type(@mut self, ty: &Ty, visitor: ResolveVisitor) {\n         match ty.node {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n@@ -4334,7 +4334,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n@@ -4367,7 +4367,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n@@ -4396,7 +4396,7 @@ impl Resolver {\n \n                     // Check the types in the path pattern.\n                     for path.types.iter().advance |ty| {\n-                        self.resolve_type(*ty, visitor);\n+                        self.resolve_type(ty, visitor);\n                     }\n                 }\n \n@@ -4491,7 +4491,7 @@ impl Resolver {\n                         -> Option<def> {\n         // First, resolve the types.\n         for path.types.iter().advance |ty| {\n-            self.resolve_type(*ty, visitor);\n+            self.resolve_type(ty, visitor);\n         }\n \n         if path.global {"}, {"sha": "e6384ae4d0d3428aad15c2bcb19c8b9b4418bbec", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -1737,7 +1737,7 @@ pub fn copy_args_to_allocas(fcx: fn_ctxt,\n         fcx.llargs.insert(arg_id, llarg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo && fcx_has_nonzero_span(fcx) {\n-            debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n+            debuginfo::create_arg(bcx, &args[arg_n], args[arg_n].ty.span);\n         }\n     }\n \n@@ -1911,7 +1911,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n     let fn_args = do args.map |varg| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: varg.ty,\n+            ty: copy varg.ty,\n             pat: ast_util::ident_to_pat(\n                 ccx.tcx.sess.next_node_id(),\n                 codemap::dummy_sp(),\n@@ -1985,7 +1985,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n     let fn_args = do fields.map |field| {\n         ast::arg {\n             is_mutbl: false,\n-            ty: field.node.ty,\n+            ty: copy field.node.ty,\n             pat: ast_util::ident_to_pat(ccx.tcx.sess.next_node_id(),\n                                         codemap::dummy_sp(),\n                                         special_idents::arg),"}, {"sha": "fc73d80537987ef04d154edb7f1f07a976f9e5d7", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -182,7 +182,7 @@ pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n /// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_arg(bcx: block, arg: ast::arg, span: span) -> Option<DIVariable> {\n+pub fn create_arg(bcx: block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n     debug!(\"create_arg\");\n     if true {\n         // XXX create_arg disabled for now because \"node_id_type(bcx, arg.id)\" below blows\n@@ -259,23 +259,25 @@ pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n     let fcx = &mut *fcx;\n     let span = fcx.span.get();\n \n-    let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n-      ast_map::node_item(item, _) => {\n+    let fnitem = cx.tcx.items.get_copy(&fcx.id);\n+    let (ident, ret_ty, id) = match fnitem {\n+      ast_map::node_item(ref item, _) => {\n         match item.node {\n-          ast::item_fn(ref decl, _, _, _, _) => {\n-            (item.ident, decl.output, item.id)\n+          ast::item_fn(ast::fn_decl { output: ref ty, _}, _, _, _, _) => {\n+            (item.ident, ty, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, \"create_function: item bound to non-function\")\n         }\n       }\n-      ast_map::node_method(method, _, _) => {\n-          (method.ident, method.decl.output, method.id)\n+      ast_map::node_method(@ast::method { decl: ast::fn_decl { output: ref ty, _ },\n+                           id: id, ident: ident, _}, _, _) => {\n+          (ident, ty, id)\n       }\n-      ast_map::node_expr(expr) => {\n+      ast_map::node_expr(ref expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n             let name = gensym_name(\"fn\");\n-            (name, decl.output, expr.id)\n+            (name, &decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n                   \"create_function: expected an expr_fn_block here\")"}, {"sha": "9442eb0b83869b427be2a8b17b322629d9d8c40f", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -179,7 +179,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + 'static>(\n             fmt!(\"wrong number of type arguments: expected %u but found %u\",\n                  decl_generics.type_param_defs.len(), path.types.len()));\n     }\n-    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, *a_t));\n+    let tps = path.types.map(|a_t| ast_ty_to_ty(this, rscope, a_t));\n \n     substs {self_r:self_r, self_ty:self_ty, tps:tps}\n }\n@@ -377,7 +377,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                    |tmt| ty::mk_rptr(tcx, r, tmt))\n       }\n       ast::ty_tup(ref fields) => {\n-        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, *t));\n+        let flds = fields.map(|t| ast_ty_to_ty(this, rscope, t));\n         ty::mk_tup(tcx, flds)\n       }\n       ast::ty_bare_fn(ref bf) => {\n@@ -525,13 +525,13 @@ pub fn ty_of_arg<AC:AstConv,\n                  RS:region_scope + Copy + 'static>(\n                  this: &AC,\n                  rscope: &RS,\n-                 a: ast::arg,\n+                 a: &ast::arg,\n                  expected_ty: Option<ty::t>)\n                  -> ty::t {\n     match a.ty.node {\n         ast::ty_infer if expected_ty.is_some() => expected_ty.get(),\n         ast::ty_infer => this.ty_infer(a.ty.span),\n-        _ => ast_ty_to_ty(this, rscope, a.ty),\n+        _ => ast_ty_to_ty(this, rscope, &a.ty),\n     }\n }\n \n@@ -621,11 +621,11 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:region_scope + Copy + 'static>(\n         transform_self_ty(this, &rb, self_info)\n     });\n \n-    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, *a, None));\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(this, &rb, a, None));\n \n     let output_ty = match decl.output.node {\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     return (opt_transformed_self_ty,\n@@ -724,14 +724,14 @@ pub fn ty_of_closure<AC:AstConv,RS:region_scope + Copy + 'static>(\n             // were supplied\n             if i < e.inputs.len() {Some(e.inputs[i])} else {None}\n         };\n-        ty_of_arg(this, &rb, *a, expected_arg_ty)\n+        ty_of_arg(this, &rb, a, expected_arg_ty)\n     }.collect();\n \n     let expected_ret_ty = expected_sig.map(|e| e.output);\n     let output_ty = match decl.output.node {\n         ast::ty_infer if expected_ret_ty.is_some() => expected_ret_ty.get(),\n         ast::ty_infer => this.ty_infer(decl.output.span),\n-        _ => ast_ty_to_ty(this, &rb, decl.output)\n+        _ => ast_ty_to_ty(this, &rb, &decl.output)\n     };\n \n     ty::ClosureTy {"}, {"sha": "51159c0391a1c1f852580bf616d68170b50480cd", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -476,7 +476,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 |local, (e, v)| {\n             let o_ty = match local.node.ty.node {\n               ast::ty_infer => None,\n-              _ => Some(fcx.to_ty(local.node.ty))\n+              _ => Some(fcx.to_ty(&local.node.ty))\n             };\n             assign(local.node.id, o_ty);\n             debug!(\"Local variable %s is assigned type %s\",\n@@ -624,7 +624,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_struct(*) => {\n         check_struct(ccx, it.id, it.span);\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         let tpt_ty = ty::node_id_to_type(ccx.tcx, it.id);\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n@@ -790,7 +790,7 @@ impl FnCtxt {\n         self.write_ty(node_id, ty::mk_err());\n     }\n \n-    pub fn to_ty(&self, ast_t: @ast::Ty) -> ty::t {\n+    pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n@@ -1381,7 +1381,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                          rcvr: @ast::expr,\n                          method_name: ast::ident,\n                          args: &[@ast::expr],\n-                         tps: &[@ast::Ty],\n+                         tps: &[ast::Ty],\n                          sugar: ast::CallSugar) {\n         check_expr(fcx, rcvr);\n \n@@ -1390,7 +1390,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                                 expr.span,\n                                                 fcx.expr_ty(rcvr));\n \n-        let tps = tps.map(|ast_ty| fcx.to_ty(*ast_ty));\n+        let tps = tps.map(|ast_ty| fcx.to_ty(ast_ty));\n         match method::lookup(fcx,\n                              expr,\n                              rcvr,\n@@ -1779,7 +1779,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    expr: @ast::expr,\n                    base: @ast::expr,\n                    field: ast::ident,\n-                   tys: &[@ast::Ty]) {\n+                   tys: &[ast::Ty]) {\n         let tcx = fcx.ccx.tcx;\n         let bot = check_expr(fcx, base);\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n@@ -1809,7 +1809,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => ()\n         }\n \n-        let tps = tys.iter().transform(|ty| fcx.to_ty(*ty)).collect::<~[ty::t]>();\n+        let tps : ~[ty::t] = tys.iter().transform(|ty| fcx.to_ty(ty)).collect();\n         match method::lookup(fcx,\n                              expr,\n                              base,\n@@ -2622,7 +2622,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_bot(id);\n         }\n       }\n-      ast::expr_cast(e, t) => {\n+      ast::expr_cast(e, ref t) => {\n         check_expr(fcx, e);\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n@@ -3336,7 +3336,7 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n             (span, \"not enough type parameters provided for this item\");\n         fcx.infcx().next_ty_vars(ty_param_count)\n     } else {\n-        pth.types.map(|aty| fcx.to_ty(*aty))\n+        pth.types.map(|aty| fcx.to_ty(aty))\n     };\n \n     let substs = substs { self_r: self_r, self_ty: None, tps: tps };"}, {"sha": "473d5b8e6e8804e3375f12d862635dc143a96006", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -638,7 +638,7 @@ impl CoherenceChecker {\n                         // Then visit the module items.\n                         visit_mod(module_, item.span, item.id, ((), visitor));\n                     }\n-                    item_impl(_, None, ast_ty, _) => {\n+                    item_impl(_, None, ref ast_ty, _) => {\n                         if !self.ast_type_is_defined_in_local_crate(ast_ty) {\n                             // This is an error.\n                             let session = self.crate_context.tcx.sess;\n@@ -725,7 +725,7 @@ impl CoherenceChecker {\n     /// For coherence, when we have `impl Type`, we need to guarantee that\n     /// `Type` is \"local\" to the crate. For our purposes, this means that it\n     /// must precisely name some nominal type defined in this crate.\n-    pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n+    pub fn ast_type_is_defined_in_local_crate(&self, original_type: &ast::Ty)\n                                               -> bool {\n         match original_type.node {\n             ty_path(_, _, path_id) => {"}, {"sha": "fb88f198231f807203e3c50be8ba832a8cc605b5", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -148,7 +148,7 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n                 let rs = type_rscope(region_parameterization);\n-                let input_tys = args.map(|va| ccx.to_ty(&rs, va.ty));\n+                let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n                 result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n             }\n \n@@ -684,7 +684,7 @@ pub fn convert_field(ccx: &CrateCtxt,\n                      generics: &ast::Generics) {\n     let region_parameterization =\n         RegionParameterization::from_variance_and_generics(rp, generics);\n-    let tt = ccx.to_ty(&type_rscope(region_parameterization), v.node.ty);\n+    let tt = ccx.to_ty(&type_rscope(region_parameterization), &v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n@@ -813,7 +813,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n                                generics,\n                                rp);\n       }\n-      ast::item_impl(ref generics, ref opt_trait_ref, selfty, ref ms) => {\n+      ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n         let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n         let region_parameterization =\n             RegionParameterization::from_variance_and_generics(rp, generics);\n@@ -1031,7 +1031,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n     }\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     match it.node {\n-      ast::item_static(t, _, _) => {\n+      ast::item_static(ref t, _, _) => {\n         let typ = ccx.to_ty(&empty_rscope, t);\n         let tpt = no_params(typ);\n         tcx.tcache.insert(local_def(it.id), tpt);\n@@ -1060,7 +1060,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_ty(t, ref generics) => {\n+      ast::item_ty(ref t, ref generics) => {\n         match tcx.tcache.find(&local_def(it.id)) {\n           Some(&tpt) => return tpt,\n           None => { }\n@@ -1124,7 +1124,7 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n                                   generics,\n                                   abis)\n         }\n-        ast::foreign_item_static(t, _) => {\n+        ast::foreign_item_static(ref t, _) => {\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n@@ -1215,8 +1215,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n     let region_param_names = RegionParamNames::from_generics(ast_generics);\n     let rb = in_binding_rscope(&empty_rscope, region_param_names);\n-    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, *a, None) );\n-    let output_ty = ast_ty_to_ty(ccx, &rb, decl.output);\n+    let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n+    let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n \n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,"}, {"sha": "8c37c1510cf20974d6543ce87a9335c961ca4c3d", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -110,7 +110,7 @@ pub struct Path {\n     global: bool,\n     idents: ~[ident],\n     rp: Option<Lifetime>,\n-    types: ~[@Ty],\n+    types: ~[Ty],\n }\n \n pub type crate_num = int;\n@@ -361,7 +361,7 @@ pub enum stmt_ {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct local_ {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     init: Option<@expr>,\n     id: node_id,\n@@ -429,12 +429,12 @@ pub enum expr_ {\n     expr_vstore(@expr, expr_vstore),\n     expr_vec(~[@expr], mutability),\n     expr_call(@expr, ~[@expr], CallSugar),\n-    expr_method_call(node_id, @expr, ident, ~[@Ty], ~[@expr], CallSugar),\n+    expr_method_call(node_id, @expr, ident, ~[Ty], ~[@expr], CallSugar),\n     expr_tup(~[@expr]),\n     expr_binary(node_id, binop, @expr, @expr),\n     expr_unary(node_id, unop, @expr),\n     expr_lit(@lit),\n-    expr_cast(@expr, @Ty),\n+    expr_cast(@expr, Ty),\n     expr_if(@expr, blk, Option<@expr>),\n     expr_while(@expr, blk),\n     /* Conditionless loop (can be exited with break, cont, or ret)\n@@ -454,7 +454,7 @@ pub enum expr_ {\n     expr_copy(@expr),\n     expr_assign(@expr, @expr),\n     expr_assign_op(node_id, binop, @expr, @expr),\n-    expr_field(@expr, ident, ~[@Ty]),\n+    expr_field(@expr, ident, ~[Ty]),\n     expr_index(node_id, @expr, @expr),\n     expr_path(Path),\n \n@@ -604,7 +604,7 @@ pub enum lit_ {\n // type structure in middle/ty.rs as well.\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct mt {\n-    ty: @Ty,\n+    ty: ~Ty,\n     mutbl: mutability,\n }\n \n@@ -733,7 +733,7 @@ pub enum ty_ {\n     ty_rptr(Option<Lifetime>, mt),\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n-    ty_tup(~[@Ty]),\n+    ty_tup(~[Ty]),\n     ty_path(Path, Option<OptVec<TyParamBound>>, node_id), // for #7264; see above\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n@@ -762,15 +762,15 @@ pub struct inline_asm {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct arg {\n     is_mutbl: bool,\n-    ty: @Ty,\n+    ty: Ty,\n     pat: @pat,\n     id: node_id,\n }\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct fn_decl {\n     inputs: ~[arg],\n-    output: @Ty,\n+    output: Ty,\n     cf: ret_style,\n }\n \n@@ -845,7 +845,7 @@ pub struct foreign_mod {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub struct variant_arg {\n-    ty: @Ty,\n+    ty: Ty,\n     id: node_id,\n }\n \n@@ -959,7 +959,7 @@ impl visibility {\n pub struct struct_field_ {\n     kind: struct_field_kind,\n     id: node_id,\n-    ty: @Ty,\n+    ty: Ty,\n     attrs: ~[attribute],\n }\n \n@@ -995,17 +995,17 @@ pub struct item {\n \n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum item_ {\n-    item_static(@Ty, mutability, @expr),\n+    item_static(Ty, mutability, @expr),\n     item_fn(fn_decl, purity, AbiSet, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n-    item_ty(@Ty, Generics),\n+    item_ty(Ty, Generics),\n     item_enum(enum_def, Generics),\n     item_struct(@struct_def, Generics),\n     item_trait(Generics, ~[trait_ref], ~[trait_method]),\n     item_impl(Generics,\n               Option<trait_ref>, // (optional) trait this impl implements\n-              @Ty, // self\n+              Ty, // self\n               ~[@method]),\n     // a macro invocation (which includes macro definition)\n     item_mac(mac),\n@@ -1024,7 +1024,7 @@ pub struct foreign_item {\n #[deriving(Eq, Encodable, Decodable,IterBytes)]\n pub enum foreign_item_ {\n     foreign_item_fn(fn_decl, purity, Generics),\n-    foreign_item_static(@Ty, /* is_mutbl */ bool),\n+    foreign_item_static(Ty, /* is_mutbl */ bool),\n }\n \n // The data we save and restore about an inlined item or method.  This is not"}, {"sha": "73220ec28817030f71afc81e00e857ffce2ca78e", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -39,31 +39,30 @@ pub trait AstBuilder {\n                 global: bool,\n                 idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n-                types: ~[@ast::Ty])\n+                types: ~[ast::Ty])\n         -> ast::Path;\n \n     // types\n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> @ast::Ty;\n-    fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty;\n+    fn ty_path(&self, ast::Path, Option<OptVec<ast::TyParamBound>>) -> ast::Ty;\n+    fn ty_ident(&self, span: span, idents: ast::ident) -> ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n-               ty: @ast::Ty,\n+               ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n-               mutbl: ast::mutability)\n-        -> @ast::Ty;\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_box(&self, span: span, ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty;\n+               mutbl: ast::mutability) -> ast::Ty;\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty;\n+    fn ty_box(&self, span: span, ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty;\n \n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty;\n-    fn ty_infer(&self, sp: span) -> @ast::Ty;\n-    fn ty_nil(&self) -> @ast::Ty;\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty;\n+    fn ty_infer(&self, sp: span) -> ast::Ty;\n+    fn ty_nil(&self) -> ast::Ty;\n \n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty];\n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field;\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty];\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field;\n     fn strip_bounds(&self, bounds: &Generics) -> Generics;\n \n     fn typaram(&self, id: ast::ident, bounds: OptVec<ast::TyParamBound>) -> ast::TyParam;\n@@ -167,25 +166,25 @@ pub trait AstBuilder {\n     fn item(&self, span: span,\n             name: ident, attrs: ~[ast::attribute], node: ast::item_) -> @ast::item;\n \n-    fn arg(&self, span: span, name: ident, ty: @ast::Ty) -> ast::arg;\n+    fn arg(&self, span: span, name: ident, ty: ast::Ty) -> ast::arg;\n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl;\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl;\n \n     fn item_fn_poly(&self,\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item;\n     fn item_fn(&self,\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk) -> @ast::item;\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant;\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant;\n     fn item_enum_poly(&self,\n                       span: span,\n                       name: ident,\n@@ -207,9 +206,9 @@ pub trait AstBuilder {\n     fn item_ty_poly(&self,\n                     span: span,\n                     name: ident,\n-                    ty: @ast::Ty,\n+                    ty: ast::Ty,\n                     generics: Generics) -> @ast::item;\n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item;\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item;\n \n     fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n \n@@ -239,7 +238,7 @@ impl AstBuilder for @ExtCtxt {\n                 global: bool,\n                 idents: ~[ast::ident],\n                 rp: Option<ast::Lifetime>,\n-                types: ~[@ast::Ty])\n+                types: ~[ast::Ty])\n         -> ast::Path {\n         ast::Path {\n             span: sp,\n@@ -250,52 +249,52 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt {\n+    fn ty_mt(&self, ty: ast::Ty, mutbl: ast::mutability) -> ast::mt {\n         ast::mt {\n-            ty: ty,\n+            ty: ~ty,\n             mutbl: mutbl\n         }\n     }\n \n-    fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty(&self, span: span, ty: ast::ty_) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             span: span,\n             node: ty\n         }\n     }\n \n     fn ty_path(&self, path: ast::Path, bounds: Option<OptVec<ast::TyParamBound>>)\n-              -> @ast::Ty {\n+              -> ast::Ty {\n         self.ty(path.span,\n                 ast::ty_path(path, bounds, self.next_id()))\n     }\n \n     // Might need to take bounds as an argument in the future, if you ever want\n     // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n-        -> @ast::Ty {\n+        -> ast::Ty {\n         self.ty_path(self.path_ident(span, ident), None)\n     }\n \n     fn ty_rptr(&self,\n                span: span,\n-               ty: @ast::Ty,\n+               ty: ast::Ty,\n                lifetime: Option<ast::Lifetime>,\n                mutbl: ast::mutability)\n-        -> @ast::Ty {\n+        -> ast::Ty {\n         self.ty(span,\n                 ast::ty_rptr(lifetime, self.ty_mt(ty, mutbl)))\n     }\n-    fn ty_uniq(&self, span: span, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_uniq(&self, span: span, ty: ast::Ty) -> ast::Ty {\n         self.ty(span, ast::ty_uniq(self.ty_mt(ty, ast::m_imm)))\n     }\n     fn ty_box(&self, span: span,\n-                 ty: @ast::Ty, mutbl: ast::mutability) -> @ast::Ty {\n+                 ty: ast::Ty, mutbl: ast::mutability) -> ast::Ty {\n         self.ty(span, ast::ty_box(self.ty_mt(ty, mutbl)))\n     }\n \n-    fn ty_option(&self, ty: @ast::Ty) -> @ast::Ty {\n+    fn ty_option(&self, ty: ast::Ty) -> ast::Ty {\n         self.ty_path(\n             self.path_all(dummy_sp(),\n                           true,\n@@ -308,20 +307,20 @@ impl AstBuilder for @ExtCtxt {\n                           ~[ ty ]), None)\n     }\n \n-    fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n+    fn ty_field_imm(&self, span: span, name: ident, ty: ast::Ty) -> ast::ty_field {\n         respan(span,\n                ast::ty_field_ {\n                    ident: name,\n-                   mt: ast::mt { ty: ty, mutbl: ast::m_imm },\n+                   mt: ast::mt { ty: ~ty, mutbl: ast::m_imm },\n                })\n     }\n \n-    fn ty_infer(&self, span: span) -> @ast::Ty {\n+    fn ty_infer(&self, span: span) -> ast::Ty {\n         self.ty(span, ast::ty_infer)\n     }\n \n-    fn ty_nil(&self) -> @ast::Ty {\n-        @ast::Ty {\n+    fn ty_nil(&self) -> ast::Ty {\n+        ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_nil,\n             span: dummy_sp(),\n@@ -335,12 +334,12 @@ impl AstBuilder for @ExtCtxt {\n     // these are strange, and probably shouldn't be used outside of\n     // pipes. Specifically, the global version possible generates\n     // incorrect code.\n-    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_ident(dummy_sp(), p.ident)))\n     }\n \n-    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n+    fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n                 self.path_global(dummy_sp(), ~[p.ident]), None)))\n@@ -642,7 +641,7 @@ impl AstBuilder for @ExtCtxt {\n         self.lambda1(span, self.blk(span, stmts, None), ident)\n     }\n \n-    fn arg(&self, span: span, ident: ast::ident, ty: @ast::Ty) -> ast::arg {\n+    fn arg(&self, span: span, ident: ast::ident, ty: ast::Ty) -> ast::arg {\n         let arg_pat = self.pat_ident(span, ident);\n         ast::arg {\n             is_mutbl: false,\n@@ -653,7 +652,7 @@ impl AstBuilder for @ExtCtxt {\n     }\n \n     // XXX unused self\n-    fn fn_decl(&self, inputs: ~[ast::arg], output: @ast::Ty) -> ast::fn_decl {\n+    fn fn_decl(&self, inputs: ~[ast::arg], output: ast::Ty) -> ast::fn_decl {\n         ast::fn_decl {\n             inputs: inputs,\n             output: output,\n@@ -677,7 +676,7 @@ impl AstBuilder for @ExtCtxt {\n                     span: span,\n                     name: ident,\n                     inputs: ~[ast::arg],\n-                    output: @ast::Ty,\n+                    output: ast::Ty,\n                     generics: Generics,\n                     body: ast::blk) -> @ast::item {\n         self.item(span,\n@@ -694,7 +693,7 @@ impl AstBuilder for @ExtCtxt {\n                span: span,\n                name: ident,\n                inputs: ~[ast::arg],\n-               output: @ast::Ty,\n+               output: ast::Ty,\n                body: ast::blk\n               ) -> @ast::item {\n         self.item_fn_poly(\n@@ -706,10 +705,10 @@ impl AstBuilder for @ExtCtxt {\n             body)\n     }\n \n-    fn variant(&self, span: span, name: ident, tys: ~[@ast::Ty]) -> ast::variant {\n-        let args = do tys.map |ty| {\n-            ast::variant_arg { ty: *ty, id: self.next_id() }\n-        };\n+    fn variant(&self, span: span, name: ident, tys: ~[ast::Ty]) -> ast::variant {\n+        let args = tys.consume_iter().transform(|ty| {\n+            ast::variant_arg { ty: ty, id: self.next_id() }\n+        }).collect();\n \n         respan(span,\n                ast::variant_ {\n@@ -773,12 +772,12 @@ impl AstBuilder for @ExtCtxt {\n         )\n     }\n \n-    fn item_ty_poly(&self, span: span, name: ident, ty: @ast::Ty,\n+    fn item_ty_poly(&self, span: span, name: ident, ty: ast::Ty,\n                     generics: Generics) -> @ast::item {\n         self.item(span, name, ~[], ast::item_ty(ty, generics))\n     }\n \n-    fn item_ty(&self, span: span, name: ident, ty: @ast::Ty) -> @ast::item {\n+    fn item_ty(&self, span: span, name: ident, ty: ast::Ty) -> @ast::item {\n         self.item_ty_poly(span, name, ty, ast_util::empty_generics())\n     }\n "}, {"sha": "01769482d08297eb211d460ca62887e56d043d24", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -456,7 +456,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     fn get_ret_ty(&self, cx: @ExtCtxt, span: span,\n-                     generics: &Generics, type_ident: ident) -> @ast::Ty {\n+                     generics: &Generics, type_ident: ident) -> ast::Ty {\n         self.ret_ty.to_ty(cx, span, type_ident, generics)\n     }\n \n@@ -466,7 +466,7 @@ impl<'self> MethodDef<'self> {\n \n     fn split_self_nonself_args(&self, cx: @ExtCtxt, span: span,\n                              type_ident: ident, generics: &Generics)\n-        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, @ast::Ty)]) {\n+        -> (ast::explicit_self, ~[@expr], ~[@expr], ~[(ident, ast::Ty)]) {\n \n         let mut self_args = ~[];\n         let mut nonself_args = ~[];\n@@ -514,7 +514,7 @@ impl<'self> MethodDef<'self> {\n                      type_ident: ident,\n                      generics: &Generics,\n                      explicit_self: ast::explicit_self,\n-                     arg_types: ~[(ident, @ast::Ty)],\n+                     arg_types: ~[(ident, ast::Ty)],\n                      body: @expr) -> @ast::method {\n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, span, type_ident, generics);"}, {"sha": "255bc6c98775be9679da3c9a6444cedaad9894d4", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -61,7 +61,7 @@ impl<'self> Path<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n+                 -> ast::Ty {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics), None)\n     }\n     pub fn to_path(&self,\n@@ -122,7 +122,7 @@ impl<'self> Ty<'self> {\n                  span: span,\n                  self_ty: ident,\n                  self_generics: &Generics)\n-                 -> @ast::Ty {\n+                 -> ast::Ty {\n         match *self {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);"}, {"sha": "a4873e6e34b45feb0e86f5f98b5658150459e388", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -42,19 +42,19 @@ pub fn path_global(ids: ~[ident], span: span) -> ast::Path {\n }\n \n pub trait append_types {\n-    fn add_ty(&self, ty: @ast::Ty) -> ast::Path;\n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> ast::Path;\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path;\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path;\n }\n \n impl append_types for ast::Path {\n-    fn add_ty(&self, ty: @ast::Ty) -> ast::Path {\n+    fn add_ty(&self, ty: ast::Ty) -> ast::Path {\n         ast::Path {\n             types: vec::append_one(copy self.types, ty),\n             .. copy *self\n         }\n     }\n \n-    fn add_tys(&self, tys: ~[@ast::Ty]) -> ast::Path {\n+    fn add_tys(&self, tys: ~[ast::Ty]) -> ast::Path {\n         ast::Path {\n             types: vec::append(copy self.types, tys),\n             .. copy *self"}, {"sha": "adf10215cb56636ef995845e1e8bc70fdcb5ace8", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -49,7 +49,7 @@ impl proto::visitor<(), (), ()> for @ExtCtxt {\n         }\n     }\n \n-    fn visit_message(&self, name: @str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, _span: span, _tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(ref next_state) => {"}, {"sha": "98fc9aa61784d05b3d634ce01d8b23e1b03e06ef", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -25,7 +25,7 @@ use std::vec;\n \n pub trait gen_send {\n     fn gen_send(&mut self, cx: @ExtCtxt, try: bool) -> @ast::item;\n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty;\n }\n \n pub trait to_type_decls {\n@@ -37,7 +37,7 @@ pub trait to_type_decls {\n pub trait gen_init {\n     fn gen_init(&self, cx: @ExtCtxt) -> @ast::item;\n     fn compile(&self, cx: @ExtCtxt) -> @ast::item;\n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty;\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty;\n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item;\n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n     fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr;\n@@ -56,7 +56,7 @@ impl gen_send for message {\n                 next.generics.ty_params.len());\n             let arg_names = vec::from_fn(tys.len(), |i| cx.ident_of(\"x_\"+i.to_str()));\n             let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                .transform(|(n, t)| cx.arg(span, *n, *t)).collect();\n+                .transform(|(n, t)| cx.arg(span, copy *n, copy *t)).collect();\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n@@ -137,7 +137,7 @@ impl gen_send for message {\n                 let arg_names = vec::from_fn(tys.len(), |i| \"x_\" + i.to_str());\n \n                 let args_ast: ~[ast::arg] = arg_names.iter().zip(tys.iter())\n-                    .transform(|(n, t)| cx.arg(span, cx.ident_of(*n), *t)).collect();\n+                    .transform(|(&n, t)| cx.arg(span, cx.ident_of(n), copy *t)).collect();\n \n                 let args_ast = vec::append(\n                     ~[cx.arg(span,\n@@ -189,7 +189,7 @@ impl gen_send for message {\n           }\n         }\n \n-    fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn to_ty(&mut self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n           .add_tys(cx.ty_vars(&self.get_generics().ty_params)), None)\n     }\n@@ -369,7 +369,7 @@ impl gen_init for protocol {\n         })\n     }\n \n-    fn buffer_ty_path(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    fn buffer_ty_path(&self, cx: @ExtCtxt) -> ast::Ty {\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n         for self.states.iter().advance |s| {\n             for s.generics.ty_params.iter().advance |tp| {"}, {"sha": "2fe8456c2749c7becbce1a5a79ebb3995b8b5630", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -37,11 +37,11 @@ impl direction {\n \n pub struct next_state {\n     state: @str,\n-    tys: ~[@ast::Ty],\n+    tys: ~[ast::Ty],\n }\n \n // name, span, data, current state, next state\n-pub struct message(@str, span, ~[@ast::Ty], state, Option<next_state>);\n+pub struct message(@str, span, ~[ast::Ty], state, Option<next_state>);\n \n impl message {\n     pub fn name(&mut self) -> @str {\n@@ -81,7 +81,7 @@ impl state_ {\n     pub fn add_message(@self,\n                        name: @str,\n                        span: span,\n-                       data: ~[@ast::Ty],\n+                       data: ~[ast::Ty],\n                        next: Option<next_state>) {\n         self.messages.push(message(name, span, data, self,\n                                    next));\n@@ -96,7 +96,7 @@ impl state_ {\n     }\n \n     /// Returns the type that is used for the messages.\n-    pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n+    pub fn to_ty(&self, cx: @ExtCtxt) -> ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n                 cx.ty_vars(&self.generics.ty_params)), None)\n@@ -206,7 +206,7 @@ impl protocol_ {\n pub trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(&self, name: @str, spane: span, tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, spane: span, tys: &[ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}, {"sha": "c550e3382a233ca272d068b2286008e7eda95f53", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -88,13 +88,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToSource for @ast::Ty {\n+    impl ToSource for ast::Ty {\n         fn to_source(&self) -> @str {\n-            pprust::ty_to_str(*self, get_ident_interner()).to_managed()\n+            pprust::ty_to_str(self, get_ident_interner()).to_managed()\n         }\n     }\n \n-    impl<'self> ToSource for &'self [@ast::Ty] {\n+    impl<'self> ToSource for &'self [ast::Ty] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\", \").to_managed()\n         }\n@@ -216,13 +216,13 @@ pub mod rt {\n         }\n     }\n \n-    impl ToTokens for @ast::Ty {\n+    impl ToTokens for ast::Ty {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }\n     }\n \n-    impl<'self> ToTokens for &'self [@ast::Ty] {\n+    impl<'self> ToTokens for &'self [ast::Ty] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n             cx.parse_tts(self.to_source())\n         }"}, {"sha": "e2beebcead26d036065000c8d72ff71d40b3ce22", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -28,7 +28,7 @@ pub trait ast_fold {\n     fn fold_pat(@self, @pat) -> @pat;\n     fn fold_decl(@self, @decl) -> Option<@decl>;\n     fn fold_expr(@self, @expr) -> @expr;\n-    fn fold_ty(@self, @Ty) -> @Ty;\n+    fn fold_ty(@self, &Ty) -> Ty;\n     fn fold_mod(@self, &_mod) -> _mod;\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n@@ -107,7 +107,7 @@ fn fold_attribute_(at: attribute, fld: @ast_fold) -> attribute {\n fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     ast::arg {\n         is_mutbl: a.is_mutbl,\n-        ty: fld.fold_ty(a.ty),\n+        ty: fld.fold_ty(&a.ty),\n         pat: fld.fold_pat(a.pat),\n         id: fld.new_id(a.id),\n     }\n@@ -154,8 +154,8 @@ fn maybe_fold_ident(t : &token::Token, fld: @ast_fold) -> token::Token {\n \n pub fn fold_fn_decl(decl: &ast::fn_decl, fld: @ast_fold) -> ast::fn_decl {\n     ast::fn_decl {\n-        inputs: decl.inputs.map(|x| fold_arg_(*x, fld)),\n-        output: fld.fold_ty(decl.output),\n+        inputs: decl.inputs.map(|x| fold_arg_(/*bad*/ copy *x, fld)),\n+        output: fld.fold_ty(&decl.output),\n         cf: decl.cf,\n     }\n }\n@@ -226,14 +226,14 @@ fn noop_fold_foreign_item(ni: @foreign_item, fld: @ast_fold)\n                 foreign_item_fn(ref fdec, purity, ref generics) => {\n                     foreign_item_fn(\n                         ast::fn_decl {\n-                            inputs: fdec.inputs.map(|a| fold_arg(*a)),\n-                            output: fld.fold_ty(fdec.output),\n+                            inputs: fdec.inputs.map(|a| fold_arg(/*bad*/copy *a)),\n+                            output: fld.fold_ty(&fdec.output),\n                             cf: fdec.cf,\n                         },\n                         purity,\n                         fold_generics(generics, fld))\n                 }\n-                foreign_item_static(t, m) => {\n+                foreign_item_static(ref t, m) => {\n                     foreign_item_static(fld.fold_ty(t), m)\n                 }\n             },\n@@ -260,14 +260,14 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n \n     @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n                                           id: sf.node.id,\n-                                          ty: fld.fold_ty(sf.node.ty),\n+                                          ty: fld.fold_ty(&sf.node.ty),\n                                           attrs: sf.node.attrs.map(|e| fold_attribute(*e)) },\n                span: sf.span }\n }\n \n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n-        item_static(t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n+        item_static(ref t, m, e) => item_static(fld.fold_ty(t), m, fld.fold_expr(e)),\n         item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n@@ -281,7 +281,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n         item_foreign_mod(ref nm) => {\n             item_foreign_mod(fld.fold_foreign_mod(nm))\n         }\n-        item_ty(t, ref generics) => {\n+        item_ty(ref t, ref generics) => {\n             item_ty(fld.fold_ty(t), fold_generics(generics, fld))\n         }\n         item_enum(ref enum_definition, ref generics) => {\n@@ -297,7 +297,7 @@ pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n             let struct_def = fold_struct_def(*struct_def, fld);\n             item_struct(struct_def, /* FIXME (#2543) */ copy *generics)\n         }\n-        item_impl(ref generics, ref ifce, ty, ref methods) => {\n+        item_impl(ref generics, ref ifce, ref ty, ref methods) => {\n             item_impl(\n                 fold_generics(generics, fld),\n                 ifce.map(|p| fold_trait_ref(p, fld)),\n@@ -348,7 +348,7 @@ fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n         node: ast::struct_field_ {\n             kind: copy f.node.kind,\n             id: fld.new_id(f.node.id),\n-            ty: fld.fold_ty(f.node.ty),\n+            ty: fld.fold_ty(&f.node.ty),\n             attrs: /* FIXME (#2543) */ copy f.node.attrs,\n         },\n         span: fld.new_span(f.span),\n@@ -518,7 +518,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.new_id(callee_id),\n                 fld.fold_expr(f),\n                 fld.fold_ident(i),\n-                tps.map(|x| fld.fold_ty(*x)),\n+                tps.map(|x| fld.fold_ty(x)),\n                 fld.map_exprs(|x| fld.fold_expr(x), *args),\n                 blk\n             )\n@@ -541,7 +541,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_loop_body(f) => expr_loop_body(fld.fold_expr(f)),\n         expr_do_body(f) => expr_do_body(fld.fold_expr(f)),\n         expr_lit(_) => copy *e,\n-        expr_cast(expr, ty) => expr_cast(fld.fold_expr(expr), ty),\n+        expr_cast(expr, ref ty) => expr_cast(fld.fold_expr(expr), copy *ty),\n         expr_addr_of(m, ohs) => expr_addr_of(m, fld.fold_expr(ohs)),\n         expr_if(cond, ref tr, fl) => {\n             expr_if(\n@@ -587,7 +587,7 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n         expr_field(el, id, ref tys) => {\n             expr_field(\n                 fld.fold_expr(el), fld.fold_ident(id),\n-                tys.map(|x| fld.fold_ty(*x))\n+                tys.map(|x| fld.fold_ty(x))\n             )\n         }\n         expr_index(callee_id, el, er) => {\n@@ -637,7 +637,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n     let fold_mac = |x| fold_mac_(x, fld);\n     fn fold_mt(mt: &mt, fld: @ast_fold) -> mt {\n         mt {\n-            ty: fld.fold_ty(mt.ty),\n+            ty: ~fld.fold_ty(mt.ty),\n             mutbl: mt.mutbl,\n         }\n     }\n@@ -682,7 +682,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 decl: fold_fn_decl(&f.decl, fld)\n             })\n         }\n-        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n+        ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(ty))),\n         ty_path(ref path, ref bounds, id) =>\n             ty_path(fld.fold_path(path), fold_opt_bounds(bounds, fld), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n@@ -714,15 +714,15 @@ fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n \n fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n     fn fold_variant_arg_(va: variant_arg, fld: @ast_fold) -> variant_arg {\n-        ast::variant_arg { ty: fld.fold_ty(va.ty), id: fld.new_id(va.id) }\n+        ast::variant_arg { ty: fld.fold_ty(&va.ty), id: fld.new_id(va.id) }\n     }\n     let fold_variant_arg = |x| fold_variant_arg_(x, fld);\n \n     let kind;\n     match v.kind {\n         tuple_variant_kind(ref variant_args) => {\n             kind = tuple_variant_kind(do variant_args.map |x| {\n-                fold_variant_arg(*x)\n+                fold_variant_arg(/*bad*/ copy *x)\n             })\n         }\n         struct_variant_kind(struct_def) => {\n@@ -761,14 +761,14 @@ fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n         global: p.global,\n         idents: p.idents.map(|x| fld.fold_ident(*x)),\n         rp: p.rp,\n-        types: p.types.map(|x| fld.fold_ty(*x)),\n+        types: p.types.map(|x| fld.fold_ty(x)),\n     }\n }\n \n fn noop_fold_local(l: &local_, fld: @ast_fold) -> local_ {\n     local_ {\n         is_mutbl: l.is_mutbl,\n-        ty: fld.fold_ty(l.ty),\n+        ty: fld.fold_ty(&l.ty),\n         pat: fld.fold_pat(l.pat),\n         init: l.init.map(|e| fld.fold_expr(*e)),\n         id: fld.new_id(l.id),\n@@ -838,7 +838,7 @@ impl ast_fold for AstFoldFns {\n             node: ast::struct_field_ {\n                 kind: copy sf.node.kind,\n                 id: sf.node.id,\n-                ty: (self as @ast_fold).fold_ty(sf.node.ty),\n+                ty: self.fold_ty(&sf.node.ty),\n                 attrs: copy sf.node.attrs,\n             },\n             span: (self.new_span)(sf.span),\n@@ -887,9 +887,9 @@ impl ast_fold for AstFoldFns {\n             span: (self.new_span)(s),\n         }\n     }\n-    fn fold_ty(@self, x: @Ty) -> @Ty {\n+    fn fold_ty(@self, x: &Ty) -> Ty {\n         let (n, s) = (self.fold_ty)(&x.node, x.span, self as @ast_fold);\n-        @Ty {\n+        Ty {\n             id: (self.new_id)(x.id),\n             node: n,\n             span: (self.new_span)(s),"}, {"sha": "d18d24c2b90e0ff92f3e3d84962181ed126bd7cb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -824,7 +824,7 @@ impl Parser {\n     // parse a possibly mutable type\n     pub fn parse_mt(&self) -> mt {\n         let mutbl = self.parse_mutability();\n-        let t = self.parse_ty(false);\n+        let t = ~self.parse_ty(false);\n         mt { ty: t, mutbl: mutbl }\n     }\n \n@@ -835,7 +835,7 @@ impl Parser {\n         let mutbl = self.parse_mutability();\n         let id = self.parse_ident();\n         self.expect(&token::COLON);\n-        let ty = self.parse_ty(false);\n+        let ty = ~self.parse_ty(false);\n         spanned(\n             lo,\n             ty.span.hi,\n@@ -847,13 +847,13 @@ impl Parser {\n     }\n \n     // parse optional return type [ -> TY ] in function decl\n-    pub fn parse_ret_ty(&self) -> (ret_style, @Ty) {\n+    pub fn parse_ret_ty(&self) -> (ret_style, Ty) {\n         return if self.eat(&token::RARROW) {\n             let lo = self.span.lo;\n             if self.eat(&token::NOT) {\n                 (\n                     noreturn,\n-                    @Ty {\n+                    Ty {\n                         id: self.get_id(),\n                         node: ty_bot,\n                         span: mk_sp(lo, self.last_span.hi)\n@@ -866,7 +866,7 @@ impl Parser {\n             let pos = self.span.lo;\n             (\n                 return_val,\n-                @Ty {\n+                Ty {\n                     id: self.get_id(),\n                     node: ty_nil,\n                     span: mk_sp(pos, pos),\n@@ -878,7 +878,7 @@ impl Parser {\n     // parse a type.\n     // Useless second parameter for compatibility with quasiquote macros.\n     // Bleh!\n-    pub fn parse_ty(&self, _: bool) -> @Ty {\n+    pub fn parse_ty(&self, _: bool) -> Ty {\n         maybe_whole!(self, nt_ty);\n \n         let lo = self.span.lo;\n@@ -975,7 +975,7 @@ impl Parser {\n         };\n \n         let sp = mk_sp(lo, self.last_span.hi);\n-        @Ty {id: self.get_id(), node: t, span: sp}\n+        Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n     // parse the type following a @ or a ~\n@@ -1116,7 +1116,7 @@ impl Parser {\n         let t = if self.eat(&token::COLON) {\n             self.parse_ty(false)\n         } else {\n-            @Ty {\n+            Ty {\n                 id: self.get_id(),\n                 node: ty_infer,\n                 span: mk_sp(self.span.lo, self.span.hi),\n@@ -1463,7 +1463,7 @@ impl Parser {\n     pub fn mk_method_call(&self,\n                       rcvr: @expr,\n                       ident: ident,\n-                      tps: ~[@Ty],\n+                      tps: ~[Ty],\n                       args: ~[@expr],\n                       sugar: CallSugar) -> ast::expr_ {\n         expr_method_call(self.get_id(), rcvr, ident, tps, args, sugar)\n@@ -1473,7 +1473,7 @@ impl Parser {\n         expr_index(self.get_id(), expr, idx)\n     }\n \n-    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[@Ty]) -> ast::expr_ {\n+    pub fn mk_field(&self, expr: @expr, ident: ident, tys: ~[Ty]) -> ast::expr_ {\n         expr_field(expr, ident, tys)\n     }\n \n@@ -2215,7 +2215,7 @@ impl Parser {\n                     // No argument list - `do foo {`\n                       ast::fn_decl {\n                           inputs: ~[],\n-                          output: @Ty {\n+                          output: Ty {\n                               id: self.get_id(),\n                               node: ty_infer,\n                               span: *self.span\n@@ -2826,7 +2826,7 @@ impl Parser {\n             self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n         }\n \n-        let mut ty = @Ty {\n+        let mut ty = Ty {\n             id: self.get_id(),\n             node: ty_infer,\n             span: mk_sp(lo, lo),\n@@ -3235,7 +3235,7 @@ impl Parser {\n \n     // parse a generic use site\n     fn parse_generic_values(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         if !self.eat(&token::LT) {\n             (opt_vec::Empty, ~[])\n@@ -3245,7 +3245,7 @@ impl Parser {\n     }\n \n     fn parse_generic_values_after_lt(\n-        &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n+        &self) -> (OptVec<ast::Lifetime>, ~[Ty])\n     {\n         let lifetimes = self.parse_lifetimes();\n         let result = self.parse_seq_to_gt(\n@@ -3455,7 +3455,7 @@ impl Parser {\n         let output = if self.eat(&token::RARROW) {\n             self.parse_ty(false)\n         } else {\n-            @Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n+            Ty { id: self.get_id(), node: ty_infer, span: *self.span }\n         };\n \n         ast::fn_decl {\n@@ -4155,9 +4155,9 @@ impl Parser {\n                     seq_sep_trailing_disallowed(token::COMMA),\n                     |p| p.parse_ty(false)\n                 );\n-                for arg_tys.iter().advance |ty| {\n+                for arg_tys.consume_iter().advance |ty| {\n                     args.push(ast::variant_arg {\n-                        ty: *ty,\n+                        ty: ty,\n                         id: self.get_id(),\n                     });\n                 }"}, {"sha": "09d6ecb40fc0b86048fb54a8d3d9926812b93df2", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -104,7 +104,7 @@ pub enum nonterminal {\n     nt_stmt(@ast::stmt),\n     nt_pat( @ast::pat),\n     nt_expr(@ast::expr),\n-    nt_ty(  @ast::Ty),\n+    nt_ty(   ast::Ty),\n     nt_ident(ast::ident, bool),\n     nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity"}, {"sha": "517065ab1b5c0cd9206172f80229f80d177e719e", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -398,7 +398,7 @@ pub fn print_type(s: @ps, ty: &ast::Ty) {\n       }\n       ast::ty_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, *elts, |p, &t| print_type(p, t));\n+        commasep(s, inconsistent, *elts, print_type);\n         if elts.len() == 1 {\n             word(s.s, \",\");\n         }\n@@ -454,7 +454,7 @@ pub fn print_foreign_item(s: @ps, item: &ast::foreign_item) {\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n       }\n-      ast::foreign_item_static(t, m) => {\n+      ast::foreign_item_static(ref t, m) => {\n         head(s, \"static\");\n         if m {\n             word_space(s, \"mut\");\n@@ -476,7 +476,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n     let ann_node = node_item(s, item);\n     (s.ann.pre)(ann_node);\n     match item.node {\n-      ast::item_static(ty, m, expr) => {\n+      ast::item_static(ref ty, m, expr) => {\n         head(s, visibility_qualified(item.vis, \"static\"));\n         if m == ast::m_mutbl {\n             word_space(s, \"mut\");\n@@ -530,7 +530,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n         print_foreign_mod(s, nmod, item.attrs);\n         bclose(s, item.span);\n       }\n-      ast::item_ty(ty, ref params) => {\n+      ast::item_ty(ref ty, ref params) => {\n         ibox(s, indent_unit);\n         ibox(s, 0u);\n         word_nbsp(s, visibility_qualified(item.vis, \"type\"));\n@@ -559,7 +559,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n           print_struct(s, struct_def, generics, item.ident, item.span);\n       }\n \n-      ast::item_impl(ref generics, ref opt_trait, ty, ref methods) => {\n+      ast::item_impl(ref generics, ref opt_trait, ref ty, ref methods) => {\n         head(s, visibility_qualified(item.vis, \"impl\"));\n         if generics.is_parameterized() {\n             print_generics(s, generics);\n@@ -694,7 +694,7 @@ pub fn print_struct(s: @ps,\n                     ast::named_field(*) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n-                        print_type(s, field.node.ty);\n+                        print_type(s, &field.node.ty);\n                     }\n                 }\n             }\n@@ -718,7 +718,7 @@ pub fn print_struct(s: @ps,\n                     print_visibility(s, visibility);\n                     print_ident(s, ident);\n                     word_nbsp(s, \":\");\n-                    print_type(s, field.node.ty);\n+                    print_type(s, &field.node.ty);\n                     word(s.s, \",\");\n                 }\n             }\n@@ -777,7 +777,7 @@ pub fn print_variant(s: @ps, v: &ast::variant) {\n             if !args.is_empty() {\n                 popen(s);\n                 fn print_variant_arg(s: @ps, arg: &ast::variant_arg) {\n-                    print_type(s, arg.ty);\n+                    print_type(s, &arg.ty);\n                 }\n                 commasep(s, consistent, *args, print_variant_arg);\n                 pclose(s);\n@@ -1172,7 +1172,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_ident(s, ident);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, |p, &e| print_type(p, e));\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, \">\");\n         }\n         print_call_post(s, sugar, &blk, &mut base_args);\n@@ -1198,7 +1198,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_expr(s, expr);\n       }\n       ast::expr_lit(lit) => print_literal(s, lit),\n-      ast::expr_cast(expr, ty) => {\n+      ast::expr_cast(expr, ref ty) => {\n         print_expr(s, expr);\n         space(s.s);\n         word_space(s, \"as\");\n@@ -1348,7 +1348,7 @@ pub fn print_expr(s: @ps, expr: &ast::expr) {\n         print_ident(s, id);\n         if tys.len() > 0u {\n             word(s.s, \"::<\");\n-            commasep(s, inconsistent, *tys, |p, &e| print_type(p, e));\n+            commasep(s, inconsistent, *tys, print_type);\n             word(s.s, \">\");\n         }\n       }\n@@ -1437,7 +1437,7 @@ pub fn print_local_decl(s: @ps, loc: &ast::local) {\n     print_irrefutable_pat(s, loc.node.pat);\n     match loc.node.ty.node {\n       ast::ty_infer => (),\n-      _ => { word_space(s, \":\"); print_type(s, loc.node.ty); }\n+      _ => { word_space(s, \":\"); print_type(s, &loc.node.ty); }\n     }\n }\n \n@@ -1510,7 +1510,7 @@ fn print_path_(s: @ps, path: &ast::Path, colons_before_params: bool,\n                 }\n             }\n \n-            commasep(s, inconsistent, path.types, |p, &e| print_type(p, e));\n+            commasep(s, inconsistent, path.types, print_type);\n \n             word(s.s, \">\");\n         }\n@@ -1693,7 +1693,7 @@ pub fn print_fn_args(s: @ps, decl: &ast::fn_decl,\n \n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n \n     end(s);\n@@ -1711,7 +1711,7 @@ pub fn print_fn_args_and_ret(s: @ps, decl: &ast::fn_decl,\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n }\n@@ -1726,7 +1726,7 @@ pub fn print_fn_block_args(s: @ps, decl: &ast::fn_decl) {\n         _ => {\n             space_if_not_bol(s);\n             word_space(s, \"->\");\n-            print_type(s, decl.output);\n+            print_type(s, &decl.output);\n         }\n     }\n \n@@ -1882,7 +1882,7 @@ pub fn print_mt(s: @ps, mt: &ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-pub fn print_arg(s: @ps, input: ast::arg) {\n+pub fn print_arg(s: @ps, input: &ast::arg) {\n     ibox(s, indent_unit);\n     if input.is_mutbl {\n         word_space(s, \"mut\");\n@@ -1902,7 +1902,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n                 space(s.s);\n             }\n         }\n-        print_type(s, input.ty);\n+        print_type(s, &input.ty);\n       }\n     }\n     end(s);\n@@ -1944,7 +1944,7 @@ pub fn print_ty_fn(s: @ps,\n     }\n     for decl.inputs.iter().advance |arg| {\n         if first { first = false; } else { word_space(s, \",\"); }\n-        print_arg(s, *arg);\n+        print_arg(s, arg);\n     }\n     end(s);\n     pclose(s);\n@@ -1958,7 +1958,7 @@ pub fn print_ty_fn(s: @ps,\n             ibox(s, indent_unit);\n             word_space(s, \"->\");\n             if decl.cf == ast::noreturn { word_nbsp(s, \"!\"); }\n-            else { print_type(s, decl.output); }\n+            else { print_type(s, &decl.output); }\n             end(s);\n         }\n     }"}, {"sha": "b2d9d49f0ee77eed8610ac37a28c494b9ca35f04", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=47eca2113c5c55a4ffbb8c11a38c8ca7a79a1d72", "patch": "@@ -83,7 +83,7 @@ pub struct Visitor<E> {\n     visit_decl: @fn(@decl, (E, vt<E>)),\n     visit_expr: @fn(@expr, (E, vt<E>)),\n     visit_expr_post: @fn(@expr, (E, vt<E>)),\n-    visit_ty: @fn(@Ty, (E, vt<E>)),\n+    visit_ty: @fn(&Ty, (E, vt<E>)),\n     visit_generics: @fn(&Generics, (E, vt<E>)),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id, (E, vt<E>)),\n     visit_ty_method: @fn(&ty_method, (E, vt<E>)),\n@@ -131,7 +131,7 @@ pub fn visit_view_item<E>(_vi: &view_item, (_e, _v): (E, vt<E>)) { }\n \n pub fn visit_local<E: Copy>(loc: &local, (e, v): (E, vt<E>)) {\n     (v.visit_pat)(loc.node.pat, (copy e, v));\n-    (v.visit_ty)(loc.node.ty, (copy e, v));\n+    (v.visit_ty)(&loc.node.ty, (copy e, v));\n     match loc.node.init {\n       None => (),\n       Some(ex) => (v.visit_expr)(ex, (e, v))\n@@ -144,7 +144,7 @@ fn visit_trait_ref<E: Copy>(tref: &ast::trait_ref, (e, v): (E, vt<E>)) {\n \n pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n     match i.node {\n-        item_static(t, _, ex) => {\n+        item_static(ref t, _, ex) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n         }\n@@ -169,7 +169,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n             for nm.view_items.iter().advance |vi| { (v.visit_view_item)(vi, (copy e, v)); }\n             for nm.items.iter().advance |ni| { (v.visit_foreign_item)(*ni, (copy e, v)); }\n         }\n-        item_ty(t, ref tps) => {\n+        item_ty(ref t, ref tps) => {\n             (v.visit_ty)(t, (copy e, v));\n             (v.visit_generics)(tps, (e, v));\n         }\n@@ -181,7 +181,7 @@ pub fn visit_item<E: Copy>(i: &item, (e, v): (E, vt<E>)) {\n                 (e, v)\n             );\n         }\n-        item_impl(ref tps, ref traits, ty, ref methods) => {\n+        item_impl(ref tps, ref traits, ref ty, ref methods) => {\n             (v.visit_generics)(tps, (copy e, v));\n             for traits.iter().advance |p| {\n                 visit_trait_ref(p, (copy e, v));\n@@ -213,7 +213,7 @@ pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n         match vr.node.kind {\n             tuple_variant_kind(ref variant_args) => {\n                 for variant_args.iter().advance |va| {\n-                    (v.visit_ty)(va.ty, (copy e, v));\n+                    (v.visit_ty)(&va.ty, (copy e, v));\n                 }\n             }\n             struct_variant_kind(struct_def) => {\n@@ -232,25 +232,25 @@ pub fn skip_ty<E>(_t: &Ty, (_e,_v): (E, vt<E>)) {}\n \n pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n     match t.node {\n-        ty_box(mt) | ty_uniq(mt) |\n-        ty_vec(mt) | ty_ptr(mt) | ty_rptr(_, mt) => {\n+        ty_box(ref mt) | ty_uniq(ref mt) |\n+        ty_vec(ref mt) | ty_ptr(ref mt) | ty_rptr(_, ref mt) => {\n             (v.visit_ty)(mt.ty, (e, v));\n         },\n         ty_tup(ref ts) => {\n             for ts.iter().advance |tt| {\n-                (v.visit_ty)(*tt, (copy e, v));\n+                (v.visit_ty)(tt, (copy e, v));\n             }\n         },\n         ty_closure(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (copy e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (copy e, v));\n             do f.bounds.map |bounds| {\n                 visit_ty_param_bounds(bounds, (copy e, v));\n             };\n         },\n         ty_bare_fn(ref f) => {\n-            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (e, v));\n+            for f.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n+            (v.visit_ty)(&f.decl.output, (e, v));\n         },\n         ty_path(ref p, ref bounds, _) => {\n             visit_path(p, (copy e, v));\n@@ -267,7 +267,7 @@ pub fn visit_ty<E: Copy>(t: &Ty, (e, v): (E, vt<E>)) {\n }\n \n pub fn visit_path<E: Copy>(p: &Path, (e, v): (E, vt<E>)) {\n-    for p.types.iter().advance |tp| { (v.visit_ty)(*tp, (copy e, v)); }\n+    for p.types.iter().advance |tp| { (v.visit_ty)(tp, (copy e, v)); }\n }\n \n pub fn visit_pat<E: Copy>(p: &pat, (e, v): (E, vt<E>)) {\n@@ -326,7 +326,7 @@ pub fn visit_foreign_item<E: Copy>(ni: &foreign_item, (e, v): (E, vt<E>)) {\n             visit_fn_decl(fd, (copy e, v));\n             (v.visit_generics)(generics, (e, v));\n         }\n-        foreign_item_static(t, _) => {\n+        foreign_item_static(ref t, _) => {\n             (v.visit_ty)(t, (e, v));\n         }\n     }\n@@ -351,9 +351,9 @@ pub fn visit_generics<E: Copy>(generics: &Generics, (e, v): (E, vt<E>)) {\n pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n     for fd.inputs.iter().advance |a| {\n         (v.visit_pat)(a.pat, (copy e, v));\n-        (v.visit_ty)(a.ty, (copy e, v));\n+        (v.visit_ty)(&a.ty, (copy e, v));\n     }\n-    (v.visit_ty)(fd.output, (e, v));\n+    (v.visit_ty)(&fd.output, (e, v));\n }\n \n // Note: there is no visit_method() method in the visitor, instead override\n@@ -384,9 +384,9 @@ pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,\n }\n \n pub fn visit_ty_method<E: Copy>(m: &ty_method, (e, v): (E, vt<E>)) {\n-    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n+    for m.decl.inputs.iter().advance |a| { (v.visit_ty)(&a.ty, (copy e, v)); }\n     (v.visit_generics)(&m.generics, (copy e, v));\n-    (v.visit_ty)(m.decl.output, (e, v));\n+    (v.visit_ty)(&m.decl.output, (e, v));\n }\n \n pub fn visit_trait_method<E: Copy>(m: &trait_method, (e, v): (E, vt<E>)) {\n@@ -409,7 +409,7 @@ pub fn visit_struct_def<E: Copy>(\n }\n \n pub fn visit_struct_field<E: Copy>(sf: &struct_field, (e, v): (E, vt<E>)) {\n-    (v.visit_ty)(sf.node.ty, (e, v));\n+    (v.visit_ty)(&sf.node.ty, (e, v));\n }\n \n pub fn visit_block<E: Copy>(b: &blk, (e, v): (E, vt<E>)) {\n@@ -475,7 +475,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_method_call(_, callee, _, ref tys, ref args, _) => {\n             visit_exprs(*args, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n             (v.visit_expr)(callee, (copy e, v));\n         }\n@@ -486,7 +486,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_addr_of(_, x) | expr_unary(_, _, x) |\n         expr_loop_body(x) | expr_do_body(x) => (v.visit_expr)(x, (copy e, v)),\n         expr_lit(_) => (),\n-        expr_cast(x, t) => {\n+        expr_cast(x, ref t) => {\n             (v.visit_expr)(x, (copy e, v));\n             (v.visit_ty)(t, (copy e, v));\n         }\n@@ -527,7 +527,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, (e, v): (E, vt<E>)) {\n         expr_field(x, _, ref tys) => {\n             (v.visit_expr)(x, (copy e, v));\n             for tys.iter().advance |tp| {\n-                (v.visit_ty)(*tp, (copy e, v));\n+                (v.visit_ty)(tp, (copy e, v));\n             }\n         }\n         expr_index(_, a, b) => {\n@@ -579,7 +579,7 @@ pub struct SimpleVisitor {\n     visit_decl: @fn(@decl),\n     visit_expr: @fn(@expr),\n     visit_expr_post: @fn(@expr),\n-    visit_ty: @fn(@Ty),\n+    visit_ty: @fn(&Ty),\n     visit_generics: @fn(&Generics),\n     visit_fn: @fn(&fn_kind, &fn_decl, &blk, span, node_id),\n     visit_ty_method: @fn(&ty_method),\n@@ -591,7 +591,7 @@ pub struct SimpleVisitor {\n \n pub type simple_visitor = @SimpleVisitor;\n \n-pub fn simple_ignore_ty(_t: @Ty) {}\n+pub fn simple_ignore_ty(_t: &Ty) {}\n \n pub fn default_simple_visitor() -> @SimpleVisitor {\n     @SimpleVisitor {\n@@ -672,7 +672,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n     fn v_expr_post(f: @fn(@expr), ex: @expr, (_e, _v): ((), vt<()>)) {\n         f(ex);\n     }\n-    fn v_ty(f: @fn(@Ty), ty: @Ty, (e, v): ((), vt<()>)) {\n+    fn v_ty(f: @fn(&Ty), ty: &Ty, (e, v): ((), vt<()>)) {\n         f(ty);\n         visit_ty(ty, (e, v));\n     }\n@@ -717,7 +717,7 @@ pub fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(fk, decl, body, sp, id);\n         visit_fn(fk, decl, body, sp, id, (e, v));\n     }\n-    let visit_ty: @fn(@Ty, ((), vt<()>)) =\n+    let visit_ty: @fn(&Ty, ((), vt<()>)) =\n         |a,b| v_ty(v.visit_ty, a, b);\n     fn v_struct_field(f: @fn(@struct_field), sf: @struct_field, (e, v): ((), vt<()>)) {\n         f(sf);"}]}