{"sha": "19288ddfd6b3448c2c221d75610bff722a6582e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5Mjg4ZGRmZDZiMzQ0OGMyYzIyMWQ3NTYxMGJmZjcyMmE2NTgyZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-15T02:24:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-15T02:24:04Z"}, "message": "Auto merge of #67681 - matthewjasper:infer-regions-in-borrowck, r=nikomatsakis\n\nInfer regions for opaque types in borrowck\n\nThis is a step towards the goal of typeck not doing region inference.\n\nThe commits up to `Arena allocate the result of mir_borrowck` are various bug fixes and prerequisites.\nThe remaining commits move opaque type inference to borrow checking.\n\nr? @nikomatsakis", "tree": {"sha": "328dee8a45bac8f49f6a127c1ebd6e3966e1a749", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/328dee8a45bac8f49f6a127c1ebd6e3966e1a749"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19288ddfd6b3448c2c221d75610bff722a6582e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19288ddfd6b3448c2c221d75610bff722a6582e8", "html_url": "https://github.com/rust-lang/rust/commit/19288ddfd6b3448c2c221d75610bff722a6582e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19288ddfd6b3448c2c221d75610bff722a6582e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92c6ee882853313698f1148512e8e992ba36b2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92c6ee882853313698f1148512e8e992ba36b2d", "html_url": "https://github.com/rust-lang/rust/commit/b92c6ee882853313698f1148512e8e992ba36b2d"}, {"sha": "d863978f89c74bd5cb90baa47331d421bbfd3936", "url": "https://api.github.com/repos/rust-lang/rust/commits/d863978f89c74bd5cb90baa47331d421bbfd3936", "html_url": "https://github.com/rust-lang/rust/commit/d863978f89c74bd5cb90baa47331d421bbfd3936"}], "stats": {"total": 3300, "additions": 1996, "deletions": 1304}, "files": [{"sha": "33cbf6ede0a0124853f3af2c68b8218c541ef557", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -35,7 +35,8 @@ macro_rules! arena_types {\n                 rustc::mir::Promoted,\n                 rustc::mir::BodyAndCache<$tcx>\n             >,\n-            [] tables: rustc::ty::TypeckTables<$tcx>,\n+            [decode] tables: rustc::ty::TypeckTables<$tcx>,\n+            [decode] borrowck_result: rustc::mir::BorrowCheckResult<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n             [] vtable_method: Option<(\n                 rustc_hir::def_id::DefId,"}, {"sha": "327e1da64c4cd403385e0d9610388273152c905b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -405,17 +405,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n \n                     RegionResolutionError::MemberConstraintFailure {\n-                        opaque_type_def_id,\n                         hidden_ty,\n                         member_region,\n-                        span: _,\n-                        choice_regions: _,\n+                        span,\n                     } => {\n                         let hidden_ty = self.resolve_vars_if_possible(&hidden_ty);\n                         opaque_types::unexpected_hidden_region_diagnostic(\n                             self.tcx,\n                             Some(region_scope_tree),\n-                            opaque_type_def_id,\n+                            span,\n                             hidden_ty,\n                             member_region,\n                         )"}, {"sha": "1b204e5ba6cb335364561f8688107c11f1576ec1", "filename": "src/librustc/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -18,7 +18,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::graph::implementation::{\n     Direction, Graph, NodeIndex, INCOMING, OUTGOING,\n };\n-use rustc_hir::def_id::DefId;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_span::Span;\n use std::fmt;\n@@ -95,13 +94,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// Indicates a failure of a `MemberConstraint`. These arise during\n     /// impl trait processing explicitly -- basically, the impl trait's hidden type\n     /// included some region that it was not supposed to.\n-    MemberConstraintFailure {\n-        span: Span,\n-        opaque_type_def_id: DefId,\n-        hidden_ty: Ty<'tcx>,\n-        member_region: Region<'tcx>,\n-        choice_regions: Vec<Region<'tcx>>,\n-    },\n+    MemberConstraintFailure { span: Span, hidden_ty: Ty<'tcx>, member_region: Region<'tcx> },\n }\n \n struct RegionAndOrigin<'tcx> {\n@@ -656,10 +649,8 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n                 let span = self.tcx().def_span(member_constraint.opaque_type_def_id);\n                 errors.push(RegionResolutionError::MemberConstraintFailure {\n                     span,\n-                    opaque_type_def_id: member_constraint.opaque_type_def_id,\n                     hidden_ty: member_constraint.hidden_ty,\n                     member_region,\n-                    choice_regions: choice_regions.collect(),\n                 });\n             }\n         }"}, {"sha": "5ecd03e41234e88a2ef93328eed0f5fb6417a181", "filename": "src/librustc/infer/opaque_types/mod.rs", "status": "modified", "additions": 85, "deletions": 47, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fopaque_types%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -93,6 +93,18 @@ pub struct OpaqueTypeDecl<'tcx> {\n     pub origin: hir::OpaqueTyOrigin,\n }\n \n+/// Whether member constraints should be generated for all opaque types\n+pub enum GenerateMemberConstraints {\n+    /// The default, used by typeck\n+    WhenRequired,\n+    /// The borrow checker needs member constraints in any case where we don't\n+    /// have a `'static` bound. This is because the borrow checker has more\n+    /// flexibility in the values of regions. For example, given `f<'a, 'b>`\n+    /// the borrow checker can have an inference variable outlive `'a` and `'b`,\n+    /// but not be equal to `'static`.\n+    IfNoStaticBound,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// Replaces all opaque types in `value` with fresh inference variables\n     /// and creates appropriate obligations. For example, given the input:\n@@ -315,7 +327,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         debug!(\"constrain_opaque_types()\");\n \n         for (&def_id, opaque_defn) in opaque_types {\n-            self.constrain_opaque_type(def_id, opaque_defn, free_region_relations);\n+            self.constrain_opaque_type(\n+                def_id,\n+                opaque_defn,\n+                GenerateMemberConstraints::WhenRequired,\n+                free_region_relations,\n+            );\n         }\n     }\n \n@@ -324,6 +341,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         def_id: DefId,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        mode: GenerateMemberConstraints,\n         free_region_relations: &FRR,\n     ) {\n         debug!(\"constrain_opaque_type()\");\n@@ -358,6 +376,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n+            if let GenerateMemberConstraints::IfNoStaticBound = mode {\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_type_generics,\n+                    opaque_defn,\n+                    def_id,\n+                );\n+            }\n             return;\n         }\n \n@@ -398,13 +424,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // we will create a \"in bound\" like `'r in\n                         // ['a, 'b, 'c]`, where `'a..'c` are the\n                         // regions that appear in the impl trait.\n+\n+                        // For now, enforce a feature gate outside of async functions.\n+                        self.member_constraint_feature_gate(opaque_defn, def_id, lr, subst_arg);\n+\n                         return self.generate_member_constraint(\n                             concrete_ty,\n                             opaque_type_generics,\n                             opaque_defn,\n                             def_id,\n-                            lr,\n-                            subst_arg,\n                         );\n                     }\n                 }\n@@ -414,6 +442,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let least_region = least_region.unwrap_or(tcx.lifetimes.re_static);\n         debug!(\"constrain_opaque_types: least_region={:?}\", least_region);\n \n+        if let GenerateMemberConstraints::IfNoStaticBound = mode {\n+            if least_region != tcx.lifetimes.re_static {\n+                self.generate_member_constraint(\n+                    concrete_ty,\n+                    opaque_type_generics,\n+                    opaque_defn,\n+                    def_id,\n+                );\n+            }\n+        }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n             tcx: self.tcx,\n             op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n@@ -434,19 +472,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         opaque_type_generics: &ty::Generics,\n         opaque_defn: &OpaqueTypeDecl<'tcx>,\n         opaque_type_def_id: DefId,\n-        conflict1: ty::Region<'tcx>,\n-        conflict2: ty::Region<'tcx>,\n     ) {\n-        // For now, enforce a feature gate outside of async functions.\n-        if self.member_constraint_feature_gate(\n-            opaque_defn,\n-            opaque_type_def_id,\n-            conflict1,\n-            conflict2,\n-        ) {\n-            return;\n-        }\n-\n         // Create the set of choice regions: each region in the hidden\n         // type can be equal to any of the region parameters of the\n         // opaque type definition.\n@@ -500,8 +526,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             hir::OpaqueTyOrigin::AsyncFn => return false,\n \n             // Otherwise, generate the label we'll use in the error message.\n-            hir::OpaqueTyOrigin::TypeAlias => \"impl Trait\",\n-            hir::OpaqueTyOrigin::FnReturn => \"impl Trait\",\n+            hir::OpaqueTyOrigin::TypeAlias\n+            | hir::OpaqueTyOrigin::FnReturn\n+            | hir::OpaqueTyOrigin::Misc => \"impl Trait\",\n         };\n         let msg = format!(\"ambiguous lifetime bound in `{}`\", context_name);\n         let mut err = self.tcx.sess.struct_span_err(span, &msg);\n@@ -549,13 +576,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// # Parameters\n     ///\n     /// - `def_id`, the `impl Trait` type\n-    /// - `opaque_defn`, the opaque definition created in `instantiate_opaque_types`\n+    /// - `substs`, the substs  used to instantiate this opaque type\n     /// - `instantiated_ty`, the inferred type C1 -- fully resolved, lifted version of\n     ///   `opaque_defn.concrete_ty`\n     pub fn infer_opaque_definition_from_instantiation(\n         &self,\n         def_id: DefId,\n-        opaque_defn: &OpaqueTypeDecl<'tcx>,\n+        substs: SubstsRef<'tcx>,\n         instantiated_ty: Ty<'tcx>,\n         span: Span,\n     ) -> Ty<'tcx> {\n@@ -571,12 +598,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         // `impl Trait` return type, resulting in the parameters\n         // shifting.\n         let id_substs = InternalSubsts::identity_for_item(self.tcx, def_id);\n-        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> = opaque_defn\n-            .substs\n-            .iter()\n-            .enumerate()\n-            .map(|(index, subst)| (*subst, id_substs[index]))\n-            .collect();\n+        let map: FxHashMap<GenericArg<'tcx>, GenericArg<'tcx>> =\n+            substs.iter().enumerate().map(|(index, subst)| (*subst, id_substs[index])).collect();\n \n         // Convert the type from the function into a type valid outside\n         // the function, by replacing invalid regions with 'static,\n@@ -598,11 +621,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n pub fn unexpected_hidden_region_diagnostic(\n     tcx: TyCtxt<'tcx>,\n     region_scope_tree: Option<&region::ScopeTree>,\n-    opaque_type_def_id: DefId,\n+    span: Span,\n     hidden_ty: Ty<'tcx>,\n     hidden_region: ty::Region<'tcx>,\n ) -> DiagnosticBuilder<'tcx> {\n-    let span = tcx.def_span(opaque_type_def_id);\n     let mut err = struct_span_err!(\n         tcx.sess,\n         span,\n@@ -817,32 +839,48 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n \n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n         match r {\n-            // ignore bound regions that appear in the type (e.g., this\n-            // would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n-            ty::ReLateBound(..) |\n-\n-            // ignore `'static`, as that can appear anywhere\n-            ty::ReStatic => return r,\n-\n-            _ => { }\n+            // Ignore bound regions and `'static` regions that appear in the\n+            // type, we only need to remap regions that reference lifetimes\n+            // from the function declaraion.\n+            // This would ignore `'r` in a type like `for<'r> fn(&'r u32)`.\n+            ty::ReLateBound(..) | ty::ReStatic => return r,\n+\n+            // If regions have been erased (by writeback), don't try to unerase\n+            // them.\n+            ty::ReErased => return r,\n+\n+            // The regions that we expect from borrow checking.\n+            ty::ReEarlyBound(_) | ty::ReFree(_) | ty::ReEmpty(ty::UniverseIndex::ROOT) => {}\n+\n+            ty::ReEmpty(_)\n+            | ty::RePlaceholder(_)\n+            | ty::ReVar(_)\n+            | ty::ReScope(_)\n+            | ty::ReClosureBound(_) => {\n+                // All of the regions in the type should either have been\n+                // erased by writeback, or mapped back to named regions by\n+                // borrow checking.\n+                bug!(\"unexpected region kind in opaque type: {:?}\", r);\n+            }\n         }\n \n         let generics = self.tcx().generics_of(self.opaque_type_def_id);\n         match self.map.get(&r.into()).map(|k| k.unpack()) {\n             Some(GenericArgKind::Lifetime(r1)) => r1,\n             Some(u) => panic!(\"region mapped to unexpected kind: {:?}\", u),\n+            None if self.map_missing_regions_to_empty || self.tainted_by_errors => {\n+                self.tcx.lifetimes.re_root_empty\n+            }\n             None if generics.parent.is_some() => {\n-                if !self.map_missing_regions_to_empty && !self.tainted_by_errors {\n-                    if let Some(hidden_ty) = self.hidden_ty.take() {\n-                        unexpected_hidden_region_diagnostic(\n-                            self.tcx,\n-                            None,\n-                            self.opaque_type_def_id,\n-                            hidden_ty,\n-                            r,\n-                        )\n-                        .emit();\n-                    }\n+                if let Some(hidden_ty) = self.hidden_ty.take() {\n+                    unexpected_hidden_region_diagnostic(\n+                        self.tcx,\n+                        None,\n+                        self.tcx.def_span(self.opaque_type_def_id),\n+                        hidden_ty,\n+                        r,\n+                    )\n+                    .emit();\n                 }\n                 self.tcx.lifetimes.re_root_empty\n             }\n@@ -860,7 +898,7 @@ impl TypeFolder<'tcx> for ReverseMapper<'tcx> {\n                     )\n                     .emit();\n \n-                self.tcx().mk_region(ty::ReStatic)\n+                self.tcx().lifetimes.re_static\n             }\n         }\n     }"}, {"sha": "824cdfe55bfb65ec4d24e0dbce4eebf4b8d7757a", "filename": "src/librustc/mir/query.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fquery.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,8 +1,10 @@\n //! Values computed by queries that use MIR.\n \n use crate::ty::{self, Ty};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitMatrix;\n use rustc_index::vec::IndexVec;\n use rustc_span::{Span, Symbol};\n@@ -59,8 +61,12 @@ pub struct GeneratorLayout<'tcx> {\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n }\n \n-#[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct BorrowCheckResult<'tcx> {\n+    /// All the opaque types that are restricted to concrete types\n+    /// by this function. Unlike the value in `TypeckTables`, this has\n+    /// unerased regions.\n+    pub concrete_opaque_types: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub closure_requirements: Option<ClosureRegionRequirements<'tcx>>,\n     pub used_mut_upvars: SmallVec<[Field; 8]>,\n }"}, {"sha": "5e279975d152d21d4a3f5f137ba3be771749584f", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -125,7 +125,9 @@ rustc_queries! {\n \n         /// Fetch the MIR for a given `DefId` right after it's built - this includes\n         /// unreachable code.\n-        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {}\n+        query mir_built(_: DefId) -> &'tcx Steal<mir::BodyAndCache<'tcx>> {\n+            desc { \"building MIR for\" }\n+        }\n \n         /// Fetch the MIR for a given `DefId` up till the point where it is\n         /// ready for const evaluation.\n@@ -345,6 +347,7 @@ rustc_queries! {\n     TypeChecking {\n         /// The result of unsafety-checking this `DefId`.\n         query unsafety_check_result(key: DefId) -> mir::UnsafetyCheckResult {\n+            desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n         }\n \n@@ -414,14 +417,8 @@ rustc_queries! {\n         }\n \n         query typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n+            desc { |tcx| \"type-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n-            load_cached(tcx, id) {\n-                let typeck_tables: Option<ty::TypeckTables<'tcx>> = tcx\n-                    .queries.on_disk_cache\n-                    .try_load_query_result(tcx, id);\n-\n-                typeck_tables.map(|tables| &*tcx.arena.alloc(tables))\n-            }\n         }\n         query diagnostic_only_typeck_tables_of(key: DefId) -> &'tcx ty::TypeckTables<'tcx> {\n             cache_on_disk_if { key.is_local() }\n@@ -452,8 +449,13 @@ rustc_queries! {\n     BorrowChecking {\n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n-        query mir_borrowck(key: DefId) -> mir::BorrowCheckResult<'tcx> {\n-            cache_on_disk_if(tcx, _) { key.is_local() && tcx.is_closure(key) }\n+        query mir_borrowck(key: DefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n+            desc { |tcx| \"borrow-checking `{}`\", tcx.def_path_str(key) }\n+            cache_on_disk_if(tcx, opt_result) {\n+                key.is_local()\n+                    && (tcx.is_closure(key)\n+                        || opt_result.map_or(false, |r| !r.concrete_opaque_types.is_empty()))\n+            }\n         }\n     }\n "}, {"sha": "4546eadc6e6e13c11be294577d9a357782d0bf12", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -138,7 +138,7 @@ impl FlagComputation {\n             }\n \n             &ty::Opaque(_, substs) => {\n-                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_flags(TypeFlags::HAS_PROJECTION | TypeFlags::HAS_TY_OPAQUE);\n                 self.add_substs(substs);\n             }\n "}, {"sha": "3212bc7241783df6a4f3e506b4d2ea495295b3c9", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -78,6 +78,9 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n     }\n+    fn has_opaque_types(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_TY_OPAQUE)\n+    }\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_TY_ERR)\n     }\n@@ -120,6 +123,10 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n     }\n \n+    fn has_erased_regions(&self) -> bool {\n+        self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n+    }\n+\n     /// True if there are any un-erased free regions.\n     fn has_erasable_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)"}, {"sha": "45ea05efd4a84cb44ebece7799584dc53a20b421", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -474,10 +474,15 @@ bitflags! {\n         /// if a global bound is safe to evaluate.\n         const HAS_RE_LATE_BOUND  = 1 << 11;\n \n-        const HAS_TY_PLACEHOLDER = 1 << 12;\n+        /// Does this have any `ReErased` regions?\n+        const HAS_RE_ERASED  = 1 << 12;\n \n-        const HAS_CT_INFER       = 1 << 13;\n-        const HAS_CT_PLACEHOLDER = 1 << 14;\n+        const HAS_TY_PLACEHOLDER = 1 << 13;\n+\n+        const HAS_CT_INFER       = 1 << 14;\n+        const HAS_CT_PLACEHOLDER = 1 << 15;\n+        /// Does this have any [Opaque] types.\n+        const HAS_TY_OPAQUE      = 1 << 16;\n \n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits;\n@@ -497,9 +502,11 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_LOCAL_NAMES.bits |\n                                   TypeFlags::KEEP_IN_LOCAL_TCX.bits |\n                                   TypeFlags::HAS_RE_LATE_BOUND.bits |\n+                                  TypeFlags::HAS_RE_ERASED.bits |\n                                   TypeFlags::HAS_TY_PLACEHOLDER.bits |\n                                   TypeFlags::HAS_CT_INFER.bits |\n-                                  TypeFlags::HAS_CT_PLACEHOLDER.bits;\n+                                  TypeFlags::HAS_CT_PLACEHOLDER.bits |\n+                                  TypeFlags::HAS_TY_OPAQUE.bits;\n     }\n }\n "}, {"sha": "02abac975ac841e4a2faeab812625928370332ec", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1777,7 +1777,9 @@ impl RegionKind {\n             ty::ReEmpty(_) | ty::ReStatic | ty::ReFree { .. } | ty::ReScope { .. } => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }\n-            ty::ReErased => {}\n+            ty::ReErased => {\n+                flags = flags | TypeFlags::HAS_RE_ERASED;\n+            }\n             ty::ReClosureBound(..) => {\n                 flags = flags | TypeFlags::HAS_FREE_REGIONS;\n             }"}, {"sha": "f3c3d04931ac3650f21f3ac47a775000a585626f", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -615,7 +615,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n                 if let ty::Opaque(def_id, substs) = t.kind {\n                     self.expand_opaque_ty(def_id, substs).unwrap_or(t)\n-                } else if t.has_projections() {\n+                } else if t.has_opaque_types() {\n                     t.super_fold_with(self)\n                 } else {\n                     t"}, {"sha": "426659fd92452371b2e54a4cc8a0d6c9a48c5dd7", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -272,7 +272,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let ty = self.lower_ty(\n                     t,\n                     if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None)\n+                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n                     } else {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n@@ -283,7 +283,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let ty = self.lower_ty(\n                     t,\n                     if self.sess.features_untracked().impl_trait_in_bindings {\n-                        ImplTraitContext::OpaqueTy(None)\n+                        ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc)\n                     } else {\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                     },\n@@ -327,8 +327,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }\n                 Some(bounds) => {\n                     let ty = hir::OpaqueTy {\n-                        generics: self.lower_generics(generics, ImplTraitContext::OpaqueTy(None)),\n-                        bounds: self.lower_param_bounds(bounds, ImplTraitContext::OpaqueTy(None)),\n+                        generics: self.lower_generics(\n+                            generics,\n+                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                        ),\n+                        bounds: self.lower_param_bounds(\n+                            bounds,\n+                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                        ),\n                         impl_trait_fn: None,\n                         origin: hir::OpaqueTyOrigin::TypeAlias,\n                     };"}, {"sha": "99de4b88fd3c4c007de72a88b2b1f6c9b5df9b1e", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -222,7 +222,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// We optionally store a `DefId` for the parent item here so we can look up necessary\n     /// information later. It is `None` when no information about the context should be stored\n     /// (e.g., for consts and statics).\n-    OpaqueTy(Option<DefId> /* fn def-ID */),\n+    OpaqueTy(Option<DefId> /* fn def-ID */, hir::OpaqueTyOrigin),\n \n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n@@ -248,7 +248,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n             Universal(params) => Universal(params),\n-            OpaqueTy(fn_def_id) => OpaqueTy(*fn_def_id),\n+            OpaqueTy(fn_def_id, origin) => OpaqueTy(*fn_def_id, *origin),\n             Disallowed(pos) => Disallowed(*pos),\n         }\n     }\n@@ -1010,7 +1010,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo() -> impl Iterator<Item = impl Debug>\n-                    ImplTraitContext::OpaqueTy(_) => (true, itctx),\n+                    ImplTraitContext::OpaqueTy(..) => (true, itctx),\n \n                     // We are in the argument position, but within a dyn type:\n                     //\n@@ -1019,7 +1019,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(_) if self.is_in_dyn_type => (true, itctx),\n+                    ImplTraitContext::Universal(..) if self.is_in_dyn_type => (true, itctx),\n \n                     // In `type Foo = dyn Iterator<Item: Debug>` we desugar to\n                     // `type Foo = dyn Iterator<Item = impl Debug>` but we have to override the\n@@ -1028,7 +1028,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     //\n                     // FIXME: this is only needed until `impl Trait` is allowed in type aliases.\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type => {\n-                        (true, ImplTraitContext::OpaqueTy(None))\n+                        (true, ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc))\n                     }\n \n                     // We are in the parameter position, but not within a dyn type:\n@@ -1269,8 +1269,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::ImplTrait(def_node_id, ref bounds) => {\n                 let span = t.span;\n                 match itctx {\n-                    ImplTraitContext::OpaqueTy(fn_def_id) => {\n-                        self.lower_opaque_impl_trait(span, fn_def_id, def_node_id, |this| {\n+                    ImplTraitContext::OpaqueTy(fn_def_id, origin) => {\n+                        self.lower_opaque_impl_trait(span, fn_def_id, origin, def_node_id, |this| {\n                             this.lower_param_bounds(bounds, itctx)\n                         })\n                     }\n@@ -1349,6 +1349,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         span: Span,\n         fn_def_id: Option<DefId>,\n+        origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n@@ -1390,7 +1391,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 },\n                 bounds: hir_bounds,\n                 impl_trait_fn: fn_def_id,\n-                origin: hir::OpaqueTyOrigin::FnReturn,\n+                origin,\n             };\n \n             trace!(\"lower_opaque_impl_trait: {:#?}\", opaque_ty_def_index);\n@@ -1622,7 +1623,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             self.lower_ty(\n                 t,\n                 if self.sess.features_untracked().impl_trait_in_bindings {\n-                    ImplTraitContext::OpaqueTy(Some(parent_def_id))\n+                    ImplTraitContext::OpaqueTy(Some(parent_def_id), hir::OpaqueTyOrigin::Misc)\n                 } else {\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Binding)\n                 },\n@@ -1722,14 +1723,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             )\n         } else {\n             match decl.output {\n-                FunctionRetTy::Ty(ref ty) => match in_band_ty_params {\n-                    Some((def_id, _)) if impl_trait_return_allow => hir::FunctionRetTy::Return(\n-                        self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(def_id))),\n-                    ),\n-                    _ => hir::FunctionRetTy::Return(\n-                        self.lower_ty(ty, ImplTraitContext::disallowed()),\n-                    ),\n-                },\n+                FunctionRetTy::Ty(ref ty) => {\n+                    let context = match in_band_ty_params {\n+                        Some((def_id, _)) if impl_trait_return_allow => {\n+                            ImplTraitContext::OpaqueTy(Some(def_id), hir::OpaqueTyOrigin::FnReturn)\n+                        }\n+                        _ => ImplTraitContext::disallowed(),\n+                    };\n+                    hir::FunctionRetTy::Return(self.lower_ty(ty, context))\n+                }\n                 FunctionRetTy::Default(span) => hir::FunctionRetTy::DefaultReturn(span),\n             }\n         };\n@@ -1957,7 +1959,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::GenericBound<'hir> {\n         // Compute the `T` in `Future<Output = T>` from the return type.\n         let output_ty = match output {\n-            FunctionRetTy::Ty(ty) => self.lower_ty(ty, ImplTraitContext::OpaqueTy(Some(fn_def_id))),\n+            FunctionRetTy::Ty(ty) => {\n+                // Not `OpaqueTyOrigin::AsyncFn`: that's only used for the\n+                // `impl Future` opaque type that `async fn` implicitly\n+                // generates.\n+                let context =\n+                    ImplTraitContext::OpaqueTy(Some(fn_def_id), hir::OpaqueTyOrigin::FnReturn);\n+                self.lower_ty(ty, context)\n+            }\n             FunctionRetTy::Default(ret_ty_span) => self.arena.alloc(self.ty_tup(*ret_ty_span, &[])),\n         };\n \n@@ -2102,9 +2111,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n \n                 let kind = hir::GenericParamKind::Type {\n-                    default: default\n-                        .as_ref()\n-                        .map(|x| self.lower_ty(x, ImplTraitContext::OpaqueTy(None))),\n+                    default: default.as_ref().map(|x| {\n+                        self.lower_ty(\n+                            x,\n+                            ImplTraitContext::OpaqueTy(None, hir::OpaqueTyOrigin::Misc),\n+                        )\n+                    }),\n                     synthetic: param\n                         .attrs\n                         .iter()"}, {"sha": "07a2c48225349d9c5c21c563a6a7e6c561d359d5", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1990,6 +1990,8 @@ pub enum OpaqueTyOrigin {\n     FnReturn,\n     /// `async fn`\n     AsyncFn,\n+    /// Impl trait in bindings, consts, statics, bounds.\n+    Misc,\n }\n \n /// The various kinds of types recognized by the compiler."}, {"sha": "b393d4bc2a5b36d72dfc723f38009c5bf60c556c", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -6,7 +6,6 @@ use rustc::infer::{\n use rustc::mir::ConstraintCategory;\n use rustc::ty::{self, RegionVid, Ty};\n use rustc_errors::{Applicability, DiagnosticBuilder};\n-use rustc_hir::def_id::DefId;\n use rustc_span::symbol::kw;\n use rustc_span::Span;\n \n@@ -58,8 +57,8 @@ crate enum RegionErrorKind<'tcx> {\n \n     /// An unexpected hidden region for an opaque type.\n     UnexpectedHiddenRegion {\n-        /// The def id of the opaque type.\n-        opaque_type_def_id: DefId,\n+        /// The span for the member constraint.\n+        span: Span,\n         /// The hidden type.\n         hidden_ty: Ty<'tcx>,\n         /// The unexpected region.\n@@ -194,18 +193,16 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     }\n                 }\n \n-                RegionErrorKind::UnexpectedHiddenRegion {\n-                    opaque_type_def_id,\n-                    hidden_ty,\n-                    member_region,\n-                } => {\n+                RegionErrorKind::UnexpectedHiddenRegion { span, hidden_ty, member_region } => {\n                     let region_scope_tree = &self.infcx.tcx.region_scope_tree(self.mir_def_id);\n+                    let named_ty = self.regioncx.name_regions(self.infcx.tcx, hidden_ty);\n+                    let named_region = self.regioncx.name_regions(self.infcx.tcx, member_region);\n                     opaque_types::unexpected_hidden_region_diagnostic(\n                         self.infcx.tcx,\n                         Some(region_scope_tree),\n-                        opaque_type_def_id,\n-                        hidden_ty,\n-                        member_region,\n+                        span,\n+                        named_ty,\n+                        named_region,\n                     )\n                     .buffer(&mut self.errors_buffer);\n                 }\n@@ -588,6 +585,10 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                             {\n                                 found = true;\n                                 break;\n+                            } else {\n+                                // If there's already a lifetime bound, don't\n+                                // suggest anything.\n+                                return;\n                             }\n                         }\n                     }"}, {"sha": "f9db62e0a3a42321058069d51ae7aa5d8d38ed49", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -90,7 +90,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers { mir_borrowck, ..*providers };\n }\n \n-fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n+fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> &BorrowCheckResult<'_> {\n     let (input_body, promoted) = tcx.mir_validated(def_id);\n     debug!(\"run query mir_borrowck: {}\", tcx.def_path_str(def_id));\n \n@@ -101,7 +101,7 @@ fn mir_borrowck(tcx: TyCtxt<'_>, def_id: DefId) -> BorrowCheckResult<'_> {\n     });\n     debug!(\"mir_borrowck done\");\n \n-    opt_closure_req\n+    tcx.arena.alloc(opt_closure_req)\n }\n \n fn do_mir_borrowck<'a, 'tcx>(\n@@ -136,6 +136,9 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     // Gather the upvars of a closure, if any.\n     let tables = tcx.typeck_tables_of(def_id);\n+    if tables.tainted_by_errors {\n+        infcx.set_tainted_by_errors();\n+    }\n     let upvars: Vec<_> = tables\n         .upvar_list\n         .get(&def_id)\n@@ -195,27 +198,40 @@ fn do_mir_borrowck<'a, 'tcx>(\n         Rc::new(BorrowSet::build(tcx, body, locals_are_invalidated_at_exit, &mdpe.move_data));\n \n     // Compute non-lexical lifetimes.\n-    let nll::NllOutput { regioncx, polonius_output, opt_closure_req, nll_errors } =\n-        nll::compute_regions(\n-            infcx,\n-            def_id,\n-            free_regions,\n-            body,\n-            &promoted,\n-            location_table,\n-            param_env,\n-            &mut flow_inits,\n-            &mdpe.move_data,\n-            &borrow_set,\n-        );\n+    let nll::NllOutput {\n+        regioncx,\n+        opaque_type_values,\n+        polonius_output,\n+        opt_closure_req,\n+        nll_errors,\n+    } = nll::compute_regions(\n+        infcx,\n+        def_id,\n+        free_regions,\n+        body,\n+        &promoted,\n+        location_table,\n+        param_env,\n+        &mut flow_inits,\n+        &mdpe.move_data,\n+        &borrow_set,\n+    );\n \n     // Dump MIR results into a file, if that is enabled. This let us\n     // write unit-tests, as well as helping with debugging.\n     nll::dump_mir_results(infcx, MirSource::item(def_id), &body, &regioncx, &opt_closure_req);\n \n-    // We also have a `#[rustc_nll]` annotation that causes us to dump\n+    // We also have a `#[rustc_regions]` annotation that causes us to dump\n     // information.\n-    nll::dump_annotation(infcx, &body, def_id, &regioncx, &opt_closure_req, &mut errors_buffer);\n+    nll::dump_annotation(\n+        infcx,\n+        &body,\n+        def_id,\n+        &regioncx,\n+        &opt_closure_req,\n+        &opaque_type_values,\n+        &mut errors_buffer,\n+    );\n \n     // The various `flow_*` structures can be large. We drop `flow_inits` here\n     // so it doesn't overlap with the others below. This reduces peak memory\n@@ -389,6 +405,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     }\n \n     let result = BorrowCheckResult {\n+        concrete_opaque_types: opaque_type_values,\n         closure_requirements: opt_closure_req,\n         used_mut_upvars: mbcx.used_mut_upvars,\n     };"}, {"sha": "101d1856c38f2cf243577e88d1751ce9fc97dfbb", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -6,6 +6,7 @@ use rustc::mir::{\n     Location, Promoted, ReadOnlyBodyAndCache,\n };\n use rustc::ty::{self, RegionKind, RegionVid};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Diagnostic;\n use rustc_hir::def_id::DefId;\n use rustc_index::vec::IndexVec;\n@@ -46,6 +47,7 @@ crate type PoloniusOutput = Output<RustcFacts>;\n /// closure requirements to propagate, and any generated errors.\n crate struct NllOutput<'tcx> {\n     pub regioncx: RegionInferenceContext<'tcx>,\n+    pub opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     pub polonius_output: Option<Rc<PoloniusOutput>>,\n     pub opt_closure_req: Option<ClosureRegionRequirements<'tcx>>,\n     pub nll_errors: RegionErrors<'tcx>,\n@@ -160,20 +162,21 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     let elements = &Rc::new(RegionValueElements::new(&body));\n \n     // Run the MIR type-checker.\n-    let MirTypeckResults { constraints, universal_region_relations } = type_check::type_check(\n-        infcx,\n-        param_env,\n-        body,\n-        promoted,\n-        def_id,\n-        &universal_regions,\n-        location_table,\n-        borrow_set,\n-        &mut all_facts,\n-        flow_inits,\n-        move_data,\n-        elements,\n-    );\n+    let MirTypeckResults { constraints, universal_region_relations, opaque_type_values } =\n+        type_check::type_check(\n+            infcx,\n+            param_env,\n+            body,\n+            promoted,\n+            def_id,\n+            &universal_regions,\n+            location_table,\n+            borrow_set,\n+            &mut all_facts,\n+            flow_inits,\n+            move_data,\n+            elements,\n+        );\n \n     if let Some(all_facts) = &mut all_facts {\n         let _prof_timer = infcx.tcx.prof.generic_activity(\"polonius_fact_generation\");\n@@ -279,8 +282,16 @@ pub(in crate::borrow_check) fn compute_regions<'cx, 'tcx>(\n     let (closure_region_requirements, nll_errors) =\n         regioncx.solve(infcx, &body, def_id, polonius_output.clone());\n \n+    if !nll_errors.is_empty() {\n+        // Suppress unhelpful extra errors in `infer_opaque_types`.\n+        infcx.set_tainted_by_errors();\n+    }\n+\n+    let remapped_opaque_tys = regioncx.infer_opaque_types(&infcx, opaque_type_values, body.span);\n+\n     NllOutput {\n         regioncx,\n+        opaque_type_values: remapped_opaque_tys,\n         polonius_output,\n         opt_closure_req: closure_region_requirements,\n         nll_errors,\n@@ -344,6 +355,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     mir_def_id: DefId,\n     regioncx: &RegionInferenceContext<'tcx>,\n     closure_region_requirements: &Option<ClosureRegionRequirements<'_>>,\n+    opaque_type_values: &FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n     errors_buffer: &mut Vec<Diagnostic>,\n ) {\n     let tcx = infcx.tcx;\n@@ -359,7 +371,7 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n     // viewing the intraprocedural state, the -Zdump-mir output is\n     // better.\n \n-    if let Some(closure_region_requirements) = closure_region_requirements {\n+    let mut err = if let Some(closure_region_requirements) = closure_region_requirements {\n         let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"external requirements\");\n \n         regioncx.annotate(tcx, &mut err);\n@@ -377,13 +389,19 @@ pub(super) fn dump_annotation<'a, 'tcx>(\n         })\n         .unwrap();\n \n-        err.buffer(errors_buffer);\n+        err\n     } else {\n         let mut err = tcx.sess.diagnostic().span_note_diag(body.span, \"no external requirements\");\n         regioncx.annotate(tcx, &mut err);\n \n-        err.buffer(errors_buffer);\n+        err\n+    };\n+\n+    if !opaque_type_values.is_empty() {\n+        err.note(&format!(\"Inferred opaque type values:\\n{:#?}\", opaque_type_values));\n     }\n+\n+    err.buffer(errors_buffer);\n }\n \n fn for_each_region_constraint("}, {"sha": "192e4700b91f66da05ff47b3a6558764529748cc", "filename": "src/librustc_mir/borrow_check/region_infer/mod.rs", "status": "modified", "additions": 18, "deletions": 42, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -12,8 +12,6 @@ use rustc::ty::{self, subst::SubstsRef, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc_data_structures::binary_search_util;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::scc::Sccs;\n-use rustc_data_structures::graph::vec_graph::VecGraph;\n-use rustc_data_structures::graph::WithSuccessors;\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n@@ -26,6 +24,7 @@ use crate::borrow_check::{\n     diagnostics::{RegionErrorKind, RegionErrors},\n     member_constraints::{MemberConstraintSet, NllMemberConstraintIndex},\n     nll::{PoloniusOutput, ToRegionVid},\n+    region_infer::reverse_sccs::ReverseSccGraph,\n     region_infer::values::{\n         LivenessValues, PlaceholderIndices, RegionElement, RegionValueElements, RegionValues,\n         ToElementIndex,\n@@ -36,6 +35,8 @@ use crate::borrow_check::{\n \n mod dump_mir;\n mod graphviz;\n+mod opaque_types;\n+mod reverse_sccs;\n \n pub mod values;\n \n@@ -65,9 +66,10 @@ pub struct RegionInferenceContext<'tcx> {\n     /// compute the values of each region.\n     constraint_sccs: Rc<Sccs<RegionVid, ConstraintSccIndex>>,\n \n-    /// Reverse of the SCC constraint graph -- i.e., an edge `A -> B`\n-    /// exists if `B: A`. Computed lazilly.\n-    rev_constraint_graph: Option<Rc<VecGraph<ConstraintSccIndex>>>,\n+    /// Reverse of the SCC constraint graph --  i.e., an edge `A -> B` exists if\n+    /// `B: A`. This is used to compute the universal regions that are required\n+    /// to outlive a given SCC. Computed lazily.\n+    rev_scc_graph: Option<Rc<ReverseSccGraph>>,\n \n     /// The \"R0 member of [R1..Rn]\" constraints, indexed by SCC.\n     member_constraints: Rc<MemberConstraintSet<'tcx, ConstraintSccIndex>>,\n@@ -287,7 +289,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             constraints,\n             constraint_graph,\n             constraint_sccs,\n-            rev_constraint_graph: None,\n+            rev_scc_graph: None,\n             member_constraints,\n             member_constraints_applied: Vec::new(),\n             closure_bounds_mapping,\n@@ -510,7 +512,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             self.check_universal_regions(body, outlives_requirements.as_mut(), &mut errors_buffer);\n         }\n \n-        self.check_member_constraints(infcx, &mut errors_buffer);\n+        if errors_buffer.is_empty() {\n+            self.check_member_constraints(infcx, &mut errors_buffer);\n+        }\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -677,15 +681,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // free region that must outlive the member region `R0` (`UB:\n         // R0`). Therefore, we need only keep an option `O` if `UB: O`\n         // for all UB.\n-        if choice_regions.len() > 1 {\n-            let universal_region_relations = self.universal_region_relations.clone();\n-            let rev_constraint_graph = self.rev_constraint_graph();\n-            for ub in self.upper_bounds(scc, &rev_constraint_graph) {\n-                debug!(\"apply_member_constraint: ub={:?}\", ub);\n-                choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n-            }\n-            debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n+        let rev_scc_graph = self.reverse_scc_graph();\n+        let universal_region_relations = &self.universal_region_relations;\n+        for ub in rev_scc_graph.upper_bounds(scc) {\n+            debug!(\"apply_member_constraint: ub={:?}\", ub);\n+            choice_regions.retain(|&o_r| universal_region_relations.outlives(ub, o_r));\n         }\n+        debug!(\"apply_member_constraint: after ub, choice_regions={:?}\", choice_regions);\n \n         // If we ruled everything out, we're done.\n         if choice_regions.is_empty() {\n@@ -741,32 +743,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         }\n     }\n \n-    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n-    fn upper_bounds(\n-        &'a mut self,\n-        scc0: ConstraintSccIndex,\n-        rev_constraint_graph: &'a VecGraph<ConstraintSccIndex>,\n-    ) -> impl Iterator<Item = RegionVid> + 'a {\n-        let scc_values = &self.scc_values;\n-        let mut duplicates = FxHashSet::default();\n-        rev_constraint_graph\n-            .depth_first_search(scc0)\n-            .skip(1)\n-            .flat_map(move |scc1| scc_values.universal_regions_outlived_by(scc1))\n-            .filter(move |&r| duplicates.insert(r))\n-    }\n-\n-    /// Compute and return the reverse SCC-based constraint graph (lazilly).\n-    fn rev_constraint_graph(&mut self) -> Rc<VecGraph<ConstraintSccIndex>> {\n-        if let Some(g) = &self.rev_constraint_graph {\n-            return g.clone();\n-        }\n-\n-        let rev_graph = Rc::new(self.constraint_sccs.reverse());\n-        self.rev_constraint_graph = Some(rev_graph.clone());\n-        rev_graph\n-    }\n-\n     /// Returns `true` if all the elements in the value of `scc_b` are nameable\n     /// in `scc_a`. Used during constraint propagation, and only once\n     /// the value of `scc_b` has been computed.\n@@ -1603,7 +1579,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // If not, report an error.\n             let member_region = infcx.tcx.mk_region(ty::ReVar(member_region_vid));\n             errors_buffer.push(RegionErrorKind::UnexpectedHiddenRegion {\n-                opaque_type_def_id: m_c.opaque_type_def_id,\n+                span: m_c.definition_span,\n                 hidden_ty: m_c.hidden_ty,\n                 member_region,\n             });"}, {"sha": "52d54f7b53c79e490fd63193c6743396c7ad8e78", "filename": "src/librustc_mir/borrow_check/region_infer/opaque_types.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Fopaque_types.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,149 @@\n+use rustc::infer::InferCtxt;\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::Span;\n+\n+use super::RegionInferenceContext;\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Resolve any opaque types that were encountered while borrow checking\n+    /// this item. This is then used to get the type in the `type_of` query.\n+    ///\n+    /// For example consider `fn f<'a>(x: &'a i32) -> impl Sized + 'a { x }`.\n+    /// This is lowered to give HIR something like\n+    ///\n+    /// type f<'a>::_Return<'_a> = impl Sized + '_a;\n+    /// fn f<'a>(x: &'a i32) -> f<'static>::_Return<'a> { x }\n+    ///\n+    /// When checking the return type record the type from the return and the\n+    /// type used in the return value. In this case they might be `_Return<'1>`\n+    /// and `&'2 i32` respectively.\n+    ///\n+    /// Once we to this method, we have completed region inference and want to\n+    /// call `infer_opaque_definition_from_instantiation` to get the inferred\n+    /// type of `_Return<'_a>`. `infer_opaque_definition_from_instantiation`\n+    /// compares lifetimes directly, so we need to map the inference variables\n+    /// back to concrete lifetimes: `'static`, `ReEarlyBound` or `ReFree`.\n+    ///\n+    /// First we map all the lifetimes in the concrete type to an equal\n+    /// universal region that occurs in the concrete type's substs, in this case\n+    /// this would result in `&'1 i32`. We only consider regions in the substs\n+    /// in case there is an equal region that does not. For example, this should\n+    /// be allowed:\n+    /// `fn f<'a: 'b, 'b: 'a>(x: *mut &'b i32) -> impl Sized + 'a { x }`\n+    ///\n+    /// Then we map the regions in both the type and the subst to their\n+    /// `external_name` giving `concrete_type = &'a i32`,\n+    /// `substs = ['static, 'a]`. This will then allow\n+    /// `infer_opaque_definition_from_instantiation` to determine that\n+    /// `_Return<'_a> = &'_a i32`.\n+    ///\n+    /// There's a slight complication around closures. Given\n+    /// `fn f<'a: 'a>() { || {} }` the closure's type is something like\n+    /// `f::<'a>::{{closure}}`. The region parameter from f is essentially\n+    /// ignored by type checking so ends up being inferred to an empty region.\n+    /// Calling `universal_upper_bound` for such a region gives `fr_fn_body`,\n+    /// which has no `external_name` in which case we use `'empty` as the\n+    /// region to pass to `infer_opaque_definition_from_instantiation`.\n+    pub(in crate::borrow_check) fn infer_opaque_types(\n+        &self,\n+        infcx: &InferCtxt<'_, 'tcx>,\n+        opaque_ty_decls: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n+        span: Span,\n+    ) -> FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>> {\n+        opaque_ty_decls\n+            .into_iter()\n+            .map(|(opaque_def_id, ty::ResolvedOpaqueTy { concrete_type, substs })| {\n+                debug!(\n+                    \"infer_opaque_types(concrete_type = {:?}, substs = {:?})\",\n+                    concrete_type, substs\n+                );\n+\n+                let mut subst_regions = vec![self.universal_regions.fr_static];\n+                let universal_substs =\n+                    infcx.tcx.fold_regions(&substs, &mut false, |region, _| match *region {\n+                        ty::ReVar(vid) => {\n+                            subst_regions.push(vid);\n+                            self.definitions[vid].external_name.unwrap_or_else(|| {\n+                                infcx.tcx.sess.delay_span_bug(\n+                                    span,\n+                                    \"opaque type with non-universal region substs\",\n+                                );\n+                                infcx.tcx.lifetimes.re_static\n+                            })\n+                        }\n+                        // We don't fold regions in the predicates of opaque\n+                        // types to `ReVar`s. This means that in a case like\n+                        //\n+                        // fn f<'a: 'a>() -> impl Iterator<Item = impl Sized>\n+                        //\n+                        // The inner opaque type has `'static` in its substs.\n+                        ty::ReStatic => region,\n+                        _ => {\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\"unexpected concrete region in borrowck: {:?}\", region),\n+                            );\n+                            region\n+                        }\n+                    });\n+\n+                subst_regions.sort();\n+                subst_regions.dedup();\n+\n+                let universal_concrete_type =\n+                    infcx.tcx.fold_regions(&concrete_type, &mut false, |region, _| match *region {\n+                        ty::ReVar(vid) => subst_regions\n+                            .iter()\n+                            .find(|ur_vid| self.eval_equal(vid, **ur_vid))\n+                            .and_then(|ur_vid| self.definitions[*ur_vid].external_name)\n+                            .unwrap_or(infcx.tcx.lifetimes.re_root_empty),\n+                        ty::ReLateBound(..) => region,\n+                        _ => {\n+                            infcx.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\"unexpected concrete region in borrowck: {:?}\", region),\n+                            );\n+                            region\n+                        }\n+                    });\n+\n+                debug!(\n+                    \"infer_opaque_types(universal_concrete_type = {:?}, universal_substs = {:?})\",\n+                    universal_concrete_type, universal_substs\n+                );\n+\n+                let remapped_type = infcx.infer_opaque_definition_from_instantiation(\n+                    opaque_def_id,\n+                    universal_substs,\n+                    universal_concrete_type,\n+                    span,\n+                );\n+                (\n+                    opaque_def_id,\n+                    ty::ResolvedOpaqueTy { concrete_type: remapped_type, substs: universal_substs },\n+                )\n+            })\n+            .collect()\n+    }\n+\n+    /// Map the regions in the type to named regions. This is similar to what\n+    /// `infer_opaque_types` does, but can infer any universal region, not only\n+    /// ones from the substs for the opaque type. It also doesn't double check\n+    /// that the regions produced are in fact equal to the named region they are\n+    /// replaced with. This is fine because this function is only to improve the\n+    /// region names in error messages.\n+    pub(in crate::borrow_check) fn name_regions<T>(&self, tcx: TyCtxt<'tcx>, ty: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        tcx.fold_regions(&ty, &mut false, |region, _| match *region {\n+            ty::ReVar(vid) => {\n+                let upper_bound = self.universal_upper_bound(vid);\n+                self.definitions[upper_bound].external_name.unwrap_or(region)\n+            }\n+            _ => region,\n+        })\n+    }\n+}"}, {"sha": "4b8357bda0280f66ea76399ca02880f21d512181", "filename": "src/librustc_mir/borrow_check/region_infer/reverse_sccs.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fregion_infer%2Freverse_sccs.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,68 @@\n+use crate::borrow_check::constraints::ConstraintSccIndex;\n+use crate::borrow_check::RegionInferenceContext;\n+use itertools::Itertools;\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::graph::vec_graph::VecGraph;\n+use rustc_data_structures::graph::WithSuccessors;\n+use std::ops::Range;\n+use std::rc::Rc;\n+\n+crate struct ReverseSccGraph {\n+    graph: VecGraph<ConstraintSccIndex>,\n+    /// For each SCC, the range of `universal_regions` that use that SCC as\n+    /// their value.\n+    scc_regions: FxHashMap<ConstraintSccIndex, Range<usize>>,\n+    /// All of the universal regions, in grouped so that `scc_regions` can\n+    /// index into here.\n+    universal_regions: Vec<RegionVid>,\n+}\n+\n+impl ReverseSccGraph {\n+    /// Find all universal regions that are required to outlive the given SCC.\n+    pub(super) fn upper_bounds<'a>(\n+        &'a self,\n+        scc0: ConstraintSccIndex,\n+    ) -> impl Iterator<Item = RegionVid> + 'a {\n+        let mut duplicates = FxHashSet::default();\n+        self.graph\n+            .depth_first_search(scc0)\n+            .flat_map(move |scc1| {\n+                self.scc_regions\n+                    .get(&scc1)\n+                    .map_or(&[][..], |range| &self.universal_regions[range.clone()])\n+            })\n+            .copied()\n+            .filter(move |r| duplicates.insert(*r))\n+    }\n+}\n+\n+impl RegionInferenceContext<'_> {\n+    /// Compute and return the reverse SCC-based constraint graph (lazily).\n+    pub(super) fn reverse_scc_graph(&mut self) -> Rc<ReverseSccGraph> {\n+        if let Some(g) = &self.rev_scc_graph {\n+            return g.clone();\n+        }\n+\n+        let graph = self.constraint_sccs.reverse();\n+        let mut paired_scc_regions = self\n+            .universal_regions\n+            .universal_regions()\n+            .map(|region| (self.constraint_sccs.scc(region), region))\n+            .collect_vec();\n+        paired_scc_regions.sort();\n+        let universal_regions = paired_scc_regions.iter().map(|&(_, region)| region).collect();\n+\n+        let mut scc_regions = FxHashMap::default();\n+        let mut start = 0;\n+        for (scc, group) in &paired_scc_regions.into_iter().group_by(|(scc, _)| *scc) {\n+            let group_size = group.into_iter().count();\n+            scc_regions.insert(scc, start..start + group_size);\n+            start += group_size;\n+        }\n+\n+        let rev_graph = Rc::new(ReverseSccGraph { graph, scc_regions, universal_regions });\n+        self.rev_scc_graph = Some(rev_graph.clone());\n+        rev_graph\n+    }\n+}"}, {"sha": "88fe6d1a3a49d37f6bbd686bedfd7b76f784ca4b", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 104, "deletions": 38, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -6,6 +6,7 @@ use std::{fmt, iter, mem};\n use either::Either;\n \n use rustc::infer::canonical::QueryRegionConstraints;\n+use rustc::infer::opaque_types::GenerateMemberConstraints;\n use rustc::infer::outlives::env::RegionBoundPairs;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionVariableOrigin};\n@@ -158,7 +159,7 @@ pub(crate) fn type_check<'mir, 'tcx>(\n         constraints: &mut constraints,\n     };\n \n-    type_check_internal(\n+    let opaque_type_values = type_check_internal(\n         infcx,\n         mir_def_id,\n         param_env,\n@@ -173,10 +174,11 @@ pub(crate) fn type_check<'mir, 'tcx>(\n             liveness::generate(&mut cx, body, elements, flow_inits, move_data, location_table);\n \n             translate_outlives_facts(&mut cx);\n+            cx.opaque_type_values\n         },\n     );\n \n-    MirTypeckResults { constraints, universal_region_relations }\n+    MirTypeckResults { constraints, universal_region_relations, opaque_type_values }\n }\n \n fn type_check_internal<'a, 'tcx, R>(\n@@ -189,7 +191,7 @@ fn type_check_internal<'a, 'tcx, R>(\n     implicit_region_bound: ty::Region<'tcx>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n-    mut extra: impl FnMut(&mut TypeChecker<'a, 'tcx>) -> R,\n+    extra: impl FnOnce(TypeChecker<'a, 'tcx>) -> R,\n ) -> R {\n     let mut checker = TypeChecker::new(\n         infcx,\n@@ -212,7 +214,7 @@ fn type_check_internal<'a, 'tcx, R>(\n         checker.typeck_mir(body);\n     }\n \n-    extra(&mut checker)\n+    extra(checker)\n }\n \n fn translate_outlives_facts(typeck: &mut TypeChecker<'_, '_>) {\n@@ -799,6 +801,7 @@ struct TypeChecker<'a, 'tcx> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: &'a mut BorrowCheckContext<'a, 'tcx>,\n     universal_region_relations: &'a UniversalRegionRelations<'tcx>,\n+    opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx> {\n@@ -812,6 +815,7 @@ struct BorrowCheckContext<'a, 'tcx> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n+    crate opaque_type_values: FxHashMap<DefId, ty::ResolvedOpaqueTy<'tcx>>,\n }\n \n /// A collection of region constraints that must be satisfied for the\n@@ -958,6 +962,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n+            opaque_type_values: FxHashMap::default(),\n         };\n         checker.check_user_type_annotations();\n         checker\n@@ -1191,10 +1196,29 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n              anon_ty={:?})\",\n             revealed_ty, anon_ty\n         );\n+\n+        // Fast path for the common case.\n+        if !anon_ty.has_opaque_types() {\n+            if let Err(terr) = self.eq_types(anon_ty, revealed_ty, locations, category) {\n+                span_mirbug!(\n+                    self,\n+                    locations,\n+                    \"eq_opaque_type_and_type: `{:?}=={:?}` failed with `{:?}`\",\n+                    revealed_ty,\n+                    anon_ty,\n+                    terr\n+                );\n+            }\n+            return Ok(());\n+        }\n+\n         let infcx = self.infcx;\n         let tcx = infcx.tcx;\n         let param_env = self.param_env;\n         let body = self.body;\n+        let concrete_opaque_types = &tcx.typeck_tables_of(anon_owner_def_id).concrete_opaque_types;\n+        let mut opaque_type_values = Vec::new();\n+\n         debug!(\"eq_opaque_type_and_type: mir_def_id={:?}\", self.mir_def_id);\n         let opaque_type_map = self.fully_perform_op(\n             locations,\n@@ -1219,54 +1243,92 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                          revealed_ty={:?}\",\n                         output_ty, opaque_type_map, revealed_ty\n                     );\n+                    // Make sure that the inferred types are well-formed. I'm\n+                    // not entirely sure this is needed (the HIR type check\n+                    // didn't do this) but it seems sensible to prevent opaque\n+                    // types hiding ill-formed types.\n+                    obligations.obligations.push(traits::Obligation::new(\n+                        ObligationCause::dummy(),\n+                        param_env,\n+                        ty::Predicate::WellFormed(revealed_ty),\n+                    ));\n                     obligations.add(\n                         infcx\n                             .at(&ObligationCause::dummy(), param_env)\n                             .eq(output_ty, revealed_ty)?,\n                     );\n \n                     for (&opaque_def_id, opaque_decl) in &opaque_type_map {\n-                        let opaque_defn_ty = tcx.type_of(opaque_def_id);\n-                        let opaque_defn_ty = opaque_defn_ty.subst(tcx, opaque_decl.substs);\n-                        let opaque_defn_ty = renumber::renumber_regions(infcx, &opaque_defn_ty);\n-                        let concrete_is_opaque = infcx\n-                            .resolve_vars_if_possible(&opaque_decl.concrete_ty)\n-                            .is_impl_trait();\n+                        let resolved_ty = infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty);\n+                        let concrete_is_opaque = if let ty::Opaque(def_id, _) = resolved_ty.kind {\n+                            def_id == opaque_def_id\n+                        } else {\n+                            false\n+                        };\n+                        let opaque_defn_ty = match concrete_opaque_types.get(&opaque_def_id) {\n+                            None => {\n+                                if !concrete_is_opaque {\n+                                    tcx.sess.delay_span_bug(\n+                                        body.span,\n+                                        &format!(\n+                                            \"Non-defining use of {:?} with revealed type\",\n+                                            opaque_def_id,\n+                                        ),\n+                                    );\n+                                }\n+                                continue;\n+                            }\n+                            Some(opaque_defn_ty) => opaque_defn_ty,\n+                        };\n+                        debug!(\"opaque_defn_ty = {:?}\", opaque_defn_ty);\n+                        let subst_opaque_defn_ty =\n+                            opaque_defn_ty.concrete_type.subst(tcx, opaque_decl.substs);\n+                        let renumbered_opaque_defn_ty =\n+                            renumber::renumber_regions(infcx, &subst_opaque_defn_ty);\n \n                         debug!(\n-                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?} \\\n-                            concrete_is_opaque={}\",\n-                            opaque_decl.concrete_ty,\n-                            infcx.resolve_vars_if_possible(&opaque_decl.concrete_ty),\n-                            opaque_defn_ty,\n-                            concrete_is_opaque\n+                            \"eq_opaque_type_and_type: concrete_ty={:?}={:?} opaque_defn_ty={:?}\",\n+                            opaque_decl.concrete_ty, resolved_ty, renumbered_opaque_defn_ty,\n                         );\n \n-                        // concrete_is_opaque is `true` when we're using an opaque `impl Trait`\n-                        // type without 'revealing' it. For example, code like this:\n-                        //\n-                        // type Foo = impl Debug;\n-                        // fn foo1() -> Foo { ... }\n-                        // fn foo2() -> Foo { foo1() }\n-                        //\n-                        // In `foo2`, we're not revealing the type of `Foo` - we're\n-                        // just treating it as the opaque type.\n-                        //\n-                        // When this occurs, we do *not* want to try to equate\n-                        // the concrete type with the underlying defining type\n-                        // of the opaque type - this will always fail, since\n-                        // the defining type of an opaque type is always\n-                        // some other type (e.g. not itself)\n-                        // Essentially, none of the normal obligations apply here -\n-                        // we're just passing around some unknown opaque type,\n-                        // without actually looking at the underlying type it\n-                        // gets 'revealed' into\n-\n                         if !concrete_is_opaque {\n+                            // Equate concrete_ty (an inference variable) with\n+                            // the renumbered type from typeck.\n                             obligations.add(\n                                 infcx\n                                     .at(&ObligationCause::dummy(), param_env)\n-                                    .eq(opaque_decl.concrete_ty, opaque_defn_ty)?,\n+                                    .eq(opaque_decl.concrete_ty, renumbered_opaque_defn_ty)?,\n+                            );\n+                            opaque_type_values.push((\n+                                opaque_def_id,\n+                                ty::ResolvedOpaqueTy {\n+                                    concrete_type: renumbered_opaque_defn_ty,\n+                                    substs: opaque_decl.substs,\n+                                },\n+                            ));\n+                        } else {\n+                            // We're using an opaque `impl Trait` type without\n+                            // 'revealing' it. For example, code like this:\n+                            //\n+                            // type Foo = impl Debug;\n+                            // fn foo1() -> Foo { ... }\n+                            // fn foo2() -> Foo { foo1() }\n+                            //\n+                            // In `foo2`, we're not revealing the type of `Foo` - we're\n+                            // just treating it as the opaque type.\n+                            //\n+                            // When this occurs, we do *not* want to try to equate\n+                            // the concrete type with the underlying defining type\n+                            // of the opaque type - this will always fail, since\n+                            // the defining type of an opaque type is always\n+                            // some other type (e.g. not itself)\n+                            // Essentially, none of the normal obligations apply here -\n+                            // we're just passing around some unknown opaque type,\n+                            // without actually looking at the underlying type it\n+                            // gets 'revealed' into\n+                            debug!(\n+                                \"eq_opaque_type_and_type: non-defining use of {:?}\",\n+                                opaque_def_id,\n                             );\n                         }\n                     }\n@@ -1282,6 +1344,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n             ),\n         )?;\n \n+        self.opaque_type_values.extend(opaque_type_values);\n+\n         let universal_region_relations = self.universal_region_relations;\n \n         // Finally, if we instantiated the anon types successfully, we\n@@ -1298,6 +1362,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             infcx.constrain_opaque_type(\n                                 opaque_def_id,\n                                 &opaque_decl,\n+                                GenerateMemberConstraints::IfNoStaticBound,\n                                 universal_region_relations,\n                             );\n                             Ok(InferOk { value: (), obligations: vec![] })\n@@ -2512,7 +2577,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+        if let Some(ref closure_region_requirements) = tcx.mir_borrowck(def_id).closure_requirements\n+        {\n             let closure_constraints = QueryRegionConstraints {\n                 outlives: closure_region_requirements.apply_requirements(tcx, def_id, substs),\n "}, {"sha": "fab55018d3099ba531a1e385bd879a5875590a4a", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -178,6 +178,16 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n     }\n \n     fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n+        // prevent\n+        // * `&mut x.field`\n+        // * `x.field = y;`\n+        // * `&x.field` if `field`'s type has interior mutability\n+        // because either of these would allow modifying the layout constrained field and\n+        // insert values that violate the layout constraints.\n+        if context.is_mutating_use() || context.is_borrow() {\n+            self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n+        }\n+\n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n \n@@ -198,24 +208,9 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            let is_borrow_of_interior_mut = context.is_borrow()\n-                && !Place::ty_from(place.local, proj_base, self.body, self.tcx).ty.is_freeze(\n-                    self.tcx,\n-                    self.param_env,\n-                    self.source_info.span,\n-                );\n-            // prevent\n-            // * `&mut x.field`\n-            // * `x.field = y;`\n-            // * `&x.field` if `field`'s type has interior mutability\n-            // because either of these would allow modifying the layout constrained field and\n-            // insert values that violate the layout constraints.\n-            if context.is_mutating_use() || is_borrow_of_interior_mut {\n-                self.check_mut_borrowing_layout_constrained_field(place, context.is_mutating_use());\n-            }\n             let old_source_info = self.source_info;\n-            if let (local, []) = (&place.local, proj_base) {\n-                let decl = &self.body.local_decls[*local];\n+            if let [] = proj_base {\n+                let decl = &self.body.local_decls[place.local];\n                 if decl.internal {\n                     if let LocalInfo::StaticRef { def_id, .. } = decl.local_info {\n                         if self.tcx.is_mutable_static(def_id) {\n@@ -240,7 +235,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n                         // desugaring, rather than the source info of the RHS.\n-                        self.source_info = self.body.local_decls[*local].source_info;\n+                        self.source_info = self.body.local_decls[place.local].source_info;\n                     }\n                 }\n             }\n@@ -396,6 +391,9 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n             cursor = proj_base;\n \n             match elem {\n+                // Modifications behind a dereference don't affect the value of\n+                // the pointer.\n+                ProjectionElem::Deref => return,\n                 ProjectionElem::Field(..) => {\n                     let ty =\n                         Place::ty_from(place.local, proj_base, &self.body.local_decls, self.tcx).ty;\n@@ -409,14 +407,23 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                         \"mutating layout constrained fields cannot statically be \\\n                                         checked for valid values\",\n                                     )\n-                                } else {\n+\n+                                // Check `is_freeze` as late as possible to avoid cycle errors\n+                                // with opaque types.\n+                                } else if !place.ty(self.body, self.tcx).ty.is_freeze(\n+                                    self.tcx,\n+                                    self.param_env,\n+                                    self.source_info.span,\n+                                ) {\n                                     (\n                                         \"borrow of layout constrained field with interior \\\n                                         mutability\",\n                                         \"references to fields of layout constrained fields \\\n                                         lose the constraints. Coupled with interior mutability, \\\n                                         the field can be changed to invalid values\",\n                                     )\n+                                } else {\n+                                    continue;\n                                 };\n                                 self.require_unsafe(\n                                     description,"}, {"sha": "5f8c0b027e96a036dc3d231daffe8ca691f9e990", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -670,14 +670,51 @@ fn construct_const<'a, 'tcx>(\n     builder.finish()\n }\n \n+/// Construct MIR for a item that has had errors in type checking.\n+///\n+/// This is required because we may still want to run MIR passes on an item\n+/// with type errors, but normal MIR construction can't handle that in general.\n fn construct_error<'a, 'tcx>(hir: Cx<'a, 'tcx>, body_id: hir::BodyId) -> Body<'tcx> {\n-    let owner_id = hir.tcx().hir().body_owner(body_id);\n-    let span = hir.tcx().hir().span(owner_id);\n-    let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, span, None);\n+    let tcx = hir.tcx();\n+    let owner_id = tcx.hir().body_owner(body_id);\n+    let span = tcx.hir().span(owner_id);\n+    let ty = tcx.types.err;\n+    let num_params = match hir.body_owner_kind {\n+        hir::BodyOwnerKind::Fn => tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len(),\n+        hir::BodyOwnerKind::Closure => {\n+            if tcx.hir().body(body_id).generator_kind().is_some() {\n+                // Generators have an implicit `self` parameter *and* a possibly\n+                // implicit resume parameter.\n+                2\n+            } else {\n+                // The implicit self parameter adds another local in MIR.\n+                1 + tcx.hir().fn_decl_by_hir_id(owner_id).unwrap().inputs.len()\n+            }\n+        }\n+        hir::BodyOwnerKind::Const => 0,\n+        hir::BodyOwnerKind::Static(_) => 0,\n+    };\n+    let mut builder = Builder::new(hir, span, num_params, Safety::Safe, ty, span, None);\n     let source_info = builder.source_info(span);\n+    // Some MIR passes will expect the number of parameters to match the\n+    // function declaration.\n+    for _ in 0..num_params {\n+        builder.local_decls.push(LocalDecl {\n+            mutability: Mutability::Mut,\n+            ty,\n+            user_ty: UserTypeProjections::none(),\n+            source_info,\n+            internal: false,\n+            local_info: LocalInfo::Other,\n+            is_block_tail: None,\n+        });\n+    }\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish()\n+    let mut body = builder.finish();\n+    if tcx.hir().body(body_id).generator_kind.is_some() {\n+        body.yield_ty = Some(ty);\n+    }\n+    body\n }\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {"}, {"sha": "3a1622f1649e50d8e11685a570b5a498018753cd", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -426,7 +426,8 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n-            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n+            let instantiated_ty =\n+                self.tcx().erase_regions(&self.resolve(&opaque_defn.concrete_ty, &hir_id));\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n@@ -444,7 +445,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             // figures out the concrete type with `U`, but the stored type is with `T`.\n             let definition_ty = self.fcx.infer_opaque_definition_from_instantiation(\n                 def_id,\n-                opaque_defn,\n+                opaque_defn.substs,\n                 instantiated_ty,\n                 span,\n             );"}, {"sha": "1a505a39e46379ecd747510a7d276dca845ee846", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 603, "changes": 609, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -27,18 +25,16 @@ use rustc::hir::map::Map;\n use rustc::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc::mir::mono::Linkage;\n use rustc::session::parse::feature_err;\n-use rustc::traits;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::GenericArgKind;\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::util::Discr;\n use rustc::ty::util::IntTypeExt;\n-use rustc::ty::{self, AdtKind, Const, DefIdTree, ToPolyTraitRef, Ty, TyCtxt, WithConstness};\n-use rustc::ty::{ReprOptions, ToPredicate};\n+use rustc::ty::{self, AdtKind, Const, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{ReprOptions, ToPredicate, WithConstness};\n use rustc_attr::{list_contains_name, mark_used, InlineAttr, OptimizeAttr};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -50,6 +46,8 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n \n+mod type_of;\n+\n struct OnlySelfBounds(bool);\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -64,7 +62,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: DefId) {\n \n pub fn provide(providers: &mut Providers<'_>) {\n     *providers = Providers {\n-        type_of,\n+        type_of: type_of::type_of,\n         generics_of,\n         predicates_of,\n         predicates_defined_on,\n@@ -1329,601 +1327,6 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::Generics {\n     })\n }\n \n-fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n-    struct_span_err!(\n-        tcx.sess,\n-        span,\n-        E0202,\n-        \"associated types are not yet supported in inherent impls (see #8995)\"\n-    )\n-    .emit();\n-}\n-\n-fn infer_placeholder_type(\n-    tcx: TyCtxt<'_>,\n-    def_id: DefId,\n-    body_id: hir::BodyId,\n-    span: Span,\n-    item_ident: Ident,\n-) -> Ty<'_> {\n-    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n-\n-    // If this came from a free `const` or `static mut?` item,\n-    // then the user may have written e.g. `const A = 42;`.\n-    // In this case, the parser has stashed a diagnostic for\n-    // us to improve in typeck so we do that now.\n-    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n-        Some(mut err) => {\n-            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n-            // We are typeck and have the real type, so remove that and suggest the actual type.\n-            err.suggestions.clear();\n-            err.span_suggestion(\n-                span,\n-                \"provide a type for the item\",\n-                format!(\"{}: {}\", item_ident, ty),\n-                Applicability::MachineApplicable,\n-            )\n-            .emit();\n-        }\n-        None => {\n-            let mut diag = bad_placeholder_type(tcx, vec![span]);\n-            if ty != tcx.types.err {\n-                diag.span_suggestion(\n-                    span,\n-                    \"replace `_` with the correct type\",\n-                    ty.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            }\n-            diag.emit();\n-        }\n-    }\n-\n-    ty\n-}\n-\n-fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    use rustc_hir::*;\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-\n-    let icx = ItemCtxt::new(tcx, def_id);\n-\n-    match tcx.hir().get(hir_id) {\n-        Node::TraitItem(item) => match item.kind {\n-            TraitItemKind::Method(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            TraitItemKind::Const(ref ty, body_id) => body_id\n-                .and_then(|body_id| {\n-                    if is_suggestable_infer_ty(ty) {\n-                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n-                    } else {\n-                        None\n-                    }\n-                })\n-                .unwrap_or_else(|| icx.to_ty(ty)),\n-            TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n-            TraitItemKind::Type(_, None) => {\n-                span_bug!(item.span, \"associated type missing default\");\n-            }\n-        },\n-\n-        Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Method(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            ImplItemKind::Const(ref ty, body_id) => {\n-                if is_suggestable_infer_ty(ty) {\n-                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n-                } else {\n-                    icx.to_ty(ty)\n-                }\n-            }\n-            ImplItemKind::OpaqueTy(_) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                find_opaque_ty_constraints(tcx, def_id)\n-            }\n-            ImplItemKind::TyAlias(ref ty) => {\n-                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n-                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n-                }\n-\n-                icx.to_ty(ty)\n-            }\n-        },\n-\n-        Node::Item(item) => {\n-            match item.kind {\n-                ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n-                    if is_suggestable_infer_ty(ty) {\n-                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n-                    } else {\n-                        icx.to_ty(ty)\n-                    }\n-                }\n-                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n-                    icx.to_ty(self_ty)\n-                }\n-                ItemKind::Fn(..) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    tcx.mk_fn_def(def_id, substs)\n-                }\n-                ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n-                    let def = tcx.adt_def(def_id);\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    tcx.mk_adt(def, substs)\n-                }\n-                ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: None, .. }) => {\n-                    find_opaque_ty_constraints(tcx, def_id)\n-                }\n-                // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(hir::OpaqueTy { impl_trait_fn: Some(owner), .. }) => {\n-                    tcx.typeck_tables_of(owner)\n-                        .concrete_opaque_types\n-                        .get(&def_id)\n-                        .map(|opaque| opaque.concrete_type)\n-                        .unwrap_or_else(|| {\n-                            // This can occur if some error in the\n-                            // owner fn prevented us from populating\n-                            // the `concrete_opaque_types` table.\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n-                                    owner, def_id,\n-                                ),\n-                            );\n-                            tcx.types.err\n-                        })\n-                }\n-                ItemKind::Trait(..)\n-                | ItemKind::TraitAlias(..)\n-                | ItemKind::Mod(..)\n-                | ItemKind::ForeignMod(..)\n-                | ItemKind::GlobalAsm(..)\n-                | ItemKind::ExternCrate(..)\n-                | ItemKind::Use(..) => {\n-                    span_bug!(\n-                        item.span,\n-                        \"compute_type_of_item: unexpected item type: {:?}\",\n-                        item.kind\n-                    );\n-                }\n-            }\n-        }\n-\n-        Node::ForeignItem(foreign_item) => match foreign_item.kind {\n-            ForeignItemKind::Fn(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n-            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n-        },\n-\n-        Node::Ctor(&ref def) | Node::Variant(hir::Variant { data: ref def, .. }) => match *def {\n-            VariantData::Unit(..) | VariantData::Struct(..) => {\n-                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n-            }\n-            VariantData::Tuple(..) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                tcx.mk_fn_def(def_id, substs)\n-            }\n-        },\n-\n-        Node::Field(field) => icx.to_ty(&field.ty),\n-\n-        Node::Expr(&hir::Expr { kind: hir::ExprKind::Closure(.., gen), .. }) => {\n-            if gen.is_some() {\n-                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n-            }\n-\n-            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-            tcx.mk_closure(def_id, substs)\n-        }\n-\n-        Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n-            match parent_node {\n-                Node::Ty(&hir::Ty { kind: hir::TyKind::Array(_, ref constant), .. })\n-                | Node::Ty(&hir::Ty { kind: hir::TyKind::Typeof(ref constant), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n-                    if constant.hir_id == hir_id =>\n-                {\n-                    tcx.types.usize\n-                }\n-\n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n-                    tcx.adt_def(tcx.hir().get_parent_did(hir_id)).repr.discr_type().to_ty(tcx)\n-                }\n-\n-                Node::Ty(&hir::Ty { kind: hir::TyKind::Path(_), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Struct(..), .. })\n-                | Node::Expr(&hir::Expr { kind: ExprKind::Path(_), .. })\n-                | Node::TraitRef(..) => {\n-                    let path = match parent_node {\n-                        Node::Ty(&hir::Ty {\n-                            kind: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n-                            ..\n-                        })\n-                        | Node::Expr(&hir::Expr {\n-                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n-                            ..\n-                        }) => Some(&**path),\n-                        Node::Expr(&hir::Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n-                            if let QPath::Resolved(_, ref path) = **path {\n-                                Some(&**path)\n-                            } else {\n-                                None\n-                            }\n-                        }\n-                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(&**path),\n-                        _ => None,\n-                    };\n-\n-                    if let Some(path) = path {\n-                        let arg_index = path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref())\n-                            .map(|generic_args| generic_args.args.as_ref())\n-                            .find_map(|args| {\n-                                args.iter()\n-                                    .filter(|arg| arg.is_const())\n-                                    .enumerate()\n-                                    .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| index)\n-                                    .next()\n-                            })\n-                            .unwrap_or_else(|| {\n-                                bug!(\"no arg matching AnonConst in path\");\n-                            });\n-\n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-                        let generics = match path.res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n-                                tcx.generics_of(tcx.parent(def_id).unwrap())\n-                            }\n-                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            Res::Err => return tcx.types.err,\n-                            res => {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\"unexpected const parent path def {:?}\", res,),\n-                                );\n-                                return tcx.types.err;\n-                            }\n-                        };\n-\n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter(|param| {\n-                                if let ty::GenericParamDefKind::Const = param.kind {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .nth(arg_index)\n-                            .map(|param| tcx.type_of(param.def_id))\n-                            // This is no generic parameter associated with the arg. This is\n-                            // probably from an extra arg where one is not needed.\n-                            .unwrap_or(tcx.types.err)\n-                    } else {\n-                        tcx.sess.delay_span_bug(\n-                            DUMMY_SP,\n-                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n-                        );\n-                        return tcx.types.err;\n-                    }\n-                }\n-\n-                x => {\n-                    tcx.sess.delay_span_bug(\n-                        DUMMY_SP,\n-                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n-                    );\n-                    tcx.types.err\n-                }\n-            }\n-        }\n-\n-        Node::GenericParam(param) => match &param.kind {\n-            hir::GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n-            hir::GenericParamKind::Const { ty: ref hir_ty, .. } => {\n-                let ty = icx.to_ty(hir_ty);\n-                if !tcx.features().const_compare_raw_pointers {\n-                    let err = match ty.peel_refs().kind {\n-                        ty::FnPtr(_) => Some(\"function pointers\"),\n-                        ty::RawPtr(_) => Some(\"raw pointers\"),\n-                        _ => None,\n-                    };\n-                    if let Some(unsupported_type) = err {\n-                        feature_err(\n-                            &tcx.sess.parse_sess,\n-                            sym::const_compare_raw_pointers,\n-                            hir_ty.span,\n-                            &format!(\n-                                \"using {} as const generic parameters is unstable\",\n-                                unsupported_type\n-                            ),\n-                        )\n-                        .emit();\n-                    };\n-                }\n-                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                    .is_some()\n-                {\n-                    struct_span_err!(\n-                        tcx.sess,\n-                        hir_ty.span,\n-                        E0741,\n-                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n-                    )\n-                    .span_label(\n-                        hir_ty.span,\n-                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n-                    )\n-                    .emit();\n-                }\n-                ty\n-            }\n-            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n-        },\n-\n-        x => {\n-            bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n-        }\n-    }\n-}\n-\n-fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n-    use rustc_hir::{ImplItem, Item, TraitItem};\n-\n-    debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n-\n-    struct ConstraintLocator<'tcx> {\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        // (first found type span, actual type, mapping from the opaque type's generic\n-        // parameters to the concrete type's generic parameters)\n-        //\n-        // The mapping is an index for each use site of a generic parameter in the concrete type\n-        //\n-        // The indices index into the generic parameters on the opaque type.\n-        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n-    }\n-\n-    impl ConstraintLocator<'tcx> {\n-        fn check(&mut self, def_id: DefId) {\n-            // Don't try to check items that cannot possibly constrain the type.\n-            if !self.tcx.has_typeck_tables(def_id) {\n-                debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n-                    self.def_id, def_id,\n-                );\n-                return;\n-            }\n-            let ty = self.tcx.typeck_tables_of(def_id).concrete_opaque_types.get(&self.def_id);\n-            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n-                debug!(\n-                    \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n-                    self.def_id, def_id, ty,\n-                );\n-\n-                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n-                let span = self.tcx.def_span(def_id);\n-                // used to quickly look up the position of a generic parameter\n-                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // Skipping binder is ok, since we only use this to find generic parameters and\n-                // their positions.\n-                for (idx, subst) in substs.iter().enumerate() {\n-                    if let GenericArgKind::Type(ty) = subst.unpack() {\n-                        if let ty::Param(p) = ty.kind {\n-                            if index_map.insert(p, idx).is_some() {\n-                                // There was already an entry for `p`, meaning a generic parameter\n-                                // was used twice.\n-                                self.tcx.sess.span_err(\n-                                    span,\n-                                    &format!(\n-                                        \"defining opaque type use restricts opaque \\\n-                                         type by using the generic parameter `{}` twice\",\n-                                        p,\n-                                    ),\n-                                );\n-                                return;\n-                            }\n-                        } else {\n-                            self.tcx.sess.delay_span_bug(\n-                                span,\n-                                &format!(\n-                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n-                                    concrete_type, substs,\n-                                ),\n-                            );\n-                        }\n-                    }\n-                }\n-                // Compute the index within the opaque type for each generic parameter used in\n-                // the concrete type.\n-                let indices = concrete_type\n-                    .subst(self.tcx, substs)\n-                    .walk()\n-                    .filter_map(|t| match &t.kind {\n-                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                let is_param = |ty: Ty<'_>| match ty.kind {\n-                    ty::Param(_) => true,\n-                    _ => false,\n-                };\n-                let bad_substs: Vec<_> = substs\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, k)| {\n-                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n-                    })\n-                    .filter(|(_, ty)| !is_param(ty))\n-                    .collect();\n-\n-                if !bad_substs.is_empty() {\n-                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n-                    for (i, bad_subst) in bad_substs {\n-                        self.tcx.sess.span_err(\n-                            span,\n-                            &format!(\n-                                \"defining opaque type use does not fully define opaque type: \\\n-                            generic parameter `{}` is specified as concrete type `{}`\",\n-                                identity_substs.type_at(i),\n-                                bad_subst\n-                            ),\n-                        );\n-                    }\n-                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n-                    let mut ty = concrete_type.walk().fuse();\n-                    let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n-                        // Type parameters are equal to any other type parameter for the purpose of\n-                        // concrete type equality, as it is possible to obtain the same type just\n-                        // by passing matching parameters to a function.\n-                        (ty::Param(_), ty::Param(_)) => true,\n-                        _ => t == p,\n-                    });\n-                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n-                        debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n-                        // Found different concrete types for the opaque type.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type differs from previous defining opaque type use\",\n-                        );\n-                        err.span_label(\n-                            span,\n-                            format!(\"expected `{}`, got `{}`\", prev_ty, concrete_type),\n-                        );\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n-                    } else if indices != *prev_indices {\n-                        // Found \"same\" concrete types, but the generic parameter order differs.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type's generic parameters differ from previous defining use\",\n-                        );\n-                        use std::fmt::Write;\n-                        let mut s = String::new();\n-                        write!(s, \"expected [\").unwrap();\n-                        let list = |s: &mut String, indices: &Vec<usize>| {\n-                            let mut indices = indices.iter().cloned();\n-                            if let Some(first) = indices.next() {\n-                                write!(s, \"`{}`\", substs[first]).unwrap();\n-                                for i in indices {\n-                                    write!(s, \", `{}`\", substs[i]).unwrap();\n-                                }\n-                            }\n-                        };\n-                        list(&mut s, prev_indices);\n-                        write!(s, \"], got [\").unwrap();\n-                        list(&mut s, &indices);\n-                        write!(s, \"]\").unwrap();\n-                        err.span_label(span, s);\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n-                    }\n-                } else {\n-                    self.found = Some((span, concrete_type, indices));\n-                }\n-            } else {\n-                debug!(\n-                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n-                    self.def_id, def_id,\n-                );\n-            }\n-        }\n-    }\n-\n-    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n-        type Map = Map<'tcx>;\n-\n-        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n-            intravisit::NestedVisitorMap::All(&self.tcx.hir())\n-        }\n-        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n-                self.check(def_id);\n-                intravisit::walk_item(self, it);\n-            }\n-        }\n-        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            // The opaque type itself or its children are not within its reveal scope.\n-            if def_id != self.def_id {\n-                self.check(def_id);\n-                intravisit::walk_impl_item(self, it);\n-            }\n-        }\n-        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            debug!(\"find_existential_constraints: visiting {:?}\", it);\n-            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n-            self.check(def_id);\n-            intravisit::walk_trait_item(self, it);\n-        }\n-    }\n-\n-    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-    let scope = tcx.hir().get_defining_scope(hir_id);\n-    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n-\n-    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n-\n-    if scope == hir::CRATE_HIR_ID {\n-        intravisit::walk_crate(&mut locator, tcx.hir().krate());\n-    } else {\n-        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n-        match tcx.hir().get(scope) {\n-            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n-            // This allows our visitor to process the defining item itself, causing\n-            // it to pick up any 'sibling' defining uses.\n-            //\n-            // For example, this code:\n-            // ```\n-            // fn foo() {\n-            //     type Blah = impl Debug;\n-            //     let my_closure = || -> Blah { true };\n-            // }\n-            // ```\n-            //\n-            // requires us to explicitly process `foo()` in order\n-            // to notice the defining usage of `Blah`.\n-            Node::Item(ref it) => locator.visit_item(it),\n-            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n-            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n-            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n-        }\n-    }\n-\n-    match locator.found {\n-        Some((_, ty, _)) => ty,\n-        None => {\n-            let span = tcx.def_span(def_id);\n-            tcx.sess.span_err(span, \"could not find defining uses\");\n-            tcx.types.err\n-        }\n-    }\n-}\n-\n fn are_suggestable_generic_args(generic_args: &[hir::GenericArg<'_>]) -> bool {\n     generic_args\n         .iter()"}, {"sha": "8b6dba749a6ef2633c7fac1da443a4e8192af01a", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "added", "additions": 661, "deletions": 0, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,661 @@\n+use rustc::hir::map::Map;\n+use rustc::session::parse::feature_err;\n+use rustc::traits;\n+use rustc::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc::ty::util::IntTypeExt;\n+use rustc::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_errors::{struct_span_err, Applicability, StashKey};\n+use rustc_hir as hir;\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::Node;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, DUMMY_SP};\n+\n+use super::ItemCtxt;\n+use super::{bad_placeholder_type, is_suggestable_infer_ty};\n+\n+pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+    use rustc_hir::*;\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+    let icx = ItemCtxt::new(tcx, def_id);\n+\n+    match tcx.hir().get(hir_id) {\n+        Node::TraitItem(item) => match item.kind {\n+            TraitItemKind::Method(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            TraitItemKind::Const(ref ty, body_id) => body_id\n+                .and_then(|body_id| {\n+                    if is_suggestable_infer_ty(ty) {\n+                        Some(infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident))\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .unwrap_or_else(|| icx.to_ty(ty)),\n+            TraitItemKind::Type(_, Some(ref ty)) => icx.to_ty(ty),\n+            TraitItemKind::Type(_, None) => {\n+                span_bug!(item.span, \"associated type missing default\");\n+            }\n+        },\n+\n+        Node::ImplItem(item) => match item.kind {\n+            ImplItemKind::Method(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            ImplItemKind::Const(ref ty, body_id) => {\n+                if is_suggestable_infer_ty(ty) {\n+                    infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                } else {\n+                    icx.to_ty(ty)\n+                }\n+            }\n+            ImplItemKind::OpaqueTy(_) => {\n+                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n+                }\n+\n+                find_opaque_ty_constraints(tcx, def_id)\n+            }\n+            ImplItemKind::TyAlias(ref ty) => {\n+                if tcx.impl_trait_ref(tcx.hir().get_parent_did(hir_id)).is_none() {\n+                    report_assoc_ty_on_inherent_impl(tcx, item.span);\n+                }\n+\n+                icx.to_ty(ty)\n+            }\n+        },\n+\n+        Node::Item(item) => {\n+            match item.kind {\n+                ItemKind::Static(ref ty, .., body_id) | ItemKind::Const(ref ty, body_id) => {\n+                    if is_suggestable_infer_ty(ty) {\n+                        infer_placeholder_type(tcx, def_id, body_id, ty.span, item.ident)\n+                    } else {\n+                        icx.to_ty(ty)\n+                    }\n+                }\n+                ItemKind::TyAlias(ref self_ty, _) | ItemKind::Impl { ref self_ty, .. } => {\n+                    icx.to_ty(self_ty)\n+                }\n+                ItemKind::Fn(..) => {\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    tcx.mk_fn_def(def_id, substs)\n+                }\n+                ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) => {\n+                    let def = tcx.adt_def(def_id);\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    tcx.mk_adt(def, substs)\n+                }\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: None, .. }) => {\n+                    find_opaque_ty_constraints(tcx, def_id)\n+                }\n+                // Opaque types desugared from `impl Trait`.\n+                ItemKind::OpaqueTy(OpaqueTy { impl_trait_fn: Some(owner), origin, .. }) => {\n+                    let concrete_types = match origin {\n+                        OpaqueTyOrigin::FnReturn | OpaqueTyOrigin::AsyncFn => {\n+                            &tcx.mir_borrowck(owner).concrete_opaque_types\n+                        }\n+                        OpaqueTyOrigin::Misc => {\n+                            // We shouldn't leak borrowck results through impl trait in bindings.\n+                            // For example, we shouldn't be able to tell if `x` in\n+                            // `let x: impl Sized + 'a = &()` has type `&'static ()` or `&'a ()`.\n+                            &tcx.typeck_tables_of(owner).concrete_opaque_types\n+                        }\n+                        OpaqueTyOrigin::TypeAlias => {\n+                            span_bug!(item.span, \"Type alias impl trait shouldn't have an owner\")\n+                        }\n+                    };\n+                    let concrete_ty = concrete_types\n+                        .get(&def_id)\n+                        .map(|opaque| opaque.concrete_type)\n+                        .unwrap_or_else(|| {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"owner {:?} has no opaque type for {:?} in its tables\",\n+                                    owner, def_id,\n+                                ),\n+                            );\n+                            if tcx.typeck_tables_of(owner).tainted_by_errors {\n+                                // Some error in the\n+                                // owner fn prevented us from populating\n+                                // the `concrete_opaque_types` table.\n+                                tcx.types.err\n+                            } else {\n+                                // We failed to resolve the opaque type or it\n+                                // resolves to itself. Return the non-revealed\n+                                // type, which should result in E0720.\n+                                tcx.mk_opaque(\n+                                    def_id,\n+                                    InternalSubsts::identity_for_item(tcx, def_id),\n+                                )\n+                            }\n+                        });\n+                    debug!(\"concrete_ty = {:?}\", concrete_ty);\n+                    if concrete_ty.has_erased_regions() {\n+                        // FIXME(impl_trait_in_bindings) Handle this case.\n+                        tcx.sess.span_fatal(\n+                            item.span,\n+                            \"lifetimes in impl Trait types in bindings are not currently supported\",\n+                        );\n+                    }\n+                    concrete_ty\n+                }\n+                ItemKind::Trait(..)\n+                | ItemKind::TraitAlias(..)\n+                | ItemKind::Mod(..)\n+                | ItemKind::ForeignMod(..)\n+                | ItemKind::GlobalAsm(..)\n+                | ItemKind::ExternCrate(..)\n+                | ItemKind::Use(..) => {\n+                    span_bug!(\n+                        item.span,\n+                        \"compute_type_of_item: unexpected item type: {:?}\",\n+                        item.kind\n+                    );\n+                }\n+            }\n+        }\n+\n+        Node::ForeignItem(foreign_item) => match foreign_item.kind {\n+            ForeignItemKind::Fn(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+            ForeignItemKind::Static(ref t, _) => icx.to_ty(t),\n+            ForeignItemKind::Type => tcx.mk_foreign(def_id),\n+        },\n+\n+        Node::Ctor(&ref def) | Node::Variant(Variant { data: ref def, .. }) => match *def {\n+            VariantData::Unit(..) | VariantData::Struct(..) => {\n+                tcx.type_of(tcx.hir().get_parent_did(hir_id))\n+            }\n+            VariantData::Tuple(..) => {\n+                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                tcx.mk_fn_def(def_id, substs)\n+            }\n+        },\n+\n+        Node::Field(field) => icx.to_ty(&field.ty),\n+\n+        Node::Expr(&Expr { kind: ExprKind::Closure(.., gen), .. }) => {\n+            if gen.is_some() {\n+                return tcx.typeck_tables_of(def_id).node_type(hir_id);\n+            }\n+\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+            tcx.mk_closure(def_id, substs)\n+        }\n+\n+        Node::AnonConst(_) => {\n+            let parent_node = tcx.hir().get(tcx.hir().get_parent_node(hir_id));\n+            match parent_node {\n+                Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n+                | Node::Ty(&Ty { kind: TyKind::Typeof(ref constant), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+                    if constant.hir_id == hir_id =>\n+                {\n+                    tcx.types.usize\n+                }\n+\n+                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                    tcx.adt_def(tcx.hir().get_parent_did(hir_id)).repr.discr_type().to_ty(tcx)\n+                }\n+\n+                Node::Ty(&Ty { kind: TyKind::Path(_), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Struct(..), .. })\n+                | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n+                | Node::TraitRef(..) => {\n+                    let path = match parent_node {\n+                        Node::Ty(&Ty {\n+                            kind: TyKind::Path(QPath::Resolved(_, ref path)), ..\n+                        })\n+                        | Node::Expr(&Expr {\n+                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        }) => Some(&**path),\n+                        Node::Expr(&Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n+                            if let QPath::Resolved(_, ref path) = **path {\n+                                Some(&**path)\n+                            } else {\n+                                None\n+                            }\n+                        }\n+                        Node::TraitRef(&TraitRef { ref path, .. }) => Some(&**path),\n+                        _ => None,\n+                    };\n+\n+                    if let Some(path) = path {\n+                        let arg_index = path\n+                            .segments\n+                            .iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .map(|generic_args| generic_args.args.as_ref())\n+                            .find_map(|args| {\n+                                args.iter()\n+                                    .filter(|arg| arg.is_const())\n+                                    .enumerate()\n+                                    .filter(|(_, arg)| arg.id() == hir_id)\n+                                    .map(|(index, _)| index)\n+                                    .next()\n+                            })\n+                            .unwrap_or_else(|| {\n+                                bug!(\"no arg matching AnonConst in path\");\n+                            });\n+\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+                        let generics = match path.res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                                tcx.generics_of(tcx.parent(def_id).unwrap())\n+                            }\n+                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                            Res::Err => return tcx.types.err,\n+                            res => {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\"unexpected const parent path def {:?}\", res,),\n+                                );\n+                                return tcx.types.err;\n+                            }\n+                        };\n+\n+                        generics\n+                            .params\n+                            .iter()\n+                            .filter(|param| {\n+                                if let ty::GenericParamDefKind::Const = param.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .nth(arg_index)\n+                            .map(|param| tcx.type_of(param.def_id))\n+                            // This is no generic parameter associated with the arg. This is\n+                            // probably from an extra arg where one is not needed.\n+                            .unwrap_or(tcx.types.err)\n+                    } else {\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n+                        );\n+                        return tcx.types.err;\n+                    }\n+                }\n+\n+                x => {\n+                    tcx.sess.delay_span_bug(\n+                        DUMMY_SP,\n+                        &format!(\"unexpected const parent in type_of_def_id(): {:?}\", x),\n+                    );\n+                    tcx.types.err\n+                }\n+            }\n+        }\n+\n+        Node::GenericParam(param) => match &param.kind {\n+            GenericParamKind::Type { default: Some(ref ty), .. } => icx.to_ty(ty),\n+            GenericParamKind::Const { ty: ref hir_ty, .. } => {\n+                let ty = icx.to_ty(hir_ty);\n+                if !tcx.features().const_compare_raw_pointers {\n+                    let err = match ty.peel_refs().kind {\n+                        ty::FnPtr(_) => Some(\"function pointers\"),\n+                        ty::RawPtr(_) => Some(\"raw pointers\"),\n+                        _ => None,\n+                    };\n+                    if let Some(unsupported_type) = err {\n+                        feature_err(\n+                            &tcx.sess.parse_sess,\n+                            sym::const_compare_raw_pointers,\n+                            hir_ty.span,\n+                            &format!(\n+                                \"using {} as const generic parameters is unstable\",\n+                                unsupported_type\n+                            ),\n+                        )\n+                        .emit();\n+                    };\n+                }\n+                if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n+                    .is_some()\n+                {\n+                    struct_span_err!(\n+                        tcx.sess,\n+                        hir_ty.span,\n+                        E0741,\n+                        \"the types of const generic parameters must derive `PartialEq` and `Eq`\",\n+                    )\n+                    .span_label(\n+                        hir_ty.span,\n+                        format!(\"`{}` doesn't derive both `PartialEq` and `Eq`\", ty),\n+                    )\n+                    .emit();\n+                }\n+                ty\n+            }\n+            x => bug!(\"unexpected non-type Node::GenericParam: {:?}\", x),\n+        },\n+\n+        x => {\n+            bug!(\"unexpected sort of node in type_of_def_id(): {:?}\", x);\n+        }\n+    }\n+}\n+\n+fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n+    use rustc_hir::{Expr, ImplItem, Item, TraitItem};\n+\n+    debug!(\"find_opaque_ty_constraints({:?})\", def_id);\n+\n+    struct ConstraintLocator<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        // (first found type span, actual type, mapping from the opaque type's generic\n+        // parameters to the concrete type's generic parameters)\n+        //\n+        // The mapping is an index for each use site of a generic parameter in the concrete type\n+        //\n+        // The indices index into the generic parameters on the opaque type.\n+        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n+    }\n+\n+    impl ConstraintLocator<'_> {\n+        fn check(&mut self, def_id: DefId) {\n+            // Don't try to check items that cannot possibly constrain the type.\n+            if !self.tcx.has_typeck_tables(def_id) {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`: no tables\",\n+                    self.def_id, def_id,\n+                );\n+                return;\n+            }\n+            // Calling `mir_borrowck` can lead to cycle errors through\n+            // const-checking, avoid calling it if we don't have to.\n+            if !self.tcx.typeck_tables_of(def_id).concrete_opaque_types.contains_key(&self.def_id) {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id, def_id,\n+                );\n+                return;\n+            }\n+            // Use borrowck to get the type with unerased regions.\n+            let ty = self.tcx.mir_borrowck(def_id).concrete_opaque_types.get(&self.def_id);\n+            if let Some(ty::ResolvedOpaqueTy { concrete_type, substs }) = ty {\n+                debug!(\n+                    \"find_opaque_ty_constraints: found constraint for `{:?}` at `{:?}`: {:?}\",\n+                    self.def_id, def_id, ty,\n+                );\n+\n+                // FIXME(oli-obk): trace the actual span from inference to improve errors.\n+                let span = self.tcx.def_span(def_id);\n+                // used to quickly look up the position of a generic parameter\n+                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n+                // Skipping binder is ok, since we only use this to find generic parameters and\n+                // their positions.\n+                for (idx, subst) in substs.iter().enumerate() {\n+                    if let GenericArgKind::Type(ty) = subst.unpack() {\n+                        if let ty::Param(p) = ty.kind {\n+                            if index_map.insert(p, idx).is_some() {\n+                                // There was already an entry for `p`, meaning a generic parameter\n+                                // was used twice.\n+                                self.tcx.sess.span_err(\n+                                    span,\n+                                    &format!(\n+                                        \"defining opaque type use restricts opaque \\\n+                                         type by using the generic parameter `{}` twice\",\n+                                        p,\n+                                    ),\n+                                );\n+                                return;\n+                            }\n+                        } else {\n+                            self.tcx.sess.delay_span_bug(\n+                                span,\n+                                &format!(\n+                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n+                                    concrete_type, substs,\n+                                ),\n+                            );\n+                        }\n+                    }\n+                }\n+                // Compute the index within the opaque type for each generic parameter used in\n+                // the concrete type.\n+                let indices = concrete_type\n+                    .subst(self.tcx, substs)\n+                    .walk()\n+                    .filter_map(|t| match &t.kind {\n+                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n+                        _ => None,\n+                    })\n+                    .collect();\n+                let is_param = |ty: Ty<'_>| match ty.kind {\n+                    ty::Param(_) => true,\n+                    _ => false,\n+                };\n+                let bad_substs: Vec<_> = substs\n+                    .iter()\n+                    .enumerate()\n+                    .filter_map(|(i, k)| {\n+                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n+                    })\n+                    .filter(|(_, ty)| !is_param(ty))\n+                    .collect();\n+                if !bad_substs.is_empty() {\n+                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n+                    for (i, bad_subst) in bad_substs {\n+                        self.tcx.sess.span_err(\n+                            span,\n+                            &format!(\n+                                \"defining opaque type use does not fully define opaque type: \\\n+                            generic parameter `{}` is specified as concrete type `{}`\",\n+                                identity_substs.type_at(i),\n+                                bad_subst\n+                            ),\n+                        );\n+                    }\n+                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n+                    let mut ty = concrete_type.walk().fuse();\n+                    let mut p_ty = prev_ty.walk().fuse();\n+                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n+                        // Type parameters are equal to any other type parameter for the purpose of\n+                        // concrete type equality, as it is possible to obtain the same type just\n+                        // by passing matching parameters to a function.\n+                        (ty::Param(_), ty::Param(_)) => true,\n+                        _ => t == p,\n+                    });\n+                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n+                        debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n+                        // Found different concrete types for the opaque type.\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            span,\n+                            \"concrete type differs from previous defining opaque type use\",\n+                        );\n+                        err.span_label(\n+                            span,\n+                            format!(\"expected `{}`, got `{}`\", prev_ty, concrete_type),\n+                        );\n+                        err.span_note(prev_span, \"previous use here\");\n+                        err.emit();\n+                    } else if indices != *prev_indices {\n+                        // Found \"same\" concrete types, but the generic parameter order differs.\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            span,\n+                            \"concrete type's generic parameters differ from previous defining use\",\n+                        );\n+                        use std::fmt::Write;\n+                        let mut s = String::new();\n+                        write!(s, \"expected [\").unwrap();\n+                        let list = |s: &mut String, indices: &Vec<usize>| {\n+                            let mut indices = indices.iter().cloned();\n+                            if let Some(first) = indices.next() {\n+                                write!(s, \"`{}`\", substs[first]).unwrap();\n+                                for i in indices {\n+                                    write!(s, \", `{}`\", substs[i]).unwrap();\n+                                }\n+                            }\n+                        };\n+                        list(&mut s, prev_indices);\n+                        write!(s, \"], got [\").unwrap();\n+                        list(&mut s, &indices);\n+                        write!(s, \"]\").unwrap();\n+                        err.span_label(span, s);\n+                        err.span_note(prev_span, \"previous use here\");\n+                        err.emit();\n+                    }\n+                } else {\n+                    self.found = Some((span, concrete_type, indices));\n+                }\n+            } else {\n+                debug!(\n+                    \"find_opaque_ty_constraints: no constraint for `{:?}` at `{:?}`\",\n+                    self.def_id, def_id,\n+                );\n+            }\n+        }\n+    }\n+\n+    impl<'tcx> intravisit::Visitor<'tcx> for ConstraintLocator<'tcx> {\n+        type Map = Map<'tcx>;\n+\n+        fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<'_, Self::Map> {\n+            intravisit::NestedVisitorMap::All(&self.tcx.hir())\n+        }\n+        fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+            if let hir::ExprKind::Closure(..) = ex.kind {\n+                let def_id = self.tcx.hir().local_def_id(ex.hir_id);\n+                self.check(def_id);\n+            }\n+            intravisit::walk_expr(self, ex);\n+        }\n+        fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            // The opaque type itself or its children are not within its reveal scope.\n+            if def_id != self.def_id {\n+                self.check(def_id);\n+                intravisit::walk_item(self, it);\n+            }\n+        }\n+        fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            // The opaque type itself or its children are not within its reveal scope.\n+            if def_id != self.def_id {\n+                self.check(def_id);\n+                intravisit::walk_impl_item(self, it);\n+            }\n+        }\n+        fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n+            debug!(\"find_existential_constraints: visiting {:?}\", it);\n+            let def_id = self.tcx.hir().local_def_id(it.hir_id);\n+            self.check(def_id);\n+            intravisit::walk_trait_item(self, it);\n+        }\n+    }\n+\n+    let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+    let scope = tcx.hir().get_defining_scope(hir_id);\n+    let mut locator = ConstraintLocator { def_id, tcx, found: None };\n+\n+    debug!(\"find_opaque_ty_constraints: scope={:?}\", scope);\n+\n+    if scope == hir::CRATE_HIR_ID {\n+        intravisit::walk_crate(&mut locator, tcx.hir().krate());\n+    } else {\n+        debug!(\"find_opaque_ty_constraints: scope={:?}\", tcx.hir().get(scope));\n+        match tcx.hir().get(scope) {\n+            // We explicitly call `visit_*` methods, instead of using `intravisit::walk_*` methods\n+            // This allows our visitor to process the defining item itself, causing\n+            // it to pick up any 'sibling' defining uses.\n+            //\n+            // For example, this code:\n+            // ```\n+            // fn foo() {\n+            //     type Blah = impl Debug;\n+            //     let my_closure = || -> Blah { true };\n+            // }\n+            // ```\n+            //\n+            // requires us to explicitly process `foo()` in order\n+            // to notice the defining usage of `Blah`.\n+            Node::Item(ref it) => locator.visit_item(it),\n+            Node::ImplItem(ref it) => locator.visit_impl_item(it),\n+            Node::TraitItem(ref it) => locator.visit_trait_item(it),\n+            other => bug!(\"{:?} is not a valid scope for an opaque type item\", other),\n+        }\n+    }\n+\n+    match locator.found {\n+        Some((_, ty, _)) => ty,\n+        None => {\n+            let span = tcx.def_span(def_id);\n+            tcx.sess.span_err(span, \"could not find defining uses\");\n+            tcx.types.err\n+        }\n+    }\n+}\n+\n+fn infer_placeholder_type(\n+    tcx: TyCtxt<'_>,\n+    def_id: DefId,\n+    body_id: hir::BodyId,\n+    span: Span,\n+    item_ident: Ident,\n+) -> Ty<'_> {\n+    let ty = tcx.diagnostic_only_typeck_tables_of(def_id).node_type(body_id.hir_id);\n+\n+    // If this came from a free `const` or `static mut?` item,\n+    // then the user may have written e.g. `const A = 42;`.\n+    // In this case, the parser has stashed a diagnostic for\n+    // us to improve in typeck so we do that now.\n+    match tcx.sess.diagnostic().steal_diagnostic(span, StashKey::ItemNoType) {\n+        Some(mut err) => {\n+            // The parser provided a sub-optimal `HasPlaceholders` suggestion for the type.\n+            // We are typeck and have the real type, so remove that and suggest the actual type.\n+            err.suggestions.clear();\n+            err.span_suggestion(\n+                span,\n+                \"provide a type for the item\",\n+                format!(\"{}: {}\", item_ident, ty),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n+        }\n+        None => {\n+            let mut diag = bad_placeholder_type(tcx, vec![span]);\n+            if ty != tcx.types.err {\n+                diag.span_suggestion(\n+                    span,\n+                    \"replace `_` with the correct type\",\n+                    ty.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            }\n+            diag.emit();\n+        }\n+    }\n+\n+    ty\n+}\n+\n+fn report_assoc_ty_on_inherent_impl(tcx: TyCtxt<'_>, span: Span) {\n+    struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0202,\n+        \"associated types are not yet supported in inherent impls (see #8995)\"\n+    )\n+    .emit();\n+}"}, {"sha": "0a765a1f9c93cb58075b03693a7661384f6cb04d", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -120,11 +120,26 @@ fn enforce_impl_params_are_constrained(\n     let lifetimes_in_associated_types: FxHashSet<_> = impl_item_refs\n         .iter()\n         .map(|item_ref| tcx.hir().local_def_id(item_ref.id.hir_id))\n-        .filter(|&def_id| {\n+        .flat_map(|def_id| {\n             let item = tcx.associated_item(def_id);\n-            item.kind == ty::AssocKind::Type && item.defaultness.has_value()\n+            match item.kind {\n+                ty::AssocKind::Type => {\n+                    if item.defaultness.has_value() {\n+                        cgp::parameters_for(&tcx.type_of(def_id), true)\n+                    } else {\n+                        Vec::new()\n+                    }\n+                }\n+                ty::AssocKind::OpaqueTy => {\n+                    // We don't know which lifetimes appear in the actual\n+                    // opaque type, so use all of the lifetimes that appear\n+                    // in the type's predicates.\n+                    let predicates = tcx.predicates_of(def_id).instantiate_identity(tcx);\n+                    cgp::parameters_for(&predicates, true)\n+                }\n+                ty::AssocKind::Method | ty::AssocKind::Const => Vec::new(),\n+            }\n         })\n-        .flat_map(|def_id| cgp::parameters_for(&tcx.type_of(def_id), true))\n         .collect();\n \n     for param in &impl_generics.params {"}, {"sha": "7b1beb1ecda80089bc6df13eceebb3ae39c99b5d", "filename": "src/libstd/future.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibstd%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Flibstd%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffuture.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -16,9 +16,10 @@ pub use core::future::*;\n ///\n /// This function returns a `GenFuture` underneath, but hides it in `impl Trait` to give\n /// better error messages (`impl Future` rather than `GenFuture<[closure.....]>`).\n+// This is `const` to avoid extra errors after we recover from `const async fn`\n #[doc(hidden)]\n #[unstable(feature = \"gen_future\", issue = \"50547\")]\n-pub fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n+pub const fn from_generator<T: Generator<Yield = ()>>(x: T) -> impl Future<Output = T::Return> {\n     GenFuture(x)\n }\n "}, {"sha": "8e0e1ce3dc34d74760348c97f98de4864cf339c2", "filename": "src/test/ui/async-await/issues/issue-63388-1.nll.stderr", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fissue-63388-1.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/issue-63388-1.rs:12:10\n-   |\n-LL |     ) -> &dyn Foo\n-   |          ^^^^^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#22r\n-\n error: lifetime may not live long enough\n   --> $DIR/issue-63388-1.rs:13:5\n    |\n@@ -19,6 +11,5 @@ LL | |         foo\n LL | |     }\n    | |_____^ function was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "57a9f175ca318ca2f30e7959a263513dee779b25", "filename": "src/test/ui/async-await/no-const-async.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -3,3 +3,4 @@\n \n pub const async fn x() {}\n //~^ ERROR functions cannot be both `const` and `async`\n+//~| ERROR `impl Trait` in const fn is unstable"}, {"sha": "07559cd240bb6f2fd742ad98b7ff04d9c5eb789a", "filename": "src/test/ui/async-await/no-const-async.stderr", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fno-const-async.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -7,5 +7,15 @@ LL | pub const async fn x() {}\n    |     |     `async` because of this\n    |     `const` because of this\n \n-error: aborting due to previous error\n+error[E0723]: `impl Trait` in const fn is unstable\n+  --> $DIR/no-const-async.rs:4:24\n+   |\n+LL | pub const async fn x() {}\n+   |                        ^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "57198cb95e770113955d02388534867706d85f93", "filename": "src/test/ui/borrowck/borrow-immutable-upvar-mutation-impl-trait.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,14 @@\n+#![feature(unboxed_closures)]\n+\n+// Tests that we can't assign to or mutably borrow upvars from `Fn`\n+// closures (issue #17780)\n+\n+fn main() {}\n+\n+fn bar() -> impl Fn() -> usize {\n+    let mut x = 0;\n+    move || {\n+        x += 1; //~ ERROR cannot assign\n+        x\n+    }\n+}"}, {"sha": "003c40d27736d5b3b43c7e689994fb2a381b4d24", "filename": "src/test/ui/borrowck/borrow-immutable-upvar-mutation-impl-trait.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation-impl-trait.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,16 @@\n+error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n+  --> $DIR/borrow-immutable-upvar-mutation-impl-trait.rs:11:9\n+   |\n+LL |   fn bar() -> impl Fn() -> usize {\n+   |      ---      ------------------ change this to return `FnMut` instead of `Fn`\n+LL |       let mut x = 0;\n+LL | /     move || {\n+LL | |         x += 1;\n+   | |         ^^^^^^ cannot assign\n+LL | |         x\n+LL | |     }\n+   | |_____- in this closure\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "e2f016614bf86a4917b1633536de422aec999693", "filename": "src/test/ui/borrowck/borrow-immutable-upvar-mutation.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -3,10 +3,16 @@\n // Tests that we can't assign to or mutably borrow upvars from `Fn`\n // closures (issue #17780)\n \n-fn set(x: &mut usize) { *x = 5; }\n+fn set(x: &mut usize) {\n+    *x = 5;\n+}\n \n-fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n+fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+    f\n+}\n+fn to_fn_mut<A, F: FnMut<A>>(f: F) -> F {\n+    f\n+}\n \n fn main() {\n     // By-ref captures\n@@ -33,7 +39,11 @@ fn main() {\n         let _g = to_fn(move || set(&mut y)); //~ ERROR cannot borrow\n \n         let mut z = 0;\n-        let _h = to_fn_mut(move || { set(&mut z); to_fn(move || z = 42); }); //~ ERROR cannot assign\n+        let _h = to_fn_mut(move || {\n+            set(&mut z);\n+            to_fn(move || z = 42);\n+            //~^ ERROR cannot assign\n+        });\n     }\n }\n \n@@ -44,11 +54,3 @@ fn foo() -> Box<dyn Fn() -> usize> {\n         x\n     })\n }\n-\n-fn bar() -> impl Fn() -> usize {\n-    let mut x = 0;\n-    move || {\n-        x += 1; //~ ERROR cannot assign\n-        x\n-    }\n-}"}, {"sha": "a28cb7431e6a905abc07ab71dc3b8330279fff41", "filename": "src/test/ui/borrowck/borrow-immutable-upvar-mutation.stderr", "status": "modified", "additions": 24, "deletions": 37, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrow-immutable-upvar-mutation.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,71 +1,71 @@\n error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:15:27\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:21:27\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n LL |         let _f = to_fn(|| x = 42);\n    |                  -----    ^^^^^^ cannot assign\n    |                  |\n    |                  expects `Fn` instead of `FnMut`\n \n error[E0596]: cannot borrow `y` as mutable, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:18:31\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:24:31\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n LL |         let _g = to_fn(|| set(&mut y));\n    |                  -----        ^^^^^^ cannot borrow as mutable\n    |                  |\n    |                  expects `Fn` instead of `FnMut`\n \n error[E0594]: cannot assign to `z`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:23:22\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:29:22\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n LL |             to_fn(|| z = 42);\n    |             -----    ^^^^^^ cannot assign\n    |             |\n    |             expects `Fn` instead of `FnMut`\n \n error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:30:32\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:36:32\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n LL |         let _f = to_fn(move || x = 42);\n    |                  -----         ^^^^^^ cannot assign\n    |                  |\n    |                  expects `Fn` instead of `FnMut`\n \n error[E0596]: cannot borrow `y` as mutable, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:33:36\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:39:36\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n LL |         let _g = to_fn(move || set(&mut y));\n    |                  -----             ^^^^^^ cannot borrow as mutable\n    |                  |\n    |                  expects `Fn` instead of `FnMut`\n \n error[E0594]: cannot assign to `z`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:36:65\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:44:27\n    |\n-LL | fn to_fn<A,F:Fn<A>>(f: F) -> F { f }\n-   |                        - change this to accept `FnMut` instead of `Fn`\n+LL | fn to_fn<A, F: Fn<A>>(f: F) -> F {\n+   |                          - change this to accept `FnMut` instead of `Fn`\n ...\n-LL |         let _h = to_fn_mut(move || { set(&mut z); to_fn(move || z = 42); });\n-   |                                                   -----         ^^^^^^ cannot assign\n-   |                                                   |\n-   |                                                   expects `Fn` instead of `FnMut`\n+LL |             to_fn(move || z = 42);\n+   |             -----         ^^^^^^ cannot assign\n+   |             |\n+   |             expects `Fn` instead of `FnMut`\n \n error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:43:9\n+  --> $DIR/borrow-immutable-upvar-mutation.rs:53:9\n    |\n LL |   fn foo() -> Box<dyn Fn() -> usize> {\n    |      ---      ---------------------- change this to return `FnMut` instead of `Fn`\n@@ -78,20 +78,7 @@ LL | |         x\n LL | |     })\n    | |_____- in this closure\n \n-error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n-  --> $DIR/borrow-immutable-upvar-mutation.rs:51:9\n-   |\n-LL |   fn bar() -> impl Fn() -> usize {\n-   |      ---      ------------------ change this to return `FnMut` instead of `Fn`\n-LL |       let mut x = 0;\n-LL | /     move || {\n-LL | |         x += 1;\n-   | |         ^^^^^^ cannot assign\n-LL | |         x\n-LL | |     }\n-   | |_____- in this closure\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n \n Some errors have detailed explanations: E0594, E0596.\n For more information about an error, try `rustc --explain E0594`."}, {"sha": "557439f394953ed460f11012a6e57e641be84479", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -123,12 +123,9 @@ impl<T: Sync + Sized> Foo<T> {\n }\n \n struct AlanTuring<T>(T);\n-const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n-//~^ ERROR `impl Trait` in const fn is unstable\n const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n //~^ ERROR trait bounds other than `Sized`\n const fn no_apit(_x: impl std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n-const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {} //~ ERROR trait bounds other than `Sized`\n const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n //~^ ERROR trait bounds other than `Sized`"}, {"sha": "512b343011b40c8a6030d5f76dabbba90faa7837", "filename": "src/test/ui/consts/min_const_fn/min_const_fn.stderr", "status": "modified", "additions": 8, "deletions": 26, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -214,17 +214,8 @@ LL | impl<T: Sync + Sized> Foo<T> {\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:126:24\n-   |\n-LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> { AlanTuring(0) }\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n-\n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:128:34\n+  --> $DIR/min_const_fn.rs:126:34\n    |\n LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n@@ -233,25 +224,16 @@ LL | const fn no_apit2(_x: AlanTuring<impl std::fmt::Debug>) {}\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:130:22\n+  --> $DIR/min_const_fn.rs:128:22\n    |\n LL | const fn no_apit(_x: impl std::fmt::Debug) {}\n    |                      ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error[E0723]: `impl Trait` in const fn is unstable\n-  --> $DIR/min_const_fn.rs:131:23\n-   |\n-LL | const fn no_rpit() -> impl std::fmt::Debug {}\n-   |                       ^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n-   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n-\n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:132:23\n+  --> $DIR/min_const_fn.rs:129:23\n    |\n LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    |                       ^^\n@@ -260,7 +242,7 @@ LL | const fn no_dyn_trait(_x: &dyn std::fmt::Debug) {}\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:133:32\n+  --> $DIR/min_const_fn.rs:130:32\n    |\n LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -269,7 +251,7 @@ LL | const fn no_dyn_trait_ret() -> &'static dyn std::fmt::Debug { &() }\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: trait bounds other than `Sized` on const fn parameters are unstable\n-  --> $DIR/min_const_fn.rs:138:41\n+  --> $DIR/min_const_fn.rs:135:41\n    |\n LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1 }\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -278,7 +260,7 @@ LL | const fn really_no_traits_i_mean_it() { (&() as &dyn std::fmt::Debug, ()).1\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:141:21\n+  --> $DIR/min_const_fn.rs:138:21\n    |\n LL | const fn no_fn_ptrs(_x: fn()) {}\n    |                     ^^\n@@ -287,15 +269,15 @@ LL | const fn no_fn_ptrs(_x: fn()) {}\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n error[E0723]: function pointers in const fn are unstable\n-  --> $DIR/min_const_fn.rs:143:27\n+  --> $DIR/min_const_fn.rs:140:27\n    |\n LL | const fn no_fn_ptrs2() -> fn() { fn foo() {} foo }\n    |                           ^^^^\n    |\n    = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n    = help: add `#![feature(const_fn)]` to the crate attributes to enable\n \n-error: aborting due to 34 previous errors\n+error: aborting due to 32 previous errors\n \n Some errors have detailed explanations: E0493, E0723.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "9cc9b69ac0b6c750c4d02ba776edd077dfb318b3", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_impl_trait.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,9 @@\n+struct AlanTuring<T>(T);\n+const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> {\n+    //~^ ERROR `impl Trait` in const fn is unstable\n+    AlanTuring(0)\n+}\n+\n+const fn no_rpit() -> impl std::fmt::Debug {} //~ ERROR `impl Trait` in const fn is unstable\n+\n+fn main() {}"}, {"sha": "a62a340332db288547b7a5ac7880af636126b28d", "filename": "src/test/ui/consts/min_const_fn/min_const_fn_impl_trait.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fmin_const_fn_impl_trait.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,21 @@\n+error[E0723]: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn_impl_trait.rs:2:24\n+   |\n+LL | const fn no_rpit2() -> AlanTuring<impl std::fmt::Debug> {\n+   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error[E0723]: `impl Trait` in const fn is unstable\n+  --> $DIR/min_const_fn_impl_trait.rs:7:23\n+   |\n+LL | const fn no_rpit() -> impl std::fmt::Debug {}\n+   |                       ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\n+   = help: add `#![feature(const_fn)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0723`."}, {"sha": "f6a92b0d0bfb53f7b4edd6a2e9f256058b90977c", "filename": "src/test/ui/feature-gates/feature-gate-member-constraints.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,9 +1,10 @@\n-trait Trait<'a, 'b> { }\n+trait Trait<'a, 'b> {}\n impl<T> Trait<'_, '_> for T {}\n \n fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n     //~^ ERROR ambiguous lifetime bound\n+    //~| ERROR ambiguous lifetime bound\n     (x, y)\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "c2ec7ae16a3a6a97f1008362a5b64ff38486baa8", "filename": "src/test/ui/feature-gates/feature-gate-member-constraints.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-member-constraints.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -6,5 +6,13 @@ LL | fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n    |\n    = help: add #![feature(member_constraints)] to the crate attributes to enable\n \n-error: aborting due to previous error\n+error: ambiguous lifetime bound in `impl Trait`\n+  --> $DIR/feature-gate-member-constraints.rs:4:43\n+   |\n+LL | fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+   |                                           ^^^^^^^^^^^^^^^^^^ the elided lifetimes here do not outlive one another\n+   |\n+   = help: add #![feature(member_constraints)] to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "3d60cbff3203f7431af547e85f82e2acbf9cbc29", "filename": "src/test/ui/impl-trait/auto-trait-leak.stderr", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fauto-trait-leak.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -4,9 +4,34 @@ error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n@@ -15,9 +40,34 @@ note: ...which requires processing `cycle2::{{opaque}}#0`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n@@ -40,9 +90,34 @@ error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n@@ -51,9 +126,34 @@ note: ...which requires processing `cycle2::{{opaque}}#0`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle\n@@ -75,9 +175,34 @@ error[E0391]: cycle detected when processing `cycle1::{{opaque}}#0`\n LL | fn cycle1() -> impl Clone {\n    |                ^^^^^^^^^^\n    |\n+note: ...which requires borrow-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle1`...\n   --> $DIR/auto-trait-leak.rs:12:1\n    |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n+LL | fn cycle1() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle1`...\n+  --> $DIR/auto-trait-leak.rs:12:1\n+   |\n LL | fn cycle1() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which requires evaluating trait selection obligation `impl std::clone::Clone: std::marker::Send`...\n@@ -86,9 +211,34 @@ note: ...which requires processing `cycle2::{{opaque}}#0`...\n    |\n LL | fn cycle2() -> impl Clone {\n    |                ^^^^^^^^^^\n+note: ...which requires borrow-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n note: ...which requires processing `cycle2`...\n   --> $DIR/auto-trait-leak.rs:22:1\n    |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires processing `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires unsafety-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires building MIR for...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n+LL | fn cycle2() -> impl Clone {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: ...which requires type-checking `cycle2`...\n+  --> $DIR/auto-trait-leak.rs:22:1\n+   |\n LL | fn cycle2() -> impl Clone {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: ...which again requires processing `cycle1::{{opaque}}#0`, completing the cycle"}, {"sha": "79db88828b9affb20621ca4f18df140ab994d9d4", "filename": "src/test/ui/impl-trait/equal-hidden-lifetimes.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,49 @@\n+// Test that we consider equal regions when checking for hidden regions in\n+// opaque types\n+\n+// check-pass\n+\n+// `'a == 'static` so `&'a i32` is fine as the return type\n+fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n+    //~^ WARNING unnecessary lifetime parameter `'a`\n+    x\n+}\n+\n+// `'a == 'b` so `&'b i32` is fine as the return type\n+fn equal_regions<'a: 'b, 'b: 'a>(x: &'b i32) -> impl Sized + 'a {\n+    let y: &'a i32 = x;\n+    let z: &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `&'a i32` is fine as the return type\n+fn equal_regions_rev<'a: 'b, 'b: 'a>(x: &'a i32) -> impl Sized + 'b {\n+    let y: &'a i32 = x;\n+    let z: &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `*mut &'b i32` is fine as the return type\n+fn equal_regions_inv<'a: 'b, 'b: 'a>(x: *mut &'b i32) -> impl Sized + 'a {\n+    let y: *mut &'a i32 = x;\n+    let z: *mut &'b i32 = y;\n+    x\n+}\n+\n+// `'a == 'b` so `*mut &'a i32` is fine as the return type\n+fn equal_regions_inv_rev<'a: 'b, 'b: 'a>(x: *mut &'a i32) -> impl Sized + 'b {\n+    let y: *mut &'a i32 = x;\n+    let z: *mut &'b i32 = y;\n+    x\n+}\n+\n+// Should be able to infer `fn(&'static ())` as the return type.\n+fn contravariant_lub<'a, 'b: 'a, 'c: 'a, 'd: 'b + 'c>(\n+    x: fn(&'b ()),\n+    y: fn(&'c ()),\n+    c: bool,\n+) -> impl Sized + 'a {\n+    if c { x } else { y }\n+}\n+\n+fn main() {}"}, {"sha": "eb064b4e14a5e6db9d3205a5b4b94c2daff4d44a", "filename": "src/test/ui/impl-trait/equal-hidden-lifetimes.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fequal-hidden-lifetimes.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,8 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/equal-hidden-lifetimes.rs:7:25\n+   |\n+LL | fn equal_regions_static<'a: 'static>(x: &'a i32) -> impl Sized {\n+   |                         ^^^^^^^^^^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+"}, {"sha": "96d891b2cf1d7276b1d8fc9ab2aeff81d7f770e3", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags:-Zborrowck=mir\n+\n+#![feature(member_constraints)]\n+#![feature(type_alias_impl_trait)]\n+\n+#[derive(Clone)]\n+struct CopyIfEq<T, U>(T, U);\n+\n+impl<T: Copy> Copy for CopyIfEq<T, T> {}\n+\n+type E<'a, 'b> = impl Sized;\n+\n+fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+    //~^ ERROR hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+    let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n+\n+    // This assignment requires that `x` and `y` have the same type due to the\n+    // `Copy` impl. The reason why we are using a copy to create a constraint\n+    // is that only borrow checking (not regionck in type checking) enforces\n+    // this bound.\n+    let u = v;\n+    let _: *mut &'a i32 = u.1;\n+    unsafe {\n+        let _: &'b i32 = *u.0;\n+    }\n+    u.0\n+}\n+\n+fn main() {}"}, {"sha": "59105f11805cd0c27de0c55025cf579a87873da1", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling-2.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling-2.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,15 @@\n+error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n+  --> $DIR/error-handling-2.rs:13:60\n+   |\n+LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |                                                            ^^^^^^^^^\n+   |\n+note: hidden type `*mut &'a i32` captures the lifetime `'a` as defined on the function body at 13:8\n+  --> $DIR/error-handling-2.rs:13:8\n+   |\n+LL | fn foo<'a: 'b, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n+   |        ^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0700`."}, {"sha": "8d02d635094be46c270d8eae84c6cc303fc9f005", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -11,11 +11,18 @@ impl<T: Copy> Copy for CopyIfEq<T, T> {}\n type E<'a, 'b> = impl Sized;\n \n fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-    //~^ ERROR lifetime may not live long enough\n-    let v = CopyIfEq::<*mut _, *mut _>(&mut {x}, &mut y);\n+    let v = CopyIfEq::<*mut _, *mut _>(&mut { x }, &mut y);\n+\n+    // This assignment requires that `x` and `y` have the same type due to the\n+    // `Copy` impl. The reason why we are using a copy to create a constraint\n+    // is that only borrow checking (not regionck in type checking) enforces\n+    // this bound.\n     let u = v;\n     let _: *mut &'a i32 = u.1;\n-    unsafe { let _: &'b i32 = *u.0; }\n+    unsafe {\n+        let _: &'b i32 = *u.0;\n+        //~^ ERROR lifetime may not live long enough\n+    }\n     u.0\n }\n "}, {"sha": "6ce3aaf49eb339b12630c25e863546a959c7027f", "filename": "src/test/ui/impl-trait/multiple-lifetimes/error-handling.stderr", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Ferror-handling.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,14 +1,15 @@\n error: lifetime may not live long enough\n-  --> $DIR/error-handling.rs:13:56\n+  --> $DIR/error-handling.rs:23:16\n    |\n LL | fn foo<'a, 'b, 'c>(x: &'static i32, mut y: &'a i32) -> E<'b, 'c> {\n-   |        -- lifetime `'a` defined here                   ^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n-   |\n-   = help: consider replacing `'a` with `'static`\n-help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n-   |\n-LL | type E<'a, 'b> = impl Sized + 'a;\n-   |\n+   |        --  -- lifetime `'b` defined here\n+   |        |\n+   |        lifetime `'a` defined here\n+...\n+LL |         let _: &'b i32 = *u.0;\n+   |                ^^^^^^^ type annotation requires that `'a` must outlive `'b`\n+   |\n+   = help: consider adding the following bound: `'a: 'b`\n \n error: aborting due to previous error\n "}, {"sha": "5bfc446f6a5731f02942edbdf7b37860c73350af", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unrelated.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unrelated.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -3,6 +3,8 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n    |\n LL | fn upper_bounds<'a, 'b, 'c, 'd, 'e>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'d, 'e>\n    |                                                                          ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#8r\n \n error: aborting due to previous error\n "}, {"sha": "7291eee7b9e88e05de456eef2848c6eae2078061", "filename": "src/test/ui/impl-trait/multiple-lifetimes/ordinary-bounds-unsuited.nll.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmultiple-lifetimes%2Fordinary-bounds-unsuited.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -3,6 +3,8 @@ error[E0700]: hidden type for `impl Trait` captures lifetime that does not appea\n    |\n LL | fn upper_bounds<'a, 'b>(a: Ordinary<'a>, b: Ordinary<'b>) -> impl Trait<'a, 'b>\n    |                                                              ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: hidden type `Ordinary<'_>` captures lifetime '_#5r\n \n error: aborting due to previous error\n "}, {"sha": "7d7a084b89046ca64f759f3c455cd7ac8c0ee6e1", "filename": "src/test/ui/impl-trait/nested-return-type.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fnested-return-type.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,16 @@\n+// Check that nested impl Trait items work in functions with generic parameters.\n+// check-pass\n+\n+trait Captures<'a> {}\n+\n+impl<T> Captures<'_> for T {}\n+\n+fn nested_assoc_type<'a: 'a, T>() -> impl Iterator<Item = impl Sized> {\n+    [1].iter()\n+}\n+\n+fn nested_assoc_lifetime<'a: 'a, T>() -> impl Iterator<Item = impl Captures<'a>> {\n+    [1].iter()\n+}\n+\n+fn main() {}"}, {"sha": "3cc537440977c09f96c24c6765d5f1d979d14f60", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,6 +1,9 @@\n // Test that an `impl Trait` type that expands to itself is an error.\n \n-fn test() -> impl Sized { //~ ERROR E0720\n+#![allow(unconditional_recursion)]\n+\n+fn test() -> impl Sized {\n+    //~^ ERROR E0720\n     test()\n }\n "}, {"sha": "5a95e2969d1b0aa0e36cdac5b1498ba52959d2e8", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-direct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-direct.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,5 +1,5 @@\n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-direct.rs:3:14\n+  --> $DIR/recursive-impl-trait-type-direct.rs:5:14\n    |\n LL | fn test() -> impl Sized {\n    |              ^^^^^^^^^^ expands to a recursive type"}, {"sha": "e3c621f0c57424357bc30d7885f70c75b453c683", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.rs", "status": "modified", "additions": 42, "deletions": 23, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -2,75 +2,94 @@\n // otherwise forbidden.\n \n #![feature(generators)]\n+#![allow(unconditional_recursion)]\n \n-fn option(i: i32) -> impl Sized { //~ ERROR\n-    if i < 0 {\n-        None\n-    } else {\n-        Some((option(i - 1), i))\n-    }\n+fn option(i: i32) -> impl Sized {\n+    //~^ ERROR\n+    if i < 0 { None } else { Some((option(i - 1), i)) }\n }\n \n-fn tuple() -> impl Sized { //~ ERROR\n+fn tuple() -> impl Sized {\n+    //~^ ERROR\n     (tuple(),)\n }\n \n-fn array() -> impl Sized { //~ ERROR\n+fn array() -> impl Sized {\n+    //~^ ERROR\n     [array()]\n }\n \n-fn ptr() -> impl Sized { //~ ERROR\n+fn ptr() -> impl Sized {\n+    //~^ ERROR\n     &ptr() as *const _\n }\n \n-fn fn_ptr() -> impl Sized { //~ ERROR\n+fn fn_ptr() -> impl Sized {\n+    //~^ ERROR\n     fn_ptr as fn() -> _\n }\n \n-fn closure_capture() -> impl Sized { //~ ERROR\n+fn closure_capture() -> impl Sized {\n+    //~^ ERROR\n     let x = closure_capture();\n-    move || { x; }\n+    move || {\n+        x;\n+    }\n }\n \n-fn closure_ref_capture() -> impl Sized { //~ ERROR\n+fn closure_ref_capture() -> impl Sized {\n+    //~^ ERROR\n     let x = closure_ref_capture();\n-    move || { &x; }\n+    move || {\n+        &x;\n+    }\n }\n \n-fn closure_sig() -> impl Sized { //~ ERROR\n+fn closure_sig() -> impl Sized {\n+    //~^ ERROR\n     || closure_sig()\n }\n \n-fn generator_sig() -> impl Sized { //~ ERROR\n+fn generator_sig() -> impl Sized {\n+    //~^ ERROR\n     || generator_sig()\n }\n \n-fn generator_capture() -> impl Sized { //~ ERROR\n+fn generator_capture() -> impl Sized {\n+    //~^ ERROR\n     let x = generator_capture();\n-    move || { yield; x; }\n+    move || {\n+        yield;\n+        x;\n+    }\n }\n \n-fn substs_change<T>() -> impl Sized { //~ ERROR\n+fn substs_change<T: 'static>() -> impl Sized {\n+    //~^ ERROR\n     (substs_change::<&T>(),)\n }\n \n-fn generator_hold() -> impl Sized { //~ ERROR\n+fn generator_hold() -> impl Sized {\n+    //~^ ERROR\n     move || {\n         let x = generator_hold();\n         yield;\n         x;\n     }\n }\n \n-fn use_fn_ptr() -> impl Sized { // OK, error already reported\n+fn use_fn_ptr() -> impl Sized {\n+    // OK, error already reported\n     fn_ptr()\n }\n \n-fn mutual_recursion() -> impl Sync { //~ ERROR\n+fn mutual_recursion() -> impl Sync {\n+    //~^ ERROR\n     mutual_recursion_b()\n }\n \n-fn mutual_recursion_b() -> impl Sized { //~ ERROR\n+fn mutual_recursion_b() -> impl Sized {\n+    //~^ ERROR\n     mutual_recursion()\n }\n "}, {"sha": "6573b00870c5bcc8c2cd2bd9c0a38e9de566113b", "filename": "src/test/ui/impl-trait/recursive-impl-trait-type-indirect.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Frecursive-impl-trait-type-indirect.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,21 +1,21 @@\n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:6:22\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:7:22\n    |\n LL | fn option(i: i32) -> impl Sized {\n    |                      ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `std::option::Option<(impl Sized, i32)>`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:14:15\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:12:15\n    |\n LL | fn tuple() -> impl Sized {\n    |               ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `(impl Sized,)`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:18:15\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:17:15\n    |\n LL | fn array() -> impl Sized {\n    |               ^^^^^^^^^^ expands to a recursive type\n@@ -31,79 +31,79 @@ LL | fn ptr() -> impl Sized {\n    = note: expanded type is `*const impl Sized`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:26:16\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:27:16\n    |\n LL | fn fn_ptr() -> impl Sized {\n    |                ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `fn() -> impl Sized`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:30:25\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:32:25\n    |\n LL | fn closure_capture() -> impl Sized {\n    |                         ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:32:5: 32:19 x:impl Sized]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:35:5: 37:6 x:impl Sized]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:35:29\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:40:29\n    |\n LL | fn closure_ref_capture() -> impl Sized {\n    |                             ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:37:5: 37:20 x:impl Sized]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:43:5: 45:6 x:impl Sized]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:40:21\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:48:21\n    |\n LL | fn closure_sig() -> impl Sized {\n    |                     ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:41:5: 41:21]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:21]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:44:23\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:53:23\n    |\n LL | fn generator_sig() -> impl Sized {\n    |                       ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:45:5: 45:23]`\n+   = note: expanded type is `[closure@$DIR/recursive-impl-trait-type-indirect.rs:55:5: 55:23]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:48:27\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:58:27\n    |\n LL | fn generator_capture() -> impl Sized {\n    |                           ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:50:5: 50:26 x:impl Sized {()}]`\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:61:5: 64:6 x:impl Sized {()}]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:53:26\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:67:35\n    |\n-LL | fn substs_change<T>() -> impl Sized {\n-   |                          ^^^^^^^^^^ expands to a recursive type\n+LL | fn substs_change<T: 'static>() -> impl Sized {\n+   |                                   ^^^^^^^^^^ expands to a recursive type\n    |\n    = note: expanded type is `(impl Sized,)`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:57:24\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:72:24\n    |\n LL | fn generator_hold() -> impl Sized {\n    |                        ^^^^^^^^^^ expands to a recursive type\n    |\n-   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:58:5: 62:6 {impl Sized, ()}]`\n+   = note: expanded type is `[generator@$DIR/recursive-impl-trait-type-indirect.rs:74:5: 78:6 {impl Sized, ()}]`\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:69:26\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:86:26\n    |\n LL | fn mutual_recursion() -> impl Sync {\n    |                          ^^^^^^^^^ expands to a recursive type\n    |\n    = note: type resolves to itself\n \n error[E0720]: opaque type expands to a recursive type\n-  --> $DIR/recursive-impl-trait-type-indirect.rs:73:28\n+  --> $DIR/recursive-impl-trait-type-indirect.rs:91:28\n    |\n LL | fn mutual_recursion_b() -> impl Sized {\n    |                            ^^^^^^^^^^ expands to a recursive type"}, {"sha": "4a5831c5b73df177261171fad04ccf789d9d9570", "filename": "src/test/ui/impl-trait/unsafety-checking-cycle.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Funsafety-checking-cycle.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,32 @@\n+// Ensure that we don't get a cycle error from trying to determine whether an\n+// opaque type implements `Freeze` in safety checking, when it doesn't matter.\n+\n+// check-pass\n+\n+#![feature(rustc_attrs)]\n+\n+struct AnyValue<T>(T);\n+\n+// No need to check for `Freeze` here, there's no\n+// `rustc_layout_scalar_valid_range_start` involved.\n+fn not_restricted(c: bool) -> impl Sized {\n+    if c {\n+        let x = AnyValue(not_restricted(false));\n+        &x.0;\n+    }\n+    2u32\n+}\n+\n+#[rustc_layout_scalar_valid_range_start(1)]\n+struct NonZero<T>(T);\n+\n+// No need to check for `Freeze` here, we're not borrowing the field.\n+fn not_field(c: bool) -> impl Sized {\n+    if c {\n+        let x = unsafe { NonZero(not_field(false)) };\n+        &x;\n+    }\n+    5u32\n+}\n+\n+fn main() {}"}, {"sha": "5c7ed9d52194010d90e44b2ea971a0649e94554b", "filename": "src/test/ui/lint/lint-unused-mut-variables.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -2,17 +2,17 @@\n \n // Exercise the unused_mut attribute in some positive and negative cases\n \n-#![deny(unused_mut)]\n+#![warn(unused_mut)]\n #![feature(async_closure, raw_ref_op)]\n \n async fn baz_async(\n     mut a: i32,\n-    //~^ ERROR: variable does not need to be mutable\n+    //~^ WARN: variable does not need to be mutable\n     #[allow(unused_mut)] mut b: i32,\n ) {}\n fn baz(\n     mut a: i32,\n-    //~^ ERROR: variable does not need to be mutable\n+    //~^ WARN: variable does not need to be mutable\n     #[allow(unused_mut)] mut b: i32,\n     #[allow(unused_mut)] (mut c, d): (i32, i32)\n ) {}\n@@ -21,13 +21,13 @@ struct RefStruct {}\n impl RefStruct {\n     async fn baz_async(\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n     ) {}\n     fn baz(\n         &self,\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n         #[allow(unused_mut)] (mut c, d): (i32, i32)\n     ) {}\n@@ -37,7 +37,7 @@ trait RefTrait {\n     fn baz(\n         &self,\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n         #[allow(unused_mut)] (mut c, d): (i32, i32)\n     ) {}\n@@ -46,7 +46,7 @@ impl RefTrait for () {\n     fn baz(\n         &self,\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n         #[allow(unused_mut)] (mut c, d): (i32, i32)\n     ) {}\n@@ -55,32 +55,32 @@ impl RefTrait for () {\n fn main() {\n     let _ = async move |\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n     | {};\n     let _ = |\n         mut a: i32,\n-        //~^ ERROR: variable does not need to be mutable\n+        //~^ WARN: variable does not need to be mutable\n         #[allow(unused_mut)] mut b: i32,\n         #[allow(unused_mut)] (mut c, d): (i32, i32)\n     | {};\n \n     // negative cases\n-    let mut a = 3; //~ ERROR: variable does not need to be mutable\n+    let mut a = 3; //~ WARN: variable does not need to be mutable\n \n-    let mut a = 2; //~ ERROR: variable does not need to be mutable\n+    let mut a = 2; //~ WARN: variable does not need to be mutable\n \n-    let mut b = 3; //~ ERROR: variable does not need to be mutable\n+    let mut b = 3; //~ WARN: variable does not need to be mutable\n \n-    let mut a = vec![3]; //~ ERROR: variable does not need to be mutable\n+    let mut a = vec![3]; //~ WARN: variable does not need to be mutable\n \n-    let (mut a, b) = (1, 2); //~ ERROR: variable does not need to be mutable\n+    let (mut a, b) = (1, 2); //~ WARN: variable does not need to be mutable\n \n-    let mut a; //~ ERROR: variable does not need to be mutable\n+    let mut a; //~ WARN: variable does not need to be mutable\n \n     a = 3;\n \n-    let mut b; //~ ERROR: variable does not need to be mutable\n+    let mut b; //~ WARN: variable does not need to be mutable\n \n     if true {\n         b = 3;\n@@ -89,44 +89,44 @@ fn main() {\n     }\n \n     match 30 {\n-        mut x => {} //~ ERROR: variable does not need to be mutable\n+        mut x => {} //~ WARN: variable does not need to be mutable\n \n     }\n     match (30, 2) {\n-      (mut x, 1) | //~ ERROR: variable does not need to be mutable\n+      (mut x, 1) | //~ WARN: variable does not need to be mutable\n \n       (mut x, 2) |\n       (mut x, 3) => {\n       }\n       _ => {}\n     }\n \n-    let x = |mut y: isize| 10; //~ ERROR: variable does not need to be mutable\n+    let x = |mut y: isize| 10; //~ WARN: variable does not need to be mutable\n \n-    fn what(mut foo: isize) {} //~ ERROR: variable does not need to be mutable\n+    fn what(mut foo: isize) {} //~ WARN: variable does not need to be mutable\n \n \n-    let mut a = &mut 5; //~ ERROR: variable does not need to be mutable\n+    let mut a = &mut 5; //~ WARN: variable does not need to be mutable\n \n     *a = 4;\n \n     let mut a = 5;\n-    let mut b = (&mut a,); //~ ERROR: variable does not need to be mutable\n+    let mut b = (&mut a,); //~ WARN: variable does not need to be mutable\n     *b.0 = 4;\n \n-    let mut x = &mut 1; //~ ERROR: variable does not need to be mutable\n+    let mut x = &mut 1; //~ WARN: variable does not need to be mutable\n \n     let mut f = || {\n       *x += 1;\n     };\n     f();\n \n     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n-        &mut arg[..] //~^ ERROR: variable does not need to be mutable\n+        &mut arg[..] //~^ WARN: variable does not need to be mutable\n \n     }\n \n-    let mut v : &mut Vec<()> = &mut vec![]; //~ ERROR: variable does not need to be mutable\n+    let mut v : &mut Vec<()> = &mut vec![]; //~ WARN: variable does not need to be mutable\n \n     v.push(());\n \n@@ -181,7 +181,7 @@ fn main() {\n     let mut raw_address_of_mut = 1; // OK\n     let mut_ptr = &raw mut raw_address_of_mut;\n \n-    let mut raw_address_of_const = 1; //~ ERROR: variable does not need to be mutable\n+    let mut raw_address_of_const = 1; //~ WARN: variable does not need to be mutable\n     let const_ptr = &raw const raw_address_of_const;\n }\n "}, {"sha": "b56b3c7569f71cf796bc1a9d87ab8459fb655ca5", "filename": "src/test/ui/lint/lint-unused-mut-variables.stderr", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unused-mut-variables.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,4 +1,4 @@\n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:9:5\n    |\n LL |     mut a: i32,\n@@ -9,194 +9,194 @@ LL |     mut a: i32,\n note: the lint level is defined here\n   --> $DIR/lint-unused-mut-variables.rs:5:9\n    |\n-LL | #![deny(unused_mut)]\n+LL | #![warn(unused_mut)]\n    |         ^^^^^^^^^^\n \n-error: variable does not need to be mutable\n-  --> $DIR/lint-unused-mut-variables.rs:14:5\n-   |\n-LL |     mut a: i32,\n-   |     ----^\n-   |     |\n-   |     help: remove this `mut`\n-\n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:23:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n+  --> $DIR/lint-unused-mut-variables.rs:14:5\n+   |\n+LL |     mut a: i32,\n+   |     ----^\n+   |     |\n+   |     help: remove this `mut`\n+\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:29:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:39:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:48:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:57:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:62:9\n    |\n LL |         mut a: i32,\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:104:14\n    |\n LL |     let x = |mut y: isize| 10;\n    |              ----^\n    |              |\n    |              help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:69:9\n    |\n LL |     let mut a = 3;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:71:9\n    |\n LL |     let mut a = 2;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:73:9\n    |\n LL |     let mut b = 3;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:75:9\n    |\n LL |     let mut a = vec![3];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:77:10\n    |\n LL |     let (mut a, b) = (1, 2);\n    |          ----^\n    |          |\n    |          help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:79:9\n    |\n LL |     let mut a;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:83:9\n    |\n LL |     let mut b;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:92:9\n    |\n LL |         mut x => {}\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:96:8\n    |\n LL |       (mut x, 1) |\n    |        ----^\n    |        |\n    |        help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:109:9\n    |\n LL |     let mut a = &mut 5;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:114:9\n    |\n LL |     let mut b = (&mut a,);\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:117:9\n    |\n LL |     let mut x = &mut 1;\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:129:9\n    |\n LL |     let mut v : &mut Vec<()> = &mut vec![];\n    |         ----^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:184:9\n    |\n LL |     let mut raw_address_of_const = 1;\n    |         ----^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:106:13\n    |\n LL |     fn what(mut foo: isize) {}\n    |             ----^^^\n    |             |\n    |             help: remove this `mut`\n \n-error: variable does not need to be mutable\n+warning: variable does not need to be mutable\n   --> $DIR/lint-unused-mut-variables.rs:124:20\n    |\n LL |     fn mut_ref_arg(mut arg : &mut [u8]) -> &mut [u8] {\n@@ -218,5 +218,5 @@ note: the lint level is defined here\n LL | #[deny(unused_mut)]\n    |        ^^^^^^^^^^\n \n-error: aborting due to 26 previous errors\n+error: aborting due to previous error\n "}, {"sha": "61f6680d5a423275e764b1474b55f6bd4d295a7d", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_mismatch-async.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:8:45\n-   |\n-LL |     async fn a(self: Pin<&Foo>, f: &Foo) -> &Foo { f }\n-   |                                             ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:8:52\n    |\n@@ -24,14 +16,6 @@ LL |     async fn c(self: Pin<&Self>, f: &Foo, g: &Foo) -> (Pin<&Foo>, &Foo) { (\n    |                          |          let's call the lifetime of this reference `'1`\n    |                          let's call the lifetime of this reference `'2`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:58\n-   |\n-LL |     async fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n-   |                                                          ^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/arbitrary_self_types_pin_lifetime_mismatch-async.rs:17:64\n    |\n@@ -41,6 +25,5 @@ LL |     async fn bar<'a>(self: Alias<&Self>, arg: &'a ()) -> &() { arg }\n    |                  |               let's call the lifetime of this reference `'1`\n    |                  lifetime `'a` defined here\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "e66711076e89396d2bcd0721419325b314e2bda8", "filename": "src/test/ui/self/elision/lt-ref-self-async.nll.stderr", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Flt-ref-self-async.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:12:42\n-   |\n-LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n-   |                                          ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:13:9\n    |\n@@ -16,14 +8,6 @@ LL |     async fn ref_self(&self, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:18:48\n-   |\n-LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n-   |                                                ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:19:9\n    |\n@@ -34,14 +18,6 @@ LL |     async fn ref_Self(self: &Self, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:22:57\n-   |\n-LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n-   |                                                         ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:23:9\n    |\n@@ -52,14 +28,6 @@ LL |     async fn box_ref_Self(self: Box<&Self>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:26:57\n-   |\n-LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n-   |                                                         ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:27:9\n    |\n@@ -70,14 +38,6 @@ LL |     async fn pin_ref_Self(self: Pin<&Self>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:30:66\n-   |\n-LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n-   |                                                                  ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:31:9\n    |\n@@ -88,14 +48,6 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&Self>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/lt-ref-self-async.rs:34:62\n-   |\n-LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n-   |                                                              ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#23r\n-\n error: lifetime may not live long enough\n   --> $DIR/lt-ref-self-async.rs:35:9\n    |\n@@ -106,6 +58,5 @@ LL |     async fn box_pin_Self(self: Box<Pin<&Self>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "82098cd4f077e01edac24a8a9c01493aeeec9aac", "filename": "src/test/ui/self/elision/ref-mut-self-async.nll.stderr", "status": "modified", "additions": 1, "deletions": 50, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-self-async.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:12:46\n-   |\n-LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n-   |                                              ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:13:9\n    |\n@@ -16,14 +8,6 @@ LL |     async fn ref_self(&mut self, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:18:52\n-   |\n-LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n-   |                                                    ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:19:9\n    |\n@@ -34,14 +18,6 @@ LL |     async fn ref_Self(self: &mut Self, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:22:61\n-   |\n-LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n-   |                                                             ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:23:9\n    |\n@@ -52,14 +28,6 @@ LL |     async fn box_ref_Self(self: Box<&mut Self>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:26:61\n-   |\n-LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n-   |                                                             ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:27:9\n    |\n@@ -70,14 +38,6 @@ LL |     async fn pin_ref_Self(self: Pin<&mut Self>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:30:70\n-   |\n-LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n-   |                                                                      ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:31:9\n    |\n@@ -88,14 +48,6 @@ LL |     async fn box_box_ref_Self(self: Box<Box<&mut Self>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-self-async.rs:34:70\n-   |\n-LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n-   |                                                                      ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-self-async.rs:35:9\n    |\n@@ -106,6 +58,5 @@ LL |     async fn box_pin_ref_Self(self: Box<Pin<&mut Self>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 6 previous errors\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "736cebae4bccf63588dc045aebfd9f6228ab62c9", "filename": "src/test/ui/self/elision/ref-mut-struct-async.nll.stderr", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-mut-struct-async.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-struct-async.rs:12:56\n-   |\n-LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n-   |                                                        ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:13:9\n    |\n@@ -16,14 +8,6 @@ LL |     async fn ref_Struct(self: &mut Struct, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-struct-async.rs:16:65\n-   |\n-LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n-   |                                                                 ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:17:9\n    |\n@@ -34,14 +18,6 @@ LL |     async fn box_ref_Struct(self: Box<&mut Struct>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-struct-async.rs:20:65\n-   |\n-LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n-   |                                                                 ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:21:9\n    |\n@@ -52,14 +28,6 @@ LL |     async fn pin_ref_Struct(self: Pin<&mut Struct>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-struct-async.rs:24:74\n-   |\n-LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                                                          ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:25:9\n    |\n@@ -70,14 +38,6 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&mut Struct>>, f: &u32) -> &u\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-mut-struct-async.rs:28:74\n-   |\n-LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u32 {\n-   |                                                                          ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-mut-struct-async.rs:29:9\n    |\n@@ -88,6 +48,5 @@ LL |     async fn box_pin_ref_Struct(self: Box<Pin<&mut Struct>>, f: &u32) -> &u\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "5d7dd76827a9680175a59c0749bf9cacbeb86ade", "filename": "src/test/ui/self/elision/ref-struct-async.nll.stderr", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Felision%2Fref-struct-async.nll.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,11 +1,3 @@\n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-struct-async.rs:12:52\n-   |\n-LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n-   |                                                    ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:13:9\n    |\n@@ -16,14 +8,6 @@ LL |     async fn ref_Struct(self: &Struct, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-struct-async.rs:16:61\n-   |\n-LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n-   |                                                             ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:17:9\n    |\n@@ -34,14 +18,6 @@ LL |     async fn box_ref_Struct(self: Box<&Struct>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-struct-async.rs:20:61\n-   |\n-LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n-   |                                                             ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:21:9\n    |\n@@ -52,14 +28,6 @@ LL |     async fn pin_ref_Struct(self: Pin<&Struct>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-struct-async.rs:24:70\n-   |\n-LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n-   |                                                                      ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:25:9\n    |\n@@ -70,14 +38,6 @@ LL |     async fn box_box_ref_Struct(self: Box<Box<&Struct>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\n-  --> $DIR/ref-struct-async.rs:28:66\n-   |\n-LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n-   |                                                                  ^^^^\n-   |\n-   = note: hidden type `impl std::future::Future` captures lifetime '_#15r\n-\n error: lifetime may not live long enough\n   --> $DIR/ref-struct-async.rs:29:9\n    |\n@@ -88,6 +48,5 @@ LL |     async fn box_pin_Struct(self: Box<Pin<&Struct>>, f: &u32) -> &u32 {\n LL |         f\n    |         ^ function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0700`."}, {"sha": "2907c21c6203c5372564697326236eb644e36763", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-const.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -6,7 +6,7 @@\n #![feature(const_generics)]\n //~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n \n-trait UnwrapItemsExt<const C: usize> {\n+trait UnwrapItemsExt<'a, const C: usize> {\n     type Iter;\n     fn unwrap_items(self) -> Self::Iter;\n }\n@@ -18,18 +18,16 @@ trait MyTrait<'a, const C: usize> {\n     const MY_CONST: usize;\n }\n \n-impl<'a, const C: usize> MyTrait<'a, {C}> for MyStruct<{C}> {\n+impl<'a, const C: usize> MyTrait<'a, { C }> for MyStruct<{ C }> {\n     type MyItem = u8;\n     const MY_CONST: usize = C;\n }\n \n-impl<'a, I, const C: usize> UnwrapItemsExt<{C}> for I\n-where\n-{\n-    type Iter = impl MyTrait<'a, {C}>;\n+impl<'a, I, const C: usize> UnwrapItemsExt<'a, { C }> for I {\n+    type Iter = impl MyTrait<'a, { C }>;\n \n     fn unwrap_items(self) -> Self::Iter {\n-        MyStruct::<{C}> {}\n+        MyStruct::<{ C }> {}\n     }\n }\n "}, {"sha": "3f34b00ec77e1b139d044e01e4f5118da263f1b8", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-lifetime-unconstrained.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,26 @@\n+// Tests that we don't allow unconstrained lifetime parameters in impls when\n+// the lifetime is used in an associated opaque type.\n+\n+#![feature(type_alias_impl_trait)]\n+\n+trait UnwrapItemsExt {\n+    type Iter;\n+    fn unwrap_items(self) -> Self::Iter;\n+}\n+\n+struct MyStruct {}\n+\n+trait MyTrait<'a> {}\n+\n+impl<'a> MyTrait<'a> for MyStruct {}\n+\n+impl<'a, I> UnwrapItemsExt for I {\n+    //~^ ERROR the lifetime parameter `'a` is not constrained\n+    type Iter = impl MyTrait<'a>;\n+\n+    fn unwrap_items(self) -> Self::Iter {\n+        MyStruct {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "e594dc577b1cd1378ce73a76b2bdaed35921cf75", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-lifetime-unconstrained.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime-unconstrained.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -0,0 +1,9 @@\n+error[E0207]: the lifetime parameter `'a` is not constrained by the impl trait, self type, or predicates\n+  --> $DIR/assoc-type-lifetime-unconstrained.rs:17:6\n+   |\n+LL | impl<'a, I> UnwrapItemsExt for I {\n+   |      ^^ unconstrained lifetime parameter\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0207`."}, {"sha": "39f785d8cc55d5d6e58d6a306112e5fe5c108ede", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-lifetime.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-lifetime.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -4,7 +4,7 @@\n \n #![feature(type_alias_impl_trait)]\n \n-trait UnwrapItemsExt {\n+trait UnwrapItemsExt<'a> {\n     type Iter;\n     fn unwrap_items(self) -> Self::Iter;\n }\n@@ -15,9 +15,7 @@ trait MyTrait<'a> {}\n \n impl<'a> MyTrait<'a> for MyStruct {}\n \n-impl<'a, I> UnwrapItemsExt for I\n-where\n-{\n+impl<'a, I> UnwrapItemsExt<'a> for I {\n     type Iter = impl MyTrait<'a>;\n \n     fn unwrap_items(self) -> Self::Iter {"}, {"sha": "6cbb3069ecd4b88d2e6b142464b7489ac56e46d3", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -7,11 +7,11 @@ fn main() {}\n // test that unused generic parameters are ok\n type Two<T, U> = impl Debug;\n \n-fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n+fn two<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n     (t, t)\n }\n \n-fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n-//~^ concrete type differs from previous\n+fn three<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n+    //~^ concrete type differs from previous\n     (u, t)\n }"}, {"sha": "7e81d362661bc9ac1f08901fd719a7ea232a22d1", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use6.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use6.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,7 +1,7 @@\n error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use6.rs:14:1\n    |\n-LL | / fn three<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n+LL | / fn three<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n LL | |\n LL | |     (u, t)\n LL | | }\n@@ -10,7 +10,7 @@ LL | | }\n note: previous use here\n   --> $DIR/generic_duplicate_param_use6.rs:10:1\n    |\n-LL | / fn two<T: Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n+LL | / fn two<T: Copy + Debug, U: Debug>(t: T, u: U) -> Two<T, U> {\n LL | |     (t, t)\n LL | | }\n    | |_^"}, {"sha": "50eeff0b18fd44eb1252568f3733d31b0744f98c", "filename": "src/test/ui/type-alias-impl-trait/issue-52843-closure-constrain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -7,7 +7,7 @@ use std::fmt::Debug;\n fn main() {\n     type Opaque = impl Debug;\n     fn _unused() -> Opaque { String::new() }\n-    //~^ ERROR: concrete type differs from previous defining opaque type use\n     let null = || -> Opaque { 0 };\n+    //~^ ERROR: concrete type differs from previous defining opaque type use\n     println!(\"{:?}\", null());\n }"}, {"sha": "1333b4c63d18ccb16a1028be06286476fdeb4c4b", "filename": "src/test/ui/type-alias-impl-trait/issue-52843-closure-constrain.stderr", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-52843-closure-constrain.stderr?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -1,20 +1,14 @@\n error: concrete type differs from previous defining opaque type use\n-  --> $DIR/issue-52843-closure-constrain.rs:9:5\n+  --> $DIR/issue-52843-closure-constrain.rs:10:16\n    |\n-LL |     fn _unused() -> Opaque { String::new() }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, got `std::string::String`\n+LL |     let null = || -> Opaque { 0 };\n+   |                ^^^^^^^^^^^^^^^^^^ expected `std::string::String`, got `i32`\n    |\n note: previous use here\n-  --> $DIR/issue-52843-closure-constrain.rs:7:1\n+  --> $DIR/issue-52843-closure-constrain.rs:9:5\n    |\n-LL | / fn main() {\n-LL | |     type Opaque = impl Debug;\n-LL | |     fn _unused() -> Opaque { String::new() }\n-LL | |\n-LL | |     let null = || -> Opaque { 0 };\n-LL | |     println!(\"{:?}\", null());\n-LL | | }\n-   | |_^\n+LL |     fn _unused() -> Opaque { String::new() }\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "73acc92172bad939ec780de90f15f4ae84ba0966", "filename": "src/test/ui/type-alias-impl-trait/issue-60564.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19288ddfd6b3448c2c221d75610bff722a6582e8/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60564.rs?ref=19288ddfd6b3448c2c221d75610bff722a6582e8", "patch": "@@ -8,7 +8,7 @@ trait IterBits {\n type IterBitsIter<T, E, I> = impl std::iter::Iterator<Item = I>;\n //~^ ERROR could not find defining uses\n \n-impl<T, E> IterBits for T\n+impl<T: Copy, E> IterBits for T\n where\n     T: std::ops::Shr<Output = T>\n         + std::ops::BitAnd<T, Output = T>"}]}