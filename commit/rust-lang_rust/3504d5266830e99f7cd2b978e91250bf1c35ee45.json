{"sha": "3504d5266830e99f7cd2b978e91250bf1c35ee45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1MDRkNTI2NjgzMGU5OWY3Y2QyYjk3OGU5MTI1MGJmMWMzNWVlNDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T17:19:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-29T17:19:57Z"}, "message": "Auto merge of #1268 - JOE1994:dir, r=RalfJung\n\nWindows shims for GetCurrentDirectoryW/SetCurrentDirectoryW\n\nImplemented shims for Windows\n* [GetCurrentDirectoryW](https://github.com/rust-lang/rust/blob/75208942f6144daac669e8e382029fc33bdce841/src/libstd/sys/windows/os.rs#L242) (`getcwd` for Windows)\n* [SetCurrentDirectoryW](https://github.com/rust-lang/rust/blob/75208942f6144daac669e8e382029fc33bdce841/src/libstd/sys/windows/os.rs#L250) (`chdir` for Windows)\n\nCurrently passes test :\n`./miri run tests/run-pass/current_dir.rs -Zmiri-disable-isolation`", "tree": {"sha": "54904dc65cbe4be57b2624333bd939a9ac4e6e00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54904dc65cbe4be57b2624333bd939a9ac4e6e00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3504d5266830e99f7cd2b978e91250bf1c35ee45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3504d5266830e99f7cd2b978e91250bf1c35ee45", "html_url": "https://github.com/rust-lang/rust/commit/3504d5266830e99f7cd2b978e91250bf1c35ee45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3504d5266830e99f7cd2b978e91250bf1c35ee45/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c706f50e3ffb4425a82cf67834402f000f1f9940", "url": "https://api.github.com/repos/rust-lang/rust/commits/c706f50e3ffb4425a82cf67834402f000f1f9940", "html_url": "https://github.com/rust-lang/rust/commit/c706f50e3ffb4425a82cf67834402f000f1f9940"}, {"sha": "9bdb4bbbbf17c2d94eece96ddc6114a3c9104f73", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bdb4bbbbf17c2d94eece96ddc6114a3c9104f73", "html_url": "https://github.com/rust-lang/rust/commit/9bdb4bbbbf17c2d94eece96ddc6114a3c9104f73"}], "stats": {"total": 254, "additions": 174, "deletions": 80}, "files": [{"sha": "5407eb12051790133c16a7a7f5b8524203b64439", "filename": "src/helpers.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=3504d5266830e99f7cd2b978e91250bf1c35ee45", "patch": "@@ -71,6 +71,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .not_undef()\n     }\n \n+    /// Helper function to get a `windows` constant as a `Scalar`.\n+    fn eval_windows(&mut self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+        self.eval_context_mut()\n+            .eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", name])?\n+            .not_undef()\n+    }\n+\n     /// Helper function to get a `libc` constant as an `i32`.\n     fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n         // TODO: Cache the result.\n@@ -407,6 +414,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         use std::io::ErrorKind::*;\n         let this = self.eval_context_mut();\n         let target = &this.tcx.sess.target.target;\n+        let target_os = &target.target_os;\n         let last_error = if target.options.target_family == Some(\"unix\".to_owned()) {\n             this.eval_libc(match e.kind() {\n                 ConnectionRefused => \"ECONNREFUSED\",\n@@ -427,12 +435,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     throw_unsup_format!(\"io error {} cannot be transformed into a raw os error\", e)\n                 }\n             })?\n+        } else if target_os == \"windows\" {\n+            // FIXME: we have to finish implementing the Windows equivalent of this.\n+            this.eval_windows(match e.kind() {\n+                NotFound => \"ERROR_FILE_NOT_FOUND\",\n+                _ => throw_unsup_format!(\"io error {} cannot be transformed into a raw os error\", e)\n+            })?\n         } else {\n-            // FIXME: we have to implement the Windows equivalent of this.\n-            throw_unsup_format!(\n-                \"setting the last OS error from an io::Error is unsupported for {}.\",\n-                target.target_os\n-            )\n+            throw_unsup_format!(\"setting the last OS error from an io::Error is unsupported for {}.\", target_os)\n         };\n         this.set_last_error(last_error)\n     }"}, {"sha": "5846f51b90428bd8fa1dffea647a157e0e1ce0d3", "filename": "src/shims/env.rs", "status": "modified", "additions": 70, "deletions": 17, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=3504d5266830e99f7cd2b978e91250bf1c35ee45", "patch": "@@ -10,6 +10,21 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc::ty::layout::Size;\n use rustc_mir::interpret::Pointer;\n \n+/// Check whether an operation that writes to a target buffer was successful.\n+/// Accordingly select return value.\n+/// Local helper function to be used in Windows shims.\n+fn windows_check_buffer_size((success, len): (bool, u64)) -> u32 {\n+    if success {\n+        // If the function succeeds, the return value is the number of characters stored in the target buffer,\n+        // not including the terminating null character.\n+        u32::try_from(len).unwrap()\n+    } else {\n+        // If the target buffer was not large enough to hold the data, the return value is the buffer size, in characters,\n+        // required to hold the string and its terminating null character.\n+        u32::try_from(len.checked_add(1).unwrap()).unwrap()\n+    }\n+}\n+\n #[derive(Default)]\n pub struct EnvVars<'tcx> {\n     /// Stores pointers to the environment variables. These variables must be stored as\n@@ -105,10 +120,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetEnvironmentVariableW(\n         &mut self,\n-        name_op: OpTy<'tcx, Tag>, // LPCWSTR\n-        buf_op: OpTy<'tcx, Tag>,  // LPWSTR\n-        size_op: OpTy<'tcx, Tag>, // DWORD\n-    ) -> InterpResult<'tcx, u32> {\n+        name_op: OpTy<'tcx, Tag>,  // LPCWSTR\n+        buf_op: OpTy<'tcx, Tag>,   // LPWSTR\n+        size_op: OpTy<'tcx, Tag>,  // DWORD\n+    ) -> InterpResult<'tcx, u32> { // Returns DWORD (u32 in Windows)\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentVariableW\");\n \n@@ -125,21 +140,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let buf_ptr = this.read_scalar(buf_op)?.not_undef()?;\n                 // `buf_size` represents the size in characters.\n                 let buf_size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n-                let (success, len) = this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?;\n-\n-                if success {\n-                    // If the function succeeds, the return value is the number of characters stored in the buffer pointed to by lpBuffer,\n-                    // not including the terminating null character.\n-                    u32::try_from(len).unwrap()\n-                } else {\n-                    // If lpBuffer is not large enough to hold the data, the return value is the buffer size, in characters,\n-                    // required to hold the string and its terminating null character and the contents of lpBuffer are undefined.\n-                    u32::try_from(len).unwrap().checked_add(1).unwrap()\n-                }\n+                windows_check_buffer_size(this.write_os_str_to_wide_str(&var, buf_ptr, buf_size)?)\n             }\n             None => {\n-                let envvar_not_found = this.eval_path_scalar(&[\"std\", \"sys\", \"windows\", \"c\", \"ERROR_ENVVAR_NOT_FOUND\"])?;\n-                this.set_last_error(envvar_not_found.not_undef()?)?;\n+                let envvar_not_found = this.eval_windows(\"ERROR_ENVVAR_NOT_FOUND\")?;\n+                this.set_last_error(envvar_not_found)?;\n                 0 // return zero upon failure\n             }\n         })\n@@ -289,6 +294,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         size_op: OpTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n+        let target_os = &this.tcx.sess.target.target.target_os;\n+        assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n \n         this.check_no_isolation(\"getcwd\")?;\n \n@@ -308,8 +315,33 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(Scalar::null_ptr(&*this.tcx))\n     }\n \n+    #[allow(non_snake_case)]\n+    fn GetCurrentDirectoryW(\n+        &mut self,\n+        size_op: OpTy<'tcx, Tag>, // DWORD\n+        buf_op: OpTy<'tcx, Tag>,  // LPTSTR\n+    ) -> InterpResult<'tcx, u32> {\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n+\n+        this.check_no_isolation(\"GetCurrentDirectoryW\")?;\n+\n+        let size = u64::from(this.read_scalar(size_op)?.to_u32()?);\n+        let buf = this.read_scalar(buf_op)?.not_undef()?;\n+\n+        // If we cannot get the current directory, we return 0\n+        match env::current_dir() {\n+            Ok(cwd) =>\n+                return Ok(windows_check_buffer_size(this.write_path_to_wide_str(&cwd, buf, size)?)),\n+            Err(e) => this.set_last_error_from_io_error(e)?,\n+        }\n+        Ok(0)\n+    }\n+\n     fn chdir(&mut self, path_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n+        let target_os = &this.tcx.sess.target.target.target_os;\n+        assert!(target_os == \"linux\" || target_os == \"macos\", \"`getcwd` is only available for the UNIX target family\");\n \n         this.check_no_isolation(\"chdir\")?;\n \n@@ -324,6 +356,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n+    #[allow(non_snake_case)]\n+    fn SetCurrentDirectoryW (\n+        &mut self,\n+        path_op: OpTy<'tcx, Tag>   // LPCTSTR\n+    ) -> InterpResult<'tcx, i32> { // Returns BOOL (i32 in Windows)\n+        let this = self.eval_context_mut();\n+        this.assert_target_os(\"windows\", \"SetCurrentDirectoryW\");\n+\n+        this.check_no_isolation(\"SetCurrentDirectoryW\")?;\n+\n+        let path = this.read_path_from_wide_str(this.read_scalar(path_op)?.not_undef()?)?;\n+\n+        match env::set_current_dir(path) {\n+            Ok(()) => Ok(1),\n+            Err(e) => {\n+                this.set_last_error_from_io_error(e)?;\n+                Ok(0)\n+            }\n+        }\n+    }\n+\n     /// Updates the `environ` static.\n     /// The first time it gets called, also initializes `extra.environ`.\n     fn update_environ(&mut self) -> InterpResult<'tcx> {"}, {"sha": "ecd1432df0cce88d5f5bacab4d5c752f10ab563d", "filename": "src/shims/foreign_items/windows.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fforeign_items%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fforeign_items%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fwindows.rs?ref=3504d5266830e99f7cd2b978e91250bf1c35ee45", "patch": "@@ -40,6 +40,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n \n+            \"GetCurrentDirectoryW\" => {\n+                let result = this.GetCurrentDirectoryW(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_u32(result), dest)?;\n+            }\n+\n+            \"SetCurrentDirectoryW\" => {\n+                let result = this.SetCurrentDirectoryW(args[0])?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n+\n             // File related shims\n             \"GetStdHandle\" => {\n                 let which = this.read_scalar(args[0])?.to_i32()?;"}, {"sha": "74932ef6ca4ed2ea1cc4efa58f8a87707654cad7", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 75, "deletions": 55, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3504d5266830e99f7cd2b978e91250bf1c35ee45/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=3504d5266830e99f7cd2b978e91250bf1c35ee45", "patch": "@@ -13,6 +13,53 @@ use rustc::ty::layout::LayoutOf;\n \n use crate::*;\n \n+/// Represent how path separator conversion should be done.\n+enum Pathconversion {\n+    HostToTarget,\n+    TargetToHost,\n+}\n+\n+/// Perform path separator conversion if needed.\n+fn convert_path_separator<'a>(\n+    os_str: &'a OsStr,\n+    target_os: &str,\n+    direction: Pathconversion,\n+) -> Cow<'a, OsStr> {\n+    #[cfg(windows)]\n+    return if target_os == \"windows\" {\n+        // Windows-on-Windows, all fine.\n+        Cow::Borrowed(os_str)\n+    } else {\n+        // Unix target, Windows host.\n+        let (from, to) = match direction {\n+            Pathconversion::HostToTarget => ('\\\\', '/'),\n+            Pathconversion::TargetToHost => ('/', '\\\\'),\n+        };\n+        let converted = os_str\n+            .encode_wide()\n+            .map(|wchar| if wchar == from as u16 { to as u16 } else { wchar })\n+            .collect::<Vec<_>>();\n+        Cow::Owned(OsString::from_wide(&converted))\n+    };\n+    #[cfg(unix)]\n+    return if target_os == \"windows\" {\n+        // Windows target, Unix host.\n+        let (from, to) = match direction {\n+            Pathconversion::HostToTarget => ('/', '\\\\'),\n+            Pathconversion::TargetToHost => ('\\\\', '/'),\n+        };\n+        let converted = os_str\n+            .as_bytes()\n+            .iter()\n+            .map(|&wchar| if wchar == from as u8 { to as u8 } else { wchar })\n+            .collect::<Vec<_>>();\n+        Cow::Owned(OsString::from_vec(converted))\n+    } else {\n+        // Unix-on-Unix, all is fine.\n+        Cow::Borrowed(os_str)\n+    };\n+}\n+\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Helper function to read an OsString from a null-terminated sequence of bytes, which is what\n@@ -179,70 +226,43 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_c_str(scalar)?;\n \n-        #[cfg(windows)]\n-        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows-on-Windows, all fine.\n-            Cow::Borrowed(Path::new(os_str))\n-        } else {\n-            // Unix target, Windows host. Need to convert target '/' to host '\\'.\n-            let converted = os_str\n-                .encode_wide()\n-                .map(|wchar| if wchar == '/' as u16 { '\\\\' as u16 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(PathBuf::from(OsString::from_wide(&converted)))\n-        });\n-        #[cfg(unix)]\n-        return Ok(if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows target, Unix host. Need to convert target '\\' to host '/'.\n-            let converted = os_str\n-                .as_bytes()\n-                .iter()\n-                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(PathBuf::from(OsString::from_vec(converted)))\n-        } else {\n-            // Unix-on-Unix, all is fine.\n-            Cow::Borrowed(Path::new(os_str))\n-        });\n+        Ok(match convert_path_separator(os_str, &this.tcx.sess.target.target.target_os, Pathconversion::TargetToHost) {\n+            Cow::Borrowed(x) => Cow::Borrowed(Path::new(x)),\n+            Cow::Owned(y) => Cow::Owned(PathBuf::from(y)),\n+        })\n+    }\n+\n+    /// Read a null-terminated sequence of `u16`s, and perform path separator conversion if needed.\n+    fn read_path_from_wide_str(&self, scalar: Scalar<Tag>) -> InterpResult<'tcx, PathBuf> {\n+        let this = self.eval_context_ref();\n+        let os_str = this.read_os_str_from_wide_str(scalar)?;\n+\n+        Ok(PathBuf::from(&convert_path_separator(&os_str, &this.tcx.sess.target.target.target_os, Pathconversion::TargetToHost)))\n     }\n \n-    /// Write a Path to the machine memory, adjusting path separators if needed.\n+    /// Write a Path to the machine memory (as a null-terminated sequence of bytes),\n+    /// adjusting path separators if needed.\n     fn write_path_to_c_str(\n         &mut self,\n         path: &Path,\n         scalar: Scalar<Tag>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n-\n-        #[cfg(windows)]\n-        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows-on-Windows, all fine.\n-            Cow::Borrowed(path.as_os_str())\n-        } else {\n-            // Unix target, Windows host. Need to convert host '\\\\' to target '/'.\n-            let converted = path\n-                .as_os_str()\n-                .encode_wide()\n-                .map(|wchar| if wchar == '\\\\' as u16 { '/' as u16 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(OsString::from_wide(&converted))\n-        };\n-        #[cfg(unix)]\n-        let os_str = if this.tcx.sess.target.target.target_os == \"windows\" {\n-            // Windows target, Unix host. Need to convert host '/' to target '\\'.\n-            let converted = path\n-                .as_os_str()\n-                .as_bytes()\n-                .iter()\n-                .map(|&wchar| if wchar == '/' as u8 { '\\\\' as u8 } else { wchar })\n-                .collect::<Vec<_>>();\n-            Cow::Owned(OsString::from_vec(converted))\n-        } else {\n-            // Unix-on-Unix, all is fine.\n-            Cow::Borrowed(path.as_os_str())\n-        };\n-\n+        let os_str = convert_path_separator(path.as_os_str(), &this.tcx.sess.target.target.target_os, Pathconversion::HostToTarget);\n         this.write_os_str_to_c_str(&os_str, scalar, size)\n     }\n+\n+    /// Write a Path to the machine memory (as a null-terminated sequence of `u16`s),\n+    /// adjusting path separators if needed.\n+    fn write_path_to_wide_str(\n+        &mut self,\n+        path: &Path,\n+        scalar: Scalar<Tag>,\n+        size: u64,\n+    ) -> InterpResult<'tcx, (bool, u64)> {\n+        let this = self.eval_context_mut();\n+        let os_str = convert_path_separator(path.as_os_str(), &this.tcx.sess.target.target.target_os, Pathconversion::HostToTarget);\n+        this.write_os_str_to_wide_str(&os_str, scalar, size)\n+    }\n }"}, {"sha": "a88f820951ca483d15f5ec902b5ae43cc01ed6c6", "filename": "tests/run-pass/current_dir.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3504d5266830e99f7cd2b978e91250bf1c35ee45/tests%2Frun-pass%2Fcurrent_dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3504d5266830e99f7cd2b978e91250bf1c35ee45/tests%2Frun-pass%2Fcurrent_dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcurrent_dir.rs?ref=3504d5266830e99f7cd2b978e91250bf1c35ee45", "patch": "@@ -1,7 +1,6 @@\n-// ignore-windows: TODO the windows hook is not done yet\n // compile-flags: -Zmiri-disable-isolation\n use std::env;\n-use std::path::Path;\n+use std::io::ErrorKind;\n \n fn main() {\n     // Test that `getcwd` is available\n@@ -11,7 +10,9 @@ fn main() {\n     // keep the current directory equal to `cwd`.\n     let parent = cwd.parent().unwrap_or(&cwd);\n     // Test that `chdir` is available\n-    assert!(env::set_current_dir(&Path::new(\"..\")).is_ok());\n+    assert!(env::set_current_dir(\"..\").is_ok());\n     // Test that `..` goes to the parent directory\n     assert_eq!(env::current_dir().unwrap(), parent);\n+    // Test that `chdir` to a non-existing directory returns a proper error\n+    assert_eq!(env::set_current_dir(\"thisdoesnotexist\").unwrap_err().kind(), ErrorKind::NotFound);\n }"}]}