{"sha": "9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "node_id": "C_kwDOAAsO6NoAKDk5NDZkNjc1NzkzMjg4ZTdiZmI1MDkxZmNiOTllMGRjMmZkNTllZTg", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-03T02:58:44Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2023-06-12T01:19:37Z"}, "message": "rustdoc-search: build args, return, and generics on one unifier\n\nThis enhances generics with the \"unboxing\" behavior where A<T>\nmatches T. It makes this unboxing transitive over generics.", "tree": {"sha": "dfdea5d5bf24bc9211df0fc64abe1f3cd4ffc296", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfdea5d5bf24bc9211df0fc64abe1f3cd4ffc296"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "html_url": "https://github.com/rust-lang/rust/commit/9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04f4493722a29018b85e6c2893c15ab0285d5dcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/04f4493722a29018b85e6c2893c15ab0285d5dcd", "html_url": "https://github.com/rust-lang/rust/commit/04f4493722a29018b85e6c2893c15ab0285d5dcd"}], "stats": {"total": 316, "additions": 178, "deletions": 138}, "files": [{"sha": "f697abd07765a53569c66b4282e73099faf0a513", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "patch": "@@ -53,7 +53,7 @@ let ParsedQuery;\n  *    parent: (Object|null|undefined),\n  *    path: string,\n  *    ty: (Number|null|number),\n- *    type: (Array<?>|null)\n+ *    type: FunctionSearchType?\n  * }}\n  */\n let Row;\n@@ -135,7 +135,7 @@ let RawFunctionType;\n /**\n  * @typedef {{\n  *     inputs: Array<FunctionType>,\n- *     outputs: Array<FunctionType>,\n+ *     output: Array<FunctionType>,\n  * }}\n  */\n let FunctionSearchType;"}, {"sha": "ba5d3843360031de85e1013d27401ec91daa32ff", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 103, "deletions": 136, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "patch": "@@ -1178,98 +1178,137 @@ function initSearch(rawSearchIndex) {\n         }\n \n         /**\n-         * This function checks if the object (`row`) generics match the given type (`elem`)\n-         * generics.\n+         * This function checks generics in search query `queryElem` can all be found in the\n+         * search index (`fnType`),\n          *\n-         * @param {Row} row                 - The object to check.\n-         * @param {QueryElement} elem       - The element from the parsed query.\n+         * @param {FunctionType} fnType     - The object to check.\n+         * @param {QueryElement} queryElem  - The element from the parsed query.\n          *\n-         * @return {boolean}           - Returns true if a match, false otherwise.\n+         * @return {boolean} - Returns true if a match, false otherwise.\n          */\n-        function checkGenerics(row, elem) {\n-            if (row.generics.length === 0 || elem.generics.length === 0) {\n-                return false;\n-            }\n-            // This function is called if the names match, but we need to make\n-            // sure that all generics match as well.\n-            //\n+        function checkGenerics(fnType, queryElem) {\n+            return unifyFunctionTypes(fnType.generics, queryElem.generics);\n+        }\n+        /**\n+         * This function checks if a list of search query `queryElems` can all be found in the\n+         * search index (`fnTypes`).\n+         *\n+         * @param {Array<FunctionType>} fnTypes    - The objects to check.\n+         * @param {Array<QueryElement>} queryElems - The elements from the parsed query.\n+         *\n+         * @return {boolean} - Returns true if a match, false otherwise.\n+         */\n+        function unifyFunctionTypes(fnTypes, queryElems) {\n             // This search engine implements order-agnostic unification. There\n             // should be no missing duplicates (generics have \"bag semantics\"),\n             // and the row is allowed to have extras.\n-            if (elem.generics.length <= 0 || row.generics.length < elem.generics.length) {\n+            if (queryElems.length === 0) {\n+                return true;\n+            }\n+            if (!fnTypes || fnTypes.length === 0) {\n                 return false;\n             }\n-            const elems = new Map();\n-            const addEntryToElems = function addEntryToElems(entry) {\n-                if (entry.id === -1) {\n+            /**\n+             * @type Map<integer, FunctionType[]>\n+             */\n+            const fnTypeSet = new Map();\n+            const addFnTypeToFnTypeSet = function addFnTypeToFnTypeSet(fnType) {\n+                if (fnType.id === -1) {\n                     // Pure generic, needs to check into it.\n-                    for (const inner_entry of entry.generics) {\n-                        addEntryToElems(inner_entry);\n+                    for (const innerFnType of fnType.generics) {\n+                        addFnTypeToFnTypeSet(innerFnType);\n                     }\n                     return;\n                 }\n-                let currentEntryElems;\n-                if (elems.has(entry.id)) {\n-                    currentEntryElems = elems.get(entry.id);\n+                let currentFnTypeList;\n+                if (fnTypeSet.has(fnType.id)) {\n+                    currentFnTypeList = fnTypeSet.get(fnType.id);\n                 } else {\n-                    currentEntryElems = [];\n-                    elems.set(entry.id, currentEntryElems);\n+                    currentFnTypeList = [];\n+                    fnTypeSet.set(fnType.id, currentFnTypeList);\n                 }\n-                currentEntryElems.push(entry);\n+                currentFnTypeList.push(fnType);\n             };\n-            for (const entry of row.generics) {\n-                addEntryToElems(entry);\n+            for (const fnType of fnTypes) {\n+                addFnTypeToFnTypeSet(fnType);\n             }\n             // We need to find the type that matches the most to remove it in order\n             // to move forward.\n-            const handleGeneric = generic => {\n-                if (!elems.has(generic.id)) {\n+            const handleQueryElem = queryElem => {\n+                if (!fnTypeSet.has(queryElem.id)) {\n                     return false;\n                 }\n-                const matchElems = elems.get(generic.id);\n-                const matchIdx = matchElems.findIndex(tmp_elem => {\n-                    if (generic.generics.length > 0 && !checkGenerics(tmp_elem, generic)) {\n+                const currentFnTypeList = fnTypeSet.get(queryElem.id);\n+                const matchIdx = currentFnTypeList.findIndex(fnType => {\n+                    if (!typePassesFilter(queryElem.typeFilter, fnType.ty)) {\n                         return false;\n                     }\n-                    return typePassesFilter(generic.typeFilter, tmp_elem.ty);\n+                    return queryElem.generics.length === 0 || checkGenerics(fnType, queryElem);\n                 });\n                 if (matchIdx === -1) {\n                     return false;\n                 }\n-                matchElems.splice(matchIdx, 1);\n-                if (matchElems.length === 0) {\n-                    elems.delete(generic.id);\n+                currentFnTypeList.splice(matchIdx, 1);\n+                if (currentFnTypeList.length === 0) {\n+                    fnTypeSet.delete(queryElem.id);\n                 }\n                 return true;\n             };\n             // To do the right thing with type filters, we first process generics\n             // that have them, removing matching ones from the \"bag,\" then do the\n             // ones with no type filter, which can match any entry regardless of its\n             // own type.\n-            for (const generic of elem.generics) {\n-                if (generic.typeFilter === TY_PRIMITIVE &&\n-                    generic.id === typeNameIdOfArrayOrSlice) {\n-                    const genericArray = {\n+            const needsUnboxed = [];\n+            for (const queryElem of queryElems) {\n+                if (queryElem.typeFilter === TY_PRIMITIVE &&\n+                    queryElem.id === typeNameIdOfArrayOrSlice) {\n+                    const queryElemArray = {\n                         id: typeNameIdOfArray,\n                         typeFilter: TY_PRIMITIVE,\n-                        generics: generic.generics,\n+                        generics: queryElem.generics,\n                     };\n-                    const genericSlice = {\n+                    const queryElemSlice = {\n                         id: typeNameIdOfSlice,\n                         typeFilter: TY_PRIMITIVE,\n-                        generics: generic.generics,\n+                        generics: queryElem.generics,\n                     };\n-                    if (!handleGeneric(genericArray) && !handleGeneric(genericSlice)) {\n-                        return false;\n+                    if (!handleQueryElem(queryElemArray) && !handleQueryElem(queryElemSlice)) {\n+                        needsUnboxed.push(queryElem);\n                     }\n-                } else if (generic.typeFilter !== -1 && !handleGeneric(generic)) {\n-                    return false;\n+                } else if (queryElem.typeFilter !== -1 && !handleQueryElem(queryElem)) {\n+                    needsUnboxed.push(queryElem);\n                 }\n             }\n-            for (const generic of elem.generics) {\n-                if (generic.typeFilter === -1 && !handleGeneric(generic)) {\n-                    return false;\n+            for (const queryElem of queryElems) {\n+                if (queryElem.typeFilter === -1 && !handleQueryElem(queryElem)) {\n+                    needsUnboxed.push(queryElem);\n+                }\n+            }\n+            // If the current item does not match, try [unboxing] the generic.\n+            // [unboxing]:\n+            //   https://ndmitchell.com/downloads/slides-hoogle_fast_type_searching-09_aug_2008.pdf\n+            unboxing: while (needsUnboxed.length !== 0) {\n+                for (const [i, queryElem] of needsUnboxed.entries()) {\n+                    if (handleQueryElem(queryElem)) {\n+                        needsUnboxed.splice(i, 1);\n+                        continue unboxing;\n+                    }\n+                }\n+                for (const [id, fnTypeList] of fnTypeSet) {\n+                    for (const [i, fnType] of fnTypeList.entries()) {\n+                        if (fnType.generics.length !== 0) {\n+                            fnTypeList.splice(i, 1);\n+                            for (const innerFnType of fnType.generics) {\n+                                addFnTypeToFnTypeSet(innerFnType);\n+                            }\n+                            if (fnTypeList.length === 0) {\n+                                fnTypeSet.delete(id);\n+                            }\n+                            continue unboxing;\n+                        }\n+                    }\n                 }\n+                return false;\n             }\n             return true;\n         }\n@@ -1278,13 +1317,13 @@ function initSearch(rawSearchIndex) {\n           * This function checks if the object (`row`) matches the given type (`elem`) and its\n           * generics (if any).\n           *\n-          * @param {Row} row\n+          * @param {Array<FunctionType>} list\n           * @param {QueryElement} elem    - The element from the parsed query.\n           *\n           * @return {boolean} - Returns true if found, false otherwise.\n           */\n-        function checkIfInGenerics(row, elem) {\n-            for (const entry of row.generics) {\n+        function checkIfInList(list, elem) {\n+            for (const entry of list) {\n                 if (checkType(entry, elem)) {\n                     return true;\n                 }\n@@ -1304,7 +1343,7 @@ function initSearch(rawSearchIndex) {\n         function checkType(row, elem) {\n             if (row.id === -1) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n-                return row.generics.length > 0 ? checkIfInGenerics(row, elem) : false;\n+                return row.generics.length > 0 ? checkIfInList(row.generics, elem) : false;\n             }\n \n             const matchesExact = row.id === elem.id;\n@@ -1322,59 +1361,7 @@ function initSearch(rawSearchIndex) {\n             // If the current item does not match, try [unboxing] the generic.\n             // [unboxing]:\n             //   https://ndmitchell.com/downloads/slides-hoogle_fast_type_searching-09_aug_2008.pdf\n-            return checkIfInGenerics(row, elem);\n-        }\n-\n-        /**\n-         * This function checks if the object (`row`) has an argument with the given type (`elem`).\n-         *\n-         * @param {Row} row\n-         * @param {QueryElement} elem    - The element from the parsed query.\n-         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n-         *\n-         * @return {integer} - Returns the position of the match, or -1 if none.\n-         */\n-        function findArg(row, elem, skipPositions) {\n-            if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n-                let i = 0;\n-                for (const input of row.type.inputs) {\n-                    if (skipPositions.indexOf(i) !== -1) {\n-                        i += 1;\n-                        continue;\n-                    }\n-                    if (checkType(input, elem)) {\n-                        return i;\n-                    }\n-                    i += 1;\n-                }\n-            }\n-            return -1;\n-        }\n-\n-        /**\n-         * This function checks if the object (`row`) returns the given type (`elem`).\n-         *\n-         * @param {Row} row\n-         * @param {QueryElement} elem   - The element from the parsed query.\n-         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n-         *\n-         * @return {integer} - Returns the position of the matching item, or -1 if none.\n-         */\n-        function checkReturned(row, elem, skipPositions) {\n-            if (row && row.type && row.type.output.length > 0) {\n-                let i = 0;\n-                for (const ret_ty of row.type.output) {\n-                    if (skipPositions.indexOf(i) !== -1) {\n-                        i += 1;\n-                        continue;\n-                    }\n-                    if (checkType(ret_ty, elem)) {\n-                        return i;\n-                    }\n-                    i += 1;\n-                }\n-            }\n-            return -1;\n+            return checkIfInList(row.generics, elem);\n         }\n \n         function checkPath(contains, ty, maxEditDistance) {\n@@ -1575,14 +1562,14 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, []);\n-            if (in_args !== -1) {\n+            const in_args = row.type && row.type.inputs && checkIfInList(row.type.inputs, elem);\n+            if (in_args) {\n                 // path_dist is 0 because no parent path information is currently stored\n                 // in the search index\n                 addIntoResults(results_in_args, fullId, pos, -1, 0, 0, maxEditDistance);\n             }\n-            const returned = checkReturned(row, elem, []);\n-            if (returned !== -1) {\n+            const returned = row.type && row.type.output && checkIfInList(row.type.output, elem);\n+            if (returned) {\n                 addIntoResults(results_returned, fullId, pos, -1, 0, 0, maxEditDistance);\n             }\n \n@@ -1638,32 +1625,15 @@ function initSearch(rawSearchIndex) {\n          * @param {Object} results\n          */\n         function handleArgs(row, pos, results) {\n-            if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n+            if (!row || (filterCrates !== null && row.crate !== filterCrates) || !row.type) {\n                 return;\n             }\n \n             // If the result is too \"bad\", we return false and it ends this search.\n-            function checkArgs(elems, callback) {\n-                const skipPositions = [];\n-                for (const elem of elems) {\n-                    // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const position = callback(\n-                        row,\n-                        elem,\n-                        skipPositions\n-                    );\n-                    if (position !== -1) {\n-                        skipPositions.push(position);\n-                    } else {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-            if (!checkArgs(parsedQuery.elems, findArg)) {\n+            if (!unifyFunctionTypes(row.type.inputs, parsedQuery.elems)) {\n                 return;\n             }\n-            if (!checkArgs(parsedQuery.returned, checkReturned)) {\n+            if (!unifyFunctionTypes(row.type.output, parsedQuery.returned)) {\n                 return;\n             }\n \n@@ -1750,12 +1720,9 @@ function initSearch(rawSearchIndex) {\n                     elem = parsedQuery.returned[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         row = searchIndex[i];\n-                        in_returned = checkReturned(\n-                            row,\n-                            elem,\n-                            []\n-                        );\n-                        if (in_returned !== -1) {\n+                        in_returned = row.type &&\n+                            unifyFunctionTypes(row.type.output, parsedQuery.returned);\n+                        if (in_returned) {\n                             addIntoResults(\n                                 results_others,\n                                 row.id,"}, {"sha": "44f784eb1f638007a6579393127e893e23ffaada", "filename": "tests/rustdoc-js/nested-unboxed.js", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/tests%2Frustdoc-js%2Fnested-unboxed.js", "raw_url": "https://github.com/rust-lang/rust/raw/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/tests%2Frustdoc-js%2Fnested-unboxed.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fnested-unboxed.js?ref=9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "patch": "@@ -0,0 +1,68 @@\n+// exact-check\n+\n+const EXPECTED = [\n+    {\n+        'query': '-> Result<Object, bool>',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Result<Object<i32, u32>, bool>',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Object, bool',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Object<i32, u32>, bool',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> i32, u32, bool',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Result<i32, u32, bool>',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Result<Object<i32>, bool>',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Result<Object<u32>, bool>',\n+        'others': [\n+            { 'path': 'nested_unboxed', 'name': 'something' },\n+        ],\n+    },\n+    {\n+        'query': '-> Result<Object<i32>, u32, bool>',\n+        'others': [],\n+    },\n+    {\n+        'query': '-> Result<i32, Object<u32>, bool>',\n+        'others': [],\n+    },\n+    {\n+        'query': '-> Result<i32, u32, Object<bool>>',\n+        'others': [],\n+    },\n+    {\n+        'query': '-> Result<Object<i32>, Object<u32>, bool>',\n+        'others': [],\n+    },\n+];"}, {"sha": "57f9592b791471e99c49a4bb4e8958b11ffd55c7", "filename": "tests/rustdoc-js/nested-unboxed.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/tests%2Frustdoc-js%2Fnested-unboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9946d675793288e7bfb5091fcb99e0dc2fd59ee8/tests%2Frustdoc-js%2Fnested-unboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fnested-unboxed.rs?ref=9946d675793288e7bfb5091fcb99e0dc2fd59ee8", "patch": "@@ -0,0 +1,5 @@\n+pub struct Object<T, U>(T, U);\n+\n+pub fn something() -> Result<Object<i32, u32>, bool> {\n+    loop {}\n+}"}]}