{"sha": "2c649830be732bc0af585ba4ef54b2c6555b7c1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNjQ5ODMwYmU3MzJiYzBhZjU4NWJhNGVmNTRiMmM2NTU1YjdjMWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T16:43:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-10T16:43:01Z"}, "message": "auto merge of #5709 : jbclements/rust/miscellaneous-cleanup, r=jbclements\n\nThere's no unifying theme here; I'm just trying to clear a bunch of small commits: removing dead code, adding comments, renaming to an upper-case type, fixing one test case.", "tree": {"sha": "1d76dbaa24449d9bfc3bb745ad2979c9da5bec07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d76dbaa24449d9bfc3bb745ad2979c9da5bec07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c649830be732bc0af585ba4ef54b2c6555b7c1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c649830be732bc0af585ba4ef54b2c6555b7c1c", "html_url": "https://github.com/rust-lang/rust/commit/2c649830be732bc0af585ba4ef54b2c6555b7c1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c649830be732bc0af585ba4ef54b2c6555b7c1c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "html_url": "https://github.com/rust-lang/rust/commit/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158"}, {"sha": "9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "url": "https://api.github.com/repos/rust-lang/rust/commits/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66", "html_url": "https://github.com/rust-lang/rust/commit/9deb2f2dfabd0ad164eedf84fe7e91b0b5dabf66"}], "stats": {"total": 451, "additions": 138, "deletions": 313}, "files": [{"sha": "387cc9f80a7f6651feeab9f334e3a8e347e9071e", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -77,7 +77,7 @@ fn inject_libcore_ref(sess: Session,\n         fold_mod: |module, fld| {\n             let n2 = sess.next_node_id();\n \n-            let prelude_path = @ast::path {\n+            let prelude_path = @ast::Path {\n                 span: dummy_sp(),\n                 global: false,\n                 idents: ~["}, {"sha": "0cb1fdf91829a42acb6f23b407cc9e96ebc29915", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -336,16 +336,16 @@ fn nospan<T:Copy>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n }\n \n-fn path_node(+ids: ~[ast::ident]) -> @ast::path {\n-    @ast::path { span: dummy_sp(),\n+fn path_node(+ids: ~[ast::ident]) -> @ast::Path {\n+    @ast::Path { span: dummy_sp(),\n                 global: false,\n                 idents: ids,\n                 rp: None,\n                 types: ~[] }\n }\n \n-fn path_node_global(+ids: ~[ast::ident]) -> @ast::path {\n-    @ast::path { span: dummy_sp(),\n+fn path_node_global(+ids: ~[ast::ident]) -> @ast::Path {\n+    @ast::Path { span: dummy_sp(),\n                  global: true,\n                  idents: ids,\n                  rp: None,"}, {"sha": "72391b7aec2a1313fbbd59a2127ee54468a5cdb2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -137,7 +137,7 @@ pub fn parse_arg_data(data: @~[u8], crate_num: int, pos: uint, tcx: ty::ctxt,\n     parse_arg(st, conv)\n }\n \n-fn parse_path(st: @mut PState) -> @ast::path {\n+fn parse_path(st: @mut PState) -> @ast::Path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { return c == '(' || c == ':'; }\n     idents.push(parse_ident_(st, is_last));\n@@ -146,7 +146,7 @@ fn parse_path(st: @mut PState) -> @ast::path {\n           ':' => { next(st); next(st); }\n           c => {\n             if c == '(' {\n-                return @ast::path { span: dummy_sp(),\n+                return @ast::Path { span: dummy_sp(),\n                                     global: false,\n                                     idents: idents,\n                                     rp: None,"}, {"sha": "df0e508398ee4d28206c720997347c1a62e94354", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -72,7 +72,7 @@ pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: @pat) -> bool {\n }\n \n pub fn pat_bindings(dm: resolve::DefMap, pat: @pat,\n-                it: &fn(binding_mode, node_id, span, @path)) {\n+                it: &fn(binding_mode, node_id, span, @Path)) {\n     do walk_pat(pat) |p| {\n         match p.node {\n           pat_ident(binding_mode, pth, _) if pat_is_binding(dm, p) => {"}, {"sha": "e59ca9e6581236d5a8bcf7a00dbf11dedd8b75c4", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -26,7 +26,7 @@ use syntax::ast::{decl_item, def, def_fn, def_id, def_static_method};\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_path};\n use syntax::ast::{expr_struct, expr_unary, ident, inherited, item_enum};\n use syntax::ast::{item_foreign_mod, item_fn, item_impl, item_struct};\n-use syntax::ast::{item_trait, local_crate, node_id, pat_struct, path};\n+use syntax::ast::{item_trait, local_crate, node_id, pat_struct, Path};\n use syntax::ast::{private, provided, public, required, stmt_decl, visibility};\n use syntax::ast;\n use syntax::ast_map::{node_foreign_item, node_item, node_method};\n@@ -276,7 +276,7 @@ pub fn check_crate(tcx: ty::ctxt,\n     };\n \n     // Checks that a private path is in scope.\n-    let check_path: @fn(span: span, def: def, path: @path) =\n+    let check_path: @fn(span: span, def: def, path: @Path) =\n             |span, def, path| {\n         debug!(\"checking path\");\n         match def {"}, {"sha": "adc348b692b1489464c131d9a866a708206d768c", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -48,7 +48,7 @@ use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n use syntax::ast::{local, local_crate, lt, method, mode, mul};\n use syntax::ast::{named_field, ne, neg, node_id, pat, pat_enum, pat_ident};\n-use syntax::ast::{path, pat_lit, pat_range, pat_struct};\n+use syntax::ast::{Path, pat_lit, pat_range, pat_struct};\n use syntax::ast::{prim_ty, private, provided};\n use syntax::ast::{public, required, rem, self_ty_, shl, shr, stmt_decl};\n use syntax::ast::{struct_dtor, struct_field, struct_variant_kind};\n@@ -4368,7 +4368,7 @@ pub impl Resolver {\n     /// If `check_ribs` is true, checks the local definitions first; i.e.\n     /// doesn't skip straight to the containing module.\n     fn resolve_path(@mut self,\n-                    path: @path,\n+                    path: @Path,\n                     namespace: Namespace,\n                     check_ribs: bool,\n                     visitor: ResolveVisitor)\n@@ -4493,7 +4493,7 @@ pub impl Resolver {\n         return NoNameDefinition;\n     }\n \n-    fn intern_module_part_of_path(@mut self, path: @path) -> ~[ident] {\n+    fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1 {\n@@ -4507,7 +4507,7 @@ pub impl Resolver {\n     }\n \n     fn resolve_module_relative_path(@mut self,\n-                                    path: @path,\n+                                    path: @Path,\n                                     +xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n@@ -4553,7 +4553,7 @@ pub impl Resolver {\n     /// Invariant: This must be called only during main resolution, not during\n     /// import resolution.\n     fn resolve_crate_relative_path(@mut self,\n-                                   path: @path,\n+                                   path: @Path,\n                                    +xray: XrayFlag,\n                                    namespace: Namespace)\n                                 -> Option<def> {"}, {"sha": "a0c12ff1a204c5934ec5ae65c9a85d8f68c1584b", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -136,7 +136,7 @@ fn ast_path_substs<AC:AstConv,RS:region_scope + Copy + Durable>(\n     def_id: ast::def_id,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n-    path: @ast::path) -> ty::substs\n+    path: @ast::Path) -> ty::substs\n {\n     /*!\n      *\n@@ -188,7 +188,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n     self: &AC,\n     rscope: &RS,\n     did: ast::def_id,\n-    path: @ast::path) -> ty_param_substs_and_ty\n+    path: @ast::Path) -> ty_param_substs_and_ty\n {\n     let tcx = self.tcx();\n     let ty::ty_param_bounds_and_ty {\n@@ -206,7 +206,7 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:region_scope + Copy + Durable>(\n     rscope: &RS,\n     trait_def_id: ast::def_id,\n     self_ty: Option<ty::t>,\n-    path: @ast::path) -> @ty::TraitRef\n+    path: @ast::Path) -> @ty::TraitRef\n {\n     let trait_def =\n         self.get_trait_def(trait_def_id);\n@@ -229,7 +229,7 @@ pub fn ast_path_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         self: &AC,\n         rscope: &RS,\n         did: ast::def_id,\n-        path: @ast::path)\n+        path: @ast::Path)\n      -> ty_param_substs_and_ty\n {\n     // Look up the polytype of the item and then substitute the provided types\n@@ -318,7 +318,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n     }\n \n     fn check_path_args(tcx: ty::ctxt,\n-                       path: @ast::path,\n+                       path: @ast::Path,\n                        flags: uint) {\n         if (flags & NO_TPS) != 0u {\n             if path.types.len() > 0u {"}, {"sha": "e2dd0d1ed9ed25302e94b60be99c5c5ff37998b2", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -99,7 +99,7 @@ pub struct pat_ctxt {\n     block_region: ty::Region, // Region for the block of the arm\n }\n \n-pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n+pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::Path,\n                          subpats: &Option<~[@ast::pat]>, expected: ty::t) {\n \n     // Typecheck the path.\n@@ -234,7 +234,7 @@ pub fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n /// `etc` is true if the pattern said '...' and false otherwise.\n pub fn check_struct_pat_fields(pcx: pat_ctxt,\n                                span: span,\n-                               path: @ast::path,\n+                               path: @ast::Path,\n                                fields: &[ast::field_pat],\n                                class_fields: ~[ty::field_ty],\n                                class_id: ast::def_id,\n@@ -285,7 +285,7 @@ pub fn check_struct_pat_fields(pcx: pat_ctxt,\n }\n \n pub fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n-                        expected: ty::t, path: @ast::path,\n+                        expected: ty::t, path: @ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n                         class_id: ast::def_id, substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n@@ -326,7 +326,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n                                           pat_id: ast::node_id,\n                                           span: span,\n                                           expected: ty::t,\n-                                          path: @ast::path,\n+                                          path: @ast::Path,\n                                           fields: &[ast::field_pat],\n                                           etc: bool,\n                                           enum_id: ast::def_id,"}, {"sha": "0eb2e5387c3bc637ebbed9f3a70741f4c87ffc68", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -3211,7 +3211,7 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n pub fn instantiate_path(fcx: @mut FnCtxt,\n-                        pth: @ast::path,\n+                        pth: @ast::Path,\n                         tpt: ty_param_bounds_and_ty,\n                         span: span,\n                         node_id: ast::node_id,"}, {"sha": "4add371a36f8230406126e2b3f7cb5c0778b78e3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -113,7 +113,7 @@ pub struct Lifetime {\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n-pub struct path {\n+pub struct Path {\n     span: span,\n     global: bool,\n     idents: ~[ident],\n@@ -301,10 +301,10 @@ pub enum pat_ {\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary enums\")\n-    pat_ident(binding_mode, @path, Option<@pat>),\n-    pat_enum(@path, Option<~[@pat]>), /* \"none\" means a * pattern where\n+    pat_ident(binding_mode, @Path, Option<@pat>),\n+    pat_enum(@Path, Option<~[@pat]>), /* \"none\" means a * pattern where\n                                        * we don't bind the fields to names */\n-    pat_struct(@path, ~[field_pat], bool),\n+    pat_struct(@Path, ~[field_pat], bool),\n     pat_tup(~[@pat]),\n     pat_box(@pat),\n     pat_uniq(@pat),\n@@ -567,7 +567,7 @@ pub enum expr_ {\n     expr_assign_op(binop, @expr, @expr),\n     expr_field(@expr, ident, ~[@Ty]),\n     expr_index(@expr, @expr),\n-    expr_path(@path),\n+    expr_path(@Path),\n     expr_addr_of(mutability, @expr),\n     expr_break(Option<ident>),\n     expr_again(Option<ident>),\n@@ -579,7 +579,7 @@ pub enum expr_ {\n     expr_mac(mac),\n \n     // A struct literal expression.\n-    expr_struct(@path, ~[field], Option<@expr>),\n+    expr_struct(@Path, ~[field], Option<@expr>),\n \n     // A vector literal constructed from one repeated element.\n     expr_repeat(@expr /* element */, @expr /* count */, mutability),\n@@ -697,7 +697,7 @@ pub type mac = spanned<mac_>;\n #[auto_decode]\n #[deriving(Eq)]\n pub enum mac_ {\n-    mac_invoc_tt(@path,~[token_tree]),   // new macro-invocation\n+    mac_invoc_tt(@Path,~[token_tree]),   // new macro-invocation\n }\n \n pub type lit = spanned<lit_>;\n@@ -894,7 +894,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n-    ty_path(@path, node_id),\n+    ty_path(@Path, node_id),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not\n@@ -1118,13 +1118,13 @@ pub enum view_path_ {\n     // or just\n     //\n     // foo::bar::baz  (with 'baz =' implicitly on the left)\n-    view_path_simple(ident, @path, namespace, node_id),\n+    view_path_simple(ident, @Path, namespace, node_id),\n \n     // foo::bar::*\n-    view_path_glob(@path, node_id),\n+    view_path_glob(@Path, node_id),\n \n     // foo::bar::{a,b,c}\n-    view_path_list(@path, ~[path_list_ident], node_id)\n+    view_path_list(@Path, ~[path_list_ident], node_id)\n }\n \n #[auto_encode]\n@@ -1177,7 +1177,7 @@ pub struct attribute_ {\n #[auto_decode]\n #[deriving(Eq)]\n pub struct trait_ref {\n-    path: @path,\n+    path: @Path,\n     ref_id: node_id,\n }\n "}, {"sha": "e83a3ef8bad52b7a1c6bccd612a01bd24af41a96", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -30,7 +30,7 @@ pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n }\n \n \n-pub fn path_to_ident(p: @path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n \n pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n@@ -223,8 +223,8 @@ pub fn default_block(\n     }\n }\n \n-pub fn ident_to_path(s: span, +i: ident) -> @path {\n-    @ast::path { span: s,\n+pub fn ident_to_path(s: span, +i: ident) -> @Path {\n+    @ast::Path { span: s,\n                  global: false,\n                  idents: ~[i],\n                  rp: None,"}, {"sha": "0ed371d9c9afe91b87f86ed4f028deafc92faeb4", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -206,8 +206,12 @@ pub struct FileLines\n     lines: ~[uint]\n }\n \n+// represents the origin of a file:\n pub enum FileSubstr {\n+    // indicates that this is a normal standalone file:\n     pub FssNone,\n+    // indicates that this \"file\" is actually a substring\n+    // of another file that appears earlier in the codemap\n     pub FssInternal(span),\n }\n "}, {"sha": "f9dadb560e3d0ee83e4fca56ccf9bead6ddcaaf2", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -224,7 +224,7 @@ priv impl @ext_ctxt {\n         &self,\n         _span: span,\n         ident: ast::ident,\n-        path: @ast::path,\n+        path: @ast::Path,\n         bounds: @OptVec<ast::TyParamBound>\n     ) -> ast::TyParam {\n         let bound = ast::TraitTyParamBound(@ast::trait_ref {\n@@ -248,8 +248,8 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path(&self, span: span, +strs: ~[ast::ident]) -> @ast::path {\n-        @ast::path {\n+    fn path(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+        @ast::Path {\n             span: span,\n             global: false,\n             idents: strs,\n@@ -258,8 +258,8 @@ priv impl @ext_ctxt {\n         }\n     }\n \n-    fn path_global(&self, span: span, +strs: ~[ast::ident]) -> @ast::path {\n-        @ast::path {\n+    fn path_global(&self, span: span, +strs: ~[ast::ident]) -> @ast::Path {\n+        @ast::Path {\n             span: span,\n             global: true,\n             idents: strs,\n@@ -273,8 +273,8 @@ priv impl @ext_ctxt {\n         span: span,\n         +strs: ~[ast::ident],\n         +tps: ~[@ast::Ty]\n-    ) -> @ast::path {\n-        @ast::path {\n+    ) -> @ast::Path {\n+        @ast::Path {\n             span: span,\n             global: false,\n             idents: strs,\n@@ -288,8 +288,8 @@ priv impl @ext_ctxt {\n         span: span,\n         +strs: ~[ast::ident],\n         +tps: ~[@ast::Ty]\n-    ) -> @ast::path {\n-        @ast::path {\n+    ) -> @ast::Path {\n+        @ast::Path {\n             span: span,\n             global: true,\n             idents: strs,\n@@ -439,7 +439,7 @@ fn mk_impl(\n     span: span,\n     ident: ast::ident,\n     ty_param: ast::TyParam,\n-    path: @ast::path,\n+    path: @ast::Path,\n     generics: &ast::Generics,\n     f: &fn(@ast::Ty) -> @ast::method\n ) -> @ast::item {"}, {"sha": "0f84ac41532726413745e0c5cbcf7bce2cb3d673", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -63,8 +63,8 @@ pub fn mk_unary(cx: @ext_ctxt, sp: span, op: ast::unop, e: @ast::expr)\n     cx.next_id(); // see ast_util::op_expr_callee_id\n     mk_expr(cx, sp, ast::expr_unary(op, e))\n }\n-pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n-    let p = @ast::path { span: sp,\n+pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+    let p = @ast::Path { span: sp,\n                          global: false,\n                          idents: idents,\n                          rp: None,\n@@ -74,15 +74,15 @@ pub fn mk_raw_path(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n pub fn mk_raw_path_(sp: span,\n                     +idents: ~[ast::ident],\n                     +types: ~[@ast::Ty])\n-                 -> @ast::path {\n-    @ast::path { span: sp,\n+                 -> @ast::Path {\n+    @ast::Path { span: sp,\n                  global: false,\n                  idents: idents,\n                  rp: None,\n                  types: types }\n }\n-pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::path {\n-    @ast::path { span: sp,\n+pub fn mk_raw_path_global(sp: span, +idents: ~[ast::ident]) -> @ast::Path {\n+    @ast::Path { span: sp,\n                  global: true,\n                  idents: idents,\n                  rp: None,\n@@ -295,15 +295,15 @@ pub fn mk_pat_ident_with_binding_mode(cx: @ext_ctxt,\n }\n pub fn mk_pat_enum(cx: @ext_ctxt,\n                    span: span,\n-                   path: @ast::path,\n+                   path: @ast::Path,\n                    +subpats: ~[@ast::pat])\n                 -> @ast::pat {\n     let pat = ast::pat_enum(path, Some(subpats));\n     mk_pat(cx, span, pat)\n }\n pub fn mk_pat_struct(cx: @ext_ctxt,\n                      span: span,\n-                     path: @ast::path,\n+                     path: @ast::Path,\n                      +field_pats: ~[ast::field_pat])\n                   -> @ast::pat {\n     let pat = ast::pat_struct(path, field_pats, false);"}, {"sha": "f4901191b8ac98419d3b2223ef381f6ef746d2e8", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -41,7 +41,7 @@ pub fn expand_syntax_ext(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n         id: cx.next_id(),\n         callee_id: cx.next_id(),\n         node: ast::expr_path(\n-            @ast::path {\n+            @ast::Path {\n                  span: sp,\n                  global: false,\n                  idents: ~[res],"}, {"sha": "4337546930ff901c5e171ccd068882b9db84cfe9", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -185,7 +185,7 @@ pub fn create_derived_impl(cx: @ext_ctxt,\n     });\n \n     // Create the reference to the trait.\n-    let trait_path = ast::path {\n+    let trait_path = ast::Path {\n         span: span,\n         global: true,\n         idents: trait_path.map(|x| *x),"}, {"sha": "5eea58b89b1c6c58f2297071f2b118dfdb7bf968", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -34,37 +34,37 @@ mod syntax {\n     pub use parse;\n }\n \n-pub fn path(+ids: ~[ident], span: span) -> @ast::path {\n-    @ast::path { span: span,\n+pub fn path(+ids: ~[ident], span: span) -> @ast::Path {\n+    @ast::Path { span: span,\n                  global: false,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n-pub fn path_global(+ids: ~[ident], span: span) -> @ast::path {\n-    @ast::path { span: span,\n+pub fn path_global(+ids: ~[ident], span: span) -> @ast::Path {\n+    @ast::Path { span: span,\n                  global: true,\n                  idents: ids,\n                  rp: None,\n                  types: ~[] }\n }\n \n pub trait append_types {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::path;\n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path;\n+    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path;\n+    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path;\n }\n \n-impl append_types for @ast::path {\n-    fn add_ty(&self, ty: @ast::Ty) -> @ast::path {\n-        @ast::path {\n+impl append_types for @ast::Path {\n+    fn add_ty(&self, ty: @ast::Ty) -> @ast::Path {\n+        @ast::Path {\n             types: vec::append_one(copy self.types, ty),\n             .. copy **self\n         }\n     }\n \n-    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::path {\n-        @ast::path {\n+    fn add_tys(&self, +tys: ~[@ast::Ty]) -> @ast::Path {\n+        @ast::Path {\n             types: vec::append(copy self.types, tys),\n             .. copy **self\n         }\n@@ -108,7 +108,7 @@ pub trait ext_ctxt_ast_builder {\n                    span: span,\n                    +struct_def: ast::struct_def) -> @ast::item;\n     fn struct_expr(&self,\n-                   path: @ast::path,\n+                   path: @ast::Path,\n                    +fields: ~[ast::field]) -> @ast::expr;\n     fn variant(&self,\n                name: ident,\n@@ -118,7 +118,7 @@ pub trait ext_ctxt_ast_builder {\n                 name: ident,\n                 span: span,\n                 +items: ~[@ast::item]) -> @ast::item;\n-    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty;\n+    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty;\n     fn item_ty_poly(&self,\n                     name: ident,\n                     span: span,\n@@ -328,7 +328,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         self.item(name, span, ast::item_struct(@struct_def, generics))\n     }\n \n-    fn struct_expr(&self, path: @ast::path,\n+    fn struct_expr(&self, path: @ast::Path,\n                    +fields: ~[ast::field]) -> @ast::expr {\n         @ast::expr {\n             id: self.next_id(),\n@@ -397,7 +397,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n         )\n     }\n \n-    fn ty_path_ast_builder(&self, path: @ast::path) -> @ast::Ty {\n+    fn ty_path_ast_builder(&self, path: @ast::Path) -> @ast::Ty {\n         @ast::Ty {\n             id: self.next_id(),\n             node: ast::ty_path(path, self.next_id()),"}, {"sha": "768dba21412506a70d93bbc02f4226833899dae7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -36,7 +36,7 @@ pub trait ast_fold {\n     fn fold_foreign_mod(@self, &foreign_mod) -> foreign_mod;\n     fn fold_variant(@self, &variant) -> variant;\n     fn fold_ident(@self, ident) -> ident;\n-    fn fold_path(@self, @path) -> @path;\n+    fn fold_path(@self, @Path) -> @Path;\n     fn fold_local(@self, @local) -> @local;\n     fn map_exprs(@self, @fn(@expr) -> @expr, &[@expr]) -> ~[@expr];\n     fn new_id(@self, node_id) -> node_id;\n@@ -65,7 +65,7 @@ pub struct AstFoldFns {\n     fold_foreign_mod: @fn(&foreign_mod, @ast_fold) -> foreign_mod,\n     fold_variant: @fn(&variant_, span, @ast_fold) -> (variant_, span),\n     fold_ident: @fn(ident, @ast_fold) -> ident,\n-    fold_path: @fn(@path, @ast_fold) -> path,\n+    fold_path: @fn(@Path, @ast_fold) -> Path,\n     fold_local: @fn(&local_, span, @ast_fold) -> (local_, span),\n     map_exprs: @fn(@fn(@expr) -> @expr, &[@expr]) -> ~[@expr],\n     new_id: @fn(node_id) -> node_id,\n@@ -702,8 +702,8 @@ fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n     /* FIXME (#2543) */ copy i\n }\n \n-fn noop_fold_path(p: @path, fld: @ast_fold) -> path {\n-    ast::path {\n+fn noop_fold_path(p: @Path, fld: @ast_fold) -> Path {\n+    ast::Path {\n         span: fld.new_span(p.span),\n         global: p.global,\n         idents: p.idents.map(|x| fld.fold_ident(*x)),\n@@ -851,7 +851,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_ident(@self, x: ident) -> ident {\n         (self.fold_ident)(x, self as @ast_fold)\n     }\n-    fn fold_path(@self, x: @path) -> @path {\n+    fn fold_path(@self, x: @Path) -> @Path {\n         @(self.fold_path)(x, self as @ast_fold)\n     }\n     fn fold_local(@self, x: @local) -> @local {"}, {"sha": "5d44db084d6000182ddd5baaa589cac5a9885ada", "filename": "src/libsyntax/parse/eval.rs", "status": "removed", "additions": 0, "deletions": 174, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibsyntax%2Fparse%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Flibsyntax%2Fparse%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Feval.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -1,174 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use parser::Parser;\n-use attr::parser_attr;\n-use codemap::{span, mk_sp};\n-\n-type ctx =\n-    @{sess: parse::parse_sess,\n-      cfg: ast::crate_cfg};\n-\n-fn eval_crate_directives(cx: ctx,\n-                         cdirs: ~[@ast::crate_directive],\n-                         prefix: &Path,\n-                         view_items: &mut~[@ast::view_item],\n-                         items: &mut~[@ast::item]) {\n-    for cdirs.each |sub_cdir| {\n-        eval_crate_directive(cx, *sub_cdir, prefix, view_items, items);\n-    }\n-}\n-\n-pub fn eval_crate_directives_to_mod(cx: ctx, cdirs: ~[@ast::crate_directive],\n-                                    prefix: &Path, suffix: &Option<Path>)\n-    -> (ast::_mod, ~[ast::attribute]) {\n-    let (cview_items, citems, cattrs)\n-        = parse_companion_mod(cx, prefix, suffix);\n-    let mut view_items: ~[@ast::view_item] = ~[];\n-    let mut items: ~[@ast::item] = ~[];\n-    eval_crate_directives(cx, cdirs, prefix, &mut view_items, &mut items);\n-    return ({view_items: vec::append(view_items, cview_items),\n-          items: vec::append(items, citems)},\n-         cattrs);\n-}\n-\n-/*\n-The 'companion mod'. So .rc crates and directory mod crate directives define\n-modules but not a .rs file to fill those mods with stuff. The companion mod is\n-a convention for location a .rs file to go with them.  For .rc files the\n-companion mod is a .rs file with the same name; for directory mods the\n-companion mod is a .rs file with the same name as the directory.\n-\n-We build the path to the companion mod by combining the prefix and the\n-optional suffix then adding the .rs extension.\n-*/\n-fn parse_companion_mod(cx: ctx, prefix: &Path, suffix: &Option<Path>)\n-    -> (~[@ast::view_item], ~[@ast::item], ~[ast::attribute]) {\n-\n-    fn companion_file(prefix: &Path, suffix: &Option<Path>) -> Path {\n-        return match *suffix {\n-          option::Some(s) => prefix.push_many(s.components),\n-          option::None => copy *prefix\n-        }.with_filetype(\"rs\");\n-    }\n-\n-    fn file_exists(path: &Path) -> bool {\n-        // Crude, but there's no lib function for this and I'm not\n-        // up to writing it just now\n-        match io::file_reader(path) {\n-          result::Ok(_) => true,\n-          result::Err(_) => false\n-        }\n-    }\n-\n-    let modpath = &companion_file(prefix, suffix);\n-    if file_exists(modpath) {\n-        debug!(\"found companion mod\");\n-        // XXX: Using a dummy span, but this code will go away soon\n-        let p0 = new_sub_parser_from_file(cx.sess, cx.cfg,\n-                                          modpath,\n-                                          codemap::dummy_sp());\n-        let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let m0 = p0.parse_mod_items(token::EOF, next);\n-        return (m0.view_items, m0.items, inner);\n-    } else {\n-        return (~[], ~[], ~[]);\n-    }\n-}\n-\n-fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n-    match ::attr::first_attr_value_str_by_name(attrs, ~\"path\") {\n-      Some(d) => d,\n-      None => default\n-    }\n-}\n-\n-pub fn eval_src_mod(cx: ctx, prefix: &Path,\n-                    outer_attrs: ~[ast::attribute],\n-                    id: ast::ident, sp: span)\n-                 -> (ast::item_, ~[ast::attribute]) {\n-    let file_path = Path(cdir_path_opt(\n-        cx.sess.interner.get(id) + ~\".rs\", outer_attrs));\n-    eval_src_mod_from_path(cx, prefix, &file_path, outer_attrs, sp)\n-}\n-\n-pub fn eval_src_mod_from_path(cx: ctx, prefix: &Path, path: &Path,\n-                              outer_attrs: ~[ast::attribute],\n-                              sp: span)\n-                           -> (ast::item_, ~[ast::attribute]) {\n-    let full_path = if path.is_absolute {\n-        copy *path\n-    } else {\n-        prefix.push_many(path.components)\n-    };\n-    let p0 =\n-        new_sub_parser_from_file(cx.sess, cx.cfg,\n-                                 &full_path, sp);\n-    let (inner, next) = p0.parse_inner_attrs_and_next();\n-    let mod_attrs = vec::append(outer_attrs, inner);\n-    let first_item_outer_attrs = next;\n-    let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n-    return (ast::item_mod(m0), mod_attrs);\n-}\n-\n-// XXX: Duplicated from parser.rs\n-fn mk_item(ctx: ctx, lo: BytePos, hi: BytePos, +ident: ast::ident,\n-           +node: ast::item_, vis: ast::visibility,\n-           +attrs: ~[ast::attribute]) -> @ast::item {\n-    return @{ident: ident,\n-             attrs: attrs,\n-             id: next_node_id(ctx.sess),\n-             node: node,\n-             vis: vis,\n-             span: mk_sp(lo, hi)};\n-}\n-\n-fn eval_crate_directive(cx: ctx, cdir: @ast::crate_directive, prefix: &Path,\n-                        view_items: &mut ~[@ast::view_item],\n-                        items: &mut ~[@ast::item]) {\n-    match cdir.node {\n-      ast::cdir_src_mod(vis, id, attrs) => {\n-        let (m, mod_attrs) = eval_src_mod(cx, prefix, attrs, id, cdir.span);\n-        let i = mk_item(cx, cdir.span.lo, cdir.span.hi,\n-                           /* FIXME (#2543) */ copy id,\n-                           m, vis, mod_attrs);\n-        items.push(i);\n-      }\n-      ast::cdir_dir_mod(vis, id, cdirs, attrs) => {\n-        let path = Path(cdir_path_opt(*cx.sess.interner.get(id), attrs));\n-        let full_path = if path.is_absolute {\n-            copy path\n-        } else {\n-            prefix.push_many(path.components)\n-        };\n-        let (m0, a0) = eval_crate_directives_to_mod(\n-            cx, cdirs, &full_path, &None);\n-        let i =\n-            @{ident: /* FIXME (#2543) */ copy id,\n-              attrs: vec::append(attrs, a0),\n-              id: cx.sess.next_id,\n-              node: ast::item_mod(m0),\n-              vis: vis,\n-              span: cdir.span};\n-        cx.sess.next_id += 1;\n-        items.push(i);\n-      }\n-      ast::cdir_view_item(vi) => view_items.push(vi),\n-    }\n-}\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "fb3e8a5ded5a88e02bf2a4478c3551604127dcfb", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 50, "deletions": 29, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -705,6 +705,7 @@ pub impl Parser {\n         @Ty {id: self.get_id(), node: t, span: sp}\n     }\n \n+    // parse the type following a @ or a ~\n     fn parse_box_or_uniq_pointee(\n         &self,\n         sigil: ast::Sigil,\n@@ -897,7 +898,7 @@ pub impl Parser {\n \n     // parse a path that doesn't have type parameters attached\n     fn parse_path_without_tps(&self)\n-        -> @ast::path {\n+        -> @ast::Path {\n         maybe_whole!(self, nt_path);\n         let lo = self.span.lo;\n         let global = self.eat(&token::MOD_SEP);\n@@ -917,7 +918,7 @@ pub impl Parser {\n                 break;\n             }\n         }\n-        @ast::path { span: mk_sp(lo, self.last_span.hi),\n+        @ast::Path { span: mk_sp(lo, self.last_span.hi),\n                      global: global,\n                      idents: ids,\n                      rp: None,\n@@ -927,7 +928,7 @@ pub impl Parser {\n     // parse a path optionally with type parameters. If 'colons'\n     // is true, then type parameters must be preceded by colons,\n     // as in a::t::<t1,t2>\n-    fn parse_path_with_tps(&self, colons: bool) -> @ast::path {\n+    fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -982,18 +983,14 @@ pub impl Parser {\n             }\n         };\n \n-        @ast::path { span: mk_sp(lo, hi),\n+        @ast::Path { span: mk_sp(lo, hi),\n                      rp: rp,\n                      types: tps,\n                      .. copy *path }\n     }\n \n+    /// parses 0 or 1 lifetime\n     fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n-        /*!\n-         *\n-         * Parses 0 or 1 lifetime.\n-         */\n-\n         match *self.token {\n             token::LIFETIME(*) => {\n                 Some(@self.parse_lifetime())\n@@ -1022,12 +1019,9 @@ pub impl Parser {\n         }\n     }\n \n+    /// Parses a single lifetime\n+    // matches lifetime = ( LIFETIME ) | ( IDENT / )\n     fn parse_lifetime(&self) -> ast::Lifetime {\n-        /*!\n-         *\n-         * Parses a single lifetime.\n-         */\n-\n         match *self.token {\n             token::LIFETIME(i) => {\n                 let span = copy self.span;\n@@ -1147,6 +1141,9 @@ pub impl Parser {\n         }\n     }\n \n+    // at the bottom (top?) of the precedence hierarchy,\n+    // parse things like parenthesized exprs,\n+    // macros, return, etc.\n     fn parse_bottom_expr(&self) -> @expr {\n         maybe_whole_expr!(self);\n \n@@ -1350,6 +1347,7 @@ pub impl Parser {\n         return self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk));\n     }\n \n+    // parse a.b or a(13) or just a\n     fn parse_dot_or_call_expr(&self) -> @expr {\n         let b = self.parse_bottom_expr();\n         self.parse_dot_or_call_expr_with(b)\n@@ -1618,7 +1616,7 @@ pub impl Parser {\n         return spanned(lo, self.span.hi, m);\n     }\n \n-\n+    // parse a prefix-operator expr\n     fn parse_prefix_expr(&self) -> @expr {\n         let lo = self.span.lo;\n         let mut hi;\n@@ -1629,7 +1627,6 @@ pub impl Parser {\n             self.bump();\n             let e = self.parse_prefix_expr();\n             hi = e.span.hi;\n-            self.get_id(); // see ast_util::op_expr_callee_id\n             ex = expr_unary(not, e);\n           }\n           token::BINOP(b) => {\n@@ -1638,7 +1635,6 @@ pub impl Parser {\n                 self.bump();\n                 let e = self.parse_prefix_expr();\n                 hi = e.span.hi;\n-                self.get_id(); // see ast_util::op_expr_callee_id\n                 ex = expr_unary(neg, e);\n               }\n               token::STAR => {\n@@ -1738,7 +1734,6 @@ pub impl Parser {\n                         self.bump();\n                         let expr = self.parse_prefix_expr();\n                         let rhs = self.parse_more_binops(expr, cur_prec);\n-                        self.get_id(); // see ast_util::op_expr_callee_id\n                         let bin = self.mk_expr(lhs.span.lo, rhs.span.hi,\n                                                expr_binary(cur_op, lhs, rhs));\n                         self.parse_more_binops(bin, min_prec)\n@@ -1789,7 +1784,6 @@ pub impl Parser {\n                   token::SHL => aop = shl,\n                   token::SHR => aop = shr\n               }\n-              self.get_id(); // see ast_util::op_expr_callee_id\n               self.mk_expr(lo, rhs.span.hi,\n                            expr_assign_op(aop, lhs, rhs))\n           }\n@@ -2556,11 +2550,14 @@ pub impl Parser {\n     }\n \n     fn parse_block(&self) -> blk {\n+        // disallow inner attrs:\n         let (attrs, blk) = self.parse_inner_attrs_and_block(false);\n         assert!(vec::is_empty(attrs));\n         return blk;\n     }\n \n+    // I claim the existence of the 'parse_attrs' flag strongly\n+    // suggests a name-change or refactoring for this function.\n     fn parse_inner_attrs_and_block(&self, parse_attrs: bool)\n         -> (~[attribute], blk) {\n \n@@ -2601,6 +2598,7 @@ pub impl Parser {\n         self.parse_block_tail_(lo, s, ~[])\n     }\n \n+    // parse the rest of a block expression or function body\n     fn parse_block_tail_(&self, lo: BytePos, s: blk_check_mode,\n                          +first_item_attrs: ~[attribute]) -> blk {\n         let mut stmts = ~[];\n@@ -2797,6 +2795,10 @@ pub impl Parser {\n         ast::TyParam { ident: ident, id: self.get_id(), bounds: bounds }\n     }\n \n+    // parse a set of optional generic type parameter declarations\n+    // matches generics = ( ) | ( < > ) | ( < typaramseq ( , )? > ) | ( < lifetimes ( , )? > )\n+    //                  | ( < lifetimes , typaramseq ( , )? > )\n+    // where   typaramseq = ( typaram ) | ( typaram , typaramseq )\n     fn parse_generics(&self) -> ast::Generics {\n         if self.eat(&token::LT) {\n             let lifetimes = self.parse_lifetimes();\n@@ -2809,6 +2811,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse a generic use site\n     fn parse_generic_values(\n         &self) -> (OptVec<ast::Lifetime>, ~[@Ty])\n     {\n@@ -3099,6 +3102,7 @@ pub impl Parser {\n         }\n     }\n \n+    // parse trait Foo { ... }\n     fn parse_item_trait(&self) -> item_info {\n         let ident = self.parse_ident();\n         self.parse_region_param();\n@@ -3177,13 +3181,15 @@ pub impl Parser {\n         (ident, item_impl(generics, opt_trait, ty, meths), None)\n     }\n \n+    // parse a::B<~str,int>\n     fn parse_trait_ref(&self) -> @trait_ref {\n         @ast::trait_ref {\n             path: self.parse_path_with_tps(false),\n             ref_id: self.get_id(),\n         }\n     }\n \n+    // parse B + C<~str,int> + D\n     fn parse_trait_ref_list(&self, ket: &token::Token) -> ~[@trait_ref] {\n         self.parse_seq_to_before_end(\n             ket,\n@@ -3192,6 +3198,7 @@ pub impl Parser {\n         )\n     }\n \n+    // parse struct Foo { ... }\n     fn parse_item_struct(&self) -> item_info {\n         let class_name = self.parse_ident();\n         self.parse_region_param();\n@@ -3441,6 +3448,7 @@ pub impl Parser {\n         (id, item_const(ty, e), None)\n     }\n \n+    // parse a mod { ...}  item\n     fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n@@ -3697,7 +3705,7 @@ pub impl Parser {\n             }\n         };\n \n-        // extern mod { ... }\n+        // extern mod foo { ... } or extern { ... }\n         if items_allowed && self.eat(&token::LBRACE) {\n             let abis = opt_abis.get_or_default(AbiSet::C());\n \n@@ -3732,6 +3740,7 @@ pub impl Parser {\n         (lo, id)\n     }\n \n+    // parse type Foo = Bar;\n     fn parse_item_type(&self) -> item_info {\n         let (_, ident) = self.parse_type_decl();\n         self.parse_region_param();\n@@ -3742,6 +3751,7 @@ pub impl Parser {\n         (ident, item_ty(ty, tps), None)\n     }\n \n+    // parse obsolete region parameter\n     fn parse_region_param(&self) {\n         if self.eat(&token::BINOP(token::SLASH)) {\n             self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n@@ -3859,6 +3869,7 @@ pub impl Parser {\n         let generics = self.parse_generics();\n         // Newtype syntax\n         if *self.token == token::EQ {\n+            // enum x = ty;\n             self.bump();\n             let ty = self.parse_ty(false);\n             self.expect(&token::SEMI);\n@@ -3883,6 +3894,7 @@ pub impl Parser {\n                 None\n             );\n         }\n+        // enum X { ... }\n         self.expect(&token::LBRACE);\n \n         let enum_definition = self.parse_enum_def(&generics);\n@@ -3986,7 +3998,7 @@ pub impl Parser {\n                 (self.is_keyword(&~\"const\") ||\n                 (self.is_keyword(&~\"static\") &&\n                     !self.token_is_keyword(&~\"fn\", &self.look_ahead(1)))) {\n-            // CONST ITEM\n+            // CONST / STATIC ITEM\n             if self.is_keyword(&~\"const\") {\n                 self.obsolete(*self.span, ObsoleteConstItem);\n             }\n@@ -4002,10 +4014,9 @@ pub impl Parser {\n             let item = self.parse_item_foreign_const(visibility, attrs);\n             return iovi_foreign_item(item);\n         }\n-        if items_allowed &&\n-            // FUNCTION ITEM (not sure about lookahead condition...)\n-            self.is_keyword(&~\"fn\") &&\n+        if items_allowed && self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n+            // FUNCTION ITEM\n             self.bump();\n             let (ident, item_, extra_attrs) =\n                 self.parse_item_fn(impure_fn, AbiSet::Rust());\n@@ -4014,7 +4025,7 @@ pub impl Parser {\n                                           maybe_append(attrs, extra_attrs)));\n         }\n         if items_allowed && self.eat_keyword(&~\"pure\") {\n-            // PURE FUNCTION ITEM\n+            // PURE FUNCTION ITEM (obsolete)\n             self.obsolete(*self.last_span, ObsoletePurity);\n             self.expect_keyword(&~\"fn\");\n             let (ident, item_, extra_attrs) =\n@@ -4192,6 +4203,12 @@ pub impl Parser {\n         return view_item_use(self.parse_view_paths());\n     }\n \n+\n+    // matches view_path : MOD? IDENT EQ non_global_path\n+    // | MOD? non_global_path MOD_SEP LBRACE RBRACE\n+    // | MOD? non_global_path MOD_SEP LBRACE ident_seq RBRACE\n+    // | MOD? non_global_path MOD_SEP STAR\n+    // | MOD? non_global_path\n     fn parse_view_path(&self) -> @view_path {\n         let lo = self.span.lo;\n \n@@ -4215,7 +4232,7 @@ pub impl Parser {\n                 let id = self.parse_ident();\n                 path.push(id);\n             }\n-            let path = @ast::path { span: mk_sp(lo, self.span.hi),\n+            let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n                                     global: false,\n                                     idents: path,\n                                     rp: None,\n@@ -4244,7 +4261,7 @@ pub impl Parser {\n                         seq_sep_trailing_allowed(token::COMMA),\n                         |p| p.parse_path_list_ident()\n                     );\n-                    let path = @ast::path { span: mk_sp(lo, self.span.hi),\n+                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4256,7 +4273,7 @@ pub impl Parser {\n                   // foo::bar::*\n                   token::BINOP(token::STAR) => {\n                     self.bump();\n-                    let path = @ast::path { span: mk_sp(lo, self.span.hi),\n+                    let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n                                             global: false,\n                                             idents: path,\n                                             rp: None,\n@@ -4272,7 +4289,7 @@ pub impl Parser {\n           _ => ()\n         }\n         let last = path[vec::len(path) - 1u];\n-        let path = @ast::path { span: mk_sp(lo, self.span.hi),\n+        let path = @ast::Path { span: mk_sp(lo, self.span.hi),\n                                 global: false,\n                                 idents: path,\n                                 rp: None,\n@@ -4281,6 +4298,7 @@ pub impl Parser {\n                      view_path_simple(last, path, namespace, self.get_id()));\n     }\n \n+    // matches view_paths = view_path | view_path , view_paths\n     fn parse_view_paths(&self) -> ~[@view_path] {\n         let mut vp = ~[self.parse_view_path()];\n         while *self.token == token::COMMA {\n@@ -4330,6 +4348,9 @@ pub impl Parser {\n \n     // Parses a sequence of items. Stops when it finds program\n     // text that can't be parsed as an item\n+    // - mod_items uses VIEW_ITEMS_AND_ITEMS_ALLOWED\n+    // - block_tail_ uses IMPORTS_AND_ITEMS_ALLOWED\n+    // - foreign_mod_items uses FOREIGN_ITEMS_ALLOWED\n     fn parse_items_and_view_items(&self, +first_item_attrs: ~[attribute],\n                                   mode: view_item_parse_mode,\n                                   macros_allowed: bool)"}, {"sha": "54b2ad851478160be8c33b121b47a7b251225cfc", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -113,7 +113,7 @@ pub enum nonterminal {\n     nt_expr(@ast::expr),\n     nt_ty(  @ast::Ty),\n     nt_ident(ast::ident, bool),\n-    nt_path(@ast::path),\n+    nt_path(@ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n }"}, {"sha": "fa1b97275660cb7705093ec7ca90e4828d9d01a9", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -178,7 +178,7 @@ pub fn generics_to_str(generics: &ast::Generics,\n     to_str(generics, print_generics, intr)\n }\n \n-pub fn path_to_str(&&p: @ast::path, intr: @ident_interner) -> ~str {\n+pub fn path_to_str(&&p: @ast::Path, intr: @ident_interner) -> ~str {\n     to_str(p, |a,b| print_path(a, b, false), intr)\n }\n \n@@ -1486,7 +1486,7 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: @ps, &&path: @ast::path, colons_before_params: bool) {\n+pub fn print_path(s: @ps, &&path: @ast::Path, colons_before_params: bool) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, ~\"::\"); }\n     let mut first = true;"}, {"sha": "c4c187bc4c7c4eba32f382afd7bfc47a49ddaad6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c649830be732bc0af585ba4ef54b2c6555b7c1c/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2c649830be732bc0af585ba4ef54b2c6555b7c1c", "patch": "@@ -265,7 +265,7 @@ pub fn visit_ty<E>(t: @Ty, e: E, v: vt<E>) {\n     }\n }\n \n-pub fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n+pub fn visit_path<E>(p: @Path, e: E, v: vt<E>) {\n     for p.types.each |tp| { (v.visit_ty)(*tp, e, v); }\n }\n "}, {"sha": "47d2f9e1df08052a118763e80f162d6f37edaaaa", "filename": "src/test/run-pass/by-val-and-by-move.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac9dc69bf3c0e4c46fadeab76229ba35f61d8158/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fby-val-and-by-move.rs?ref=ac9dc69bf3c0e4c46fadeab76229ba35f61d8158", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-test #2443\n-// exec-env:RUST_POISON_ON_FREE\n-\n-fn it_takes_two(x: @int, -y: @int) -> int {\n-    free(y);\n-    debug!(\"about to deref\");\n-    *x\n-}\n-\n-fn free<T>(-_t: T) {\n-}\n-\n-pub fn main() {\n-    let z = @3;\n-    assert!(3 == it_takes_two(z, z));\n-}"}]}