{"sha": "a92d3a36066e966b405a28db2ee4ae61a934f3c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MmQzYTM2MDY2ZTk2NmI0MDVhMjhkYjJlZTRhZTYxYTkzNGYzYzg=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-23T01:03:01Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-05T14:54:49Z"}, "message": "Add duplicity lint for lang features", "tree": {"sha": "90a9f5cd817af02215c63eb0872ba702915dacba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90a9f5cd817af02215c63eb0872ba702915dacba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a92d3a36066e966b405a28db2ee4ae61a934f3c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a92d3a36066e966b405a28db2ee4ae61a934f3c8", "html_url": "https://github.com/rust-lang/rust/commit/a92d3a36066e966b405a28db2ee4ae61a934f3c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a92d3a36066e966b405a28db2ee4ae61a934f3c8/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc99ea7ffa1f2dc3407e4f2b7eb64e36532cb5f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc99ea7ffa1f2dc3407e4f2b7eb64e36532cb5f9", "html_url": "https://github.com/rust-lang/rust/commit/fc99ea7ffa1f2dc3407e4f2b7eb64e36532cb5f9"}], "stats": {"total": 67, "additions": 38, "deletions": 29}, "files": [{"sha": "d086d3bd28df00227bda9bedc7b92467270a8873", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=a92d3a36066e966b405a28db2ee4ae61a934f3c8", "patch": "@@ -511,7 +511,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for feature_gate::Features {\n                                           hasher: &mut StableHasher<W>) {\n         // Unfortunately we cannot exhaustively list fields here, since the\n         // struct is macro generated.\n-        self.declared_stable_lang_features.hash_stable(hcx, hasher);\n+        self.declared_lang_features.hash_stable(hcx, hasher);\n         self.declared_lib_features.hash_stable(hcx, hasher);\n \n         self.walk_feature_fields(|feature_name, value| {"}, {"sha": "85d4bcbd0d4f018d7db9d10c35ef7ed7cb37d02f", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a92d3a36066e966b405a28db2ee4ae61a934f3c8", "patch": "@@ -23,7 +23,7 @@ use syntax::symbol::Symbol;\n use syntax_pos::{Span, MultiSpan};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n-use syntax::feature_gate::{GateIssue, emit_feature_err, find_lang_feature_accepted_version};\n+use syntax::feature_gate::{GateIssue, emit_feature_err};\n use syntax::attr::{self, Stability, Deprecation};\n use util::nodemap::{FxHashSet, FxHashMap};\n \n@@ -813,40 +813,51 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n     }\n \n-    for &(ref stable_lang_feature, span) in &tcx.features().declared_stable_lang_features {\n-        let since = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n-            .expect(\"unexpectedly couldn't find version feature was stabilized\");\n-        tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-                      ast::CRATE_NODE_ID,\n-                      span,\n-                      &format_stable_since_msg(*stable_lang_feature, since));\n-    }\n \n-    let ref declared_lib_features = tcx.features().declared_lib_features;\n+    let declared_lang_features = &tcx.features().declared_lang_features;\n+    let mut lang_features = FxHashSet();\n+    for &(ref feature, span, since) in declared_lang_features {\n+        if let Some(since) = since {\n+            // Warn if the user has enabled an already-stable lang feature.\n+            tcx.lint_node(lint::builtin::STABLE_FEATURES,\n+                        ast::CRATE_NODE_ID,\n+                        span,\n+                        &format_stable_since_msg(*feature, since));\n+        }\n+        if lang_features.contains(&feature) {\n+            // Warn if the user enables a lang feature multiple times.\n+            tcx.lint_node(lint::builtin::DUPLICATE_FEATURES,\n+                          ast::CRATE_NODE_ID,\n+                          span,\n+                          &format!(\"duplicate `{}` feature attribute\", feature));\n+        }\n+        lang_features.insert(feature);\n+    }\n \n+    let declared_lib_features = &tcx.features().declared_lib_features;\n     let mut remaining_lib_features = FxHashMap();\n-    for (feature, span) in declared_lib_features.clone().into_iter() {\n-        // Warn if the user enables a feature multiple times.\n+    for (feature, span) in declared_lib_features {\n+        // Warn if the user enables a lib feature multiple times.\n         if remaining_lib_features.contains_key(&feature) {\n             tcx.lint_node(lint::builtin::DUPLICATE_FEATURES,\n                           ast::CRATE_NODE_ID,\n-                          span,\n+                          *span,\n                           &format!(\"duplicate `{}` feature attribute\", feature));\n         }\n-        remaining_lib_features.insert(feature, span);\n+        remaining_lib_features.insert(feature, span.clone());\n     }\n     // FIXME(varkor): we don't properly handle lib features behind `cfg` attributes yet,\n     // but it happens just to affect `libc`, so we're just going to hard-code it for now.\n     remaining_lib_features.remove(&Symbol::intern(\"libc\"));\n \n     for (feature, stable) in tcx.lib_features().iter() {\n-        // Warn if the user has enabled an already-stable feature.\n+        // Warn if the user has enabled an already-stable lib feature.\n         if let Some(since) = stable {\n             if let Some(span) = remaining_lib_features.get(&feature) {\n                 tcx.lint_node(lint::builtin::STABLE_FEATURES,\n-                    ast::CRATE_NODE_ID,\n-                    *span,\n-                    &format_stable_since_msg(feature, &since.as_str()));\n+                              ast::CRATE_NODE_ID,\n+                              *span,\n+                              &format_stable_since_msg(feature, since));\n             }\n         }\n \n@@ -864,7 +875,7 @@ pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     // don't lint about unused features. We should reenable this one day!\n }\n \n-fn format_stable_since_msg(feature: Symbol, since: &str) -> String {\n+fn format_stable_since_msg(feature: Symbol, since: Symbol) -> String {\n     // \"this feature has been stable since {}. Attribute no longer needed\"\n     format!(\"the feature `{}` has been stable since {} and no longer requires \\\n              an attribute to enable\", feature, since)"}, {"sha": "9ca9909ffa6df3b99caeb5644dd1f50dbdb5f669", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a92d3a36066e966b405a28db2ee4ae61a934f3c8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=a92d3a36066e966b405a28db2ee4ae61a934f3c8", "patch": "@@ -59,8 +59,8 @@ macro_rules! declare_features {\n         /// A set of features to be used by later passes.\n         #[derive(Clone)]\n         pub struct Features {\n-            /// `#![feature]` attrs for stable language features, for error reporting\n-            pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n+            /// `#![feature]` attrs for language features, for error reporting\n+            pub declared_lang_features: Vec<(Symbol, Span, Option<Symbol>)>,\n             /// `#![feature]` attrs for non-language (library) features\n             pub declared_lib_features: Vec<(Symbol, Span)>,\n             $(pub $feature: bool),+\n@@ -69,7 +69,7 @@ macro_rules! declare_features {\n         impl Features {\n             pub fn new() -> Features {\n                 Features {\n-                    declared_stable_lang_features: Vec::new(),\n+                    declared_lang_features: Vec::new(),\n                     declared_lib_features: Vec::new(),\n                     $($feature: false),+\n                 }\n@@ -1220,10 +1220,6 @@ pub fn check_attribute(attr: &ast::Attribute, parse_sess: &ParseSess, features:\n     cx.check_attribute(attr, true);\n }\n \n-pub fn find_lang_feature_accepted_version(feature: &str) -> Option<&'static str> {\n-    ACCEPTED_FEATURES.iter().find(|t| t.0 == feature).map(|t| t.1)\n-}\n-\n fn find_lang_feature_issue(feature: &str) -> Option<u32> {\n     if let Some(info) = ACTIVE_FEATURES.iter().find(|t| t.0 == feature) {\n         let issue = info.2;\n@@ -1940,6 +1936,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n             if let Some((.., set)) = ACTIVE_FEATURES.iter().find(|f| name == f.0) {\n                 set(&mut features, mi.span);\n                 feature_checker.collect(&features, mi.span);\n+                features.declared_lang_features.push((name, mi.span, None));\n                 continue\n             }\n \n@@ -1950,8 +1947,9 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute],\n                 continue\n             }\n \n-            if ACCEPTED_FEATURES.iter().any(|f| name == f.0) {\n-                features.declared_stable_lang_features.push((name, mi.span));\n+            if let Some((_, since, ..)) = ACCEPTED_FEATURES.iter().find(|f| name == f.0) {\n+                let since = Some(Symbol::intern(since));\n+                features.declared_lang_features.push((name, mi.span, since));\n                 continue\n             }\n "}]}