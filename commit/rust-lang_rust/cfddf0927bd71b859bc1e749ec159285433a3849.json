{"sha": "cfddf0927bd71b859bc1e749ec159285433a3849", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZGRmMDkyN2JkNzFiODU5YmMxZTc0OWVjMTU5Mjg1NDMzYTM4NDk=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-23T17:16:09Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-05-31T13:37:13Z"}, "message": "Fix type checks for `manual_str_repeat`", "tree": {"sha": "c089f5f3c657544f10e1411b1ff54a008c0adf72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c089f5f3c657544f10e1411b1ff54a008c0adf72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfddf0927bd71b859bc1e749ec159285433a3849", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmC05pUACgkQ2lnoZDo37QYTFQD8ClEoNpXNYBQICOuj2zUquqTb\nQVIQHkll0oGUS6ssMTIBALrRE6UaG0yQv4KWAyKmCcm6Z1/6ZgIyHNo06mqyk00E\n=I8/G\n-----END PGP SIGNATURE-----", "payload": "tree c089f5f3c657544f10e1411b1ff54a008c0adf72\nparent 97311f0906ca89656f5942b326a665fe98d84c17\nauthor Jason Newcomb <jsnewcomb@pm.me> 1621790169 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1622468233 -0400\n\nFix type checks for `manual_str_repeat`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfddf0927bd71b859bc1e749ec159285433a3849", "html_url": "https://github.com/rust-lang/rust/commit/cfddf0927bd71b859bc1e749ec159285433a3849", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfddf0927bd71b859bc1e749ec159285433a3849/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97311f0906ca89656f5942b326a665fe98d84c17", "url": "https://api.github.com/repos/rust-lang/rust/commits/97311f0906ca89656f5942b326a665fe98d84c17", "html_url": "https://github.com/rust-lang/rust/commit/97311f0906ca89656f5942b326a665fe98d84c17"}], "stats": {"total": 206, "additions": 162, "deletions": 44}, "files": [{"sha": "919e2628c523cf2c75da29f965a066c4b1da15b2", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -1,40 +1,49 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_with_context;\n+use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n+use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n use clippy_utils::{is_expr_path_def_path, paths};\n use if_chain::if_chain;\n-use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n \n use super::MANUAL_STR_REPEAT;\n \n enum RepeatKind {\n-    Str,\n     String,\n-    Char,\n+    Char(char),\n+}\n+\n+fn get_ty_param(ty: Ty<'_>) -> Option<Ty<'_>> {\n+    if let ty::Adt(_, subs) = ty.kind() {\n+        subs.types().next()\n+    } else {\n+        None\n+    }\n }\n \n fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n     if let ExprKind::Lit(lit) = &e.kind {\n         match lit.node {\n-            LitKind::Str(..) => Some(RepeatKind::Str),\n-            LitKind::Char(_) => Some(RepeatKind::Char),\n+            LitKind::Str(..) => Some(RepeatKind::String),\n+            LitKind::Char(c) => Some(RepeatKind::Char(c)),\n             _ => None,\n         }\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::string_type)\n-            || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-            || match_type(cx, ty, &paths::COW)\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n             let ty = ty.peel_refs();\n-            (ty.is_str() || is_type_diagnostic_item(cx, ty, sym::string_type)).then(|| RepeatKind::Str)\n+            (ty.is_str() || is_type_diagnostic_item(cx, ty, sym::string_type)).then(|| RepeatKind::String)\n         }\n     }\n }\n@@ -61,18 +70,19 @@ pub(super) fn check(\n         if ctxt == take_self_arg.span.ctxt();\n         then {\n             let mut app = Applicability::MachineApplicable;\n-            let (val_snip, val_is_mac) = snippet_with_context(cx, repeat_arg.span, ctxt, \"..\", &mut app);\n             let count_snip = snippet_with_context(cx, take_arg.span, ctxt, \"..\", &mut app).0;\n \n             let val_str = match repeat_kind {\n-                RepeatKind::String => format!(\"(&{})\", val_snip),\n-                RepeatKind::Str if !val_is_mac && repeat_arg.precedence().order() < PREC_POSTFIX => {\n-                    format!(\"({})\", val_snip)\n-                },\n-                RepeatKind::Str => val_snip.into(),\n-                RepeatKind::Char if val_snip == r#\"'\"'\"# => r#\"\"\\\"\"\"#.into(),\n-                RepeatKind::Char if val_snip == r#\"'\\''\"# => r#\"\"'\"\"#.into(),\n-                RepeatKind::Char => format!(\"\\\"{}\\\"\", &val_snip[1..val_snip.len() - 1]),\n+                RepeatKind::Char(_) if repeat_arg.span.ctxt() != ctxt => return,\n+                RepeatKind::Char('\\'') => r#\"\"'\"\"#.into(),\n+                RepeatKind::Char('\"') => r#\"\"\\\"\"\"#.into(),\n+                RepeatKind::Char(_) =>\n+                    match snippet_with_applicability(cx, repeat_arg.span, \"..\", &mut app) {\n+                        Cow::Owned(s) => Cow::Owned(format!(\"\\\"{}\\\"\", &s[1..s.len() - 1])),\n+                        s @ Cow::Borrowed(_) => s,\n+                    },\n+                RepeatKind::String =>\n+                    Sugg::hir_with_context(cx, repeat_arg, ctxt, \"..\", &mut app).maybe_par().to_string().into(),\n             };\n \n             span_lint_and_sugg("}, {"sha": "c8ae972f18ca62a5d4ba0f3e19ca803fa4169f7a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -61,12 +61,9 @@ mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_adt_constructor, contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n-use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, paths, return_ty};\n-use clippy_utils::{\n-    diagnostics::{span_lint, span_lint_and_help},\n-    meets_msrv, msrvs,\n-};\n+use clippy_utils::{contains_return, get_trait_def_id, in_macro, iter_input_pats, meets_msrv, msrvs, paths, return_ty};\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::def::Res;"}, {"sha": "0e33ae740d946cd00e6c2903d56094a53e9bb441", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -124,7 +124,7 @@ macro_rules! define_Conf {\n define_Conf! {\n     /// Lint: ENUM_VARIANT_NAMES, LARGE_TYPES_PASSED_BY_VALUE, TRIVIALLY_COPY_PASS_BY_REF, UNNECESSARY_WRAPS, UPPER_CASE_ACRONYMS, WRONG_SELF_CONVENTION. Suppress lints whenever the suggested change would cause breakage for other crates.\n     (avoid_breaking_exported_api: bool = true),\n-    /// Lint: CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n+    /// Lint: MANUAL_STR_REPEAT, CLONED_INSTEAD_OF_COPIED, REDUNDANT_FIELD_NAMES, REDUNDANT_STATIC_LIFETIMES, FILTER_MAP_NEXT, CHECKED_CONVERSIONS, MANUAL_RANGE_CONTAINS, USE_SELF, MEM_REPLACE_WITH_DEFAULT, MANUAL_NON_EXHAUSTIVE, OPTION_AS_REF_DEREF, MAP_UNWRAP_OR, MATCH_LIKE_MATCHES_MACRO, MANUAL_STRIP, MISSING_CONST_FOR_FN, UNNESTED_OR_PATTERNS, FROM_OVER_INTO, PTR_AS_PTR, IF_THEN_SOME_ELSE_NONE. The minimum rust version that the project supports\n     (msrv: Option<String> = None),\n     /// Lint: BLACKLISTED_NAME. The list of blacklisted names to lint about. NB: `bar` is not here since it has legitimate uses\n     (blacklisted_names: Vec<String> = [\"foo\", \"baz\", \"quux\"].iter().map(ToString::to_string).collect()),"}, {"sha": "efc0ec50fdc947f9d209be2256d8c41ecf1f906b", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -2,15 +2,15 @@\n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::higher;\n-use crate::source::{snippet, snippet_opt, snippet_with_macro_callsite};\n+use crate::source::{snippet, snippet_opt, snippet_with_context, snippet_with_macro_callsite};\n use rustc_ast::util::parser::AssocOp;\n use rustc_ast::{ast, token};\n use rustc_ast_pretty::pprust::token_kind_to_string;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::{EarlyContext, LateContext, LintContext};\n use rustc_span::source_map::{CharPos, Span};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, SyntaxContext};\n use std::borrow::Cow;\n use std::convert::TryInto;\n use std::fmt::Display;\n@@ -90,6 +90,29 @@ impl<'a> Sugg<'a> {\n         Self::hir_from_snippet(expr, snippet)\n     }\n \n+    /// Same as `hir`, but first walks the span up to the given context. This will result in the\n+    /// macro call, rather then the expansion, if the span is from a child context. If the span is\n+    /// not from a child context, it will be used directly instead.\n+    ///\n+    /// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR\n+    /// node would result in `box []`. If given the context of the address of expression, this\n+    /// function will correctly get a snippet of `vec![]`.\n+    pub fn hir_with_context(\n+        cx: &LateContext<'_>,\n+        expr: &hir::Expr<'_>,\n+        ctxt: SyntaxContext,\n+        default: &'a str,\n+        applicability: &mut Applicability,\n+    ) -> Self {\n+        let (snippet, in_macro) = snippet_with_context(cx, expr.span, ctxt, default, applicability);\n+\n+        if in_macro {\n+            Sugg::NonParen(snippet)\n+        } else {\n+            Self::hir_from_snippet(expr, snippet)\n+        }\n+    }\n+\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {"}, {"sha": "dc140257f32108c9c4c48d84578481b54d641dcf", "filename": "tests/ui/manual_str_repeat.fixed", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.fixed?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -1,8 +1,10 @@\n // run-rustfix\n \n+#![feature(custom_inner_attributes)]\n #![warn(clippy::manual_str_repeat)]\n \n-use std::iter::repeat;\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n \n fn main() {\n     let _: String = \"test\".repeat(10);\n@@ -17,8 +19,8 @@ fn main() {\n     macro_rules! m {\n         ($e:expr) => {{ $e }};\n     }\n-\n-    let _: String = m!(\"test\").repeat(m!(count));\n+    // FIXME: macro args are fine\n+    let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n \n     let x = &x;\n     let _: String = (*x).repeat(count);\n@@ -28,4 +30,37 @@ fn main() {\n     }\n     // Don't lint, repeat is from a macro.\n     let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = x.repeat(count);\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = Cow::Borrowed(\"test\").repeat(count);\n+\n+    let x = \"x\".to_owned();\n+    let _: String = x.repeat(count);\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = \"test\".repeat(10);\n }"}, {"sha": "0d69c989b2ed84a0b616f773aa963e9ca30c9d14", "filename": "tests/ui/manual_str_repeat.rs", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.rs?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -1,8 +1,10 @@\n // run-rustfix\n \n+#![feature(custom_inner_attributes)]\n #![warn(clippy::manual_str_repeat)]\n \n-use std::iter::repeat;\n+use std::borrow::Cow;\n+use std::iter::{repeat, FromIterator};\n \n fn main() {\n     let _: String = std::iter::repeat(\"test\").take(10).collect();\n@@ -17,7 +19,7 @@ fn main() {\n     macro_rules! m {\n         ($e:expr) => {{ $e }};\n     }\n-\n+    // FIXME: macro args are fine\n     let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n \n     let x = &x;\n@@ -28,4 +30,37 @@ fn main() {\n     }\n     // Don't lint, repeat is from a macro.\n     let _: String = repeat_m!(\"test\").take(count).collect();\n+\n+    let x: Box<str> = Box::from(\"test\");\n+    let _: String = repeat(x).take(count).collect();\n+\n+    #[derive(Clone)]\n+    struct S;\n+    impl FromIterator<Box<S>> for String {\n+        fn from_iter<T: IntoIterator<Item = Box<S>>>(_: T) -> Self {\n+            Self::new()\n+        }\n+    }\n+    // Don't lint, wrong box type\n+    let _: String = repeat(Box::new(S)).take(count).collect();\n+\n+    let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+\n+    let x = \"x\".to_owned();\n+    let _: String = repeat(x).take(count).collect();\n+\n+    let x = 'x';\n+    // Don't lint, not char literal\n+    let _: String = repeat(x).take(count).collect();\n+}\n+\n+fn _msrv_1_15() {\n+    #![clippy::msrv = \"1.15\"]\n+    // `str::repeat` was stabilized in 1.16. Do not lint this\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n+}\n+\n+fn _msrv_1_16() {\n+    #![clippy::msrv = \"1.16\"]\n+    let _: String = std::iter::repeat(\"test\").take(10).collect();\n }"}, {"sha": "c65116897164409e7b4ecb3862bfce925418b6c9", "filename": "tests/ui/manual_str_repeat.stderr", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cfddf0927bd71b859bc1e749ec159285433a3849/tests%2Fui%2Fmanual_str_repeat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_str_repeat.stderr?ref=cfddf0927bd71b859bc1e749ec159285433a3849", "patch": "@@ -1,46 +1,64 @@\n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:8:21\n+  --> $DIR/manual_str_repeat.rs:10:21\n    |\n LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n    |\n    = note: `-D clippy::manual-str-repeat` implied by `-D warnings`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:9:21\n+  --> $DIR/manual_str_repeat.rs:11:21\n    |\n LL |     let _: String = std::iter::repeat('x').take(10).collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"x\".repeat(10)`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:10:21\n+  --> $DIR/manual_str_repeat.rs:12:21\n    |\n LL |     let _: String = std::iter::repeat('/'').take(10).collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"'\".repeat(10)`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:11:21\n+  --> $DIR/manual_str_repeat.rs:13:21\n    |\n LL |     let _: String = std::iter::repeat('\"').take(10).collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"/\"\".repeat(10)`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:15:13\n+  --> $DIR/manual_str_repeat.rs:17:13\n    |\n LL |     let _ = repeat(x).take(count + 2).collect::<String>();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count + 2)`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:21:21\n+  --> $DIR/manual_str_repeat.rs:26:21\n    |\n-LL |     let _: String = repeat(m!(\"test\")).take(m!(count)).collect();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `m!(\"test\").repeat(m!(count))`\n+LL |     let _: String = repeat(*x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*x).repeat(count)`\n \n error: manual implementation of `str::repeat` using iterators\n-  --> $DIR/manual_str_repeat.rs:24:21\n+  --> $DIR/manual_str_repeat.rs:35:21\n    |\n-LL |     let _: String = repeat(*x).take(count).collect();\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `(*x).repeat(count)`\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:47:21\n+   |\n+LL |     let _: String = repeat(Cow::Borrowed(\"test\")).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Cow::Borrowed(\"test\").repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:50:21\n+   |\n+LL |     let _: String = repeat(x).take(count).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `x.repeat(count)`\n+\n+error: manual implementation of `str::repeat` using iterators\n+  --> $DIR/manual_str_repeat.rs:65:21\n+   |\n+LL |     let _: String = std::iter::repeat(\"test\").take(10).collect();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"test\".repeat(10)`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 10 previous errors\n "}]}