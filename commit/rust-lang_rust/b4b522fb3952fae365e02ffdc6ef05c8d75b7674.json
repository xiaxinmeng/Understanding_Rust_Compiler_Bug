{"sha": "b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YjUyMmZiMzk1MmZhZTM2NWUwMmZmZGM2ZWYwNWM4ZDc1Yjc2NzQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T19:14:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "cleanup the api", "tree": {"sha": "8ae249dc026b71d91b0ce066d5fc0e2e146247eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ae249dc026b71d91b0ce066d5fc0e2e146247eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "html_url": "https://github.com/rust-lang/rust/commit/b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2", "html_url": "https://github.com/rust-lang/rust/commit/a16f6bb27df1a9a9fcb506081bb30ccbf966e5c2"}], "stats": {"total": 126, "additions": 70, "deletions": 56}, "files": [{"sha": "af3ccc0f598de1f7c5a5a5dd01b37da1d26b30be", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "patch": "@@ -24,17 +24,26 @@ use ra_syntax::SmolStr;\n \n pub use tt::{Delimiter, Punct};\n \n-pub use crate::{\n-    mbe_parser::parse,\n-    mbe_expander::exapnd,\n-    syntax_bridge::macro_call_to_tt,\n-};\n+pub use crate::syntax_bridge::ast_to_token_tree;\n \n+/// This struct contains AST for a single `macro_rules` defenition. What might\n+/// be very confusing is that AST has almost exactly the same shape as\n+/// `tt::TokenTree`, but there's a crucial difference: in macro rules, `$ident`\n+/// and `$()*` have special meaning (see `Var` and `Repeat` data structures)\n #[derive(Debug)]\n pub struct MacroRules {\n     pub(crate) rules: Vec<Rule>,\n }\n \n+impl MacroRules {\n+    pub fn parse(tt: &tt::Subtree) -> Option<MacroRules> {\n+        mbe_parser::parse(tt)\n+    }\n+    pub fn expand(&self, tt: &tt::Subtree) -> Option<tt::Subtree> {\n+        mbe_expander::exapnd(self, tt)\n+    }\n+}\n+\n #[derive(Debug)]\n pub(crate) struct Rule {\n     pub(crate) lhs: Subtree,\n@@ -93,3 +102,55 @@ pub(crate) struct Var {\n     pub(crate) text: SmolStr,\n     pub(crate) kind: Option<SmolStr>,\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_syntax::{ast, AstNode};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn test_convert_tt() {\n+        let macro_definition = r#\"\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\"#;\n+\n+        let macro_invocation = r#\"\n+impl_froms!(TokenTree: Leaf, Subtree);\n+\"#;\n+\n+        let source_file = ast::SourceFile::parse(macro_definition);\n+        let macro_definition = source_file\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::MacroCall::cast)\n+            .unwrap();\n+\n+        let source_file = ast::SourceFile::parse(macro_invocation);\n+        let macro_invocation = source_file\n+            .syntax()\n+            .descendants()\n+            .find_map(ast::MacroCall::cast)\n+            .unwrap();\n+\n+        let definition_tt = ast_to_token_tree(macro_definition.token_tree().unwrap()).unwrap();\n+        let invocation_tt = ast_to_token_tree(macro_invocation.token_tree().unwrap()).unwrap();\n+        let rules = crate::MacroRules::parse(&definition_tt).unwrap();\n+        let expansion = rules.expand(&invocation_tt).unwrap();\n+        assert_eq!(\n+        expansion.to_string(),\n+        \"impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}} \\\n+         impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}}\"\n+    )\n+    }\n+}"}, {"sha": "a3e6abffceae9f4dd1170a637a257130ee59d486", "filename": "crates/ra_mbe/src/mbe_parser.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_parser.rs?ref=b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "patch": "@@ -1,10 +1,9 @@\n-use crate::tt_cursor::TtCursor;\n-\n /// This module parses a raw `tt::TokenStream` into macro-by-example token\n /// stream. This is a *mostly* identify function, expect for handling of\n /// `$var:tt_kind` and `$(repeat),*` constructs.\n+use crate::tt_cursor::TtCursor;\n \n-pub fn parse(tt: &tt::Subtree) -> Option<crate::MacroRules> {\n+pub(crate) fn parse(tt: &tt::Subtree) -> Option<crate::MacroRules> {\n     let mut parser = TtCursor::new(tt);\n     let mut rules = Vec::new();\n     while !parser.is_eof() {"}, {"sha": "2dc04d4e731680f07d26a5618b45951a110b0b88", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 2, "deletions": 48, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4b522fb3952fae365e02ffdc6ef05c8d75b7674/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=b4b522fb3952fae365e02ffdc6ef05c8d75b7674", "patch": "@@ -1,8 +1,7 @@\n use ra_syntax::{ast, AstNode, SyntaxNode, SyntaxKind::*};\n \n-pub fn macro_call_to_tt(call: &ast::MacroCall) -> Option<tt::Subtree> {\n-    let tt = call.token_tree()?;\n-    convert_tt(tt.syntax())\n+pub fn ast_to_token_tree(ast: &ast::TokenTree) -> Option<tt::Subtree> {\n+    convert_tt(ast.syntax())\n }\n \n fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n@@ -66,48 +65,3 @@ fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n     };\n     Some(res)\n }\n-\n-#[test]\n-fn test_convert_tt() {\n-    let macro_definition = r#\"\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n-            }\n-        )*\n-    }\n-}\n-\"#;\n-\n-    let macro_invocation = r#\"\n-impl_froms!(TokenTree: Leaf, Subtree);\n-\"#;\n-\n-    let source_file = ast::SourceFile::parse(macro_definition);\n-    let macro_definition = source_file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::MacroCall::cast)\n-        .unwrap();\n-\n-    let source_file = ast::SourceFile::parse(macro_invocation);\n-    let macro_invocation = source_file\n-        .syntax()\n-        .descendants()\n-        .find_map(ast::MacroCall::cast)\n-        .unwrap();\n-\n-    let definition_tt = macro_call_to_tt(macro_definition).unwrap();\n-    let invocation_tt = macro_call_to_tt(macro_invocation).unwrap();\n-    let mbe = crate::parse(&definition_tt).unwrap();\n-    let expansion = crate::exapnd(&mbe, &invocation_tt).unwrap();\n-    assert_eq!(\n-        expansion.to_string(),\n-        \"impl From < Leaf > for TokenTree {fn from (it : Leaf) -> TokenTree {TokenTree :: Leaf (it)}} \\\n-         impl From < Subtree > for TokenTree {fn from (it : Subtree) -> TokenTree {TokenTree :: Subtree (it)}}\"\n-    )\n-}"}]}