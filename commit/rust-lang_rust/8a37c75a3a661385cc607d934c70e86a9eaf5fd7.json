{"sha": "8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhMzdjNzVhM2E2NjEzODVjYzYwN2Q5MzRjNzBlODZhOWVhZjVmZDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-02T20:33:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-02T20:33:31Z"}, "message": "Auto merge of #50355 - petrochenkov:50187, r=oli-obk\n\nFix an unresolved import issue with enabled `use_extern_macros`\n\nThis is a kinda ugly special-purpose solution that will break if we suddenly add a fourth namespace, but I hope to come up with something more general if I get to import resolution refactoring this summer.\n\nFixes https://github.com/rust-lang/rust/issues/50187 thus removing a blocker for stabilization of `use_extern_macros`", "tree": {"sha": "e57a9458d66eb0a11d840afe230d18f950b08444", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e57a9458d66eb0a11d840afe230d18f950b08444"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "html_url": "https://github.com/rust-lang/rust/commit/8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3eadd754730923936ca2ce9c2d303fcac9af099f", "url": "https://api.github.com/repos/rust-lang/rust/commits/3eadd754730923936ca2ce9c2d303fcac9af099f", "html_url": "https://github.com/rust-lang/rust/commit/3eadd754730923936ca2ce9c2d303fcac9af099f"}, {"sha": "d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d", "html_url": "https://github.com/rust-lang/rust/commit/d5e31158a204aaa8ddc46bd8b9f44a4770db5c4d"}], "stats": {"total": 158, "additions": 122, "deletions": 36}, "files": [{"sha": "45fd82b33bd1c8235ff0aaa9d90091f8d60cafb7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "patch": "@@ -17,7 +17,7 @@ use macros::{InvocationData, LegacyScope};\n use resolve_imports::ImportDirective;\n use resolve_imports::ImportDirectiveSubclass::{self, GlobImport, SingleImport};\n use {Module, ModuleData, ModuleKind, NameBinding, NameBindingKind, ToNameBinding};\n-use {Resolver, ResolverArenas};\n+use {PerNS, Resolver, ResolverArenas};\n use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n@@ -174,7 +174,11 @@ impl<'a> Resolver<'a> {\n                 let subclass = SingleImport {\n                     target: ident,\n                     source,\n-                    result: self.per_ns(|_, _| Cell::new(Err(Undetermined))),\n+                    result: PerNS {\n+                        type_ns: Cell::new(Err(Undetermined)),\n+                        value_ns: Cell::new(Err(Undetermined)),\n+                        macro_ns: Cell::new(Err(Undetermined)),\n+                    },\n                     type_ns_only,\n                 };\n                 self.add_import_directive("}, {"sha": "d4b212a15d82f9ba637f3337f9431303448e3a42", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "patch": "@@ -700,7 +700,7 @@ pub enum Namespace {\n pub struct PerNS<T> {\n     value_ns: T,\n     type_ns: T,\n-    macro_ns: Option<T>,\n+    macro_ns: T,\n }\n \n impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n@@ -709,7 +709,7 @@ impl<T> ::std::ops::Index<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &self.value_ns,\n             TypeNS => &self.type_ns,\n-            MacroNS => self.macro_ns.as_ref().unwrap(),\n+            MacroNS => &self.macro_ns,\n         }\n     }\n }\n@@ -719,7 +719,7 @@ impl<T> ::std::ops::IndexMut<Namespace> for PerNS<T> {\n         match ns {\n             ValueNS => &mut self.value_ns,\n             TypeNS => &mut self.type_ns,\n-            MacroNS => self.macro_ns.as_mut().unwrap(),\n+            MacroNS => &mut self.macro_ns,\n         }\n     }\n }\n@@ -1728,7 +1728,7 @@ impl<'a> Resolver<'a> {\n             ribs: PerNS {\n                 value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n                 type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: Some(vec![Rib::new(ModuleRibKind(graph_root))]),\n+                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n             },\n             label_ribs: Vec::new(),\n \n@@ -1808,14 +1808,11 @@ impl<'a> Resolver<'a> {\n     }\n \n     /// Runs the function on each namespace.\n-    fn per_ns<T, F: FnMut(&mut Self, Namespace) -> T>(&mut self, mut f: F) -> PerNS<T> {\n-        PerNS {\n-            type_ns: f(self, TypeNS),\n-            value_ns: f(self, ValueNS),\n-            macro_ns: match self.use_extern_macros {\n-                true => Some(f(self, MacroNS)),\n-                false => None,\n-            },\n+    fn per_ns<F: FnMut(&mut Self, Namespace)>(&mut self, mut f: F) {\n+        f(self, TypeNS);\n+        f(self, ValueNS);\n+        if self.use_extern_macros {\n+            f(self, MacroNS);\n         }\n     }\n "}, {"sha": "17aa510b565e90805ea2ae54cd31d8b14f80f2ba", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 58, "deletions": 22, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "patch": "@@ -33,7 +33,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n-use std::mem;\n+use std::{mem, ptr};\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -89,6 +89,8 @@ enum SingleImports<'a> {\n     None,\n     /// Only the given single import can define the name in the namespace.\n     MaybeOne(&'a ImportDirective<'a>),\n+    /// Only one of these two single imports can define the name in the namespace.\n+    MaybeTwo(&'a ImportDirective<'a>, &'a ImportDirective<'a>),\n     /// At least one single import will define the name in the namespace.\n     AtLeastOne,\n }\n@@ -101,21 +103,28 @@ impl<'a> Default for SingleImports<'a> {\n }\n \n impl<'a> SingleImports<'a> {\n-    fn add_directive(&mut self, directive: &'a ImportDirective<'a>) {\n+    fn add_directive(&mut self, directive: &'a ImportDirective<'a>, use_extern_macros: bool) {\n         match *self {\n             SingleImports::None => *self = SingleImports::MaybeOne(directive),\n-            // If two single imports can define the name in the namespace, we can assume that at\n-            // least one of them will define it since otherwise both would have to define only one\n-            // namespace, leading to a duplicate error.\n-            SingleImports::MaybeOne(_) => *self = SingleImports::AtLeastOne,\n+            SingleImports::MaybeOne(directive_one) => *self = if use_extern_macros {\n+                SingleImports::MaybeTwo(directive_one, directive)\n+            } else {\n+                SingleImports::AtLeastOne\n+            },\n+            // If three single imports can define the name in the namespace, we can assume that at\n+            // least one of them will define it since otherwise we'd get duplicate errors in one of\n+            // other namespaces.\n+            SingleImports::MaybeTwo(..) => *self = SingleImports::AtLeastOne,\n             SingleImports::AtLeastOne => {}\n         };\n     }\n \n-    fn directive_failed(&mut self) {\n+    fn directive_failed(&mut self, dir: &'a ImportDirective<'a>) {\n         match *self {\n             SingleImports::None => unreachable!(),\n             SingleImports::MaybeOne(_) => *self = SingleImports::None,\n+            SingleImports::MaybeTwo(dir1, dir2) =>\n+                *self = SingleImports::MaybeOne(if ptr::eq(dir1, dir) { dir1 } else { dir2 }),\n             SingleImports::AtLeastOne => {}\n         }\n     }\n@@ -199,23 +208,50 @@ impl<'a> Resolver<'a> {\n         }\n \n         // Check if a single import can still define the name.\n+        let resolve_single_import = |this: &mut Self, directive: &'a ImportDirective<'a>| {\n+            let module = match directive.imported_module.get() {\n+                Some(module) => module,\n+                None => return false,\n+            };\n+            let ident = match directive.subclass {\n+                SingleImport { source, .. } => source,\n+                _ => unreachable!(),\n+            };\n+            match this.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n+                Err(Determined) => {}\n+                _ => return false,\n+            }\n+            true\n+        };\n         match resolution.single_imports {\n             SingleImports::AtLeastOne => return Err(Undetermined),\n-            SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n-                let module = match directive.imported_module.get() {\n-                    Some(module) => module,\n-                    None => return Err(Undetermined),\n-                };\n-                let ident = match directive.subclass {\n-                    SingleImport { source, .. } => source,\n-                    _ => unreachable!(),\n-                };\n-                match self.resolve_ident_in_module(module, ident, ns, false, false, path_span) {\n-                    Err(Determined) => {}\n-                    _ => return Err(Undetermined),\n+            SingleImports::MaybeOne(directive) => {\n+                let accessible = self.is_accessible(directive.vis.get());\n+                if accessible {\n+                    if !resolve_single_import(self, directive) {\n+                        return Err(Undetermined)\n+                    }\n+                }\n+            }\n+            SingleImports::MaybeTwo(directive1, directive2) => {\n+                let accessible1 = self.is_accessible(directive1.vis.get());\n+                let accessible2 = self.is_accessible(directive2.vis.get());\n+                if accessible1 && accessible2 {\n+                    if !resolve_single_import(self, directive1) &&\n+                       !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n+                } else if accessible1 {\n+                    if !resolve_single_import(self, directive1) {\n+                        return Err(Undetermined)\n+                    }\n+                } else {\n+                    if !resolve_single_import(self, directive2) {\n+                        return Err(Undetermined)\n+                    }\n                 }\n             }\n-            SingleImports::MaybeOne(_) | SingleImports::None => {},\n+            SingleImports::None => {},\n         }\n \n         let no_unresolved_invocations =\n@@ -281,7 +317,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, .. } => {\n                 self.per_ns(|this, ns| {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.add_directive(directive);\n+                    resolution.single_imports.add_directive(directive, this.use_extern_macros);\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -575,7 +611,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.directive_failed()\n+                        resolution.single_imports.directive_failed(directive)\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {"}, {"sha": "87acf106393310c5f4799e63f4b977333a6ab239", "filename": "src/test/ui/issue-50187.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Ftest%2Fui%2Fissue-50187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a37c75a3a661385cc607d934c70e86a9eaf5fd7/src%2Ftest%2Fui%2Fissue-50187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-50187.rs?ref=8a37c75a3a661385cc607d934c70e86a9eaf5fd7", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![feature(use_extern_macros, decl_macro)]\n+\n+mod type_ns {\n+    pub type A = u8;\n+}\n+mod value_ns {\n+    pub const A: u8 = 0;\n+}\n+mod macro_ns {\n+    pub macro A() {}\n+}\n+\n+mod merge2 {\n+    pub use type_ns::A;\n+    pub use value_ns::A;\n+}\n+mod merge3 {\n+    pub use type_ns::A;\n+    pub use value_ns::A;\n+    pub use macro_ns::A;\n+}\n+\n+mod use2 {\n+    pub use merge2::A;\n+}\n+mod use3 {\n+    pub use merge3::A;\n+}\n+\n+fn main() {\n+    type B2 = use2::A;\n+    let a2 = use2::A;\n+\n+    type B3 = use3::A;\n+    let a3 = use3::A;\n+    use3::A!();\n+}"}]}