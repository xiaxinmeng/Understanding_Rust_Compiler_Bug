{"sha": "db5ca23118f1d96286a25d8627be3fe05ae51c5d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNWNhMjMxMThmMWQ5NjI4NmEyNWQ4NjI3YmUzZmUwNWFlNTFjNWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-14T08:06:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-14T08:06:24Z"}, "message": "auto merge of #14169 : alexcrichton/rust/atomics, r=sanxiyn\n\nThis module is a foundation on which many other algorithms are built. When hardware support is missing, stubs are provided in libcompiler-rt.a, so this should be available on all platforms.", "tree": {"sha": "c634585ae1f8fd0bc0b7c309638c9d3b7e7b11bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c634585ae1f8fd0bc0b7c309638c9d3b7e7b11bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db5ca23118f1d96286a25d8627be3fe05ae51c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db5ca23118f1d96286a25d8627be3fe05ae51c5d", "html_url": "https://github.com/rust-lang/rust/commit/db5ca23118f1d96286a25d8627be3fe05ae51c5d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db5ca23118f1d96286a25d8627be3fe05ae51c5d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e02f6ef0036849c67b045cac58ef7212f4363f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e02f6ef0036849c67b045cac58ef7212f4363f8", "html_url": "https://github.com/rust-lang/rust/commit/2e02f6ef0036849c67b045cac58ef7212f4363f8"}, {"sha": "949443eff640ede205502547ea04a4dd350b255f", "url": "https://api.github.com/repos/rust-lang/rust/commits/949443eff640ede205502547ea04a4dd350b255f", "html_url": "https://github.com/rust-lang/rust/commit/949443eff640ede205502547ea04a4dd350b255f"}], "stats": {"total": 1656, "additions": 857, "deletions": 799}, "files": [{"sha": "9edce3bd6756edf5c8fbb4eba2b86cfa8ba6cb69", "filename": "src/libcore/atomics.rs", "status": "added", "additions": 791, "deletions": 0, "changes": 791, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomics.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -0,0 +1,791 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Core atomic primitives\n+\n+use intrinsics;\n+use std::kinds::marker;\n+use ty::Unsafe;\n+\n+/// An atomic boolean type.\n+pub struct AtomicBool {\n+    v: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// A signed atomic integer type, supporting basic atomic arithmetic operations\n+pub struct AtomicInt {\n+    v: Unsafe<int>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n+pub struct AtomicUint {\n+    v: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// An unsafe atomic pointer. Only supports basic atomic operations\n+pub struct AtomicPtr<T> {\n+    p: Unsafe<uint>,\n+    nocopy: marker::NoCopy\n+}\n+\n+/// Atomic memory orderings\n+///\n+/// Memory orderings limit the ways that both the compiler and CPU may reorder\n+/// instructions around atomic operations. At its most restrictive,\n+/// \"sequentially consistent\" atomics allow neither reads nor writes\n+/// to be moved either before or after the atomic operation; on the other end\n+/// \"relaxed\" atomics allow all reorderings.\n+///\n+/// Rust's memory orderings are the same as in C++[1].\n+///\n+/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n+pub enum Ordering {\n+    /// No ordering constraints, only atomic operations\n+    Relaxed,\n+    /// When coupled with a store, all previous writes become visible\n+    /// to another thread that performs a load with `Acquire` ordering\n+    /// on the same value\n+    Release,\n+    /// When coupled with a load, all subsequent loads will see data\n+    /// written before a store with `Release` ordering on the same value\n+    /// in another thread\n+    Acquire,\n+    /// When coupled with a load, uses `Acquire` ordering, and with a store\n+    /// `Release` ordering\n+    AcqRel,\n+    /// Like `AcqRel` with the additional guarantee that all threads see all\n+    /// sequentially consistent operations in the same order.\n+    SeqCst\n+}\n+\n+/// An `AtomicBool` initialized to `false`\n+pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+/// An `AtomicInt` initialized to `0`\n+pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+/// An `AtomicUint` initialized to `0`\n+pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n+                                                                  marker1: marker::InvariantType},\n+                                                        nocopy: marker::NoCopy };\n+\n+// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n+static UINT_TRUE: uint = -1;\n+\n+impl AtomicBool {\n+    /// Create a new `AtomicBool`\n+    pub fn new(v: bool) -> AtomicBool {\n+        let val = if v { UINT_TRUE } else { 0 };\n+        AtomicBool { v: Unsafe::new(val), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> bool {\n+        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: bool, order: Ordering) {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// # // FIXME: Needs PR #12430\n+    /// extern crate sync;\n+    ///\n+    /// use sync::Arc;\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// fn main() {\n+    ///     let spinlock = Arc::new(AtomicBool::new(false));\n+    ///     let spinlock_clone = spin_lock.clone();\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n+    ///     });\n+    ///\n+    ///     spawn(proc() {\n+    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n+    ///     });\n+    /// }\n+    ///\n+    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n+    ///     // CAS loop until we are able to replace `false` with `true`\n+    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n+    ///         // Since tasks may not be preemptive (if they are green threads)\n+    ///         // yield to the scheduler to let the other task run. Low level\n+    ///         // concurrent code needs to take into account Rust's two threading\n+    ///         // models.\n+    ///         deschedule();\n+    ///     }\n+    ///\n+    ///     // Now we have the spinlock\n+    ///     f();\n+    ///\n+    ///     // Release the lock\n+    ///     spinlock.store(false);\n+    /// }\n+    /// ```\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n+        let old = if old { UINT_TRUE } else { 0 };\n+        let new = if new { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n+    }\n+\n+    /// A logical \"and\" operation\n+    ///\n+    /// Performs a logical \"and\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_and(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"nand\" operation\n+    ///\n+    /// Performs a logical \"nand\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst) as int);\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"or\" operation\n+    ///\n+    /// Performs a logical \"or\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_or(self.v.get(), val, order) > 0 }\n+    }\n+\n+    /// A logical \"xor\" operation\n+    ///\n+    /// Performs a logical \"xor\" operation on the current value and the\n+    /// argument `val`, and sets the new value to the result.\n+    /// Returns the previous value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicBool, SeqCst};\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(true, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(true);\n+    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    ///\n+    /// let foo = AtomicBool::new(false);\n+    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n+    /// assert_eq!(false, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n+        let val = if val { UINT_TRUE } else { 0 };\n+\n+        unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n+    }\n+}\n+\n+impl AtomicInt {\n+    /// Create a new `AtomicInt`\n+    pub fn new(v: int) -> AtomicInt {\n+        AtomicInt {v: Unsafe::new(v), nocopy: marker::NoCopy}\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> int {\n+        unsafe { atomic_load(self.v.get() as *int, order) }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: int, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicInt, SeqCst};\n+    ///\n+    /// let foo = AtomicInt::new(0);\n+    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(-10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise and with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n+    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise or with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n+    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise xor with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n+    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}\n+\n+impl AtomicUint {\n+    /// Create a new `AtomicUint`\n+    pub fn new(v: uint) -> AtomicUint {\n+        AtomicUint { v: Unsafe::new(v), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> uint {\n+        unsafe { atomic_load(self.v.get() as *uint, order) }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, val: uint, order: Ordering) {\n+        unsafe { atomic_store(self.v.get(), val, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_swap(self.v.get(), val, order) }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n+        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n+    }\n+\n+    /// Add to the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0);\n+    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n+    /// assert_eq!(10, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_add(self.v.get(), val, order) }\n+    }\n+\n+    /// Subtract from the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(10);\n+    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n+    /// assert_eq!(0, foo.load(SeqCst));\n+    /// ```\n+    #[inline]\n+    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_sub(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise and with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n+    /// assert_eq!(0b100001, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_and(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise or with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n+    /// assert_eq!(0b111111, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_or(self.v.get(), val, order) }\n+    }\n+\n+    /// Bitwise xor with the current value, returning the previous\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::atomics::{AtomicUint, SeqCst};\n+    ///\n+    /// let foo = AtomicUint::new(0b101101);\n+    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n+    /// assert_eq!(0b011110, foo.load(SeqCst));\n+    #[inline]\n+    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n+        unsafe { atomic_xor(self.v.get(), val, order) }\n+    }\n+}\n+\n+impl<T> AtomicPtr<T> {\n+    /// Create a new `AtomicPtr`\n+    pub fn new(p: *mut T) -> AtomicPtr<T> {\n+        AtomicPtr { p: Unsafe::new(p as uint), nocopy: marker::NoCopy }\n+    }\n+\n+    /// Load the value\n+    #[inline]\n+    pub fn load(&self, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_load(self.p.get() as **mut T, order) as *mut T\n+        }\n+    }\n+\n+    /// Store the value\n+    #[inline]\n+    pub fn store(&self, ptr: *mut T, order: Ordering) {\n+        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n+    }\n+\n+    /// Store a value, returning the old value\n+    #[inline]\n+    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n+        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n+    }\n+\n+    /// If the current value is the same as expected, store a new value\n+    ///\n+    /// Compare the current value with `old`; if they are the same then\n+    /// replace the current value with `new`. Return the previous value.\n+    /// If the return value is equal to `old` then the value was updated.\n+    #[inline]\n+    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n+        unsafe {\n+            atomic_compare_and_swap(self.p.get(), old as uint,\n+                                    new as uint, order) as *mut T\n+        }\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n+    match order {\n+        Release => intrinsics::atomic_store_rel(dst, val),\n+        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n+        _       => intrinsics::atomic_store(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_load_acq(dst),\n+        Relaxed => intrinsics::atomic_load_relaxed(dst),\n+        _       => intrinsics::atomic_load(dst)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n+        Release => intrinsics::atomic_xchg_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n+        _       => intrinsics::atomic_xchg(dst, val)\n+    }\n+}\n+\n+/// Returns the old value (like __sync_fetch_and_add).\n+#[inline]\n+unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n+        Release => intrinsics::atomic_xadd_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n+        _       => intrinsics::atomic_xadd(dst, val)\n+    }\n+}\n+\n+/// Returns the old value (like __sync_fetch_and_sub).\n+#[inline]\n+unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n+        Release => intrinsics::atomic_xsub_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n+        _       => intrinsics::atomic_xsub(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n+        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n+        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n+        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n+        _       => intrinsics::atomic_cxchg(dst, old, new),\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_and_acq(dst, val),\n+        Release => intrinsics::atomic_and_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n+        _       => intrinsics::atomic_and(dst, val)\n+    }\n+}\n+\n+#[inline]\n+unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_nand_acq(dst, val),\n+        Release => intrinsics::atomic_nand_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n+        _       => intrinsics::atomic_nand(dst, val)\n+    }\n+}\n+\n+\n+#[inline]\n+unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_or_acq(dst, val),\n+        Release => intrinsics::atomic_or_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n+        _       => intrinsics::atomic_or(dst, val)\n+    }\n+}\n+\n+\n+#[inline]\n+unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n+    match order {\n+        Acquire => intrinsics::atomic_xor_acq(dst, val),\n+        Release => intrinsics::atomic_xor_rel(dst, val),\n+        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n+        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n+        _       => intrinsics::atomic_xor(dst, val)\n+    }\n+}\n+\n+\n+/// An atomic fence.\n+///\n+/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n+/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n+/// atomic operations X and Y, both operating on some atomic object 'M' such\n+/// that A is sequenced before X, Y is synchronized before B and Y observers\n+/// the change to M. This provides a happens-before dependence between A and B.\n+///\n+/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n+/// with a fence.\n+///\n+/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n+/// `Release` semantics, participates in the global program order of the other\n+/// `SeqCst` operations and/or fences.\n+///\n+/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n+///\n+/// # Failure\n+///\n+/// Fails if `order` is `Relaxed`\n+#[inline]\n+pub fn fence(order: Ordering) {\n+    unsafe {\n+        match order {\n+            Acquire => intrinsics::atomic_fence_acq(),\n+            Release => intrinsics::atomic_fence_rel(),\n+            AcqRel  => intrinsics::atomic_fence_acqrel(),\n+            SeqCst  => intrinsics::atomic_fence(),\n+            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn bool_() {\n+        let a = AtomicBool::new(false);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n+\n+        a.store(false, SeqCst);\n+        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n+    }\n+\n+    #[test]\n+    fn bool_and() {\n+        let a = AtomicBool::new(true);\n+        assert_eq!(a.fetch_and(false, SeqCst),true);\n+        assert_eq!(a.load(SeqCst),false);\n+    }\n+\n+    #[test]\n+    fn uint_and() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+    }\n+\n+    #[test]\n+    fn uint_or() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+    }\n+\n+    #[test]\n+    fn uint_xor() {\n+        let x = AtomicUint::new(0xf731);\n+        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_and() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_or() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n+    }\n+\n+    #[test]\n+    fn int_xor() {\n+        let x = AtomicInt::new(0xf731);\n+        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n+        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n+    }\n+\n+    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n+    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n+    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n+\n+    #[test]\n+    fn static_init() {\n+        unsafe {\n+            assert!(!S_BOOL.load(SeqCst));\n+            assert!(S_INT.load(SeqCst) == 0);\n+            assert!(S_UINT.load(SeqCst) == 0);\n+        }\n+    }\n+\n+    #[test]\n+    fn different_sizes() {\n+        unsafe {\n+            let mut slot = 0u16;\n+            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n+\n+            let mut slot = 0u8;\n+            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n+\n+            let slot = 0u32;\n+            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n+\n+            let mut slot = 0u64;\n+            super::atomic_store(&mut slot, 2, SeqCst);\n+        }\n+    }\n+}"}, {"sha": "8a28f7b13928fc1d2287414a749eb68587fd4413", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -10,7 +10,7 @@\n \n //! Failure support for libcore\n \n-#![allow(dead_code)]\n+#![allow(dead_code, missing_doc)]\n \n #[cfg(not(test))]\n use str::raw::c_str_to_static_slice;"}, {"sha": "4eab7e9d45d351c2b83881ff6e8be7d95a546312", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -9,6 +9,27 @@\n // except according to those terms.\n \n //! The Rust core library\n+//!\n+//! This library is meant to represent the core functionality of rust that is\n+//! maximally portable to other platforms. To that exent, this library has no\n+//! knowledge of things like allocation, threads, I/O, etc. This library is\n+//! built on the assumption of a few existing symbols:\n+//!\n+//! * `memcpy`, `memcmp`, `memset` - These are core memory routines which are\n+//!   often generated by LLVM. Additionally, this library can make explicit\n+//!   calls to these funcitons. Their signatures are the same as found in C.\n+//!\n+//! * `rust_begin_unwind` - This function takes three arguments, a\n+//!   `&fmt::Arguments`, a `&str`, and a `uint. These three arguments dictate\n+//!   the failure message, the file at which failure was invoked, and the line.\n+//!   It is up to consumers of this core library to define this failure\n+//!   function; it is only required to never return.\n+//!\n+//! Currently, it is *not* recommended to use the core library. The stable\n+//! functionality of libcore is exported directly into the\n+//! [standard library](../std/index.html). The composition of this library is\n+//! subject to change over time, only the interface exposed through libstd is\n+//! intended to be stable.\n \n #![crate_id = \"core#0.11.0-pre\"]\n #![license = \"MIT/ASL2\"]\n@@ -81,9 +102,11 @@ pub mod container;\n mod unicode;\n mod unit;\n pub mod any;\n+pub mod atomics;\n pub mod bool;\n pub mod cell;\n pub mod char;\n+pub mod failure;\n pub mod finally;\n pub mod iter;\n pub mod option;\n@@ -96,13 +119,15 @@ pub mod tuple;\n #[cfg(stage0, not(test))]\n pub mod owned;\n \n-mod failure;\n-\n // FIXME: this module should not exist. Once owned allocations are no longer a\n //        language type, this module can move outside to the owned allocation\n //        crate.\n mod should_not_exist;\n \n+mod core {\n+    pub use failure;\n+}\n+\n mod std {\n     pub use clone;\n     pub use cmp;"}, {"sha": "69be68a34a130eef16c8d8e5e41d80395cb6062e", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -17,7 +17,7 @@ macro_rules! fail(\n         fail!(\"explicit failure\")\n     );\n     ($msg:expr) => (\n-        ::failure::begin_unwind($msg, file!(), line!())\n+        ::core::failure::begin_unwind($msg, file!(), line!())\n     );\n )\n "}, {"sha": "9272f24da9d40f83b179efa70d72adc3304f9313", "filename": "src/libcore/should_not_exist.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fshould_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibcore%2Fshould_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fshould_not_exist.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -8,6 +8,22 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// As noted by this file name, this file should not exist. This file should not\n+// exist because it performs allocations which libcore is not allowed to do. The\n+// reason for this file's existence is that the `~[T]` and `~str` types are\n+// language-defined types. Traits are defined in libcore, such as `Clone`, which\n+// these types need to implement, but the implementation can only be found in\n+// libcore.\n+//\n+// Plan of attack for solving this problem:\n+//\n+//      1. Implement DST\n+//      2. Make `Box<T>` not a language feature\n+//      3. Move `Box<T>` to a separate crate, liballoc.\n+//      4. Implement relevant trais in liballoc, not libcore\n+//\n+// Currently, no progress has been made on this list.\n+\n use char::Char;\n use clone::Clone;\n use container::Container;"}, {"sha": "b2565a6a449e3c2c3e93cc378d31a0254196f373", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 21, "deletions": 795, "changes": 816, "blob_url": "https://github.com/rust-lang/rust/blob/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db5ca23118f1d96286a25d8627be3fe05ae51c5d/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=db5ca23118f1d96286a25d8627be3fe05ae51c5d", "patch": "@@ -105,584 +105,42 @@\n //! }\n //! ```\n \n-#![allow(missing_doc)]\n-\n-use intrinsics;\n use mem;\n use ops::Drop;\n use option::{Option,Some,None};\n use owned::Box;\n-use std::kinds::marker;\n-use ty::Unsafe;\n \n-/// An atomic boolean type.\n-pub struct AtomicBool {\n-    v: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// A signed atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicInt {\n-    v: Unsafe<int>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// An unsigned atomic integer type, supporting basic atomic arithmetic operations\n-pub struct AtomicUint {\n-    v: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n-\n-/// An unsafe atomic pointer. Only supports basic atomic operations\n-pub struct AtomicPtr<T> {\n-    p: Unsafe<uint>,\n-    nocopy: marker::NoCopy\n-}\n+pub use core::atomics::{AtomicBool, AtomicInt, AtomicUint, AtomicPtr};\n+pub use core::atomics::{Ordering, Relaxed, Release, Acquire, AcqRel, SeqCst};\n+pub use core::atomics::{INIT_ATOMIC_BOOL, INIT_ATOMIC_INT, INIT_ATOMIC_UINT};\n+pub use core::atomics::fence;\n \n /// An atomic, nullable unique pointer\n ///\n /// This can be used as the concurrency primitive for operations that transfer\n /// owned heap objects across tasks.\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n-    p: Unsafe<uint>,\n-}\n-\n-/// Atomic memory orderings\n-///\n-/// Memory orderings limit the ways that both the compiler and CPU may reorder\n-/// instructions around atomic operations. At its most restrictive,\n-/// \"sequentially consistent\" atomics allow neither reads nor writes\n-/// to be moved either before or after the atomic operation; on the other end\n-/// \"relaxed\" atomics allow all reorderings.\n-///\n-/// Rust's memory orderings are the same as in C++[1].\n-///\n-/// 1: http://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync\n-pub enum Ordering {\n-    /// No ordering constraints, only atomic operations\n-    Relaxed,\n-    /// When coupled with a store, all previous writes become visible\n-    /// to another thread that performs a load with `Acquire` ordering\n-    /// on the same value\n-    Release,\n-    /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with `Release` ordering on the same value\n-    /// in another thread\n-    Acquire,\n-    /// When coupled with a load, uses `Acquire` ordering, and with a store\n-    /// `Release` ordering\n-    AcqRel,\n-    /// Like `AcqRel` with the additional guarantee that all threads see all\n-    /// sequentially consistent operations in the same order.\n-    SeqCst\n-}\n-\n-/// An `AtomicBool` initialized to `false`\n-pub static INIT_ATOMIC_BOOL : AtomicBool = AtomicBool { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-/// An `AtomicInt` initialized to `0`\n-pub static INIT_ATOMIC_INT  : AtomicInt  = AtomicInt  { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-/// An `AtomicUint` initialized to `0`\n-pub static INIT_ATOMIC_UINT : AtomicUint = AtomicUint { v: Unsafe{value: 0,\n-                                                                  marker1: marker::InvariantType},\n-                                                        nocopy: marker::NoCopy };\n-\n-// NB: Needs to be -1 (0b11111111...) to make fetch_nand work correctly\n-static UINT_TRUE: uint = -1;\n-\n-impl AtomicBool {\n-    /// Create a new `AtomicBool`\n-    pub fn new(v: bool) -> AtomicBool {\n-        let val = if v { UINT_TRUE } else { 0 };\n-        AtomicBool { v: Unsafe::new(val), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.v.get() as *uint, order) > 0 }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: bool, order: Ordering) {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_swap(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```ignore\n-    /// # // FIXME: Needs PR #12430\n-    /// extern crate sync;\n-    ///\n-    /// use sync::Arc;\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// fn main() {\n-    ///     let spinlock = Arc::new(AtomicBool::new(false));\n-    ///     let spinlock_clone = spin_lock.clone();\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock, || println!(\"task 1 in lock\"));\n-    ///     });\n-    ///\n-    ///     spawn(proc() {\n-    ///         with_lock(&spinlock_clone, || println!(\"task 2 in lock\"));\n-    ///     });\n-    /// }\n-    ///\n-    /// fn with_lock(spinlock: &Arc<AtomicBool>, f: || -> ()) {\n-    ///     // CAS loop until we are able to replace `false` with `true`\n-    ///     while spinlock.compare_and_swap(false, true, SeqCst) == false {\n-    ///         // Since tasks may not be preemptive (if they are green threads)\n-    ///         // yield to the scheduler to let the other task run. Low level\n-    ///         // concurrent code needs to take into account Rust's two threading\n-    ///         // models.\n-    ///         deschedule();\n-    ///     }\n-    ///\n-    ///     // Now we have the spinlock\n-    ///     f();\n-    ///\n-    ///     // Release the lock\n-    ///     spinlock.store(false);\n-    /// }\n-    /// ```\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: bool, new: bool, order: Ordering) -> bool {\n-        let old = if old { UINT_TRUE } else { 0 };\n-        let new = if new { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) > 0 }\n-    }\n-\n-    /// A logical \"and\" operation\n-    ///\n-    /// Performs a logical \"and\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_and(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_and(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_and(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"nand\" operation\n-    ///\n-    /// Performs a logical \"nand\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_nand(true, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst) as int);\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_nand(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_nand(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_nand(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"or\" operation\n-    ///\n-    /// Performs a logical \"or\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_or(true, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_or(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_or(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_or(self.v.get(), val, order) > 0 }\n-    }\n-\n-    /// A logical \"xor\" operation\n-    ///\n-    /// Performs a logical \"xor\" operation on the current value and the\n-    /// argument `val`, and sets the new value to the result.\n-    /// Returns the previous value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicBool, SeqCst};\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(true, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(true);\n-    /// assert_eq!(true, foo.fetch_xor(true, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    ///\n-    /// let foo = AtomicBool::new(false);\n-    /// assert_eq!(false, foo.fetch_xor(false, SeqCst));\n-    /// assert_eq!(false, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_xor(&self, val: bool, order: Ordering) -> bool {\n-        let val = if val { UINT_TRUE } else { 0 };\n-\n-        unsafe { atomic_xor(self.v.get(), val, order) > 0 }\n-    }\n-}\n-\n-impl AtomicInt {\n-    /// Create a new `AtomicInt`\n-    pub fn new(v: int) -> AtomicInt {\n-        AtomicInt {v: Unsafe::new(v), nocopy: marker::NoCopy}\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> int {\n-        unsafe { atomic_load(self.v.get() as *int, order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: int, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: int, new: int, order: Ordering) -> int {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicInt, SeqCst};\n-    ///\n-    /// let foo = AtomicInt::new(0);\n-    /// assert_eq!(0, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(-10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_and(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_or(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_xor(&self, val: int, order: Ordering) -> int {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl AtomicUint {\n-    /// Create a new `AtomicUint`\n-    pub fn new(v: uint) -> AtomicUint {\n-        AtomicUint { v: Unsafe::new(v), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> uint {\n-        unsafe { atomic_load(self.v.get() as *uint, order) }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, val: uint, order: Ordering) {\n-        unsafe { atomic_store(self.v.get(), val, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_swap(self.v.get(), val, order) }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: uint, new: uint, order: Ordering) -> uint {\n-        unsafe { atomic_compare_and_swap(self.v.get(), old, new, order) }\n-    }\n-\n-    /// Add to the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0);\n-    /// assert_eq!(0, foo.fetch_add(10, SeqCst));\n-    /// assert_eq!(10, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_add(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_add(self.v.get(), val, order) }\n-    }\n-\n-    /// Subtract from the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(10);\n-    /// assert_eq!(10, foo.fetch_sub(10, SeqCst));\n-    /// assert_eq!(0, foo.load(SeqCst));\n-    /// ```\n-    #[inline]\n-    pub fn fetch_sub(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_sub(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise and with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_and(0b110011, SeqCst));\n-    /// assert_eq!(0b100001, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_and(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_and(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise or with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_or(0b110011, SeqCst));\n-    /// assert_eq!(0b111111, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_or(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_or(self.v.get(), val, order) }\n-    }\n-\n-    /// Bitwise xor with the current value, returning the previous\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::sync::atomics::{AtomicUint, SeqCst};\n-    ///\n-    /// let foo = AtomicUint::new(0b101101);\n-    /// assert_eq!(0b101101, foo.fetch_xor(0b110011, SeqCst));\n-    /// assert_eq!(0b011110, foo.load(SeqCst));\n-    #[inline]\n-    pub fn fetch_xor(&self, val: uint, order: Ordering) -> uint {\n-        unsafe { atomic_xor(self.v.get(), val, order) }\n-    }\n-}\n-\n-impl<T> AtomicPtr<T> {\n-    /// Create a new `AtomicPtr`\n-    pub fn new(p: *mut T) -> AtomicPtr<T> {\n-        AtomicPtr { p: Unsafe::new(p as uint), nocopy: marker::NoCopy }\n-    }\n-\n-    /// Load the value\n-    #[inline]\n-    pub fn load(&self, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_load(self.p.get() as **mut T, order) as *mut T\n-        }\n-    }\n-\n-    /// Store the value\n-    #[inline]\n-    pub fn store(&self, ptr: *mut T, order: Ordering) {\n-        unsafe { atomic_store(self.p.get(), ptr as uint, order); }\n-    }\n-\n-    /// Store a value, returning the old value\n-    #[inline]\n-    pub fn swap(&self, ptr: *mut T, order: Ordering) -> *mut T {\n-        unsafe { atomic_swap(self.p.get(), ptr as uint, order) as *mut T }\n-    }\n-\n-    /// If the current value is the same as expected, store a new value\n-    ///\n-    /// Compare the current value with `old`; if they are the same then\n-    /// replace the current value with `new`. Return the previous value.\n-    /// If the return value is equal to `old` then the value was updated.\n-    #[inline]\n-    pub fn compare_and_swap(&self, old: *mut T, new: *mut T, order: Ordering) -> *mut T {\n-        unsafe {\n-            atomic_compare_and_swap(self.p.get(), old as uint,\n-                                    new as uint, order) as *mut T\n-        }\n-    }\n+    p: AtomicUint,\n }\n \n impl<T> AtomicOption<T> {\n     /// Create a new `AtomicOption`\n     pub fn new(p: Box<T>) -> AtomicOption<T> {\n-        unsafe { AtomicOption { p: Unsafe::new(mem::transmute(p)) } }\n+        unsafe { AtomicOption { p: AtomicUint::new(mem::transmute(p)) } }\n     }\n \n     /// Create a new `AtomicOption` that doesn't contain a value\n-    pub fn empty() -> AtomicOption<T> { AtomicOption { p: Unsafe::new(0) } }\n+    pub fn empty() -> AtomicOption<T> { AtomicOption { p: AtomicUint::new(0) } }\n \n     /// Store a value, returning the old value\n     #[inline]\n     pub fn swap(&self, val: Box<T>, order: Ordering) -> Option<Box<T>> {\n-        unsafe {\n-            let val = mem::transmute(val);\n+        let val = unsafe { mem::transmute(val) };\n \n-            let p = atomic_swap(self.p.get(), val, order);\n-            if p as uint == 0 {\n-                None\n-            } else {\n-                Some(mem::transmute(p))\n-            }\n+        match self.p.swap(val, order) {\n+            0 => None,\n+            n => Some(unsafe { mem::transmute(n) }),\n         }\n     }\n \n@@ -702,7 +160,7 @@ impl<T> AtomicOption<T> {\n         unsafe {\n             let val = mem::transmute(val);\n             let expected = mem::transmute(0);\n-            let oldval = atomic_compare_and_swap(self.p.get(), expected, val, order);\n+            let oldval = self.p.compare_and_swap(expected, val, order);\n             if oldval == expected {\n                 None\n             } else {\n@@ -717,7 +175,7 @@ impl<T> AtomicOption<T> {\n     /// result does not get invalidated by another task after this returns.\n     #[inline]\n     pub fn is_empty(&self, order: Ordering) -> bool {\n-        unsafe { atomic_load(self.p.get() as *uint, order) as uint == 0 }\n+        self.p.load(order) as uint == 0\n     }\n }\n \n@@ -728,165 +186,11 @@ impl<T> Drop for AtomicOption<T> {\n     }\n }\n \n-#[inline]\n-unsafe fn atomic_store<T>(dst: *mut T, val: T, order:Ordering) {\n-    match order {\n-        Release => intrinsics::atomic_store_rel(dst, val),\n-        Relaxed => intrinsics::atomic_store_relaxed(dst, val),\n-        _       => intrinsics::atomic_store(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_load<T>(dst: *T, order:Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_load_acq(dst),\n-        Relaxed => intrinsics::atomic_load_relaxed(dst),\n-        _       => intrinsics::atomic_load(dst)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_swap<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xchg_acq(dst, val),\n-        Release => intrinsics::atomic_xchg_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xchg_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xchg_relaxed(dst, val),\n-        _       => intrinsics::atomic_xchg(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_add).\n-#[inline]\n-unsafe fn atomic_add<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xadd_acq(dst, val),\n-        Release => intrinsics::atomic_xadd_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xadd_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xadd_relaxed(dst, val),\n-        _       => intrinsics::atomic_xadd(dst, val)\n-    }\n-}\n-\n-/// Returns the old value (like __sync_fetch_and_sub).\n-#[inline]\n-unsafe fn atomic_sub<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xsub_acq(dst, val),\n-        Release => intrinsics::atomic_xsub_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xsub_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xsub_relaxed(dst, val),\n-        _       => intrinsics::atomic_xsub(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_compare_and_swap<T>(dst: *mut T, old:T, new:T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_cxchg_acq(dst, old, new),\n-        Release => intrinsics::atomic_cxchg_rel(dst, old, new),\n-        AcqRel  => intrinsics::atomic_cxchg_acqrel(dst, old, new),\n-        Relaxed => intrinsics::atomic_cxchg_relaxed(dst, old, new),\n-        _       => intrinsics::atomic_cxchg(dst, old, new),\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_and<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_and_acq(dst, val),\n-        Release => intrinsics::atomic_and_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_and_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_and_relaxed(dst, val),\n-        _       => intrinsics::atomic_and(dst, val)\n-    }\n-}\n-\n-#[inline]\n-unsafe fn atomic_nand<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_nand_acq(dst, val),\n-        Release => intrinsics::atomic_nand_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_nand_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_nand_relaxed(dst, val),\n-        _       => intrinsics::atomic_nand(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-unsafe fn atomic_or<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_or_acq(dst, val),\n-        Release => intrinsics::atomic_or_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_or_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_or_relaxed(dst, val),\n-        _       => intrinsics::atomic_or(dst, val)\n-    }\n-}\n-\n-\n-#[inline]\n-unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n-    match order {\n-        Acquire => intrinsics::atomic_xor_acq(dst, val),\n-        Release => intrinsics::atomic_xor_rel(dst, val),\n-        AcqRel  => intrinsics::atomic_xor_acqrel(dst, val),\n-        Relaxed => intrinsics::atomic_xor_relaxed(dst, val),\n-        _       => intrinsics::atomic_xor(dst, val)\n-    }\n-}\n-\n-\n-/// An atomic fence.\n-///\n-/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n-/// atomic operations X and Y, both operating on some atomic object 'M' such\n-/// that A is sequenced before X, Y is synchronized before B and Y observers\n-/// the change to M. This provides a happens-before dependence between A and B.\n-///\n-/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n-/// with a fence.\n-///\n-/// A fence with has `SeqCst` ordering, in addition to having both `Acquire` and\n-/// `Release` semantics, participates in the global program order of the other\n-/// `SeqCst` operations and/or fences.\n-///\n-/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n-///\n-/// # Failure\n-///\n-/// Fails if `order` is `Relaxed`\n-#[inline]\n-pub fn fence(order: Ordering) {\n-    unsafe {\n-        match order {\n-            Acquire => intrinsics::atomic_fence_acq(),\n-            Release => intrinsics::atomic_fence_rel(),\n-            AcqRel  => intrinsics::atomic_fence_acqrel(),\n-            SeqCst  => intrinsics::atomic_fence(),\n-            Relaxed => fail!(\"there is no such thing as a relaxed fence\")\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod test {\n     use option::*;\n     use super::*;\n \n-    #[test]\n-    fn bool_() {\n-        let a = AtomicBool::new(false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), true);\n-\n-        a.store(false, SeqCst);\n-        assert_eq!(a.compare_and_swap(false, true, SeqCst), false);\n-    }\n-\n     #[test]\n     fn option_empty() {\n         let option: AtomicOption<()> = AtomicOption::empty();\n@@ -900,109 +204,31 @@ mod test {\n \n         let b = p.swap(a, SeqCst);\n \n-        assert_eq!(b, Some(box 1));\n-        assert_eq!(p.take(SeqCst), Some(box 2));\n+        assert!(b == Some(box 1));\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n \n     #[test]\n     fn option_take() {\n         let p = AtomicOption::new(box 1);\n \n-        assert_eq!(p.take(SeqCst), Some(box 1));\n-        assert_eq!(p.take(SeqCst), None);\n+        assert!(p.take(SeqCst) == Some(box 1));\n+        assert!(p.take(SeqCst) == None);\n \n         let p2 = box 2;\n         p.swap(p2, SeqCst);\n \n-        assert_eq!(p.take(SeqCst), Some(box 2));\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n \n     #[test]\n     fn option_fill() {\n         let p = AtomicOption::new(box 1);\n         assert!(p.fill(box 2, SeqCst).is_some()); // should fail; shouldn't leak!\n-        assert_eq!(p.take(SeqCst), Some(box 1));\n+        assert!(p.take(SeqCst) == Some(box 1));\n \n         assert!(p.fill(box 2, SeqCst).is_none()); // shouldn't fail\n-        assert_eq!(p.take(SeqCst), Some(box 2));\n-    }\n-\n-    #[test]\n-    fn bool_and() {\n-        let a = AtomicBool::new(true);\n-        assert_eq!(a.fetch_and(false, SeqCst),true);\n-        assert_eq!(a.load(SeqCst),false);\n-    }\n-\n-    #[test]\n-    fn uint_and() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_or() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn uint_xor() {\n-        let x = AtomicUint::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_and() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_and(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 & 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_or() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_or(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 | 0x137f);\n-    }\n-\n-    #[test]\n-    fn int_xor() {\n-        let x = AtomicInt::new(0xf731);\n-        assert_eq!(x.fetch_xor(0x137f, SeqCst), 0xf731);\n-        assert_eq!(x.load(SeqCst), 0xf731 ^ 0x137f);\n-    }\n-\n-    static mut S_BOOL : AtomicBool = INIT_ATOMIC_BOOL;\n-    static mut S_INT  : AtomicInt  = INIT_ATOMIC_INT;\n-    static mut S_UINT : AtomicUint = INIT_ATOMIC_UINT;\n-\n-    #[test]\n-    fn static_init() {\n-        unsafe {\n-            assert!(!S_BOOL.load(SeqCst));\n-            assert!(S_INT.load(SeqCst) == 0);\n-            assert!(S_UINT.load(SeqCst) == 0);\n-        }\n-    }\n-\n-    #[test]\n-    fn different_sizes() {\n-        unsafe {\n-            let mut slot = 0u16;\n-            assert_eq!(super::atomic_swap(&mut slot, 1, SeqCst), 0);\n-\n-            let mut slot = 0u8;\n-            assert_eq!(super::atomic_compare_and_swap(&mut slot, 1, 2, SeqCst), 0);\n-\n-            let slot = 0u32;\n-            assert_eq!(super::atomic_load(&slot, SeqCst), 0);\n-\n-            let mut slot = 0u64;\n-            super::atomic_store(&mut slot, 2, SeqCst);\n-        }\n+        assert!(p.take(SeqCst) == Some(box 2));\n     }\n }\n+"}]}