{"sha": "6e7a813ed20f9f0639c1565da083824d039566b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlN2E4MTNlZDIwZjlmMDYzOWMxNTY1ZGEwODM4MjRkMDM5NTY2Yjg=", "commit": {"author": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-02-18T05:30:50Z"}, "committer": {"name": "Michael Wright", "email": "mikerite@lavabit.com", "date": "2019-02-18T05:30:50Z"}, "message": "Improve `iter_cloned_collect` suggestions\n\nFixes #3704", "tree": {"sha": "050ea485284af15872146fb9027e10720d32e2e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/050ea485284af15872146fb9027e10720d32e2e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e7a813ed20f9f0639c1565da083824d039566b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e7a813ed20f9f0639c1565da083824d039566b8", "html_url": "https://github.com/rust-lang/rust/commit/6e7a813ed20f9f0639c1565da083824d039566b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e7a813ed20f9f0639c1565da083824d039566b8/comments", "author": null, "committer": null, "parents": [{"sha": "a71acac1da7eaf667ab90a1d65d10e5cc4b80191", "url": "https://api.github.com/repos/rust-lang/rust/commits/a71acac1da7eaf667ab90a1d65d10e5cc4b80191", "html_url": "https://github.com/rust-lang/rust/commit/a71acac1da7eaf667ab90a1d65d10e5cc4b80191"}], "stats": {"total": 79, "additions": 56, "deletions": 23}, "files": [{"sha": "b1bd43410150419137455ff7c590f22d6829a88e", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/6e7a813ed20f9f0639c1565da083824d039566b8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7a813ed20f9f0639c1565da083824d039566b8/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=6e7a813ed20f9f0639c1565da083824d039566b8", "patch": "@@ -1477,17 +1477,22 @@ fn lint_cstring_as_ptr(cx: &LateContext<'_, '_>, expr: &hir::Expr, new: &hir::Ex\n     }\n }\n \n-fn lint_iter_cloned_collect(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n-    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC)\n-        && derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some()\n-    {\n-        span_lint(\n-            cx,\n-            ITER_CLONED_COLLECT,\n-            expr.span,\n-            \"called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n-             more readable\",\n-        );\n+fn lint_iter_cloned_collect<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr]) {\n+    if match_type(cx, cx.tables.expr_ty(expr), &paths::VEC) {\n+        if let Some(slice) = derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])) {\n+            if let Some(to_replace) = expr.span.trim_start(slice.span.source_callsite()) {\n+                span_lint_and_sugg(\n+                    cx,\n+                    ITER_CLONED_COLLECT,\n+                    to_replace,\n+                    \"called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and \\\n+                     more readable\",\n+                    \"try\",\n+                    \".to_vec()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n     }\n }\n \n@@ -1573,7 +1578,7 @@ fn lint_unnecessary_fold(cx: &LateContext<'_, '_>, expr: &hir::Expr, fold_args:\n     };\n }\n \n-fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::Expr], is_mut: bool) {\n+fn lint_iter_nth<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, iter_args: &'tcx [hir::Expr], is_mut: bool) {\n     let mut_str = if is_mut { \"_mut\" } else { \"\" };\n     let caller_type = if derefs_to_slice(cx, &iter_args[0], cx.tables.expr_ty(&iter_args[0])).is_some() {\n         \"slice\"\n@@ -1596,7 +1601,7 @@ fn lint_iter_nth(cx: &LateContext<'_, '_>, expr: &hir::Expr, iter_args: &[hir::E\n     );\n }\n \n-fn lint_get_unwrap(cx: &LateContext<'_, '_>, expr: &hir::Expr, get_args: &[hir::Expr], is_mut: bool) {\n+fn lint_get_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &hir::Expr, get_args: &'tcx [hir::Expr], is_mut: bool) {\n     // Note: we don't want to lint `get_mut().unwrap` for HashMap or BTreeMap,\n     // because they do not implement `IndexMut`\n     let mut applicability = Applicability::MachineApplicable;\n@@ -1681,7 +1686,7 @@ fn lint_iter_skip_next(cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n     }\n }\n \n-fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Option<sugg::Sugg<'static>> {\n+fn derefs_to_slice<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr, ty: Ty<'tcx>) -> Option<&'tcx hir::Expr> {\n     fn may_slice(cx: &LateContext<'_, '_>, ty: Ty<'_>) -> bool {\n         match ty.sty {\n             ty::Slice(_) => true,\n@@ -1695,17 +1700,17 @@ fn derefs_to_slice(cx: &LateContext<'_, '_>, expr: &hir::Expr, ty: Ty<'_>) -> Op\n \n     if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.node {\n         if path.ident.name == \"iter\" && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n-            sugg::Sugg::hir_opt(cx, &args[0]).map(sugg::Sugg::addr)\n+            Some(&args[0])\n         } else {\n             None\n         }\n     } else {\n         match ty.sty {\n-            ty::Slice(_) => sugg::Sugg::hir_opt(cx, expr),\n-            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => sugg::Sugg::hir_opt(cx, expr),\n+            ty::Slice(_) => Some(expr),\n+            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n                 if may_slice(cx, inner) {\n-                    sugg::Sugg::hir_opt(cx, expr)\n+                    Some(expr)\n                 } else {\n                     None\n                 }"}, {"sha": "e7fceab01c6d877c5d23778287d7f641ba10ab30", "filename": "tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e7a813ed20f9f0639c1565da083824d039566b8/tests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e7a813ed20f9f0639c1565da083824d039566b8/tests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.rs?ref=6e7a813ed20f9f0639c1565da083824d039566b8", "patch": "@@ -66,6 +66,18 @@ fn iter_clone_collect() {\n     let v2: Vec<isize> = v.iter().cloned().collect();\n     let v3: HashSet<isize> = v.iter().cloned().collect();\n     let v4: VecDeque<isize> = v.iter().cloned().collect();\n+\n+    // Handle macro expansion in suggestion\n+    let _ : Vec<isize> = vec![1, 2, 3].iter().cloned().collect();\n+\n+    // Issue #3704\n+    unsafe {\n+        let _: Vec<u8> = std::ffi::CStr::from_ptr(std::ptr::null())\n+            .to_bytes()\n+            .iter()\n+            .cloned()\n+            .collect();\n+    }\n }\n \n mod many_derefs {"}, {"sha": "13c5a43c8e97572792015122b79c2d785e180447", "filename": "tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6e7a813ed20f9f0639c1565da083824d039566b8/tests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6e7a813ed20f9f0639c1565da083824d039566b8/tests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_clone.stderr?ref=6e7a813ed20f9f0639c1565da083824d039566b8", "patch": "@@ -78,19 +78,35 @@ help: or try being explicit about what type to clone\n LL |     let z: &Vec<_> = &std::vec::Vec<i32>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: called `cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n-  --> $DIR/unnecessary_clone.rs:66:26\n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:66:27\n    |\n LL |     let v2: Vec<isize> = v.iter().cloned().collect();\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.to_vec()`\n    |\n    = note: `-D clippy::iter-cloned-collect` implied by `-D warnings`\n \n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:71:39\n+   |\n+LL |     let _ : Vec<isize> = vec![1, 2, 3].iter().cloned().collect();\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `.to_vec()`\n+\n+error: called `iter().cloned().collect()` on a slice to create a `Vec`. Calling `to_vec()` is both faster and more readable\n+  --> $DIR/unnecessary_clone.rs:76:24\n+   |\n+LL |               .to_bytes()\n+   |  ________________________^\n+LL | |             .iter()\n+LL | |             .cloned()\n+LL | |             .collect();\n+   | |______________________^ help: try: `.to_vec()`\n+\n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:102:20\n+  --> $DIR/unnecessary_clone.rs:114:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n-error: aborting due to 13 previous errors\n+error: aborting due to 15 previous errors\n "}]}