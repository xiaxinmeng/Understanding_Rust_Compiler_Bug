{"sha": "11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExYzM4ZmRjZTA4ZDNmYTM4Y2I5YTZhNTg1MjE1Y2U4OTU3ZGEzYTk=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T01:43:26Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-18T08:09:24Z"}, "message": "Rename `target_module` to `module` or `imported_module`.", "tree": {"sha": "c3de0ecb308a24d5ff71abc44c9a6c8edfab1166", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3de0ecb308a24d5ff71abc44c9a6c8edfab1166"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "html_url": "https://github.com/rust-lang/rust/commit/11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11c38fdce08d3fa38cb9a6a585215ce8957da3a9/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b969a2a58da5a1c7f6ea0587b9ff97b56e2f21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b969a2a58da5a1c7f6ea0587b9ff97b56e2f21d", "html_url": "https://github.com/rust-lang/rust/commit/5b969a2a58da5a1c7f6ea0587b9ff97b56e2f21d"}], "stats": {"total": 50, "additions": 24, "deletions": 26}, "files": [{"sha": "e76a93a6db03aac16e94f18d479b0555a8f34d0f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/11c38fdce08d3fa38cb9a6a585215ce8957da3a9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11c38fdce08d3fa38cb9a6a585215ce8957da3a9/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=11c38fdce08d3fa38cb9a6a585215ce8957da3a9", "patch": "@@ -65,7 +65,7 @@ pub struct ImportDirective<'a> {\n     pub id: NodeId,\n     parent: Module<'a>,\n     module_path: Vec<Name>,\n-    target_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n+    imported_module: Cell<Option<Module<'a>>>, // the resolution of `module_path`\n     subclass: ImportDirectiveSubclass<'a>,\n     span: Span,\n     vis: Cell<ty::Visibility>,\n@@ -192,8 +192,8 @@ impl<'a> Resolver<'a> {\n         // Check if the globs are determined\n         for directive in module.globs.borrow().iter() {\n             if self.is_accessible(directive.vis.get()) {\n-                if let Some(target_module) = directive.target_module.get() {\n-                    let result = self.resolve_name_in_module(target_module, name, ns, true, None);\n+                if let Some(module) = directive.imported_module.get() {\n+                    let result = self.resolve_name_in_module(module, name, ns, true, None);\n                     if let Indeterminate = result {\n                         return Indeterminate;\n                     }\n@@ -220,15 +220,15 @@ impl<'a> Resolver<'a> {\n         match resolution.single_imports {\n             SingleImports::AtLeastOne => return Some(Indeterminate),\n             SingleImports::MaybeOne(directive) if self.is_accessible(directive.vis.get()) => {\n-                let target_module = match directive.target_module.get() {\n-                    Some(target_module) => target_module,\n+                let module = match directive.imported_module.get() {\n+                    Some(module) => module,\n                     None => return Some(Indeterminate),\n                 };\n                 let name = match directive.subclass {\n                     SingleImport { source, .. } => source,\n                     GlobImport { .. } => unreachable!(),\n                 };\n-                match self.resolve_name_in_module(target_module, name, ns, true, None) {\n+                match self.resolve_name_in_module(module, name, ns, true, None) {\n                     Failed(_) => {}\n                     _ => return Some(Indeterminate),\n                 }\n@@ -250,7 +250,7 @@ impl<'a> Resolver<'a> {\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent: current_module,\n             module_path: module_path,\n-            target_module: Cell::new(None),\n+            imported_module: Cell::new(None),\n             subclass: subclass,\n             span: span,\n             id: id,\n@@ -485,10 +485,9 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                names_to_string(&directive.module_path),\n                module_to_string(self.current_module));\n \n-        let module = directive.parent;\n-        self.set_current_module(module);\n+        self.set_current_module(directive.parent);\n \n-        let target_module = if let Some(module) = directive.target_module.get() {\n+        let module = if let Some(module) = directive.imported_module.get() {\n             module\n         } else {\n             let vis = directive.vis.get();\n@@ -506,7 +505,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             }\n         };\n \n-        directive.target_module.set(Some(target_module));\n+        directive.imported_module.set(Some(module));\n         let (source, target, value_result, type_result) = match directive.subclass {\n             SingleImport { source, target, ref value_result, ref type_result } =>\n                 (source, target, value_result, type_result),\n@@ -520,7 +519,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         for &(ns, result) in &[(ValueNS, value_result), (TypeNS, type_result)] {\n             if let Err(false) = result.get() {\n                 result.set({\n-                    match self.resolve_name_in_module(target_module, source, ns, false, None) {\n+                    match self.resolve_name_in_module(module, source, ns, false, None) {\n                         Success(binding) => Ok(binding),\n                         Indeterminate => Err(false),\n                         Failed(_) => Err(true),\n@@ -533,7 +532,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n             match result.get() {\n                 Err(false) => indeterminate = true,\n                 Err(true) => {\n-                    self.update_resolution(module, target, ns, |_, resolution| {\n+                    self.update_resolution(directive.parent, target, ns, |_, resolution| {\n                         resolution.single_imports.directive_failed()\n                     });\n                 }\n@@ -549,10 +548,10 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 }\n                 Ok(binding) => {\n                     let imported_binding = self.import(binding, directive);\n-                    let conflict = self.try_define(module, target, ns, imported_binding);\n+                    let conflict = self.try_define(directive.parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         let binding = &self.import(binding, directive);\n-                        self.report_conflict(module, target, ns, binding, old_binding);\n+                        self.report_conflict(directive.parent, target, ns, binding, old_binding);\n                     }\n                 }\n             }\n@@ -666,38 +665,37 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n     }\n \n     fn resolve_glob_import(&mut self, directive: &'b ImportDirective<'b>) {\n-        let target_module = directive.target_module.get().unwrap();\n-        self.populate_module_if_necessary(target_module);\n+        let module = directive.imported_module.get().unwrap();\n+        self.populate_module_if_necessary(module);\n \n-        if let Some(Def::Trait(_)) = target_module.def {\n+        if let Some(Def::Trait(_)) = module.def {\n             self.session.span_err(directive.span, \"items in traits are not importable.\");\n         }\n \n-        let module = directive.parent;\n-        if target_module.def_id() == module.def_id()  {\n+        if module.def_id() == directive.parent.def_id()  {\n             return;\n         } else if let GlobImport { is_prelude: true } = directive.subclass {\n-            self.prelude = Some(target_module);\n+            self.prelude = Some(module);\n             return;\n         }\n \n-        // Add to target_module's glob_importers\n-        target_module.glob_importers.borrow_mut().push(directive);\n+        // Add to module's glob_importers\n+        module.glob_importers.borrow_mut().push(directive);\n \n         // Ensure that `resolutions` isn't borrowed during `try_define`,\n         // since it might get updated via a glob cycle.\n-        let bindings = target_module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n+        let bindings = module.resolutions.borrow().iter().filter_map(|(name, resolution)| {\n             resolution.borrow().binding().map(|binding| (*name, binding))\n         }).collect::<Vec<_>>();\n         for ((name, ns), binding) in bindings {\n             if binding.is_importable() && binding.is_pseudo_public() {\n                 let imported_binding = self.import(binding, directive);\n-                let _ = self.try_define(module, name, ns, imported_binding);\n+                let _ = self.try_define(directive.parent, name, ns, imported_binding);\n             }\n         }\n \n         // Record the destination of this import\n-        if let Some(did) = target_module.def_id() {\n+        if let Some(did) = module.def_id() {\n             let resolution = PathResolution::new(Def::Mod(did));\n             self.def_map.insert(directive.id, resolution);\n         }"}]}