{"sha": "5560d4d6d7685b7eb9425d8d54c346157471a0ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1NjBkNGQ2ZDc2ODViN2ViOTQyNWQ4ZDU0YzM0NjE1NzQ3MWEwYWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-13T04:26:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-13T04:26:44Z"}, "message": "Rollup merge of #57353 - huonw:faster-finiteness-checks, r=KodrAus\n\nOptimise floating point `is_finite` (2x) and `is_infinite` (1.6x).\n\nThese can both rely on IEEE754 semantics to be made faster, by folding\naway the sign with an abs (left private for now), and then comparing\nto infinity, letting the NaN semantics of a direct float comparison\nhandle NaN input properly.\n\nThe `abs` bit-fiddling is simple (a single and), and so these new\nforms compile down to a few instructions, without branches, e.g. for\nf32:\n\n```asm\nis_infinite:\n        andps   xmm0, xmmword ptr [rip + .LCPI2_0] ; 0x7FFF_FFFF\n        ucomiss xmm0, dword ptr [rip + .LCPI2_1]   ; 0x7F80_0000\n        setae   al\n        ret\n\nis_finite:\n        andps   xmm0, xmmword ptr [rip + .LCPI1_0] ; 0x7FFF_FFFF\n        movss   xmm1, dword ptr [rip + .LCPI1_1]   ; 0x7F80_0000\n        ucomiss xmm1, xmm0\n        seta    al\n        ret\n```\n\nWhen used in loops/repeatedly, they get even better: the memory\noperations (loading the mask 0x7FFFFFFF for abs, and infinity\n0x7F80_0000) are likely to be hoisted out of the individual calls, to\nbe shared, and the `seta`/`setae` are likely to be collapsed into\nconditional jumps or moves (or similar).\n\nThe old `is_infinite` did two comparisons, and the old `is_finite` did\nthree (with a branch), and both of them had to check the flags after\nevery one of those comparison. These functions have had that old\nimplementation since they were added in\nhttps://github.com/rust-lang/rust/commit/6284190ef9918e05cb9147a2a81100ddcb06fea8\n7 years ago.\n\nBenchmark (`abs` is the new form, `std` is the old):\n\n```\ntest f32_is_finite_abs            ... bench:          55 ns/iter (+/- 10)\ntest f32_is_finite_std            ... bench:         118 ns/iter (+/- 5)\n\ntest f32_is_infinite_abs          ... bench:          53 ns/iter (+/- 1)\ntest f32_is_infinite_std          ... bench:          84 ns/iter (+/- 6)\n\ntest f64_is_finite_abs            ... bench:          52 ns/iter (+/- 12)\ntest f64_is_finite_std            ... bench:         128 ns/iter (+/- 25)\n\ntest f64_is_infinite_abs          ... bench:          54 ns/iter (+/- 5)\ntest f64_is_infinite_std          ... bench:          93 ns/iter (+/- 23)\n```\n\n```rust\n #![feature(test)]\nextern crate test;\n\nuse std::{f32, f64};\nuse test::Bencher;\n\nconst VALUES_F32: &[f32] = &[0.910, 0.135, 0.735, -0.874, 0.518, 0.150, -0.527, -0.418, 0.449, -0.158, -0.064, -0.144, -0.948, -0.103, 0.225, -0.104, -0.795, 0.435, 0.860, 0.027, 0.625, -0.848, -0.454, 0.359, -0.930, 0.067, 0.642, 0.976, -0.682, -0.035, 0.750, 0.005, -0.825, 0.731, -0.850, -0.740, -0.118, -0.972, 0.888, -0.958, 0.086, 0.237, -0.580, 0.488, 0.028, -0.552, 0.302, 0.058, -0.229, -0.166, -0.248, -0.430, 0.789, -0.122, 0.120, -0.934, -0.911, -0.976, 0.882, -0.410, 0.311, -0.611, -0.758, 0.786, -0.711, 0.378, 0.803, -0.068, 0.932, 0.483, 0.085, 0.247, -0.128, -0.839, -0.737, -0.605, 0.637, -0.230, -0.502, 0.231, -0.694, -0.400, -0.441, 0.142, 0.174, 0.681, -0.763, -0.608, 0.848, -0.550, 0.883, -0.212, 0.876, 0.186, -0.909, 0.401, -0.533, -0.961, 0.539, -0.298, -0.448, 0.223, -0.307, -0.594, 0.629, -0.534, 0.959, 0.349, -0.926, -0.523, -0.895, -0.157, -0.074, -0.060, 0.513, -0.647, -0.649, 0.428, 0.401, 0.391, 0.426, 0.700, 0.880, -0.101, 0.862, 0.493, 0.819, -0.597];\n\n #[bench]\nfn f32_is_infinite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().any(|x| x.is_infinite()));\n}\n #[bench]\nfn f32_is_infinite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().any(|x| x.abs()== f32::INFINITY));\n}\n #[bench]\nfn f32_is_finite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().all(|x| x.is_finite()));\n}\n #[bench]\nfn f32_is_finite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().all(|x| x.abs() < f32::INFINITY));\n}\n\nconst VALUES_F64: &[f64] = &[0.910, 0.135, 0.735, -0.874, 0.518, 0.150, -0.527, -0.418, 0.449, -0.158, -0.064, -0.144, -0.948, -0.103, 0.225, -0.104, -0.795, 0.435, 0.860, 0.027, 0.625, -0.848, -0.454, 0.359, -0.930, 0.067, 0.642, 0.976, -0.682, -0.035, 0.750, 0.005, -0.825, 0.731, -0.850, -0.740, -0.118, -0.972, 0.888, -0.958, 0.086, 0.237, -0.580, 0.488, 0.028, -0.552, 0.302, 0.058, -0.229, -0.166, -0.248, -0.430, 0.789, -0.122, 0.120, -0.934, -0.911, -0.976, 0.882, -0.410, 0.311, -0.611, -0.758, 0.786, -0.711, 0.378, 0.803, -0.068, 0.932, 0.483, 0.085, 0.247, -0.128, -0.839, -0.737, -0.605, 0.637, -0.230, -0.502, 0.231, -0.694, -0.400, -0.441, 0.142, 0.174, 0.681, -0.763, -0.608, 0.848, -0.550, 0.883, -0.212, 0.876, 0.186, -0.909, 0.401, -0.533, -0.961, 0.539, -0.298, -0.448, 0.223, -0.307, -0.594, 0.629, -0.534, 0.959, 0.349, -0.926, -0.523, -0.895, -0.157, -0.074, -0.060, 0.513, -0.647, -0.649, 0.428, 0.401, 0.391, 0.426, 0.700, 0.880, -0.101, 0.862, 0.493, 0.819, -0.597];\n\n #[bench]\nfn f64_is_infinite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().any(|x| x.is_infinite()));\n}\n #[bench]\nfn f64_is_infinite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().any(|x| x.abs() == f64::INFINITY));\n}\n #[bench]\nfn f64_is_finite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().all(|x| x.is_finite()));\n}\n #[bench]\nfn f64_is_finite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().all(|x| x.abs() < f64::INFINITY));\n}\n```", "tree": {"sha": "d20e04e9190b732c91439a6a34289f3616977147", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d20e04e9190b732c91439a6a34289f3616977147"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5560d4d6d7685b7eb9425d8d54c346157471a0ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcOr4FCRBK7hj4Ov3rIwAAdHIIAJWB1Pxbx5dYmPkHF76gHthj\nv8KIZNnVj5jEu0qBA5nxsdnfLuDBQ74TOxRA+IsIk77LLKmfwvLj+tAMbIdALSrR\nP9YUfaI8FabLb3g0APKB544UDdyEFeVvDc7bSPHskoB/unSNxd0wut9otLDbQ1B4\ntc6gZ+FGoe+3ZfnG0R9CZfUMGGK1+KtyNQFpoYD5pOvg+OYnsCRsNtCID8PWUehV\nGOVeTyqf7MQlRWeVjfdEswYYGc7kN0R7syLrQevWY4mM059fF7OdYBXFW6CnWMox\nGabQwBrRqIbjv5tXxTptsTyXtsC0/6YtC8KUaN4TZjBaYHRLoMmrTZWYwkT8akY=\n=mg5o\n-----END PGP SIGNATURE-----\n", "payload": "tree d20e04e9190b732c91439a6a34289f3616977147\nparent 035eff1c1fdc42ae7713efd81d7a481014015a95\nparent 6e742dbb3f5f9dde10dda8ba1930e03a0f057b5e\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547353604 +0100\ncommitter GitHub <noreply@github.com> 1547353604 +0100\n\nRollup merge of #57353 - huonw:faster-finiteness-checks, r=KodrAus\n\nOptimise floating point `is_finite` (2x) and `is_infinite` (1.6x).\n\nThese can both rely on IEEE754 semantics to be made faster, by folding\naway the sign with an abs (left private for now), and then comparing\nto infinity, letting the NaN semantics of a direct float comparison\nhandle NaN input properly.\n\nThe `abs` bit-fiddling is simple (a single and), and so these new\nforms compile down to a few instructions, without branches, e.g. for\nf32:\n\n```asm\nis_infinite:\n        andps   xmm0, xmmword ptr [rip + .LCPI2_0] ; 0x7FFF_FFFF\n        ucomiss xmm0, dword ptr [rip + .LCPI2_1]   ; 0x7F80_0000\n        setae   al\n        ret\n\nis_finite:\n        andps   xmm0, xmmword ptr [rip + .LCPI1_0] ; 0x7FFF_FFFF\n        movss   xmm1, dword ptr [rip + .LCPI1_1]   ; 0x7F80_0000\n        ucomiss xmm1, xmm0\n        seta    al\n        ret\n```\n\nWhen used in loops/repeatedly, they get even better: the memory\noperations (loading the mask 0x7FFFFFFF for abs, and infinity\n0x7F80_0000) are likely to be hoisted out of the individual calls, to\nbe shared, and the `seta`/`setae` are likely to be collapsed into\nconditional jumps or moves (or similar).\n\nThe old `is_infinite` did two comparisons, and the old `is_finite` did\nthree (with a branch), and both of them had to check the flags after\nevery one of those comparison. These functions have had that old\nimplementation since they were added in\nhttps://github.com/rust-lang/rust/commit/6284190ef9918e05cb9147a2a81100ddcb06fea8\n7 years ago.\n\nBenchmark (`abs` is the new form, `std` is the old):\n\n```\ntest f32_is_finite_abs            ... bench:          55 ns/iter (+/- 10)\ntest f32_is_finite_std            ... bench:         118 ns/iter (+/- 5)\n\ntest f32_is_infinite_abs          ... bench:          53 ns/iter (+/- 1)\ntest f32_is_infinite_std          ... bench:          84 ns/iter (+/- 6)\n\ntest f64_is_finite_abs            ... bench:          52 ns/iter (+/- 12)\ntest f64_is_finite_std            ... bench:         128 ns/iter (+/- 25)\n\ntest f64_is_infinite_abs          ... bench:          54 ns/iter (+/- 5)\ntest f64_is_infinite_std          ... bench:          93 ns/iter (+/- 23)\n```\n\n```rust\n #![feature(test)]\nextern crate test;\n\nuse std::{f32, f64};\nuse test::Bencher;\n\nconst VALUES_F32: &[f32] = &[0.910, 0.135, 0.735, -0.874, 0.518, 0.150, -0.527, -0.418, 0.449, -0.158, -0.064, -0.144, -0.948, -0.103, 0.225, -0.104, -0.795, 0.435, 0.860, 0.027, 0.625, -0.848, -0.454, 0.359, -0.930, 0.067, 0.642, 0.976, -0.682, -0.035, 0.750, 0.005, -0.825, 0.731, -0.850, -0.740, -0.118, -0.972, 0.888, -0.958, 0.086, 0.237, -0.580, 0.488, 0.028, -0.552, 0.302, 0.058, -0.229, -0.166, -0.248, -0.430, 0.789, -0.122, 0.120, -0.934, -0.911, -0.976, 0.882, -0.410, 0.311, -0.611, -0.758, 0.786, -0.711, 0.378, 0.803, -0.068, 0.932, 0.483, 0.085, 0.247, -0.128, -0.839, -0.737, -0.605, 0.637, -0.230, -0.502, 0.231, -0.694, -0.400, -0.441, 0.142, 0.174, 0.681, -0.763, -0.608, 0.848, -0.550, 0.883, -0.212, 0.876, 0.186, -0.909, 0.401, -0.533, -0.961, 0.539, -0.298, -0.448, 0.223, -0.307, -0.594, 0.629, -0.534, 0.959, 0.349, -0.926, -0.523, -0.895, -0.157, -0.074, -0.060, 0.513, -0.647, -0.649, 0.428, 0.401, 0.391, 0.426, 0.700, 0.880, -0.101, 0.862, 0.493, 0.819, -0.597];\n\n #[bench]\nfn f32_is_infinite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().any(|x| x.is_infinite()));\n}\n #[bench]\nfn f32_is_infinite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().any(|x| x.abs()== f32::INFINITY));\n}\n #[bench]\nfn f32_is_finite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().all(|x| x.is_finite()));\n}\n #[bench]\nfn f32_is_finite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F32).iter().all(|x| x.abs() < f32::INFINITY));\n}\n\nconst VALUES_F64: &[f64] = &[0.910, 0.135, 0.735, -0.874, 0.518, 0.150, -0.527, -0.418, 0.449, -0.158, -0.064, -0.144, -0.948, -0.103, 0.225, -0.104, -0.795, 0.435, 0.860, 0.027, 0.625, -0.848, -0.454, 0.359, -0.930, 0.067, 0.642, 0.976, -0.682, -0.035, 0.750, 0.005, -0.825, 0.731, -0.850, -0.740, -0.118, -0.972, 0.888, -0.958, 0.086, 0.237, -0.580, 0.488, 0.028, -0.552, 0.302, 0.058, -0.229, -0.166, -0.248, -0.430, 0.789, -0.122, 0.120, -0.934, -0.911, -0.976, 0.882, -0.410, 0.311, -0.611, -0.758, 0.786, -0.711, 0.378, 0.803, -0.068, 0.932, 0.483, 0.085, 0.247, -0.128, -0.839, -0.737, -0.605, 0.637, -0.230, -0.502, 0.231, -0.694, -0.400, -0.441, 0.142, 0.174, 0.681, -0.763, -0.608, 0.848, -0.550, 0.883, -0.212, 0.876, 0.186, -0.909, 0.401, -0.533, -0.961, 0.539, -0.298, -0.448, 0.223, -0.307, -0.594, 0.629, -0.534, 0.959, 0.349, -0.926, -0.523, -0.895, -0.157, -0.074, -0.060, 0.513, -0.647, -0.649, 0.428, 0.401, 0.391, 0.426, 0.700, 0.880, -0.101, 0.862, 0.493, 0.819, -0.597];\n\n #[bench]\nfn f64_is_infinite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().any(|x| x.is_infinite()));\n}\n #[bench]\nfn f64_is_infinite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().any(|x| x.abs() == f64::INFINITY));\n}\n #[bench]\nfn f64_is_finite_std(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().all(|x| x.is_finite()));\n}\n #[bench]\nfn f64_is_finite_abs(b: &mut Bencher) {\n    b.iter(|| test::black_box(VALUES_F64).iter().all(|x| x.abs() < f64::INFINITY));\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5560d4d6d7685b7eb9425d8d54c346157471a0ad", "html_url": "https://github.com/rust-lang/rust/commit/5560d4d6d7685b7eb9425d8d54c346157471a0ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5560d4d6d7685b7eb9425d8d54c346157471a0ad/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "035eff1c1fdc42ae7713efd81d7a481014015a95", "url": "https://api.github.com/repos/rust-lang/rust/commits/035eff1c1fdc42ae7713efd81d7a481014015a95", "html_url": "https://github.com/rust-lang/rust/commit/035eff1c1fdc42ae7713efd81d7a481014015a95"}, {"sha": "6e742dbb3f5f9dde10dda8ba1930e03a0f057b5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e742dbb3f5f9dde10dda8ba1930e03a0f057b5e", "html_url": "https://github.com/rust-lang/rust/commit/6e742dbb3f5f9dde10dda8ba1930e03a0f057b5e"}], "stats": {"total": 28, "additions": 24, "deletions": 4}, "files": [{"sha": "68da79135d3a33ee76d4b52c718e2ee0e646ee84", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5560d4d6d7685b7eb9425d8d54c346157471a0ad/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5560d4d6d7685b7eb9425d8d54c346157471a0ad/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=5560d4d6d7685b7eb9425d8d54c346157471a0ad", "patch": "@@ -161,6 +161,14 @@ impl f32 {\n         self != self\n     }\n \n+    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n+    // concerns about portability, so this implementation is for\n+    // private use internally.\n+    #[inline]\n+    fn abs_private(self) -> f32 {\n+        f32::from_bits(self.to_bits() & 0x7fff_ffff)\n+    }\n+\n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n     ///\n@@ -181,7 +189,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool {\n-        self == INFINITY || self == NEG_INFINITY\n+        self.abs_private() == INFINITY\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -203,7 +211,9 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n+        // There's no need to handle NaN separately: if self is NaN,\n+        // the comparison is not true, exactly as desired.\n+        self.abs_private() < INFINITY\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,"}, {"sha": "b677391548146ec4c69e26ef18f21ed9ecdbea79", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5560d4d6d7685b7eb9425d8d54c346157471a0ad/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5560d4d6d7685b7eb9425d8d54c346157471a0ad/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=5560d4d6d7685b7eb9425d8d54c346157471a0ad", "patch": "@@ -161,6 +161,14 @@ impl f64 {\n         self != self\n     }\n \n+    // FIXME(#50145): `abs` is publicly unavailable in libcore due to\n+    // concerns about portability, so this implementation is for\n+    // private use internally.\n+    #[inline]\n+    fn abs_private(self) -> f64 {\n+        f64::from_bits(self.to_bits() & 0x7fff_ffff_ffff_ffff)\n+    }\n+\n     /// Returns `true` if this value is positive infinity or negative infinity and\n     /// false otherwise.\n     ///\n@@ -181,7 +189,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_infinite(self) -> bool {\n-        self == INFINITY || self == NEG_INFINITY\n+        self.abs_private() == INFINITY\n     }\n \n     /// Returns `true` if this number is neither infinite nor `NaN`.\n@@ -203,7 +211,9 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is_finite(self) -> bool {\n-        !(self.is_nan() || self.is_infinite())\n+        // There's no need to handle NaN separately: if self is NaN,\n+        // the comparison is not true, exactly as desired.\n+        self.abs_private() < INFINITY\n     }\n \n     /// Returns `true` if the number is neither zero, infinite,"}]}