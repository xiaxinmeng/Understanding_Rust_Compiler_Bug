{"sha": "dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "node_id": "C_kwDOAAsO6NoAKGRjODBjYTc4YjZlYzJiNmJiYTAyNTYwNDcwMzQ3NDMzYmNkMGJiM2M", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T16:24:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-21T16:24:56Z"}, "message": "Auto merge of #98098 - bjorn3:archive_refactor, r=michaelwoerister\n\nRemove the source archive functionality of ArchiveWriter\n\nWe now build archives through strictly additive means rather than taking an existing archive and potentially substracting parts. This is simpler and makes it easier to swap out the archive writer in https://github.com/rust-lang/rust/pull/97485.", "tree": {"sha": "fdb55256f83f00febe26d6d345a3c5811fc2fc81", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdb55256f83f00febe26d6d345a3c5811fc2fc81"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "html_url": "https://github.com/rust-lang/rust/commit/dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "url": "https://api.github.com/repos/rust-lang/rust/commits/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f", "html_url": "https://github.com/rust-lang/rust/commit/72fd41a8b4d3488c97df3c3c75ddd9951aa3c73f"}, {"sha": "7643f82e012c29603374fbdc4cd8c2ce3b600c82", "url": "https://api.github.com/repos/rust-lang/rust/commits/7643f82e012c29603374fbdc4cd8c2ce3b600c82", "html_url": "https://github.com/rust-lang/rust/commit/7643f82e012c29603374fbdc4cd8c2ce3b600c82"}], "stats": {"total": 255, "additions": 62, "deletions": 193}, "files": [{"sha": "0812f930b5dea20c06b97e93127c9105174c5dd5", "filename": "compiler/rustc_codegen_cranelift/src/archive.rs", "status": "modified", "additions": 8, "deletions": 35, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Farchive.rs?ref=dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "patch": "@@ -30,50 +30,19 @@ pub(crate) struct ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n-        let (src_archives, entries) = if let Some(input) = input {\n-            let read_cache = ReadCache::new(File::open(input).unwrap());\n-            let archive = ArchiveFile::parse(&read_cache).unwrap();\n-            let mut entries = Vec::new();\n-\n-            for entry in archive.members() {\n-                let entry = entry.unwrap();\n-                entries.push((\n-                    entry.name().to_vec(),\n-                    ArchiveEntry::FromArchive { archive_index: 0, file_range: entry.file_range() },\n-                ));\n-            }\n-\n-            (vec![read_cache.into_inner()], entries)\n-        } else {\n-            (vec![], Vec::new())\n-        };\n-\n+    fn new(sess: &'a Session, output: &Path) -> Self {\n         ArArchiveBuilder {\n             sess,\n             dst: output.to_path_buf(),\n             use_gnu_style_archive: sess.target.archive_format == \"gnu\",\n             // FIXME fix builtin ranlib on macOS\n             no_builtin_ranlib: sess.target.is_like_osx,\n \n-            src_archives,\n-            entries,\n+            src_archives: vec![],\n+            entries: vec![],\n         }\n     }\n \n-    fn src_files(&mut self) -> Vec<String> {\n-        self.entries.iter().map(|(name, _)| String::from_utf8(name.clone()).unwrap()).collect()\n-    }\n-\n-    fn remove_file(&mut self, name: &str) {\n-        let index = self\n-            .entries\n-            .iter()\n-            .position(|(entry_name, _)| entry_name == name.as_bytes())\n-            .expect(\"Tried to remove file not existing in src archive\");\n-        self.entries.remove(index);\n-    }\n-\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string().into_bytes(),\n@@ -105,7 +74,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) {\n+    fn build(mut self) -> bool {\n         enum BuilderKind {\n             Bsd(ar::Builder<File>),\n             Gnu(ar::GnuBuilder<File>),\n@@ -204,6 +173,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             )\n         };\n \n+        let any_members = !entries.is_empty();\n+\n         // Add all files\n         for (entry_name, data) in entries.into_iter() {\n             let header = ar::Header::new(entry_name, data.len() as u64);\n@@ -229,6 +200,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n                 self.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n             }\n         }\n+\n+        any_members\n     }\n \n     fn inject_dll_import_lib("}, {"sha": "411ec27139e426d20968c8e7ba8091f5c3e9f291", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 8, "deletions": 39, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "patch": "@@ -32,7 +32,7 @@ pub struct ArArchiveBuilder<'a> {\n }\n \n impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self {\n+    fn new(sess: &'a Session, output: &Path) -> Self {\n         let config = ArchiveConfig {\n             sess,\n             dst: output.to_path_buf(),\n@@ -41,48 +41,13 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             use_gnu_style_archive: sess.target.options.archive_format == \"gnu\",\n         };\n \n-        let (src_archives, entries) = if let Some(input) = input {\n-            let mut archive = ar::Archive::new(File::open(input).unwrap());\n-            let mut entries = Vec::new();\n-\n-            let mut i = 0;\n-            while let Some(entry) = archive.next_entry() {\n-                let entry = entry.unwrap();\n-                entries.push((\n-                    String::from_utf8(entry.header().identifier().to_vec()).unwrap(),\n-                    ArchiveEntry::FromArchive {\n-                        archive_index: 0,\n-                        entry_index: i,\n-                    },\n-                ));\n-                i += 1;\n-            }\n-\n-            (vec![(input.to_owned(), archive)], entries)\n-        } else {\n-            (vec![], Vec::new())\n-        };\n-\n         ArArchiveBuilder {\n             config,\n-            src_archives,\n-            entries,\n+            src_archives: vec![],\n+            entries: vec![],\n         }\n     }\n \n-    fn src_files(&mut self) -> Vec<String> {\n-        self.entries.iter().map(|(name, _)| name.clone()).collect()\n-    }\n-\n-    fn remove_file(&mut self, name: &str) {\n-        let index = self\n-            .entries\n-            .iter()\n-            .position(|(entry_name, _)| entry_name == name)\n-            .expect(\"Tried to remove file not existing in src archive\");\n-        self.entries.remove(index);\n-    }\n-\n     fn add_file(&mut self, file: &Path) {\n         self.entries.push((\n             file.file_name().unwrap().to_str().unwrap().to_string(),\n@@ -113,7 +78,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         Ok(())\n     }\n \n-    fn build(mut self) {\n+    fn build(mut self) -> bool {\n         use std::process::Command;\n \n         fn add_file_using_ar(archive: &Path, file: &Path) {\n@@ -146,6 +111,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             BuilderKind::Bsd(ar::Builder::new(File::create(&self.config.dst).unwrap()))\n         };\n \n+        let any_members = !self.entries.is_empty();\n+\n         // Add all files\n         for (entry_name, entry) in self.entries.into_iter() {\n             match entry {\n@@ -206,6 +173,8 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n         if !status.success() {\n             self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n         }\n+\n+        any_members\n     }\n \n     fn inject_dll_import_lib(&mut self, _lib_name: &str, _dll_imports: &[DllImport], _tmpdir: &MaybeTempDir) {"}, {"sha": "da9d8b5fb334a6c1c6de81567b4daeb48e0e250a", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 25, "deletions": 95, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "patch": "@@ -15,19 +15,12 @@ use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_session::cstore::{DllCallingConvention, DllImport};\n use rustc_session::Session;\n \n-struct ArchiveConfig<'a> {\n-    pub sess: &'a Session,\n-    pub dst: PathBuf,\n-    pub src: Option<PathBuf>,\n-}\n-\n /// Helper for adding many files to an archive.\n #[must_use = \"must call build() to finish building the archive\"]\n pub struct LlvmArchiveBuilder<'a> {\n-    config: ArchiveConfig<'a>,\n-    removals: Vec<String>,\n+    sess: &'a Session,\n+    dst: PathBuf,\n     additions: Vec<Addition>,\n-    src_archive: Option<Option<ArchiveRO>>,\n }\n \n enum Addition {\n@@ -50,10 +43,6 @@ fn is_relevant_child(c: &Child<'_>) -> bool {\n     }\n }\n \n-fn archive_config<'a>(sess: &'a Session, output: &Path, input: Option<&Path>) -> ArchiveConfig<'a> {\n-    ArchiveConfig { sess, dst: output.to_path_buf(), src: input.map(|p| p.to_path_buf()) }\n-}\n-\n /// Map machine type strings to values of LLVM's MachineTypes enum.\n fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n     match cpu {\n@@ -68,37 +57,8 @@ fn llvm_machine_type(cpu: &str) -> LLVMMachineType {\n impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n     /// Creates a new static archive, ready for modifying the archive specified\n     /// by `config`.\n-    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> LlvmArchiveBuilder<'a> {\n-        let config = archive_config(sess, output, input);\n-        LlvmArchiveBuilder {\n-            config,\n-            removals: Vec::new(),\n-            additions: Vec::new(),\n-            src_archive: None,\n-        }\n-    }\n-\n-    /// Removes a file from this archive\n-    fn remove_file(&mut self, file: &str) {\n-        self.removals.push(file.to_string());\n-    }\n-\n-    /// Lists all files in an archive\n-    fn src_files(&mut self) -> Vec<String> {\n-        if self.src_archive().is_none() {\n-            return Vec::new();\n-        }\n-\n-        let archive = self.src_archive.as_ref().unwrap().as_ref().unwrap();\n-\n-        archive\n-            .iter()\n-            .filter_map(|child| child.ok())\n-            .filter(is_relevant_child)\n-            .filter_map(|child| child.name())\n-            .filter(|name| !self.removals.iter().any(|x| x == name))\n-            .map(|name| name.to_owned())\n-            .collect()\n+    fn new(sess: &'a Session, output: &Path) -> LlvmArchiveBuilder<'a> {\n+        LlvmArchiveBuilder { sess, dst: output.to_path_buf(), additions: Vec::new() }\n     }\n \n     fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n@@ -129,13 +89,10 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n     /// Combine the provided files, rlibs, and native libraries into a single\n     /// `Archive`.\n-    fn build(mut self) {\n-        let kind = self.llvm_archive_kind().unwrap_or_else(|kind| {\n-            self.config.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n-        });\n-\n-        if let Err(e) = self.build_with_llvm(kind) {\n-            self.config.sess.fatal(&format!(\"failed to build archive: {}\", e));\n+    fn build(mut self) -> bool {\n+        match self.build_with_llvm() {\n+            Ok(any_members) => any_members,\n+            Err(e) => self.sess.fatal(&format!(\"failed to build archive: {}\", e)),\n         }\n     }\n \n@@ -151,7 +108,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             output_path.with_extension(\"lib\")\n         };\n \n-        let target = &self.config.sess.target;\n+        let target = &self.sess.target;\n         let mingw_gnu_toolchain = target.vendor == \"pc\"\n             && target.os == \"windows\"\n             && target.env == \"gnu\"\n@@ -160,7 +117,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         let import_name_and_ordinal_vector: Vec<(String, Option<u16>)> = dll_imports\n             .iter()\n             .map(|import: &DllImport| {\n-                if self.config.sess.target.arch == \"x86\" {\n+                if self.sess.target.arch == \"x86\" {\n                     (\n                         LlvmArchiveBuilder::i686_decorated_name(import, mingw_gnu_toolchain),\n                         import.ordinal,\n@@ -197,11 +154,11 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n             match std::fs::write(&def_file_path, def_file_content) {\n                 Ok(_) => {}\n                 Err(e) => {\n-                    self.config.sess.fatal(&format!(\"Error writing .DEF file: {}\", e));\n+                    self.sess.fatal(&format!(\"Error writing .DEF file: {}\", e));\n                 }\n             };\n \n-            let dlltool = find_binutils_dlltool(self.config.sess);\n+            let dlltool = find_binutils_dlltool(self.sess);\n             let result = std::process::Command::new(dlltool)\n                 .args([\n                     \"-d\",\n@@ -215,9 +172,9 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n \n             match result {\n                 Err(e) => {\n-                    self.config.sess.fatal(&format!(\"Error calling dlltool: {}\", e));\n+                    self.sess.fatal(&format!(\"Error calling dlltool: {}\", e));\n                 }\n-                Ok(output) if !output.status.success() => self.config.sess.fatal(&format!(\n+                Ok(output) if !output.status.success() => self.sess.fatal(&format!(\n                     \"Dlltool could not create import library: {}\\n{}\",\n                     String::from_utf8_lossy(&output.stdout),\n                     String::from_utf8_lossy(&output.stderr)\n@@ -263,13 +220,13 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n                     output_path_z.as_ptr(),\n                     ffi_exports.as_ptr(),\n                     ffi_exports.len(),\n-                    llvm_machine_type(&self.config.sess.target.arch) as u16,\n-                    !self.config.sess.target.is_like_msvc,\n+                    llvm_machine_type(&self.sess.target.arch) as u16,\n+                    !self.sess.target.is_like_msvc,\n                 )\n             };\n \n             if result == crate::llvm::LLVMRustResult::Failure {\n-                self.config.sess.fatal(&format!(\n+                self.sess.fatal(&format!(\n                     \"Error creating import library for {}: {}\",\n                     lib_name,\n                     llvm::last_error().unwrap_or(\"unknown LLVM error\".to_string())\n@@ -278,7 +235,7 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n         };\n \n         self.add_archive(&output_path, |_| false).unwrap_or_else(|e| {\n-            self.config.sess.fatal(&format!(\n+            self.sess.fatal(&format!(\n                 \"failed to add native library {}: {}\",\n                 output_path.display(),\n                 e\n@@ -288,46 +245,19 @@ impl<'a> ArchiveBuilder<'a> for LlvmArchiveBuilder<'a> {\n }\n \n impl<'a> LlvmArchiveBuilder<'a> {\n-    fn src_archive(&mut self) -> Option<&ArchiveRO> {\n-        if let Some(ref a) = self.src_archive {\n-            return a.as_ref();\n-        }\n-        let src = self.config.src.as_ref()?;\n-        self.src_archive = Some(ArchiveRO::open(src).ok());\n-        self.src_archive.as_ref().unwrap().as_ref()\n-    }\n-\n-    fn llvm_archive_kind(&self) -> Result<ArchiveKind, &str> {\n-        let kind = &*self.config.sess.target.archive_format;\n-        kind.parse().map_err(|_| kind)\n-    }\n+    fn build_with_llvm(&mut self) -> io::Result<bool> {\n+        let kind = &*self.sess.target.archive_format;\n+        let kind = kind.parse::<ArchiveKind>().map_err(|_| kind).unwrap_or_else(|kind| {\n+            self.sess.fatal(&format!(\"Don't know how to build archive of type: {}\", kind))\n+        });\n \n-    fn build_with_llvm(&mut self, kind: ArchiveKind) -> io::Result<()> {\n-        let removals = mem::take(&mut self.removals);\n         let mut additions = mem::take(&mut self.additions);\n         let mut strings = Vec::new();\n         let mut members = Vec::new();\n \n-        let dst = CString::new(self.config.dst.to_str().unwrap())?;\n+        let dst = CString::new(self.dst.to_str().unwrap())?;\n \n         unsafe {\n-            if let Some(archive) = self.src_archive() {\n-                for child in archive.iter() {\n-                    let child = child.map_err(string_to_io_error)?;\n-                    let Some(child_name) = child.name() else { continue };\n-                    if removals.iter().any(|r| r == child_name) {\n-                        continue;\n-                    }\n-\n-                    let name = CString::new(child_name)?;\n-                    members.push(llvm::LLVMRustArchiveMemberNew(\n-                        ptr::null(),\n-                        name.as_ptr(),\n-                        Some(child.raw),\n-                    ));\n-                    strings.push(name);\n-                }\n-            }\n             for addition in &mut additions {\n                 match addition {\n                     Addition::File { path, name_in_archive } => {\n@@ -389,7 +319,7 @@ impl<'a> LlvmArchiveBuilder<'a> {\n                 };\n                 Err(io::Error::new(io::ErrorKind::Other, msg))\n             } else {\n-                Ok(())\n+                Ok(!members.is_empty())\n             };\n             for member in members {\n                 llvm::LLVMRustArchiveMemberFree(member);"}, {"sha": "553486ae8ec65e4d970cb16a2ce8d31b56acaf1d", "filename": "compiler/rustc_codegen_ssa/src/back/archive.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Farchive.rs?ref=dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "patch": "@@ -42,17 +42,15 @@ pub(super) fn find_library(\n }\n \n pub trait ArchiveBuilder<'a> {\n-    fn new(sess: &'a Session, output: &Path, input: Option<&Path>) -> Self;\n+    fn new(sess: &'a Session, output: &Path) -> Self;\n \n     fn add_file(&mut self, path: &Path);\n-    fn remove_file(&mut self, name: &str);\n-    fn src_files(&mut self) -> Vec<String>;\n \n     fn add_archive<F>(&mut self, archive: &Path, skip: F) -> io::Result<()>\n     where\n         F: FnMut(&str) -> bool + 'static;\n \n-    fn build(self);\n+    fn build(self) -> bool;\n \n     fn inject_dll_import_lib(\n         &mut self,"}, {"sha": "edf49b8c80eead216f0b7a214fd984c319a1ffb0", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc80ca78b6ec2b6bba02560470347433bcd0bb3c/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=dc80ca78b6ec2b6bba02560470347433bcd0bb3c", "patch": "@@ -270,7 +270,7 @@ fn link_rlib<'a, B: ArchiveBuilder<'a>>(\n \n     let lib_search_paths = archive_search_paths(sess);\n \n-    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename, None);\n+    let mut ab = <B as ArchiveBuilder>::new(sess, out_filename);\n \n     let trailing_metadata = match flavor {\n         RlibFlavor::Normal => {\n@@ -2466,17 +2466,19 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n         let name = &name[3..name.len() - 5]; // chop off lib/.rlib\n \n         sess.prof.generic_activity_with_arg(\"link_altering_rlib\", name).run(|| {\n-            let mut archive = <B as ArchiveBuilder>::new(sess, &dst, Some(cratepath));\n-\n-            let mut any_objects = false;\n-            for f in archive.src_files() {\n+            let canonical_name = name.replace('-', \"_\");\n+            let upstream_rust_objects_already_included =\n+                are_upstream_rust_objects_already_included(sess);\n+            let is_builtins = sess.target.no_builtins\n+                || !codegen_results.crate_info.is_no_builtins.contains(&cnum);\n+\n+            let mut archive = <B as ArchiveBuilder>::new(sess, &dst);\n+            if let Err(e) = archive.add_archive(cratepath, move |f| {\n                 if f == METADATA_FILENAME {\n-                    archive.remove_file(&f);\n-                    continue;\n+                    return true;\n                 }\n \n                 let canonical = f.replace('-', \"_\");\n-                let canonical_name = name.replace('-', \"_\");\n \n                 let is_rust_object =\n                     canonical.starts_with(&canonical_name) && looks_like_rust_object_file(&f);\n@@ -2490,23 +2492,20 @@ fn add_upstream_rust_crates<'a, B: ArchiveBuilder<'a>>(\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                let skip_because_lto = are_upstream_rust_objects_already_included(sess)\n-                    && is_rust_object\n-                    && (sess.target.no_builtins\n-                        || !codegen_results.crate_info.is_no_builtins.contains(&cnum));\n+                let skip_because_lto =\n+                    upstream_rust_objects_already_included && is_rust_object && is_builtins;\n \n                 if skip_because_cfg_say_so || skip_because_lto {\n-                    archive.remove_file(&f);\n-                } else {\n-                    any_objects = true;\n+                    return true;\n                 }\n-            }\n \n-            if !any_objects {\n-                return;\n+                false\n+            }) {\n+                sess.fatal(&format!(\"failed to build archive from rlib: {}\", e));\n+            }\n+            if archive.build() {\n+                link_upstream(&dst);\n             }\n-            archive.build();\n-            link_upstream(&dst);\n         });\n     }\n "}]}