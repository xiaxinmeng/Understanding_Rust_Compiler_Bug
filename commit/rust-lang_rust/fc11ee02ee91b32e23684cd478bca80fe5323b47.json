{"sha": "fc11ee02ee91b32e23684cd478bca80fe5323b47", "node_id": "C_kwDOAAsO6NoAKGZjMTFlZTAyZWU5MWIzMmUyMzY4NGNkNDc4YmNhODBmZTUzMjNiNDc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T12:10:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-15T12:10:36Z"}, "message": "Auto merge of #106171 - compiler-errors:consolidate-extract_callable_info, r=estebank,lcnr\n\nConsolidate two almost duplicated fn info extraction routines\n\nMoves `extract_callable_info` up to trait selection, because it was being (almost) duplicated fully there for similar diagnostic purposes. This also generalizes the diagnostics we can give slightly (see UI test).", "tree": {"sha": "0c66b87e31438e45c055345e2f62e1e10b2639b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c66b87e31438e45c055345e2f62e1e10b2639b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc11ee02ee91b32e23684cd478bca80fe5323b47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc11ee02ee91b32e23684cd478bca80fe5323b47", "html_url": "https://github.com/rust-lang/rust/commit/fc11ee02ee91b32e23684cd478bca80fe5323b47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc11ee02ee91b32e23684cd478bca80fe5323b47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7", "html_url": "https://github.com/rust-lang/rust/commit/bbb36fe5455ee56cdeec0a5d12015ac7ae77a6a7"}, {"sha": "c1a7dbc0e3511b144f7051a065b9467871ad6ef9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1a7dbc0e3511b144f7051a065b9467871ad6ef9", "html_url": "https://github.com/rust-lang/rust/commit/c1a7dbc0e3511b144f7051a065b9467871ad6ef9"}], "stats": {"total": 368, "additions": 183, "deletions": 185}, "files": [{"sha": "f1a4f94cd0151e9f4c2b30526c2d3e0413bd123e", "filename": "compiler/rustc_hir_typeck/src/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcallee.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -659,8 +659,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-            if let Some((maybe_def, output_ty, _)) =\n-                self.extract_callable_info(callee_expr, callee_ty)\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_ty)\n                 && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n             {\n                 let descr = match maybe_def {"}, {"sha": "76f33be7a389c5bb111778f7964e626aa29b1acf", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 6, "deletions": 97, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -11,7 +11,6 @@ use rustc_hir::{\n     Expr, ExprKind, GenericBound, Node, Path, QPath, Stmt, StmtKind, TyKind, WherePredicate,\n };\n use rustc_hir_analysis::astconv::AstConv;\n-use rustc_infer::infer;\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n@@ -23,9 +22,9 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n+use rustc_trait_selection::traits::error_reporting::suggestions::TypeErrCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n-use rustc_trait_selection::traits::NormalizeExt;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(crate) fn body_fn_sig(&self) -> Option<ty::FnSig<'tcx>> {\n@@ -94,7 +93,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(expr, found)\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(found)\n             else { return false; };\n         if can_satisfy(output) {\n             let (sugg_call, mut applicability) = match inputs.len() {\n@@ -163,99 +162,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// because the callable type must also be well-formed to be called.\n     pub(in super::super) fn extract_callable_info(\n         &self,\n-        expr: &Expr<'_>,\n-        found: Ty<'tcx>,\n+        ty: Ty<'tcx>,\n     ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n-        // Autoderef is useful here because sometimes we box callables, etc.\n-        let Some((def_id_or_name, output, inputs)) = self.autoderef(expr.span, found).silence_errors().find_map(|(found, _)| {\n-            match *found.kind() {\n-                ty::FnPtr(fn_sig) =>\n-                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n-                ty::FnDef(def_id, _) => {\n-                    let fn_sig = found.fn_sig(self.tcx);\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-                }\n-                ty::Closure(def_id, substs) => {\n-                    let fn_sig = substs.as_closure().sig();\n-                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n-                }\n-                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Dynamic(data, _, ty::Dyn) => {\n-                    data.iter().find_map(|pred| {\n-                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                        // for existential projection, substs are shifted over by 1\n-                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::Name(\"trait object\"),\n-                                pred.rebind(proj.term.ty().unwrap()),\n-                                pred.rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                ty::Param(param) => {\n-                    let def_id = self.tcx.generics_of(self.body_id.owner).type_param(&param, self.tcx).def_id;\n-                    self.tcx.predicates_of(self.body_id.owner).predicates.iter().find_map(|(pred, _)| {\n-                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                        && proj.projection_ty.self_ty() == found\n-                        // args tuple will always be substs[1]\n-                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                        {\n-                            Some((\n-                                DefIdOrName::DefId(def_id),\n-                                pred.kind().rebind(proj.term.ty().unwrap()),\n-                                pred.kind().rebind(args.as_slice()),\n-                            ))\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                }\n-                _ => None,\n-            }\n-        }) else { return None; };\n-\n-        let output = self.replace_bound_vars_with_fresh_vars(expr.span, infer::FnCall, output);\n-        let inputs = inputs\n-            .skip_binder()\n-            .iter()\n-            .map(|ty| {\n-                self.replace_bound_vars_with_fresh_vars(\n-                    expr.span,\n-                    infer::FnCall,\n-                    inputs.rebind(*ty),\n-                )\n-            })\n-            .collect();\n-\n-        // We don't want to register any extra obligations, which should be\n-        // implied by wf, but also because that would possibly result in\n-        // erroneous errors later on.\n-        let infer::InferOk { value: output, obligations: _ } =\n-            self.at(&self.misc(expr.span), self.param_env).normalize(output);\n-\n-        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+        self.err_ctxt().extract_callable_info(self.body_id, self.param_env, ty)\n     }\n \n     pub fn suggest_two_fn_call(\n@@ -267,9 +176,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rhs_ty: Ty<'tcx>,\n         can_satisfy: impl FnOnce(Ty<'tcx>, Ty<'tcx>) -> bool,\n     ) -> bool {\n-        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_expr, lhs_ty)\n+        let Some((_, lhs_output_ty, lhs_inputs)) = self.extract_callable_info(lhs_ty)\n             else { return false; };\n-        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_expr, rhs_ty)\n+        let Some((_, rhs_output_ty, rhs_inputs)) = self.extract_callable_info(rhs_ty)\n             else { return false; };\n \n         if can_satisfy(lhs_output_ty, rhs_output_ty) {"}, {"sha": "2e1fc4c38b542d5cae2f9e6b281fd652f8c409ec", "filename": "compiler/rustc_hir_typeck/src/method/suggest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fsuggest.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -2700,8 +2700,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         found: Ty<'tcx>,\n         expected: Ty<'tcx>,\n     ) -> bool {\n-        let Some((_def_id_or_name, output, _inputs)) = self.extract_callable_info(expr, found)\n-        else { return false; };\n+        let Some((_def_id_or_name, output, _inputs)) =\n+            self.extract_callable_info(found) else {\n+                return false;\n+        };\n \n         if !self.can_coerce(output, expected) {\n             return false;"}, {"sha": "edd187b8dec3b1469a14125c01ad4845f6e0bade", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -2937,6 +2937,7 @@ impl<'tcx> ty::TypeVisitor<'tcx> for HasNumericInferVisitor {\n     }\n }\n \n+#[derive(Copy, Clone)]\n pub enum DefIdOrName {\n     DefId(DefId),\n     Name(&'static str),"}, {"sha": "5211f873a1e3b845e62c6f0b26fb4d1c091685a1", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 137, "deletions": 84, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -212,6 +212,13 @@ pub trait TypeErrCtxtExt<'tcx> {\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)>;\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n@@ -878,99 +885,30 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         err: &mut Diagnostic,\n         trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n+        // It doesn't make sense to make this suggestion outside of typeck...\n+        // (also autoderef will ICE...)\n+        if self.typeck_results.is_none() {\n+            return false;\n+        }\n+\n         if let ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) = obligation.predicate.kind().skip_binder()\n             && Some(trait_pred.def_id()) == self.tcx.lang_items().sized_trait()\n         {\n             // Don't suggest calling to turn an unsized type into a sized type\n             return false;\n         }\n \n-        // This is duplicated from `extract_callable_info` in typeck, which\n-        // relies on autoderef, so we can't use it here.\n-        let found = trait_pred.self_ty().skip_binder().peel_refs();\n-        let Some((def_id_or_name, output, inputs)) = (match *found.kind()\n-        {\n-            ty::FnPtr(fn_sig) => {\n-                Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::FnDef(def_id, _) => {\n-                let fn_sig = found.fn_sig(self.tcx);\n-                Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n-            }\n-            ty::Closure(def_id, substs) => {\n-                let fn_sig = substs.as_closure().sig();\n-                Some((\n-                    DefIdOrName::DefId(def_id),\n-                    fn_sig.output(),\n-                    fn_sig.inputs().map_bound(|inputs| &inputs[1..]),\n-                ))\n-            }\n-            ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n-                self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::DefId(def_id),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Dynamic(data, _, ty::Dyn) => {\n-                data.iter().find_map(|pred| {\n-                    if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n-                    && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n-                    // for existential projection, substs are shifted over by 1\n-                    && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"trait object\"),\n-                            pred.rebind(proj.term.ty().unwrap()),\n-                            pred.rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            ty::Param(_) => {\n-                obligation.param_env.caller_bounds().iter().find_map(|pred| {\n-                    if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n-                    && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n-                    && proj.projection_ty.self_ty() == found\n-                    // args tuple will always be substs[1]\n-                    && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n-                    {\n-                        Some((\n-                            DefIdOrName::Name(\"type parameter\"),\n-                            pred.kind().rebind(proj.term.ty().unwrap()),\n-                            pred.kind().rebind(args.as_slice()),\n-                        ))\n-                    } else {\n-                        None\n-                    }\n-                })\n-            }\n-            _ => None,\n-        }) else { return false; };\n-        let output = self.replace_bound_vars_with_fresh_vars(\n-            obligation.cause.span,\n+        let self_ty = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n             LateBoundRegionConversionTime::FnCall,\n-            output,\n+            trait_pred.self_ty(),\n         );\n-        let inputs = inputs.skip_binder().iter().map(|ty| {\n-            self.replace_bound_vars_with_fresh_vars(\n-                obligation.cause.span,\n-                LateBoundRegionConversionTime::FnCall,\n-                inputs.rebind(*ty),\n-            )\n-        });\n+\n+        let Some((def_id_or_name, output, inputs)) = self.extract_callable_info(\n+            obligation.cause.body_id,\n+            obligation.param_env,\n+            self_ty,\n+        ) else { return false; };\n \n         // Remapping bound vars here\n         let trait_pred_and_self = trait_pred.map_bound(|trait_pred| (trait_pred, output));\n@@ -998,6 +936,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         };\n \n         let args = inputs\n+            .into_iter()\n             .map(|ty| {\n                 if ty.is_suggestable(self.tcx, false) {\n                     format!(\"/* {ty} */\")\n@@ -1161,6 +1100,120 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         false\n     }\n \n+    /// Extracts information about a callable type for diagnostics. This is a\n+    /// heuristic -- it doesn't necessarily mean that a type is always callable,\n+    /// because the callable type must also be well-formed to be called.\n+    fn extract_callable_info(\n+        &self,\n+        hir_id: HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> Option<(DefIdOrName, Ty<'tcx>, Vec<Ty<'tcx>>)> {\n+        // Autoderef is useful here because sometimes we box callables, etc.\n+        let Some((def_id_or_name, output, inputs)) = (self.autoderef_steps)(found).into_iter().find_map(|(found, _)| {\n+            match *found.kind() {\n+                ty::FnPtr(fn_sig) =>\n+                    Some((DefIdOrName::Name(\"function pointer\"), fn_sig.output(), fn_sig.inputs())),\n+                ty::FnDef(def_id, _) => {\n+                    let fn_sig = found.fn_sig(self.tcx);\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs()))\n+                }\n+                ty::Closure(def_id, substs) => {\n+                    let fn_sig = substs.as_closure().sig();\n+                    Some((DefIdOrName::DefId(def_id), fn_sig.output(), fn_sig.inputs().map_bound(|inputs| &inputs[1..])))\n+                }\n+                ty::Alias(ty::Opaque, ty::AliasTy { def_id, substs, .. }) => {\n+                    self.tcx.bound_item_bounds(def_id).subst(self.tcx, substs).iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::DefId(def_id),\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Dynamic(data, _, ty::Dyn) => {\n+                    data.iter().find_map(|pred| {\n+                        if let ty::ExistentialPredicate::Projection(proj) = pred.skip_binder()\n+                        && Some(proj.def_id) == self.tcx.lang_items().fn_once_output()\n+                        // for existential projection, substs are shifted over by 1\n+                        && let ty::Tuple(args) = proj.substs.type_at(0).kind()\n+                        {\n+                            Some((\n+                                DefIdOrName::Name(\"trait object\"),\n+                                pred.rebind(proj.term.ty().unwrap()),\n+                                pred.rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                ty::Param(param) => {\n+                    let generics = self.tcx.generics_of(hir_id.owner.to_def_id());\n+                    let name = if generics.count() > param.index as usize\n+                        && let def = generics.param_at(param.index as usize, self.tcx)\n+                        && matches!(def.kind, ty::GenericParamDefKind::Type { .. })\n+                        && def.name == param.name\n+                    {\n+                        DefIdOrName::DefId(def.def_id)\n+                    } else {\n+                        DefIdOrName::Name(\"type parameter\")\n+                    };\n+                    param_env.caller_bounds().iter().find_map(|pred| {\n+                        if let ty::PredicateKind::Clause(ty::Clause::Projection(proj)) = pred.kind().skip_binder()\n+                        && Some(proj.projection_ty.def_id) == self.tcx.lang_items().fn_once_output()\n+                        && proj.projection_ty.self_ty() == found\n+                        // args tuple will always be substs[1]\n+                        && let ty::Tuple(args) = proj.projection_ty.substs.type_at(1).kind()\n+                        {\n+                            Some((\n+                                name,\n+                                pred.kind().rebind(proj.term.ty().unwrap()),\n+                                pred.kind().rebind(args.as_slice()),\n+                            ))\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                }\n+                _ => None,\n+            }\n+        }) else { return None; };\n+\n+        let output = self.replace_bound_vars_with_fresh_vars(\n+            DUMMY_SP,\n+            LateBoundRegionConversionTime::FnCall,\n+            output,\n+        );\n+        let inputs = inputs\n+            .skip_binder()\n+            .iter()\n+            .map(|ty| {\n+                self.replace_bound_vars_with_fresh_vars(\n+                    DUMMY_SP,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    inputs.rebind(*ty),\n+                )\n+            })\n+            .collect();\n+\n+        // We don't want to register any extra obligations, which should be\n+        // implied by wf, but also because that would possibly result in\n+        // erroneous errors later on.\n+        let InferOk { value: output, obligations: _ } =\n+            self.at(&ObligationCause::dummy(), param_env).normalize(output);\n+\n+        if output.is_ty_var() { None } else { Some((def_id_or_name, output, inputs)) }\n+    }\n+\n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,"}, {"sha": "9021dd752e7e9525c3e6bc8489827d601895acf0", "filename": "tests/ui/suggestions/call-on-unimplemented-with-autoderef.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.rs?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -0,0 +1,13 @@\n+trait Foo {}\n+\n+impl Foo for i32 {}\n+\n+fn needs_foo(_: impl Foo) {}\n+\n+fn test(x: &Box<dyn Fn() -> i32>) {\n+    needs_foo(x);\n+    //~^ ERROR the trait bound\n+    //~| HELP use parentheses to call this trait object\n+}\n+\n+fn main() {}"}, {"sha": "90f44cce06e440a1744d2e508201e2459f391af3", "filename": "tests/ui/suggestions/call-on-unimplemented-with-autoderef.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fc11ee02ee91b32e23684cd478bca80fe5323b47/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fc11ee02ee91b32e23684cd478bca80fe5323b47/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fcall-on-unimplemented-with-autoderef.stderr?ref=fc11ee02ee91b32e23684cd478bca80fe5323b47", "patch": "@@ -0,0 +1,21 @@\n+error[E0277]: the trait bound `&Box<dyn Fn() -> i32>: Foo` is not satisfied\n+  --> $DIR/call-on-unimplemented-with-autoderef.rs:8:15\n+   |\n+LL |     needs_foo(x);\n+   |     --------- ^ the trait `Foo` is not implemented for `&Box<dyn Fn() -> i32>`\n+   |     |\n+   |     required by a bound introduced by this call\n+   |\n+note: required by a bound in `needs_foo`\n+  --> $DIR/call-on-unimplemented-with-autoderef.rs:5:22\n+   |\n+LL | fn needs_foo(_: impl Foo) {}\n+   |                      ^^^ required by this bound in `needs_foo`\n+help: use parentheses to call this trait object\n+   |\n+LL |     needs_foo(x());\n+   |                ++\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}]}