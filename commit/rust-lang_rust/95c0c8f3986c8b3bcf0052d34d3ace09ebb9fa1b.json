{"sha": "95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1YzBjOGYzOTg2YzhiM2JjZjAwNTJkMzRkM2FjZTA5ZWJiOWZhMWI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-28T01:10:58Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-28T01:10:58Z"}, "message": "Merge #247\n\n247: Hir r=matklad a=matklad\n\nThis doesn't achive anything new, just a big refactoring. \r\n\r\nThe main change is that Descriptors are now called `hir`, and live in a separate crate.\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0e5aa7337c000dd8c6ef3a7fedba68abf7feca8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e5aa7337c000dd8c6ef3a7fedba68abf7feca8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "html_url": "https://github.com/rust-lang/rust/commit/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9f08341aa486ea59cb488635f19e960523568fb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f08341aa486ea59cb488635f19e960523568fb8", "html_url": "https://github.com/rust-lang/rust/commit/9f08341aa486ea59cb488635f19e960523568fb8"}, {"sha": "59e29aef633e906837f8fed604435976a46be691", "url": "https://api.github.com/repos/rust-lang/rust/commits/59e29aef633e906837f8fed604435976a46be691", "html_url": "https://github.com/rust-lang/rust/commit/59e29aef633e906837f8fed604435976a46be691"}], "stats": {"total": 2309, "additions": 1249, "deletions": 1060}, "files": [{"sha": "bacea8dc3efefa74d37f4a9e4154ac6a15d63d19", "filename": "Cargo.lock", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -604,10 +604,11 @@ name = \"ra_analysis\"\n version = \"0.1.0\"\n dependencies = [\n  \"fst 0.3.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"id-arena 1.0.2 (git+https://github.com/fitzgen/id-arena/?rev=43ecd67)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_db 0.1.0\",\n  \"ra_editor 0.1.0\",\n+ \"ra_hir 0.1.0\",\n  \"ra_syntax 0.1.0\",\n  \"rayon 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -628,6 +629,21 @@ dependencies = [\n  \"tools 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_db\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"id-arena 1.0.2 (git+https://github.com/fitzgen/id-arena/?rev=43ecd67)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_editor 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_editor\"\n version = \"0.1.0\"\n@@ -640,6 +656,22 @@ dependencies = [\n  \"test_utils 0.1.0\",\n ]\n \n+[[package]]\n+name = \"ra_hir\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"id-arena 1.0.2 (git+https://github.com/fitzgen/id-arena/?rev=43ecd67)\",\n+ \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"ra_db 0.1.0\",\n+ \"ra_editor 0.1.0\",\n+ \"ra_syntax 0.1.0\",\n+ \"relative-path 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"salsa 0.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"test_utils 0.1.0\",\n+]\n+\n [[package]]\n name = \"ra_lsp_server\"\n version = \"0.1.0\""}, {"sha": "fe9765a666811dae1f901c2930bb0996466d1b4d", "filename": "crates/ra_analysis/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2FCargo.toml?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -12,7 +12,8 @@ fst = \"0.3.1\"\n salsa = \"0.8.0\"\n rustc-hash = \"1.0\"\n parking_lot = \"0.6.4\"\n-id-arena = { git = \"https://github.com/fitzgen/id-arena/\", rev = \"43ecd67\" }\n ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n+ra_db = { path = \"../ra_db\" }\n+hir = { path = \"../ra_hir\", package = \"ra_hir\" }\n test_utils = { path = \"../test_utils\" }"}, {"sha": "e5ba92acdea2fb61531ddfe092e2f8d7a19d93aa", "filename": "crates/ra_analysis/src/completion/mod.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fmod.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -7,13 +7,11 @@ use ra_syntax::{\n     AstNode, AtomEdit,\n     SyntaxNodeRef,\n };\n+use ra_db::SyntaxDatabase;\n use rustc_hash::{FxHashMap};\n \n use crate::{\n-    db::{self, SyntaxDatabase},\n-    descriptors::{\n-        module::{ModuleDescriptor}\n-    },\n+    db,\n     Cancelable, FilePosition\n };\n \n@@ -31,14 +29,14 @@ pub(crate) fn completions(\n     db: &db::RootDatabase,\n     position: FilePosition,\n ) -> Cancelable<Option<Vec<CompletionItem>>> {\n-    let original_file = db.file_syntax(position.file_id);\n+    let original_file = db.source_file(position.file_id);\n     // Insert a fake ident to get a valid parse tree\n     let file = {\n         let edit = AtomEdit::insert(position.offset, \"intellijRulezz\".to_string());\n         original_file.reparse(&edit)\n     };\n \n-    let module = ctry!(ModuleDescriptor::guess_from_position(db, position)?);\n+    let module = ctry!(hir::Module::guess_from_position(db, position)?);\n \n     let mut res = Vec::new();\n     let mut has_completions = false;"}, {"sha": "e1a2d52410d99127c4330dd56c69581ee67e4081", "filename": "crates/ra_analysis/src/completion/reference_completion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Freference_completion.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -6,23 +6,23 @@ use ra_syntax::{\n     ast::{self, LoopBodyOwner},\n     SyntaxKind::*,\n };\n+use     hir::{\n+        self,\n+        FnScopes,\n+        Def,\n+        Path,\n+};\n \n use crate::{\n     db::RootDatabase,\n     completion::CompletionItem,\n-    descriptors::{\n-        module::{ModuleDescriptor},\n-        function::FnScopes,\n-        Def,\n-        Path,\n-    },\n     Cancelable\n };\n \n pub(super) fn completions(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    module: &ModuleDescriptor,\n+    module: &hir::Module,\n     file: &SourceFileNode,\n     name_ref: ast::NameRef,\n ) -> Cancelable<()> {\n@@ -150,7 +150,7 @@ fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<Completi\n fn complete_path(\n     acc: &mut Vec<CompletionItem>,\n     db: &RootDatabase,\n-    module: &ModuleDescriptor,\n+    module: &hir::Module,\n     mut path: Path,\n ) -> Cancelable<()> {\n     if path.segments.is_empty() {"}, {"sha": "7fc3fe31badfda1aa96e37b5246bcab4253ef371", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 47, "deletions": 79, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,17 +1,12 @@\n use std::sync::Arc;\n #[cfg(test)]\n use parking_lot::Mutex;\n-use ra_editor::LineIndex;\n-use ra_syntax::{SourceFileNode, SyntaxNode};\n use salsa::{self, Database};\n+use ra_db::{LocationIntener, BaseDatabase};\n+use hir::{self, DefId, DefLoc, FnId, SourceItemId};\n \n use crate::{\n-    db,\n-    descriptors,\n-    symbol_index::SymbolIndex,\n-    syntax_ptr::SyntaxPtr,\n-    loc2id::{IdMaps, IdDatabase},\n-    Cancelable, Canceled, FileId,\n+    symbol_index,\n };\n \n #[derive(Debug)]\n@@ -22,7 +17,13 @@ pub(crate) struct RootDatabase {\n     events: (),\n \n     runtime: salsa::Runtime<RootDatabase>,\n-    id_maps: IdMaps,\n+    id_maps: Arc<IdMaps>,\n+}\n+\n+#[derive(Debug, Default)]\n+struct IdMaps {\n+    fns: LocationIntener<SourceItemId, FnId>,\n+    defs: LocationIntener<DefLoc, DefId>,\n }\n \n impl salsa::Database for RootDatabase {\n@@ -47,26 +48,18 @@ impl Default for RootDatabase {\n         let mut db = RootDatabase {\n             events: Default::default(),\n             runtime: salsa::Runtime::default(),\n-            id_maps: IdMaps::default(),\n+            id_maps: Default::default(),\n         };\n-        db.query_mut(crate::input::SourceRootQuery)\n-            .set(crate::input::WORKSPACE, Default::default());\n-        db.query_mut(crate::input::CrateGraphQuery)\n+        db.query_mut(ra_db::SourceRootQuery)\n+            .set(ra_db::WORKSPACE, Default::default());\n+        db.query_mut(ra_db::CrateGraphQuery)\n             .set((), Default::default());\n-        db.query_mut(crate::input::LibrariesQuery)\n+        db.query_mut(ra_db::LibrariesQuery)\n             .set((), Default::default());\n         db\n     }\n }\n \n-pub(crate) fn check_canceled(db: &impl salsa::Database) -> Cancelable<()> {\n-    if db.salsa_runtime().is_current_revision_canceled() {\n-        Err(Canceled)\n-    } else {\n-        Ok(())\n-    }\n-}\n-\n impl salsa::ParallelDatabase for RootDatabase {\n     fn snapshot(&self) -> salsa::Snapshot<RootDatabase> {\n         salsa::Snapshot::new(RootDatabase {\n@@ -77,9 +70,17 @@ impl salsa::ParallelDatabase for RootDatabase {\n     }\n }\n \n-impl IdDatabase for RootDatabase {\n-    fn id_maps(&self) -> &IdMaps {\n-        &self.id_maps\n+impl BaseDatabase for RootDatabase {}\n+\n+impl AsRef<LocationIntener<DefLoc, DefId>> for RootDatabase {\n+    fn as_ref(&self) -> &LocationIntener<DefLoc, DefId> {\n+        &self.id_maps.defs\n+    }\n+}\n+\n+impl AsRef<LocationIntener<hir::SourceItemId, FnId>> for RootDatabase {\n+    fn as_ref(&self) -> &LocationIntener<hir::SourceItemId, FnId> {\n+        &self.id_maps.fns\n     }\n }\n \n@@ -108,63 +109,30 @@ impl RootDatabase {\n \n salsa::database_storage! {\n     pub(crate) struct RootDatabaseStorage for RootDatabase {\n-        impl crate::input::FilesDatabase {\n-            fn file_text() for crate::input::FileTextQuery;\n-            fn file_source_root() for crate::input::FileSourceRootQuery;\n-            fn source_root() for crate::input::SourceRootQuery;\n-            fn libraries() for crate::input::LibrariesQuery;\n-            fn library_symbols() for crate::input::LibrarySymbolsQuery;\n-            fn crate_graph() for crate::input::CrateGraphQuery;\n+        impl ra_db::FilesDatabase {\n+            fn file_text() for ra_db::FileTextQuery;\n+            fn file_source_root() for ra_db::FileSourceRootQuery;\n+            fn source_root() for ra_db::SourceRootQuery;\n+            fn libraries() for ra_db::LibrariesQuery;\n+            fn crate_graph() for ra_db::CrateGraphQuery;\n         }\n-        impl SyntaxDatabase {\n-            fn file_syntax() for FileSyntaxQuery;\n-            fn file_lines() for FileLinesQuery;\n-            fn file_symbols() for FileSymbolsQuery;\n-            fn resolve_syntax_ptr() for ResolveSyntaxPtrQuery;\n+        impl ra_db::SyntaxDatabase {\n+            fn source_file() for ra_db::SourceFileQuery;\n+            fn file_lines() for ra_db::FileLinesQuery;\n         }\n-        impl descriptors::DescriptorDatabase {\n-            fn module_tree() for descriptors::ModuleTreeQuery;\n-            fn fn_scopes() for descriptors::FnScopesQuery;\n-            fn _file_items() for descriptors::FileItemsQuery;\n-            fn _file_item() for descriptors::FileItemQuery;\n-            fn _input_module_items() for descriptors::InputModuleItemsQuery;\n-            fn _item_map() for descriptors::ItemMapQuery;\n-            fn _fn_syntax() for descriptors::FnSyntaxQuery;\n-            fn _submodules() for descriptors::SubmodulesQuery;\n+        impl symbol_index::SymbolsDatabase {\n+            fn file_symbols() for symbol_index::FileSymbolsQuery;\n+            fn library_symbols() for symbol_index::LibrarySymbolsQuery;\n         }\n-    }\n-}\n-\n-salsa::query_group! {\n-    pub(crate) trait SyntaxDatabase: crate::input::FilesDatabase {\n-        fn file_syntax(file_id: FileId) -> SourceFileNode {\n-            type FileSyntaxQuery;\n-        }\n-        fn file_lines(file_id: FileId) -> Arc<LineIndex> {\n-            type FileLinesQuery;\n-        }\n-        fn file_symbols(file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n-            type FileSymbolsQuery;\n-        }\n-        fn resolve_syntax_ptr(ptr: SyntaxPtr) -> SyntaxNode {\n-            type ResolveSyntaxPtrQuery;\n-            // Don't retain syntax trees in memory\n-            storage dependencies;\n-            use fn crate::syntax_ptr::resolve_syntax_ptr;\n+        impl hir::db::HirDatabase {\n+            fn module_tree() for hir::db::ModuleTreeQuery;\n+            fn fn_scopes() for hir::db::FnScopesQuery;\n+            fn file_items() for hir::db::SourceFileItemsQuery;\n+            fn file_item() for hir::db::FileItemQuery;\n+            fn input_module_items() for hir::db::InputModuleItemsQuery;\n+            fn item_map() for hir::db::ItemMapQuery;\n+            fn fn_syntax() for hir::db::FnSyntaxQuery;\n+            fn submodules() for hir::db::SubmodulesQuery;\n         }\n     }\n }\n-\n-fn file_syntax(db: &impl SyntaxDatabase, file_id: FileId) -> SourceFileNode {\n-    let text = db.file_text(file_id);\n-    SourceFileNode::parse(&*text)\n-}\n-fn file_lines(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<LineIndex> {\n-    let text = db.file_text(file_id);\n-    Arc::new(LineIndex::new(&*text))\n-}\n-fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n-    db::check_canceled(db)?;\n-    let syntax = db.file_syntax(file_id);\n-    Ok(Arc::new(SymbolIndex::for_file(file_id, syntax)))\n-}"}, {"sha": "e09deba0f3563f826f393e8d234e6d50422cb268", "filename": "crates/ra_analysis/src/descriptors/function/imp.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Ffunction%2Fimp.rs?ref=9f08341aa486ea59cb488635f19e960523568fb8", "patch": "@@ -1,21 +0,0 @@\n-use std::sync::Arc;\n-\n-use ra_syntax::ast::{AstNode, FnDef, FnDefNode};\n-\n-use crate::descriptors::{\n-    function::{FnId, FnScopes},\n-    DescriptorDatabase,\n-};\n-\n-/// Resolve `FnId` to the corresponding `SyntaxNode`\n-pub(crate) fn fn_syntax(db: &impl DescriptorDatabase, fn_id: FnId) -> FnDefNode {\n-    let ptr = db.id_maps().fn_ptr(fn_id);\n-    let syntax = db.resolve_syntax_ptr(ptr);\n-    FnDef::cast(syntax.borrowed()).unwrap().owned()\n-}\n-\n-pub(crate) fn fn_scopes(db: &impl DescriptorDatabase, fn_id: FnId) -> Arc<FnScopes> {\n-    let syntax = db._fn_syntax(fn_id);\n-    let res = FnScopes::new(syntax.borrowed());\n-    Arc::new(res)\n-}"}, {"sha": "7a1bcf4475899ec9edd03c651ef4cc081f2165c1", "filename": "crates/ra_analysis/src/descriptors/mod.rs", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmod.rs?ref=9f08341aa486ea59cb488635f19e960523568fb8", "patch": "@@ -1,137 +0,0 @@\n-pub(crate) mod function;\n-pub(crate) mod module;\n-mod path;\n-\n-use std::sync::Arc;\n-\n-use ra_syntax::{\n-    ast::{self, FnDefNode, AstNode},\n-    TextRange, SyntaxNode,\n-};\n-\n-use crate::{\n-    FileId,\n-    db::SyntaxDatabase,\n-    descriptors::function::{resolve_local_name, FnId, FnScopes},\n-    descriptors::module::{\n-        ModuleId, ModuleTree, ModuleSource, ModuleDescriptor,\n-        nameres::{ItemMap, InputModuleItems, FileItems}\n-    },\n-    input::SourceRootId,\n-    loc2id::{IdDatabase, DefId, DefLoc},\n-    syntax_ptr::LocalSyntaxPtr,\n-    Cancelable,\n-};\n-\n-pub(crate) use self::path::{Path, PathKind};\n-pub(crate) use self::module::nameres::FileItemId;\n-\n-salsa::query_group! {\n-    pub(crate) trait DescriptorDatabase: SyntaxDatabase + IdDatabase {\n-        fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n-            type FnScopesQuery;\n-            use fn function::imp::fn_scopes;\n-        }\n-\n-        fn _file_items(file_id: FileId) -> Arc<FileItems> {\n-            type FileItemsQuery;\n-            storage dependencies;\n-            use fn module::nameres::file_items;\n-        }\n-\n-        fn _file_item(file_id: FileId, file_item_id: FileItemId) -> SyntaxNode {\n-            type FileItemQuery;\n-            storage dependencies;\n-            use fn module::nameres::file_item;\n-        }\n-\n-        fn _input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n-            type InputModuleItemsQuery;\n-            use fn module::nameres::input_module_items;\n-        }\n-        fn _item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n-            type ItemMapQuery;\n-            use fn module::nameres::item_map;\n-        }\n-        fn _module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n-            type ModuleTreeQuery;\n-            use fn module::imp::module_tree;\n-        }\n-        fn _fn_syntax(fn_id: FnId) -> FnDefNode {\n-            type FnSyntaxQuery;\n-            // Don't retain syntax trees in memory\n-            storage dependencies;\n-            use fn function::imp::fn_syntax;\n-        }\n-        fn _submodules(source: ModuleSource) -> Cancelable<Arc<Vec<module::imp::Submodule>>> {\n-            type SubmodulesQuery;\n-            use fn module::imp::submodules;\n-        }\n-    }\n-}\n-\n-pub(crate) enum Def {\n-    Module(ModuleDescriptor),\n-    Item,\n-}\n-\n-impl DefId {\n-    pub(crate) fn resolve(self, db: &impl DescriptorDatabase) -> Cancelable<Def> {\n-        let loc = db.id_maps().def_loc(self);\n-        let res = match loc {\n-            DefLoc::Module { id, source_root } => {\n-                let descr = ModuleDescriptor::new(db, source_root, id)?;\n-                Def::Module(descr)\n-            }\n-            DefLoc::Item { .. } => Def::Item,\n-        };\n-        Ok(res)\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct ReferenceDescriptor {\n-    pub range: TextRange,\n-    pub name: String,\n-}\n-\n-#[derive(Debug)]\n-pub struct DeclarationDescriptor<'a> {\n-    pat: ast::BindPat<'a>,\n-    pub range: TextRange,\n-}\n-\n-impl<'a> DeclarationDescriptor<'a> {\n-    pub fn new(pat: ast::BindPat) -> DeclarationDescriptor {\n-        let range = pat.syntax().range();\n-\n-        DeclarationDescriptor { pat, range }\n-    }\n-\n-    pub fn find_all_refs(&self) -> Vec<ReferenceDescriptor> {\n-        let name_ptr = LocalSyntaxPtr::new(self.pat.syntax());\n-\n-        let fn_def = match self.pat.syntax().ancestors().find_map(ast::FnDef::cast) {\n-            Some(def) => def,\n-            None => return Default::default(),\n-        };\n-\n-        let fn_scopes = FnScopes::new(fn_def);\n-\n-        let refs: Vec<_> = fn_def\n-            .syntax()\n-            .descendants()\n-            .filter_map(ast::NameRef::cast)\n-            .filter(|name_ref| match resolve_local_name(*name_ref, &fn_scopes) {\n-                None => false,\n-                Some(entry) => entry.ptr() == name_ptr,\n-            })\n-            .map(|name_ref| ReferenceDescriptor {\n-                name: name_ref.syntax().text().to_string(),\n-                range: name_ref.syntax().range(),\n-            })\n-            .collect();\n-\n-        refs\n-    }\n-}"}, {"sha": "f5cb3550e640b15a393dae997568e7821543648c", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 84, "deletions": 154, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,94 +1,33 @@\n use std::{\n     fmt,\n-    hash::{Hash, Hasher},\n     sync::Arc,\n };\n \n use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n     ast::{self, ArgListOwner, Expr, NameOwner},\n-    AstNode, SourceFileNode, SmolStr,\n+    AstNode, SourceFileNode,\n     SyntaxKind::*,\n     SyntaxNodeRef, TextRange, TextUnit,\n };\n+use ra_db::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE, SyntaxDatabase, SourceFileQuery};\n use rayon::prelude::*;\n-use relative_path::RelativePath;\n use rustc_hash::FxHashSet;\n use salsa::{Database, ParallelDatabase};\n+use hir::{\n+    self,\n+    FnSignatureInfo,\n+    Problem,\n+};\n \n use crate::{\n     completion::{completions, CompletionItem},\n-    db::{self, FileSyntaxQuery, SyntaxDatabase},\n-    descriptors::{\n-        function::{FnDescriptor, FnId},\n-        module::{ModuleDescriptor, Problem},\n-        DeclarationDescriptor, DescriptorDatabase,\n-    },\n-    input::{FilesDatabase, SourceRoot, SourceRootId, WORKSPACE},\n-    symbol_index::SymbolIndex,\n-    AnalysisChange, Cancelable, CrateGraph, CrateId, Diagnostic, FileId, FileResolver,\n+    db,\n+    symbol_index::{SymbolIndex, SymbolsDatabase},\n+    AnalysisChange, Cancelable, CrateId, Diagnostic, FileId,\n     FileSystemEdit, FilePosition, Query, SourceChange, SourceFileNodeEdit,\n };\n \n-#[derive(Clone, Debug)]\n-pub(crate) struct FileResolverImp {\n-    inner: Arc<FileResolver>,\n-}\n-\n-impl PartialEq for FileResolverImp {\n-    fn eq(&self, other: &FileResolverImp) -> bool {\n-        self.inner() == other.inner()\n-    }\n-}\n-\n-impl Eq for FileResolverImp {}\n-\n-impl Hash for FileResolverImp {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        self.inner().hash(hasher);\n-    }\n-}\n-\n-impl FileResolverImp {\n-    pub(crate) fn new(inner: Arc<FileResolver>) -> FileResolverImp {\n-        FileResolverImp { inner }\n-    }\n-    pub(crate) fn file_stem(&self, file_id: FileId) -> String {\n-        self.inner.file_stem(file_id)\n-    }\n-    pub(crate) fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n-        self.inner.resolve(file_id, path)\n-    }\n-    pub(crate) fn debug_path(&self, file_id: FileId) -> Option<std::path::PathBuf> {\n-        self.inner.debug_path(file_id)\n-    }\n-    fn inner(&self) -> *const FileResolver {\n-        &*self.inner\n-    }\n-}\n-\n-impl Default for FileResolverImp {\n-    fn default() -> FileResolverImp {\n-        #[derive(Debug)]\n-        struct DummyResolver;\n-        impl FileResolver for DummyResolver {\n-            fn file_stem(&self, _file_: FileId) -> String {\n-                panic!(\"file resolver not set\")\n-            }\n-            fn resolve(\n-                &self,\n-                _file_id: FileId,\n-                _path: &::relative_path::RelativePath,\n-            ) -> Option<FileId> {\n-                panic!(\"file resolver not set\")\n-            }\n-        }\n-        FileResolverImp {\n-            inner: Arc::new(DummyResolver),\n-        }\n-    }\n-}\n-\n #[derive(Debug, Default)]\n pub(crate) struct AnalysisHostImpl {\n     db: db::RootDatabase,\n@@ -105,7 +44,7 @@ impl AnalysisHostImpl {\n \n         for (file_id, text) in change.files_changed {\n             self.db\n-                .query_mut(crate::input::FileTextQuery)\n+                .query_mut(ra_db::FileTextQuery)\n                 .set(file_id, Arc::new(text))\n         }\n         if !(change.files_added.is_empty() && change.files_removed.is_empty()) {\n@@ -115,22 +54,22 @@ impl AnalysisHostImpl {\n             let mut source_root = SourceRoot::clone(&self.db.source_root(WORKSPACE));\n             for (file_id, text) in change.files_added {\n                 self.db\n-                    .query_mut(crate::input::FileTextQuery)\n+                    .query_mut(ra_db::FileTextQuery)\n                     .set(file_id, Arc::new(text));\n                 self.db\n-                    .query_mut(crate::input::FileSourceRootQuery)\n-                    .set(file_id, crate::input::WORKSPACE);\n+                    .query_mut(ra_db::FileSourceRootQuery)\n+                    .set(file_id, ra_db::WORKSPACE);\n                 source_root.files.insert(file_id);\n             }\n             for file_id in change.files_removed {\n                 self.db\n-                    .query_mut(crate::input::FileTextQuery)\n+                    .query_mut(ra_db::FileTextQuery)\n                     .set(file_id, Arc::new(String::new()));\n                 source_root.files.remove(&file_id);\n             }\n             source_root.file_resolver = file_resolver;\n             self.db\n-                .query_mut(crate::input::SourceRootQuery)\n+                .query_mut(ra_db::SourceRootQuery)\n                 .set(WORKSPACE, Arc::new(source_root))\n         }\n         if !change.libraries_added.is_empty() {\n@@ -147,30 +86,30 @@ impl AnalysisHostImpl {\n                         library.file_resolver.debug_path(file_id)\n                     );\n                     self.db\n-                        .query_mut(crate::input::FileSourceRootQuery)\n+                        .query_mut(ra_db::FileSourceRootQuery)\n                         .set_constant(file_id, source_root_id);\n                     self.db\n-                        .query_mut(crate::input::FileTextQuery)\n+                        .query_mut(ra_db::FileTextQuery)\n                         .set_constant(file_id, Arc::new(text));\n                 }\n                 let source_root = SourceRoot {\n                     files,\n                     file_resolver: library.file_resolver,\n                 };\n                 self.db\n-                    .query_mut(crate::input::SourceRootQuery)\n+                    .query_mut(ra_db::SourceRootQuery)\n                     .set(source_root_id, Arc::new(source_root));\n                 self.db\n-                    .query_mut(crate::input::LibrarySymbolsQuery)\n+                    .query_mut(crate::symbol_index::LibrarySymbolsQuery)\n                     .set(source_root_id, Arc::new(library.symbol_index));\n             }\n             self.db\n-                .query_mut(crate::input::LibrariesQuery)\n+                .query_mut(ra_db::LibrariesQuery)\n                 .set((), Arc::new(libraries));\n         }\n         if let Some(crate_graph) = change.crate_graph {\n             self.db\n-                .query_mut(crate::input::CrateGraphQuery)\n+                .query_mut(ra_db::CrateGraphQuery)\n                 .set((), Arc::new(crate_graph))\n         }\n     }\n@@ -189,7 +128,7 @@ impl fmt::Debug for AnalysisImpl {\n \n impl AnalysisImpl {\n     pub fn file_syntax(&self, file_id: FileId) -> SourceFileNode {\n-        self.db.file_syntax(file_id)\n+        self.db.source_file(file_id)\n     }\n     pub fn file_line_index(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.db.file_lines(file_id)\n@@ -220,14 +159,14 @@ impl AnalysisImpl {\n                 .collect()\n         };\n         self.db\n-            .query(FileSyntaxQuery)\n+            .query(SourceFileQuery)\n             .sweep(salsa::SweepStrategy::default().discard_values());\n         Ok(query.search(&buf))\n     }\n     /// This return `Vec`: a module may be included from several places. We\n     /// don't handle this case yet though, so the Vec has length at most one.\n     pub fn parent_module(&self, position: FilePosition) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let descr = match ModuleDescriptor::guess_from_position(&*self.db, position)? {\n+        let descr = match hir::Module::guess_from_position(&*self.db, position)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -246,7 +185,7 @@ impl AnalysisImpl {\n     }\n     /// Returns `Vec` for the same reason as `parent_module`\n     pub fn crate_for(&self, file_id: FileId) -> Cancelable<Vec<CrateId>> {\n-        let descr = match ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+        let descr = match hir::Module::guess_from_file_id(&*self.db, file_id)? {\n             None => return Ok(Vec::new()),\n             Some(it) => it,\n         };\n@@ -261,7 +200,7 @@ impl AnalysisImpl {\n         Ok(crate_id.into_iter().collect())\n     }\n     pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n-        self.db.crate_graph().crate_roots[&crate_id]\n+        self.db.crate_graph().crate_root(crate_id)\n     }\n     pub fn completions(&self, position: FilePosition) -> Cancelable<Option<Vec<CompletionItem>>> {\n         completions(&self.db, position)\n@@ -270,33 +209,36 @@ impl AnalysisImpl {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n-        let file = self.db.file_syntax(position.file_id);\n+        let file = self.db.source_file(position.file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, position.offset) {\n-            // First try to resolve the symbol locally\n-            return if let Some((name, range)) =\n-                resolve_local_name(&self.db, position.file_id, name_ref)\n+            if let Some(fn_descr) =\n+                hir::Function::guess_for_name_ref(&*self.db, position.file_id, name_ref)\n             {\n-                let mut vec = vec![];\n-                vec.push((\n-                    position.file_id,\n-                    FileSymbol {\n-                        name,\n-                        node_range: range,\n-                        kind: NAME,\n-                    },\n-                ));\n-                Ok(vec)\n-            } else {\n-                // If that fails try the index based approach.\n-                self.index_resolve(name_ref)\n-            };\n+                let scope = fn_descr.scope(&*self.db);\n+                // First try to resolve the symbol locally\n+                return if let Some(entry) = scope.resolve_local_name(name_ref) {\n+                    let mut vec = vec![];\n+                    vec.push((\n+                        position.file_id,\n+                        FileSymbol {\n+                            name: entry.name().clone(),\n+                            node_range: entry.ptr().range(),\n+                            kind: NAME,\n+                        },\n+                    ));\n+                    Ok(vec)\n+                } else {\n+                    // If that fails try the index based approach.\n+                    self.index_resolve(name_ref)\n+                };\n+            }\n         }\n         if let Some(name) = find_node_at_offset::<ast::Name>(syntax, position.offset) {\n             if let Some(module) = name.syntax().parent().and_then(ast::Module::cast) {\n                 if module.has_semi() {\n                     let parent_module =\n-                        ModuleDescriptor::guess_from_file_id(&*self.db, position.file_id)?;\n+                        hir::Module::guess_from_file_id(&*self.db, position.file_id)?;\n                     let child_name = module.name();\n                     match (parent_module, child_name) {\n                         (Some(parent_module), Some(child_name)) => {\n@@ -319,46 +261,56 @@ impl AnalysisImpl {\n     }\n \n     pub fn find_all_refs(&self, position: FilePosition) -> Vec<(FileId, TextRange)> {\n-        let file = self.db.file_syntax(position.file_id);\n-        let syntax = file.syntax();\n-\n+        let file = self.db.source_file(position.file_id);\n         // Find the binding associated with the offset\n-        let maybe_binding =\n-            find_node_at_offset::<ast::BindPat>(syntax, position.offset).or_else(|| {\n-                let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n-                let resolved = resolve_local_name(&self.db, position.file_id, name_ref)?;\n-                find_node_at_offset::<ast::BindPat>(syntax, resolved.1.end())\n-            });\n-\n-        let binding = match maybe_binding {\n+        let (binding, descr) = match find_binding(&self.db, &file, position) {\n             None => return Vec::new(),\n             Some(it) => it,\n         };\n \n-        let decl = DeclarationDescriptor::new(binding);\n-\n-        let mut ret = vec![(position.file_id, decl.range)];\n+        let mut ret = vec![(position.file_id, binding.syntax().range())];\n         ret.extend(\n-            decl.find_all_refs()\n+            descr\n+                .scope(&*self.db)\n+                .find_all_refs(binding)\n                 .into_iter()\n                 .map(|ref_desc| (position.file_id, ref_desc.range)),\n         );\n \n-        ret\n+        return ret;\n+\n+        fn find_binding<'a>(\n+            db: &db::RootDatabase,\n+            source_file: &'a SourceFileNode,\n+            position: FilePosition,\n+        ) -> Option<(ast::BindPat<'a>, hir::Function)> {\n+            let syntax = source_file.syntax();\n+            if let Some(binding) = find_node_at_offset::<ast::BindPat>(syntax, position.offset) {\n+                let descr = hir::Function::guess_for_bind_pat(db, position.file_id, binding)?;\n+                return Some((binding, descr));\n+            };\n+            let name_ref = find_node_at_offset::<ast::NameRef>(syntax, position.offset)?;\n+            let descr = hir::Function::guess_for_name_ref(db, position.file_id, name_ref)?;\n+            let scope = descr.scope(db);\n+            let resolved = scope.resolve_local_name(name_ref)?;\n+            let resolved = resolved.ptr().resolve(source_file);\n+            let binding = find_node_at_offset::<ast::BindPat>(syntax, resolved.range().end())?;\n+            Some((binding, descr))\n+        }\n     }\n \n     pub fn doc_comment_for(\n         &self,\n         file_id: FileId,\n         symbol: FileSymbol,\n     ) -> Cancelable<Option<String>> {\n-        let file = self.db.file_syntax(file_id);\n+        let file = self.db.source_file(file_id);\n \n         Ok(symbol.docs(&file))\n     }\n \n     pub fn diagnostics(&self, file_id: FileId) -> Cancelable<Vec<Diagnostic>> {\n-        let syntax = self.db.file_syntax(file_id);\n+        let syntax = self.db.source_file(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n             .into_iter()\n@@ -368,7 +320,7 @@ impl AnalysisImpl {\n                 fix: None,\n             })\n             .collect::<Vec<_>>();\n-        if let Some(m) = ModuleDescriptor::guess_from_file_id(&*self.db, file_id)? {\n+        if let Some(m) = hir::Module::guess_from_file_id(&*self.db, file_id)? {\n             for (name_node, problem) in m.problems(&*self.db) {\n                 let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n@@ -445,8 +397,8 @@ impl AnalysisImpl {\n     pub fn resolve_callable(\n         &self,\n         position: FilePosition,\n-    ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n-        let file = self.db.file_syntax(position.file_id);\n+    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n+        let file = self.db.source_file(position.file_id);\n         let syntax = file.syntax();\n \n         // Find the calling expression and it's NameRef\n@@ -455,11 +407,12 @@ impl AnalysisImpl {\n \n         // Resolve the function's NameRef (NOTE: this isn't entirely accurate).\n         let file_symbols = self.index_resolve(name_ref)?;\n-        for (fn_fiel_id, fs) in file_symbols {\n+        for (fn_file_id, fs) in file_symbols {\n             if fs.kind == FN_DEF {\n-                let fn_file = self.db.file_syntax(fn_fiel_id);\n+                let fn_file = self.db.source_file(fn_file_id);\n                 if let Some(fn_def) = find_node_at_offset(fn_file.syntax(), fs.node_range.start()) {\n-                    if let Some(descriptor) = FnDescriptor::new(fn_def) {\n+                    let descr = hir::Function::guess_from_source(&*self.db, fn_file_id, fn_def);\n+                    if let Some(descriptor) = descr.signature_info(&*self.db) {\n                         // If we have a calling expression let's find which argument we are on\n                         let mut current_parameter = None;\n \n@@ -532,16 +485,6 @@ impl SourceChange {\n     }\n }\n \n-impl CrateGraph {\n-    fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n-        let (&crate_id, _) = self\n-            .crate_roots\n-            .iter()\n-            .find(|(_crate_id, &root_id)| root_id == file_id)?;\n-        Some(crate_id)\n-    }\n-}\n-\n enum FnCallNode<'a> {\n     CallExpr(ast::CallExpr<'a>),\n     MethodCallExpr(ast::MethodCallExpr<'a>),\n@@ -580,16 +523,3 @@ impl<'a> FnCallNode<'a> {\n         }\n     }\n }\n-\n-fn resolve_local_name(\n-    db: &db::RootDatabase,\n-    file_id: FileId,\n-    name_ref: ast::NameRef,\n-) -> Option<(SmolStr, TextRange)> {\n-    let fn_def = name_ref.syntax().ancestors().find_map(ast::FnDef::cast)?;\n-    let fn_id = FnId::get(db, file_id, fn_def);\n-    let scopes = db.fn_scopes(fn_id);\n-    let scope_entry = crate::descriptors::function::resolve_local_name(name_ref, &scopes)?;\n-    let syntax = db.resolve_syntax_ptr(scope_entry.ptr().into_global(file_id));\n-    Some((scope_entry.name().clone(), syntax.range()))\n-}"}, {"sha": "350a6d627e2f00e309cfc4f2de93e50574826c75", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 117, "deletions": 27, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -18,49 +18,36 @@ macro_rules! ctry {\n     };\n }\n \n-mod arena;\n mod db;\n-mod loc2id;\n-mod input;\n mod imp;\n mod completion;\n-mod descriptors;\n mod symbol_index;\n-mod syntax_ptr;\n pub mod mock_analysis;\n \n use std::{fmt, sync::Arc};\n \n use ra_syntax::{AtomEdit, SourceFileNode, TextRange, TextUnit};\n+use ra_db::FileResolverImp;\n use rayon::prelude::*;\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp},\n+    imp::{AnalysisHostImpl, AnalysisImpl},\n     symbol_index::SymbolIndex,\n };\n \n pub use crate::{\n     completion::CompletionItem,\n-    descriptors::function::FnDescriptor,\n-    input::{CrateGraph, CrateId, FileId, FileResolver},\n };\n pub use ra_editor::{\n     FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable, RunnableKind, StructureNode,\n };\n+pub use hir::FnSignatureInfo;\n \n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub struct Canceled;\n-\n-pub type Cancelable<T> = Result<T, Canceled>;\n-\n-impl std::fmt::Display for Canceled {\n-    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        fmt.write_str(\"Canceled\")\n-    }\n-}\n-\n-impl std::error::Error for Canceled {}\n+pub use ra_db::{\n+    Canceled, Cancelable, FilePosition,\n+    CrateGraph, CrateId, FileId, FileResolver\n+};\n \n #[derive(Default)]\n pub struct AnalysisChange {\n@@ -130,12 +117,6 @@ impl AnalysisHost {\n     }\n }\n \n-#[derive(Clone, Copy, Debug)]\n-pub struct FilePosition {\n-    pub file_id: FileId,\n-    pub offset: TextUnit,\n-}\n-\n #[derive(Debug)]\n pub struct SourceChange {\n     pub label: String,\n@@ -305,7 +286,7 @@ impl Analysis {\n     pub fn resolve_callable(\n         &self,\n         position: FilePosition,\n-    ) -> Cancelable<Option<(FnDescriptor, Option<usize>)>> {\n+    ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n         self.imp.resolve_callable(position)\n     }\n }\n@@ -336,3 +317,112 @@ fn analysis_is_send() {\n     fn is_send<T: Send>() {}\n     is_send::<Analysis>();\n }\n+\n+//TODO: move to hir\n+#[cfg(test)]\n+mod hir_namres_tests {\n+    use std::sync::Arc;\n+    use ra_db::FilesDatabase;\n+    use ra_syntax::SmolStr;\n+    use hir::{self, db::HirDatabase};\n+\n+    use crate::{\n+        AnalysisChange,\n+        mock_analysis::{MockAnalysis, analysis_and_position},\n+};\n+\n+    fn item_map(fixture: &str) -> (Arc<hir::ItemMap>, hir::ModuleId) {\n+        let (analysis, pos) = analysis_and_position(fixture);\n+        let db = analysis.imp.db;\n+        let source_root = db.file_source_root(pos.file_id);\n+        let descr = hir::Module::guess_from_position(&*db, pos)\n+            .unwrap()\n+            .unwrap();\n+        let module_id = descr.module_id;\n+        (db.item_map(source_root).unwrap(), module_id)\n+    }\n+\n+    #[test]\n+    fn test_item_map() {\n+        let (item_map, module_id) = item_map(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+            <|>\n+\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+        let name = SmolStr::from(\"Baz\");\n+        let resolution = &item_map.per_module[&module_id].items[&name];\n+        assert!(resolution.def_id.is_some());\n+    }\n+\n+    #[test]\n+    fn typing_inside_a_function_should_not_invalidate_item_map() {\n+        let mock_analysis = MockAnalysis::with_files(\n+            \"\n+            //- /lib.rs\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 {\n+                1 + 1\n+            }\n+            //- /foo/mod.rs\n+            pub mod bar;\n+\n+            //- /foo/bar.rs\n+            pub struct Baz;\n+        \",\n+        );\n+\n+        let file_id = mock_analysis.id_of(\"/lib.rs\");\n+        let mut host = mock_analysis.analysis_host();\n+\n+        let source_root = host.analysis().imp.db.file_source_root(file_id);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(format!(\"{:?}\", events).contains(\"item_map\"))\n+        }\n+\n+        let mut change = AnalysisChange::new();\n+\n+        change.change_file(\n+            file_id,\n+            \"\n+            mod foo;\n+\n+            use crate::foo::bar::Baz;\n+\n+            fn foo() -> i32 { 92 }\n+        \"\n+            .to_string(),\n+        );\n+\n+        host.apply_change(change);\n+\n+        {\n+            let db = host.analysis().imp.db;\n+            let events = db.log_executed(|| {\n+                db.item_map(source_root).unwrap();\n+            });\n+            assert!(\n+                !format!(\"{:?}\", events).contains(\"_item_map\"),\n+                \"{:#?}\",\n+                events\n+            )\n+        }\n+    }\n+}"}, {"sha": "c7c799a91fe776e1d72e4f6c6125eb425ec7e383", "filename": "crates/ra_analysis/src/loc2id.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f08341aa486ea59cb488635f19e960523568fb8/crates%2Fra_analysis%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Floc2id.rs?ref=9f08341aa486ea59cb488635f19e960523568fb8", "patch": "@@ -1,141 +0,0 @@\n-use parking_lot::Mutex;\n-\n-use std::{\n-    hash::Hash,\n-    sync::Arc,\n-};\n-\n-use rustc_hash::FxHashMap;\n-\n-use crate::{\n-    FileId,\n-    descriptors::FileItemId,\n-    descriptors::module::ModuleId,\n-    syntax_ptr::SyntaxPtr,\n-    input::SourceRootId,\n-};\n-\n-/// There are two principle ways to refer to things:\n-///   - by their locatinon (module in foo/bar/baz.rs at line 42)\n-///   - by their numeric id (module `ModuleId(42)`)\n-///\n-/// The first one is more powerful (you can actually find the thing in question\n-/// by id), but the second one is so much more compact.\n-///\n-/// `Loc2IdMap` allows us to have a cake an eat it as well: by maintaining a\n-/// bidirectional mapping between positional and numeric ids, we can use compact\n-/// representation wich still allows us to get the actual item\n-#[derive(Debug)]\n-pub(crate) struct Loc2IdMap<L, ID>\n-where\n-    ID: NumericId,\n-    L: Clone + Eq + Hash,\n-{\n-    loc2id: FxHashMap<L, ID>,\n-    id2loc: FxHashMap<ID, L>,\n-}\n-\n-impl<L, ID> Default for Loc2IdMap<L, ID>\n-where\n-    ID: NumericId,\n-    L: Clone + Eq + Hash,\n-{\n-    fn default() -> Self {\n-        Loc2IdMap {\n-            loc2id: FxHashMap::default(),\n-            id2loc: FxHashMap::default(),\n-        }\n-    }\n-}\n-\n-impl<L, ID> Loc2IdMap<L, ID>\n-where\n-    ID: NumericId,\n-    L: Clone + Eq + Hash,\n-{\n-    pub fn loc2id(&mut self, loc: &L) -> ID {\n-        match self.loc2id.get(loc) {\n-            Some(id) => return id.clone(),\n-            None => (),\n-        }\n-        let id = self.loc2id.len();\n-        assert!(id < u32::max_value() as usize);\n-        let id = ID::from_u32(id as u32);\n-        self.loc2id.insert(loc.clone(), id.clone());\n-        self.id2loc.insert(id.clone(), loc.clone());\n-        id\n-    }\n-\n-    pub fn id2loc(&self, id: ID) -> L {\n-        self.id2loc[&id].clone()\n-    }\n-}\n-\n-pub(crate) trait NumericId: Clone + Eq + Hash {\n-    fn from_u32(id: u32) -> Self;\n-    fn to_u32(self) -> u32;\n-}\n-\n-macro_rules! impl_numeric_id {\n-    ($id:ident) => {\n-        impl NumericId for $id {\n-            fn from_u32(id: u32) -> Self {\n-                $id(id)\n-            }\n-            fn to_u32(self) -> u32 {\n-                self.0\n-            }\n-        }\n-    };\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct FnId(u32);\n-impl_numeric_id!(FnId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct DefId(u32);\n-impl_numeric_id!(DefId);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum DefLoc {\n-    Module {\n-        id: ModuleId,\n-        source_root: SourceRootId,\n-    },\n-    Item {\n-        file_id: FileId,\n-        id: FileItemId,\n-    },\n-}\n-\n-pub(crate) trait IdDatabase: salsa::Database {\n-    fn id_maps(&self) -> &IdMaps;\n-}\n-\n-#[derive(Debug, Default, Clone)]\n-pub(crate) struct IdMaps {\n-    inner: Arc<IdMapsInner>,\n-}\n-\n-impl IdMaps {\n-    pub(crate) fn fn_id(&self, ptr: SyntaxPtr) -> FnId {\n-        self.inner.fns.lock().loc2id(&ptr)\n-    }\n-    pub(crate) fn fn_ptr(&self, fn_id: FnId) -> SyntaxPtr {\n-        self.inner.fns.lock().id2loc(fn_id)\n-    }\n-\n-    pub(crate) fn def_id(&self, loc: DefLoc) -> DefId {\n-        self.inner.defs.lock().loc2id(&loc)\n-    }\n-    pub(crate) fn def_loc(&self, def_id: DefId) -> DefLoc {\n-        self.inner.defs.lock().id2loc(def_id)\n-    }\n-}\n-\n-#[derive(Debug, Default)]\n-struct IdMapsInner {\n-    fns: Mutex<Loc2IdMap<SyntaxPtr, FnId>>,\n-    defs: Mutex<Loc2IdMap<DefLoc, DefId>>,\n-}"}, {"sha": "b48a372298746cee6dbed07d1ebc05f4af33604c", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -4,14 +4,36 @@ use std::{\n };\n \n use fst::{self, Streamer};\n-use ra_editor::{file_symbols, FileSymbol};\n+use ra_editor::{self, FileSymbol};\n use ra_syntax::{\n     SourceFileNode,\n     SyntaxKind::{self, *},\n };\n+use ra_db::{SyntaxDatabase, SourceRootId};\n use rayon::prelude::*;\n \n-use crate::{FileId, Query};\n+use crate::{\n+    Cancelable,\n+    FileId, Query,\n+};\n+\n+salsa::query_group! {\n+    pub(crate) trait SymbolsDatabase: SyntaxDatabase {\n+        fn file_symbols(file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n+            type FileSymbolsQuery;\n+        }\n+        fn library_symbols(id: SourceRootId) -> Arc<SymbolIndex> {\n+            type LibrarySymbolsQuery;\n+            storage input;\n+        }\n+    }\n+}\n+\n+fn file_symbols(db: &impl SyntaxDatabase, file_id: FileId) -> Cancelable<Arc<SymbolIndex>> {\n+    db.check_canceled()?;\n+    let syntax = db.source_file(file_id);\n+    Ok(Arc::new(SymbolIndex::for_file(file_id, syntax)))\n+}\n \n #[derive(Default, Debug)]\n pub(crate) struct SymbolIndex {\n@@ -39,7 +61,7 @@ impl SymbolIndex {\n     ) -> SymbolIndex {\n         let mut symbols = files\n             .flat_map(|(file_id, file)| {\n-                file_symbols(&file)\n+                ra_editor::file_symbols(&file)\n                     .into_iter()\n                     .map(move |symbol| (symbol.name.as_str().to_lowercase(), (file_id, symbol)))\n                     .collect::<Vec<_>>()"}, {"sha": "fbe89f44489547054376930c042a44801ff3efaf", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -10,10 +10,10 @@ use test_utils::assert_eq_dbg;\n \n use ra_analysis::{\n     mock_analysis::{analysis_and_position, single_file, single_file_with_position, MockAnalysis},\n-    AnalysisChange, CrateGraph, FileId, FnDescriptor,\n+    AnalysisChange, CrateGraph, FileId, FnSignatureInfo,\n };\n \n-fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n+fn get_signature(text: &str) -> (FnSignatureInfo, Option<usize>) {\n     let (analysis, position) = single_file_with_position(text);\n     analysis.resolve_callable(position).unwrap().unwrap()\n }\n@@ -126,7 +126,7 @@ fn test_resolve_crate_root() {\n     let mut host = mock.analysis_host();\n     assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n \n-    let mut crate_graph = CrateGraph::new();\n+    let mut crate_graph = CrateGraph::default();\n     let crate_id = crate_graph.add_crate_root(root_file);\n     let mut change = AnalysisChange::new();\n     change.set_crate_graph(crate_graph);"}, {"sha": "3bf2f635e755fe1f7b8d066140790cf3712206c4", "filename": "crates/ra_db/Cargo.toml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2FCargo.toml?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,16 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_db\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+relative-path = \"0.4.0\"\n+salsa = \"0.8.0\"\n+rustc-hash = \"1.0\"\n+parking_lot = \"0.6.4\"\n+id-arena = { git = \"https://github.com/fitzgen/id-arena/\", rev = \"43ecd67\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_editor = { path = \"../ra_editor\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "f849ac75214c81d23eff6dd0bfc748358bdaabd1", "filename": "crates/ra_db/src/file_resolver.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Ffile_resolver.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,76 @@\n+use std::{\n+    sync::Arc,\n+    hash::{Hash, Hasher},\n+    fmt,\n+};\n+\n+use relative_path::RelativePath;\n+\n+use crate::input::FileId;\n+\n+pub trait FileResolver: fmt::Debug + Send + Sync + 'static {\n+    fn file_stem(&self, file_id: FileId) -> String;\n+    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n+    fn debug_path(&self, _1file_id: FileId) -> Option<std::path::PathBuf> {\n+        None\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct FileResolverImp {\n+    inner: Arc<FileResolver>,\n+}\n+\n+impl PartialEq for FileResolverImp {\n+    fn eq(&self, other: &FileResolverImp) -> bool {\n+        self.inner() == other.inner()\n+    }\n+}\n+\n+impl Eq for FileResolverImp {}\n+\n+impl Hash for FileResolverImp {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        self.inner().hash(hasher);\n+    }\n+}\n+\n+impl FileResolverImp {\n+    pub fn new(inner: Arc<FileResolver>) -> FileResolverImp {\n+        FileResolverImp { inner }\n+    }\n+    pub fn file_stem(&self, file_id: FileId) -> String {\n+        self.inner.file_stem(file_id)\n+    }\n+    pub fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n+        self.inner.resolve(file_id, path)\n+    }\n+    pub fn debug_path(&self, file_id: FileId) -> Option<std::path::PathBuf> {\n+        self.inner.debug_path(file_id)\n+    }\n+    fn inner(&self) -> *const FileResolver {\n+        &*self.inner\n+    }\n+}\n+\n+impl Default for FileResolverImp {\n+    fn default() -> FileResolverImp {\n+        #[derive(Debug)]\n+        struct DummyResolver;\n+        impl FileResolver for DummyResolver {\n+            fn file_stem(&self, _file_: FileId) -> String {\n+                panic!(\"file resolver not set\")\n+            }\n+            fn resolve(\n+                &self,\n+                _file_id: FileId,\n+                _path: &::relative_path::RelativePath,\n+            ) -> Option<FileId> {\n+                panic!(\"file resolver not set\")\n+            }\n+        }\n+        FileResolverImp {\n+            inner: Arc::new(DummyResolver),\n+        }\n+    }\n+}"}, {"sha": "9101ac7a8a37a6f109780200125dd8e965bea8c0", "filename": "crates/ra_db/src/input.rs", "status": "renamed", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,11 +1,10 @@\n-use std::{fmt, sync::Arc};\n+use std::sync::Arc;\n \n-use relative_path::RelativePath;\n use rustc_hash::FxHashMap;\n use rustc_hash::FxHashSet;\n use salsa;\n \n-use crate::{symbol_index::SymbolIndex, FileResolverImp};\n+use crate::file_resolver::FileResolverImp;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct FileId(pub u32);\n@@ -19,27 +18,26 @@ pub struct CrateGraph {\n }\n \n impl CrateGraph {\n-    pub fn new() -> CrateGraph {\n-        CrateGraph::default()\n+    pub fn crate_root(&self, crate_id: CrateId) -> FileId {\n+        self.crate_roots[&crate_id]\n     }\n     pub fn add_crate_root(&mut self, file_id: FileId) -> CrateId {\n         let crate_id = CrateId(self.crate_roots.len() as u32);\n         let prev = self.crate_roots.insert(crate_id, file_id);\n         assert!(prev.is_none());\n         crate_id\n     }\n-}\n-\n-pub trait FileResolver: fmt::Debug + Send + Sync + 'static {\n-    fn file_stem(&self, file_id: FileId) -> String;\n-    fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId>;\n-    fn debug_path(&self, _file_id: FileId) -> Option<std::path::PathBuf> {\n-        None\n+    pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n+        let (&crate_id, _) = self\n+            .crate_roots\n+            .iter()\n+            .find(|(_crate_id, &root_id)| root_id == file_id)?;\n+        Some(crate_id)\n     }\n }\n \n salsa::query_group! {\n-    pub(crate) trait FilesDatabase: salsa::Database {\n+    pub trait FilesDatabase: salsa::Database {\n         fn file_text(file_id: FileId) -> Arc<String> {\n             type FileTextQuery;\n             storage input;\n@@ -56,10 +54,6 @@ salsa::query_group! {\n             type LibrariesQuery;\n             storage input;\n         }\n-        fn library_symbols(id: SourceRootId) -> Arc<SymbolIndex> {\n-            type LibrarySymbolsQuery;\n-            storage input;\n-        }\n         fn crate_graph() -> Arc<CrateGraph> {\n             type CrateGraphQuery;\n             storage input;\n@@ -68,12 +62,12 @@ salsa::query_group! {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]\n-pub(crate) struct SourceRootId(pub(crate) u32);\n+pub struct SourceRootId(pub u32);\n \n #[derive(Default, Clone, Debug, PartialEq, Eq)]\n-pub(crate) struct SourceRoot {\n-    pub(crate) file_resolver: FileResolverImp,\n-    pub(crate) files: FxHashSet<FileId>,\n+pub struct SourceRoot {\n+    pub file_resolver: FileResolverImp,\n+    pub files: FxHashSet<FileId>,\n }\n \n-pub(crate) const WORKSPACE: SourceRootId = SourceRootId(0);\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);", "previous_filename": "crates/ra_analysis/src/input.rs"}, {"sha": "33cb0e2ecb8ce6f06989f56376b2ab29fef5a352", "filename": "crates/ra_db/src/lib.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,89 @@\n+//! ra_db defines basic database traits. Concrete DB is defined by ra_analysis.\n+\n+extern crate ra_editor;\n+extern crate ra_syntax;\n+extern crate relative_path;\n+extern crate rustc_hash;\n+extern crate salsa;\n+\n+mod syntax_ptr;\n+mod file_resolver;\n+mod input;\n+mod loc2id;\n+\n+use std::sync::Arc;\n+use ra_editor::LineIndex;\n+use ra_syntax::{TextUnit, SourceFileNode};\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]\n+pub struct Canceled;\n+\n+pub type Cancelable<T> = Result<T, Canceled>;\n+\n+impl std::fmt::Display for Canceled {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        fmt.write_str(\"Canceled\")\n+    }\n+}\n+\n+impl std::error::Error for Canceled {}\n+\n+pub use crate::{\n+    syntax_ptr::LocalSyntaxPtr,\n+    file_resolver::{FileResolver, FileResolverImp},\n+    input::{\n+        FilesDatabase, FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, WORKSPACE,\n+        FileTextQuery, FileSourceRootQuery, SourceRootQuery, LibrariesQuery, CrateGraphQuery,\n+    },\n+    loc2id::{LocationIntener, NumericId},\n+};\n+\n+#[macro_export]\n+macro_rules! impl_numeric_id {\n+    ($id:ident) => {\n+        impl $crate::NumericId for $id {\n+            fn from_u32(id: u32) -> Self {\n+                $id(id)\n+            }\n+            fn to_u32(self) -> u32 {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+pub trait BaseDatabase: salsa::Database {\n+    fn check_canceled(&self) -> Cancelable<()> {\n+        if self.salsa_runtime().is_current_revision_canceled() {\n+            Err(Canceled)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+}\n+\n+salsa::query_group! {\n+    pub trait SyntaxDatabase: crate::input::FilesDatabase + BaseDatabase {\n+        fn source_file(file_id: FileId) -> SourceFileNode {\n+            type SourceFileQuery;\n+        }\n+        fn file_lines(file_id: FileId) -> Arc<LineIndex> {\n+            type FileLinesQuery;\n+        }\n+    }\n+}\n+\n+fn source_file(db: &impl SyntaxDatabase, file_id: FileId) -> SourceFileNode {\n+    let text = db.file_text(file_id);\n+    SourceFileNode::parse(&*text)\n+}\n+fn file_lines(db: &impl SyntaxDatabase, file_id: FileId) -> Arc<LineIndex> {\n+    let text = db.file_text(file_id);\n+    Arc::new(LineIndex::new(&*text))\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct FilePosition {\n+    pub file_id: FileId,\n+    pub offset: TextUnit,\n+}"}, {"sha": "69ba43d0f76c0ef5e208c268367acf38487bc35e", "filename": "crates/ra_db/src/loc2id.rs", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Floc2id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Floc2id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Floc2id.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,100 @@\n+use parking_lot::Mutex;\n+\n+use std::hash::Hash;\n+\n+use rustc_hash::FxHashMap;\n+\n+/// There are two principle ways to refer to things:\n+///   - by their locatinon (module in foo/bar/baz.rs at line 42)\n+///   - by their numeric id (module `ModuleId(42)`)\n+///\n+/// The first one is more powerful (you can actually find the thing in question\n+/// by id), but the second one is so much more compact.\n+///\n+/// `Loc2IdMap` allows us to have a cake an eat it as well: by maintaining a\n+/// bidirectional mapping between positional and numeric ids, we can use compact\n+/// representation wich still allows us to get the actual item\n+#[derive(Debug)]\n+struct Loc2IdMap<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    loc2id: FxHashMap<LOC, ID>,\n+    id2loc: FxHashMap<ID, LOC>,\n+}\n+\n+impl<LOC, ID> Default for Loc2IdMap<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    fn default() -> Self {\n+        Loc2IdMap {\n+            loc2id: FxHashMap::default(),\n+            id2loc: FxHashMap::default(),\n+        }\n+    }\n+}\n+\n+impl<LOC, ID> Loc2IdMap<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    pub fn loc2id(&mut self, loc: &LOC) -> ID {\n+        match self.loc2id.get(loc) {\n+            Some(id) => return id.clone(),\n+            None => (),\n+        }\n+        let id = self.loc2id.len();\n+        assert!(id < u32::max_value() as usize);\n+        let id = ID::from_u32(id as u32);\n+        self.loc2id.insert(loc.clone(), id.clone());\n+        self.id2loc.insert(id.clone(), loc.clone());\n+        id\n+    }\n+\n+    pub fn id2loc(&self, id: ID) -> LOC {\n+        self.id2loc[&id].clone()\n+    }\n+}\n+\n+pub trait NumericId: Clone + Eq + Hash {\n+    fn from_u32(id: u32) -> Self;\n+    fn to_u32(self) -> u32;\n+}\n+\n+#[derive(Debug)]\n+pub struct LocationIntener<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    map: Mutex<Loc2IdMap<LOC, ID>>,\n+}\n+\n+impl<LOC, ID> Default for LocationIntener<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    fn default() -> Self {\n+        LocationIntener {\n+            map: Default::default(),\n+        }\n+    }\n+}\n+\n+impl<LOC, ID> LocationIntener<LOC, ID>\n+where\n+    ID: NumericId,\n+    LOC: Clone + Eq + Hash,\n+{\n+    pub fn loc2id(&self, loc: &LOC) -> ID {\n+        self.map.lock().loc2id(loc)\n+    }\n+    pub fn id2loc(&self, id: ID) -> LOC {\n+        self.map.lock().id2loc(id)\n+    }\n+}"}, {"sha": "dac94dd36ddfba692c67f64da61dec384e61f2a0", "filename": "crates/ra_db/src/syntax_ptr.rs", "status": "renamed", "additions": 5, "deletions": 36, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Fsyntax_ptr.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,49 +1,21 @@\n use ra_syntax::{SourceFileNode, SyntaxKind, SyntaxNode, SyntaxNodeRef, TextRange};\n \n-use crate::db::SyntaxDatabase;\n-use crate::FileId;\n-\n-pub(crate) fn resolve_syntax_ptr(db: &impl SyntaxDatabase, ptr: SyntaxPtr) -> SyntaxNode {\n-    let syntax = db.file_syntax(ptr.file_id);\n-    ptr.local.resolve(&syntax)\n-}\n-\n-/// SyntaxPtr is a cheap `Copy` id which identifies a particular syntax node,\n-/// without retaining syntax tree in memory. You need to explicitly `resolve`\n-/// `SyntaxPtr` to get a `SyntaxNode`\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct SyntaxPtr {\n-    file_id: FileId,\n-    local: LocalSyntaxPtr,\n-}\n-\n-impl SyntaxPtr {\n-    pub(crate) fn new(file_id: FileId, node: SyntaxNodeRef) -> SyntaxPtr {\n-        let local = LocalSyntaxPtr::new(node);\n-        SyntaxPtr { file_id, local }\n-    }\n-\n-    pub(crate) fn file_id(self) -> FileId {\n-        self.file_id\n-    }\n-}\n-\n /// A pionter to a syntax node inside a file.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub(crate) struct LocalSyntaxPtr {\n+pub struct LocalSyntaxPtr {\n     range: TextRange,\n     kind: SyntaxKind,\n }\n \n impl LocalSyntaxPtr {\n-    pub(crate) fn new(node: SyntaxNodeRef) -> LocalSyntaxPtr {\n+    pub fn new(node: SyntaxNodeRef) -> LocalSyntaxPtr {\n         LocalSyntaxPtr {\n             range: node.range(),\n             kind: node.kind(),\n         }\n     }\n \n-    pub(crate) fn resolve(self, file: &SourceFileNode) -> SyntaxNode {\n+    pub fn resolve(self, file: &SourceFileNode) -> SyntaxNode {\n         let mut curr = file.syntax();\n         loop {\n             if curr.range() == self.range && curr.kind() == self.kind {\n@@ -56,11 +28,8 @@ impl LocalSyntaxPtr {\n         }\n     }\n \n-    pub(crate) fn into_global(self, file_id: FileId) -> SyntaxPtr {\n-        SyntaxPtr {\n-            file_id,\n-            local: self,\n-        }\n+    pub fn range(self) -> TextRange {\n+        self.range\n     }\n }\n ", "previous_filename": "crates/ra_analysis/src/syntax_ptr.rs"}, {"sha": "9bde289e707eeebab90c37765f935fa599cfd07c", "filename": "crates/ra_hir/Cargo.toml", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,17 @@\n+[package]\n+edition = \"2018\"\n+name = \"ra_hir\"\n+version = \"0.1.0\"\n+authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n+\n+[dependencies]\n+log = \"0.4.5\"\n+relative-path = \"0.4.0\"\n+salsa = \"0.8.0\"\n+rustc-hash = \"1.0\"\n+parking_lot = \"0.6.4\"\n+id-arena = { git = \"https://github.com/fitzgen/id-arena/\", rev = \"43ecd67\" }\n+ra_syntax = { path = \"../ra_syntax\" }\n+ra_editor = { path = \"../ra_editor\" }\n+ra_db = { path = \"../ra_db\" }\n+test_utils = { path = \"../test_utils\" }"}, {"sha": "8d67ab1c9ca94d9d615ac93c9ab5d59b3d8e232e", "filename": "crates/ra_hir/src/arena.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Farena.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -8,7 +8,7 @@ use std::{\n     marker::PhantomData,\n };\n \n-pub(crate) struct Id<T> {\n+pub struct Id<T> {\n     idx: u32,\n     _ty: PhantomData<fn() -> T>,\n }", "previous_filename": "crates/ra_analysis/src/arena.rs"}, {"sha": "2f01bae6d19a45936a07ce083c8fe0ffddca2e4c", "filename": "crates/ra_hir/src/db.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,66 @@\n+use std::sync::Arc;\n+\n+use ra_syntax::{\n+    SyntaxNode,\n+    ast::FnDefNode,\n+};\n+use ra_db::{SourceRootId, LocationIntener, SyntaxDatabase, FileId, Cancelable};\n+\n+use crate::{\n+    DefLoc, DefId, FnId,\n+    SourceFileItems, SourceItemId,\n+    query_definitions,\n+    FnScopes,\n+    module::{ModuleId, ModuleTree, ModuleSource,\n+    nameres::{ItemMap, InputModuleItems}},\n+};\n+\n+salsa::query_group! {\n+\n+pub trait HirDatabase: SyntaxDatabase\n+    + AsRef<LocationIntener<DefLoc, DefId>>\n+    + AsRef<LocationIntener<SourceItemId, FnId>>\n+{\n+    fn fn_scopes(fn_id: FnId) -> Arc<FnScopes> {\n+        type FnScopesQuery;\n+        use fn query_definitions::fn_scopes;\n+    }\n+    fn fn_syntax(fn_id: FnId) -> FnDefNode {\n+        type FnSyntaxQuery;\n+        // Don't retain syntax trees in memory\n+        storage dependencies;\n+        use fn query_definitions::fn_syntax;\n+    }\n+\n+    fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n+        type SourceFileItemsQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_items;\n+    }\n+\n+    fn file_item(source_item_id: SourceItemId) -> SyntaxNode {\n+        type FileItemQuery;\n+        storage dependencies;\n+        use fn query_definitions::file_item;\n+    }\n+\n+    fn submodules(source: ModuleSource) -> Cancelable<Arc<Vec<crate::module::imp::Submodule>>> {\n+        type SubmodulesQuery;\n+        use fn query_definitions::submodules;\n+    }\n+\n+    fn input_module_items(source_root_id: SourceRootId, module_id: ModuleId) -> Cancelable<Arc<InputModuleItems>> {\n+        type InputModuleItemsQuery;\n+        use fn query_definitions::input_module_items;\n+    }\n+    fn item_map(source_root_id: SourceRootId) -> Cancelable<Arc<ItemMap>> {\n+        type ItemMapQuery;\n+        use fn query_definitions::item_map;\n+    }\n+    fn module_tree(source_root_id: SourceRootId) -> Cancelable<Arc<ModuleTree>> {\n+        type ModuleTreeQuery;\n+        use fn crate::module::imp::module_tree;\n+    }\n+}\n+\n+}"}, {"sha": "c8af2e54f9716c08a2550b0f4641855f640fc5a6", "filename": "crates/ra_hir/src/function/mod.rs", "status": "renamed", "additions": 69, "deletions": 16, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fmod.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,39 +1,92 @@\n-pub(super) mod imp;\n mod scope;\n \n-use std::cmp::{max, min};\n+use std::{\n+    cmp::{max, min},\n+    sync::Arc,\n+};\n \n use ra_syntax::{\n+    TextRange, TextUnit, SyntaxNodeRef,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n-    TextRange, TextUnit,\n };\n+use ra_db::FileId;\n \n use crate::{\n-    syntax_ptr::SyntaxPtr, FileId,\n-    loc2id::IdDatabase,\n+    FnId, HirDatabase, SourceItemId,\n };\n \n-pub(crate) use self::scope::{resolve_local_name, FnScopes};\n-pub(crate) use crate::loc2id::FnId;\n+pub use self::scope::FnScopes;\n \n impl FnId {\n-    pub(crate) fn get(db: &impl IdDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n-        let ptr = SyntaxPtr::new(file_id, fn_def.syntax());\n-        db.id_maps().fn_id(ptr)\n+    pub fn get(db: &impl HirDatabase, file_id: FileId, fn_def: ast::FnDef) -> FnId {\n+        let file_items = db.file_items(file_id);\n+        let item_id = file_items.id_of(fn_def.syntax());\n+        let item_id = SourceItemId { file_id, item_id };\n+        FnId::from_loc(db, &item_id)\n+    }\n+}\n+\n+pub struct Function {\n+    fn_id: FnId,\n+}\n+\n+impl Function {\n+    pub fn guess_from_source(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        fn_def: ast::FnDef,\n+    ) -> Function {\n+        let fn_id = FnId::get(db, file_id, fn_def);\n+        Function { fn_id }\n+    }\n+\n+    pub fn guess_for_name_ref(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        name_ref: ast::NameRef,\n+    ) -> Option<Function> {\n+        Function::guess_for_node(db, file_id, name_ref.syntax())\n+    }\n+\n+    pub fn guess_for_bind_pat(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        bind_pat: ast::BindPat,\n+    ) -> Option<Function> {\n+        Function::guess_for_node(db, file_id, bind_pat.syntax())\n+    }\n+\n+    fn guess_for_node(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        node: SyntaxNodeRef,\n+    ) -> Option<Function> {\n+        let fn_def = node.ancestors().find_map(ast::FnDef::cast)?;\n+        let res = Function::guess_from_source(db, file_id, fn_def);\n+        Some(res)\n+    }\n+\n+    pub fn scope(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n+        db.fn_scopes(self.fn_id)\n+    }\n+\n+    pub fn signature_info(&self, db: &impl HirDatabase) -> Option<FnSignatureInfo> {\n+        let syntax = db.fn_syntax(self.fn_id);\n+        FnSignatureInfo::new(syntax.borrowed())\n     }\n }\n \n #[derive(Debug, Clone)]\n-pub struct FnDescriptor {\n+pub struct FnSignatureInfo {\n     pub name: String,\n     pub label: String,\n     pub ret_type: Option<String>,\n     pub params: Vec<String>,\n     pub doc: Option<String>,\n }\n \n-impl FnDescriptor {\n-    pub fn new(node: ast::FnDef) -> Option<Self> {\n+impl FnSignatureInfo {\n+    fn new(node: ast::FnDef) -> Option<Self> {\n         let name = node.name()?.text().to_string();\n \n         let mut doc = None;\n@@ -52,7 +105,7 @@ impl FnDescriptor {\n             node.syntax().text().to_string()\n         };\n \n-        if let Some((comment_range, docs)) = FnDescriptor::extract_doc_comments(node) {\n+        if let Some((comment_range, docs)) = FnSignatureInfo::extract_doc_comments(node) {\n             let comment_range = comment_range\n                 .checked_sub(node.syntax().range().start())\n                 .unwrap();\n@@ -84,10 +137,10 @@ impl FnDescriptor {\n             }\n         }\n \n-        let params = FnDescriptor::param_list(node);\n+        let params = FnSignatureInfo::param_list(node);\n         let ret_type = node.ret_type().map(|r| r.syntax().text().to_string());\n \n-        Some(FnDescriptor {\n+        Some(FnSignatureInfo {\n             name,\n             ret_type,\n             params,", "previous_filename": "crates/ra_analysis/src/descriptors/function/mod.rs"}, {"sha": "8634532916628dfc5497776c0c42320999eecf95", "filename": "crates/ra_hir/src/function/scope.rs", "status": "renamed", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction%2Fscope.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,21 +1,21 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n+    AstNode, SmolStr, SyntaxNodeRef, TextRange,\n     algo::generate,\n     ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n-    AstNode, SmolStr, SyntaxNodeRef,\n };\n+use ra_db::LocalSyntaxPtr;\n \n use crate::{\n-    syntax_ptr::LocalSyntaxPtr,\n     arena::{Arena, Id},\n };\n \n pub(crate) type ScopeId = Id<ScopeData>;\n \n #[derive(Debug, PartialEq, Eq)]\n pub struct FnScopes {\n-    pub(crate) self_param: Option<LocalSyntaxPtr>,\n+    pub self_param: Option<LocalSyntaxPtr>,\n     scopes: Arena<ScopeData>,\n     scope_for: FxHashMap<LocalSyntaxPtr, ScopeId>,\n }\n@@ -27,13 +27,13 @@ pub struct ScopeEntry {\n }\n \n #[derive(Debug, PartialEq, Eq)]\n-pub(crate) struct ScopeData {\n+pub struct ScopeData {\n     parent: Option<ScopeId>,\n     entries: Vec<ScopeEntry>,\n }\n \n impl FnScopes {\n-    pub(crate) fn new(fn_def: ast::FnDef) -> FnScopes {\n+    pub fn new(fn_def: ast::FnDef) -> FnScopes {\n         let mut scopes = FnScopes {\n             self_param: fn_def\n                 .param_list()\n@@ -49,14 +49,45 @@ impl FnScopes {\n         }\n         scopes\n     }\n-    pub(crate) fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n+    pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n         &self.scopes[scope].entries\n     }\n     pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n         generate(self.scope_for(node), move |&scope| {\n             self.scopes[scope].parent\n         })\n     }\n+    pub fn resolve_local_name<'a>(&'a self, name_ref: ast::NameRef) -> Option<&'a ScopeEntry> {\n+        let mut shadowed = FxHashSet::default();\n+        let ret = self\n+            .scope_chain(name_ref.syntax())\n+            .flat_map(|scope| self.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .filter(|entry| entry.name() == &name_ref.text())\n+            .nth(0);\n+        ret\n+    }\n+\n+    pub fn find_all_refs(&self, pat: ast::BindPat) -> Vec<ReferenceDescriptor> {\n+        let fn_def = pat.syntax().ancestors().find_map(ast::FnDef::cast).unwrap();\n+        let name_ptr = LocalSyntaxPtr::new(pat.syntax());\n+        let refs: Vec<_> = fn_def\n+            .syntax()\n+            .descendants()\n+            .filter_map(ast::NameRef::cast)\n+            .filter(|name_ref| match self.resolve_local_name(*name_ref) {\n+                None => false,\n+                Some(entry) => entry.ptr() == name_ptr,\n+            })\n+            .map(|name_ref| ReferenceDescriptor {\n+                name: name_ref.syntax().text().to_string(),\n+                range: name_ref.syntax().range(),\n+            })\n+            .collect();\n+\n+        refs\n+    }\n+\n     fn root_scope(&mut self) -> ScopeId {\n         self.scopes.alloc(ScopeData {\n             parent: None,\n@@ -104,10 +135,10 @@ impl ScopeEntry {\n         };\n         Some(res)\n     }\n-    pub(crate) fn name(&self) -> &SmolStr {\n+    pub fn name(&self) -> &SmolStr {\n         &self.name\n     }\n-    pub(crate) fn ptr(&self) -> LocalSyntaxPtr {\n+    pub fn ptr(&self) -> LocalSyntaxPtr {\n         self.ptr\n     }\n }\n@@ -249,18 +280,10 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n     }\n }\n \n-pub fn resolve_local_name<'a>(\n-    name_ref: ast::NameRef,\n-    scopes: &'a FnScopes,\n-) -> Option<&'a ScopeEntry> {\n-    let mut shadowed = FxHashSet::default();\n-    let ret = scopes\n-        .scope_chain(name_ref.syntax())\n-        .flat_map(|scope| scopes.entries(scope).iter())\n-        .filter(|entry| shadowed.insert(entry.name()))\n-        .filter(|entry| entry.name() == &name_ref.text())\n-        .nth(0);\n-    ret\n+#[derive(Debug)]\n+pub struct ReferenceDescriptor {\n+    pub range: TextRange,\n+    pub name: String,\n }\n \n #[cfg(test)]\n@@ -376,7 +399,7 @@ mod tests {\n \n         let scopes = FnScopes::new(fn_def);\n \n-        let local_name_entry = resolve_local_name(name_ref, &scopes).unwrap();\n+        let local_name_entry = scopes.resolve_local_name(name_ref).unwrap();\n         let local_name = local_name_entry.ptr().resolve(&file);\n         let expected_name =\n             find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();", "previous_filename": "crates/ra_analysis/src/descriptors/function/scope.rs"}, {"sha": "f13f0107e2271eb4dd7efd0dc851ea912aa42170", "filename": "crates/ra_hir/src/lib.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,139 @@\n+//! HIR (previsouly known as descriptors) provides a high-level OO acess to Rust\n+//! code.\n+//!\n+//! The principal difference between HIR and syntax trees is that HIR is bound\n+//! to a particular crate instance. That is, it has cfg flags and features\n+//! applied. So, there relation between syntax and HIR is many-to-one.\n+\n+macro_rules! ctry {\n+    ($expr:expr) => {\n+        match $expr {\n+            None => return Ok(None),\n+            Some(it) => it,\n+        }\n+    };\n+}\n+\n+pub mod db;\n+mod query_definitions;\n+mod function;\n+mod module;\n+mod path;\n+mod arena;\n+\n+use std::ops::Index;\n+\n+use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n+use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n+\n+use crate::{\n+    db::HirDatabase,\n+    arena::{Arena, Id},\n+};\n+\n+pub use self::{\n+    path::{Path, PathKind},\n+    module::{Module, ModuleId, Problem, nameres::ItemMap},\n+    function::{Function, FnScopes},\n+};\n+\n+pub use self::function::FnSignatureInfo;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct FnId(u32);\n+ra_db::impl_numeric_id!(FnId);\n+\n+impl FnId {\n+    pub fn from_loc(\n+        db: &impl AsRef<LocationIntener<SourceItemId, FnId>>,\n+        loc: &SourceItemId,\n+    ) -> FnId {\n+        db.as_ref().loc2id(loc)\n+    }\n+    pub fn loc(self, db: &impl AsRef<LocationIntener<SourceItemId, FnId>>) -> SourceItemId {\n+        db.as_ref().id2loc(self)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct DefId(u32);\n+ra_db::impl_numeric_id!(DefId);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum DefLoc {\n+    Module {\n+        id: ModuleId,\n+        source_root: SourceRootId,\n+    },\n+    Item {\n+        source_item_id: SourceItemId,\n+    },\n+}\n+\n+impl DefId {\n+    pub fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n+        db.as_ref().id2loc(self)\n+    }\n+}\n+\n+impl DefLoc {\n+    pub fn id(&self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefId {\n+        db.as_ref().loc2id(&self)\n+    }\n+}\n+\n+pub enum Def {\n+    Module(Module),\n+    Item,\n+}\n+\n+impl DefId {\n+    pub fn resolve(self, db: &impl HirDatabase) -> Cancelable<Def> {\n+        let loc = self.loc(db);\n+        let res = match loc {\n+            DefLoc::Module { id, source_root } => {\n+                let descr = Module::new(db, source_root, id)?;\n+                Def::Module(descr)\n+            }\n+            DefLoc::Item { .. } => Def::Item,\n+        };\n+        Ok(res)\n+    }\n+}\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+pub(crate) type SourceFileItemId = Id<SyntaxNode>;\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SourceItemId {\n+    file_id: FileId,\n+    item_id: SourceFileItemId,\n+}\n+\n+/// Maps item's `SyntaxNode`s to `SourceFileItemId` and back.\n+#[derive(Debug, PartialEq, Eq, Default)]\n+pub struct SourceFileItems {\n+    arena: Arena<SyntaxNode>,\n+}\n+\n+impl SourceFileItems {\n+    fn alloc(&mut self, item: SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(item)\n+    }\n+    pub fn id_of(&self, item: SyntaxNodeRef) -> SourceFileItemId {\n+        let (id, _item) = self\n+            .arena\n+            .iter()\n+            .find(|(_id, i)| i.borrowed() == item)\n+            .unwrap();\n+        id\n+    }\n+}\n+\n+impl Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNode;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNode {\n+        &self.arena[idx]\n+    }\n+}"}, {"sha": "76ea129a76d45a0151539aa4906efeb178b610cf", "filename": "crates/ra_hir/src/module/imp.rs", "status": "renamed", "additions": 9, "deletions": 44, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fimp.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -6,21 +6,19 @@ use ra_syntax::{\n };\n use relative_path::RelativePathBuf;\n use rustc_hash::{FxHashMap, FxHashSet};\n+use ra_db::{SourceRoot, SourceRootId, FileResolverImp, Cancelable, FileId,};\n \n use crate::{\n-    db,\n-    descriptors::DescriptorDatabase,\n-    input::{SourceRoot, SourceRootId},\n-    Cancelable, FileId, FileResolverImp,\n+    HirDatabase,\n };\n \n use super::{\n-    LinkData, LinkId, ModuleData, ModuleId, ModuleSource, ModuleSourceNode,\n+    LinkData, LinkId, ModuleData, ModuleId, ModuleSource,\n     ModuleTree, Problem,\n };\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n-pub(crate) enum Submodule {\n+pub enum Submodule {\n     Declaration(SmolStr),\n     Definition(SmolStr, ModuleSource),\n }\n@@ -34,39 +32,6 @@ impl Submodule {\n     }\n }\n \n-pub(crate) fn submodules(\n-    db: &impl DescriptorDatabase,\n-    source: ModuleSource,\n-) -> Cancelable<Arc<Vec<Submodule>>> {\n-    db::check_canceled(db)?;\n-    let file_id = source.file_id();\n-    let submodules = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => collect_submodules(file_id, it.borrowed()),\n-        ModuleSourceNode::Module(it) => it\n-            .borrowed()\n-            .item_list()\n-            .map(|it| collect_submodules(file_id, it))\n-            .unwrap_or_else(Vec::new),\n-    };\n-    return Ok(Arc::new(submodules));\n-\n-    fn collect_submodules<'a>(\n-        file_id: FileId,\n-        root: impl ast::ModuleItemOwner<'a>,\n-    ) -> Vec<Submodule> {\n-        modules(root)\n-            .map(|(name, m)| {\n-                if m.has_semi() {\n-                    Submodule::Declaration(name)\n-                } else {\n-                    let src = ModuleSource::new_inline(file_id, m);\n-                    Submodule::Definition(name, src)\n-                }\n-            })\n-            .collect()\n-    }\n-}\n-\n pub(crate) fn modules<'a>(\n     root: impl ast::ModuleItemOwner<'a>,\n ) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n@@ -82,16 +47,16 @@ pub(crate) fn modules<'a>(\n }\n \n pub(crate) fn module_tree(\n-    db: &impl DescriptorDatabase,\n+    db: &impl HirDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<Arc<ModuleTree>> {\n-    db::check_canceled(db)?;\n+    db.check_canceled()?;\n     let res = create_module_tree(db, source_root)?;\n     Ok(Arc::new(res))\n }\n \n fn create_module_tree<'a>(\n-    db: &impl DescriptorDatabase,\n+    db: &impl HirDatabase,\n     source_root: SourceRootId,\n ) -> Cancelable<ModuleTree> {\n     let mut tree = ModuleTree::default();\n@@ -121,7 +86,7 @@ fn create_module_tree<'a>(\n }\n \n fn build_subtree(\n-    db: &impl DescriptorDatabase,\n+    db: &impl HirDatabase,\n     source_root: &SourceRoot,\n     tree: &mut ModuleTree,\n     visited: &mut FxHashSet<ModuleSource>,\n@@ -135,7 +100,7 @@ fn build_subtree(\n         parent,\n         children: Vec::new(),\n     });\n-    for sub in db._submodules(source)?.iter() {\n+    for sub in db.submodules(source)?.iter() {\n         let link = tree.push_link(LinkData {\n             name: sub.name().clone(),\n             owner: id,", "previous_filename": "crates/ra_analysis/src/descriptors/module/imp.rs"}, {"sha": "a011fd53eafd194fc27fb7f9f55e37b43ac64c7c", "filename": "crates/ra_hir/src/module/mod.rs", "status": "renamed", "additions": 67, "deletions": 70, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fmod.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -10,65 +10,64 @@ use ra_syntax::{\n     ast::{self, AstNode, NameOwner},\n     SmolStr, SyntaxNode,\n };\n+use ra_db::{SourceRootId, FileId, FilePosition, Cancelable};\n use relative_path::RelativePathBuf;\n \n use crate::{\n-    db::SyntaxDatabase, syntax_ptr::SyntaxPtr, FileId, FilePosition, Cancelable,\n-    descriptors::{Path, PathKind, DescriptorDatabase},\n-    input::SourceRootId,\n+    DefLoc, DefId, Path, PathKind, HirDatabase, SourceItemId,\n     arena::{Arena, Id},\n-    loc2id::{DefLoc, DefId},\n };\n \n-pub(crate) use self::nameres::ModuleScope;\n+pub use self::nameres::ModuleScope;\n \n-/// `ModuleDescriptor` is API entry point to get all the information\n+/// `Module` is API entry point to get all the information\n /// about a particular module.\n #[derive(Debug, Clone)]\n-pub(crate) struct ModuleDescriptor {\n+pub struct Module {\n     tree: Arc<ModuleTree>,\n     source_root_id: SourceRootId,\n-    module_id: ModuleId,\n+    //TODO: make private\n+    pub module_id: ModuleId,\n }\n \n-impl ModuleDescriptor {\n-    /// Lookup `ModuleDescriptor` by `FileId`. Note that this is inherently\n+impl Module {\n+    /// Lookup `Module` by `FileId`. Note that this is inherently\n     /// lossy transformation: in general, a single source might correspond to\n     /// several modules.\n     pub fn guess_from_file_id(\n-        db: &impl DescriptorDatabase,\n+        db: &impl HirDatabase,\n         file_id: FileId,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n-        ModuleDescriptor::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n+    ) -> Cancelable<Option<Module>> {\n+        Module::guess_from_source(db, file_id, ModuleSource::SourceFile(file_id))\n     }\n \n-    /// Lookup `ModuleDescriptor` by position in the source code. Note that this\n+    /// Lookup `Module` by position in the source code. Note that this\n     /// is inherently lossy transformation: in general, a single source might\n     /// correspond to several modules.\n     pub fn guess_from_position(\n-        db: &impl DescriptorDatabase,\n+        db: &impl HirDatabase,\n         position: FilePosition,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n-        let file = db.file_syntax(position.file_id);\n+    ) -> Cancelable<Option<Module>> {\n+        let file = db.source_file(position.file_id);\n         let module_source = match find_node_at_offset::<ast::Module>(file.syntax(), position.offset)\n         {\n-            Some(m) if !m.has_semi() => ModuleSource::new_inline(position.file_id, m),\n+            Some(m) if !m.has_semi() => ModuleSource::new_inline(db, position.file_id, m),\n             _ => ModuleSource::SourceFile(position.file_id),\n         };\n-        ModuleDescriptor::guess_from_source(db, position.file_id, module_source)\n+        Module::guess_from_source(db, position.file_id, module_source)\n     }\n \n     fn guess_from_source(\n-        db: &impl DescriptorDatabase,\n+        db: &impl HirDatabase,\n         file_id: FileId,\n         module_source: ModuleSource,\n-    ) -> Cancelable<Option<ModuleDescriptor>> {\n+    ) -> Cancelable<Option<Module>> {\n         let source_root_id = db.file_source_root(file_id);\n-        let module_tree = db._module_tree(source_root_id)?;\n+        let module_tree = db.module_tree(source_root_id)?;\n \n         let res = match module_tree.any_module_for_source(module_source) {\n             None => None,\n-            Some(module_id) => Some(ModuleDescriptor {\n+            Some(module_id) => Some(Module {\n                 tree: module_tree,\n                 source_root_id,\n                 module_id,\n@@ -78,12 +77,12 @@ impl ModuleDescriptor {\n     }\n \n     pub(super) fn new(\n-        db: &impl DescriptorDatabase,\n+        db: &impl HirDatabase,\n         source_root_id: SourceRootId,\n         module_id: ModuleId,\n-    ) -> Cancelable<ModuleDescriptor> {\n-        let module_tree = db._module_tree(source_root_id)?;\n-        let res = ModuleDescriptor {\n+    ) -> Cancelable<Module> {\n+        let module_tree = db.module_tree(source_root_id)?;\n+        let res = Module {\n             tree: module_tree,\n             source_root_id,\n             module_id,\n@@ -93,10 +92,7 @@ impl ModuleDescriptor {\n \n     /// Returns `mod foo;` or `mod foo {}` node whihc declared this module.\n     /// Returns `None` for the root module\n-    pub fn parent_link_source(\n-        &self,\n-        db: &impl DescriptorDatabase,\n-    ) -> Option<(FileId, ast::ModuleNode)> {\n+    pub fn parent_link_source(&self, db: &impl HirDatabase) -> Option<(FileId, ast::ModuleNode)> {\n         let link = self.module_id.parent_link(&self.tree)?;\n         let file_id = link.owner(&self.tree).source(&self.tree).file_id();\n         let src = link.bind_source(&self.tree, db);\n@@ -108,18 +104,18 @@ impl ModuleDescriptor {\n     }\n \n     /// Parent module. Returns `None` if this is a root module.\n-    pub fn parent(&self) -> Option<ModuleDescriptor> {\n+    pub fn parent(&self) -> Option<Module> {\n         let parent_id = self.module_id.parent(&self.tree)?;\n-        Some(ModuleDescriptor {\n+        Some(Module {\n             module_id: parent_id,\n             ..self.clone()\n         })\n     }\n \n     /// The root of the tree this module is part of\n-    pub fn crate_root(&self) -> ModuleDescriptor {\n+    pub fn crate_root(&self) -> Module {\n         let root_id = self.module_id.crate_root(&self.tree);\n-        ModuleDescriptor {\n+        Module {\n             module_id: root_id,\n             ..self.clone()\n         }\n@@ -132,35 +128,31 @@ impl ModuleDescriptor {\n         Some(link.name(&self.tree))\n     }\n \n-    pub fn def_id(&self, db: &impl DescriptorDatabase) -> DefId {\n+    pub fn def_id(&self, db: &impl HirDatabase) -> DefId {\n         let def_loc = DefLoc::Module {\n             id: self.module_id,\n             source_root: self.source_root_id,\n         };\n-        db.id_maps().def_id(def_loc)\n+        def_loc.id(db)\n     }\n \n     /// Finds a child module with the specified name.\n-    pub fn child(&self, name: &str) -> Option<ModuleDescriptor> {\n+    pub fn child(&self, name: &str) -> Option<Module> {\n         let child_id = self.module_id.child(&self.tree, name)?;\n-        Some(ModuleDescriptor {\n+        Some(Module {\n             module_id: child_id,\n             ..self.clone()\n         })\n     }\n \n     /// Returns a `ModuleScope`: a set of items, visible in this module.\n-    pub(crate) fn scope(&self, db: &impl DescriptorDatabase) -> Cancelable<ModuleScope> {\n-        let item_map = db._item_map(self.source_root_id)?;\n+    pub fn scope(&self, db: &impl HirDatabase) -> Cancelable<ModuleScope> {\n+        let item_map = db.item_map(self.source_root_id)?;\n         let res = item_map.per_module[&self.module_id].clone();\n         Ok(res)\n     }\n \n-    pub(crate) fn resolve_path(\n-        &self,\n-        db: &impl DescriptorDatabase,\n-        path: Path,\n-    ) -> Cancelable<Option<DefId>> {\n+    pub fn resolve_path(&self, db: &impl HirDatabase, path: Path) -> Cancelable<Option<DefId>> {\n         let mut curr = match path.kind {\n             PathKind::Crate => self.crate_root(),\n             PathKind::Self_ | PathKind::Plain => self.clone(),\n@@ -170,8 +162,8 @@ impl ModuleDescriptor {\n \n         let segments = path.segments;\n         for name in segments.iter() {\n-            let module = match db.id_maps().def_loc(curr) {\n-                DefLoc::Module { id, source_root } => ModuleDescriptor::new(db, source_root, id)?,\n+            let module = match curr.loc(db) {\n+                DefLoc::Module { id, source_root } => Module::new(db, source_root, id)?,\n                 _ => return Ok(None),\n             };\n             let scope = module.scope(db)?;\n@@ -180,7 +172,7 @@ impl ModuleDescriptor {\n         Ok(Some(curr))\n     }\n \n-    pub fn problems(&self, db: &impl DescriptorDatabase) -> Vec<(SyntaxNode, Problem)> {\n+    pub fn problems(&self, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         self.module_id.problems(&self.tree, db)\n     }\n }\n@@ -193,13 +185,13 @@ impl ModuleDescriptor {\n /// (which can have multiple parents) to the precise world of modules (which\n /// always have one parent).\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ModuleTree {\n+pub struct ModuleTree {\n     mods: Arena<ModuleData>,\n     links: Arena<LinkData>,\n }\n \n impl ModuleTree {\n-    fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n+    pub(crate) fn modules<'a>(&'a self) -> impl Iterator<Item = ModuleId> + 'a {\n         self.mods.iter().map(|(id, _)| id)\n     }\n \n@@ -219,20 +211,19 @@ impl ModuleTree {\n /// `ModuleSource` is the syntax tree element that produced this module:\n /// either a file, or an inlinde module.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub(crate) enum ModuleSource {\n+pub enum ModuleSource {\n     SourceFile(FileId),\n-    #[allow(dead_code)]\n-    Module(SyntaxPtr),\n+    Module(SourceItemId),\n }\n \n /// An owned syntax node for a module. Unlike `ModuleSource`,\n /// this holds onto the AST for the whole file.\n-enum ModuleSourceNode {\n+pub enum ModuleSourceNode {\n     SourceFile(ast::SourceFileNode),\n     Module(ast::ModuleNode),\n }\n \n-pub(crate) type ModuleId = Id<ModuleData>;\n+pub type ModuleId = Id<ModuleData>;\n type LinkId = Id<LinkData>;\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n@@ -247,7 +238,7 @@ pub enum Problem {\n }\n \n impl ModuleId {\n-    fn source(self, tree: &ModuleTree) -> ModuleSource {\n+    pub(crate) fn source(self, tree: &ModuleTree) -> ModuleSource {\n         tree.mods[self].source\n     }\n     fn parent_link(self, tree: &ModuleTree) -> Option<LinkId> {\n@@ -277,7 +268,7 @@ impl ModuleId {\n             Some((link.name.clone(), module))\n         })\n     }\n-    fn problems(self, tree: &ModuleTree, db: &impl SyntaxDatabase) -> Vec<(SyntaxNode, Problem)> {\n+    fn problems(self, tree: &ModuleTree, db: &impl HirDatabase) -> Vec<(SyntaxNode, Problem)> {\n         tree.mods[self]\n             .children\n             .iter()\n@@ -298,7 +289,7 @@ impl LinkId {\n     fn name(self, tree: &ModuleTree) -> SmolStr {\n         tree.links[self].name.clone()\n     }\n-    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl SyntaxDatabase) -> ast::ModuleNode {\n+    fn bind_source<'a>(self, tree: &ModuleTree, db: &impl HirDatabase) -> ast::ModuleNode {\n         let owner = self.owner(tree);\n         match owner.source(tree).resolve(db) {\n             ModuleSourceNode::SourceFile(root) => {\n@@ -314,41 +305,47 @@ impl LinkId {\n }\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n-pub(crate) struct ModuleData {\n+pub struct ModuleData {\n     source: ModuleSource,\n     parent: Option<LinkId>,\n     children: Vec<LinkId>,\n }\n \n impl ModuleSource {\n-    fn new_inline(file_id: FileId, module: ast::Module) -> ModuleSource {\n+    pub(crate) fn new_inline(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        module: ast::Module,\n+    ) -> ModuleSource {\n         assert!(!module.has_semi());\n-        let ptr = SyntaxPtr::new(file_id, module.syntax());\n-        ModuleSource::Module(ptr)\n+        let items = db.file_items(file_id);\n+        let item_id = items.id_of(module.syntax());\n+        let id = SourceItemId { file_id, item_id };\n+        ModuleSource::Module(id)\n     }\n \n-    pub(crate) fn as_file(self) -> Option<FileId> {\n+    pub fn as_file(self) -> Option<FileId> {\n         match self {\n             ModuleSource::SourceFile(f) => Some(f),\n             ModuleSource::Module(..) => None,\n         }\n     }\n \n-    pub(crate) fn file_id(self) -> FileId {\n+    pub fn file_id(self) -> FileId {\n         match self {\n             ModuleSource::SourceFile(f) => f,\n-            ModuleSource::Module(ptr) => ptr.file_id(),\n+            ModuleSource::Module(source_item_id) => source_item_id.file_id,\n         }\n     }\n \n-    fn resolve(self, db: &impl SyntaxDatabase) -> ModuleSourceNode {\n+    pub fn resolve(self, db: &impl HirDatabase) -> ModuleSourceNode {\n         match self {\n             ModuleSource::SourceFile(file_id) => {\n-                let syntax = db.file_syntax(file_id);\n+                let syntax = db.source_file(file_id);\n                 ModuleSourceNode::SourceFile(syntax.ast().owned())\n             }\n-            ModuleSource::Module(ptr) => {\n-                let syntax = db.resolve_syntax_ptr(ptr);\n+            ModuleSource::Module(item_id) => {\n+                let syntax = db.file_item(item_id);\n                 let syntax = syntax.borrowed();\n                 let module = ast::Module::cast(syntax).unwrap();\n                 ModuleSourceNode::Module(module.owned())", "previous_filename": "crates/ra_analysis/src/descriptors/module/mod.rs"}, {"sha": "837a8d5ae594aa83c46426c424e08df3b15f416a", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "renamed", "additions": 50, "deletions": 261, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -16,101 +16,42 @@\n //! structure itself is modified.\n use std::{\n     sync::Arc,\n-    time::Instant,\n-    ops::Index,\n };\n \n use rustc_hash::FxHashMap;\n-\n use ra_syntax::{\n-    SyntaxNode, SyntaxNodeRef, TextRange,\n+    TextRange,\n     SmolStr, SyntaxKind::{self, *},\n-    ast::{self, ModuleItemOwner, AstNode}\n+    ast::{self, AstNode}\n };\n+use ra_db::SourceRootId;\n \n use crate::{\n     Cancelable, FileId,\n-    loc2id::{DefId, DefLoc},\n-    descriptors::{\n-        Path, PathKind,\n-        DescriptorDatabase,\n-        module::{ModuleId, ModuleTree, ModuleSourceNode},\n-    },\n-    input::SourceRootId,\n-    arena::{Arena, Id}\n+    DefId, DefLoc,\n+    SourceItemId, SourceFileItemId, SourceFileItems,\n+    Path, PathKind,\n+    HirDatabase,\n+    module::{ModuleId, ModuleTree},\n };\n \n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-pub(crate) type FileItemId = Id<SyntaxNode>;\n-\n-/// Maps item's `SyntaxNode`s to `FileItemId` and back.\n-#[derive(Debug, PartialEq, Eq, Default)]\n-pub(crate) struct FileItems {\n-    arena: Arena<SyntaxNode>,\n-}\n-\n-impl FileItems {\n-    fn alloc(&mut self, item: SyntaxNode) -> FileItemId {\n-        self.arena.alloc(item)\n-    }\n-    fn id_of(&self, item: SyntaxNodeRef) -> FileItemId {\n-        let (id, _item) = self\n-            .arena\n-            .iter()\n-            .find(|(_id, i)| i.borrowed() == item)\n-            .unwrap();\n-        id\n-    }\n-}\n-\n-impl Index<FileItemId> for FileItems {\n-    type Output = SyntaxNode;\n-    fn index(&self, idx: FileItemId) -> &SyntaxNode {\n-        &self.arena[idx]\n-    }\n-}\n-\n-pub(crate) fn file_items(db: &impl DescriptorDatabase, file_id: FileId) -> Arc<FileItems> {\n-    let source_file = db.file_syntax(file_id);\n-    let source_file = source_file.borrowed();\n-    let mut res = FileItems::default();\n-    source_file\n-        .syntax()\n-        .descendants()\n-        .filter_map(ast::ModuleItem::cast)\n-        .map(|it| it.syntax().owned())\n-        .for_each(|it| {\n-            res.alloc(it);\n-        });\n-    Arc::new(res)\n-}\n-\n-pub(crate) fn file_item(\n-    db: &impl DescriptorDatabase,\n-    file_id: FileId,\n-    file_item_id: FileItemId,\n-) -> SyntaxNode {\n-    db._file_items(file_id)[file_item_id].clone()\n-}\n-\n /// Item map is the result of the name resolution. Item map contains, for each\n /// module, the set of visible items.\n #[derive(Default, Debug, PartialEq, Eq)]\n-pub(crate) struct ItemMap {\n-    pub(crate) per_module: FxHashMap<ModuleId, ModuleScope>,\n+pub struct ItemMap {\n+    pub per_module: FxHashMap<ModuleId, ModuleScope>,\n }\n \n #[derive(Debug, Default, PartialEq, Eq, Clone)]\n-pub(crate) struct ModuleScope {\n-    items: FxHashMap<SmolStr, Resolution>,\n+pub struct ModuleScope {\n+    pub items: FxHashMap<SmolStr, Resolution>,\n }\n \n impl ModuleScope {\n-    pub(crate) fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a SmolStr, &Resolution)> + 'a {\n         self.items.iter()\n     }\n-    pub(crate) fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n+    pub fn get(&self, name: &SmolStr) -> Option<&Resolution> {\n         self.items.get(name)\n     }\n }\n@@ -122,14 +63,14 @@ impl ModuleScope {\n /// recomputing name res: if `InputModuleItems` are the same, we can avoid\n /// running name resolution.\n #[derive(Debug, Default, PartialEq, Eq)]\n-pub(crate) struct InputModuleItems {\n+pub struct InputModuleItems {\n     items: Vec<ModuleItem>,\n     imports: Vec<Import>,\n }\n \n #[derive(Debug, PartialEq, Eq)]\n struct ModuleItem {\n-    id: FileItemId,\n+    id: SourceFileItemId,\n     name: SmolStr,\n     kind: SyntaxKind,\n     vis: Vis,\n@@ -148,14 +89,18 @@ struct Import {\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) struct NamedImport {\n-    file_item_id: FileItemId,\n-    relative_range: TextRange,\n+pub struct NamedImport {\n+    pub file_item_id: SourceFileItemId,\n+    pub relative_range: TextRange,\n }\n \n impl NamedImport {\n-    pub(crate) fn range(&self, db: &impl DescriptorDatabase, file_id: FileId) -> TextRange {\n-        let syntax = db._file_item(file_id, self.file_item_id);\n+    pub fn range(&self, db: &impl HirDatabase, file_id: FileId) -> TextRange {\n+        let source_item_id = SourceItemId {\n+            file_id,\n+            item_id: self.file_item_id,\n+        };\n+        let syntax = db.file_item(source_item_id);\n         let offset = syntax.borrowed().range().start();\n         self.relative_range + offset\n     }\n@@ -167,66 +112,14 @@ enum ImportKind {\n     Named(NamedImport),\n }\n \n-pub(crate) fn input_module_items(\n-    db: &impl DescriptorDatabase,\n-    source_root: SourceRootId,\n-    module_id: ModuleId,\n-) -> Cancelable<Arc<InputModuleItems>> {\n-    let module_tree = db._module_tree(source_root)?;\n-    let source = module_id.source(&module_tree);\n-    let file_items = db._file_items(source.file_id());\n-    let res = match source.resolve(db) {\n-        ModuleSourceNode::SourceFile(it) => {\n-            let items = it.borrowed().items();\n-            InputModuleItems::new(&file_items, items)\n-        }\n-        ModuleSourceNode::Module(it) => {\n-            let items = it\n-                .borrowed()\n-                .item_list()\n-                .into_iter()\n-                .flat_map(|it| it.items());\n-            InputModuleItems::new(&file_items, items)\n-        }\n-    };\n-    Ok(Arc::new(res))\n-}\n-\n-pub(crate) fn item_map(\n-    db: &impl DescriptorDatabase,\n-    source_root: SourceRootId,\n-) -> Cancelable<Arc<ItemMap>> {\n-    let start = Instant::now();\n-    let module_tree = db._module_tree(source_root)?;\n-    let input = module_tree\n-        .modules()\n-        .map(|id| {\n-            let items = db._input_module_items(source_root, id)?;\n-            Ok((id, items))\n-        })\n-        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n-    let mut resolver = Resolver {\n-        db: db,\n-        input: &input,\n-        source_root,\n-        module_tree,\n-        result: ItemMap::default(),\n-    };\n-    resolver.resolve()?;\n-    let res = resolver.result;\n-    let elapsed = start.elapsed();\n-    log::info!(\"item_map: {:?}\", elapsed);\n-    Ok(Arc::new(res))\n-}\n-\n /// Resolution is basically `DefId` atm, but it should account for stuff like\n /// multiple namespaces, ambiguity and errors.\n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Resolution {\n+pub struct Resolution {\n     /// None for unresolved\n-    pub(crate) def_id: Option<DefId>,\n+    pub def_id: Option<DefId>,\n     /// ident by whitch this is imported into local scope.\n-    pub(crate) import: Option<NamedImport>,\n+    pub import: Option<NamedImport>,\n }\n \n // #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -242,8 +135,8 @@ pub(crate) struct Resolution {\n // }\n \n impl InputModuleItems {\n-    fn new<'a>(\n-        file_items: &FileItems,\n+    pub(crate) fn new<'a>(\n+        file_items: &SourceFileItems,\n         items: impl Iterator<Item = ast::ModuleItem<'a>>,\n     ) -> InputModuleItems {\n         let mut res = InputModuleItems::default();\n@@ -253,7 +146,7 @@ impl InputModuleItems {\n         res\n     }\n \n-    fn add_item(&mut self, file_items: &FileItems, item: ast::ModuleItem) -> Option<()> {\n+    fn add_item(&mut self, file_items: &SourceFileItems, item: ast::ModuleItem) -> Option<()> {\n         match item {\n             ast::ModuleItem::StructDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n             ast::ModuleItem::EnumDef(it) => self.items.push(ModuleItem::new(file_items, it)?),\n@@ -274,7 +167,7 @@ impl InputModuleItems {\n         Some(())\n     }\n \n-    fn add_use_item(&mut self, file_items: &FileItems, item: ast::UseItem) {\n+    fn add_use_item(&mut self, file_items: &SourceFileItems, item: ast::UseItem) {\n         let file_item_id = file_items.id_of(item.syntax());\n         let start_offset = item.syntax().range().start();\n         Path::expand_use_item(item, |path, range| {\n@@ -291,7 +184,7 @@ impl InputModuleItems {\n }\n \n impl ModuleItem {\n-    fn new<'a>(file_items: &FileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n+    fn new<'a>(file_items: &SourceFileItems, item: impl ast::NameOwner<'a>) -> Option<ModuleItem> {\n         let name = item.name()?.text();\n         let kind = item.syntax().kind();\n         let vis = Vis::Other;\n@@ -306,28 +199,28 @@ impl ModuleItem {\n     }\n }\n \n-struct Resolver<'a, DB> {\n-    db: &'a DB,\n-    input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n-    source_root: SourceRootId,\n-    module_tree: Arc<ModuleTree>,\n-    result: ItemMap,\n+pub(crate) struct Resolver<'a, DB> {\n+    pub db: &'a DB,\n+    pub input: &'a FxHashMap<ModuleId, Arc<InputModuleItems>>,\n+    pub source_root: SourceRootId,\n+    pub module_tree: Arc<ModuleTree>,\n+    pub result: ItemMap,\n }\n \n impl<'a, DB> Resolver<'a, DB>\n where\n-    DB: DescriptorDatabase,\n+    DB: HirDatabase,\n {\n-    fn resolve(&mut self) -> Cancelable<()> {\n+    pub(crate) fn resolve(mut self) -> Cancelable<ItemMap> {\n         for (&module_id, items) in self.input.iter() {\n             self.populate_module(module_id, items)\n         }\n \n         for &module_id in self.input.keys() {\n-            crate::db::check_canceled(self.db)?;\n+            self.db.check_canceled()?;\n             self.resolve_imports(module_id);\n         }\n-        Ok(())\n+        Ok(self.result)\n     }\n \n     fn populate_module(&mut self, module_id: ModuleId, input: &InputModuleItems) {\n@@ -355,10 +248,12 @@ where\n                 continue;\n             }\n             let def_loc = DefLoc::Item {\n-                file_id,\n-                id: item.id,\n+                source_item_id: SourceItemId {\n+                    file_id,\n+                    item_id: item.id,\n+                },\n             };\n-            let def_id = self.db.id_maps().def_id(def_loc);\n+            let def_id = def_loc.id(self.db);\n             let resolution = Resolution {\n                 def_id: Some(def_id),\n                 import: None,\n@@ -371,7 +266,7 @@ where\n                 id: mod_id,\n                 source_root: self.source_root,\n             };\n-            let def_id = self.db.id_maps().def_id(def_loc);\n+            let def_id = def_loc.id(self.db);\n             let resolution = Resolution {\n                 def_id: Some(def_id),\n                 import: None,\n@@ -420,7 +315,7 @@ where\n             };\n \n             if !is_last {\n-                curr = match self.db.id_maps().def_loc(def_id) {\n+                curr = match def_id.loc(self.db) {\n                     DefLoc::Module { id, .. } => id,\n                     _ => return,\n                 }\n@@ -441,109 +336,3 @@ where\n         f(module_items)\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::{\n-        AnalysisChange,\n-        mock_analysis::{MockAnalysis, analysis_and_position},\n-        descriptors::{DescriptorDatabase, module::ModuleDescriptor},\n-        input::FilesDatabase,\n-};\n-    use super::*;\n-\n-    fn item_map(fixture: &str) -> (Arc<ItemMap>, ModuleId) {\n-        let (analysis, pos) = analysis_and_position(fixture);\n-        let db = analysis.imp.db;\n-        let source_root = db.file_source_root(pos.file_id);\n-        let descr = ModuleDescriptor::guess_from_position(&*db, pos)\n-            .unwrap()\n-            .unwrap();\n-        let module_id = descr.module_id;\n-        (db._item_map(source_root).unwrap(), module_id)\n-    }\n-\n-    #[test]\n-    fn test_item_map() {\n-        let (item_map, module_id) = item_map(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-            <|>\n-\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-        let name = SmolStr::from(\"Baz\");\n-        let resolution = &item_map.per_module[&module_id].items[&name];\n-        assert!(resolution.def_id.is_some());\n-    }\n-\n-    #[test]\n-    fn typing_inside_a_function_should_not_invalidate_item_map() {\n-        let mock_analysis = MockAnalysis::with_files(\n-            \"\n-            //- /lib.rs\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 {\n-                1 + 1\n-            }\n-            //- /foo/mod.rs\n-            pub mod bar;\n-\n-            //- /foo/bar.rs\n-            pub struct Baz;\n-        \",\n-        );\n-\n-        let file_id = mock_analysis.id_of(\"/lib.rs\");\n-        let mut host = mock_analysis.analysis_host();\n-\n-        let source_root = host.analysis().imp.db.file_source_root(file_id);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db._item_map(source_root).unwrap();\n-            });\n-            assert!(format!(\"{:?}\", events).contains(\"_item_map\"))\n-        }\n-\n-        let mut change = AnalysisChange::new();\n-\n-        change.change_file(\n-            file_id,\n-            \"\n-            mod foo;\n-\n-            use crate::foo::bar::Baz;\n-\n-            fn foo() -> i32 { 92 }\n-        \"\n-            .to_string(),\n-        );\n-\n-        host.apply_change(change);\n-\n-        {\n-            let db = host.analysis().imp.db;\n-            let events = db.log_executed(|| {\n-                db._item_map(source_root).unwrap();\n-            });\n-            assert!(\n-                !format!(\"{:?}\", events).contains(\"_item_map\"),\n-                \"{:#?}\",\n-                events\n-            )\n-        }\n-    }\n-}", "previous_filename": "crates/ra_analysis/src/descriptors/module/nameres.rs"}, {"sha": "4a2e427cd90b6a91eaee0c6fd2776189bf5651b4", "filename": "crates/ra_hir/src/path.rs", "status": "renamed", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fpath.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -1,13 +1,13 @@\n use ra_syntax::{SmolStr, ast, AstNode, TextRange};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(crate) struct Path {\n-    pub(crate) kind: PathKind,\n-    pub(crate) segments: Vec<SmolStr>,\n+pub struct Path {\n+    pub kind: PathKind,\n+    pub segments: Vec<SmolStr>,\n }\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n-pub(crate) enum PathKind {\n+pub enum PathKind {\n     Plain,\n     Self_,\n     Super,\n@@ -16,14 +16,14 @@ pub(crate) enum PathKind {\n \n impl Path {\n     /// Calls `cb` with all paths, represented by this use item.\n-    pub(crate) fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n+    pub fn expand_use_item(item: ast::UseItem, mut cb: impl FnMut(Path, Option<TextRange>)) {\n         if let Some(tree) = item.use_tree() {\n             expand_use_tree(None, tree, &mut cb);\n         }\n     }\n \n     /// Converts an `ast::Path` to `Path`. Works with use trees.\n-    pub(crate) fn from_ast(mut path: ast::Path) -> Option<Path> {\n+    pub fn from_ast(mut path: ast::Path) -> Option<Path> {\n         let mut kind = PathKind::Plain;\n         let mut segments = Vec::new();\n         loop {\n@@ -64,7 +64,7 @@ impl Path {\n     }\n \n     /// `true` is this path is a single identifier, like `foo`\n-    pub(crate) fn is_ident(&self) -> bool {\n+    pub fn is_ident(&self) -> bool {\n         self.kind == PathKind::Plain && self.segments.len() == 1\n     }\n }", "previous_filename": "crates/ra_analysis/src/descriptors/path.rs"}, {"sha": "6f602878c8d6b747a600525b6942b6ecb1428d1e", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -0,0 +1,154 @@\n+use std::{\n+    sync::Arc,\n+    time::Instant,\n+};\n+\n+use rustc_hash::FxHashMap;\n+use ra_syntax::{\n+    AstNode,  SyntaxNode, SmolStr,\n+    ast::{self, FnDef, FnDefNode, NameOwner, ModuleItemOwner}\n+};\n+use ra_db::{SourceRootId, FileId, Cancelable,};\n+\n+use crate::{\n+        FnId,\n+        SourceFileItems, SourceItemId,\n+        db::HirDatabase,\n+        function::FnScopes,\n+        module::{\n+            ModuleSource, ModuleSourceNode, ModuleId,\n+            imp::Submodule,\n+            nameres::{InputModuleItems, ItemMap, Resolver},\n+        },\n+};\n+\n+/// Resolve `FnId` to the corresponding `SyntaxNode`\n+pub(super) fn fn_syntax(db: &impl HirDatabase, fn_id: FnId) -> FnDefNode {\n+    let item_id = fn_id.loc(db);\n+    let syntax = db.file_item(item_id);\n+    FnDef::cast(syntax.borrowed()).unwrap().owned()\n+}\n+\n+pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n+    let syntax = db.fn_syntax(fn_id);\n+    let res = FnScopes::new(syntax.borrowed());\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n+    let source_file = db.source_file(file_id);\n+    let source_file = source_file.borrowed();\n+    let mut res = SourceFileItems::default();\n+    source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::ModuleItem::cast)\n+        .map(|it| it.syntax().owned())\n+        .for_each(|it| {\n+            res.alloc(it);\n+        });\n+    Arc::new(res)\n+}\n+\n+pub(super) fn file_item(db: &impl HirDatabase, source_item_id: SourceItemId) -> SyntaxNode {\n+    db.file_items(source_item_id.file_id)[source_item_id.item_id].clone()\n+}\n+\n+pub(crate) fn submodules(\n+    db: &impl HirDatabase,\n+    source: ModuleSource,\n+) -> Cancelable<Arc<Vec<Submodule>>> {\n+    db.check_canceled()?;\n+    let file_id = source.file_id();\n+    let submodules = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => collect_submodules(db, file_id, it.borrowed()),\n+        ModuleSourceNode::Module(it) => it\n+            .borrowed()\n+            .item_list()\n+            .map(|it| collect_submodules(db, file_id, it))\n+            .unwrap_or_else(Vec::new),\n+    };\n+    return Ok(Arc::new(submodules));\n+\n+    fn collect_submodules<'a>(\n+        db: &impl HirDatabase,\n+        file_id: FileId,\n+        root: impl ast::ModuleItemOwner<'a>,\n+    ) -> Vec<Submodule> {\n+        modules(root)\n+            .map(|(name, m)| {\n+                if m.has_semi() {\n+                    Submodule::Declaration(name)\n+                } else {\n+                    let src = ModuleSource::new_inline(db, file_id, m);\n+                    Submodule::Definition(name, src)\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+pub(crate) fn modules<'a>(\n+    root: impl ast::ModuleItemOwner<'a>,\n+) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.items()\n+        .filter_map(|item| match item {\n+            ast::ModuleItem::Module(m) => Some(m),\n+            _ => None,\n+        })\n+        .filter_map(|module| {\n+            let name = module.name()?.text();\n+            Some((name, module))\n+        })\n+}\n+\n+pub(super) fn input_module_items(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+    module_id: ModuleId,\n+) -> Cancelable<Arc<InputModuleItems>> {\n+    let module_tree = db.module_tree(source_root)?;\n+    let source = module_id.source(&module_tree);\n+    let file_items = db.file_items(source.file_id());\n+    let res = match source.resolve(db) {\n+        ModuleSourceNode::SourceFile(it) => {\n+            let items = it.borrowed().items();\n+            InputModuleItems::new(&file_items, items)\n+        }\n+        ModuleSourceNode::Module(it) => {\n+            let items = it\n+                .borrowed()\n+                .item_list()\n+                .into_iter()\n+                .flat_map(|it| it.items());\n+            InputModuleItems::new(&file_items, items)\n+        }\n+    };\n+    Ok(Arc::new(res))\n+}\n+\n+pub(super) fn item_map(\n+    db: &impl HirDatabase,\n+    source_root: SourceRootId,\n+) -> Cancelable<Arc<ItemMap>> {\n+    let start = Instant::now();\n+    let module_tree = db.module_tree(source_root)?;\n+    let input = module_tree\n+        .modules()\n+        .map(|id| {\n+            let items = db.input_module_items(source_root, id)?;\n+            Ok((id, items))\n+        })\n+        .collect::<Cancelable<FxHashMap<_, _>>>()?;\n+    let resolver = Resolver {\n+        db: db,\n+        input: &input,\n+        source_root,\n+        module_tree,\n+        result: ItemMap::default(),\n+    };\n+    let res = resolver.resolve()?;\n+    let elapsed = start.elapsed();\n+    log::info!(\"item_map: {:?}\", elapsed);\n+    Ok(Arc::new(res))\n+}"}, {"sha": "12faeb93afe7a2fa2f96de8f5c03aa8100b72dc0", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=95c0c8f3986c8b3bcf0052d34d3ace09ebb9fa1b", "patch": "@@ -140,7 +140,7 @@ impl ServerWorldState {\n         Ok(file_id)\n     }\n     pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n-        let mut crate_graph = CrateGraph::new();\n+        let mut crate_graph = CrateGraph::default();\n         ws.iter()\n             .flat_map(|ws| {\n                 ws.packages()"}]}