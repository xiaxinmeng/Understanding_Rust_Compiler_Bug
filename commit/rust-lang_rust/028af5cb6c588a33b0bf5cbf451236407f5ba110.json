{"sha": "028af5cb6c588a33b0bf5cbf451236407f5ba110", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOGFmNWNiNmM1ODhhMzNiMGJmNWNiZjQ1MTIzNjQwN2Y1YmExMTA=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-07T07:38:22Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-08T23:42:51Z"}, "message": "rt: Change the lifecycle of tasks and schedulers for various reasons\n\nThis is in preparation for giving schedulers their own life cycle separate\nfrom the kernel.\n\nTasks must be deleted before their scheduler thread, so we can't let the\nscheduler exit before all its tasks have been cleaned up. In this scheme,\nthe scheduler will unregister tasks with the kernel when they are reaped,\nthen drop their ref on the task (there may still be others). When the task\nref count hits zero, the task will request to be unregistered from the\nscheduler, which is responsible for deleting the task.\n\nInstead of having the kernel tell the scheduler to exit, let the scheduler\ndecide when to exit. For now it will exit when all of its tasks are\nunregistered.", "tree": {"sha": "611d6a90a411b1917d75994604784f9248c7433c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/611d6a90a411b1917d75994604784f9248c7433c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/028af5cb6c588a33b0bf5cbf451236407f5ba110", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/028af5cb6c588a33b0bf5cbf451236407f5ba110", "html_url": "https://github.com/rust-lang/rust/commit/028af5cb6c588a33b0bf5cbf451236407f5ba110", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/028af5cb6c588a33b0bf5cbf451236407f5ba110/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebc3646c39e2a24fe6eec778fb7ca5862d95acf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebc3646c39e2a24fe6eec778fb7ca5862d95acf7", "html_url": "https://github.com/rust-lang/rust/commit/ebc3646c39e2a24fe6eec778fb7ca5862d95acf7"}], "stats": {"total": 89, "additions": 66, "deletions": 23}, "files": [{"sha": "b6bd20fc98bd8758ecb5273ad42e5357657f6530", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -104,15 +104,14 @@ static size_t const BUF_BYTES = 2048;\n   void ref() { ++ref_count; } \\\n   void deref() { if (--ref_count == 0) { dtor; } }\n \n-#define RUST_ATOMIC_REFCOUNT()                                          \\\n-    private:                                                            \\\n-    intptr_t ref_count;                                                 \\\n-public:                                                                 \\\n- void ref() {                                                           \\\n-     intptr_t old = sync::increment(ref_count);                         \\\n-     assert(old > 0);                                                   \\\n- }                                                                      \\\n- void deref() { if(0 == sync::decrement(ref_count)) { delete this; } }\n+#define RUST_ATOMIC_REFCOUNT()                                            \\\n+public:                                                                   \\\n+   intptr_t ref_count;                                                    \\\n+   void ref() {                                                           \\\n+       intptr_t old = sync::increment(ref_count);                         \\\n+       assert(old > 0);                                                   \\\n+   }                                                                      \\\n+   void deref() { if(0 == sync::decrement(ref_count)) { delete_this(); } }\n \n template <typename T> struct task_owned {\n     inline void *operator new(size_t size, rust_task *task, const char *tag);"}, {"sha": "4517ec7b76664dac173fbecd821d5f3c5acc221c", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -129,11 +129,6 @@ rust_kernel::release_task_id(rust_task_id id) {\n         new_live_tasks = --live_tasks;\n     }\n     KLOG_(\"Total outstanding tasks: %d\", new_live_tasks);\n-    if (new_live_tasks == 0) {\n-        // There are no more tasks and there never will be.\n-        // Tell all the schedulers to exit.\n-        sched->exit();\n-    }\n }\n \n rust_task *"}, {"sha": "629df420bd1b91ee3e4a267e07743547f2d8f2d6", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -9,6 +9,7 @@ rust_scheduler::rust_scheduler(rust_kernel *kernel,\n     srv(srv),\n     env(srv->env),\n     live_threads(num_threads),\n+    live_tasks(0),\n     num_threads(num_threads),\n     id(id)\n {\n@@ -84,6 +85,7 @@ rust_scheduler::create_task(rust_task *spawner, const char *name,\n     {\n \tscoped_lock with(lock);\n \tthread_no = isaac_rand(&rctx) % num_threads;\n+\tlive_tasks++;\n     }\n     rust_task_thread *thread = threads[thread_no];\n     return thread->create_task(spawner, name, init_stack_sz);\n@@ -94,9 +96,28 @@ rust_scheduler::create_task(rust_task *spawner, const char *name) {\n     return create_task(spawner, name, env->min_stack_size);\n }\n \n+void\n+rust_scheduler::release_task() {\n+    bool need_exit = false;\n+    {\n+\tscoped_lock with(lock);\n+\tlive_tasks--;\n+\tif (live_tasks == 0) {\n+\t    need_exit = true;\n+\t}\n+    }\n+    if (need_exit) {\n+\t// There are no more tasks on this scheduler. Time to leave\n+\texit();\n+    }\n+}\n+\n void\n rust_scheduler::exit() {\n-    for(size_t i = 0; i < num_threads; ++i) {\n+    // Take a copy of num_threads. After the last thread exits this\n+    // scheduler will get destroyed, and our fields will cease to exist.\n+    size_t current_num_threads = num_threads;\n+    for(size_t i = 0; i < current_num_threads; ++i) {\n         threads[i]->exit();\n     }\n }"}, {"sha": "533f773ee35240ca5907152902236c318247e48e", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -14,6 +14,8 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n     lock_and_signal lock;\n     // When this hits zero we'll tell the kernel to release us\n     uintptr_t live_threads;\n+    // When this hits zero we'll tell the threads to exit\n+    uintptr_t live_tasks;\n     randctx rctx;\n \n     array_list<rust_task_thread *> threads;\n@@ -27,6 +29,8 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n     rust_task_thread *create_task_thread(int id);\n     void destroy_task_thread(rust_task_thread *thread);\n \n+    void exit();\n+\n public:\n     rust_scheduler(rust_kernel *kernel, rust_srv *srv, size_t num_threads,\n \t\t   rust_sched_id id);\n@@ -39,7 +43,8 @@ class rust_scheduler : public kernel_owned<rust_scheduler> {\n \t\t\t     size_t init_stack_sz);\n     rust_task_id create_task(rust_task *spawner, const char *name);\n \n-    void exit();\n+    void release_task();\n+\n     size_t number_of_threads();\n     // Called by each thread when it terminates. When all threads\n     // terminate the scheduler does as well."}, {"sha": "9443d4f37060265fa55fdce14064d76bf4084eb0", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -268,7 +268,8 @@ rust_task::rust_task(rust_task_thread *thread, rust_task_list *state,\n     }\n }\n \n-rust_task::~rust_task()\n+void\n+rust_task::delete_this()\n {\n     I(thread, !thread->lock.lock_held_by_current_thread());\n     I(thread, port_table.is_empty());\n@@ -291,6 +292,8 @@ rust_task::~rust_task()\n     while (stk != NULL) {\n         del_stk(this, stk);\n     }\n+\n+    thread->release_task(this);\n }\n \n struct spawn_args {"}, {"sha": "33e0da5af337a7b8cbe2ecaffb98eb3df2b1a079", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -122,15 +122,18 @@ rust_task : public kernel_owned<rust_task>, rust_cond\n     // The amount of stack we're using, excluding red zones\n     size_t total_stack_sz;\n \n+private:\n+    // Called when the atomic refcount reaches zero\n+    void delete_this();\n+public:\n+\n     // Only a pointer to 'name' is kept, so it must live as long as this task.\n     rust_task(rust_task_thread *thread,\n               rust_task_list *state,\n               rust_task *spawner,\n               const char *name,\n               size_t init_stack_sz);\n \n-    ~rust_task();\n-\n     void start(spawn_fn spawnee_fn,\n                rust_opaque_box *env,\n                void *args);"}, {"sha": "236eaaab98e75eb9c9dd918abea52b2c3dbc6982", "filename": "src/rt/rust_task_thread.cpp", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task_thread.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task_thread.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.cpp?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -136,16 +136,30 @@ rust_task_thread::reap_dead_tasks() {\n \n     for (size_t i = 0; i < dead_tasks_len; ++i) {\n         rust_task *task = dead_tasks_copy[i];\n-        if (task) {\n-            kernel->release_task_id(task->user.id);\n-            task->deref();\n-        }\n+        // Release the task from the kernel so nobody else can get at it\n+        kernel->release_task_id(task->user.id);\n+        // Deref the task, which may cause it to request us to release it\n+        task->deref();\n     }\n     srv->free(dead_tasks_copy);\n \n     lock.lock();\n }\n \n+void\n+rust_task_thread::release_task(rust_task *task) {\n+    // Nobody should have a ref to the task at this point\n+    I(this, task->ref_count == 0);\n+    // Kernel should not know about the task any more\n+    I(this, kernel->get_task_by_id(task->user.id) == NULL);\n+    // Now delete the task, which will require using this thread's\n+    // memory region.\n+    delete task;\n+    // Now release the task from the scheduler, which may trigger this\n+    // thread to exit\n+    sched->release_task();\n+}\n+\n /**\n  * Schedules a running task for execution. Only running tasks can be\n  * activated.  Blocked tasks have to be unblocked before they can be"}, {"sha": "541d95f6460567e68593560fe035983d574de6f1", "filename": "src/rt/rust_task_thread.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task_thread.h", "raw_url": "https://github.com/rust-lang/rust/raw/028af5cb6c588a33b0bf5cbf451236407f5ba110/src%2Frt%2Frust_task_thread.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task_thread.h?ref=028af5cb6c588a33b0bf5cbf451236407f5ba110", "patch": "@@ -122,6 +122,9 @@ struct rust_task_thread : public kernel_owned<rust_task_thread>,\n \n     static rust_task *get_task();\n \n+    // Called by each task when they are ready to be destroyed\n+    void release_task(rust_task *task);\n+\n     // Tells the scheduler to exit it's scheduling loop and thread\n     void exit();\n };"}]}